<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2805" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="39" left="337" height="834" width="763"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T2501" a="E"><vh>Edge sources</vh>
<v t="T2796"><vh>Importing the sources</vh></v>
<v t="T2502"><vh>The copyright notice</vh></v>
<v t="T2619"><vh>.DDF files</vh>
<v t="T2620"><vh>@file LINES.DDF</vh>
<v t="T2788"><vh>1 - 50</vh></v>
<v t="T2791"><vh>51 - 100</vh></v>
<v t="T2792"><vh>101 - 150</vh></v>
<v t="T2794"><vh>151 - 200</vh></v>
<v t="T2793"><vh>201 - 300</vh></v>
<v t="T2795"><vh>400 - 499</vh></v>
</v>
<v t="T2621"><vh>@file PLAYLIST.DDF</vh></v>
<v t="T2622"><vh>@file SECTORS.DDF</vh></v>
<v t="T2623"><vh>@file SOUNDS.DDF</vh></v>
<v t="T2624"><vh>@file SWITCH.DDF</vh></v>
<v t="T2625"><vh>@file THINGS.DDF</vh>
<v t="T2672"><vh>Health Items</vh>
<v t="T2673"><vh>HEALTH_POTION:2014</vh></v>
<v t="T2674"><vh>STIMPACK:2011</vh></v>
<v t="T2675"><vh>MEDIKIT:2012</vh></v>
<v t="T2676"><vh>SOULSPHERE:2013</vh></v>
<v t="T2677"><vh>BERSERKER:2023</vh></v>
<v t="T2678"><vh>MEGASPHERE:83</vh></v>
</v>
<v t="T2679"><vh>Armour Items</vh>
<v t="T2680"><vh>ARMOUR_HELMET:2015</vh></v>
<v t="T2681"><vh>GREEN_ARMOUR:2018</vh></v>
<v t="T2682"><vh>BLUE_ARMOUR:2019</vh></v>
</v>
<v t="T2683"><vh>Keys</vh>
<v t="T2684"><vh>BLUE_KEY:5</vh></v>
<v t="T2685"><vh>YELLOW_KEY:6</vh></v>
<v t="T2686"><vh>RED_KEY:13</vh></v>
<v t="T2687"><vh>RED_SKULLKEY:38</vh></v>
<v t="T2688"><vh>YELLOW_SKULLKEY:39</vh></v>
<v t="T2689"><vh>BLUE_SKULLKEY:40</vh></v>
</v>
<v t="T2690"><vh>Weapons</vh>
<v t="T2691"><vh>BFG:2006</vh></v>
<v t="T2692"><vh>CHAINGUN:2002</vh></v>
<v t="T2693"><vh>CHAINSAW:2005</vh></v>
<v t="T2694"><vh>MISSILE_LAUNCHER:2003</vh></v>
<v t="T2695"><vh>PLASMA_RIFLE:2004</vh></v>
<v t="T2696"><vh>SHOTGUN:2001</vh></v>
<v t="T2697"><vh>SUPER_SHOTGUN:8</vh></v>
</v>
<v t="T2698"><vh>Ammo</vh>
<v t="T2705"><vh>BOX_OF_BULLETS:2048</vh></v>
<v t="T2706"><vh>BOX_OF_ROCKETS:2046</vh></v>
<v t="T2707"><vh>BOX_OF_SHELLS:204</vh></v>
<v t="T2708"><vh>CELL_PACK:17</vh></v>
<v t="T2709"><vh>CELLS:2047</vh></v>
<v t="T2710"><vh>CLIP:2007</vh></v>
<v t="T2711"><vh>ROCKET:2010</vh></v>
<v t="T2712"><vh>SHELLS:2008</vh></v>
</v>
<v t="T2699"><vh>Specials</vh>
<v t="T2713"><vh>AUTOMAP:2026</vh></v>
<v t="T2714"><vh>BACKPACK:8</vh></v>
<v t="T2715"><vh>BLURSPHERE:2024</vh></v>
<v t="T2716"><vh>INVULNERABILITY_SPHERE:2022</vh></v>
<v t="T2717"><vh>LIGHT_SPECS:2045</vh></v>
<v t="T2718"><vh>RADIATION_SUIT:2025</vh></v>
</v>
<v t="T2700"><vh>EDGE Experimental Specials</vh>
<v t="T2719"><vh>NIGHTVISION_SPECS:7000</vh></v>
<v t="T2720"><vh>JETPACK:7020</vh></v>
</v>
<v t="T2701"><vh>Scenery Items</vh>
<v t="T2745"><vh>Barrels</vh>
<v t="T2746"><vh>BURNING_BARREL:70</vh></v>
<v t="T2747"><vh>BARREL:2035</vh></v>
<v t="T2748"><vh>UNSTABLE_BARREL:7104</vh></v>
</v>
<v t="T2761"><vh>Blokes</vh>
<v t="T2762"><vh>SKEWERED_BLOKE:25</vh></v>
</v>
<v t="T2749"><vh>Blood</vh>
<v t="T2750"><vh>POOL_OF_BLOOD:24</vh></v>
<v t="T2751"><vh>BLOOD</vh></v>
</v>
<v t="T2757"><vh>Columns</vh></v>
<v t="T2752"><vh>Dead characters</vh></v>
<v t="T2763"><vh>Effects</vh>
<v t="T2764"><vh>PUFF</vh></v>
<v t="T2765"><vh>ITEM_RESPAWN</vh></v>
<v t="T2766"><vh>TELEPORT_FLASH:14</vh></v>
<v t="T2767"><vh>RESPAWN_FLASH:7014</vh></v>
</v>
<v t="T2753"><vh>Heads, skulls &amp; body parts</vh>
<v t="T2754"><vh>EYE_SYMBOL:41</vh></v>
<v t="T2755"><vh>Brain stem &amp; Pool of blood</vh></v>
<v t="T2756"><vh>FLOATING_SKULLROCK:42</vh></v>
</v>
<v t="T2739"><vh>Light sources</vh>
<v t="T2758"><vh>Candels &amp; candelabra</vh></v>
<v t="T2740"><vh>Lamps</vh></v>
<v t="T2744"><vh>Torches</vh></v>
</v>
<v t="T2759"><vh>Trees &amp; stumps</vh>
<v t="T2760"><vh>BURNT_SPIKE_STUMP:7010</vh></v>
</v>
</v>
<v t="T2702"><vh>Creature Definitions</vh>
<v t="T2731"><vh>ARACHNOTRON:68</vh></v>
<v t="T2732"><vh>ARCHVILE:64</vh></v>
<v t="T2733"><vh>BARON_OF_HELL:3003</vh></v>
<v t="T2734"><vh>CACODEMON:3005</vh></v>
<v t="T2735"><vh>COMMANDER_KEEN:72</vh></v>
<v t="T2768"><vh>DEATHMATCH_START:11</vh></v>
<v t="T2737"><vh>DEMON:3002</vh></v>
<v t="T2738"><vh>HEAVY_WEAPON_DUDE:65</vh></v>
<v t="T2769"><vh>HELL_KNIGHT:69</vh></v>
<v t="T2770"><vh>IMP:3001</vh></v>
<v t="T2771"><vh>LOST_SOUL:3006</vh></v>
<v t="T2772"><vh>MANCUBUS:67</vh></v>
<v t="T2773"><vh>OUR_HERO:1</vh></v>
<v t="T2774"><vh>PAIN_ELEMENTAL:71</vh></v>
<v t="T2775"><vh>PLAYER2:2</vh></v>
<v t="T2776"><vh>PLAYER3:3</vh></v>
<v t="T2777"><vh>PLAYER4:4</vh></v>
<v t="T2778"><vh>PLAYER5:4001</vh></v>
<v t="T2779"><vh>PLAYER6:4002</vh></v>
<v t="T2780"><vh>PLAYER7:4003</vh></v>
<v t="T2781"><vh>PLAYER8:4004</vh></v>
<v t="T2782"><vh>REVENANT:66</vh></v>
<v t="T2783"><vh>SHOTGUN_GUY:9</vh></v>
<v t="T2784"><vh>SPECTRE:58</vh></v>
<v t="T2736"><vh>THE_CYBERDEMON:16</vh></v>
<v t="T2785"><vh>THE_SPIDER_MASTERMIND:7</vh></v>
<v t="T2786"><vh>WOLFENSTEIN_SS:84</vh></v>
<v t="T2787"><vh>ZOMBIEMAN:3004</vh></v>
</v>
<v t="T2703"><vh>BOSS BRAIN STUFF</vh>
<v t="T2704"><vh>&lt;&lt; New Experimental Creatures &gt;&gt;</vh></v>
</v>
</v>
<v t="T2626"><vh>@file WEAPONS.DDF</vh>
<v t="T2650"><vh>BFG9000</vh></v>
<v t="T2647"><vh>CHAINGUN</vh></v>
<v t="T2642"><vh>CHAINSAW</vh></v>
<v t="T2643"><vh>FIST</vh></v>
<v t="T2644"><vh>PISTOL</vh></v>
<v t="T2649"><vh>PLASMA_RIFLE</vh></v>
<v t="T2648"><vh>ROCKET_LAUNCHER</vh></v>
<v t="T2646"><vh>SHOTGUN</vh></v>
<v t="T2645"><vh>SUPERSHOTGUN</vh></v>
</v>
<v t="T2627"><vh>@file ANIMS.DDF</vh></v>
<v t="T2628"><vh>@file ATTACKS.DDF</vh>
<v t="T2632"><vh>ARACHNOTRON_PLASMA</vh></v>
<v t="T2633"><vh>ARCHVILE_FIRE</vh></v>
<v t="T2634"><vh>BARON_CLOSECOMBAT</vh></v>
<v t="T2635"><vh>BARON_FIREBALL</vh></v>
<v t="T2653"><vh>BFG9000_SPRAY</vh></v>
<v t="T2641"><vh>BOSSBRAIN STUFF</vh></v>
<v t="T2656"><vh>CACO_CLOSECOMBAT</vh></v>
<v t="T2651"><vh>CACO_FIREBALL</vh></v>
<v t="T2639"><vh>CYBERDEMON_MISSILE</vh></v>
<v t="T2657"><vh>DEMON_CLOSECOMBAT</vh></v>
<v t="T2659"><vh>ELEMENTAL_DEATHSPAWN</vh></v>
<v t="T2658"><vh>ELEMENTAL_SPAWNER</vh></v>
<v t="T2640"><vh>Experimental Stuff</vh></v>
<v t="T2660"><vh>FORMER_HUMAN_CHAINGUN</vh></v>
<v t="T2661"><vh>FORMER_HUMAN_PISTOL</vh></v>
<v t="T2662"><vh>FORMER_HUMAN_SHOTGUN</vh></v>
<v t="T2663"><vh>IMP_CLOSECOMBAT</vh></v>
<v t="T2636"><vh>IMP_FIREBALL</vh></v>
<v t="T2637"><vh>MANCUBUS_FIREBALL</vh></v>
<v t="T2654"><vh>PLAYER_BFG9000</vh></v>
<v t="T2667"><vh>PLAYER_CHAINGUN</vh></v>
<v t="T2638"><vh>PLAYER_MISSILE</vh></v>
<v t="T2664"><vh>PLAYER_PISTOL</vh></v>
<v t="T2652"><vh>PLAYER_PLASMA</vh></v>
<v t="T2669"><vh>PLAYER_PUNCH</vh></v>
<v t="T2668"><vh>PLAYER_SAW</vh></v>
<v t="T2665"><vh>PLAYER_SHOTGUN</vh></v>
<v t="T2666"><vh>PLAYER_SHOTGUN2</vh></v>
<v t="T2670"><vh>REVENANT_CLOSECOMBAT</vh></v>
<v t="T2655"><vh>REVENANT_MISSILE</vh></v>
<v t="T2671"><vh>SKULL_ASSAULT</vh></v>
</v>
<v t="T2629"><vh>@file COLMAP.DDF</vh></v>
<v t="T2630"><vh>@file GAMES.DDF</vh>
<v t="T2721"><vh>HELL_ON_EARTH</vh></v>
<v t="T2722"><vh>INFERNO</vh></v>
<v t="T2723"><vh>KNEE_DEEP_IN_THE_DEAD</vh></v>
<v t="T2724"><vh>THE_SHORES_OF_HELL</vh></v>
<v t="T2725"><vh>THY_FLESH_CONSUMED</vh></v>
</v>
<v t="T2631"><vh>@file LEVELS.DDF</vh>
<v t="T2726"><vh>HELL ON EARTH (DOOM 2)</vh></v>
<v t="T2727"><vh>INFERNO</vh></v>
<v t="T2728"><vh>KNEE_DEEP_IN_THE_DEAD</vh></v>
<v t="T2729"><vh>THE_SHORES_OF_HELL</vh></v>
<v t="T2730"><vh>THY_FLESH_CONSUMED</vh></v>
</v>
</v>
<v t="T2528"><vh>Headers</vh>
<v t="T2529"><vh>@file am_map.h</vh></v>
<v t="T2530"><vh>@file con_cvar.h</vh></v>
<v t="T2531"><vh>@file con_defs.h</vh></v>
<v t="T2532"><vh>@file con_main.h</vh></v>
<v t="T2533"><vh>@file ddf_locl.h</vh></v>
<v t="T2534"><vh>@file ddf_main.h</vh></v>
<v t="T2535"><vh>@file dm_data.h</vh></v>
<v t="T2536"><vh>@file dm_defs.h</vh></v>
<v t="T2537"><vh>@file dm_state.h</vh></v>
<v t="T2538"><vh>@file dm_type.h</vh></v>
<v t="T2539"><vh>@file dstrings.h</vh></v>
<v t="T2540"><vh>@file e_event.h</vh></v>
<v t="T2541"><vh>@file e_main.h</vh></v>
<v t="T2542"><vh>@file e_net.h</vh></v>
<v t="T2543"><vh>@file e_player.h</vh></v>
<v t="T2544"><vh>@file e_search.h</vh></v>
<v t="T2545"><vh>@file e_think.h</vh></v>
<v t="T2546"><vh>@file e_ticcmd.h</vh></v>
<v t="T2547"><vh>@file f_finale.h</vh></v>
<v t="T2548"><vh>@file g_game.h</vh></v>
<v t="T2549"><vh>@file gui_ctls.h</vh></v>
<v t="T2550"><vh>@file gui_gui.h</vh></v>
<v t="T2551"><vh>@file gui_main.h</vh></v>
<v t="T2552"><vh>@file hu_lib.h</vh></v>
<v t="T2553"><vh>@file hu_stuff.h</vh></v>
<v t="T2554"><vh>@file i_defs.h</vh></v>
<v t="T2555"><vh>@file i_system.h</vh></v>
<v t="T2556"><vh>@file l_epi.h</vh></v>
<v t="T2557"><vh>@file l_glbsp.h</vh></v>
<v t="T2558"><vh>@file l_mp3.h</vh></v>
<v t="T2559"><vh>@file lu_math.h</vh></v>
<v t="T2560"><vh>@file m_argv.h</vh></v>
<v t="T2561"><vh>@file m_bbox.h</vh></v>
<v t="T2562"><vh>@file m_cheat.h</vh></v>
<v t="T2563"><vh>@file m_fixed.h</vh></v>
<v t="T2564"><vh>@file m_inline.h</vh></v>
<v t="T2565"><vh>@file m_math.h</vh></v>
<v t="T2566"><vh>@file m_menu.h</vh></v>
<v t="T2567"><vh>@file m_misc.h</vh></v>
<v t="T2568"><vh>@file m_option.h</vh></v>
<v t="T2569"><vh>@file m_random.h</vh></v>
<v t="T2570"><vh>@file m_swap.h</vh></v>
<v t="T2571"><vh>@file p_action.h</vh></v>
<v t="T2572"><vh>@file p_bot.h</vh></v>
<v t="T2573"><vh>@file p_local.h</vh></v>
<v t="T2574"><vh>@file p_mobj.h</vh></v>
<v t="T2575"><vh>@file p_saveg.h</vh></v>
<v t="T2576"><vh>@file p_setup.h</vh></v>
<v t="T2577"><vh>@file p_spec.h</vh></v>
<v t="T2578"><vh>@file p_tick.h</vh></v>
<v t="T2579"><vh>@file p_weapon.h</vh></v>
<v t="T2580"><vh>@file r2_defs.h</vh></v>
<v t="T2581"><vh>@file r_bsp.h</vh></v>
<v t="T2582"><vh>@file r_data.h</vh></v>
<v t="T2583"><vh>@file r_defs.h</vh></v>
<v t="T2584"><vh>@file r_draw1.h</vh></v>
<v t="T2585"><vh>@file r_draw2.h</vh></v>
<v t="T2586"><vh>@file r_layers.h</vh></v>
<v t="T2587"><vh>@file r_local.h</vh></v>
<v t="T2588"><vh>@file r_main.h</vh></v>
<v t="T2589"><vh>@file r_plane.h</vh></v>
<v t="T2590"><vh>@file r_segs.h</vh></v>
<v t="T2591"><vh>@file r_sky.h</vh></v>
<v t="T2592"><vh>@file r_state.h</vh></v>
<v t="T2593"><vh>@file r_things.h</vh></v>
<v t="T2594"><vh>@file r_vbinit.h</vh></v>
<v t="T2595"><vh>@file r_view.h</vh></v>
<v t="T2596"><vh>@file rad_main.h</vh></v>
<v t="T2597"><vh>@file rad_trig.h</vh></v>
<v t="T2598"><vh>@file rgl_defs.h</vh></v>
<v t="T2599"><vh>@file s_sound.h</vh></v>
<v t="T2600"><vh>@file st_lib.h</vh></v>
<v t="T2601"><vh>@file v_ctx.h</vh></v>
<v t="T2602"><vh>@file st_stuff.h</vh></v>
<v t="T2603"><vh>@file sv_chunk.h</vh></v>
<v t="T2604"><vh>@file sv_main.h</vh></v>
<v t="T2605"><vh>@file v_colour.h</vh></v>
<v t="T2606"><vh>@file v_res.h</vh></v>
<v t="T2607"><vh>@file v_screen.h</vh></v>
<v t="T2608"><vh>@file v_toplev.h</vh></v>
<v t="T2609"><vh>@file v_video1.h</vh></v>
<v t="T2610"><vh>@file v_video2.h</vh></v>
<v t="T2611"><vh>@file version.h</vh></v>
<v t="T2612"><vh>@file w_image.h</vh></v>
<v t="T2613"><vh>@file w_textur.h</vh></v>
<v t="T2614"><vh>@file w_wad.h</vh></v>
<v t="T2615"><vh>@file wi_stuff.h</vh></v>
<v t="T2616"><vh>@file wp_main.h</vh></v>
<v t="T2617"><vh>@file z_zone.h</vh></v>
</v>
<v t="T2078" a="E"><vh>Main .c files</vh>
<v t="T2079"><vh>@file am_map.c (automap)</vh>
<v t="T2080"><vh>&lt;&lt; am_map #includes &gt;&gt;</vh></v>
<v t="T2081"><vh>&lt;&lt; am_map declarations &gt;&gt;</vh></v>
<v t="T2082"><vh>ActivateNewScale</vh></v>
<v t="T2083"><vh>SaveScaleAndLoc</vh></v>
<v t="T2084"><vh>RestoreScaleAndLoc</vh></v>
<v t="T2085"><vh>AddMark</vh></v>
<v t="T2086"><vh>FindMinMaxBoundaries</vh></v>
<v t="T2087"><vh>ChangeWindowLoc</vh></v>
<v t="T2088"><vh>InitVariables</vh></v>
<v t="T2089"><vh>LoadPics</vh></v>
<v t="T2090"><vh>ClearMarks</vh></v>
<v t="T2091"><vh>LevelInit</vh></v>
<v t="T2092"><vh>AM_Stop</vh></v>
<v t="T2093"><vh>StartAM</vh></v>
<v t="T2094"><vh>AM_InitResolution</vh></v>
<v t="T2095"><vh>AM_Hide</vh></v>
<v t="T2096"><vh>AM_Show</vh></v>
<v t="T2097"><vh>MinOutWindowScale</vh></v>
<v t="T2098"><vh>MaxOutWindowScale</vh></v>
<v t="T2099"><vh>AM_Responder</vh></v>
<v t="T2100"><vh>ChangeWindowScale</vh></v>
<v t="T2101"><vh>DoFollowPlayer</vh></v>
<v t="T2102"><vh>AM_Ticker</vh></v>
<v t="T2103"><vh>Rotate</vh></v>
<v t="T2104"><vh>GetRotatedCoords</vh></v>
<v t="T2105"><vh>GetRotatedAngle</vh></v>
<v t="T2106"><vh>DrawMline</vh></v>
<v t="T2107"><vh>DrawGrid</vh></v>
<v t="T2108"><vh>CheckSimiliarRegions</vh></v>
<v t="T2109"><vh>AM_WalkSeg</vh></v>
<v t="T2110"><vh>DEBUG_ShowSubSecs</vh></v>
<v t="T2111"><vh>DrawLineCharacter</vh></v>
<v t="T2112"><vh>AM_DrawPlayer</vh></v>
<v t="T2113"><vh>AM_WalkThing</vh></v>
<v t="T2114"><vh>AM_WalkSubsector</vh></v>
<v t="T2115"><vh>AM_CheckBBox</vh></v>
<v t="T2116"><vh>AM_WalkBSPNode</vh></v>
<v t="T2117"><vh>DrawMarks</vh></v>
<v t="T2118"><vh>DrawCrosshair</vh></v>
<v t="T2119"><vh>AM_RenderScene</vh></v>
<v t="T2120"><vh>AM_Drawer</vh></v>
</v>
<v t="T2525"><vh>con_*.c (console)</vh>
<v t="T2121"><vh>@file con_con.c</vh>
<v t="T2122"><vh>&lt;&lt; con_con #includes &gt;&gt;</vh></v>
<v t="T2123"><vh>&lt;&lt; con_con declarations &gt;&gt;</vh></v>
<v t="T2124"><vh>MaxTextLen_gfx</vh></v>
<v t="T2125"><vh>MaxTextLen_text</vh></v>
<v t="T2126"><vh>AddLine</vh></v>
<v t="T2127"><vh>GrowLine</vh></v>
<v t="T2128"><vh>AddSplitRow</vh></v>
<v t="T2129"><vh>UpdateNumvislines</vh></v>
<v t="T2130"><vh>AddConsoleLine</vh></v>
<v t="T2131"><vh>UpdateCmdLine</vh></v>
<v t="T2132"><vh>UpdateLastLine</vh></v>
<v t="T2133"><vh>AddCommandToHistory</vh></v>
<v t="T2134"><vh>UpdateConsole</vh></v>
<v t="T2135"><vh>NeedConsoleUpdate</vh></v>
<v t="T2136"><vh>CON_InitConsole</vh></v>
<v t="T2137"><vh>CON_SetVisible</vh></v>
<v t="T2138"><vh>PrintString</vh></v>
<v t="T2139"><vh>CON_Printf</vh></v>
<v t="T2140"><vh>CON_MessageLDF</vh></v>
<v t="T2141"><vh>CON_Message</vh></v>
<v t="T2142"><vh>CON_Ticker</vh></v>
<v t="T2143"><vh>WriteText</vh></v>
<v t="T2144"><vh>CON_Drawer</vh></v>
<v t="T2145"><vh>ToggleConsole</vh></v>
<v t="T2146"><vh>TabComplete</vh></v>
<v t="T2147"><vh>AddTabCommand</vh></v>
<v t="T2148"><vh>RemoveTabCommand</vh></v>
<v t="T2149"><vh>CON_HandleKey</vh></v>
<v t="T2150"><vh>CON_Responder</vh></v>
<v t="T2151"><vh>CON_InitResolution</vh></v>
<v t="T2152"><vh>UpdateConback</vh></v>
<v t="T2153"><vh>CON_Start</vh></v>
</v>
<v t="T2154"><vh>@file con_cvar.c</vh>
<v t="T2155"><vh>&lt;&lt; con_cvar #includes &gt;&gt;</vh></v>
<v t="T2156"><vh>&lt;&lt; con_cvar declarations &gt;&gt;</vh></v>
<v t="T2157"><vh>GetValue_Val</vh></v>
<v t="T2158"><vh>KillValue_Val</vh></v>
<v t="T2159"><vh>GetValueStr_Enum</vh></v>
<v t="T2160"><vh>GetValue_Enum</vh></v>
<v t="T2161"><vh>SetValue_Enum</vh></v>
<v t="T2162"><vh>KillValue_Enum</vh></v>
<v t="T2163"><vh>GetType_Enum</vh></v>
<v t="T2164"><vh>CON_AddValueToEnum</vh></v>
<v t="T2165"><vh>GetValueStr_Bool</vh></v>
<v t="T2166"><vh>SetValue_Bool</vh></v>
<v t="T2167"><vh>GetType_Bool</vh></v>
<v t="T2168"><vh>GetValueStr_Real</vh></v>
<v t="T2169"><vh>SetValue_Real</vh></v>
<v t="T2170"><vh>GetType_Real</vh></v>
<v t="T2171"><vh>GetValueStr_Str</vh></v>
<v t="T2172"><vh>GetValue_Str</vh></v>
<v t="T2173"><vh>SetValue_Str</vh></v>
<v t="T2174"><vh>KillValue_Str</vh></v>
<v t="T2175"><vh>GetType_Str</vh></v>
<v t="T2176"><vh>GetValueStr_Int</vh></v>
<v t="T2177"><vh>SetValue_Int</vh></v>
<v t="T2178"><vh>GetType_Int</vh></v>
<v t="T2179"><vh>GetType_Callback</vh></v>
<v t="T2180"><vh>GetValueStr_Callback</vh></v>
<v t="T2181"><vh>GetValue_Callback</vh></v>
<v t="T2182"><vh>SetValue_Callback</vh></v>
<v t="T2183"><vh>KillValue_Callback</vh></v>
<v t="T2184"><vh>CON_CVarIndexFromName</vh></v>
<v t="T2185"><vh>CON_CVarPtrFromName</vh></v>
<v t="T2186"><vh>CON_CVarGetValue</vh></v>
<v t="T2187"><vh>CON_GetCVar</vh></v>
<v t="T2188"><vh>CON_CreateCVar</vh></v>
<v t="T2189"><vh>CON_SetCVar</vh></v>
<v t="T2190"><vh>CON_DeleteCVar</vh></v>
<v t="T2191"><vh>CON_CreateCVarBool</vh></v>
<v t="T2192"><vh>CON_CreateCVarInt</vh></v>
<v t="T2193"><vh>CON_CreateCVarReal</vh></v>
<v t="T2194"><vh>CON_CreateCVarStr</vh></v>
<v t="T2195"><vh>CON_CreateCVarEnum</vh></v>
<v t="T2196"><vh>CON_AddCVarCallback</vh></v>
<v t="T2197"><vh>UpdateFunctionList</vh></v>
<v t="T2198"><vh>CON_ChooseFunctionFromList</vh></v>
<v t="T2199"><vh>CON_InitFunctionList</vh></v>
<v t="T2200"><vh>CON_SetFunclistDest</vh></v>
<v t="T2201"><vh>CON_AddFunctionToList</vh></v>
</v>
<v t="T2202"><vh>@file con_main.c</vh>
<v t="T2203"><vh>&lt;&lt; con_main #includes &gt;&gt;</vh></v>
<v t="T2204"><vh>&lt;&lt; con_main declarations &gt;&gt;</vh></v>
<v t="T2205"><vh>GetArgs</vh></v>
<v t="T2206"><vh>KillArgs</vh></v>
<v t="T2207"><vh>CON_TryCommand</vh></v>
<v t="T2208"><vh>CON_CMDToggleMouse</vh></v>
<v t="T2209"><vh>CON_CMDHelloWorldResponder</vh></v>
<v t="T2210"><vh>CON_CMDHelloWorld</vh></v>
<v t="T2211"><vh>CON_CMDExec</vh></v>
<v t="T2212"><vh>CON_CMDType</vh></v>
<v t="T2213"><vh>CON_CMDArgText</vh></v>
<v t="T2214"><vh>CON_CMDEat</vh></v>
<v t="T2215"><vh>CON_CMDLeakInfo</vh></v>
<v t="T2216"><vh>CON_CMDSet</vh></v>
<v t="T2217"><vh>CON_CMDTypeOf</vh></v>
<v t="T2218"><vh>CON_CMDWatch</vh></v>
<v t="T2219"><vh>CON_CMDQuitEDGE</vh></v>
<v t="T2220"><vh>CON_CMDCrc</vh></v>
<v t="T2221"><vh>CON_CMDPlaySound</vh></v>
<v t="T2222"><vh>CON_PlayerMessage</vh></v>
<v t="T2223"><vh>CON_PlayerMessageLDF</vh></v>
</v>
</v>
<v t="T2521"><vh>ddf_*.c (data definition file)</vh>
<v t="T2224"><vh>@file ddf_anim.c</vh>
<v t="T2225"><vh>&lt;&lt; ddf_anim #includes &gt;&gt;</vh></v>
<v t="T2226"><vh>&lt;&lt; ddf_anim declarations &gt;&gt;</vh></v>
<v t="T2227"><vh>AnimStartEntry</vh></v>
<v t="T2228"><vh>AnimParseField</vh></v>
<v t="T2229"><vh>AnimFinishEntry</vh></v>
<v t="T2230"><vh>AnimClearAll</vh></v>
<v t="T2231"><vh>DDF_ReadAnims</vh></v>
<v t="T2232"><vh>DDF_AnimInit</vh></v>
<v t="T2233"><vh>DDF_AnimCleanUp</vh></v>
<v t="T2234"><vh>DDF_AnimGetType</vh></v>
</v>
<v t="T2235"><vh>@file ddf_atk.c</vh>
<v t="T2236"><vh>&lt;&lt; ddf_atk #includes &gt;&gt;</vh></v>
<v t="T2237"><vh>&lt;&lt; ddf_atk declarations &gt;&gt;</vh></v>
<v t="T2238"><vh>AttackStartEntry</vh></v>
<v t="T2239"><vh>AttackParseField</vh></v>
<v t="T2240"><vh>AttackFinishEntry</vh></v>
<v t="T2241"><vh>AttackClearAll</vh></v>
<v t="T2242"><vh>DDF_ReadAtks</vh></v>
<v t="T2243"><vh>DDF_AttackInit</vh></v>
<v t="T2244"><vh>DDF_AttackCleanUp</vh></v>
<v t="T2245"><vh>DDF_AtkGetSpecial</vh></v>
<v t="T2246"><vh>DDF_AtkGetType</vh></v>
<v t="T2247"><vh>DDF_AtkGetLabel</vh></v>
<v t="T2248"><vh>DDF_AttackLookup</vh></v>
</v>
<v t="T2249"><vh>@file ddf_boom.c</vh>
<v t="T2250"><vh>&lt;&lt; ddf_boom #includes &gt;&gt;</vh></v>
<v t="T2251"><vh>DDF_BoomMakeGenSector</vh></v>
<v t="T2252"><vh>HandleLineTrigger</vh></v>
<v t="T2253"><vh>MakeBoomFloor</vh></v>
<v t="T2254"><vh>MakeBoomCeiling</vh></v>
<v t="T2255"><vh>MakeBoomDoor</vh></v>
<v t="T2256"><vh>MakeBoomLockedDoor</vh></v>
<v t="T2257"><vh>MakeBoomLift</vh></v>
<v t="T2258"><vh>MakeBoomStair</vh></v>
<v t="T2259"><vh>MakeBoomCrusher</vh></v>
<v t="T2260"><vh>DDF_BoomMakeGenLine</vh></v>
</v>
<v t="T2261"><vh>@file ddf_colm.c</vh>
<v t="T2262"><vh>&lt;&lt; ddf_colm #includes &gt;&gt;</vh></v>
<v t="T2263"><vh>&lt;&lt; ddf_colm declarations &gt;&gt;</vh></v>
<v t="T2264"><vh>ColmapStartEntry</vh></v>
<v t="T2265"><vh>ColmapParseField</vh></v>
<v t="T2266"><vh>ColmapFinishEntry</vh></v>
<v t="T2267"><vh>ColmapClearAll</vh></v>
<v t="T2268"><vh>DDF_ReadColourMaps</vh></v>
<v t="T2269"><vh>DDF_ColmapInit</vh></v>
<v t="T2270"><vh>DDF_ColmapCleanUp</vh></v>
<v t="T2271"><vh>DDF_ColmapLookup</vh></v>
<v t="T2272"><vh>DDF_ColmapGetSpecial</vh></v>
</v>
<v t="T2273"><vh>@file ddf_game.c</vh>
<v t="T2274"><vh>&lt;&lt; ddf_game #includes &gt;&gt;</vh></v>
<v t="T2275"><vh>&lt;&lt; ddf_game declarations &gt;&gt;</vh></v>
<v t="T2276"><vh>GameStartEntry</vh></v>
<v t="T2277"><vh>GameParseField</vh></v>
<v t="T2278"><vh>GameFinishEntry</vh></v>
<v t="T2279"><vh>GameClearAll</vh></v>
<v t="T2280"><vh>DDF_ReadGames</vh></v>
<v t="T2281"><vh>DDF_GameInit</vh></v>
<v t="T2282"><vh>DDF_GameCleanUp</vh></v>
<v t="T2283"><vh>DDF_GameAddFrame</vh></v>
<v t="T2284"><vh>DDF_GameAddAnim</vh></v>
<v t="T2285"><vh>DDF_GameGetFrames</vh></v>
<v t="T2286"><vh>DDF_GameGetMap</vh></v>
<v t="T2287"><vh>DDF_GameGetPic</vh></v>
<v t="T2288"><vh>DDF_GameLookup</vh></v>
</v>
<v t="T2289"><vh>@file ddf_lang.c</vh>
<v t="T2290"><vh>&lt;&lt; ddf_lang #includes &gt;&gt;</vh></v>
<v t="T2291"><vh>&lt;&lt; ddf_lang declarations &gt;&gt;</vh></v>
<v t="T2292"><vh>LanguageStartEntry</vh></v>
<v t="T2293"><vh>LanguageParseField</vh></v>
<v t="T2294"><vh>LanguageFinishEntry</vh></v>
<v t="T2295"><vh>LanguageClearAll</vh></v>
<v t="T2296"><vh>DDF_ReadLangs</vh></v>
<v t="T2297"><vh>DDF_LanguageInit</vh></v>
<v t="T2298"><vh>DDF_LanguageCleanUp</vh></v>
<v t="T2299"><vh>FindLanguageRef</vh></v>
<v t="T2300"><vh>DDF_LanguageLookup</vh></v>
<v t="T2301"><vh>DDF_LanguageValidRef</vh></v>
<v t="T2302"><vh>DDF_LanguageAddRef</vh></v>
</v>
<v t="T2303"><vh>@file ddf_levl.c</vh>
<v t="T2304"><vh>&lt;&lt; ddf_levl #includes &gt;&gt;</vh></v>
<v t="T2305"><vh>&lt;&lt; ddf_levl declarations &gt;&gt;</vh></v>
<v t="T2306"><vh>LevelStartEntry</vh></v>
<v t="T2307"><vh>LevelParseField</vh></v>
<v t="T2308"><vh>LevelFinishEntry</vh></v>
<v t="T2309"><vh>LevelClearAll</vh></v>
<v t="T2310"><vh>DDF_ReadLevels</vh></v>
<v t="T2311"><vh>DDF_LevelInit</vh></v>
<v t="T2312"><vh>DDF_LevelCleanUp</vh></v>
<v t="T2313"><vh>DDF_LevelMapLookup</vh></v>
<v t="T2314"><vh>DDF_LevelGetPic</vh></v>
<v t="T2315"><vh>DDF_LevelGetSpecials</vh></v>
<v t="T2316"><vh>DDF_LevelGetLighting</vh></v>
<v t="T2317"><vh>DDF_LevelGetWistyle</vh></v>
</v>
<v t="T2318"><vh>@file ddf_line.c</vh>
<v t="T2319"><vh>&lt;&lt; ddf_line #includes &gt;&gt;</vh></v>
<v t="T2320"><vh>&lt;&lt; ddf_line declarations &gt;&gt;</vh></v>
<v t="T2321"><vh>LinedefStartEntry</vh></v>
<v t="T2322"><vh>LinedefParseField</vh></v>
<v t="T2323"><vh>LinedefFinishEntry</vh></v>
<v t="T2324"><vh>LinedefClearAll</vh></v>
<v t="T2325"><vh>DDF_ReadLines</vh></v>
<v t="T2326"><vh>DDF_LinedefInit</vh></v>
<v t="T2327"><vh>DDF_LinedefCleanUp</vh></v>
<v t="T2328"><vh>DDF_LineGetScroller</vh></v>
<v t="T2329"><vh>DDF_LineGetSecurity</vh></v>
<v t="T2330"><vh>DDF_LineGetTrigType</vh></v>
<v t="T2331"><vh>DDF_LineGetActivators</vh></v>
<v t="T2332"><vh>DDF_LineGetExtraFloor</vh></v>
<v t="T2333"><vh>DDF_LineGetEFControl</vh></v>
<v t="T2334"><vh>DDF_LineGetTeleportSpecial</vh></v>
<v t="T2335"><vh>DDF_LineGetScrollPart</vh></v>
<v t="T2336"><vh>DDF_LineLookupGeneralised</vh></v>
<v t="T2337"><vh>DDF_LineClearGeneralised</vh></v>
<v t="T2338"><vh>DDF_LineLookupNum</vh></v>
<v t="T2339"><vh>DDF_LineGetSpecialFlags</vh></v>
<v t="T2340"><vh>DDF_LineGetRadTrig</vh></v>
<v t="T2341"><vh>DDF_LineGetSlideType</vh></v>
<v t="T2342"><vh>DDF_LineGetSkyType</vh></v>
<v t="T2343"><vh>DDF_LineGetLineEffect</vh></v>
<v t="T2344"><vh>DDF_LineGetSectorEffect</vh></v>
</v>
<v t="T2345"><vh>@file ddf_main.c</vh>
<v t="T2346"><vh>&lt;&lt; ddf_main #includes &gt;&gt;</vh></v>
<v t="T2347"><vh>&lt;&lt; ddf_main declarations &gt;&gt;</vh></v>
<v t="T2348"><vh>DDF_Error</vh></v>
<v t="T2349"><vh>DDF_Warning</vh></v>
<v t="T2350"><vh>DDF_WarnError</vh></v>
<v t="T2351"><vh>DDF_ErrorSetFilename</vh></v>
<v t="T2352"><vh>DDF_ErrorClearFilename</vh></v>
<v t="T2353"><vh>DDF_ErrorSetEntryName</vh></v>
<v t="T2354"><vh>DDF_ErrorClearEntryName</vh></v>
<v t="T2355"><vh>DDF_ErrorSetLineData</vh></v>
<v t="T2356"><vh>DDF_ErrorClearLineData</vh></v>
<v t="T2357"><vh>DDF_MainInit</vh></v>
<v t="T2358"><vh>DDF_MainAddDefine</vh></v>
<v t="T2359"><vh>DDF_MainGetDefine</vh></v>
<v t="T2360"><vh>DDF_MainCleanUp</vh></v>
<v t="T2361"><vh>DDF_MainCacheFile</vh></v>
<v t="T2362"><vh>DDF_MainReadFile</vh></v>
<v t="T2363"><vh>DDF_MainProcessChar</vh></v>
<v t="T2364"><vh>DDF_MainGetNumeric</vh></v>
<v t="T2365"><vh>DDF_MainGetBoolean</vh></v>
<v t="T2366"><vh>DDF_MainGetString</vh></v>
<v t="T2367"><vh>DDF_MainParseSubField</vh></v>
<v t="T2368"><vh>DDF_MainParseField</vh></v>
<v t="T2369"><vh>DDF_MainGetInlineStr10</vh></v>
<v t="T2370"><vh>DDF_MainGetInlineStr32</vh></v>
<v t="T2371"><vh>DDF_MainRefAttack</vh></v>
<v t="T2372"><vh>DDF_MainLookupDirector</vh></v>
<v t="T2373"><vh>DDF_MainGetFloat</vh></v>
<v t="T2374"><vh>DDF_MainGetAngle</vh></v>
<v t="T2375"><vh>DDF_MainGetSlope</vh></v>
<v t="T2376"><vh>DDF_MainGetPercent</vh></v>
<v t="T2377"><vh>DDF_MainGetPercentAny</vh></v>
<v t="T2378"><vh>DDF_MainGetTime</vh></v>
<v t="T2379"><vh>DDF_DummyFunction</vh></v>
<v t="T2380"><vh>DDF_MainGetColourmap</vh></v>
<v t="T2381"><vh>DDF_MainGetRGB</vh></v>
<v t="T2382"><vh>DDF_MainGetWhenAppear</vh></v>
<v t="T2383"><vh>DDF_MainGetBitSet</vh></v>
<v t="T2384"><vh>FindSpecialFlag</vh></v>
<v t="T2385"><vh>DDF_MainCheckSpecialFlag</vh></v>
<v t="T2386"><vh>DDF_MainCreateUniqueName</vh></v>
</v>
<v t="T2387"><vh>@file ddf_mobj.c</vh>
<v t="T2388"><vh>&lt;&lt; ddf_mobj #includes &gt;&gt;</vh></v>
<v t="T2389"><vh>&lt;&lt; ddf_mobj declarations &gt;&gt;</vh></v>
<v t="T2390"><vh>DDF_CompareName</vh></v>
<v t="T2391"><vh>ThingTryParseState</vh></v>
<v t="T2392"><vh>ThingStartEntry</vh></v>
<v t="T2393"><vh>ThingParseField</vh></v>
<v t="T2394"><vh>ThingFinishEntry</vh></v>
<v t="T2395"><vh>ThingClearAll</vh></v>
<v t="T2396"><vh>DDF_ReadThings</vh></v>
<v t="T2397"><vh>DDF_MobjInit</vh></v>
<v t="T2398"><vh>DDF_MobjCleanUp</vh></v>
<v t="T2399"><vh>DDF_MobjLookup</vh></v>
<v t="T2400"><vh>DDF_MobjLookupNum</vh></v>
<v t="T2401"><vh>DDF_MobjLookupCast</vh></v>
<v t="T2402"><vh>ParseBenefitString</vh></v>
<v t="T2403"><vh>BenefitTryAmmo</vh></v>
<v t="T2404"><vh>BenefitTryAmmoLimit</vh></v>
<v t="T2405"><vh>BenefitTryWeapon</vh></v>
<v t="T2406"><vh>BenefitTryKey</vh></v>
<v t="T2407"><vh>BenefitTryHealth</vh></v>
<v t="T2408"><vh>BenefitTryArmour</vh></v>
<v t="T2409"><vh>BenefitTryPowerup</vh></v>
<v t="T2410"><vh>BenefitAdd</vh></v>
<v t="T2411"><vh>DDF_MobjGetBenefit</vh></v>
<v t="T2412"><vh>DDF_MobjGetSpecial</vh></v>
<v t="T2413"><vh>DDF_MobjGetDLight</vh></v>
<v t="T2414"><vh>DDF_MobjGetExtra</vh></v>
<v t="T2415"><vh>DDF_MobjGetPlayer</vh></v>
<v t="T2416"><vh>DDF_MobjMakeAttackObj</vh></v>
<v t="T2417"><vh>DDF_MobjLookupPlayer</vh></v>
<v t="T2418"><vh>ConditionTryAmmo</vh></v>
<v t="T2419"><vh>ConditionTryWeapon</vh></v>
<v t="T2420"><vh>ConditionTryKey</vh></v>
<v t="T2421"><vh>ConditionTryHealth</vh></v>
<v t="T2422"><vh>ConditionTryArmour</vh></v>
<v t="T2423"><vh>ConditionTryPowerup</vh></v>
<v t="T2424"><vh>ConditionTryPlayerState</vh></v>
<v t="T2425"><vh>DDF_MainParseCondition</vh></v>
</v>
<v t="T2426"><vh>@file ddf_mus.c</vh>
<v t="T2427"><vh>&lt;&lt; ddf_mus #includes &gt;&gt;</vh></v>
<v t="T2428"><vh>&lt;&lt; ddf_mus declarations &gt;&gt;</vh></v>
<v t="T2429"><vh>DDF_MusicParseInfo</vh></v>
<v t="T2430"><vh>PlaylistStartEntry</vh></v>
<v t="T2431"><vh>PlaylistParseField</vh></v>
<v t="T2432"><vh>PlaylistFinishEntry</vh></v>
<v t="T2433"><vh>PlaylistClearAll</vh></v>
<v t="T2434"><vh>DDF_ReadMusicPlaylist</vh></v>
<v t="T2435"><vh>DDF_MusicPlaylistInit</vh></v>
<v t="T2436"><vh>DDF_MusicPlaylistCleanUp</vh></v>
<v t="T2437"><vh>DDF_MusicLookupNum</vh></v>
</v>
<v t="T2438"><vh>@file ddf_sect.c</vh>
<v t="T2439"><vh>&lt;&lt; ddf_sect #includes &gt;&gt;</vh></v>
<v t="T2440"><vh>&lt;&lt; ddf_sect declarations &gt;&gt;</vh></v>
<v t="T2441"><vh>SectorStartEntry</vh></v>
<v t="T2442"><vh>SectorParseField</vh></v>
<v t="T2443"><vh>SectorFinishEntry</vh></v>
<v t="T2444"><vh>SectorClearAll</vh></v>
<v t="T2445"><vh>DDF_ReadSectors</vh></v>
<v t="T2446"><vh>DDF_SectorInit</vh></v>
<v t="T2447"><vh>DDF_SectorCleanUp</vh></v>
<v t="T2448"><vh>DDF_SectorLookupGeneralised</vh></v>
<v t="T2449"><vh>DDF_SectorClearGeneralised</vh></v>
<v t="T2450"><vh>DDF_SectorLookupNum</vh></v>
<v t="T2451"><vh>DDF_SectGetSpecialFlags</vh></v>
<v t="T2452"><vh>DDF_SectGetExit</vh></v>
<v t="T2453"><vh>DDF_SectGetLighttype</vh></v>
<v t="T2454"><vh>DDF_SectGetMType</vh></v>
<v t="T2455"><vh>DDF_SectGetDestRef</vh></v>
</v>
<v t="T2456"><vh>@file ddf_sfx.c</vh>
<v t="T2457"><vh>&lt;&lt; ddf_sfx #includes &gt;&gt;</vh></v>
<v t="T2458"><vh>&lt;&lt; ddf_sfx declarations &gt;&gt;</vh></v>
<v t="T2459"><vh>SoundStartEntry</vh></v>
<v t="T2460"><vh>SoundParseField</vh></v>
<v t="T2461"><vh>SoundFinishEntry</vh></v>
<v t="T2462"><vh>SoundClearAll</vh></v>
<v t="T2463"><vh>DDF_ReadSFX</vh></v>
<v t="T2464"><vh>DDF_SFXInit</vh></v>
<v t="T2465"><vh>DDF_SFXCleanUp</vh></v>
<v t="T2466"><vh>DDF_SfxLookupSound</vh></v>
<v t="T2467"><vh>DDF_MainLookupSound</vh></v>
<v t="T2468"><vh>DDF_SfxSelect</vh></v>
</v>
<v t="T2469"><vh>@file ddf_stat.c</vh>
<v t="T2470"><vh>&lt;&lt; ddf_stat #includes &gt;&gt;</vh></v>
<v t="T2471"><vh>&lt;&lt; ddf_stat declarations &gt;&gt;</vh></v>
<v t="T2472"><vh>DDF_StateInit</vh></v>
<v t="T2473"><vh>DDF_StateCleanUp</vh></v>
<v t="T2474"><vh>DDF_MainSplitIntoState</vh></v>
<v t="T2475"><vh>DestroyStateInfo</vh></v>
<v t="T2476"><vh>DDF_MainSplitActionArg</vh></v>
<v t="T2477"><vh>StateGetRedirector</vh></v>
<v t="T2478"><vh>StateFindLabel</vh></v>
<v t="T2479"><vh>DDF_StateReadState</vh></v>
<v t="T2480"><vh>DDF_StateFinishStates</vh></v>
<v t="T2481"><vh>DDF_StateGetAttack</vh></v>
<v t="T2482"><vh>DDF_StateGetMobj</vh></v>
<v t="T2483"><vh>DDF_StateGetSound</vh></v>
<v t="T2484"><vh>DDF_StateGetInteger</vh></v>
<v t="T2485"><vh>DDF_StateGetIntPair</vh></v>
<v t="T2486"><vh>DDF_StateGetFloat</vh></v>
<v t="T2487"><vh>DDF_StateGetPercent</vh></v>
<v t="T2488"><vh>DDF_StateGetJump</vh></v>
<v t="T2489"><vh>DDF_StateGetAngle</vh></v>
<v t="T2490"><vh>DDF_StateGetSlope</vh></v>
</v>
<v t="T2491"><vh>@file ddf_swth.c</vh>
<v t="T2492"><vh>&lt;&lt; ddf_swth #includes &gt;&gt;</vh></v>
<v t="T2493"><vh>&lt;&lt; ddf_swth declarations &gt;&gt;</vh></v>
<v t="T2494"><vh>SwitchStartEntry</vh></v>
<v t="T2495"><vh>SwitchParseField</vh></v>
<v t="T2496"><vh>SwitchFinishEntry</vh></v>
<v t="T2497"><vh>SwitchClearAll</vh></v>
<v t="T2498"><vh>DDF_ReadSW</vh></v>
<v t="T2499"><vh>DDF_SWInit</vh></v>
<v t="T2500"><vh>DDF_SWCleanUp</vh></v>
</v>
<v t="T1253"><vh>@file ddf_weap.c</vh>
<v t="T1254"><vh>&lt;&lt; ddf_weap #includes &gt;&gt;</vh></v>
<v t="T1255"><vh>&lt;&lt; ddf_weap declarations &gt;&gt;</vh></v>
<v t="T1256"><vh>WeaponTryParseState</vh></v>
<v t="T1257"><vh>WeaponStartEntry</vh></v>
<v t="T1258"><vh>WeaponParseField</vh></v>
<v t="T1259"><vh>WeaponFinishEntry</vh></v>
<v t="T1260"><vh>WeaponClearAll</vh></v>
<v t="T1261"><vh>DDF_ReadWeapons</vh></v>
<v t="T1262"><vh>DDF_WeaponInit</vh></v>
<v t="T1263"><vh>DDF_WeaponCleanUp</vh></v>
<v t="T1264"><vh>DDF_WGetAmmo</vh></v>
<v t="T1265"><vh>DDF_WeaponLookup</vh></v>
<v t="T1266"><vh>DDF_WGetUpgrade</vh></v>
<v t="T1267"><vh>DDF_WGetSpecialFlags</vh></v>
</v>
</v>
<v t="T2526"><vh>dm_*.c (definitions: empty)</vh>
<v t="T1268" a="E"><vh>@file dm_defs.c</vh></v>
<v t="T1270" a="E"><vh>@file dm_state.c</vh></v>
</v>
<v t="T2527"><vh>e_*.c (main loop)</vh>
<v t="T1272"><vh>@file e_main.c</vh>
<v t="T1273"><vh>&lt;&lt; e_main #includes &gt;&gt;</vh></v>
<v t="T1274"><vh>&lt;&lt; e_main declarations &gt;&gt;</vh></v>
<v t="T1275"><vh>SetGlobalVars</vh></v>
<v t="T1276"><vh>SpecialWadVerify</vh></v>
<v t="T1277"><vh>ShowNotice</vh></v>
<v t="T1278"><vh>E_PostEvent</vh></v>
<v t="T1279"><vh>E_ProcessEvents</vh></v>
<v t="T1280"><vh>M_DisplayPause</vh></v>
<v t="T1281"><vh>E_Display</vh></v>
<v t="T1282"><vh>E_EDGELoopRoutine</vh></v>
<v t="T1283"><vh>E_EDGELoop</vh></v>
<v t="T1284"><vh>E_PageTicker</vh></v>
<v t="T1285"><vh>E_PageDrawer</vh></v>
<v t="T1286"><vh>E_AdvanceDemo</vh></v>
<v t="T1287"><vh>DemoNextPicture</vh></v>
<v t="T1288"><vh>E_DoAdvanceDemo</vh></v>
<v t="T1289"><vh>E_StartTitle</vh></v>
<v t="T1290"><vh>InitDirectories</vh></v>
<v t="T1291"><vh>CheckExternal</vh></v>
<v t="T1292"><vh>IdentifyVersion</vh></v>
<v t="T1293"><vh>ShowVersion</vh></v>
<v t="T1294"><vh>E_EDGEMain</vh></v>
<v t="T1295"><vh>E_EngineShutdown</vh></v>
</v>
<v t="T1296"><vh>@file e_net.c</vh>
<v t="T1297"><vh>&lt;&lt; e_net #includes &gt;&gt;</vh></v>
<v t="T1298"><vh>&lt;&lt; e_net declarations &gt;&gt;</vh></v>
<v t="T1299"><vh>NetBufferSize</vh></v>
<v t="T1300"><vh>NetBufferChecksum</vh></v>
<v t="T1301"><vh>ExpandTics</vh></v>
<v t="T1302"><vh>HSendPacket</vh></v>
<v t="T1303"><vh>E_ReceiveSetupPacket</vh></v>
<v t="T1304"><vh>E_HGetPacket</vh></v>
<v t="T1305"><vh>GetPackets</vh></v>
<v t="T1306"><vh>E_NetUpdate</vh></v>
<v t="T1307"><vh>E_CheckAbort</vh></v>
<v t="T1308"><vh>E_PrintSetupPacket</vh></v>
<v t="T1309"><vh>E_SendSetupPacket</vh></v>
<v t="T1310"><vh>E_ArbitrateNetStart</vh></v>
<v t="T1311"><vh>E_QuitNetGame</vh></v>
<v t="T1312"><vh>E_TryRunTics</vh></v>
<v t="T1313"><vh>E_NetGetRandomSeed</vh></v>
<v t="T1314"><vh>E_CheckNetGame</vh></v>
</v>
</v>
<v t="T1315"><vh>@file f_finale.c (game complete)</vh>
<v t="T1316"><vh>&lt;&lt; f_finale #includes &gt;&gt;</vh></v>
<v t="T1317"><vh>&lt;&lt; f_finale declarations &gt;&gt;</vh></v>
<v t="T1318"><vh>F_StartFinale</vh></v>
<v t="T1319"><vh>F_Responder</vh></v>
<v t="T1320"><vh>F_Ticker</vh></v>
<v t="T1321"><vh>TextWrite</vh></v>
<v t="T1322"><vh>CastSetState</vh></v>
<v t="T1323"><vh>CAST_RangeAttack</vh></v>
<v t="T1324"><vh>CastPerformAction</vh></v>
<v t="T1325"><vh>StartCast</vh></v>
<v t="T1326"><vh>CastTicker</vh></v>
<v t="T1327"><vh>CastResponder</vh></v>
<v t="T1328"><vh>CastPrint</vh></v>
<v t="T1329"><vh>CastDrawer</vh></v>
<v t="T1330"><vh>BunnyScroll</vh></v>
<v t="T1331"><vh>F_Drawer</vh></v>
</v>
<v t="T1332"><vh>@file g_game.c (game handling)</vh>
<v t="T1333"><vh>&lt;&lt; g_game #includes &gt;&gt;</vh></v>
<v t="T1334"><vh>&lt;&lt; g_game declarations &gt;&gt;</vh></v>
<v t="T1335"><vh>CheckKey</vh></v>
<v t="T1336"><vh>WriteToDemo</vh></v>
<v t="T1337"><vh>WriteByteToDemo</vh></v>
<v t="T1338"><vh>CmdChecksum</vh></v>
<v t="T1339"><vh>G_BuildTiccmd</vh></v>
<v t="T1340"><vh>G_DoLoadLevel</vh></v>
<v t="T1341"><vh>G_Responder</vh></v>
<v t="T1342"><vh>G_Ticker</vh></v>
<v t="T1343"><vh>G_PlayerFinishLevel</vh></v>
<v t="T1344"><vh>G_PlayerReborn</vh></v>
<v t="T1345"><vh>G_CheckSpot</vh></v>
<v t="T1346"><vh>G_DeathMatchSpawnPlayer</vh></v>
<v t="T1347"><vh>G_DoReborn</vh></v>
<v t="T1348"><vh>G_ScreenShot</vh></v>
<v t="T1349"><vh>G_ExitLevel</vh></v>
<v t="T1350"><vh>G_SecretExitLevel</vh></v>
<v t="T1351"><vh>G_ExitToLevel</vh></v>
<v t="T1352"><vh>G_DoCompleted</vh></v>
<v t="T1353"><vh>G_WorldDone</vh></v>
<v t="T1354"><vh>G_DoWorldDone</vh></v>
<v t="T1355"><vh>G_FileNameFromSlot</vh></v>
<v t="T1356"><vh>G_LoadGame</vh></v>
<v t="T1357"><vh>G_DoLoadGame</vh></v>
<v t="T1358"><vh>G_SaveGame</vh></v>
<v t="T1359"><vh>G_DoSaveGame</vh></v>
<v t="T1360"><vh>G_DeferedInitNew</vh></v>
<v t="T1361"><vh>G_DoNewGame</vh></v>
<v t="T1362"><vh>G_InitNew</vh></v>
<v t="T1363"><vh>G_ReadDemoTiccmd</vh></v>
<v t="T1364"><vh>G_WriteDemoTiccmd</vh></v>
<v t="T1365"><vh>G_RecordDemo</vh></v>
<v t="T1366"><vh>G_BeginRecording</vh></v>
<v t="T1367"><vh>G_SetTurboScale</vh></v>
<v t="T1368"><vh>G_DeferedPlayDemo</vh></v>
<v t="T1369"><vh>G_DoPlayDemo</vh></v>
<v t="T1370"><vh>G_TimeDemo</vh></v>
<v t="T1371"><vh>G_CheckDemoStatus</vh></v>
<v t="T1372"><vh>G_CheckWhenAppear</vh></v>
<v t="T1373"><vh>G_CheckConditions</vh></v>
</v>
<v t="T2522"><vh>gui_*.c</vh>
<v t="T1374"><vh>@file gui_ctls.c</vh>
<v t="T1375"><vh>&lt;&lt; gui_ctls #includes &gt;&gt;</vh></v>
<v t="T1376"><vh>&lt;&lt; gui_ctls declarations &gt;&gt;</vh></v>
<v t="T1377"><vh>GUI_BTStart</vh></v>
<v t="T1378"><vh>BT_Responder</vh></v>
<v t="T1379"><vh>BT_Drawer</vh></v>
<v t="T1380"><vh>GUI_MSGStart</vh></v>
<v t="T1381"><vh>MSG_Responder</vh></v>
<v t="T1382"><vh>MSG_Drawer</vh></v>
<v t="T1383"><vh>DRAG_Responder</vh></v>
<v t="T1384"><vh>GUI_DRAGStart</vh></v>
<v t="T1385"><vh>GUI_WriteText</vh></v>
<v t="T1386"><vh>BAR_Responder</vh></v>
<v t="T1387"><vh>BAR_Drawer</vh></v>
<v t="T1388"><vh>GUI_BARStart</vh></v>
</v>
<v t="T1389"><vh>@file gui_main.c</vh>
<v t="T1390"><vh>&lt;&lt; gui_main #includes &gt;&gt;</vh></v>
<v t="T1391"><vh>&lt;&lt; gui_main declarations &gt;&gt;</vh></v>
<v t="T1392"><vh>GUI_Init</vh></v>
<v t="T1393"><vh>GUI_NULL</vh></v>
<v t="T1394"><vh>GUI_Start</vh></v>
<v t="T1395"><vh>GUI_Destroy</vh></v>
<v t="T1396"><vh>GUI_SetFocus</vh></v>
<v t="T1397"><vh>GUI_Ticker</vh></v>
<v t="T1398"><vh>GUI_InBox</vh></v>
<v t="T1399"><vh>GUI_Responder</vh></v>
<v t="T1400"><vh>GUI_Drawer</vh></v>
<v t="T1401"><vh>GUI_MainTicker</vh></v>
<v t="T1402"><vh>GUI_MainResponder</vh></v>
<v t="T1403"><vh>GUI_MainDrawer</vh></v>
<v t="T1404"><vh>GUI_MainInit</vh></v>
<v t="T1405"><vh>GUI_InitResolution</vh></v>
<v t="T1406"><vh>GUI_MainSetMouseVisibility</vh></v>
<v t="T1407"><vh>GUI_MainGetMouseVisibility</vh></v>
<v t="T1408"><vh>GUI_SetMouse</vh></v>
</v>
</v>
<v t="T2523"><vh>hu_*.c (heads up)</vh>
<v t="T1409"><vh>@file hu_lib.c</vh>
<v t="T1410"><vh>&lt;&lt; hu_lib #includes &gt;&gt;</vh></v>
<v t="T1411"><vh>HL_Init</vh></v>
<v t="T1412"><vh>HL_CharWidth</vh></v>
<v t="T1413"><vh>HL_TextMaxLen</vh></v>
<v t="T1414"><vh>HL_StringWidth</vh></v>
<v t="T1415"><vh>HL_StringHeight</vh></v>
<v t="T1416"><vh>HL_WriteChar</vh></v>
<v t="T1417"><vh>HL_WriteTextTrans</vh></v>
<v t="T1418"><vh>HL_WriteText</vh></v>
<v t="T1419"><vh>HL_ClearTextLine</vh></v>
<v t="T1420"><vh>HL_InitTextLine</vh></v>
<v t="T1421"><vh>HL_AddCharToTextLine</vh></v>
<v t="T1422"><vh>HL_DelCharFromTextLine</vh></v>
<v t="T1423"><vh>HL_DrawTextLineAlpha</vh></v>
<v t="T1424"><vh>HL_DrawTextLine</vh></v>
<v t="T1425"><vh>HL_EraseTextLine</vh></v>
<v t="T1426"><vh>HL_InitSText</vh></v>
<v t="T1427"><vh>HL_AddLineToSText</vh></v>
<v t="T1428"><vh>HL_AddMessageToSText</vh></v>
<v t="T1429"><vh>HL_DrawSText</vh></v>
<v t="T1430"><vh>HL_EraseSText</vh></v>
<v t="T1431"><vh>HL_InitIText</vh></v>
<v t="T1432"><vh>HL_DelCharFromIText</vh></v>
<v t="T1433"><vh>HL_EraseLineFromIText</vh></v>
<v t="T1434"><vh>HL_ResetIText</vh></v>
<v t="T1435"><vh>HL_AddPrefixToIText</vh></v>
<v t="T1436"><vh>HL_KeyInIText</vh></v>
<v t="T1437"><vh>HL_DrawIText</vh></v>
<v t="T1438"><vh>HL_EraseIText</vh></v>
</v>
<v t="T1439"><vh>@file hu_stuff.c</vh>
<v t="T1440"><vh>&lt;&lt; hu_stuff #includes &gt;&gt;</vh></v>
<v t="T1441"><vh>&lt;&lt; hu_stuff declarations &gt;&gt;</vh></v>
<v t="T1442"><vh>HU_Init</vh></v>
<v t="T1443"><vh>HU_Stop</vh></v>
<v t="T1444"><vh>HU_Start</vh></v>
<v t="T1445"><vh>HU_DrawCrossHair</vh></v>
<v t="T1446"><vh>HU_Drawer</vh></v>
<v t="T1447"><vh>HU_Erase</vh></v>
<v t="T1448"><vh>HU_StartMessage</vh></v>
<v t="T1449"><vh>HU_Ticker</vh></v>
<v t="T1450"><vh>HU_QueueChatChar</vh></v>
<v t="T1451"><vh>HU_DequeueChatChar</vh></v>
<v t="T1452"><vh>HU_Responder</vh></v>
</v>
</v>
<v t="T2524"><vh>l_*.c (linker)</vh>
<v t="T1453"><vh>@file l_glbsp.c</vh>
<v t="T1454"><vh>&lt;&lt; l_glbsp #includes &gt;&gt;</vh></v>
<v t="T1455"><vh>&lt;&lt; l_glbsp declarations &gt;&gt;</vh></v>
<v t="T1456"><vh>GB_PrintMsg</vh></v>
<v t="T1457"><vh>GB_FatalError</vh></v>
<v t="T1458"><vh>GB_Ticker</vh></v>
<v t="T1459"><vh>GB_DisplayOpen</vh></v>
<v t="T1460"><vh>GB_DisplaySetTitle</vh></v>
<v t="T1461"><vh>GB_DisplaySetText</vh></v>
<v t="T1462"><vh>GB_DisplaySetBarText</vh></v>
<v t="T1463"><vh>GB_DisplaySetBarLimit</vh></v>
<v t="T1464"><vh>GB_DisplaySetBar</vh></v>
<v t="T1465"><vh>GB_DisplayClose</vh></v>
<v t="T1466"><vh>GB_BuildNodes</vh></v>
<v t="T1467"><vh>GB_InitProgress</vh></v>
<v t="T1468"><vh>GB_TermProgress</vh></v>
<v t="T1469"><vh>GB_DrawProgress</vh></v>
</v>
<v t="T1470"><vh>@file l_mp3.c</vh>
<v t="T1471"><vh>&lt;&lt; l_mp3 #includes &gt;&gt;</vh></v>
<v t="T1472"><vh>&lt;&lt; l_mp3 declarations &gt;&gt;</vh></v>
<v t="T1473"><vh>L_MP3Init</vh></v>
<v t="T1474"><vh>L_MP3Shutdown</vh></v>
<v t="T1475"><vh>TryReadInfo</vh></v>
<v t="T1476"><vh>L_MP3SetMusicFile</vh></v>
<v t="T1477"><vh>L_MP3SetMusicLump</vh></v>
<v t="T1478"><vh>L_MP3ClearMusicFile</vh></v>
<v t="T1479"><vh>DecodeIntoRingBuffer</vh></v>
<v t="T1480"><vh>L_MP3FillBuffer</vh></v>
<v t="T1481"><vh>L_MP3RestartMusicFile</vh></v>
<v t="T1482"><vh>L_MP3ReadBuffer</vh></v>
<v t="T1483"><vh>L_MP3ReadAdvance</vh></v>
</v>
</v>
<v t="T2519"><vh>lu_*.c (lookup tables)</vh>
<v t="T1484"><vh>@file lu_gamma.c</vh>
<v t="T1485"><vh>&lt;&lt; lu_gamma #includes &gt;&gt;</vh></v>
</v>
<v t="T1486"><vh>@file lu_math.c</vh>
<v t="T1487"><vh>&lt;&lt; lu_math #includes &gt;&gt;</vh></v>
<v t="T1488"><vh>SlopeDiv</vh></v>
</v>
</v>
<v t="T2520"><vh>m_*.c (math)</vh>
<v t="T1489"><vh>@file m_argv.c</vh>
<v t="T1490"><vh>&lt;&lt; m_argv #includes &gt;&gt;</vh></v>
<v t="T1491"><vh>&lt;&lt; m_argv declarations &gt;&gt;</vh></v>
<v t="T1492"><vh>AddArgument</vh></v>
<v t="T1493"><vh>M_CheckNextParm</vh></v>
<v t="T1494"><vh>M_CheckParm</vh></v>
<v t="T1495"><vh>M_GetParm</vh></v>
<v t="T1496"><vh>M_ApplyResponseFile</vh></v>
<v t="T1497"><vh>M_InitArguments</vh></v>
<v t="T1498"><vh>M_CheckBooleanParm</vh></v>
<v t="T1499"><vh>M_GetArguments</vh></v>
<v t="T1500"><vh>M_GetArgument</vh></v>
<v t="T1501"><vh>M_GetArgCount</vh></v>
</v>
<v t="T1502"><vh>@file m_bbox.c</vh>
<v t="T1503"><vh>&lt;&lt; m_bbox #includes &gt;&gt;</vh></v>
<v t="T1504"><vh>M_ClearBox</vh></v>
<v t="T1505"><vh>M_AddToBox</vh></v>
<v t="T1506"><vh>M_CopyBox</vh></v>
<v t="T1507"><vh>M_UnionBox</vh></v>
<v t="T1508"><vh>M_CleanMatrix</vh></v>
<v t="T1509"><vh>M_DirtyMatrix</vh></v>
<v t="T1510"><vh>M_DirtyRegion</vh></v>
</v>
<v t="T1511"><vh>@file m_cheat.c</vh>
<v t="T1512"><vh>&lt;&lt; m_cheat #includes &gt;&gt;</vh></v>
<v t="T1513"><vh>&lt;&lt; m_cheat declarations &gt;&gt;</vh></v>
<v t="T1514"><vh>M_CheckCheat</vh></v>
<v t="T1515"><vh>M_ChangeLevelCheat</vh></v>
<v t="T1516"><vh>M_ChangeMusicCheat</vh></v>
<v t="T1517"><vh>M_CheatResponder</vh></v>
<v t="T1518"><vh>M_CheatInit</vh></v>
</v>
<v t="T1519"><vh>@file m_crc32.c</vh>
<v t="T1520"><vh>&lt;&lt; m_crc32 #includes &gt;&gt;</vh></v>
<v t="T1521"><vh>CRC32_Init</vh></v>
<v t="T1522"><vh>CRC32_ProcessByte</vh></v>
<v t="T1523"><vh>CRC32_ProcessBlock</vh></v>
<v t="T1524"><vh>CRC32_Done</vh></v>
<v t="T1525"><vh>CRC32_ProcessInt</vh></v>
<v t="T1526"><vh>CRC32_ProcessFixed</vh></v>
<v t="T1527"><vh>CRC32_ProcessFloat</vh></v>
<v t="T1528"><vh>CRC32_ProcessStr</vh></v>
</v>
<v t="T1529"><vh>@file m_fixed.c</vh>
<v t="T1530"><vh>&lt;&lt; m_fixed #includes &gt;&gt;</vh></v>
</v>
<v t="T1531"><vh>@file m_inline.c</vh>
<v t="T1532"><vh>&lt;&lt; m_inline #includes &gt;&gt;</vh></v>
</v>
<v t="T1533"><vh>@file m_math.c</vh>
<v t="T1534"><vh>&lt;&lt; m_math #includes &gt;&gt;</vh></v>
<v t="T1535"><vh>FixedDiv2</vh></v>
<v t="T1536"><vh>FixedDiv</vh></v>
<v t="T1537"><vh>FixedMul</vh></v>
<v t="T1538"><vh>M_Sin</vh></v>
<v t="T1539"><vh>M_Cos</vh></v>
<v t="T1540"><vh>M_Tan</vh></v>
<v t="T1541"><vh>M_ATan</vh></v>
<v t="T1542"><vh>M_Angle2Matrix</vh></v>
</v>
<v t="T1543"><vh>@file m_menu.c</vh>
<v t="T1544"><vh>&lt;&lt; m_menu #includes &gt;&gt;</vh></v>
<v t="T1545"><vh>&lt;&lt; m_menu declarations &gt;&gt;</vh></v>
<v t="T1546"><vh>M_LoadSavePage</vh></v>
<v t="T1547"><vh>M_ReadSaveStrings</vh></v>
<v t="T1548"><vh>M_DrawSaveLoadCommon</vh></v>
<v t="T1549"><vh>M_DrawLoad</vh></v>
<v t="T1550"><vh>M_DrawSaveLoadBorder</vh></v>
<v t="T1551"><vh>M_LoadSelect</vh></v>
<v t="T1552"><vh>M_LoadGame</vh></v>
<v t="T1553"><vh>M_DrawSave</vh></v>
<v t="T1554"><vh>M_DoSave</vh></v>
<v t="T1555"><vh>M_SaveSelect</vh></v>
<v t="T1556"><vh>M_SaveGame</vh></v>
<v t="T1557"><vh>QuickSaveResponse</vh></v>
<v t="T1558"><vh>M_QuickSave</vh></v>
<v t="T1559"><vh>QuickLoadResponse</vh></v>
<v t="T1560"><vh>M_QuickLoad</vh></v>
<v t="T1561"><vh>M_DrawReadThis1</vh></v>
<v t="T1562"><vh>M_DrawReadThis2</vh></v>
<v t="T1563"><vh>M_DrawSound</vh></v>
<v t="T1564"><vh>M_Sound</vh></v>
<v t="T1565"><vh>M_SfxVol</vh></v>
<v t="T1566"><vh>M_MusicVol</vh></v>
<v t="T1567"><vh>M_DrawMainMenu</vh></v>
<v t="T1568"><vh>M_DrawNewGame</vh></v>
<v t="T1569"><vh>M_NewGame</vh></v>
<v t="T1570"><vh>CreateEpisodeMenu</vh></v>
<v t="T1571"><vh>M_DrawEpisode</vh></v>
<v t="T1572"><vh>VerifyNightmare</vh></v>
<v t="T1573"><vh>M_ChooseSkill</vh></v>
<v t="T1574"><vh>M_Episode</vh></v>
<v t="T1575"><vh>M_Options</vh></v>
<v t="T1576"><vh>M_ChangeMessages</vh></v>
<v t="T1577"><vh>EndGameResponse</vh></v>
<v t="T1578"><vh>M_EndGame</vh></v>
<v t="T1579"><vh>M_ReadThis</vh></v>
<v t="T1580"><vh>M_ReadThis2</vh></v>
<v t="T1581"><vh>M_FinishReadThis</vh></v>
<v t="T1582"><vh>QuitResponse</vh></v>
<v t="T1583"><vh>M_QuitEDGE</vh></v>
<v t="T1584"><vh>M_ChangeSensitivity</vh></v>
<v t="T1585"><vh>M_SizeDisplay</vh></v>
<v t="T1586"><vh>M_DrawThermo</vh></v>
<v t="T1587"><vh>M_StartMessage</vh></v>
<v t="T1588"><vh>M_StartMessageInput</vh></v>
<v t="T1589"><vh>M_StopMessage</vh></v>
<v t="T1590"><vh>M_Responder</vh></v>
<v t="T1591"><vh>M_StartControlPanel</vh></v>
<v t="T1592"><vh>M_Drawer</vh></v>
<v t="T1593"><vh>M_ClearMenus</vh></v>
<v t="T1594"><vh>M_SetupNextMenu</vh></v>
<v t="T1595"><vh>M_Ticker</vh></v>
<v t="T1596"><vh>M_Init</vh></v>
</v>
<v t="T1597"><vh>@file m_misc.c</vh>
<v t="T1598"><vh>&lt;&lt; m_misc #includes &gt;&gt;</vh></v>
<v t="T1599"><vh>&lt;&lt; m_misc declarations &gt;&gt;</vh></v>
<v t="T1600"><vh>WriteTGAFile</vh></v>
<v t="T1601"><vh>M_WriteFile</vh></v>
<v t="T1602"><vh>M_ReadFile</vh></v>
<v t="T1603"><vh>M_SaveDefaults</vh></v>
<v t="T1604"><vh>M_LoadDefaults</vh></v>
<v t="T1605"><vh>M_DisplayDisk</vh></v>
<v t="T1606"><vh>M_DisplayAir</vh></v>
<v t="T1607"><vh>M_ScreenShot</vh></v>
<v t="T1608"><vh>M_MakeSaveScreenShot</vh></v>
<v t="T1609"><vh>M_CheckExtension</vh></v>
<v t="T1610"><vh>M_ComposeFileName</vh></v>
<v t="T1611"><vh>M_GetFileData</vh></v>
<v t="T1612"><vh>M_WarnError</vh></v>
<v t="T1613"><vh>L_WriteDebug</vh></v>
<v t="T1614"><vh>L_ConvertToDB</vh></v>
<v t="T1615"><vh>L_CompareTimeStamps</vh></v>
</v>
<v t="T1616"><vh>@file m_option.c</vh>
<v t="T1617"><vh>&lt;&lt; m_option #includes &gt;&gt;</vh></v>
<v t="T1618"><vh>&lt;&lt; m_option declarations &gt;&gt;</vh></v>
<v t="T1619"><vh>M_Toggle3dMode</vh></v>
<v t="T1620"><vh>M_ChangeScreenSize</vh></v>
<v t="T1621"><vh>M_ChangeMusVol</vh></v>
<v t="T1622"><vh>M_ChangeSfxVol</vh></v>
<v t="T1623"><vh>M_ChangeNormalFOV</vh></v>
<v t="T1624"><vh>M_ChangeZoomedFOV</vh></v>
<v t="T1625"><vh>M_ChangeScreenComp</vh></v>
<v t="T1626"><vh>M_InitOptmenu</vh></v>
<v t="T1627"><vh>M_OptTicker</vh></v>
<v t="T1628"><vh>M_OptDrawer</vh></v>
<v t="T1629"><vh>M_ResOptDrawer</vh></v>
<v t="T1630"><vh>M_LanguageDrawer</vh></v>
<v t="T1631"><vh>M_OptResponder</vh></v>
<v t="T1632"><vh>M_VideoOptions</vh></v>
<v t="T1633"><vh>M_ResolutionOptions</vh></v>
<v t="T1634"><vh>M_AnalogueOptions</vh></v>
<v t="T1635"><vh>M_GameplayOptions</vh></v>
<v t="T1636"><vh>M_StandardControlOptions</vh></v>
<v t="T1637"><vh>M_ExtendedControlOptions</vh></v>
<v t="T1638"><vh>M_ResetToDefaults</vh></v>
<v t="T1639"><vh>M_Key2String</vh></v>
<v t="T1640"><vh>M_CalibrateJoystick</vh></v>
<v t="T1641"><vh>M_ChangeGamma</vh></v>
<v t="T1642"><vh>M_ChangeBlood</vh></v>
<v t="T1643"><vh>M_ChangeJumping</vh></v>
<v t="T1644"><vh>M_ChangeCrouching</vh></v>
<v t="T1645"><vh>M_ChangeExtra</vh></v>
<v t="T1646"><vh>M_ChangeMonsterRespawn</vh></v>
<v t="T1647"><vh>M_ChangeItemRespawn</vh></v>
<v t="T1648"><vh>M_ChangeStretchSky</vh></v>
<v t="T1649"><vh>M_ChangeTransluc</vh></v>
<v t="T1650"><vh>M_ChangeTrue3d</vh></v>
<v t="T1651"><vh>M_ChangeAutoAim</vh></v>
<v t="T1652"><vh>M_ChangeRespawn</vh></v>
<v t="T1653"><vh>M_ChangeFastparm</vh></v>
<v t="T1654"><vh>M_ChangeMipMap</vh></v>
<v t="T1655"><vh>M_ChangeShadows</vh></v>
<v t="T1656"><vh>M_ChangeHalos</vh></v>
<v t="T1657"><vh>M_ChangeCompatMode</vh></v>
<v t="T1658"><vh>M_ChangeKicking</vh></v>
<v t="T1659"><vh>M_ChangeDLights</vh></v>
<v t="T1660"><vh>M_ChangeLanguage</vh></v>
<v t="T1661"><vh>M_ChangeStoredRes</vh></v>
<v t="T1662"><vh>M_ChangeStoredBpp</vh></v>
<v t="T1663"><vh>M_OptionSetResolution</vh></v>
<v t="T1664"><vh>M_OptionTestResolution</vh></v>
<v t="T1665"><vh>M_RestoreResSettings</vh></v>
</v>
<v t="T1666"><vh>@file m_random.c</vh>
<v t="T1667"><vh>&lt;&lt; m_random #includes &gt;&gt;</vh></v>
<v t="T1668"><vh>&lt;&lt; m_random declarations &gt;&gt;</vh></v>
<v t="T1669"><vh>M_Random</vh></v>
<v t="T1670"><vh>P_Random</vh></v>
<v t="T1671"><vh>P_RandomNegPos</vh></v>
<v t="T1672"><vh>M_RandomTest</vh></v>
<v t="T1673"><vh>P_RandomTest</vh></v>
<v t="T1674"><vh>P_ReadRandomState</vh></v>
<v t="T1675"><vh>P_WriteRandomState</vh></v>
</v>
</v>
<v t="T2512"><vh>p_*.c (play)</vh>
<v t="T1676"><vh>@file p_action.c</vh>
<v t="T1677"><vh>&lt;&lt; p_action #includes &gt;&gt;</vh></v>
<v t="T1678"><vh>&lt;&lt; p_action declarations &gt;&gt;</vh></v>
<v t="T1679"><vh>P_ActActivateLineType</vh></v>
<v t="T1680"><vh>P_ActEnableRadTrig</vh></v>
<v t="T1681"><vh>P_ActDisableRadTrig</vh></v>
<v t="T1682"><vh>P_ActLookForTargets</vh></v>
<v t="T1683"><vh>DecideMeleeAttack</vh></v>
<v t="T1684"><vh>P_ActDecideRangeAttack</vh></v>
<v t="T1685"><vh>P_ActFaceTarget</vh></v>
<v t="T1686"><vh>P_ActMakeIntoCorpse</vh></v>
<v t="T1687"><vh>P_BringCorpseToLife</vh></v>
<v t="T1688"><vh>P_ActResetSpreadCount</vh></v>
<v t="T1689"><vh>P_ActTransSet</vh></v>
<v t="T1690"><vh>P_ActTransFade</vh></v>
<v t="T1691"><vh>P_ActTransLess</vh></v>
<v t="T1692"><vh>P_ActTransMore</vh></v>
<v t="T1693"><vh>P_ActTransAlternate</vh></v>
<v t="T1694"><vh>P_ActDLightSet</vh></v>
<v t="T1695"><vh>P_ActDLightFade</vh></v>
<v t="T1696"><vh>P_ActDLightRandom</vh></v>
<v t="T1697"><vh>P_ActFaceDir</vh></v>
<v t="T1698"><vh>P_ActTurnDir</vh></v>
<v t="T1699"><vh>P_ActTurnRandom</vh></v>
<v t="T1700"><vh>P_ActMlookFace</vh></v>
<v t="T1701"><vh>P_ActMlookTurn</vh></v>
<v t="T1702"><vh>P_ActMoveFwd</vh></v>
<v t="T1703"><vh>P_ActMoveRight</vh></v>
<v t="T1704"><vh>P_ActMoveUp</vh></v>
<v t="T1705"><vh>P_ActStopMoving</vh></v>
<v t="T1706"><vh>P_ActPlaySound</vh></v>
<v t="T1707"><vh>P_ActKillSound</vh></v>
<v t="T1708"><vh>P_ActMakeAmbientSound</vh></v>
<v t="T1709"><vh>P_ActMakeAmbientSoundRandom</vh></v>
<v t="T1710"><vh>P_ActMakeActiveSound</vh></v>
<v t="T1711"><vh>P_ActMakeDyingSound</vh></v>
<v t="T1712"><vh>P_ActMakePainSound</vh></v>
<v t="T1713"><vh>P_ActMakeOverKillSound</vh></v>
<v t="T1714"><vh>P_ActMakeCloseAttemptSound</vh></v>
<v t="T1715"><vh>P_ActMakeRangeAttemptSound</vh></v>
<v t="T1716"><vh>P_ActDamageExplosion</vh></v>
<v t="T1717"><vh>P_ActThrust</vh></v>
<v t="T1718"><vh>P_ActExplode</vh></v>
<v t="T1719"><vh>CheckMissileSpawn</vh></v>
<v t="T1720"><vh>LaunchProjectile</vh></v>
<v t="T1721"><vh>LaunchSmartProjectile</vh></v>
<v t="T1722"><vh>P_ActMissileContact</vh></v>
<v t="T1723"><vh>P_ActBulletContact</vh></v>
<v t="T1724"><vh>P_ActCreateSmokeTrail</vh></v>
<v t="T1725"><vh>P_ActRandomHomingProjectile</vh></v>
<v t="T1726"><vh>P_ActFixedHomingProjectile</vh></v>
<v t="T1727"><vh>P_ActHomeToSpot</vh></v>
<v t="T1728"><vh>P_ActLaunchOrderedSpread</vh></v>
<v t="T1729"><vh>P_ActLaunchRandomSpread</vh></v>
<v t="T1730"><vh>ShotAttack</vh></v>
<v t="T1731"><vh>SprayAttack</vh></v>
<v t="T1732"><vh>P_ActTrackerFollow</vh></v>
<v t="T1733"><vh>P_ActTrackerActive</vh></v>
<v t="T1734"><vh>P_ActTrackerStart</vh></v>
<v t="T1735"><vh>LaunchTracker</vh></v>
<v t="T1736"><vh>P_ActEffectTracker</vh></v>
<v t="T1737"><vh>ShootToSpot</vh></v>
<v t="T1738"><vh>ObjectSpawning</vh></v>
<v t="T1739"><vh>ObjectTripleSpawn</vh></v>
<v t="T1740"><vh>SkullFlyAttack</vh></v>
<v t="T1741"><vh>P_ActSlammedIntoObject</vh></v>
<v t="T1742"><vh>P_ActUseThing</vh></v>
<v t="T1743"><vh>P_ActTouchyContact</vh></v>
<v t="T1744"><vh>P_ActTouchyRearm</vh></v>
<v t="T1745"><vh>P_ActTouchyDisarm</vh></v>
<v t="T1746"><vh>P_ActBounceRearm</vh></v>
<v t="T1747"><vh>P_ActBounceDisarm</vh></v>
<v t="T1748"><vh>P_ActDropItem</vh></v>
<v t="T1749"><vh>P_ActPathCheck</vh></v>
<v t="T1750"><vh>P_ActPathFollow</vh></v>
<v t="T1751"><vh>P_DoAttack</vh></v>
<v t="T1752"><vh>P_ActComboAttack</vh></v>
<v t="T1753"><vh>P_ActMeleeAttack</vh></v>
<v t="T1754"><vh>P_ActRangeAttack</vh></v>
<v t="T1755"><vh>P_ActSpareAttack</vh></v>
<v t="T1756"><vh>P_ActRefireCheck</vh></v>
<v t="T1757"><vh>SelectTarget</vh></v>
<v t="T1758"><vh>CreateAggression</vh></v>
<v t="T1759"><vh>P_ActStandardLook</vh></v>
<v t="T1760"><vh>P_ActPlayerSupportLook</vh></v>
<v t="T1761"><vh>P_ActStandardMeander</vh></v>
<v t="T1762"><vh>P_ActPlayerSupportMeander</vh></v>
<v t="T1763"><vh>P_ActStandardChase</vh></v>
<v t="T1764"><vh>P_ActResurrectChase</vh></v>
<v t="T1765"><vh>P_ActWalkSoundChase</vh></v>
<v t="T1766"><vh>P_ActCheckBlood</vh></v>
<v t="T1767"><vh>P_ActJump</vh></v>
<v t="T1768"><vh>P_ActPlayerAttack</vh></v>
</v>
<v t="T1769"><vh>@file p_bot.c</vh>
<v t="T1770"><vh>&lt;&lt; p_bot #includes &gt;&gt;</vh></v>
<v t="T1771"><vh>&lt;&lt; p_bot declarations &gt;&gt;</vh></v>
<v t="T1772"><vh>NewBotChaseDir</vh></v>
<v t="T1773"><vh>Confidence</vh></v>
<v t="T1774"><vh>EvaluateWeapon</vh></v>
<v t="T1775"><vh>P_RemoveBots</vh></v>
<v t="T1776"><vh>PTR_BotLook</vh></v>
<v t="T1777"><vh>LookForStuff</vh></v>
<v t="T1778"><vh>MoveBot</vh></v>
<v t="T1779"><vh>LookForBotTargets</vh></v>
<v t="T1780"><vh>BotThink</vh></v>
<v t="T1781"><vh>BOT_DMSpawn</vh></v>
<v t="T1782"><vh>P_BotCreate</vh></v>
<v t="T1783"><vh>ConvertToTiccmd</vh></v>
<v t="T1784"><vh>DoThink</vh></v>
<v t="T1785"><vh>P_BotPlayerThinker</vh></v>
</v>
<v t="T1786"><vh>@file p_enemy.c</vh>
<v t="T1787"><vh>&lt;&lt; p_enemy #includes &gt;&gt;</vh></v>
<v t="T1788"><vh>&lt;&lt; p_enemy declarations &gt;&gt;</vh></v>
<v t="T1789"><vh>RecursiveSound</vh></v>
<v t="T1790"><vh>P_NoiseAlert</vh></v>
<v t="T1791"><vh>P_CheckMeleeRange</vh></v>
<v t="T1792"><vh>P_Move</vh></v>
<v t="T1793"><vh>TryWalk</vh></v>
<v t="T1794"><vh>P_NewChaseDir</vh></v>
<v t="T1795"><vh>P_LookForPlayers</vh></v>
<v t="T1796"><vh>P_LookForShootSpots</vh></v>
<v t="T1797"><vh>P_FreeShootSpots</vh></v>
<v t="T1798"><vh>SpawnDeathMissile</vh></v>
<v t="T1799"><vh>A_BrainScream</vh></v>
<v t="T1800"><vh>A_BrainMissileExplode</vh></v>
<v t="T1801"><vh>A_BrainDie</vh></v>
<v t="T1802"><vh>A_BrainSpit</vh></v>
<v t="T1803"><vh>A_CubeSpawn</vh></v>
<v t="T1804"><vh>A_PlayerScream</vh></v>
</v>
<v t="T1805"><vh>@file p_inter.c</vh>
<v t="T1806"><vh>&lt;&lt; p_inter #includes &gt;&gt;</vh></v>
<v t="T1807"><vh>GiveAmmo</vh></v>
<v t="T1808"><vh>GiveAmmoLimit</vh></v>
<v t="T1809"><vh>GiveWeapon</vh></v>
<v t="T1810"><vh>GiveHealth</vh></v>
<v t="T1811"><vh>GiveArmour</vh></v>
<v t="T1812"><vh>GiveKey</vh></v>
<v t="T1813"><vh>GivePower</vh></v>
<v t="T1814"><vh>P_GiveBenefitList</vh></v>
<v t="T1815"><vh>P_TouchSpecialThing</vh></v>
<v t="T1816"><vh>P_KillMobj</vh></v>
<v t="T1817"><vh>P_ThrustMobj</vh></v>
<v t="T1818"><vh>P_DamageMobj</vh></v>
</v>
<v t="T1819"><vh>@file p_lights.c</vh>
<v t="T1820"><vh>&lt;&lt; p_lights #includes &gt;&gt;</vh></v>
<v t="T1821"><vh>&lt;&lt; p_lights declarations &gt;&gt;</vh></v>
<v t="T1822"><vh>DoLight</vh></v>
<v t="T1823"><vh>EV_LightTurnOn</vh></v>
<v t="T1824"><vh>P_DestroyLight</vh></v>
<v t="T1825"><vh>P_DestroyAllLights</vh></v>
<v t="T1826"><vh>P_NewLight</vh></v>
<v t="T1827"><vh>EV_Lights</vh></v>
<v t="T1828"><vh>P_RunLights</vh></v>
</v>
<v t="T1829"><vh>@file p_map.c</vh>
<v t="T1830"><vh>&lt;&lt; p_map #includes &gt;&gt;</vh></v>
<v t="T1831"><vh>&lt;&lt; p_map declarations &gt;&gt;</vh></v>
<v t="T1832"><vh>PointOnLineSide</vh></v>
<v t="T1833"><vh>PIT_StompThing</vh></v>
<v t="T1834"><vh>P_TeleportMove</vh></v>
<v t="T1835"><vh>PIT_CheckAbsLine</vh></v>
<v t="T1836"><vh>PIT_CheckAbsThing</vh></v>
<v t="T1837"><vh>P_CheckAbsPosition</vh></v>
<v t="T1838"><vh>PIT_CheckRelLine</vh></v>
<v t="T1839"><vh>PIT_CheckRelThing</vh></v>
<v t="T1840"><vh>P_CheckRelPosition</vh></v>
<v t="T1841"><vh>P_TryMove</vh></v>
<v t="T1842"><vh>P_ThingHeightClip</vh></v>
<v t="T1843"><vh>HitSlideLine</vh></v>
<v t="T1844"><vh>PTR_SlideTraverse</vh></v>
<v t="T1845"><vh>P_SlideMove</vh></v>
<v t="T1846"><vh>PTR_AimTraverse</vh></v>
<v t="T1847"><vh>ShootCheckGap</vh></v>
<v t="T1848"><vh>PTR_ShootTraverse</vh></v>
<v t="T1849"><vh>P_AimLineAttack</vh></v>
<v t="T1850"><vh>P_LineAttack</vh></v>
<v t="T1851"><vh>P_MapTargetTheory</vh></v>
<v t="T1852"><vh>P_MapTargetAutoAim</vh></v>
<v t="T1853"><vh>PTR_UseTraverse</vh></v>
<v t="T1854"><vh>P_UseLines</vh></v>
<v t="T1855"><vh>PIT_RadiusAttack</vh></v>
<v t="T1856"><vh>PIT_SphereAttack</vh></v>
<v t="T1857"><vh>P_RadiusAttack</vh></v>
<v t="T1858"><vh>PIT_ChangeSector</vh></v>
<v t="T1859"><vh>ChangeSectorHeights</vh></v>
<v t="T1860"><vh>P_CheckSolidSectorMove</vh></v>
<v t="T1861"><vh>P_SolidSectorMove</vh></v>
<v t="T1862"><vh>P_ChangeThingSize</vh></v>
<v t="T1863"><vh>PIT_CorpseCheck</vh></v>
<v t="T1864"><vh>P_MapFindCorpse</vh></v>
<v t="T1865"><vh>PIT_CheckBlockingLine</vh></v>
<v t="T1866"><vh>P_MapCheckBlockingLine</vh></v>
<v t="T1867"><vh>P_MapInit</vh></v>
</v>
<v t="T1868"><vh>@file p_maputl.c</vh>
<v t="T1869"><vh>&lt;&lt; p_maputl #includes &gt;&gt;</vh></v>
<v t="T1870"><vh>&lt;&lt; p_maputl declarations &gt;&gt;</vh></v>
<v t="T1871"><vh>P_ApproxDistance</vh></v>
<v t="T1872"><vh>P_ApproxSlope</vh></v>
<v t="T1873"><vh>P_PointOnDivlineSide</vh></v>
<v t="T1874"><vh>P_PointOnDivlineThick</vh></v>
<v t="T1875"><vh>P_BoxOnLineSide</vh></v>
<v t="T1876"><vh>P_BoxOnDivLineSide</vh></v>
<v t="T1877"><vh>P_InterceptVector</vh></v>
<v t="T1878"><vh>GAP_RemoveSolid</vh></v>
<v t="T1879"><vh>GAP_Construct</vh></v>
<v t="T1880"><vh>GAP_SightConstruct</vh></v>
<v t="T1881"><vh>GAP_Restrict</vh></v>
<v t="T1882"><vh>GAP_Dump</vh></v>
<v t="T1883"><vh>P_FindThingGap</vh></v>
<v t="T1884"><vh>P_ComputeThingGap</vh></v>
<v t="T1885"><vh>P_ComputeGaps</vh></v>
<v t="T1886"><vh>P_DumpExtraFloors</vh></v>
<v t="T1887"><vh>P_ExtraFloorFits</vh></v>
<v t="T1888"><vh>P_AddExtraFloor</vh></v>
<v t="T1889"><vh>P_FloodExtraFloors</vh></v>
<v t="T1890"><vh>AddWallTile</vh></v>
<v t="T1891"><vh>P_ComputeWallTiles</vh></v>
<v t="T1892"><vh>P_RecomputeGapsAroundSector</vh></v>
<v t="T1893"><vh>P_RecomputeTilesInSector</vh></v>
<v t="T1894"><vh>TouchNodeAlloc</vh></v>
<v t="T1895"><vh>TouchNodeFree</vh></v>
<v t="T1896"><vh>TouchNodeLinkIntoSector</vh></v>
<v t="T1897"><vh>TouchNodeLinkIntoThing</vh></v>
<v t="T1898"><vh>TouchNodeUnlinkFromSector</vh></v>
<v t="T1899"><vh>TouchNodeUnlinkFromThing</vh></v>
<v t="T1900"><vh>SetPositionBSP</vh></v>
<v t="T1901"><vh>P_UnsetThingPosition</vh></v>
<v t="T1902"><vh>P_UnsetThingFinally</vh></v>
<v t="T1903"><vh>P_SetThingPosition</vh></v>
<v t="T1904"><vh>P_ChangeThingPosition</vh></v>
<v t="T1905"><vh>P_FreeSectorTouchNodes</vh></v>
<v t="T1906"><vh>P_BlockLinesIterator</vh></v>
<v t="T1907"><vh>P_BlockThingsIterator</vh></v>
<v t="T1908"><vh>PIT_AddLineIntercepts</vh></v>
<v t="T1909"><vh>PIT_AddThingIntercepts</vh></v>
<v t="T1910"><vh>TraverseIntercepts</vh></v>
<v t="T1911"><vh>P_PathTraverse</vh></v>
<v t="T1912"><vh>PST_CheckBBox</vh></v>
<v t="T1913"><vh>TraverseSubsec</vh></v>
<v t="T1914"><vh>P_SubsecThingIterator</vh></v>
<v t="T1915"><vh>PST_CheckThingArea</vh></v>
<v t="T1916"><vh>PST_CheckThingLine</vh></v>
<v t="T1917"><vh>P_ThingsInArea</vh></v>
<v t="T1918"><vh>P_ThingsOnLine</vh></v>
</v>
<v t="T1919"><vh>@file p_mobj.c</vh>
<v t="T1920"><vh>&lt;&lt; p_mobj #includes &gt;&gt;</vh></v>
<v t="T1921"><vh>&lt;&lt; p_mobj declarations &gt;&gt;</vh></v>
<v t="T1922"><vh>PointOnLineSide</vh></v>
<v t="T1923"><vh>EnterBounceStates</vh></v>
<v t="T1924"><vh>BounceOffWall</vh></v>
<v t="T1925"><vh>BounceOffPlane</vh></v>
<v t="T1926"><vh>MissileHitSpecialLine</vh></v>
<v t="T1927"><vh>CorpseShouldSlide</vh></v>
<v t="T1928"><vh>TeleportRespawn</vh></v>
<v t="T1929"><vh>ResurrectRespawn</vh></v>
<v t="T1930"><vh>DoRemoveMobj</vh></v>
<v t="T1931"><vh>AddMobjToRemoveQue</vh></v>
<v t="T1932"><vh>CREATE_FUNCTION</vh></v>
<v t="T1933"><vh>P_SetMobjState</vh></v>
<v t="T1934"><vh>P_SetMobjStateDeferred</vh></v>
<v t="T1935"><vh>P_MobjFindLabel</vh></v>
<v t="T1936"><vh>P_SetMobjDirAndSpeed</vh></v>
<v t="T1937"><vh>P_MobjExplodeMissile</vh></v>
<v t="T1938"><vh>AddRegionProperties</vh></v>
<v t="T1939"><vh>P_CalcFullProperties</vh></v>
<v t="T1940"><vh>P_XYMovement</vh></v>
<v t="T1941"><vh>P_ZMovement</vh></v>
<v t="T1942"><vh>P_MobjThinker</vh></v>
<v t="T1943"><vh>P_RunMobjThinkers</vh></v>
<v t="T1944"><vh>P_RemoveQueuedMobjs</vh></v>
<v t="T1945"><vh>P_RemoveMobj</vh></v>
<v t="T1946"><vh>P_SpawnPlayer</vh></v>
<v t="T1947"><vh>P_SpawnPuff</vh></v>
<v t="T1948"><vh>P_SpawnBlood</vh></v>
<v t="T1949"><vh>P_MobjItemRespawn</vh></v>
<v t="T1950"><vh>P_MobjRemoveMissile</vh></v>
<v t="T1951"><vh>P_MobjCreateObject</vh></v>
<v t="T1952"><vh>P_DumpMobjs</vh></v>
</v>
<v t="T1953"><vh>@file p_plane.c</vh>
<v t="T1954"><vh>&lt;&lt; p_plane #includes &gt;&gt;</vh></v>
<v t="T1955"><vh>&lt;&lt; p_plane declarations &gt;&gt;</vh></v>
<v t="T1956"><vh>HEIGHT</vh></v>
<v t="T1957"><vh>SECPIC</vh></v>
<v t="T1958"><vh>GetSecHeightReference</vh></v>
<v t="T1959"><vh>GetElevatorHeightReference</vh></v>
<v t="T1960"><vh>P_AddActivePart</vh></v>
<v t="T1961"><vh>P_RemoveActivePart</vh></v>
<v t="T1962"><vh>P_RemoveAllActiveParts</vh></v>
<v t="T1963"><vh>AttemptMovePlane</vh></v>
<v t="T1964"><vh>MovePlane</vh></v>
<v t="T1965"><vh>P_RunActiveSectors</vh></v>
<v t="T1966"><vh>P_GSS</vh></v>
<v t="T1967"><vh>P_GetSectorSurrounding</vh></v>
<v t="T1968"><vh>P_SetupSectorAction</vh></v>
<v t="T1969"><vh>EV_Teleport</vh></v>
<v t="T1970"><vh>EV_BuildOneStair</vh></v>
<v t="T1971"><vh>EV_BuildStairs</vh></v>
<v t="T1972"><vh>EV_DoPlane</vh></v>
<v t="T1973"><vh>EV_ManualPlane</vh></v>
<v t="T1974"><vh>P_ActivateInStasis</vh></v>
<v t="T1975"><vh>P_StasifySector</vh></v>
<v t="T1976"><vh>EV_DoDonut</vh></v>
<v t="T1977"><vh>SliderCanClose</vh></v>
<v t="T1978"><vh>MoveSlider</vh></v>
<v t="T1979"><vh>EV_DoSlider</vh></v>
<v t="T1980"><vh>AttemptMoveElevator</vh></v>
<v t="T1981"><vh>MoveElevator</vh></v>
<v t="T1982"><vh>EV_DoElevator</vh></v>
<v t="T1983"><vh>EV_ManualElevator</vh></v>
<v t="T1984"><vh>P_SetupElevatorAction</vh></v>
</v>
<v t="T1985"><vh>@file p_setup.c</vh>
<v t="T1986"><vh>&lt;&lt; p_setup #includes &gt;&gt;</vh></v>
<v t="T1987"><vh>&lt;&lt; p_setup declarations &gt;&gt;</vh></v>
<v t="T1988"><vh>LoadVertexes</vh></v>
<v t="T1989"><vh>LoadGLVertexes</vh></v>
<v t="T1990"><vh>LoadGLSegs</vh></v>
<v t="T1991"><vh>LoadSubsectors</vh></v>
<v t="T1992"><vh>GroupSectorTags</vh></v>
<v t="T1993"><vh>LoadSectors</vh></v>
<v t="T1994"><vh>LoadNodes</vh></v>
<v t="T1995"><vh>SpawnMapThing</vh></v>
<v t="T1996"><vh>LoadThings</vh></v>
<v t="T1997"><vh>LoadHexenThings</vh></v>
<v t="T1998"><vh>ComputeLinedefData</vh></v>
<v t="T1999"><vh>LoadLineDefs</vh></v>
<v t="T2000"><vh>LoadHexenLineDefs</vh></v>
<v t="T2001"><vh>TransferMapSideDef</vh></v>
<v t="T2002"><vh>LoadSideDefs</vh></v>
<v t="T2003"><vh>SetupExtrafloors</vh></v>
<v t="T2004"><vh>SetupWallTiles</vh></v>
<v t="T2005"><vh>SetupVertGaps</vh></v>
<v t="T2006"><vh>LoadBlockMap</vh></v>
<v t="T2007"><vh>BlockAdd</vh></v>
<v t="T2008"><vh>BlockAddLine</vh></v>
<v t="T2009"><vh>GenerateBlockMap</vh></v>
<v t="T2010"><vh>DoBlockMap</vh></v>
<v t="T2011"><vh>GroupLines</vh></v>
<v t="T2012"><vh>LoadReject</vh></v>
<v t="T2013"><vh>P_RemoveMobjs</vh></v>
<v t="T2014"><vh>P_RemoveItemsInQue</vh></v>
<v t="T2015"><vh>P_RemoveSectors</vh></v>
<v t="T2016"><vh>ShutdownLevel</vh></v>
<v t="T2017"><vh>P_SetupLevel</vh></v>
<v t="T2018"><vh>P_Init</vh></v>
</v>
<v t="T2019"><vh>@file p_sight.c</vh>
<v t="T2020"><vh>&lt;&lt; p_sight #includes &gt;&gt;</vh></v>
<v t="T2021"><vh>&lt;&lt; p_sight declarations &gt;&gt;</vh></v>
<v t="T2022"><vh>Z_Bunch</vh></v>
<v t="T2023"><vh>CrossSubsector</vh></v>
<v t="T2024"><vh>CheckSightBSP</vh></v>
<v t="T2025"><vh>CheckSightIntercepts</vh></v>
<v t="T2026"><vh>CheckSightSameSubsector</vh></v>
<v t="T2027"><vh>P_CheckSight</vh></v>
<v t="T2028"><vh>P_CheckSightApproxVert</vh></v>
</v>
<v t="T2029"><vh>@file p_spec.c</vh>
<v t="T2030"><vh>&lt;&lt; p_spec #includes &gt;&gt;</vh></v>
<v t="T2031"><vh>&lt;&lt; p_spec declarations &gt;&gt;</vh></v>
<v t="T2032"><vh>DoElevator_wrapper</vh></v>
<v t="T2033"><vh>DoPlane_wrapper</vh></v>
<v t="T2034"><vh>DoLights_wrapper</vh></v>
<v t="T2035"><vh>DoDonut_wrapper</vh></v>
<v t="T2036"><vh>NewSectorSFX</vh></v>
<v t="T2037"><vh>P_DestroyAllSectorSFX</vh></v>
<v t="T2038"><vh>DoSectorSFX</vh></v>
<v t="T2039"><vh>P_RunSectorSFX</vh></v>
<v t="T2040"><vh>P_GetSide</vh></v>
<v t="T2041"><vh>P_GetSector</vh></v>
<v t="T2042"><vh>P_TwoSided</vh></v>
<v t="T2043"><vh>P_GetNextSector</vh></v>
<v t="T2044"><vh>P_FindSurroundingHeight</vh></v>
<v t="T2045"><vh>P_FindRaiseToTexture</vh></v>
<v t="T2046"><vh>P_FindSectorFromTag</vh></v>
<v t="T2047"><vh>P_FindMinSurroundingLight</vh></v>
<v t="T2048"><vh>P_AddSpecialLine</vh></v>
<v t="T2049"><vh>P_AddSpecialSector</vh></v>
<v t="T2050"><vh>AdjustScrollParts</vh></v>
<v t="T2051"><vh>AdjustScaleParts</vh></v>
<v t="T2052"><vh>AdjustSkewParts</vh></v>
<v t="T2053"><vh>AdjustLightParts</vh></v>
<v t="T2054"><vh>P_EFTransferTrans</vh></v>
<v t="T2055"><vh>P_LineEffect</vh></v>
<v t="T2056"><vh>P_SectorEffect</vh></v>
<v t="T2057"><vh>P_ActivateSpecialLine</vh></v>
<v t="T2058"><vh>P_CrossSpecialLine</vh></v>
<v t="T2059"><vh>P_ShootSpecialLine</vh></v>
<v t="T2060"><vh>P_UseSpecialLine</vh></v>
<v t="T2061"><vh>P_RemoteActivation</vh></v>
<v t="T2062"><vh>PlayerInProperties</vh></v>
<v t="T2063"><vh>P_PlayerInSpecialSector</vh></v>
<v t="T2064"><vh>P_UpdateSpecials</vh></v>
<v t="T2065"><vh>P_SpawnSpecials</vh></v>
<v t="T2066"><vh>P_DoSectorsFromTag</vh></v>
</v>
<v t="T2067"><vh>@file p_tick.c</vh>
<v t="T2068"><vh>&lt;&lt; p_tick #includes &gt;&gt;</vh></v>
<v t="T2069"><vh>&lt;&lt; p_tick declarations &gt;&gt;</vh></v>
<v t="T2070"><vh>P_Ticker</vh></v>
</v>
<v t="T2071"><vh>@file p_switch.c</vh>
<v t="T2072"><vh>&lt;&lt; p_switch #includes &gt;&gt;</vh></v>
<v t="T2073"><vh>&lt;&lt; p_switch declarations &gt;&gt;</vh></v>
<v t="T2074"><vh>P_InitSwitchList</vh></v>
<v t="T2075"><vh>P_ButtonCheckPressed</vh></v>
<v t="T2076"><vh>StartButton</vh></v>
<v t="T2077"><vh>P_ChangeSwitchTexture</vh></v>
</v>
<v t="T657"><vh>@file p_user.c</vh>
<v t="T658"><vh>&lt;&lt; p_user #includes &gt;&gt;</vh></v>
<v t="T659"><vh>CalcHeight</vh></v>
<v t="T660"><vh>MovePlayer</vh></v>
<v t="T661"><vh>DeathThink</vh></v>
<v t="T662"><vh>P_ConsolePlayerThinker</vh></v>
<v t="T663"><vh>P_PlayerThink</vh></v>
<v t="T664"><vh>P_AddPlayer</vh></v>
<v t="T665"><vh>P_RemoveAllPlayers</vh></v>
<v t="T666"><vh>P_AddPlayerToGame</vh></v>
<v t="T667"><vh>P_RemovePlayerFromGame</vh></v>
<v t="T668"><vh>P_UpdateAvailWeapons</vh></v>
<v t="T669"><vh>P_AddWeapon</vh></v>
<v t="T670"><vh>P_RemoveWeapon</vh></v>
<v t="T671"><vh>P_GiveInitialBenefits</vh></v>
</v>
<v t="T672"><vh>@file p_weapon.c</vh>
<v t="T673"><vh>&lt;&lt; p_weapon #includes &gt;&gt;</vh></v>
<v t="T674"><vh>P_SetPsprite</vh></v>
<v t="T675"><vh>P_CheckWeaponSprite</vh></v>
<v t="T676"><vh>P_RefillClips</vh></v>
<v t="T677"><vh>P_BringUpWeapon</vh></v>
<v t="T678"><vh>P_SelectNewWeapon</vh></v>
<v t="T679"><vh>CheckAmmo</vh></v>
<v t="T680"><vh>CheckAmmoSA</vh></v>
<v t="T681"><vh>P_FireWeapon</vh></v>
<v t="T682"><vh>P_FireSecondAttack</vh></v>
<v t="T683"><vh>P_DropWeapon</vh></v>
<v t="T684"><vh>A_WeaponReady</vh></v>
<v t="T685"><vh>A_ReFire</vh></v>
<v t="T686"><vh>A_ReFireSA</vh></v>
<v t="T687"><vh>A_NoFire</vh></v>
<v t="T688"><vh>A_NoFireSA</vh></v>
<v t="T689"><vh>A_NoFireReturn</vh></v>
<v t="T690"><vh>A_NoFireReturnSA</vh></v>
<v t="T691"><vh>A_WeaponKick</vh></v>
<v t="T692"><vh>A_CheckReload</vh></v>
<v t="T693"><vh>A_CheckReloadSA</vh></v>
<v t="T694"><vh>A_Lower</vh></v>
<v t="T695"><vh>A_Raise</vh></v>
<v t="T696"><vh>A_SetCrosshair</vh></v>
<v t="T697"><vh>A_GotTarget</vh></v>
<v t="T698"><vh>A_GunFlash</vh></v>
<v t="T699"><vh>A_GunFlashSA</vh></v>
<v t="T700"><vh>A_WeaponShoot</vh></v>
<v t="T701"><vh>A_WeaponShootSA</vh></v>
<v t="T702"><vh>A_WeaponEject</vh></v>
<v t="T703"><vh>A_WeaponPlaySound</vh></v>
<v t="T704"><vh>A_WeaponKillSound</vh></v>
<v t="T705"><vh>A_SFXWeapon1</vh></v>
<v t="T706"><vh>A_SFXWeapon2</vh></v>
<v t="T707"><vh>A_SFXWeapon3</vh></v>
<v t="T708"><vh>A_Light0</vh></v>
<v t="T709"><vh>A_Light1</vh></v>
<v t="T710"><vh>A_Light2</vh></v>
<v t="T711"><vh>A_WeaponJump</vh></v>
<v t="T712"><vh>A_WeaponTransSet</vh></v>
<v t="T713"><vh>A_WeaponTransFade</vh></v>
<v t="T714"><vh>P_SetupPsprites</vh></v>
<v t="T715"><vh>P_MovePsprites</vh></v>
<v t="T716"><vh>P_ActCheckMoving</vh></v>
<v t="T717"><vh>A_WeaponEnableRadTrig</vh></v>
<v t="T718"><vh>A_WeaponDisableRadTrig</vh></v>
<v t="T719"><vh>P_Zoom</vh></v>
</v>
</v>
<v t="T2513"><vh>r2_*.c (rendering)</vh>
<v t="T720"><vh>@file r2_bsp.c</vh>
<v t="T721"><vh>&lt;&lt; r2_bsp #includes &gt;&gt;</vh></v>
<v t="T722"><vh>&lt;&lt; r2_bsp declarations &gt;&gt;</vh></v>
<v t="T723"><vh>R2_AddDLights</vh></v>
<v t="T724"><vh>R2_AddColourDLights</vh></v>
<v t="T725"><vh>R2_WallEvent</vh></v>
<v t="T726"><vh>R2_BuildWalls</vh></v>
<v t="T727"><vh>R2_WalkWall</vh></v>
<v t="T728"><vh>R2_WalkSeg</vh></v>
<v t="T729"><vh>R2_CheckBBox</vh></v>
<v t="T730"><vh>R2_PlaneEvent</vh></v>
<v t="T731"><vh>R2_GetThingSprite</vh></v>
<v t="T732"><vh>R2_GetOtherSprite</vh></v>
<v t="T733"><vh>R2_WalkThing</vh></v>
<v t="T734"><vh>R2_ClipSpriteHorizontally</vh></v>
<v t="T735"><vh>LinkDrawthingIntoDrawfloor</vh></v>
<v t="T736"><vh>R2_ClipSpriteVertically</vh></v>
<v t="T737"><vh>R2_ClipOneSprite</vh></v>
<v t="T738"><vh>R2_ClipSprites</vh></v>
<v t="T739"><vh>R2_FindDLights</vh></v>
<v t="T740"><vh>LightUpPlayerWeapon</vh></v>
<v t="T741"><vh>AddNewDrawFloor</vh></v>
<v t="T742"><vh>R2_WalkSubsector</vh></v>
<v t="T743"><vh>R2_WalkBSPNode</vh></v>
<v t="T744"><vh>R2_RenderTrueBSP</vh></v>
</v>
<v t="T745"><vh>@file r2_draw.c</vh>
<v t="T746"><vh>&lt;&lt; r2_draw #includes &gt;&gt;</vh></v>
<v t="T747"><vh>&lt;&lt; r2_draw declarations &gt;&gt;</vh></v>
<v t="T748"><vh>BOGUS_Column16</vh></v>
<v t="T749"><vh>BOGUS_Column</vh></v>
<v t="T750"><vh>BOGUS_DrawArea</vh></v>
<v t="T751"><vh>R2_DrawMaskedWPost</vh></v>
<v t="T752"><vh>R2_MapWallColumn</vh></v>
<v t="T753"><vh>R2_DrawWall</vh></v>
<v t="T754"><vh>R2_MapPlaneRow</vh></v>
<v t="T755"><vh>R2_MakeSpans</vh></v>
<v t="T756"><vh>R2_DrawPlane</vh></v>
<v t="T757"><vh>R2_DrawThing</vh></v>
<v t="T758"><vh>R2_DrawSortThings</vh></v>
<v t="T759"><vh>R2_DrawFloor</vh></v>
<v t="T760"><vh>R2_DrawSubsector</vh></v>
<v t="T761"><vh>R2_DrawSkyPlane</vh></v>
<v t="T762"><vh>R2_DrawPSprite</vh></v>
<v t="T763"><vh>R2_DrawPlayerSprites</vh></v>
<v t="T2797"><vh>Video context stuff</vh>
<v t="T764"><vh>R2_ClipLine</vh></v>
<v t="T765"><vh>R2_NewScreenSize</vh></v>
<v t="T766"><vh>R2_RenderScene</vh></v>
<v t="T767"><vh>R2_BeginDraw</vh></v>
<v t="T768"><vh>R2_EndDraw</vh></v>
<v t="T769"><vh>DrawImagePost</vh></v>
<v t="T770"><vh>DrawImageBlock</vh></v>
<v t="T771"><vh>R2_DrawImage</vh></v>
<v t="T772"><vh>R2_SolidBox</vh></v>
<v t="T773"><vh>R2_SolidLine</vh></v>
<v t="T774"><vh>R2_ReadScreen</vh></v>
</v>
<v t="T775"><vh>R2_Init</vh></v>
</v>
<v t="T776"><vh>@file r2_util.c</vh>
<v t="T777"><vh>&lt;&lt; r2_util #includes &gt;&gt;</vh></v>
<v t="T778"><vh>&lt;&lt; r2_util declarations &gt;&gt;</vh></v>
<v t="T779"><vh>R2_InitUtil</vh></v>
<v t="T780"><vh>R2_ClearBSP</vh></v>
<v t="T781"><vh>R2_GetDrawWall</vh></v>
<v t="T782"><vh>R2_GetDrawPlane</vh></v>
<v t="T783"><vh>R2_GetDrawThing</vh></v>
<v t="T784"><vh>R2_GetDrawFloor</vh></v>
<v t="T785"><vh>R2_CommitDrawWall</vh></v>
<v t="T786"><vh>R2_CommitDrawPlane</vh></v>
<v t="T787"><vh>R2_CommitDrawThing</vh></v>
<v t="T788"><vh>R2_CommitDrawFloor</vh></v>
<v t="T789"><vh>R2_FreeupBSP</vh></v>
<v t="T790"><vh>R2_InitOpenings</vh></v>
<v t="T791"><vh>R2_StartOpenings</vh></v>
<v t="T792"><vh>R2_GetOpenings</vh></v>
<v t="T793"><vh>R2_CommitOpenings</vh></v>
<v t="T794"><vh>R2_1DOcclusionClear</vh></v>
<v t="T795"><vh>R2_1DOcclusionSet</vh></v>
<v t="T796"><vh>R2_1DOcclusionTest</vh></v>
<v t="T797"><vh>R2_1DOcclusionTestShrink</vh></v>
<v t="T798"><vh>R2_1DOcclusionClose</vh></v>
<v t="T799"><vh>R2_2DOcclusionClear</vh></v>
<v t="T800"><vh>R2_2DOcclusionClose</vh></v>
<v t="T801"><vh>R2_2DOcclusionCopy</vh></v>
<v t="T802"><vh>R2_2DUpdate1D</vh></v>
<v t="T803"><vh>R2_TileSkyClear</vh></v>
<v t="T804"><vh>R2_TileSkyAdd</vh></v>
<v t="T805"><vh>R2_GetPointLOD</vh></v>
<v t="T806"><vh>R2_GetBBoxLOD</vh></v>
<v t="T807"><vh>R2_GetWallLOD</vh></v>
<v t="T808"><vh>R2_GetPlaneLOD</vh></v>
</v>
</v>
<v t="T2514"><vh>r_*.c (drawing)</vh>
<v t="T809"><vh>@file r_bsp.c</vh>
<v t="T810"><vh>&lt;&lt; r_bsp #includes &gt;&gt;</vh></v>
</v>
<v t="T811"><vh>@file r_data.c</vh>
<v t="T812"><vh>&lt;&lt; r_data #includes &gt;&gt;</vh></v>
<v t="T813"><vh>R_AddFlatAnim</vh></v>
<v t="T814"><vh>R_AddTextureAnim</vh></v>
<v t="T815"><vh>R_InitFlats</vh></v>
<v t="T816"><vh>R_InitPicAnims</vh></v>
<v t="T817"><vh>R_PrecacheSprites</vh></v>
<v t="T818"><vh>R_PrecacheLevel</vh></v>
</v>
<v t="T819" a="M"><vh>@file r_draw1.c (drawing to the view buffer)</vh>
<v t="T820"><vh>&lt;&lt; r_draw1 #includes &gt;&gt;</vh></v>
<v t="T821"><vh>&lt;&lt; r_draw1 declarations &gt;&gt;</vh></v>
<v t="T822"><vh>ColSmoothingOn</vh></v>
<v t="T823"><vh>ColSmoothingOff</vh></v>
<v t="T824"><vh>SpanSmoothingOn</vh></v>
<v t="T825"><vh>SpanSmoothingOff</vh></v>
<v t="T826"><vh>BLF_Init8</vh></v>
<v t="T827"><vh>resinit_r_draw_c8</vh></v>
<v t="T828"><vh>R_DrawColumn8_CVersion</vh></v>
<v t="T829"><vh>R_DrawColumn8_MIP</vh></v>
<v t="T830"><vh>R_DrawTranslucentColumn8_MIP</vh></v>
<v t="T831"><vh>R_DrawHaloColumn8_MIP</vh></v>
<v t="T832"><vh>R_DrawColumn8_dontdraw</vh></v>
<v t="T833"><vh>R_DrawSpan8_dontdraw</vh></v>
<v t="T834" a="M"><vh>R_DrawColumn8_MIP</vh></v>
<v t="T835" a="M"><vh>R_DrawColumn8_vfi</vh></v>
<v t="T836"><vh>R_DrawSpan8_vfi</vh></v>
<v t="T837"><vh>R_DrawColumn8_KM</vh></v>
<v t="T838"><vh>R_DrawColumn8_BLF</vh></v>
<v t="T839"><vh>R_DrawFuzzColumn8</vh></v>
<v t="T840"><vh>R_DrawTranslucentColumn8</vh></v>
<v t="T841"><vh>R_DrawTranslatedColumn8</vh></v>
<v t="T842"><vh>R_DrawTranslucentTranslatedColumn8</vh></v>
<v t="T843"><vh>R_DrawSpan8_CVersion</vh></v>
<v t="T844"><vh>R_DrawSpan8_MIP</vh></v>
<v t="T845"><vh>R_DrawTranslucentSpan8_MIP</vh></v>
<v t="T846"><vh>R_DrawHoleySpan8_MIP</vh></v>
<v t="T847"><vh>R_DrawTranslucentSpan8</vh></v>
<v t="T848"><vh>R_DrawSpan8_MIP</vh></v>
<v t="T849"><vh>R_DrawSpan8_KM</vh></v>
<v t="T2799"><vh>Bilinear filtering</vh>
<v t="T850"><vh>R_DrawSpan8_BLF</vh></v>
<v t="T851"><vh>R_InitFunctions_Draw1</vh></v>
<v t="T852"><vh>R_FillBackScreen8</vh></v>
<v t="T853"><vh>R_VideoErase8</vh></v>
<v t="T854"><vh>R_DrawViewBorder8</vh></v>
</v>
</v>
<v t="T855"><vh>@file r_draw2.c</vh>
<v t="T856"><vh>&lt;&lt; r_draw2 #includes &gt;&gt;</vh></v>
<v t="T857"><vh>&lt;&lt; r_draw2 declarations &gt;&gt;</vh></v>
<v t="T858"><vh>ColSmoothingOn</vh></v>
<v t="T859"><vh>ColSmoothingOff</vh></v>
<v t="T860"><vh>SpanSmoothingOn</vh></v>
<v t="T861"><vh>SpanSmoothingOff</vh></v>
<v t="T862"><vh>BLF_Init16</vh></v>
<v t="T863"><vh>resinit_r_draw_c16</vh></v>
<v t="T864"><vh>R_DrawColumn16_CVersion</vh></v>
<v t="T865"><vh>R_DrawColumn16_MIP</vh></v>
<v t="T866"><vh>R_DrawTranslucentColumn16_MIP</vh></v>
<v t="T867"><vh>R_DrawColumn16_KM</vh></v>
<v t="T868"><vh>R_DrawColumn16_BLF</vh></v>
<v t="T869"><vh>R_DrawFuzzColumn16</vh></v>
<v t="T870"><vh>R_DrawTranslucentColumn16</vh></v>
<v t="T871"><vh>R_DrawTranslatedColumn16</vh></v>
<v t="T872"><vh>R_DrawTranslucentTranslatedColumn16</vh></v>
<v t="T873"><vh>R_DrawSpan16_CVersion</vh></v>
<v t="T874"><vh>R_DrawSpan16_MIP</vh></v>
<v t="T875"><vh>R_DrawTranslucentSpan16_MIP</vh></v>
<v t="T876"><vh>R_DrawHoleySpan16_MIP</vh></v>
<v t="T877"><vh>R_DrawTranslucentSpan16</vh></v>
<v t="T878"><vh>R_DrawSpan16_KM</vh></v>
<v t="T879"><vh>R_DrawSpan16_BLF</vh></v>
<v t="T880"><vh>R_InitFunctions_Draw2</vh></v>
<v t="T881"><vh>R_FillBackScreen16</vh></v>
<v t="T882"><vh>R_VideoErase16</vh></v>
<v t="T883"><vh>R_DrawViewBorder16</vh></v>
</v>
<v t="T884"><vh>@file r_layers.c</vh>
<v t="T885"><vh>&lt;&lt; r_layers #includes &gt;&gt;</vh></v>
<v t="T886"><vh>&lt;&lt; r_layers declarations &gt;&gt;</vh></v>
<v t="T887"><vh>R_LayerInit</vh></v>
<v t="T888"><vh>R_LayerNew</vh></v>
<v t="T889"><vh>R_LayerDestroy</vh></v>
<v t="T890"><vh>R_LayerAdd</vh></v>
<v t="T891"><vh>R_LayerRemove</vh></v>
<v t="T892"><vh>R_LayerEnable</vh></v>
<v t="T893"><vh>R_LayerDisable</vh></v>
<v t="T894"><vh>R_LayerChangeBounds</vh></v>
<v t="T895"><vh>R_LayerChangeFlags</vh></v>
<v t="T896"><vh>R_LayerChangeContents</vh></v>
<v t="T897"><vh>R_LayerClipRectToSolids</vh></v>
<v t="T898"><vh>ListenLayersRecursive</vh></v>
<v t="T899"><vh>R_ListenLayers</vh></v>
<v t="T900"><vh>ResizeLayerList</vh></v>
<v t="T901"><vh>R_ResizeLayers</vh></v>
<v t="T902"><vh>DL_Init</vh></v>
<v t="T903"><vh>DL_CleanUp</vh></v>
<v t="T904"><vh>DL_Query</vh></v>
<v t="T905"><vh>DL_Draw</vh></v>
<v t="T906"><vh>R_DrawLayers</vh></v>
</v>
<v t="T907"><vh>@file r_main.c</vh>
<v t="T908"><vh>&lt;&lt; r_main #includes &gt;&gt;</vh></v>
<v t="T909"><vh>&lt;&lt; r_main declarations &gt;&gt;</vh></v>
<v t="T910"><vh>R_Render_Standard</vh></v>
<v t="T911"><vh>R_PointToAngle</vh></v>
<v t="T912"><vh>R_PointToDist</vh></v>
<v t="T913"><vh>R_ScaleFromGlobalAngle</vh></v>
<v t="T914"><vh>InitTextureMapping</vh></v>
<v t="T915"><vh>InitLightTables</vh></v>
<v t="T916"><vh>R_SetViewSize</vh></v>
<v t="T917"><vh>InitViews</vh></v>
<v t="T918"><vh>R_ExecuteSetViewSize</vh></v>
<v t="T919"><vh>R_SetFOV</vh></v>
<v t="T920"><vh>R_SetNormalFOV</vh></v>
<v t="T921"><vh>R_SetZoomedFOV</vh></v>
<v t="T922"><vh>R_ChangeResolution</vh></v>
<v t="T923"><vh>DoExecuteChangeResolution</vh></v>
<v t="T924"><vh>R_ExecuteChangeResolution</vh></v>
<v t="T925"><vh>R_Init</vh></v>
<v t="T926"><vh>R_PointInSubsector</vh></v>
<v t="T927"><vh>R_PointGetProps</vh></v>
<v t="T928"><vh>R_StartFading</vh></v>
<v t="T929"><vh>SetupFrame</vh></v>
<v t="T930"><vh>R_RenderViewBitmap</vh></v>
<v t="T931"><vh>R_SetActiveViewBitmap</vh></v>
<v t="T932"><vh>R_SetActiveView</vh></v>
</v>
<v t="T933"><vh>@file r_plane.c</vh>
<v t="T934"><vh>&lt;&lt; r_plane #includes &gt;&gt;</vh></v>
</v>
<v t="T935"><vh>@file r_segs.c</vh>
<v t="T936"><vh>&lt;&lt; r_segs #includes &gt;&gt;</vh></v>
</v>
<v t="T937"><vh>@file r_sky.c</vh>
<v t="T938"><vh>&lt;&lt; r_sky #includes &gt;&gt;</vh></v>
<v t="T939"><vh>&lt;&lt; r_sky declarations &gt;&gt;</vh></v>
<v t="T940"><vh>R_InitSkyMap</vh></v>
<v t="T941"><vh>R_ComputeSkyHeights</vh></v>
</v>
<v t="T942"><vh>@file r_things.c</vh>
<v t="T943"><vh>&lt;&lt; r_things #includes &gt;&gt;</vh></v>
<v t="T944"><vh>&lt;&lt; r_things declarations &gt;&gt;</vh></v>
<v t="T945"><vh>R_AddSpriteName</vh></v>
<v t="T946"><vh>InstallSpriteLump</vh></v>
<v t="T947"><vh>FillSpriteFrames</vh></v>
<v t="T948"><vh>MarkCompletedFrames</vh></v>
<v t="T949"><vh>CheckSpriteFrames</vh></v>
<v t="T950"><vh>R_InitSprites</vh></v>
</v>
<v t="T951"><vh>@file r_vbinit.c</vh>
<v t="T952"><vh>&lt;&lt; r_vbinit #includes &gt;&gt;</vh></v>
<v t="T953"><vh>&lt;&lt; r_vbinit declarations &gt;&gt;</vh></v>
<v t="T954"><vh>R_EnlargeView8_2_2_CVersion</vh></v>
<v t="T955"><vh>R_EnlargeView16_2_2_CVersion</vh></v>
<v t="T956"><vh>R_EnlargeView8_2_2_Blur</vh></v>
<v t="T957"><vh>R_EnlargeView_2_2</vh></v>
<v t="T958"><vh>BlurViewStrong8</vh></v>
<v t="T959"><vh>BlurViewLight8</vh></v>
<v t="T960"><vh>CheckDetailChange</vh></v>
<v t="T961"><vh>AutoDetailViewFunc</vh></v>
<v t="T962"><vh>MakeViewAutoDetail</vh></v>
<v t="T963"><vh>MakeVBAutoDetail</vh></v>
<v t="T964"><vh>InitVB_Classic</vh></v>
<v t="T965"><vh>InitVB_Classic_2y</vh></v>
<v t="T966"><vh>InitVB_LowDetail</vh></v>
<v t="T967"><vh>InitVB_LDE</vh></v>
<v t="T968"><vh>InitVB_AutoDetail</vh></v>
<v t="T969"><vh>InitVB_BlurLight</vh></v>
<v t="T970"><vh>InitVB_BlurStrong</vh></v>
<v t="T971"><vh>InitVB_NViews</vh></v>
<v t="T972"><vh>InitVB_3Views</vh></v>
<v t="T973"><vh>InitVB_10Views</vh></v>
<v t="T974"><vh>CameraFrameInit_StdObject</vh></v>
<v t="T975"><vh>R_InitCamera_StdObject</vh></v>
<v t="T976"><vh>CameraFrameInit_StdPlayer</vh></v>
<v t="T977"><vh>R_InitCamera_StdPlayer</vh></v>
<v t="T978"><vh>CameraFrameInit_ViewOffs</vh></v>
<v t="T979"><vh>R_InitCamera_ViewOffs</vh></v>
<v t="T980"><vh>CameraFrameInit_3D_Left</vh></v>
<v t="T981"><vh>CameraFrameInit_3D_Right</vh></v>
<v t="T982"><vh>R_InitCamera_3D_Left</vh></v>
<v t="T983"><vh>R_InitCamera_3D_Right</vh></v>
<v t="T984"><vh>FinishVB_3D_Left</vh></v>
<v t="T985"><vh>FinishVB_3D_Right</vh></v>
<v t="T986"><vh>R_InitVB_3D_Left</vh></v>
<v t="T987"><vh>R_InitVB_3D_Right</vh></v>
<v t="T988"><vh>R_InitVBFunctions</vh></v>
</v>
<v t="T989"><vh>@file r_view.c</vh>
<v t="T990"><vh>&lt;&lt; r_view #includes &gt;&gt;</vh></v>
<v t="T991"><vh>&lt;&lt; r_view declarations &gt;&gt;</vh></v>
<v t="T992"><vh>R_DestroyCallbackList</vh></v>
<v t="T993"><vh>R_CallCallbackList</vh></v>
<v t="T994"><vh>R_AddStartCallback</vh></v>
<v t="T995"><vh>R_AddEndCallback</vh></v>
<v t="T996"><vh>R_DestroyViewBitmap</vh></v>
<v t="T997"><vh>R_CreateViewBitmap</vh></v>
<v t="T998"><vh>R_DestroyAspect</vh></v>
<v t="T999"><vh>R_AspectChangeY</vh></v>
<v t="T1000"><vh>R_AspectChangeX</vh></v>
<v t="T1001"><vh>R_CreateAspect</vh></v>
<v t="T1002"><vh>ViewRemoveFromVBList</vh></v>
<v t="T1003"><vh>R_ViewClearAspect</vh></v>
<v t="T1004"><vh>R_DestroyView</vh></v>
<v t="T1005"><vh>ViewSetVBXPos</vh></v>
<v t="T1006"><vh>ViewSetVBYPos</vh></v>
<v t="T1007"><vh>R_ViewSetAspectXPos</vh></v>
<v t="T1008"><vh>ViewSetAspectYPos</vh></v>
<v t="T1009"><vh>R_ViewSetYPosition</vh></v>
<v t="T1010"><vh>R_ViewSetXPosition</vh></v>
<v t="T1011"><vh>ViewSetPosition</vh></v>
<v t="T1012"><vh>R_ViewSetAspect</vh></v>
<v t="T1013"><vh>R_CreateView</vh></v>
<v t="T1014"><vh>R_DestroyCamera</vh></v>
<v t="T1015"><vh>R_CreateCamera</vh></v>
</v>
</v>
<v t="T2515" a="M"><vh>rad_*.c (action triggers)</vh>
<v t="T1016"><vh>@file rad_act.c</vh>
<v t="T1017"><vh>&lt;&lt; rad_act #includes &gt;&gt;</vh></v>
<v t="T1018"><vh>&lt;&lt; rad_act declarations &gt;&gt;</vh></v>
<v t="T1019"><vh>RAD_InitTips</vh></v>
<v t="T1020"><vh>RAD_ResetTips</vh></v>
<v t="T1021"><vh>SetupTip</vh></v>
<v t="T1022"><vh>FinishTip</vh></v>
<v t="T1023"><vh>SendTip</vh></v>
<v t="T1024"><vh>RAD_DisplayTips</vh></v>
<v t="T1025"><vh>RAD_Ticker</vh></v>
<v t="T2800"><vh>Trigger actions</vh>
<v t="T1026"><vh>RAD_ActNOP</vh></v>
<v t="T1027"><vh>RAD_ActTip</vh></v>
<v t="T1028"><vh>RAD_ActTipProps</vh></v>
<v t="T1029"><vh>RAD_ActSpawnThing</vh></v>
<v t="T1030"><vh>RAD_ActDamagePlayers</vh></v>
<v t="T1031"><vh>RAD_ActHealPlayers</vh></v>
<v t="T1032"><vh>RAD_ActArmourPlayers</vh></v>
<v t="T1033"><vh>RAD_ActBenefitPlayers</vh></v>
<v t="T1034"><vh>RAD_ActDamageMonsters</vh></v>
<v t="T1035"><vh>RAD_ActThingEvent</vh></v>
<v t="T1036"><vh>RAD_ActGotoMap</vh></v>
<v t="T1037"><vh>RAD_ActExitLevel</vh></v>
<v t="T1038"><vh>RAD_ActPlaySound</vh></v>
<v t="T1039"><vh>RAD_ActKillSound</vh></v>
<v t="T1040"><vh>RAD_ActChangeMusic</vh></v>
<v t="T1041"><vh>RAD_ActChangeTex</vh></v>
<v t="T1042"><vh>RAD_ActSkill</vh></v>
<v t="T1043"><vh>MoveOneSector</vh></v>
<v t="T1044"><vh>RAD_ActMoveSector</vh></v>
<v t="T1045"><vh>LightOneSector</vh></v>
<v t="T1046"><vh>RAD_ActLightSector</vh></v>
<v t="T1047"><vh>RAD_ActEnableScript</vh></v>
<v t="T1048"><vh>RAD_ActActivateLinetype</vh></v>
<v t="T1049"><vh>RAD_ActUnblockLines</vh></v>
<v t="T1050"><vh>RAD_ActJump</vh></v>
<v t="T1051"><vh>RAD_ActSleep</vh></v>
<v t="T1052"><vh>RAD_ActRetrigger</vh></v>
</v>
</v>
<v t="T1053"><vh>@file rad_pars.c</vh>
<v t="T1054"><vh>&lt;&lt; rad_pars #includes &gt;&gt;</vh></v>
<v t="T1055"><vh>&lt;&lt; rad_pars declarations &gt;&gt;</vh></v>
<v t="T1056"><vh>RAD_StringHashFunc</vh></v>
<v t="T1057"><vh>RAD_Error</vh></v>
<v t="T1058"><vh>RAD_Warning</vh></v>
<v t="T1059"><vh>RAD_WarnError</vh></v>
<v t="T1060"><vh>RAD_ErrorSetLineData</vh></v>
<v t="T1061"><vh>RAD_ErrorClearLineData</vh></v>
<v t="T1062"><vh>CheckForDefine</vh></v>
<v t="T1063"><vh>RAD_CheckForInt</vh></v>
<v t="T1064"><vh>RAD_CheckForFloat</vh></v>
<v t="T1065"><vh>RAD_CheckForPercent</vh></v>
<v t="T1066"><vh>RAD_CheckForPercentAny</vh></v>
<v t="T1067"><vh>RAD_CheckForTime</vh></v>
<v t="T1068"><vh>RAD_CheckForArmourType</vh></v>
<v t="T1069"><vh>RAD_CheckForChangetexType</vh></v>
<v t="T1070"><vh>RAD_UnquoteString</vh></v>
<v t="T1071"><vh>CheckForBoolean</vh></v>
<v t="T1072"><vh>DoParseWhenAppear</vh></v>
<v t="T1073"><vh>DoParsePlayerSet</vh></v>
<v t="T1074"><vh>AddStateToScript</vh></v>
<v t="T1075"><vh>ClearOneScript</vh></v>
<v t="T1076"><vh>ClearPreviousScripts</vh></v>
<v t="T1077"><vh>ClearAllScripts</vh></v>
<v t="T1078"><vh>RAD_ComputeScriptCRC</vh></v>
<v t="T1079"><vh>RAD_CollectParameters</vh></v>
<v t="T1080"><vh>RAD_FreeParameters</vh></v>
<v t="T1081"><vh>RAD_ParseVersion</vh></v>
<v t="T1082"><vh>RAD_ParseClearAll</vh></v>
<v t="T1083"><vh>RAD_ParseDefine</vh></v>
<v t="T1084"><vh>RAD_ParseStartMap</vh></v>
<v t="T1085"><vh>RAD_ParseRadiusTrigger</vh></v>
<v t="T1086"><vh>RAD_ParseEndRadiusTrigger</vh></v>
<v t="T1087"><vh>RAD_ParseEndMap</vh></v>
<v t="T1088"><vh>RAD_ParseName</vh></v>
<v t="T1089"><vh>RAD_ParseTag</vh></v>
<v t="T1090"><vh>RAD_ParseWhenAppear</vh></v>
<v t="T1091"><vh>RAD_ParseWhenPlayerNum</vh></v>
<v t="T1092"><vh>RAD_ParseNetMode</vh></v>
<v t="T1093"><vh>RAD_ParseTaggedRepeatable</vh></v>
<v t="T1094"><vh>RAD_ParseTaggedUse</vh></v>
<v t="T1095"><vh>RAD_ParseTaggedIndependent</vh></v>
<v t="T1096"><vh>RAD_ParseTaggedImmediate</vh></v>
<v t="T1097"><vh>RAD_ParseTaggedPlayerSpecific</vh></v>
<v t="T1098"><vh>RAD_ParseTaggedDisabled</vh></v>
<v t="T1099"><vh>RAD_ParseTaggedPath</vh></v>
<v t="T1100"><vh>RAD_ParsePathEvent</vh></v>
<v t="T1101"><vh>RAD_ParseOnDeath</vh></v>
<v t="T1102"><vh>RAD_ParseOnHeight</vh></v>
<v t="T1103"><vh>RAD_ParseOnCondition</vh></v>
<v t="T1104"><vh>RAD_ParseLabel</vh></v>
<v t="T1105"><vh>RAD_ParseEnableScript</vh></v>
<v t="T1106"><vh>RAD_ParseEnableTagged</vh></v>
<v t="T1107"><vh>RAD_ParseExitLevel</vh></v>
<v t="T1108"><vh>RAD_ParseTip</vh></v>
<v t="T1109"><vh>RAD_ParseTipSlot</vh></v>
<v t="T1110"><vh>RAD_ParseTipPos</vh></v>
<v t="T1111"><vh>RAD_ParseTipColour</vh></v>
<v t="T1112"><vh>RAD_ParseTipTrans</vh></v>
<v t="T1113"><vh>RAD_ParseTipAlign</vh></v>
<v t="T1114"><vh>RAD_ParseSpawnThing</vh></v>
<v t="T1115"><vh>RAD_ParsePlaySound</vh></v>
<v t="T1116"><vh>RAD_ParseKillSound</vh></v>
<v t="T1117"><vh>RAD_ParseChangeMusic</vh></v>
<v t="T1118"><vh>RAD_ParseDamagePlayer</vh></v>
<v t="T1119"><vh>RAD_ParseHealPlayer</vh></v>
<v t="T1120"><vh>RAD_ParseGiveArmour</vh></v>
<v t="T1121"><vh>RAD_ParseGiveLoseBenefit</vh></v>
<v t="T1122"><vh>RAD_ParseDamageMonsters</vh></v>
<v t="T1123"><vh>RAD_ParseThingEvent</vh></v>
<v t="T1124"><vh>RAD_ParseSkill</vh></v>
<v t="T1125"><vh>RAD_ParseGotoMap</vh></v>
<v t="T1126"><vh>RAD_ParseMoveSector</vh></v>
<v t="T1127"><vh>RAD_ParseLightSector</vh></v>
<v t="T1128"><vh>RAD_ParseActivateLinetype</vh></v>
<v t="T1129"><vh>RAD_ParseUnblockLines</vh></v>
<v t="T1130"><vh>RAD_ParseWait</vh></v>
<v t="T1131"><vh>RAD_ParseJump</vh></v>
<v t="T1132"><vh>RAD_ParseSleep</vh></v>
<v t="T1133"><vh>RAD_ParseRetrigger</vh></v>
<v t="T1134"><vh>RAD_ParseChangeTex</vh></v>
<v t="T1135"><vh>RAD_ParseLine</vh></v>
<v t="T1136"><vh>RAD_ParserBegin</vh></v>
<v t="T1137"><vh>RAD_ParserDone</vh></v>
</v>
<v t="T1138" a="M"><vh>@file rad_trig.c</vh>
<v t="T1139"><vh>&lt;&lt; rad_trig #includes &gt;&gt;</vh></v>
<v t="T1140"><vh>&lt;&lt; rad_trig declarations &gt;&gt;</vh></v>
<v t="T1141"><vh>RAD_FindScriptByName</vh></v>
<v t="T1142"><vh>RAD_FindTriggerByName</vh></v>
<v t="T1143"><vh>RAD_FindStateByLabel</vh></v>
<v t="T1144"><vh>RAD_EnableByTag</vh></v>
<v t="T1145"><vh>RAD_WithinRadius</vh></v>
<v t="T1146"><vh>RAD_CheckBossTrig</vh></v>
<v t="T1147"><vh>RAD_CheckHeightTrig</vh></v>
<v t="T1148"><vh>RAD_CheckReachedTrigger</vh></v>
<v t="T1149"><vh>DoRemoveTrigger</vh></v>
<v t="T1150" a="M"><vh>RAD_DoRadiTrigger</vh>
<v t="T2801"><vh>&lt;&lt; handle trigger trig &gt;&gt;</vh>
<v t="T2802"><vh>&lt;&lt; handle trig &gt;&gt;</vh></v>
<v t="T2803"><vh>&lt;&lt; Execute the commands &gt;&gt;</vh></v>
</v>
</v>
<v t="T1151"><vh>RAD_GroupTriggerTags</vh></v>
<v t="T1152"><vh>RAD_SpawnTriggers</vh>
<v t="T2804"><vh>&lt;&lt; handle script scr &gt;&gt;</vh></v>
</v>
<v t="T1153"><vh>RAD_ClearCachedInfo</vh></v>
<v t="T1154"><vh>RAD_ClearTriggers</vh></v>
<v t="T1155"><vh>RAD_MainCacheFile</vh></v>
<v t="T1156"><vh>RAD_ParseScript</vh></v>
<v t="T1157"><vh>RAD_LoadLump</vh></v>
<v t="T1158"><vh>RAD_LoadFile</vh></v>
<v t="T1159"><vh>RAD_Init</vh></v>
<v t="T1160"><vh>RAD_LoadParam</vh></v>
</v>
</v>
<v t="T2516" a="V"><vh>rgs_*.c (rendering-wipes)</vh>
<v t="T1161"><vh>@file rgl_bsp.c</vh>
<v t="T1162"><vh>&lt;&lt; rgl_bsp #includes &gt;&gt;</vh></v>
<v t="T1163"><vh>&lt;&lt; rgl_bsp declarations &gt;&gt;</vh></v>
<v t="T1164"><vh>RGL_Light</vh></v>
<v t="T1165"><vh>WallCoordFunc</vh></v>
<v t="T1166"><vh>PlaneCoordFunc</vh></v>
<v t="T1167"><vh>RGL_DrawWall</vh></v>
<v t="T1168"><vh>RGL_BuildWalls</vh></v>
<v t="T1169"><vh>RGL_WalkWall</vh></v>
<v t="T1170"><vh>RGL_WalkSeg</vh></v>
<v t="T1171"><vh>RGL_CheckBBox</vh></v>
<v t="T1172"><vh>RGL_DrawPlane</vh></v>
<v t="T1173"><vh>RGL_WalkThing</vh></v>
<v t="T1174"><vh>RGL_DrawThing</vh></v>
<v t="T1175"><vh>RGL_DrawSortThings</vh></v>
<v t="T1176"><vh>LightUpPlayerWeapon</vh></v>
<v t="T1177"><vh>AddNewDrawFloor</vh></v>
<v t="T1178"><vh>RGL_WalkSubsector</vh></v>
<v t="T1179"><vh>RGL_DrawSubsector</vh></v>
<v t="T1180"><vh>RGL_WalkBSPNode</vh></v>
<v t="T1181" a="M"><vh>RGL_RenderTrueBSP</vh></v>
<v t="T1182"><vh>RGL_RenderScene</vh></v>
</v>
<v t="T1183"><vh>@file rgl_main.c</vh>
<v t="T1184"><vh>&lt;&lt; rgl_main #includes &gt;&gt;</vh></v>
<v t="T1185"><vh>&lt;&lt; rgl_main declarations &gt;&gt;</vh></v>
<v t="T1186"><vh>SetupLightMap</vh></v>
<v t="T1187"><vh>RGL_SetupMatrices2D</vh></v>
<v t="T1188"><vh>RGL_SetupMatrices3D</vh></v>
<v t="T1189"><vh>RGL_DrawPSprite</vh></v>
<v t="T1190"><vh>RGL_DrawPlayerSprites</vh></v>
<v t="T1191"><vh>RGL_RainbowEffect</vh></v>
<v t="T1192"><vh>RGL_ColourmapEffect</vh></v>
<v t="T1193"><vh>RGL_PaletteEffect</vh></v>
<v t="T2805"><vh>VIDEO CONTEXT STUFF</vh>
<v t="T1194"><vh>RGL_NewScreenSize</vh></v>
<v t="T1195"><vh>RGL_BeginDraw</vh></v>
<v t="T1196"><vh>RGL_EndDraw</vh></v>
<v t="T1197"><vh>RGL_DrawImage</vh></v>
<v t="T1198"><vh>RGL_SolidBox</vh></v>
<v t="T1199"><vh>RGL_SolidLine</vh></v>
<v t="T1200"><vh>RGL_ReadScreen</vh></v>
<v t="T1201"><vh>RGL_CheckExtensions</vh></v>
<v t="T1202"><vh>RGL_SoftInit</vh></v>
<v t="T1203"><vh>RGL_Init</vh></v>
</v>
</v>
<v t="T1204"><vh>@file rgl_sky.c</vh>
<v t="T1205"><vh>&lt;&lt; rgl_sky #includes &gt;&gt;</vh></v>
<v t="T1206"><vh>DrawSkyTilePoint</vh></v>
<v t="T1207"><vh>DrawSkyTilePart</vh></v>
<v t="T1208"><vh>RGL_DrawTiledSky</vh></v>
<v t="T1209"><vh>RGL_DrawSky</vh></v>
<v t="T1210"><vh>CalcSkyTexCoord</vh></v>
<v t="T1211"><vh>SkyPolyCoordFunc</vh></v>
<v t="T1212"><vh>RGL_DrawSkyPlane</vh></v>
<v t="T1213"><vh>RGL_DrawSkyWall</vh></v>
</v>
<v t="T1214"><vh>@file rgl_tex.c</vh>
<v t="T1215"><vh>&lt;&lt; rgl_tex #includes &gt;&gt;</vh></v>
</v>
<v t="T1216"><vh>@file rgl_unit.c</vh>
<v t="T1217"><vh>&lt;&lt; rgl_unit #includes &gt;&gt;</vh></v>
<v t="T1218"><vh>&lt;&lt; rgl_unit declarations &gt;&gt;</vh></v>
<v t="T1219"><vh>RGL_InitUnits</vh></v>
<v t="T1220"><vh>RGL_StartUnits</vh></v>
<v t="T1221"><vh>RGL_FinishUnits</vh></v>
<v t="T1222"><vh>RGL_BeginUnit</vh></v>
<v t="T1223"><vh>RGL_EndUnit</vh></v>
<v t="T1224"><vh>RGL_DrawUnits</vh></v>
<v t="T1225"><vh>RGL_1DOcclusionClear</vh></v>
<v t="T1226"><vh>RGL_1DOcclusionSet</vh></v>
<v t="T1227"><vh>RGL_1DOcclusionTest</vh></v>
<v t="T1228"><vh>RGL_NewPolyQuad</vh></v>
<v t="T1229"><vh>RGL_FreePolyQuad</vh></v>
<v t="T1230"><vh>RGL_BoundPolyQuad</vh></v>
<v t="T1231"><vh>RGL_DumpPolyQuad</vh></v>
<v t="T1232"><vh>RGL_DoSplitQuadVertSep</vh></v>
<v t="T1233"><vh>RGL_DoSplitQuadHorizSep</vh></v>
<v t="T1234"><vh>RGL_DoSplitQuadHoriz</vh></v>
<v t="T1235"><vh>RGL_DoSplitQuad</vh></v>
<v t="T1236"><vh>AddPolyDynPoint</vh></v>
<v t="T1237"><vh>AddPolyVertIntercept</vh></v>
<v t="T1238"><vh>AddPolyHorizIntercept</vh></v>
<v t="T1239"><vh>RGL_DoSplitPolyVert</vh></v>
<v t="T1240"><vh>RGL_DoSplitPolyHoriz</vh></v>
<v t="T1241"><vh>RGL_DoSplitPolyVertSep</vh></v>
<v t="T1242"><vh>RGL_DoSplitPolyHorizSep</vh></v>
<v t="T1243"><vh>RGL_DoSplitPolyListVert</vh></v>
<v t="T1244"><vh>RGL_DoSplitPolyListHoriz</vh></v>
<v t="T1245"><vh>RGL_DoSplitPolygon</vh></v>
<v t="T1246"><vh>RGL_SplitPolyQuad</vh></v>
<v t="T1247"><vh>RGL_SplitPolyQuadLOD</vh></v>
<v t="T1248"><vh>RGL_RenderPolyQuad</vh></v>
<v t="T1249"><vh>CreateTestQuad</vh></v>
<v t="T1250"><vh>CreateTestPolygon1</vh></v>
<v t="T1251"><vh>RGL_TestPolyQuads</vh></v>
</v>
<v t="T233"><vh>@file rgl_wipe.c</vh>
<v t="T234"><vh>&lt;&lt; rgl_wipe #includes &gt;&gt;</vh></v>
<v t="T235"><vh>&lt;&lt; rgl_wipe declarations &gt;&gt;</vh></v>
<v t="T236"><vh>SendWipeTexture</vh></v>
<v t="T237"><vh>CaptureScreenAsTexture</vh></v>
<v t="T238"><vh>RGL_Init_Melt</vh></v>
<v t="T239"><vh>RGL_Update_Melt</vh></v>
<v t="T240"><vh>RGL_InitWipe</vh></v>
<v t="T241"><vh>RGL_StopWipe</vh></v>
<v t="T242"><vh>RGL_Wipe_Fading</vh></v>
<v t="T243"><vh>RGL_Wipe_Melt</vh></v>
<v t="T244"><vh>RGL_Wipe_Slide</vh></v>
<v t="T245"><vh>RGL_Wipe_Doors</vh></v>
<v t="T246"><vh>RGL_DoWipe</vh></v>
</v>
</v>
<v t="T2517"><vh>s_*.c (music handline)</vh>
<v t="T247"><vh>@file s_music.c</vh>
<v t="T248"><vh>&lt;&lt; s_music #includes &gt;&gt;</vh></v>
<v t="T249"><vh>&lt;&lt; s_music declarations &gt;&gt;</vh></v>
<v t="T250"><vh>edgemin</vh></v>
<v t="T251"><vh>edgemax</vh></v>
<v t="T252"><vh>edgemid</vh></v>
<v t="T253"><vh>S_ChangeMusic</vh></v>
<v t="T254"><vh>S_ResumeMusic</vh></v>
<v t="T255"><vh>S_PauseMusic</vh></v>
<v t="T256"><vh>S_StopMusic</vh></v>
<v t="T257"><vh>S_MusicTicker</vh></v>
<v t="T258"><vh>S_GetMusicVolume</vh></v>
<v t="T259"><vh>S_SetMusicVolume</vh></v>
</v>
<v t="T260"><vh>@file s_sound.c</vh>
<v t="T261"><vh>&lt;&lt; s_sound #includes &gt;&gt;</vh></v>
<v t="T262"><vh>&lt;&lt; s_sound declarations &gt;&gt;</vh></v>
<v t="T263"><vh>edgemin</vh></v>
<v t="T264"><vh>edgemax</vh></v>
<v t="T265"><vh>edgemid</vh></v>
<v t="T266"><vh>InsertAtTail</vh></v>
<v t="T267"><vh>InsertAtHead</vh></v>
<v t="T268"><vh>UnlinkSound</vh></v>
<v t="T269"><vh>RemoveSoundFromCache</vh></v>
<v t="T270"><vh>GetSfxLumpNum</vh></v>
<v t="T271"><vh>CacheSound</vh></v>
<v t="T272"><vh>AdjustSoundParams</vh></v>
<v t="T273"><vh>GetSoundChannel</vh></v>
<v t="T274"><vh>StartSoundAtVolume</vh></v>
<v t="T275"><vh>FlushSoundCaches</vh></v>
<v t="T276"><vh>S_Init</vh></v>
<v t="T277"><vh>S_SoundLevelInit</vh></v>
<v t="T278"><vh>S_StartSound</vh></v>
<v t="T279"><vh>S_ResumeSounds</vh></v>
<v t="T280"><vh>S_PauseSounds</vh></v>
<v t="T281"><vh>S_StopSound</vh></v>
<v t="T282"><vh>S_RemoveSoundOrigin</vh></v>
<v t="T283"><vh>S_AddToFreeQueue</vh></v>
<v t="T284"><vh>S_UpdateSounds</vh></v>
<v t="T285"><vh>S_SoundTicker</vh></v>
<v t="T286"><vh>S_GetSfxVolume</vh></v>
<v t="T287"><vh>S_SetSfxVolume</vh></v>
<v t="T288"><vh>S_StopLoopingChannel</vh></v>
<v t="T289"><vh>S_StopLoopingSound</vh></v>
<v t="T290"><vh>S_StopChannel</vh></v>
</v>
</v>
<v t="T2518"><vh>st_*.c (status bar)</vh>
<v t="T291"><vh>@file st_lib.c</vh>
<v t="T292"><vh>&lt;&lt; st_lib #includes &gt;&gt;</vh></v>
<v t="T293"><vh>STLIB_Init</vh></v>
<v t="T294"><vh>STLIB_InitNum</vh></v>
<v t="T295"><vh>STLIB_InitFloat</vh></v>
<v t="T296"><vh>DrawNum</vh></v>
<v t="T297"><vh>STLIB_UpdateNum</vh></v>
<v t="T298"><vh>STLIB_UpdateFloat</vh></v>
<v t="T299"><vh>STLIB_InitPercent</vh></v>
<v t="T300"><vh>STLIB_UpdatePercent</vh></v>
<v t="T301"><vh>STLIB_InitMultIcon</vh></v>
<v t="T302"><vh>STLIB_UpdateMultIcon</vh></v>
<v t="T303"><vh>STLIB_InitBinIcon</vh></v>
<v t="T304"><vh>STLIB_UpdateBinIcon</vh></v>
</v>
<v t="T305"><vh>@file st_stuff.c</vh>
<v t="T306"><vh>&lt;&lt; st_stuff #includes &gt;&gt;</vh></v>
<v t="T307"><vh>&lt;&lt; st_stuff declarations &gt;&gt;</vh></v>
<v t="T308"><vh>RefreshBackground</vh></v>
<v t="T309"><vh>ST_Responder</vh></v>
<v t="T310"><vh>ST_CalcPainOffset</vh></v>
<v t="T311"><vh>DrawWidgets</vh></v>
<v t="T312"><vh>ST_UpdateFaceWidget</vh></v>
<v t="T313"><vh>UpdateWidgets</vh></v>
<v t="T314"><vh>ST_Ticker</vh></v>
<v t="T315"><vh>DoPaletteStuff</vh></v>
<v t="T316"><vh>DoRefresh</vh></v>
<v t="T317"><vh>DiffDraw</vh></v>
<v t="T318"><vh>ST_Drawer</vh></v>
<v t="T319"><vh>LoadGraphics</vh></v>
<v t="T320"><vh>LoadData</vh></v>
<v t="T321"><vh>UnloadGraphics</vh></v>
<v t="T322"><vh>UnloadData</vh></v>
<v t="T323"><vh>InitData</vh></v>
<v t="T324"><vh>CreateWidgets</vh></v>
<v t="T325"><vh>ST_Start</vh></v>
<v t="T326"><vh>ST_Stop</vh></v>
<v t="T327"><vh>ST_ReInit</vh></v>
<v t="T328"><vh>ST_Init</vh></v>
</v>
</v>
<v t="T2511"><vh>sv_*.c (save game)</vh>
<v t="T329"><vh>@file sv_chunk.c</vh>
<v t="T330"><vh>&lt;&lt; sv_chunk #includes &gt;&gt;</vh></v>
<v t="T331"><vh>&lt;&lt; sv_chunk declarations &gt;&gt;</vh></v>
<v t="T332"><vh>sizeof</vh></v>
<v t="T333"><vh>PutMagic</vh></v>
<v t="T334"><vh>PutPadding</vh></v>
<v t="T335"><vh>VerifyMarker</vh></v>
<v t="T336"><vh>SV_ChunkInit</vh></v>
<v t="T337"><vh>SV_ChunkShutdown</vh></v>
<v t="T338"><vh>SV_GetError</vh></v>
<v t="T339"><vh>SV_OpenReadFile</vh></v>
<v t="T340"><vh>SV_CloseReadFile</vh></v>
<v t="T341"><vh>SV_VerifyHeader</vh></v>
<v t="T342"><vh>SV_VerifyContents</vh></v>
<v t="T343"><vh>SV_GetByte</vh></v>
<v t="T344"><vh>SV_PushReadChunk</vh></v>
<v t="T345"><vh>SV_PopReadChunk</vh></v>
<v t="T346"><vh>SV_RemainingChunkSize</vh></v>
<v t="T347"><vh>SV_SkipReadChunk</vh></v>
<v t="T348"><vh>SV_OpenWriteFile</vh></v>
<v t="T349"><vh>SV_CloseWriteFile</vh></v>
<v t="T350"><vh>SV_PushWriteChunk</vh></v>
<v t="T351"><vh>SV_PopWriteChunk</vh></v>
<v t="T352"><vh>SV_PutByte</vh></v>
<v t="T353"><vh>SV_PutShort</vh></v>
<v t="T354"><vh>SV_PutInt</vh></v>
<v t="T355"><vh>SV_GetShort</vh></v>
<v t="T356"><vh>SV_GetInt</vh></v>
<v t="T357"><vh>SV_PutFixed</vh></v>
<v t="T358"><vh>SV_PutAngle</vh></v>
<v t="T359"><vh>SV_GetFixed</vh></v>
<v t="T360"><vh>SV_GetAngle</vh></v>
<v t="T361"><vh>SV_PutFloat</vh></v>
<v t="T362"><vh>SV_GetFloat</vh></v>
<v t="T363"><vh>SV_PutString</vh></v>
<v t="T364"><vh>SV_PutMarker</vh></v>
<v t="T365"><vh>SV_GetString</vh></v>
<v t="T366"><vh>SV_GetMarker</vh></v>
</v>
<v t="T367"><vh>@file sv_dump.c</vh>
<v t="T368"><vh>&lt;&lt; sv_dump #includes &gt;&gt;</vh></v>
<v t="T369"><vh>GlobDumpVARI</vh></v>
<v t="T370"><vh>GlobDumpWADS</vh></v>
<v t="T371"><vh>GlobDumpVIEW</vh></v>
<v t="T372"><vh>SV_DumpGLOB</vh></v>
<v t="T373"><vh>SV_DumpSTRU</vh></v>
<v t="T374"><vh>SV_DumpARRY</vh></v>
<v t="T375"><vh>SV_DumpDATA</vh></v>
<v t="T376"><vh>SV_DumpSaveGame</vh></v>
</v>
<v t="T377"><vh>@file sv_glob.c</vh>
<v t="T378"><vh>&lt;&lt; sv_glob #includes &gt;&gt;</vh></v>
<v t="T379"><vh>&lt;&lt; sv_glob declarations &gt;&gt;</vh></v>
<v t="T380"><vh>GV_GetInt</vh></v>
<v t="T381"><vh>GV_GetString</vh></v>
<v t="T382"><vh>GV_GetCheckCRC</vh></v>
<v t="T383"><vh>GV_GetLevelFlags</vh></v>
<v t="T384"><vh>GV_PutInt</vh></v>
<v t="T385"><vh>GV_PutString</vh></v>
<v t="T386"><vh>GV_PutCheckCRC</vh></v>
<v t="T387"><vh>GV_PutLevelFlags</vh></v>
<v t="T388"><vh>SV_NewGLOB</vh></v>
<v t="T389"><vh>SV_FreeGLOB</vh></v>
<v t="T390"><vh>GlobReadVARI</vh></v>
<v t="T391"><vh>GlobReadWADS</vh></v>
<v t="T392"><vh>GlobReadVIEW</vh></v>
<v t="T393"><vh>SV_LoadGLOB</vh></v>
<v t="T394"><vh>GlobWriteVARIs</vh></v>
<v t="T395"><vh>GlobWriteWADS</vh></v>
<v t="T396"><vh>GlobWriteVIEW</vh></v>
<v t="T397"><vh>SV_SaveGLOB</vh></v>
</v>
<v t="T398"><vh>@file sv_level.c</vh>
<v t="T399"><vh>&lt;&lt; sv_level #includes &gt;&gt;</vh></v>
<v t="T400"><vh>&lt;&lt; sv_level declarations &gt;&gt;</vh></v>
<v t="T401"><vh>SV_SideCountElems</vh></v>
<v t="T402"><vh>SV_SideGetElem</vh></v>
<v t="T403"><vh>SV_SideFindElem</vh></v>
<v t="T404"><vh>SV_SideCreateElems</vh></v>
<v t="T405"><vh>SV_SideFinaliseElems</vh></v>
<v t="T406"><vh>SV_LineCountElems</vh></v>
<v t="T407"><vh>SV_LineGetElem</vh></v>
<v t="T408"><vh>SV_LineFindElem</vh></v>
<v t="T409"><vh>SV_LineCreateElems</vh></v>
<v t="T410"><vh>SV_LineFinaliseElems</vh></v>
<v t="T411"><vh>SV_ExfloorCountElems</vh></v>
<v t="T412"><vh>SV_ExfloorGetElem</vh></v>
<v t="T413"><vh>SV_ExfloorFindElem</vh></v>
<v t="T414"><vh>SV_ExfloorCreateElems</vh></v>
<v t="T415"><vh>SV_ExfloorFinaliseElems</vh></v>
<v t="T416"><vh>SV_SectorCountElems</vh></v>
<v t="T417"><vh>SV_SectorGetElem</vh></v>
<v t="T418"><vh>SV_SectorFindElem</vh></v>
<v t="T419"><vh>SV_SectorCreateElems</vh></v>
<v t="T420"><vh>SV_SectorFinaliseElems</vh></v>
<v t="T421"><vh>SR_LevelGetSurface</vh></v>
<v t="T422"><vh>SR_LevelPutSurface</vh></v>
<v t="T423"><vh>SR_LevelGetSurfPtr</vh></v>
<v t="T424"><vh>SR_LevelPutSurfPtr</vh></v>
<v t="T425"><vh>SR_LevelGetImage</vh></v>
<v t="T426"><vh>SR_LevelPutImage</vh></v>
<v t="T427"><vh>SR_LevelGetColmap</vh></v>
<v t="T428"><vh>SR_LevelPutColmap</vh></v>
<v t="T429"><vh>SR_LineGetSpecial</vh></v>
<v t="T430"><vh>SR_LinePutSpecial</vh></v>
<v t="T431"><vh>SR_SectorGetSpecial</vh></v>
<v t="T432"><vh>SR_SectorPutSpecial</vh></v>
<v t="T433"><vh>SR_SectorGetProps</vh></v>
<v t="T434"><vh>SR_SectorPutProps</vh></v>
<v t="T435"><vh>SR_SectorGetPropRef</vh></v>
<v t="T436"><vh>SR_SectorPutPropRef</vh></v>
<v t="T437"><vh>SR_LineGetLine</vh></v>
<v t="T438"><vh>SR_LinePutLine</vh></v>
<v t="T439"><vh>SR_SectorGetSector</vh></v>
<v t="T440"><vh>SR_SectorPutSector</vh></v>
<v t="T441"><vh>SR_SectorGetEF</vh></v>
<v t="T442"><vh>SR_SectorPutEF</vh></v>
<v t="T443"><vh>SR_ExtrafloorGetInfo</vh></v>
<v t="T444"><vh>SR_ExtrafloorPutInfo</vh></v>
<v t="T445"><vh>SR_SectorGetGenMove</vh></v>
<v t="T446"><vh>SR_SectorPutGenMove</vh></v>
</v>
<v t="T447"><vh>@file sv_load.c</vh>
<v t="T448"><vh>&lt;&lt; sv_load #includes &gt;&gt;</vh></v>
<v t="T449"><vh>&lt;&lt; sv_load declarations &gt;&gt;</vh></v>
<v t="T450"><vh>AddLoadedStruct</vh></v>
<v t="T451"><vh>AddLoadedArray</vh></v>
<v t="T452"><vh>SV_LookupLoadedStruct</vh></v>
<v t="T453"><vh>SV_LookupLoadedArray</vh></v>
<v t="T454"><vh>SV_BeginLoad</vh></v>
<v t="T455"><vh>LoadFreeStruct</vh></v>
<v t="T456"><vh>LoadFreeArray</vh></v>
<v t="T457"><vh>SV_FinishLoad</vh></v>
<v t="T458"><vh>StructFindField</vh></v>
<v t="T459"><vh>StructSkipField</vh></v>
<v t="T460"><vh>SV_LoadStruct</vh></v>
<v t="T461"><vh>SV_LoadSTRU</vh></v>
<v t="T462"><vh>SV_LoadARRY</vh></v>
<v t="T463"><vh>SV_LoadDATA</vh></v>
<v t="T464"><vh>SV_LoadEverything</vh></v>
</v>
<v t="T465"><vh>@file sv_main.c</vh>
<v t="T466"><vh>&lt;&lt; sv_main #includes &gt;&gt;</vh></v>
<v t="T467"><vh>&lt;&lt; sv_main declarations &gt;&gt;</vh></v>
<v t="T468"><vh>SR_GetByte</vh></v>
<v t="T469"><vh>SR_GetShort</vh></v>
<v t="T470"><vh>SR_GetInt</vh></v>
<v t="T471"><vh>SR_GetFixed</vh></v>
<v t="T472"><vh>SR_GetAngle</vh></v>
<v t="T473"><vh>SR_GetFloat</vh></v>
<v t="T474"><vh>SR_GetVec2</vh></v>
<v t="T475"><vh>SR_GetVec3</vh></v>
<v t="T476"><vh>SR_GetIntAsFloat</vh></v>
<v t="T477"><vh>SR_PutByte</vh></v>
<v t="T478"><vh>SR_PutShort</vh></v>
<v t="T479"><vh>SR_PutInt</vh></v>
<v t="T480"><vh>SR_PutFixed</vh></v>
<v t="T481"><vh>SR_PutAngle</vh></v>
<v t="T482"><vh>SR_PutFloat</vh></v>
<v t="T483"><vh>SR_PutVec2</vh></v>
<v t="T484"><vh>SR_PutVec3</vh></v>
<v t="T485"><vh>AddKnownStruct</vh></v>
<v t="T486"><vh>AddKnownArray</vh></v>
<v t="T487"><vh>SV_MainInit</vh></v>
<v t="T488"><vh>SV_MainLookupStruct</vh></v>
<v t="T489"><vh>SV_MainLookupArray</vh></v>
<v t="T490"><vh>SV_MainTestPrimitives</vh></v>
</v>
<v t="T491"><vh>@file sv_misc.c</vh>
<v t="T492"><vh>&lt;&lt; sv_misc #includes &gt;&gt;</vh></v>
<v t="T493"><vh>&lt;&lt; sv_misc declarations &gt;&gt;</vh></v>
<v t="T494"><vh>SV_ButtonCountElems</vh></v>
<v t="T495"><vh>SV_ButtonGetElem</vh></v>
<v t="T496"><vh>SV_ButtonFindElem</vh></v>
<v t="T497"><vh>SV_ButtonCreateElems</vh></v>
<v t="T498"><vh>SV_ButtonFinaliseElems</vh></v>
<v t="T499"><vh>SV_LightCountElems</vh></v>
<v t="T500"><vh>SV_LightGetElem</vh></v>
<v t="T501"><vh>SV_LightFindElem</vh></v>
<v t="T502"><vh>SV_LightCreateElems</vh></v>
<v t="T503"><vh>SV_LightFinaliseElems</vh></v>
<v t="T504"><vh>SV_TriggerCountElems</vh></v>
<v t="T505"><vh>SV_TriggerGetElem</vh></v>
<v t="T506"><vh>SV_TriggerFindElem</vh></v>
<v t="T507"><vh>SV_TriggerCreateElems</vh></v>
<v t="T508"><vh>SV_TriggerFinaliseElems</vh></v>
<v t="T509"><vh>SV_TipCountElems</vh></v>
<v t="T510"><vh>SV_TipGetElem</vh></v>
<v t="T511"><vh>SV_TipFindElem</vh></v>
<v t="T512"><vh>SV_TipCreateElems</vh></v>
<v t="T513"><vh>SV_TipFinaliseElems</vh></v>
<v t="T514"><vh>SV_PlaneMoveCountElems</vh></v>
<v t="T515"><vh>SV_PlaneMoveGetElem</vh></v>
<v t="T516"><vh>SV_PlaneMoveFindElem</vh></v>
<v t="T517"><vh>SV_PlaneMoveCreateElems</vh></v>
<v t="T518"><vh>SV_PlaneMoveFinaliseElems</vh></v>
<v t="T519"><vh>SR_LightGetType</vh></v>
<v t="T520"><vh>SR_LightPutType</vh></v>
<v t="T521"><vh>SR_TriggerGetState</vh></v>
<v t="T522"><vh>SR_TriggerPutState</vh></v>
<v t="T523"><vh>SR_TriggerGetScript</vh></v>
<v t="T524"><vh>SR_TriggerPutScript</vh></v>
<v t="T525"><vh>SR_TipGetString</vh></v>
<v t="T526"><vh>SR_TipPutString</vh></v>
<v t="T527"><vh>SR_PlaneMoveGetType</vh></v>
<v t="T528"><vh>SR_PlaneMovePutType</vh></v>
</v>
<v t="T529"><vh>@file sv_mobj.c</vh>
<v t="T530"><vh>&lt;&lt; sv_mobj #includes &gt;&gt;</vh></v>
<v t="T531"><vh>&lt;&lt; sv_mobj declarations &gt;&gt;</vh></v>
<v t="T532"><vh>SV_MobjCountElems</vh></v>
<v t="T533"><vh>SV_MobjGetElem</vh></v>
<v t="T534"><vh>SV_MobjFindElem</vh></v>
<v t="T535"><vh>SV_MobjCreateElems</vh></v>
<v t="T536"><vh>SV_MobjFinaliseElems</vh></v>
<v t="T537"><vh>SV_ItemqCountElems</vh></v>
<v t="T538"><vh>SV_ItemqGetElem</vh></v>
<v t="T539"><vh>SV_ItemqFindElem</vh></v>
<v t="T540"><vh>SV_ItemqCreateElems</vh></v>
<v t="T541"><vh>SV_ItemqFinaliseElems</vh></v>
<v t="T542"><vh>SR_MobjGetPlayer</vh></v>
<v t="T543"><vh>SR_MobjPutPlayer</vh></v>
<v t="T544"><vh>SR_MobjGetMobj</vh></v>
<v t="T545"><vh>SR_MobjPutMobj</vh></v>
<v t="T546"><vh>SR_MobjGetType</vh></v>
<v t="T547"><vh>SR_MobjPutType</vh></v>
<v t="T548"><vh>SR_MobjGetSpawnPoint</vh></v>
<v t="T549"><vh>SR_MobjPutSpawnPoint</vh></v>
<v t="T550"><vh>SR_MobjGetAttack</vh></v>
<v t="T551"><vh>SR_MobjPutAttack</vh></v>
<v t="T552"><vh>SR_MobjGetState</vh></v>
<v t="T553"><vh>SR_MobjPutState</vh></v>
</v>
<v t="T554"><vh>@file sv_play.c</vh>
<v t="T555"><vh>&lt;&lt; sv_play #includes &gt;&gt;</vh></v>
<v t="T556"><vh>&lt;&lt; sv_play declarations &gt;&gt;</vh></v>
<v t="T557"><vh>SV_PlayerCountElems</vh></v>
<v t="T558"><vh>SV_PlayerGetElem</vh></v>
<v t="T559"><vh>SV_PlayerFindElem</vh></v>
<v t="T560"><vh>SV_PlayerCreateElems</vh></v>
<v t="T561"><vh>SV_PlayerFinaliseElems</vh></v>
<v t="T562"><vh>SR_PlayerGetAmmo</vh></v>
<v t="T563"><vh>SR_PlayerPutAmmo</vh></v>
<v t="T564"><vh>SR_PlayerGetWeapon</vh></v>
<v t="T565"><vh>SR_PlayerPutWeapon</vh></v>
<v t="T566"><vh>SR_PlayerGetPSprite</vh></v>
<v t="T567"><vh>SR_PlayerPutPSprite</vh></v>
<v t="T568"><vh>SR_PlayerGetName</vh></v>
<v t="T569"><vh>SR_PlayerPutName</vh></v>
<v t="T570"><vh>SR_WeaponGetInfo</vh></v>
<v t="T571"><vh>SR_WeaponPutInfo</vh></v>
<v t="T572"><vh>SR_PlayerGetState</vh></v>
<v t="T573"><vh>SR_PlayerPutState</vh></v>
</v>
<v t="T574"><vh>@file sv_save.c</vh>
<v t="T575"><vh>&lt;&lt; sv_save #includes &gt;&gt;</vh></v>
<v t="T576"><vh>SV_BeginSave</vh></v>
<v t="T577"><vh>SV_FinishSave</vh></v>
<v t="T578"><vh>SV_SaveStruct</vh></v>
<v t="T579"><vh>SV_SaveSTRU</vh></v>
<v t="T580"><vh>SV_SaveARRY</vh></v>
<v t="T581"><vh>SV_SaveDATA</vh></v>
<v t="T582"><vh>SV_SaveEverything</vh></v>
</v>
</v>
<v t="T2509"><vh>v_*.c</vh>
<v t="T583"><vh>@file v_colour.c</vh>
<v t="T584"><vh>&lt;&lt; v_colour #includes &gt;&gt;</vh></v>
<v t="T585"><vh>&lt;&lt; v_colour declarations &gt;&gt;</vh></v>
<v t="T586"><vh>V_InitPalette</vh></v>
<v t="T587"><vh>InitTranslationTables</vh></v>
<v t="T588"><vh>ColourCallbackFunc</vh></v>
<v t="T589"><vh>BestfitInit</vh></v>
<v t="T590"><vh>CreateRGBTable</vh></v>
<v t="T591"><vh>SwapEm</vh></v>
<v t="T592"><vh>V_ComputeRGBInfo</vh></v>
<v t="T593"><vh>V_CalcRGB</vh></v>
<v t="T594"><vh>CalcTranslucencyTable</vh></v>
<v t="T595"><vh>V_InitColour</vh></v>
<v t="T596"><vh>V_FindColour</vh></v>
<v t="T597"><vh>V_FindPureColour</vh></v>
<v t="T598"><vh>V_SetPalette</vh></v>
<v t="T599"><vh>MakeRGB</vh></v>
<v t="T600"><vh>MakeColourmapRange</vh></v>
<v t="T601"><vh>LoadColourmap</vh></v>
<v t="T602"><vh>V_GetRawColtable</vh></v>
<v t="T603"><vh>V_GetTranslationTable</vh></v>
<v t="T604"><vh>V_GetColtable</vh></v>
<v t="T605"><vh>V_GetColmapRGB</vh></v>
<v t="T606"><vh>V_GetTranslatedColtable</vh></v>
<v t="T607"><vh>V_ColourNewFrame</vh></v>
<v t="T608"><vh>V_IndexColourToRGB</vh></v>
<v t="T609"><vh>V_IndexNominalToRGB</vh></v>
</v>
<v t="T610"><vh>@file v_func.c</vh>
<v t="T611"><vh>&lt;&lt; v_func #includes &gt;&gt;</vh></v>
<v t="T612"><vh>&lt;&lt; v_func declarations &gt;&gt;</vh></v>
<v t="T613"><vh>R_DrawViewBorder</vh></v>
<v t="T614"><vh>R_FillBackScreen</vh></v>
</v>
<v t="T615"><vh>@file v_res.c</vh>
<v t="T616"><vh>&lt;&lt; v_res #includes &gt;&gt;</vh></v>
<v t="T617"><vh>&lt;&lt; v_res declarations &gt;&gt;</vh></v>
<v t="T618"><vh>SetRes</vh></v>
<v t="T619"><vh>BPPToFuncTable</vh></v>
<v t="T620"><vh>SetBPP</vh></v>
<v t="T621"><vh>V_InitResolution</vh></v>
<v t="T622"><vh>V_MultiResInit</vh></v>
<v t="T623"><vh>V_ClearPageBackground</vh></v>
<v t="T624"><vh>V_AddAvailableResolution</vh></v>
<v t="T625"><vh>V_FindClosestResolution</vh></v>
<v t="T626"><vh>V_CompareModes</vh></v>
</v>
<v t="T627"><vh>@file v_screen.c</vh>
<v t="T628"><vh>&lt;&lt; v_screen #includes &gt;&gt;</vh></v>
<v t="T629"><vh>&lt;&lt; v_screen declarations &gt;&gt;</vh></v>
<v t="T630"><vh>V_EmptyScreen</vh></v>
<v t="T631"><vh>V_DestroyScreen</vh></v>
<v t="T632"><vh>V_InitScreen</vh></v>
<v t="T633"><vh>V_CreateScreen</vh></v>
<v t="T634"><vh>V_CreateEmptyScreen</vh></v>
<v t="T635"><vh>V_InitSubScreen</vh></v>
<v t="T636"><vh>V_CreateSubScreen</vh></v>
<v t="T637"><vh>V_ResizeScreen</vh></v>
<v t="T638"><vh>V_MoveSubScreen</vh></v>
<v t="T639"><vh>V_GetPitch</vh></v>
<v t="T640"><vh>V_ScreensIntersect</vh></v>
<v t="T641"><vh>V_ScreenHasCurrentRes</vh></v>
</v>
<v t="T642"><vh>@file v_toplev.c</vh>
<v t="T643"><vh>&lt;&lt; v_toplev #includes &gt;&gt;</vh></v>
<v t="T644"><vh>&lt;&lt; v_toplev declarations &gt;&gt;</vh></v>
<v t="T645"><vh>VTOP_NewScreenSize</vh></v>
<v t="T646"><vh>VTOP_RenderScene</vh></v>
<v t="T647"><vh>VTOP_BeginDraw</vh></v>
<v t="T648"><vh>VTOP_EndDraw</vh></v>
<v t="T649"><vh>VTOP_DrawImage</vh></v>
<v t="T650"><vh>VTOP_SolidBox</vh></v>
<v t="T651"><vh>VTOP_SolidLine</vh></v>
<v t="T652"><vh>VTOP_ReadScreen</vh></v>
<v t="T653"><vh>VTOP_AnalyseBegin</vh></v>
<v t="T654"><vh>VTOP_AnalyseEnd</vh></v>
<v t="T655"><vh>VTOP_AnalyseNextRect</vh></v>
</v>
<v t="T3"><vh>@file v_video1.c</vh>
<v t="T4"><vh>&lt;&lt; v_video1 #includes &gt;&gt;</vh></v>
<v t="T5"><vh>V_CopyRect8</vh></v>
<v t="T6"><vh>V_CopyScreen8</vh></v>
<v t="T7"><vh>V_DrawLine8</vh></v>
<v t="T8"><vh>V_DrawPixel8</vh></v>
<v t="T9"><vh>V_DrawBox8</vh></v>
<v t="T10"><vh>V_DrawBoxAlpha8</vh></v>
</v>
<v t="T11"><vh>@file v_video2.c</vh>
<v t="T12"><vh>&lt;&lt; v_video2 #includes &gt;&gt;</vh></v>
<v t="T13"><vh>V_CopyRect16</vh></v>
<v t="T14"><vh>V_CopyScreen16</vh></v>
<v t="T15"><vh>V_DrawLine16</vh></v>
<v t="T16"><vh>V_DrawPixel16</vh></v>
<v t="T17"><vh>V_DrawBox16</vh></v>
<v t="T18"><vh>V_DrawBoxAlpha16</vh></v>
</v>
</v>
<v t="T2510"><vh>w?_*.c</vh>
<v t="T19"><vh>@file w_image.c</vh>
<v t="T20"><vh>&lt;&lt; w_image #includes &gt;&gt;</vh></v>
<v t="T21"><vh>&lt;&lt; w_image declarations &gt;&gt;</vh></v>
<v t="T22"><vh>InsertAtTail</vh></v>
<v t="T23"><vh>Unlink</vh></v>
<v t="T24"><vh>W_MakeValidSize</vh></v>
<v t="T25"><vh>NewImage</vh></v>
<v t="T26"><vh>AddImageDummy</vh></v>
<v t="T27"><vh>AddImagePatch</vh></v>
<v t="T28"><vh>AddImageTexture</vh></v>
<v t="T29"><vh>AddImageFlat</vh></v>
<v t="T30"><vh>W_ImageCreateFlats</vh></v>
<v t="T31"><vh>W_ImageCreateTextures</vh></v>
<v t="T32"><vh>W_ImageCreateSprite</vh></v>
<v t="T33"><vh>ShrinkBlock</vh></v>
<v t="T34"><vh>EnlargeBlock</vh></v>
<v t="T35"><vh>DrawColumnIntoBlock</vh></v>
<v t="T36"><vh>DrawWPostIntoBlock</vh></v>
<v t="T37"><vh>CheckBlockSolid</vh></v>
<v t="T38"><vh>ConvertBlockToPost</vh></v>
<v t="T39"><vh>ShrinkBlockRGBA</vh></v>
<v t="T40"><vh>ConvertHaloGL</vh></v>
<v t="T41"><vh>W_SendGLTexture</vh></v>
<v t="T42"><vh>ReadFlatAsBlock</vh></v>
<v t="T43"><vh>ReadTextureAsBlock</vh></v>
<v t="T44"><vh>ReadPatchAsBlock</vh></v>
<v t="T45"><vh>ReadDummyAsBlock</vh></v>
<v t="T46"><vh>ReadAsBlock</vh></v>
<v t="T47"><vh>TranslateColumn</vh></v>
<v t="T48"><vh>ReadPatchAsPost</vh></v>
<v t="T49"><vh>ReadAsPost</vh></v>
<v t="T50"><vh>LoadImagePost</vh></v>
<v t="T51"><vh>LoadImageBlock</vh></v>
<v t="T52"><vh>LoadImageOGL</vh></v>
<v t="T53"><vh>UnloadImagePost</vh></v>
<v t="T54"><vh>UnloadImageBlock</vh></v>
<v t="T55"><vh>UnloadImageOGL</vh></v>
<v t="T56"><vh>UnloadImage</vh></v>
<v t="T57"><vh>W_ImageFromTexture</vh></v>
<v t="T58"><vh>W_ImageFromFlat</vh></v>
<v t="T59"><vh>W_ImageFromPatch</vh></v>
<v t="T60"><vh>W_ImageFromFont</vh></v>
<v t="T61"><vh>W_ImageFromHalo</vh></v>
<v t="T62"><vh>W_ImageForDummySprite</vh></v>
<v t="T63"><vh>W_ImageFromString</vh></v>
<v t="T64"><vh>W_ImageToString</vh></v>
<v t="T65"><vh>W_ImageDebugName</vh></v>
<v t="T66"><vh>ImageCachePost</vh></v>
<v t="T67"><vh>ImageCacheBlock</vh></v>
<v t="T68"><vh>ImageCacheOGL</vh></v>
<v t="T69"><vh>W_ImageCache</vh></v>
<v t="T70"><vh>W_ImageDone</vh></v>
<v t="T71"><vh>W_ImageGetPost</vh></v>
<v t="T72"><vh>W_ImageGetBlock</vh></v>
<v t="T73"><vh>W_ImageGetOGL</vh></v>
<v t="T74"><vh>FlushImageCaches</vh></v>
<v t="T75"><vh>W_ImagePreCache</vh></v>
<v t="T76"><vh>W_InitImages</vh></v>
<v t="T77"><vh>W_UpdateImageAnims</vh></v>
<v t="T78"><vh>W_ResetImages</vh></v>
<v t="T79"><vh>W_LockImagesOGL</vh></v>
<v t="T80"><vh>W_UnlockImagesOGL</vh></v>
<v t="T81"><vh>W_AnimateImageSet</vh></v>
</v>
<v t="T82"><vh>@file w_textur.c</vh>
<v t="T83"><vh>&lt;&lt; w_textur #includes &gt;&gt;</vh></v>
<v t="T84"><vh>&lt;&lt; w_textur declarations &gt;&gt;</vh></v>
<v t="T85"><vh>InstallTextureLumps</vh></v>
<v t="T86"><vh>W_InitTextures</vh></v>
<v t="T87"><vh>W_FindTextureSequence</vh></v>
<v t="T88"><vh>W_TextureNameInSet</vh></v>
</v>
<v t="T89"><vh>@file w_wad.c</vh>
<v t="T90"><vh>&lt;&lt; w_wad #includes &gt;&gt;</vh></v>
<v t="T91"><vh>&lt;&lt; w_wad declarations &gt;&gt;</vh></v>
<v t="T92"><vh>IsS_START</vh></v>
<v t="T93"><vh>IsS_END</vh></v>
<v t="T94"><vh>IsF_START</vh></v>
<v t="T95"><vh>IsF_END</vh></v>
<v t="T96"><vh>IsDummySF</vh></v>
<v t="T97"><vh>FileLength</vh></v>
<v t="T98"><vh>ExtractFileBase</vh></v>
<v t="T99"><vh>W_GetTextureLumps</vh></v>
<v t="T100"><vh>SortLumps</vh></v>
<v t="T101"><vh>SortSpriteLumps</vh></v>
<v t="T102"><vh>FreeLump</vh></v>
<v t="T103"><vh>MarkAsCached</vh></v>
<v t="T104"><vh>AddSpriteOrFlat</vh></v>
<v t="T105"><vh>AddLump</vh></v>
<v t="T106"><vh>AddFile</vh></v>
<v t="T107"><vh>FlushLumpCache</vh></v>
<v t="T108"><vh>InitCaches</vh></v>
<v t="T109"><vh>W_AddRawFilename</vh></v>
<v t="T110"><vh>W_InitMultipleFiles</vh></v>
<v t="T111"><vh>W_GetFileName</vh></v>
<v t="T112"><vh>W_GetPaletteForLump</vh></v>
<v t="T113"><vh>W_AddDynamicGWA</vh></v>
<v t="T114"><vh>W_CheckNumForName2</vh></v>
<v t="T115"><vh>W_GetNumForName2</vh></v>
<v t="T116"><vh>W_VerifyLumpName</vh></v>
<v t="T117"><vh>W_LumpLength</vh></v>
<v t="T118"><vh>W_FindFlatSequence</vh></v>
<v t="T119"><vh>W_GetListLumps</vh></v>
<v t="T120"><vh>W_GetNumFiles</vh></v>
<v t="T121"><vh>W_LumpRawInfo</vh></v>
<v t="T122"><vh>W_ReadLump</vh></v>
<v t="T123"><vh>W_DoneWithLump</vh></v>
<v t="T124"><vh>W_DoneWithLump_Flushable</vh></v>
<v t="T125"><vh>W_CacheLumpNum2</vh></v>
<v t="T126"><vh>W_CacheLumpName2</vh></v>
<v t="T127"><vh>W_PreCacheLumpNum</vh></v>
<v t="T128"><vh>W_PreCacheLumpName</vh></v>
<v t="T129"><vh>W_CacheInfo</vh></v>
<v t="T130"><vh>W_LoadLumpNum</vh></v>
<v t="T131"><vh>W_LoadLumpName</vh></v>
<v t="T132"><vh>W_GetLumpName</vh></v>
</v>
<v t="T133"><vh>@file wi_stuff.c</vh>
<v t="T134"><vh>&lt;&lt; wi_stuff #includes &gt;&gt;</vh></v>
<v t="T135"><vh>&lt;&lt; wi_stuff declarations &gt;&gt;</vh></v>
<v t="T136"><vh>WI_MapInit</vh></v>
<v t="T137"><vh>DrawLevelFinished</vh></v>
<v t="T138"><vh>DrawEnteringLevel</vh></v>
<v t="T139"><vh>DrawOnLnode</vh></v>
<v t="T140"><vh>DrawNum</vh></v>
<v t="T141"><vh>DrawPercent</vh></v>
<v t="T142"><vh>DrawTime</vh></v>
<v t="T143"><vh>UnloadData</vh></v>
<v t="T144"><vh>WI_End</vh></v>
<v t="T145"><vh>InitNoState</vh></v>
<v t="T146"><vh>UpdateNoState</vh></v>
<v t="T147"><vh>InitShowNextLoc</vh></v>
<v t="T148"><vh>UpdateShowNextLoc</vh></v>
<v t="T149"><vh>DrawShowNextLoc</vh></v>
<v t="T150"><vh>DrawNoState</vh></v>
<v t="T151"><vh>WI_DeathmatchScore</vh></v>
<v t="T152"><vh>InitDeathmatchStats</vh></v>
<v t="T153"><vh>UpdateDeathmatchStats</vh></v>
<v t="T154"><vh>DrawDeathmatchStats</vh></v>
<v t="T155"><vh>NetgameScore</vh></v>
<v t="T156"><vh>InitNetgameStats</vh></v>
<v t="T157"><vh>UpdateNetgameStats</vh></v>
<v t="T158"><vh>DrawNetgameStats</vh></v>
<v t="T159"><vh>InitStats</vh></v>
<v t="T160"><vh>UpdateStats</vh></v>
<v t="T161"><vh>DrawStats</vh></v>
<v t="T162"><vh>CheckForAccelerate</vh></v>
<v t="T163"><vh>WI_Ticker</vh></v>
<v t="T164"><vh>LoadData</vh></v>
<v t="T165"><vh>WI_Drawer</vh></v>
<v t="T166"><vh>InitVariables</vh></v>
<v t="T167"><vh>WI_Start</vh></v>
</v>
<v t="T168"><vh>@file wp_main.c</vh>
<v t="T169"><vh>&lt;&lt; wp_main #includes &gt;&gt;</vh></v>
<v t="T170"><vh>WIPE_CreateWipeInfo</vh></v>
<v t="T171"><vh>WIPE_DestroyWipeInfo</vh></v>
<v t="T172"><vh>WIPE_StopWipe</vh></v>
<v t="T173"><vh>InitWipeScr</vh></v>
<v t="T174"><vh>WIPE_InitWipe</vh></v>
<v t="T175"><vh>WIPE_DoWipe</vh></v>
</v>
<v t="T176"><vh>@file wp_wipe.c</vh>
<v t="T177"><vh>&lt;&lt; wp_wipe #includes &gt;&gt;</vh></v>
<v t="T178"><vh>DoWipe_Crossfade16</vh></v>
<v t="T179"><vh>DoWipe_Crossfade8</vh></v>
<v t="T180"><vh>DoWipe_Crossfade</vh></v>
<v t="T181"><vh>Wipe_Pixelfade8</vh></v>
<v t="T182"><vh>Wipe_Pixelfade16</vh></v>
<v t="T183"><vh>DoWipe_Pixelfade</vh></v>
<v t="T184"><vh>DoWipe_Melt</vh></v>
<v t="T185"><vh>InitData_Melt</vh></v>
<v t="T186"><vh>DestroyData_ZFree</vh></v>
<v t="T187"><vh>DefDuration_Doors</vh></v>
<v t="T188"><vh>DefDuration_Fade</vh></v>
<v t="T189"><vh>DefDuration_Melt</vh></v>
<v t="T190"><vh>DefDuration_VScroll</vh></v>
<v t="T191"><vh>DefDuration_HScroll</vh></v>
<v t="T192"><vh>DefDuration_None</vh></v>
<v t="T193"><vh>DoWipe_Top</vh></v>
<v t="T194"><vh>DoWipe_Bottom</vh></v>
<v t="T195"><vh>DoWipe_Left</vh></v>
<v t="T196"><vh>DoWipe_Right</vh></v>
<v t="T197"><vh>DoWipe_Corners</vh></v>
<v t="T198"><vh>InitData_Doors</vh></v>
<v t="T199"><vh>DrawDoorCol16</vh></v>
<v t="T200"><vh>DrawDoorCol8</vh></v>
<v t="T201"><vh>GetDoorCol</vh></v>
<v t="T202"><vh>GetDoorScale</vh></v>
<v t="T203"><vh>DoWipe_Doors</vh></v>
<v t="T204"><vh>DoWipe_None</vh></v>
</v>
</v>
<v t="T205"><vh>@file z_zone.c</vh>
<v t="T206"><vh>&lt;&lt; z_zone #includes &gt;&gt;</vh></v>
<v t="T207"><vh>&lt;&lt; z_zone declarations &gt;&gt;</vh></v>
<v t="T208"><vh>Z_StrDup</vh></v>
<v t="T209"><vh>Z_ClearStackArray</vh></v>
<v t="T210"><vh>Z_DeleteStackArray</vh></v>
<v t="T211"><vh>Z_LockStackArray</vh></v>
<v t="T212"><vh>Z_UnlockStackArray</vh></v>
<v t="T213"><vh>Z_InitStackArray</vh></v>
<v t="T214"><vh>Z_CreateStackArray</vh></v>
<v t="T215"><vh>SetActualArraySize</vh></v>
<v t="T216"><vh>Z_SetArraySize</vh></v>
<v t="T217"><vh>FlushStackArrays</vh></v>
<v t="T218"><vh>Z_Free</vh></v>
<v t="T219"><vh>Z_RegisterCacheFlusher</vh></v>
<v t="T220"><vh>FlushCaches</vh></v>
<v t="T221"><vh>Z_Calloc2</vh></v>
<v t="T222"><vh>Z_ReMalloc2</vh></v>
<v t="T223"><vh>Z_Malloc2</vh></v>
<v t="T224"><vh>Z_RegisterMalloc</vh></v>
<v t="T225"><vh>Z_UnRegisterTmpMalloc</vh></v>
<v t="T226"><vh>Z_DumpLeakInfo</vh></v>
<v t="T227"><vh>Z_CheckHeap</vh></v>
<v t="T228"><vh>Z_UsedMemory</vh></v>
<v t="T229"><vh>Z_FreeMemory</vh></v>
<v t="T230"><vh>Z_Init</vh></v>
<v t="T231"><vh>Z_CheckIfZero</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T3">@ignore
@language c

// Video Code for 8-Bit Colour. 

&lt;&lt; v_video1 #includes &gt;&gt;
@others
</t>
<t tx="T4">#include "i_defs.h"
#include "v_video1.h"

#include "dm_data.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "e_main.h"
#include "m_bbox.h"
#include "m_inline.h"
#include "m_misc.h"
#include "m_swap.h"
#include "r_local.h"
#include "v_colour.h"
#include "v_res.h"
#include "v_screen.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T5">@ V_CopyRect8
@c

void V_CopyRect8(screen_t * destscr, screen_t * srcscr, int srcx, int srcy,
    int width, int height, int destx, int desty)
{
  byte *src;
  byte *dest;

  src = srcscr-&gt;data + srcscr-&gt;pitch * srcy + srcx;
  dest = destscr-&gt;data + destscr-&gt;pitch * desty + destx;

#ifdef DEVELOPERS
  if (srcx + width &gt; srcscr-&gt;width || srcy + height &gt; srcscr-&gt;height ||
      destx + width &gt; destscr-&gt;width || desty + height &gt; destscr-&gt;height ||
      (srcx | srcy | destx | desty) &lt; 0)
    I_Error("V_CopyRect8: Coordinates outside screen boundaries!\n%d,%d, %d,%d, %d,%d",
        srcx, srcy, width, height, destx, desty);
#endif

  while (height--)
  {
    Z_MoveData(dest, src, byte, width);
    src += srcscr-&gt;pitch;
    dest += destscr-&gt;pitch;
  }
}
</t>
<t tx="T6">@ V_CopyScreen8

Copies one screen to another. They must have equal size.
@c

void V_CopyScreen8(screen_t * dest, screen_t * src)
{
  if (src-&gt;width != dest-&gt;width ||
      src-&gt;height != dest-&gt;height ||
      src-&gt;bytepp != dest-&gt;bytepp)
    I_Error("V_CopyScreen8:  Screens have different size!");

  V_CopyRect8(dest, src, 0, 0, src-&gt;width, src-&gt;height, 0, 0);
}
</t>
<t tx="T7">@ Classic Bresenham w/ whatever optimizations needed for speed

-AJA- 1999/07/04: Moved here from am_map.c.
@c

void V_DrawLine8(screen_t * scr, int x1, int y1, int x2, int y2, int col)
{
  register int x;
  register int y;
  register int dx;
  register int dy;
  register int sx;
  register int sy;
  register int ax;
  register int ay;
  register int d;
  register byte *fb = scr-&gt;data;
  int pitch = scr-&gt;pitch;

  dx = x2 - x1;
  ax = 2 * (dx &lt; 0 ? -dx : dx);
  sx = dx &lt; 0 ? -1 : 1;

  dy = y2 - y1;
  ay = 2 * (dy &lt; 0 ? -dy : dy);
  sy = dy &lt; 0 ? -1 : 1;

  x = x1;
  y = y1;

  if (ax &gt; ay)
  {
    d = ay - ax / 2;
    while (1)
    {
      fb[(y) * pitch + (x)] = (col);
      if (x == x2)
        return;
      if (d &gt;= 0)
      {
        y += sy;
        d -= ax;
      }
      x += sx;
      d += ay;
    }
  }
  else
  {
    d = ax - ay / 2;
    while (1)
    {
      fb[(y) * pitch + (x)] = (col);
      if (y == y2)
        return;
      if (d &gt;= 0)
      {
        x += sx;
        d -= ay;
      }
      y += sy;
      d += ax;
    }
  }
}
</t>
<t tx="T8">@ -AJA- 1999/07/05: Added these two functions.
@c

void V_DrawPixel8(screen_t * scr, int x, int y, int col)
{
  scr-&gt;data[y * scr-&gt;pitch + x] = col;
}
</t>
<t tx="T9">
void V_DrawBox8(screen_t * scr, int x, int y, int w, int h, int col)
{
  byte *dest;

  dest = scr-&gt;data + y * scr-&gt;pitch + x;

  for (y = 0; y &lt; h; y++)
  {
    memset(dest, col, w);
    dest += scr-&gt;pitch;
  }
}
</t>
<t tx="T10">
void V_DrawBoxAlpha8(screen_t * scr, int x, int y, int w, int h, int col, fixed_t alpha)
{
  byte *dest;

  fixed_t fglevel, bglevel;
  unsigned long *fg2rgb, *bg2rgb;
  unsigned long fg;  // current colours

  fglevel = alpha &amp; ~0x3ff;
  bglevel = FRACUNIT - fglevel;

  fg2rgb = col2rgb8[fglevel &gt;&gt; 10];
  bg2rgb = col2rgb8[bglevel &gt;&gt; 10];

  dest = scr-&gt;data + y * scr-&gt;pitch + x;

  for (y=0; y &lt; h; y++, dest += scr-&gt;pitch)
  {
    for (x=0; x &lt; w; x++)
    {
      fg = (fg2rgb[col] + bg2rgb[dest[x]]) | 0x07c1fc1f;

      dest[x] = rgb_32k[0][0][fg &amp; (fg &gt;&gt; 17)];
    }
  }
}
</t>
<t tx="T11">@ignore
@language c

// Video Code for 16-Bit Colour. 

&lt;&lt; v_video2 #includes &gt;&gt;
@others

#endif // NOHICOLOUR
</t>
<t tx="T12">#include "i_defs.h"
</t>
<t tx="T13">
#ifndef NOHICOLOUR

#include "v_video2.h"

#include "dm_data.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "e_main.h"
#include "r_local.h"
#include "m_bbox.h"
#include "m_inline.h"
#include "m_misc.h"
#include "m_swap.h"
#include "v_res.h"
#include "v_colour.h"
#include "w_image.h"
#include "w_wad.h"
#include "w_image.h"
#include "z_zone.h"

//
// V_CopyRect16
// 
void V_CopyRect16(screen_t * destscr, screen_t * srcscr, int srcx, int srcy,
    int width, int height, int destx, int desty)
{
  byte *src;
  byte *dest;

  src = srcscr-&gt;data + srcscr-&gt;pitch * srcy + srcx * 2;
  dest = destscr-&gt;data + destscr-&gt;pitch * desty + destx * 2;

#ifdef DEVELOPERS
  if (srcx + width &gt; srcscr-&gt;width || srcy + height &gt; srcscr-&gt;height ||
      destx + width &gt; destscr-&gt;width || desty + height &gt; destscr-&gt;height ||
      (srcx | srcy | destx | desty) &lt; 0)
    I_Error("V_CopyRect8: Coordinates outside screen boundaries!\n%d,%d, %d,%d, %d,%d",
        srcx, srcy, width, height, destx, desty);
#endif

  while (height--)
  {
    Z_MoveData(dest, src, byte, width * sizeof(short));
    src += srcscr-&gt;pitch;
    dest += destscr-&gt;pitch;
  }
}
</t>
<t tx="T14">@ V_CopyScreen16

Copies one screen to another. They must have equal size.
@c

void V_CopyScreen16(screen_t * dest, screen_t * src)
{
  if (src-&gt;width != dest-&gt;width ||
      src-&gt;height != dest-&gt;height ||
      src-&gt;bytepp != dest-&gt;bytepp)
    I_Error("V_CopyScreen16:  Screens have different size!");

  V_CopyRect16(dest, src, 0, 0, src-&gt;width, src-&gt;height, 0, 0);
}
</t>
<t tx="T15">@ Classic Bresenham w/ whatever optimizations needed for speed

-AJA- 1999/07/04: Moved here from am_map.c.
-ES- Optimise: This algorithm is very very poor.
@c

void V_DrawLine16(screen_t * scr, int x1, int y1, int x2, int y2, int col)
{
  register int x;
  register int y;
  register int dx;
  register int dy;
  register int sx;
  register int sy;
  register int ax;
  register int ay;
  register int d;
  register short *fb = (short *)scr-&gt;data;
  int pitch = scr-&gt;pitch;

  dx = x2 - x1;
  ax = 2 * (dx &lt; 0 ? -dx : dx);
  sx = dx &lt; 0 ? -1 : 1;

  dy = y2 - y1;
  ay = 2 * (dy &lt; 0 ? -dy : dy);
  sy = dy &lt; 0 ? -1 : 1;

  x = x1;
  y = y1;

  if (ax &gt; ay)
  {
    d = ay - ax / 2;
    while (1)
    {
      fb[(y) * pitch / 2 + (x)] = (short)pixel_values[col];
      if (x == x2)
        return;
      if (d &gt;= 0)
      {
        y += sy;
        d -= ax;
      }
      x += sx;
      d += ay;
    }
  }
  else
  {
    d = ax - ay / 2;
    while (1)
    {
      fb[(y) * pitch / 2 + (x)] = (short)pixel_values[col];
      if (y == y2)
        return;
      if (d &gt;= 0)
      {
        x += sx;
        d -= ay;
      }
      y += sy;
      d += ax;
    }
  }
}
</t>
<t tx="T16">@ -AJA- 1999/07/05: Added these two functions.
@c

void V_DrawPixel16(screen_t * scr, int x, int y, int col)
{
  short *line = (short *)&amp;scr-&gt;data[y * scr-&gt;pitch];

  line[x] = (short)pixel_values[col];
}
</t>
<t tx="T17">
void V_DrawBox16(screen_t * scr, int x, int y, int w, int h, int col)
{
  short *dest;

  col = (short)pixel_values[col];
  dest = (short *)(scr-&gt;data + y * scr-&gt;pitch) + x;

  for (y=0; y &lt; h; y++)
  {
    for (x=0; x &lt; w; x++)
      dest[x] = col;

    dest += scr-&gt;pitch / 2;
  }
}
</t>
<t tx="T18">
void V_DrawBoxAlpha16(screen_t * scr, int x, int y, int w, int h, int col, fixed_t alpha)
{
  short *dest;

  fixed_t fglevel, bglevel;
  unsigned long c;  // current colour
  
  fglevel = (alpha + 1023) / 1040;
  bglevel = 64 - fglevel;

  col = (short)pixel_values[col];
  dest = (short *)(scr-&gt;data + y * scr-&gt;pitch) + x;

  for (y=0; y &lt; h; y++)
  {
    for (x=0; x &lt; w; x++)
    {
      c = col2rgb16[fglevel][(byte)col][0] +
          col2rgb16[fglevel][(byte)(col &gt;&gt; 8)][1] +
          col2rgb16[bglevel][((byte *)dest)[2*x]][0] +
          col2rgb16[bglevel][((byte *)dest)[2*x+1]][1];

      c |= hicolourtransmask;

      dest[x] = (short)(c &amp; (c &gt;&gt; 16));
    }
    
    dest += scr-&gt;pitch / 2;
  }
}
</t>
<t tx="T19">@ignore
@language c

// Generalised Image Handling

// -AJA- 2000/06/25: Began this image generalisation, based on Erik
//       Sandberg's w_textur.c/h code.
//
// TODO HERE:
//   +  faster search methods.
//   -  do some optimisation

&lt;&lt; w_image #includes &gt;&gt;
&lt;&lt; w_image declarations &gt;&gt;

@others
</t>
<t tx="T20">#include "i_defs.h"
#include "w_image.h"

#include "e_search.h"
#include "dm_state.h"
#include "dm_defs.h"
#include "m_argv.h"
#include "m_misc.h"
#include "m_swap.h"
#include "p_local.h"
#include "r_local.h"
#include "r_sky.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "w_textur.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T21">

// range of mip values is 0 to 11, allowing images upto 2048x2048
#define MAX_MIP  11


#ifndef USE_GL
typedef unsigned int  GLuint;
#endif

struct real_image_s;


//
// This structure is for "cached" images (i.e. ready to be used for
// rendering), and is the non-opaque version of cached_image_t.  A
// single structure is used for all three image modes (Post, Block and
// OGL).
//
// Note: multiple modes and/or multiple mips of the same image_t can
// indeed be present in the cache list at any one time.
//
typedef struct real_cached_image_s
{
  // link in cache list
  struct real_cached_image_s *next, *prev;

  // number of current users
  int users;

  // true if image has been invalidated -- unload a.s.a.p
  boolean_t invalidated;
 
  // parent image
  struct real_image_s *parent;
  
  // mip value (&gt;= 0)
  unsigned short mip;

  // current image mode
  image_mode_e mode;

  union
  {
    // case IMG_Post:
    struct
    {
      // array of columns.  Size is MIP_SIZE(total_w, mip).  Totally
      // empty columns can be NULL.
      w_post_t ** columns;
    }
    post;

    // case IMG_Block:
    struct
    {
      // pixel block.  MIP_SIZE(total_h,mip) * MIP_SIZE(total_w,mip)
      // is the size.  Pixel order is down columns first (i.e. not the
      // usual layout).  Transparent pixels are TRANS_PIXEL.
      byte *pixels;
    }
    block;

    // case IMG_OGL:
    struct
    {
      // texture identifier within GL
      GLuint tex_id;
    }
    ogl;
  }
  info;

  // total memory size taken up by this image.  Includes this
  // structure.
  int size;

  // NOTE: Post/Block data may follow this structure...
}
real_cached_image_t;


typedef enum
{
  // Source was a patch name
  IMSRC_Patch = 0,

  // Source was a font patch name
  IMSRC_Font = 1,

  // Source was a halo patch name
  IMSRC_Halo = 2,

  // Source was a sprite name
  IMSRC_Sprite = 3,

  // Source was a flat name
  IMSRC_Flat = 4,

  // Source was a raw block of 320x200 bytes (Heretic/Hexen)
  IMSRC_Raw320x200 = 5,

  // Source was a texture name
  IMSRC_Texture = 6,

  // Source is dummy image
  IMSRC_Dummy = 7,

  // Source is from IMAGE.DDF
  IMSRC_User = 8
}
image_source_e;

//
// This structure is the full version of image_t.  It contains all the
// information needed to create the actual cached images when needed.
//
typedef struct real_image_s
{
  // base is the publicly visible structure
  image_t pub;

  // --- information about where this image came from ---

  char name[10];

  image_source_e source_type;
 
  union
  {
    // case IMSRC_Patch:
    // case IMSRC_Font:
    // case IMSRC_Halo:
    // case IMSRC_Sprite:
    struct { int lump; } patch;

    // case IMSRC_Flat:
    // case IMSRC_Raw320x200:
    struct { int lump; } flat;

    // case IMSRC_Texture:
    struct { texturedef_t *tdef; } texture;

    // case IMSRC_Dummy:
    struct { byte fg, bg; } dummy;

    // case IMSRC_User:
    struct { void /* image_def_t */ * def; } user;
  }
  source;

  // palette lump, or -1 to use the "GLOBAL" palette
  int source_palette;

  // --- information about caching ---

  struct
  {
    int num_mips;
    real_cached_image_t ** mips;
  }
  block_cache;

  // no mipmapping for posters, there is no improvement
  real_cached_image_t * post_cache;

  // no mipmapping here, GL does this itself
  real_cached_image_t * ogl_cache;

  // --- animation info ---

  struct
  {
    // current version of this image in the animation.  Initially points
    // to self.  For non-animated images, doesn't change.  Otherwise
    // when the animation flips over, it becomes cur-&gt;next.
    struct real_image_s *cur;

    // next image in the animation, or NULL.
    struct real_image_s *next;

    // tics before next anim change, or 0 if non-animated.
    unsigned short count;

    // animation speed (in tics), or 0 if non-animated.
    unsigned short speed;
  }
  anim;
}
real_image_t;


// mipmapping enabled ?
// 0 off, 1 bilinear, 2 trilinear
int use_mipmapping = 1;

boolean_t use_smoothing = true;
boolean_t use_dithering = false;

static boolean_t w_locked_ogl = false;

// total set of images
static stack_array_t real_images_a;
static real_image_t ** real_images = NULL;
static int num_real_images = 0;

#define RIM_DUMMY_TEX    real_images[0]
#define RIM_DUMMY_FLAT   real_images[1]
#define RIM_SKY_FLAT     real_images[2]
#define RIM_DUMMY_PATCH  real_images[3]
#define RIM_DUMMY_SPRITE real_images[4]
#define RIM_DUMMY_FONT   real_images[5]
#define RIM_DUMMY_HALO   real_images[6]

const struct image_s *skyflatimage;


// image cache (actually a ring)
static real_cached_image_t imagecachehead;
</t>
<t tx="T22">@ tiny ring helpers
@c

static INLINE void InsertAtTail(real_cached_image_t *rc)
{
  DEV_ASSERT2(rc != &amp;imagecachehead);

  rc-&gt;prev =  imagecachehead.prev;
  rc-&gt;next = &amp;imagecachehead;

  rc-&gt;prev-&gt;next = rc;
  rc-&gt;next-&gt;prev = rc;
}
</t>
<t tx="T23">static INLINE void Unlink(real_cached_image_t *rc)
{
  DEV_ASSERT2(rc != &amp;imagecachehead);

  rc-&gt;prev-&gt;next = rc-&gt;next;
  rc-&gt;next-&gt;prev = rc-&gt;prev;
}
</t>
<t tx="T24">@ the number of bytes of the texture cache that currently can be
freed. Useful when we decide how much to flush. This changes when
the number of users of a block changes from 1 to 0 or back.
@c

static int cache_size = 0;


// Dummy image, for when texture/flat/patch is unknown.  Row major
// order.  Could be packed, but why bother ?
#define DUMMY_X  16
#define DUMMY_Y  16
static byte dummy_graphic[DUMMY_X * DUMMY_Y] =
{
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
  0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
  0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,
  0,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0,
  0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,
  0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,
  0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
  0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};


//----------------------------------------------------------------------------

//
//  IMAGE CREATION
//

int W_MakeValidSize(int value)
{
  DEV_ASSERT2(value &gt; 0);

  if (value &lt;=    1) return    1;
  if (value &lt;=    2) return    2;
  if (value &lt;=    4) return    4;
  if (value &lt;=    8) return    8;
  if (value &lt;=   16) return   16;
  if (value &lt;=   32) return   32;
  if (value &lt;=   64) return   64;
  if (value &lt;=  128) return  128;
  if (value &lt;=  256) return  256;
  if (value &lt;=  512) return  512;
  if (value &lt;= 1024) return 1024;
  if (value &lt;= 2048) return 2048;

  I_Error("Texture size (%d) too large !\n", value);
  return -1;
}
</t>
<t tx="T25">
static real_image_t *NewImage(int width, int height, boolean_t solid)
{
  real_image_t *rim;
  short scale = 0x0100;
  
  Z_SetArraySize(&amp;real_images_a, ++num_real_images);
  rim = real_images[num_real_images-1];

  // clear newbie
  Z_Clear(rim, real_image_t, 1);

  rim-&gt;pub.actual_w = width;
  rim-&gt;pub.actual_h = height;
  rim-&gt;pub.total_w  = W_MakeValidSize(width);
  rim-&gt;pub.total_h  = W_MakeValidSize(height);
  rim-&gt;pub.offset_x = rim-&gt;pub.offset_y = 0;
  rim-&gt;pub.scale_x  = rim-&gt;pub.scale_y = scale;
  rim-&gt;pub.solid    = solid;

  // set initial animation info
  rim-&gt;anim.cur = rim;
  rim-&gt;anim.next = NULL;
  rim-&gt;anim.count = rim-&gt;anim.speed = 0;

  return rim;
}
</t>
<t tx="T26">
static real_image_t *AddImageDummy(image_source_e realsrc)
{
  real_image_t *rim;
  
  rim = NewImage(DUMMY_X, DUMMY_Y, 
      (realsrc != IMSRC_Patch) &amp;&amp; (realsrc != IMSRC_Font) &amp;&amp;
      (realsrc != IMSRC_Halo) &amp;&amp; (realsrc != IMSRC_Sprite));
 
  DEV_ASSERT2(num_real_images &lt;= 10);
  sprintf(rim-&gt;name, "DUMMY__%d", num_real_images-1);

  rim-&gt;source_type = IMSRC_Dummy;
  rim-&gt;source_palette = -1;

  switch (realsrc)
  {
    case IMSRC_Texture:
      rim-&gt;source.dummy.fg = pal_black;
      rim-&gt;source.dummy.bg = pal_brown1;
      break;

    case IMSRC_Flat:
    case IMSRC_Raw320x200:
      rim-&gt;source.dummy.fg = pal_black;
      rim-&gt;source.dummy.bg = pal_green1;
      break;

    case IMSRC_Patch:
    case IMSRC_Sprite:
      rim-&gt;source.dummy.fg = pal_yellow;
      rim-&gt;source.dummy.bg = TRANS_PIXEL;
      break;
    
    case IMSRC_Font:
    case IMSRC_Halo:
      rim-&gt;source.dummy.fg = pal_white;
      rim-&gt;source.dummy.bg = TRANS_PIXEL;
      break;
    
    default:
      I_Error("AddImageDummy: bad realsrc value %d !\n", realsrc);
  }

  return rim;
}
</t>
<t tx="T27">
static real_image_t *AddImagePatch(const char *name, 
    image_source_e type, int lump)
{
  patch_t *pat;
  int width, height, offset_x, offset_y;
  
  real_image_t *rim;

  pat = (patch_t *) W_CacheLumpNum(lump);
  
  // FIXME: do a validity check on patch ??

  width  = SHORT(pat-&gt;width);
  height = SHORT(pat-&gt;height);
  offset_x = SHORT(pat-&gt;leftoffset);
  offset_y = SHORT(pat-&gt;topoffset);
  
  W_DoneWithLump(pat);

  // check for Heretic/Hexen images, which are raw 320x200 
  if (W_LumpLength(lump) == 64000 &amp;&amp;
      (width &lt;= 0 || height &lt;= 0 || (width * height) &gt; 80000))
  {
    if (type != IMSRC_Patch)
      return NULL;

    rim = NewImage(320, 200, true);
    strcpy(rim-&gt;name, name);

    rim-&gt;source_type = IMSRC_Raw320x200;
    rim-&gt;source.flat.lump = lump;
    rim-&gt;source_palette = W_GetPaletteForLump(lump);
    return rim;
  }
 
  // create new image
  rim = NewImage(width, height, false);
 
  rim-&gt;pub.offset_x = offset_x;
  rim-&gt;pub.offset_y = offset_y;

  strcpy(rim-&gt;name, name);

  rim-&gt;source_type = type;
  rim-&gt;source.patch.lump = lump;
  rim-&gt;source_palette = W_GetPaletteForLump(lump);

  return rim;
}
</t>
<t tx="T28">
static real_image_t *AddImageTexture(const char *name, 
    texturedef_t *tdef)
{
  real_image_t *rim;
 
  // assume it is non-solid, we'll update it when we know for sure
  rim = NewImage(tdef-&gt;width, tdef-&gt;height, false);
 
  strcpy(rim-&gt;name, name);

  rim-&gt;source_type = IMSRC_Texture;
  rim-&gt;source.texture.tdef = tdef;
  rim-&gt;source_palette = tdef-&gt;palette_lump;

  return rim;
}
</t>
<t tx="T29">
static real_image_t *AddImageFlat(const char *name, int lump)
{
  real_image_t *rim;
  int len, size;
  
  len = W_LumpLength(lump);
  
  switch (len)
  {
    case 64 * 64: size = 64; break;

    // support for odd-size Hexen flats
    case 64 * 128: size = 64; break;
  
    // -- EDGE feature: bigger than normal flats --
  
    case 128 * 128: size = 128; break;
    case 256 * 256: size = 256; break;
    case 512 * 512: size = 512; break;
    case 1024 * 1024: size = 1024; break;
    
    default:
      return NULL;
  }
   
  rim = NewImage(size, size, true);
 
  strcpy(rim-&gt;name, name);

  rim-&gt;source_type = IMSRC_Flat;
  rim-&gt;source.flat.lump = lump;
  rim-&gt;source_palette = W_GetPaletteForLump(lump);

  return rim;
}
</t>
<t tx="T30">@ W_ImageCreateFlats

Used to fill in the image array with flats from the WAD. The set
of lumps is those that occurred between F_START and F_END in each
existing wad file, with duplicates set to -1.

NOTE: should only be called once, as it assumes none of the flats
in the list have names colliding with existing flat images.
@c

void W_ImageCreateFlats(int *lumps, int number)
{
  int i;

  DEV_ASSERT2(lumps);

  for (i=0; i &lt; number; i++)
  {
    if (lumps[i] &lt; 0)
      continue;
    
    AddImageFlat(W_GetLumpName(lumps[i]), lumps[i]);
  }
}
</t>
<t tx="T31">@ W_ImageCreateTextures

Used to fill in the image array with textures from the WAD. The
list of texture definitions comes from each TEXTURE1/2 lump in each
existing wad file, with duplicates set to NULL.

NOTE: should only be called once, as it assumes none of the
textures in the list have names colliding with existing texture
images.
@c

void W_ImageCreateTextures(struct texturedef_s ** defs, int number)
{
  int i;

  DEV_ASSERT2(defs);

  for (i=0; i &lt; number; i++)
  {
    if (defs[i] == NULL)
      continue;
    
    AddImageTexture(defs[i]-&gt;name, defs[i]);
  }
}
</t>
<t tx="T32">@ W_ImageCreateSprite

Used to fill in the image array with sprites from the WAD. The
lumps come from those occurring between S_START and S_END markers
in each existing wad.

NOTE: it is assumed that each new sprite is unique i.e. the name
does not collide with any existing sprite image.
@c

const image_t *W_ImageCreateSprite(int lump)
{
  const real_image_t *rim;

  DEV_ASSERT2(lump &gt;= 0);

  rim = AddImagePatch(W_GetLumpName(lump), IMSRC_Sprite, lump);

  if (!rim)
    rim = RIM_DUMMY_SPRITE;

  return &amp;rim-&gt;pub;
}
</t>
<t tx="T33">@ ----------------------------------------------------------------------------

UTILITY
@c

#define PIXEL_RED(pix)  (what_palette[pix*3 + 0])
#define PIXEL_GRN(pix)  (what_palette[pix*3 + 1])
#define PIXEL_BLU(pix)  (what_palette[pix*3 + 2])

#define GAMMA_RED(pix)  (gammatable[usegamma][PIXEL_RED(pix)])
#define GAMMA_GRN(pix)  (gammatable[usegamma][PIXEL_GRN(pix)])
#define GAMMA_BLU(pix)  (gammatable[usegamma][PIXEL_BLU(pix)])

//
// ShrinkBlock
//
// Take a block of pixels, and compute a shrunk down version of it
// (for mipmapping), returning the new block of pixels.
//
static real_cached_image_t *ShrinkBlock(real_cached_image_t *src, int mip,
    const byte *what_palette)
{
  real_cached_image_t *dest;
  
  byte *pixels, *src_pixels;
  
  int x, y;
  int dx, dy;
  int step_x, step_y;

  int total_w = MIP_SIZE(src-&gt;parent-&gt;pub.total_w, src-&gt;mip);
  int total_h = MIP_SIZE(src-&gt;parent-&gt;pub.total_h, src-&gt;mip);

  int new_w = MIP_SIZE(src-&gt;parent-&gt;pub.total_w, mip);
  int new_h = MIP_SIZE(src-&gt;parent-&gt;pub.total_h, mip);

  int size = new_w * new_h;
  
  DEV_ASSERT2(mip &gt; src-&gt;mip);
  DEV_ASSERT2(new_w &gt; 0);
  DEV_ASSERT2(new_h &gt; 0);
  DEV_ASSERT2(size &gt; 0);
  DEV_ASSERT2(src-&gt;mode == IMG_Block);

  size += sizeof(real_cached_image_t);

  dest = (real_cached_image_t *) Z_Malloc(size);

  dest-&gt;next = dest-&gt;prev = NULL;
  dest-&gt;parent = src-&gt;parent;
  dest-&gt;mip = mip;
  dest-&gt;users = 0;
  dest-&gt;invalidated = false;
  dest-&gt;mode = IMG_Block;
  dest-&gt;info.block.pixels = (byte *)(dest + 1);
  dest-&gt;size = size;

  DEV_ASSERT2((total_w % new_w) == 0);
  DEV_ASSERT2((total_h % new_h) == 0);

  step_x = total_w / new_w;
  step_y = total_h / new_h;

  DEV_ASSERT2(step_x &gt; 1 || step_y &gt; 1);

  pixels = dest-&gt;info.block.pixels;
  src_pixels = src-&gt;info.block.pixels;
  
  // remember, blocks are in column-major order
  for (x=0; x &lt; new_w; x++)
  for (y=0; y &lt; new_h; y++)
  {
    int px = x * step_x;
    int py = y * step_y;

    int tot_r=0, tot_g=0, tot_b=0, a_count=0;
    int total = step_x * step_y;

    // compute average colour of block
    for (dx=0; dx &lt; step_x; dx++)
    for (dy=0; dy &lt; step_y; dy++)
    {
      byte pix = src_pixels[(px+dx) * total_h + (py+dy)];

      if (pix == TRANS_PIXEL)
        a_count++;
      else
      {
        tot_r += PIXEL_RED(pix);
        tot_g += PIXEL_GRN(pix);
        tot_b += PIXEL_BLU(pix);
      }
    }

    if (a_count &gt; total/2) 
      pixels[x * new_h + y] = TRANS_PIXEL;
    else
    {
      total -= a_count;

      tot_r = tot_r / total * 32 / 256;
      tot_g = tot_g / total * 32 / 256;
      tot_b = tot_b / total * 32 / 256;
      
      pixels[x * new_h + y] = rgb_32k[tot_r][tot_b][tot_g];
    }
  }

  return dest;
}
</t>
<t tx="T34">@ EnlargeBlock

Take a block of pixels, and compute a larger version of it
(anti-mipmapping), returning the new block of pixels.
@c

static real_cached_image_t *EnlargeBlock(real_cached_image_t *src, int mip,
    const byte *what_palette)
{
  real_cached_image_t *dest;
  
  byte *pixels, *src_pixels;
  
  int x, y;
  int dx, dy;
  int step_x, step_y;

  int total_w = MIP_SIZE(src-&gt;parent-&gt;pub.total_w, src-&gt;mip);
  int total_h = MIP_SIZE(src-&gt;parent-&gt;pub.total_h, src-&gt;mip);

  int new_w = MIP_SIZE(src-&gt;parent-&gt;pub.total_w, mip);
  int new_h = MIP_SIZE(src-&gt;parent-&gt;pub.total_h, mip);

  int size = new_w * new_h;
 
  DEV_ASSERT2(mip &lt; src-&gt;mip);
  DEV_ASSERT2(new_w &gt; 0);
  DEV_ASSERT2(new_h &gt; 0);
  DEV_ASSERT2(size &gt; 0);
  DEV_ASSERT2(src-&gt;mode == IMG_Block);

  size += sizeof(real_cached_image_t);

  dest = (real_cached_image_t *) Z_Malloc(size);

  dest-&gt;next = dest-&gt;prev = NULL;
  dest-&gt;parent = src-&gt;parent;
  dest-&gt;mip = mip;
  dest-&gt;users = 0;
  dest-&gt;invalidated = false;
  dest-&gt;mode = IMG_Block;
  dest-&gt;info.block.pixels = (byte *)(dest + 1);
  dest-&gt;size = size;

  DEV_ASSERT2((new_w % total_w) == 0);
  DEV_ASSERT2((new_h % total_h) == 0);

  step_x = new_w / total_w;
  step_y = new_h / total_h;

  DEV_ASSERT2(step_x &gt; 1 || step_y &gt; 1);

  pixels = dest-&gt;info.block.pixels;
  src_pixels = src-&gt;info.block.pixels;
  
  // remember, blocks are in column-major order
  for (x=0; x &lt; new_w; x++)
  for (y=0; y &lt; new_h; y++)
  {
    int tot_r=0, tot_g=0, tot_b=0, a_count=0;
    int total = step_x * step_y;

    // compute average colour of sub-pixel block
    for (dx=0; dx &lt; step_x; dx++)
    for (dy=0; dy &lt; step_y; dy++)
    {
      int px = MIN(x+dx, new_w-1) / step_x;
      int py = MIN(y+dy, new_h-1) / step_y;

      byte pix = src_pixels[px * total_h + py];

      if (pix == TRANS_PIXEL)
        a_count++;
      else
      {
        tot_r += PIXEL_RED(pix);
        tot_g += PIXEL_GRN(pix);
        tot_b += PIXEL_BLU(pix);
      }
    }

    if (a_count &gt; 0)
      pixels[x * new_h + y] = TRANS_PIXEL;
    else
    {
      total -= a_count;

      tot_r = tot_r / total * 32 / 256;
      tot_g = tot_g / total * 32 / 256;
      tot_b = tot_b / total * 32 / 256;
      
      pixels[x * new_h + y] = rgb_32k[tot_r][tot_b][tot_g];
    }
  }

  return dest;
}
</t>
<t tx="T35">@ DrawColumnIntoBlock

Clip and draw an old-style column from a patch into a blockified
image. Can also do a font conversion (make white).
@c

static void DrawColumnIntoBlock(real_cached_image_t *rc, 
    const column_t *patchcol, int x, int y, int font)
{
  int w1, h1, w2, h2;
  
  DEV_ASSERT2(patchcol);
  DEV_ASSERT2(rc-&gt;mode == IMG_Block);
  DEV_ASSERT2(rc-&gt;mip  == 0);

  w1 = MIP_SIZE(rc-&gt;parent-&gt;pub.actual_w, rc-&gt;mip);
  h1 = MIP_SIZE(rc-&gt;parent-&gt;pub.actual_h, rc-&gt;mip);
  w2 = MIP_SIZE(rc-&gt;parent-&gt;pub.total_w,  rc-&gt;mip);
  h2 = MIP_SIZE(rc-&gt;parent-&gt;pub.total_h,  rc-&gt;mip);

  // clip horizontally
  if (x &lt; 0 || x &gt;= w1)
    return;

  while (patchcol-&gt;topdelta != P_SENTINEL)
  {
    int top = y + (int) patchcol-&gt;topdelta;
    int count = patchcol-&gt;length;

    byte *src = (byte *) patchcol + 3;
    byte *dest = rc-&gt;info.block.pixels + (x * h2);

    if (top &lt; 0)
    {
      count += top;
      top = 0;
    }

    if (top + count &gt; h1)
      count = h1 - top;

    // copy the pixels, remapping any TRANS_PIXEL values
    for (dest += top; count &gt; 0; count--, src++, dest++)
    {
      if (*src == TRANS_PIXEL)
        *dest = pal_black;
#ifndef USE_GL
      else if (font == 2)
        *dest = halo_conv_table[*src];
#endif
      else if (font)
        *dest = font_whitener[*src];
      else
        *dest = *src;
    }

    patchcol = (const column_t *) ((const byte *) patchcol + 
        patchcol-&gt;length + 4);
  }
}
</t>
<t tx="T36">
#if 0  // NOT USED.  NOTE: code has rotted a bit
//
// DrawWPostIntoBlock
//
// Clip and draw a new-style w_post from a postified image into a
// blockified image. 
//
static void DrawWPostIntoBlock(real_cached_image_t *rc, 
    const w_post_t *post, int x, int y)
{
  DEV_ASSERT2(post);
  DEV_ASSERT2(rc-&gt;mode == IMG_Block);
  DEV_ASSERT2(rc-&gt;mip  == 0);

  // clip horizontally
  if (x &lt; 0 || x &gt;= rc-&gt;parent-&gt;pub.actual_w)
    return;

  while (post-&gt;skip != P_SENTINEL)
  {
    int top = y + post-&gt;skip;
    int count = post-&gt;length;

    byte *src = (byte *) post + 3;
    byte *dest = rc-&gt;info.block.pixels + (x * rc-&gt;parent-&gt;pub.total_h);

    if (top &lt; 0)
    {
      count += top;
      top = 0;
    }

    if (top + count &gt; rc-&gt;parent-&gt;pub.actual_h)
      count = rc-&gt;parent-&gt;pub.actual_h - top;

    // copy the pixels (if any).  No remapping needed.
    if (count &gt; 0)
      Z_MoveData(dest+top, src, byte, count);

    y += post-&gt;skip + post-&gt;length;

    post = (const w_post_t *) ((const byte *) post + post-&gt;length + 4);
  }
}
</t>
<t tx="T37">#endif

//
// CheckBlockSolid
//
// FIXME: Avoid future checks.
//
#define MAX_STRAY_PIXELS  2

static void CheckBlockSolid(real_cached_image_t *rc)
{
  int x, y;
  int total_num;
  int stray_count=0;

  int w1, h1, w2, h2;

  byte *src;

  DEV_ASSERT2(rc-&gt;mode == IMG_Block);
  DEV_ASSERT2(rc-&gt;mip  == 0);

  w1 = MIP_SIZE(rc-&gt;parent-&gt;pub.actual_w, rc-&gt;mip);
  h1 = MIP_SIZE(rc-&gt;parent-&gt;pub.actual_h, rc-&gt;mip);
  w2 = MIP_SIZE(rc-&gt;parent-&gt;pub.total_w,  rc-&gt;mip);
  h2 = MIP_SIZE(rc-&gt;parent-&gt;pub.total_h,  rc-&gt;mip);

  src = rc-&gt;info.block.pixels;

  total_num = w1 * h1;

  for (x=0; x &lt; w1; x++)
  for (y=0; y &lt; h1; y++)
  {
    byte src_pix = src[x * h2 + y];

    if (src_pix != TRANS_PIXEL)
      continue;

    stray_count++;

    // only ignore stray pixels on large images
    if (total_num &lt; 256 || stray_count &gt; MAX_STRAY_PIXELS)
      return;
  }

  // image is totally solid.  Blacken any transparent parts.
  rc-&gt;parent-&gt;pub.solid = true;

  for (x=0; x &lt; w2; x++)
  for (y=0; y &lt; h2; y++)
  {
    if (x &gt;= w1 || y &gt;= h1 || src[x * h2 + y] == TRANS_PIXEL)
    {
      src[x * h2 + y] = pal_black;
    }
  }
}
</t>
<t tx="T38">@ ConvertBlockToPost

Converts a blockified image to a postified one. Returns a new
cached image. New image has same parent and mip as source, but
users field will be 0 (bump up if used).
@c

#define MAX_POST_H  240

#define ADD_BYTE(value)  \
do {  \
  if (buf_pos == buf_size)  \
  {  \
    buf_size += 1024;  \
    Z_Resize(buf_start, byte, buf_size);  \
  }  \
  buf_start[buf_pos++] = (value);  \
} while(0)

static real_cached_image_t *ConvertBlockToPost(real_cached_image_t *rc)
{
int i, x, y;
int len, skip, size;
int *offsets; 

byte *buf_start, *dest;
int buf_size = 1024;
int buf_pos = 0;

int w1, h1, w2, h2;

real_cached_image_t *result;

DEV_ASSERT2(rc);
DEV_ASSERT2(rc-&gt;mode == IMG_Block);

w1 = MIP_SIZE(rc-&gt;parent-&gt;pub.actual_w, rc-&gt;mip);
h1 = MIP_SIZE(rc-&gt;parent-&gt;pub.actual_h, rc-&gt;mip);
w2 = MIP_SIZE(rc-&gt;parent-&gt;pub.total_w, rc-&gt;mip);
h2 = MIP_SIZE(rc-&gt;parent-&gt;pub.total_h, rc-&gt;mip);

// allocate initial post &amp; offset buffers
buf_start = Z_New(byte, buf_size);
offsets = Z_New(int, w2);

// handle columns outside of actual width: for transparent images,
// mark the columns as empty, otherwise for solid images add a
// custom post at offset 0 that contains all black.

if (w1 &lt; w2)
{
if (rc-&gt;parent-&gt;pub.solid)
{
  for (y=0; y &lt; h1; )
  {
    len = MIN(h1 - y, MAX_POST_H);

    DEV_ASSERT2(len &gt; 0);

    ADD_BYTE(0);     // skip
    ADD_BYTE(len);   // length
    
    for (i=0; i &lt; len+2; i++)
    {
      ADD_BYTE(pal_black);  // pixels and two pad bytes
    }
  }

  // add end-of-column sentinel
  ADD_BYTE(P_SENTINEL);

  for (x=w1; x &lt; w2; x++)
    offsets[x] = 0;
}
else
{
  for (x=w1; x &lt; w2; x++)
    offsets[x] = -1;
}
}

// convert the blockified columns into posts
for (x=0; x &lt; w1; x++)
{
byte *src = &amp;rc-&gt;info.block.pixels[x * h2];

// completely transparent ?
for (len=0; len &lt; h1 &amp;&amp; src[len] == TRANS_PIXEL; len++)
{ /* nothing here */ }

if (len == h1)
{
  offsets[x] = -1;
  continue;
}

// postify the column
offsets[x] = buf_pos;

for (y=0; y &lt; h1; )
{ 
  // determine how many transparent pixels to skip
  for (skip=0; (y + skip &lt; h1) &amp;&amp; 
       src[y + skip] == TRANS_PIXEL; skip++)
  { /* nothing here */ }
   
  y += skip;
  DEV_ASSERT2(y &lt;= h1);

  // rest of column is totally transparent ?
  if (y == h1)
    break;

  // if necessary, add empty posts to get around limit
  for (; skip &gt; MAX_POST_H; skip -= MAX_POST_H)
  {
    ADD_BYTE(MAX_POST_H);  // skip
    ADD_BYTE(0);           // length
    ADD_BYTE(pal_black);   // pad1
    ADD_BYTE(pal_black);   // pad2
  }

  // determine number of non-transparent pixels
  for (len=0; (y + len &lt; h1) &amp;&amp; (len &lt; MAX_POST_H) &amp;&amp;
       src[y + len] != TRANS_PIXEL; len++)
  { /* nothing here */ }

  DEV_ASSERT2(len &gt; 0);
  DEV_ASSERT2(len &lt;= MAX_POST_H);

  ADD_BYTE(skip);     // skip
  ADD_BYTE(len);      // length
  ADD_BYTE(src[y]);   // pad1

  // copy pixels in post
  for (; len &gt; 0; len--, y++)
  {
    ADD_BYTE(src[y]);
  }
  
  ADD_BYTE(src[y-1]);  // pad2
}

DEV_ASSERT2(buf_pos &gt; offsets[x]);

// add end-of-column sentinel
ADD_BYTE(P_SENTINEL);
}

// Phew... Now create and fill out the result image

size = sizeof(real_cached_image_t) + buf_pos + w2 * sizeof(w_post_t*);

result = (real_cached_image_t *) Z_Malloc(size);

result-&gt;next = result-&gt;prev = NULL;
result-&gt;parent = rc-&gt;parent;
result-&gt;mip = rc-&gt;mip;
result-&gt;users = 0;
result-&gt;invalidated = false;
result-&gt;mode = IMG_Post;
result-&gt;info.post.columns = (w_post_t **)(result + 1);
result-&gt;size = size;

dest = (byte *) (&amp;result-&gt;info.post.columns[w2]);

if (buf_pos &gt; 0)
Z_MoveData(dest, buf_start, byte, buf_pos);

for (x=0; x &lt; w2; x++)
result-&gt;info.post.columns[x] =
    (offsets[x] &lt; 0) ? NULL : (w_post_t *)(dest + offsets[x]);

// free stuff
Z_Free(buf_start);
Z_Free(offsets);

return result;
}
</t>
<t tx="T39">
#undef ADD_BYTE


//----------------------------------------------------------------------------

//
//  GL UTILITIES
//

#ifdef USE_GL

//
// ShrinkBlockRGBA
//
// Just like ShrinkBlock() above, but the returned format is RGBA.
// Source format is column-major (i.e. normal block), whereas result
// is row-major (ano note that GL textures are _bottom up_ rather than
// the usual top-down ordering).  The new size should be scaled down
// to fit into glmax_tex_size.
//
static byte *ShrinkBlockRGBA(byte *src, int total_w, int total_h,
    int new_w, int new_h, const byte *what_palette)
{
  byte *dest;
 
  int x, y, dx, dy;
  int step_x, step_y;

  DEV_ASSERT2(new_w &gt; 0);
  DEV_ASSERT2(new_h &gt; 0);
  DEV_ASSERT2(new_w &lt;= glmax_tex_size);
  DEV_ASSERT2(new_h &lt;= glmax_tex_size);
  DEV_ASSERT2((total_w % new_w) == 0);
  DEV_ASSERT2((total_h % new_h) == 0);

  dest = (byte *) Z_New(byte, new_w * new_h * 4);

  step_x = total_w / new_w;
  step_y = total_h / new_h;

  // faster method for the usual case (no shrinkage)

  if (step_x == 1 &amp;&amp; step_y == 1)
  {
    for (y=0; y &lt; total_h; y++)
    for (x=0; x &lt; total_w; x++)
    {
      byte src_pix = src[x * total_h + y];
      byte *dest_pix = dest + (((total_h-1-y) * total_w + x) * 4);

      if (src_pix == TRANS_PIXEL)
      {
        dest_pix[0] = dest_pix[1] = dest_pix[2] = dest_pix[3] = 0;
      }
      else
      {
        dest_pix[0] = GAMMA_RED(src_pix);
        dest_pix[1] = GAMMA_GRN(src_pix);
        dest_pix[2] = GAMMA_BLU(src_pix);
        dest_pix[3] = 255;
      }
    }
    return dest;
  }

  // slower method, as we must shrink the bugger...

  for (y=0; y &lt; new_h; y++)
  for (x=0; x &lt; new_w; x++)
  {
    byte *dest_pix = dest + (((new_h-1-y) * new_w + x) * 4);

    int px = x * step_x;
    int py = y * step_y;

    int tot_r=0, tot_g=0, tot_b=0, a_count=0, alpha;
    int total = step_x * step_y;

    // compute average colour of block
    for (dx=0; dx &lt; step_x; dx++)
    for (dy=0; dy &lt; step_y; dy++)
    {
      byte src_pix = src[(px+dx) * total_h + (py+dy)];

      if (src_pix == TRANS_PIXEL)
        a_count++;
      else
      {
        tot_r += GAMMA_RED(src_pix);
        tot_g += GAMMA_GRN(src_pix);
        tot_b += GAMMA_BLU(src_pix);
      }
    }

    if (a_count &gt;= total)
    {
      // some pixels were translucent.  Keep r/g/b as zero.
      alpha = 0;
    }
    else
    {
      alpha = (total - a_count) * 255 / total;

      total -= a_count;

      tot_r /= total;
      tot_g /= total;
      tot_b /= total;
    }

    dest_pix[0] = tot_r;
    dest_pix[1] = tot_g;
    dest_pix[2] = tot_b;
    dest_pix[3] = alpha;
  }

  return dest;
}
</t>
<t tx="T40">@ ConvertHaloGL

Convert the RGBA image (which should have come from an IMSRC_Halo
patch, which gets passed through font_whitener[]) into a halo image
(with smooth alpha gradients).
@c

static void ConvertHaloGL(byte *src, int width, int height)
{
  int x, y;

  DEV_ASSERT2(width  &gt; 0);
  DEV_ASSERT2(height &gt; 0);

  for (y=0; y &lt; height; y++)
  for (x=0; x &lt; width;  x++)
  {
    byte *pix = src + ((y * width + x) * 4);

#if 1
    pix[3] = pix[1] * pix[3] / 255;
#else
    int dx = x - width/2;
    int dy = y - height/2;

    float_t len = sqrt(width*width/4.0 + height*height/4.0);
    float_t dist = sqrt(dx*dx + dy*dy);

    pix[3] = MAX(0, (int)(255 * (1.0 - 2.0 * dist / len)));
#endif

    // halos are all white, only the alpha varies
    pix[0] = pix[1] = pix[2] = 255;
    pix[2] = 0;
  }
}
</t>
<t tx="T41">@ W_SendGLTexture

Send the texture data to the GL, and returns the texture ID
assigned to it. The format of the data must be a normal block if
palette-indexed pixels.
@c

static GLuint minif_modes[2*3] =
{
  GL_NEAREST,
  GL_NEAREST_MIPMAP_NEAREST,
  GL_NEAREST_MIPMAP_LINEAR,
  
  GL_LINEAR,
  GL_LINEAR_MIPMAP_NEAREST,
  GL_LINEAR_MIPMAP_LINEAR
};

GLuint W_SendGLTexture(byte *src, int total_w, int total_h,
    boolean_t clamp, boolean_t halo, boolean_t nomip, 
    const byte *what_palette)
{
  GLuint id;
  
  byte *rgba_src;
  int new_w, new_h;
  int mip;

  // scale down, if necessary, to fix the maximum size
  for (new_w = total_w; new_w &gt; glmax_tex_size; new_w /= 2)
  { /* nothing here */ }

  for (new_h = total_h; new_h &gt; glmax_tex_size; new_h /= 2)
  { /* nothing here */ }

  glEnable(GL_TEXTURE_2D);

  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

  glGenTextures(1, &amp;id);
  glBindTexture(GL_TEXTURE_2D, id);

  if (clamp)
  {
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
  }
  else
  {
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  }

  // magnification mode
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      use_smoothing ? GL_LINEAR : GL_NEAREST);

  // minification mode
  use_mipmapping = MIN(2, MAX(0, use_mipmapping));

  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
      minif_modes[(use_smoothing ? 3 : 0) +
      (nomip ? 0 : use_mipmapping)]);

  for (mip=0; ; mip++)
  {
    rgba_src = ShrinkBlockRGBA(src, total_w, total_h, new_w, new_h, 
        what_palette);
    
    if (halo)
      ConvertHaloGL(rgba_src, new_w, new_h);

    glTexImage2D(GL_TEXTURE_2D, mip, 4, new_w, new_h,
                 0, GL_RGBA, GL_UNSIGNED_BYTE, rgba_src);
    
    Z_Free(rgba_src);

    // stop if mipmapping disabled or we have reached the end
    if (nomip || !use_mipmapping || (new_w == 1 &amp;&amp; new_h == 1))
      break;
    
    new_w = MAX(1, new_w / 2);
    new_h = MAX(1, new_h / 2);
  }

  glDisable(GL_TEXTURE_2D);

  return id;
}
</t>
<t tx="T42">
#endif  // USE_GL


//----------------------------------------------------------------------------

//
//  BLOCK READING STUFF
//

//
// ReadFlatAsBlock
//
// Loads a flat from the wad and returns the image block for it.
// Doesn't do any mipmapping (this is too "raw" if you follow).
//
static real_cached_image_t *ReadFlatAsBlock(real_image_t *rim)
{
  real_cached_image_t *rc;

  const byte *src;
  byte *dest;

  int x, y, w, h, tw, th, size;

  DEV_ASSERT2(rim-&gt;source_type == IMSRC_Flat ||
              rim-&gt;source_type == IMSRC_Raw320x200);

  tw = MAX(rim-&gt;pub.total_w, 1);
  th = MAX(rim-&gt;pub.total_h, 1);

  w = rim-&gt;pub.actual_w;
  h = rim-&gt;pub.actual_h;

  size = tw * th;
  size += sizeof(real_cached_image_t);
  
  rc = (real_cached_image_t *) Z_Malloc(size);
  dest = (byte *)(rc + 1);

  // clear initial image to black
  memset(dest, pal_black, tw * th);
   
  rc-&gt;next = rc-&gt;prev = NULL;
  rc-&gt;parent = rim;
  rc-&gt;mip = 0;
  rc-&gt;users = 0;
  rc-&gt;invalidated = false;
  rc-&gt;mode = IMG_Block;
  rc-&gt;info.block.pixels = dest;
  rc-&gt;size = size;

  // read in pixels
  src = W_CacheLumpNum(rim-&gt;source.flat.lump);

  for (y=0; y &lt; h; y++)
  for (x=0; x &lt; w; x++)
  {
    byte src_pix = src[y * w + x];

    // remember, blocks are in column-major format
    byte *dest_pix = &amp;dest[x * th + y];

    // make sure TRANS_PIXEL values (which do not occur naturally in
    // Doom images) are properly remapped.
    if (src_pix == TRANS_PIXEL)
      dest_pix[0] = pal_black;
    else
      dest_pix[0] = src_pix;
  }

  W_DoneWithLump(src);

  return rc;
}
</t>
<t tx="T43">@ ReadTextureAsBlock

Loads a texture from the wad and returns the image block for it.
Doesn't do any mipmapping (this is too "raw" if you follow). This
routine will also update the `solid' flag if texture turns out to
be solid.
@c

static real_cached_image_t *ReadTextureAsBlock(real_image_t *rim)
{
  real_cached_image_t *rc;

  texturedef_t *tdef;
  texpatch_t *patch;
  const patch_t *realpatch;
  const column_t *patchcol;

  byte *dest;

  int i, x, x1, x2, y1;
  int pix_size, size;

  DEV_ASSERT2(rim-&gt;source_type == IMSRC_Texture);

  tdef = rim-&gt;source.texture.tdef;
  DEV_ASSERT2(tdef);

  pix_size = rim-&gt;pub.total_w * rim-&gt;pub.total_h;
  size = pix_size + sizeof(real_cached_image_t);
  
  rc = (real_cached_image_t *) Z_Malloc(size);
  dest = (byte *)(rc + 1);

  rc-&gt;next = rc-&gt;prev = NULL;
  rc-&gt;parent = rim;
  rc-&gt;mip = 0;
  rc-&gt;users = 0;
  rc-&gt;invalidated = false;
  rc-&gt;mode = IMG_Block;
  rc-&gt;info.block.pixels = dest;
  rc-&gt;size = size;

  // Clear initial pixels to either totally transparent, or totally
  // black (if we know the image should be solid).  If the image turns
  // out to be solid instead of transparent, the transparent pixels
  // will be blackened.
  
  if (rc-&gt;parent-&gt;pub.solid)
    memset(dest, pal_black, pix_size);
  else
    memset(dest, TRANS_PIXEL, pix_size);

  // Composite the columns into the block.
  for (i=0, patch=tdef-&gt;patches; i &lt; tdef-&gt;patchcount; i++, patch++)
  {
    realpatch = W_CacheLumpNum(patch-&gt;patch);

    x1 = patch-&gt;originx;
    y1 = patch-&gt;originy;
    x2 = x1 + SHORT(realpatch-&gt;width);

    x  = MAX(0, x1);
    x2 = MIN(tdef-&gt;width, x2);

    for (; x &lt; x2; x++)
    {
      patchcol = (const column_t *) ((const byte *) realpatch +
          LONG(realpatch-&gt;columnofs[x - x1]));

      DrawColumnIntoBlock(rc, patchcol, x, y1, false);
    }

    W_DoneWithLump(realpatch);
  }

  // update solid flag, if needed
  if (! rc-&gt;parent-&gt;pub.solid)
    CheckBlockSolid(rc);

  return rc;
}
</t>
<t tx="T44">@ ReadPatchAsBlock

Loads a patch from the wad and returns the image block for it.
Very similiar to ReadTextureAsBlock() above. Doesn't do any
mipmapping (this is too "raw" if you follow). This routine will
also update the `solid' flag if it turns out to be 100% solid.
@c

static real_cached_image_t *ReadPatchAsBlock(real_image_t *rim,
    int font)
{
  real_cached_image_t *rc;

  const patch_t *realpatch;
  const column_t *patchcol;

  byte *dest;

  int x;
  int pix_size, size;

  DEV_ASSERT2(rim-&gt;source_type == IMSRC_Patch ||
      rim-&gt;source_type == IMSRC_Font ||
      rim-&gt;source_type == IMSRC_Halo ||
      rim-&gt;source_type == IMSRC_Sprite);

  pix_size = rim-&gt;pub.total_w * rim-&gt;pub.total_h;
  size = pix_size + sizeof(real_cached_image_t);
  
  rc = (real_cached_image_t *) Z_Malloc(size);
  dest = (byte *)(rc + 1);

  rc-&gt;next = rc-&gt;prev = NULL;
  rc-&gt;parent = rim;
  rc-&gt;mip = 0;
  rc-&gt;users = 0;
  rc-&gt;invalidated = false;
  rc-&gt;mode = IMG_Block;
  rc-&gt;info.block.pixels = dest;
  rc-&gt;size = size;

  // Clear initial pixels to either totally transparent, or totally
  // black (if we know the image should be solid).  If the image turns
  // out to be solid instead of transparent, the transparent pixels
  // will be blackened.
  
  if (rc-&gt;parent-&gt;pub.solid)
    memset(dest, pal_black, pix_size);
  else
    memset(dest, TRANS_PIXEL, pix_size);

  // Composite the columns into the block.
  realpatch = W_CacheLumpNum(rim-&gt;source.patch.lump);

  DEV_ASSERT2(rim-&gt;pub.actual_w == SHORT(realpatch-&gt;width));
  DEV_ASSERT2(rim-&gt;pub.actual_h == SHORT(realpatch-&gt;height));
  
  for (x=0; x &lt; rim-&gt;pub.actual_w; x++)
  {
    patchcol = (const column_t *) ((const byte *) realpatch +
        LONG(realpatch-&gt;columnofs[x]));

    DrawColumnIntoBlock(rc, patchcol, x, 0, font);
  }

  W_DoneWithLump(realpatch);

  // update solid flag, if needed
  if (! rc-&gt;parent-&gt;pub.solid)
    CheckBlockSolid(rc);

  return rc;
}
</t>
<t tx="T45">@ ReadDummyAsBlock

Creates a dummy image.
@c

static real_cached_image_t *ReadDummyAsBlock(real_image_t *rim)
{
  real_cached_image_t *rc;
  byte *dest;

  int x, y;
  int size;

  DEV_ASSERT2(rim-&gt;source_type == IMSRC_Dummy);
  DEV_ASSERT2(rim-&gt;pub.actual_w == rim-&gt;pub.total_w);
  DEV_ASSERT2(rim-&gt;pub.actual_h == rim-&gt;pub.total_h);
  DEV_ASSERT2(rim-&gt;pub.total_w == DUMMY_X);
  DEV_ASSERT2(rim-&gt;pub.total_h == DUMMY_Y);

  size = rim-&gt;pub.total_w * rim-&gt;pub.total_h;
  size += sizeof(real_cached_image_t);
  
  rc = (real_cached_image_t *) Z_Malloc(size);
  dest = (byte *)(rc + 1);

  rc-&gt;next = rc-&gt;prev = NULL;
  rc-&gt;parent = rim;
  rc-&gt;mip = 0;
  rc-&gt;users = 0;
  rc-&gt;invalidated = false;
  rc-&gt;mode = IMG_Block;
  rc-&gt;info.block.pixels = dest;
  rc-&gt;size = size;

  // copy pixels
  for (y=0; y &lt; DUMMY_Y; y++)
  for (x=0; x &lt; DUMMY_X; x++)
  {
    byte src_pix = dummy_graphic[y * DUMMY_X + x];

    // remember, blocks are in column-major format
    byte *dest_pix = dest + (x * rim-&gt;pub.total_h + y);

    *dest_pix = src_pix ? rim-&gt;source.dummy.fg : rim-&gt;source.dummy.bg;
  }

  return rc;
}
</t>
<t tx="T46">@ ReadAsBlock

Read the image from the wad, applying the mip value to shrink it
appropriately, and returns the cached image (blockified). Never
returns NULL. Mainly just a switch to more specialised image
readers.
@c

static real_cached_image_t *ReadAsBlock(real_image_t *rim, int mip)
{
  real_cached_image_t *rc, *rc2;
  const byte *what_palette;

  switch (rim-&gt;source_type)
  {
    case IMSRC_Flat:
    case IMSRC_Raw320x200:
      rc = ReadFlatAsBlock(rim);
      break;

    case IMSRC_Texture:
      rc = ReadTextureAsBlock(rim);
      break;

    case IMSRC_Patch:
    case IMSRC_Sprite:
      rc = ReadPatchAsBlock(rim, 0);
      break;

    case IMSRC_Font:
      rc = ReadPatchAsBlock(rim, 1);
      break;

    case IMSRC_Halo:
      rc = ReadPatchAsBlock(rim, 2);
      break;

    case IMSRC_Dummy:
      rc = ReadDummyAsBlock(rim);
      break;
    
    case IMSRC_User:
      I_Error("IMSRC_User: not yet implemented.\n");
      rc = NULL;  // keep GCC happy
      break;
      
    default:
      I_Error("ReadAsBlock: unknown source_type %d !\n", rim-&gt;source_type);
      return NULL;
  }

  if (mip == rc-&gt;mip)
    return rc;

  what_palette = (const byte *) &amp;playpal_data[0];

  if (mip &lt; rc-&gt;mip)
    rc2 = EnlargeBlock(rc, mip, what_palette);
  else
    rc2 = ShrinkBlock(rc, mip, what_palette);
 
  // free the old one.  Note: there's nothing in it that needs special
  // handling.
  Z_Free(rc);

  return rc2;
}
</t>
<t tx="T47">@ ----------------------------------------------------------------------------

POST READING STUFF
@c

#define O_TOPDELTA  W_SKIP
#define O_LENGTH    W_LEN

static void TranslateColumn(real_cached_image_t *rc,
    w_post_t *pos, byte *processed, int remaining, int font)
{
  int i, y;

  DEV_ASSERT2(remaining &gt; 0);

  for (y=0; pos[O_TOPDELTA] != P_SENTINEL; )
  {
    int top   = pos[O_TOPDELTA];
    int count = pos[O_LENGTH];

    if (processed[0])
      return;
 
    // convert topdelta to w_post_t skip value
    pos[W_SKIP] = MAX(0, top - y);
    pos[W_LEN]  = count;
    pos[W_PAD1] = pos[W_DATA];
    pos[W_DATA+count] = pos[W_DATA+count-1];

    *processed++ = 1;
    *processed++ = 1;
 
    // translate post pixels
    for (i=0; i &lt; count+2; i++)
    {
      // make sure TRANS_PIXEL values are properly remapped, since
      // they don't have any special meaning in DOOM images.
      if (pos[W_PAD1+i] == TRANS_PIXEL)
        pos[W_PAD1+i] = pal_black;
#ifndef USE_GL
      else if (font == 2)
        pos[W_PAD1+i] = halo_conv_table[pos[W_PAD1+i]];
#endif
      else if (font)
        pos[W_PAD1+i] = font_whitener[pos[W_PAD1+i]];
      else
        pos[W_PAD1+i] = pos[W_PAD1+i];

      *processed++ = 1;
    }

    y = top + count;

    pos += count + W_TOTAL;
    remaining -= count + W_TOTAL;

    // size check
    DEV_ASSERT2(remaining &gt; 0);
  }

  *processed = 1;
}
</t>
<t tx="T48">
static real_cached_image_t *ReadPatchAsPost(real_image_t *rim, 
    int font)
{
  real_cached_image_t *rc;
  const patch_t *realpatch;
  
  byte *start;
  byte *processed;

  int x, size, post_size, head_size;

  DEV_ASSERT2(rim-&gt;source_type == IMSRC_Patch ||
      rim-&gt;source_type == IMSRC_Font ||
      rim-&gt;source_type == IMSRC_Halo ||
      rim-&gt;source_type == IMSRC_Sprite);

  // compute size of the post data itself (nothing else)
  head_size = 8 + rim-&gt;pub.actual_w * 4;
  post_size = W_LumpLength(rim-&gt;source.patch.lump) - head_size;

  // minimum size is 1 byte
  DEV_ASSERT2(post_size &gt;= 1);

  size = post_size + rim-&gt;pub.total_w * sizeof(w_post_t *);
  size += sizeof(real_cached_image_t);
  
  rc = (real_cached_image_t *) Z_Malloc(size);

  rc-&gt;next = rc-&gt;prev = NULL;
  rc-&gt;parent = rim;
  rc-&gt;mip = 0;
  rc-&gt;users = 0;
  rc-&gt;invalidated = false;
  rc-&gt;mode = IMG_Post;
  rc-&gt;info.post.columns = (w_post_t **)(rc + 1);
  rc-&gt;size = size;

  start  = (byte *) (&amp;rc-&gt;info.post.columns[rim-&gt;pub.total_w]);

  realpatch = W_CacheLumpNum(rim-&gt;source.patch.lump);

  // copy the raw columns
  memcpy(start, (byte *)realpatch + head_size, post_size);

  // allocate a map of processed bytes within the patch.  Since some
  // patches contain multiple references to the same column (a kind of
  // compression), the map prevents translating the same column twice.
  processed = Z_ClearNew(byte, post_size);

  for (x=0; x &lt; rim-&gt;pub.actual_w; x++)
  {
    int offset = LONG(realpatch-&gt;columnofs[x]) - head_size;

    DEV_ASSERT2(0 &lt;= offset &amp;&amp; offset &lt; post_size);

    rc-&gt;info.post.columns[x] = (w_post_t *)(start + offset);
    
    TranslateColumn(rc, rc-&gt;info.post.columns[x], processed + offset,
        post_size - offset, font);
  }
 
  W_DoneWithLump(realpatch);

  Z_Free(processed);

  // clear remaining columns (if any)
  for (x=rim-&gt;pub.actual_w+1; x &lt; rim-&gt;pub.total_w; x++)
    rc-&gt;info.post.columns[x] = NULL;

  return rc;
}
</t>
<t tx="T49">@ ReadAsPost

Read the image from the wad, applying the mip value to shrink it
appropriately, and returns the cached image (postified). Never
returns NULL.
@c

static real_cached_image_t *ReadAsPost(real_image_t *rim, int mip)
{
  real_cached_image_t *rc, *rc2;

  // for patches at mip #0, read the posts in the lump directly
  if (mip == 0 &amp;&amp;
      (rim-&gt;source_type == IMSRC_Patch ||
       rim-&gt;source_type == IMSRC_Font ||
       rim-&gt;source_type == IMSRC_Halo ||
       rim-&gt;source_type == IMSRC_Sprite))
  {
    return ReadPatchAsPost(rim, (rim-&gt;source_type == IMSRC_Font) ? 1 :
        (rim-&gt;source_type == IMSRC_Halo) ? 2 : 0);
  }

  // Handle everything else by reading as a block and converting. 
  // OPTIMISE: For single-patch textures, read posts directly.

  rc = ReadAsBlock(rim, mip);

  rc2 = ConvertBlockToPost(rc);

  // free the old one.  Note: there's nothing in it that needs special
  // handling.
  Z_Free(rc);

  return rc2;
}
</t>
<t tx="T50">@ ----------------------------------------------------------------------------

IMAGE LOADING / UNLOADING
@c

static INLINE
real_cached_image_t *LoadImagePost(real_image_t *rim)
{
  // OPTIMISE: check if a blockified version at mip #0 already exists,
  // saving us the trouble to read from the WAD.
 
  real_cached_image_t *rc;
  
  rc = ReadAsPost(rim, 0);

  DEV_ASSERT2(rc-&gt;mode == IMG_Post);

  rc-&gt;users++;
  InsertAtTail(rc);

  return rc;
}
</t>
<t tx="T51">
static INLINE
real_cached_image_t *LoadImageBlock(real_image_t *rim, int mip)
{
  // OPTIMISE: check if a blockified version at a lower mip already
  // exists, saving us the trouble to read the stuff from the WAD.
 
  real_cached_image_t *rc;
  
  rc = ReadAsBlock(rim, mip);

  DEV_ASSERT2(rc-&gt;mode == IMG_Block);

  rc-&gt;users++;
  InsertAtTail(rc);

  return rc;
}
</t>
<t tx="T52">
#ifdef USE_GL

static INLINE
real_cached_image_t *LoadImageOGL(real_image_t *rim)
{
  real_cached_image_t *rc, *tmp_rc;
  int size;

  boolean_t clamp = false;
  boolean_t halo  = false;
  
  const byte *what_palette;
  boolean_t what_pal_cached = false;
  
  tmp_rc = ReadAsBlock(rim, 0);

  DEV_ASSERT2(tmp_rc-&gt;mode == IMG_Block);

  rc = (real_cached_image_t *) Z_New(real_cached_image_t,1);

  if (rim-&gt;source_type &lt;= IMSRC_Sprite)
    clamp = true;
   
  if (rim-&gt;source_type == IMSRC_Halo)
    halo = true;
   
  if (rim-&gt;source_palette &lt; 0)
    what_palette = (const byte *) &amp;playpal_data[0];
  else
  {
    what_palette = W_CacheLumpNum(rim-&gt;source_palette);
    what_pal_cached = true;
  }

  // compute approximate size (including mipmaps)
  size = sizeof(real_cached_image_t) +
         rim-&gt;pub.total_w * rim-&gt;pub.total_h * 16 / 3;

  rc-&gt;next = rc-&gt;prev = NULL;
  rc-&gt;parent = rim;
  rc-&gt;mip = 0;
  rc-&gt;users = 0;
  rc-&gt;invalidated = false;
  rc-&gt;mode = IMG_OGL;
  rc-&gt;size = size;

  rc-&gt;info.ogl.tex_id = W_SendGLTexture(tmp_rc-&gt;info.block.pixels,
      rim-&gt;pub.total_w, rim-&gt;pub.total_h, clamp, halo, false, 
      what_palette);

  // free the blockified one.  Note: there's nothing in it that needs
  // special handling.
  Z_Free(tmp_rc);

  if (what_pal_cached)
    W_DoneWithLump(what_palette);

  rc-&gt;users++;
  InsertAtTail(rc);

  return rc;
}
</t>
<t tx="T53">#endif  // USE_GL


static INLINE 
void UnloadImagePost(real_cached_image_t *rc, real_image_t *rim)
{
  // nothing to do, column &amp; post data were allocated with the
  // real_cached_image_t structure.
}
</t>
<t tx="T54">
static INLINE 
void UnloadImageBlock(real_cached_image_t *rc, real_image_t *rim)
{
  // nothing to do, pixel data was allocated along with the
  // real_cached_image_t structure.
}
</t>
<t tx="T55">
#ifdef USE_GL

static INLINE 
void UnloadImageOGL(real_cached_image_t *rc, real_image_t *rim)
{
  glDeleteTextures(1, &amp;rc-&gt;info.ogl.tex_id);
}
</t>
<t tx="T56">#endif  // USE_GL


//
// UnloadImage
//
// Unloads a cached image from the cache list and frees all resources.
// Mainly just a switch to more specialised image unloaders.
//
static void UnloadImage(real_cached_image_t *rc)
{
  real_image_t *rim = rc-&gt;parent;

  DEV_ASSERT2(rc);
  DEV_ASSERT2(rc != &amp;imagecachehead);
  DEV_ASSERT2(rim);
  DEV_ASSERT2(rc-&gt;users == 0);

  // unlink from the cache list
  Unlink(rc);

  cache_size -= rc-&gt;size;

  switch (rc-&gt;mode)
  {
    case IMG_Post:
    {
      UnloadImagePost(rc, rim);
      rim-&gt;post_cache = NULL;
      break;
    }
      
    case IMG_Block:
    {
      UnloadImageBlock(rc, rim);
      rim-&gt;block_cache.mips[rc-&gt;mip] = NULL;
      break;
    }

    case IMG_OGL:
#ifdef USE_GL
    {
      UnloadImageOGL(rc, rim);
      rim-&gt;ogl_cache = NULL;
    }
#endif
      break;

    default:
      I_Error("UnloadImage: bad mode %d !\n", rc-&gt;mode);
  }

  // finally, free the rest of the mem
  Z_Free(rc);
}
</t>
<t tx="T57">@ ----------------------------------------------------------------------------

IMAGE LOOKUP


W_ImageFromTexture

Returns NULL for the no texture marker '-', otherwise the result is
a valid image. Note: search must be case insensitive.
@c

const image_t *W_ImageFromTexture(const char *tex_name)
{
  int i;
  const real_image_t *rim;

  // "NoTexture" marker.
  if (!tex_name || !tex_name[0] || tex_name[0] == '-')
    return NULL;
 
  // look for name in current list
  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (rim-&gt;source_type != IMSRC_Texture)
      continue;

    if (stricmp(tex_name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }
  
  // backup plan: try a flat with the same name

  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (rim-&gt;source_type != IMSRC_Flat)
      continue;

    if (stricmp(tex_name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }

  M_WarnError("Unknown texture found in level: '%s'\n", tex_name);

  // return the texture dummy image
  rim = RIM_DUMMY_TEX;
  return &amp;rim-&gt;pub;
}
</t>
<t tx="T58">@ W_ImageFromFlat

Note: search must be case insensitive.
@c

const image_t *W_ImageFromFlat(const char *flat_name)
{
  int i;
  const real_image_t *rim;

  // "NoTexture" marker.
  if (!flat_name || !flat_name[0] || flat_name[0] == '-')
    return NULL;

  // "Sky" marker.
  if (stricmp(flat_name, SKYFLATNAME) == 0)
    return skyflatimage;
  
  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (rim-&gt;source_type != IMSRC_Flat)
      continue;

    if (stricmp(flat_name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }

  // backup plan 1: if lump exists and is right size, add it.

  i = W_CheckNumForName(flat_name);

  if (i &gt;= 0)
  {
    rim = AddImageFlat(flat_name, i);
    if (rim)
      return &amp;rim-&gt;pub;
  }

  // backup plan 2: Texture with the same name ?

  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (rim-&gt;source_type != IMSRC_Texture)
      continue;

    if (stricmp(flat_name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }

  M_WarnError("Unknown flat found in level: '%s'\n", flat_name);

  // return the flat dummy image
  rim = RIM_DUMMY_FLAT;
  return &amp;rim-&gt;pub;
}
</t>
<t tx="T59">@ W_ImageFromPatch
@c

const image_t *W_ImageFromPatch(const char *patch_name)
{
  int i;
  const real_image_t *rim;

  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (rim-&gt;source_type != IMSRC_Patch &amp;&amp;
        rim-&gt;source_type != IMSRC_Raw320x200)
      continue;

    if (stricmp(patch_name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }

  // backup plan 1: look for sprites

  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (rim-&gt;source_type != IMSRC_Sprite)
      continue;

    if (stricmp(patch_name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }

  // not already loaded ?  Check if lump exists in wad, if so add it.

  i = W_CheckNumForName(patch_name);

  if (i &gt;= 0)
  {
    rim = AddImagePatch(patch_name, IMSRC_Patch, i);
    if (rim)
      return &amp;rim-&gt;pub;
  }

  M_WarnError("Unknown patch: '%s'\n", patch_name);

  // return the patch dummy image
  rim = RIM_DUMMY_PATCH;
  return &amp;rim-&gt;pub;
}
</t>
<t tx="T60">@ W_ImageFromFont

This is like W_ImageFromPatch above, but for getting font
characters.
@c

const image_t *W_ImageFromFont(const char *patch_name)
{
  int i;
  const real_image_t *rim;

  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (rim-&gt;source_type != IMSRC_Font)
      continue;

    if (stricmp(patch_name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }

  // not already loaded ?  Check if lump exists in wad, if so add it.

  i = W_CheckNumForName(patch_name);

  if (i &gt;= 0)
  {
    rim = AddImagePatch(patch_name, IMSRC_Font, i);
    if (rim)
      return &amp;rim-&gt;pub;
  }

  M_WarnError("Unknown font patch: '%s'\n", patch_name);

  // return the font dummy image
  rim = RIM_DUMMY_FONT;
  return &amp;rim-&gt;pub;
}
</t>
<t tx="T61">@ W_ImageFromHalo

Also like W_ImageFromPatch above, but for halos.
@c

const image_t *W_ImageFromHalo(const char *patch_name)
{
  int i;
  const real_image_t *rim;

  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (rim-&gt;source_type != IMSRC_Halo)
      continue;

    if (stricmp(patch_name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }

  // not already loaded ?  Check if lump exists in wad, if so add it.

  i = W_CheckNumForName(patch_name);

  if (i &gt;= 0)
  {
    rim = AddImagePatch(patch_name, IMSRC_Halo, i);
    if (rim)
      return &amp;rim-&gt;pub;
  }

  M_WarnError("Unknown halo graphic: '%s'\n", patch_name);

  // return the dummy halo image
  rim = RIM_DUMMY_HALO;
  return &amp;rim-&gt;pub;
}
</t>
<t tx="T62">@ W_ImageForDummySprite
@c

const image_t *W_ImageForDummySprite(void)
{
  const real_image_t *rim = RIM_DUMMY_SPRITE;
  return &amp;rim-&gt;pub;
}
</t>
<t tx="T63">@ W_ImageFromString

Used by the savegame code. One special value for type is `*',
which means that we don't care too much about the actual type (not
actually used yet -- but reserved for future use).
@c

const image_t *W_ImageFromString(char type, const char *name)
{
  int i;
  const real_image_t *rim;

  switch (type)
  {
    case 'T': return W_ImageFromTexture(name);
    case 'F': return W_ImageFromFlat(name);

    case 'P':
    case 'S':
    case 'r': return W_ImageFromPatch(name);

    case 'o': return W_ImageFromFont(name);
    case 'h': return W_ImageFromHalo(name);

    case 'U': /* user */
    case 'd': /* dummy */
    case '*': /* don't care, equivalent to 'U' */
      break;
     
    default:
      I_Warning("W_ImageFromString: unknown type `%c'\n", type);
      break;
  }

  for (i=0; i &lt; num_real_images; i++)
  {
    rim = real_images[i];
    
    if (stricmp(name, rim-&gt;name) == 0)
      return &amp;rim-&gt;pub;
  }

  I_Warning("W_ImageFromString: image [%c:%s] not found.\n", type, name);

  // return the texture dummy image
  rim = RIM_DUMMY_TEX;
  return &amp;rim-&gt;pub;
}
</t>
<t tx="T64">@ W_ImageToString

Used by the savegame code.
@c

void W_ImageToString(const image_t *image, char *type, char *namebuf)
{
  const real_image_t *rim;

  rim = (const real_image_t *) image;

  strcpy(namebuf, rim-&gt;name);

  switch (rim-&gt;source_type)
  {
    case IMSRC_Flat:    (*type) = 'F'; break;
    case IMSRC_Texture: (*type) = 'T'; break;
    case IMSRC_Patch:   (*type) = 'P'; break;
    case IMSRC_Sprite:  (*type) = 'S'; break;
    case IMSRC_User:    (*type) = 'U'; break;

    case IMSRC_Font:    (*type) = 'o'; break;
    case IMSRC_Halo:    (*type) = 'h'; break;
    case IMSRC_Dummy:   (*type) = 'd'; break;
    case IMSRC_Raw320x200: (*type) = 'r'; break;

    default:            (*type) = '*'; break;
  }
}
</t>
<t tx="T65">@ W_ImageDebugName

Used for debugging (and ONLY debugging !).
@c

#ifdef DEVELOPERS
const char *W_ImageDebugName(const image_t *image)
{
  const real_image_t *rim;

  rim = (const real_image_t *) image;

  return rim-&gt;name;
}
</t>
<t tx="T66">#endif


//----------------------------------------------------------------------------

//
//  IMAGE USAGE
//

static INLINE
const cached_image_t *ImageCachePost(real_image_t *rim, int mip)
{
  real_cached_image_t *rc;

  DEV_ASSERT2(mip == 0);

  rc = rim-&gt;post_cache;

  if (rc &amp;&amp; rc-&gt;users == 0 &amp;&amp; rc-&gt;invalidated)
  {
    UnloadImagePost(rc, rim);
    rc = rim-&gt;post_cache = NULL;
  }

  // already cached ?
  if (rc)
  {
    if (rc-&gt;users == 0)
    {
      // no longer freeable
      cache_size -= rc-&gt;size;
    }
    rc-&gt;users++;
  }
  else
  {
    // load into cache
    rc = rim-&gt;post_cache = LoadImagePost(rim);
  }

  DEV_ASSERT2(rc);
  DEV_ASSERT2(rc-&gt;mode == IMG_Post);

  return (const cached_image_t *)(rc + 1);
}
</t>
<t tx="T67">
static INLINE
const cached_image_t *ImageCacheBlock(real_image_t *rim, int mip)
{
  real_cached_image_t *rc;
  
  if (mip &gt;= rim-&gt;block_cache.num_mips)
  {
    // reallocate mip array
    
    Z_Resize(rim-&gt;block_cache.mips, real_cached_image_t *, mip+1);

    while (rim-&gt;block_cache.num_mips &lt;= mip)
      rim-&gt;block_cache.mips[rim-&gt;block_cache.num_mips++] = NULL;
  }

  rc = rim-&gt;block_cache.mips[mip];

  if (rc &amp;&amp; rc-&gt;users == 0 &amp;&amp; rc-&gt;invalidated)
  {
    UnloadImageBlock(rc, rim);
    rc = rim-&gt;block_cache.mips[rc-&gt;mip] = NULL;
  }

  // already cached ?
  if (rc)
  {
    if (rc-&gt;users == 0)
    {
      // no longer freeable
      cache_size -= rc-&gt;size;
    }
    rc-&gt;users++;
  }
  else
  {
    // load into cache
    rc = rim-&gt;block_cache.mips[mip] = LoadImageBlock(rim, mip);
  }

  DEV_ASSERT2(rc);
  DEV_ASSERT2(rc-&gt;mode == IMG_Block);

  return (const cached_image_t *)(rc + 1);
}
</t>
<t tx="T68">
#ifdef USE_GL

static INLINE
const cached_image_t *ImageCacheOGL(real_image_t *rim, int mip)
{
  real_cached_image_t *rc;

  DEV_ASSERT2(mip == 0);

  rc = rim-&gt;ogl_cache;

  if (rc &amp;&amp; rc-&gt;users == 0 &amp;&amp; rc-&gt;invalidated)
  {
    UnloadImageOGL(rc, rim);
    rc = rim-&gt;ogl_cache = NULL;
  }

  // already cached ?
  if (rc)
  {
    if (rc-&gt;users == 0)
    {
      // no longer freeable
      cache_size -= rc-&gt;size;
    }
    rc-&gt;users++;
  }
  else
  {
    // load into cache
    rc = rim-&gt;ogl_cache = LoadImageOGL(rim);
  }

  DEV_ASSERT2(rc);
  DEV_ASSERT2(rc-&gt;mode == IMG_OGL);

  return (const cached_image_t *)(rc + 1);
}
</t>
<t tx="T69">#endif  // USE_GL


//
// W_ImageCache
//
// The top-level routine for caching in an image.  Mainly just a
// switch to more specialised routines.  Never returns NULL.
//
const cached_image_t *W_ImageCache(const image_t *image, 
    image_mode_e mode, int mip, boolean_t anim)
{
  // Intentional Const Override
  real_image_t *rim = (real_image_t *) image;
 
  DEV_ASSERT2(mip &gt;= 0);

  if (mip &gt; MAX_MIP)
    mip = MAX_MIP;

  // handle animations
  if (anim)
    rim = rim-&gt;anim.cur;

  switch (mode)
  {
    case IMG_Post:
      return ImageCachePost(rim, mip);
      
    case IMG_Block:
      return ImageCacheBlock(rim, mip);

    case IMG_OGL:
#ifdef USE_GL
      return ImageCacheOGL(rim, mip);
#else
      break; // -ACB- 2000/07/10 Required to compile file
#endif
  }

  I_Error("W_ImageCache: bad mode %d !\n", mode);
  return NULL;
}
</t>
<t tx="T70">@ W_ImageDone
@c

void W_ImageDone(const cached_image_t *c)
{
  real_cached_image_t *rc;

  DEV_ASSERT2(c);

  // Intentional Const Override
  rc = ((real_cached_image_t *) c) - 1;

  DEV_ASSERT(rc-&gt;users &gt; 0, ("W_ImageDone: No users"));

  rc-&gt;users--;

  if (rc-&gt;users == 0)
  {
    cache_size += rc-&gt;size;

    // move cached image to the end of the cache list.  This way,
    // the Most Recently Used (MRU) images are at the tail of the
    // list, and thus the Least Recently Used (LRU) images are at the
    // head of the cache list.

    Unlink(rc);
    InsertAtTail(rc);
  }
}
</t>
<t tx="T71">@ W_ImageGetPost

Return the posts for the cached image at the given column. Returns
NULL if the column is empty. `column' will be suitably converted
if it lies outside of the horizontal range of the image.
@c

const w_post_t *W_ImageGetPost(const cached_image_t *c, int column)
{
  real_cached_image_t *rc;
  int mip_w;
 
  DEV_ASSERT2(c);

  // Intentional Const Override
  rc = ((real_cached_image_t *) c) - 1;

  DEV_ASSERT2(rc-&gt;parent);
  DEV_ASSERT2(rc-&gt;mode == IMG_Post);
  DEV_ASSERT2(rc-&gt;info.post.columns);

  mip_w = MIP_SIZE(rc-&gt;parent-&gt;pub.total_w, rc-&gt;mip);

  DEV_ASSERT2(mip_w &gt;= 0);

  // power of two check
  DEV_ASSERT2((mip_w &amp; (mip_w - 1)) == 0);
 
  return rc-&gt;info.post.columns[column &amp; (mip_w - 1)];
}
</t>
<t tx="T72">@ W_ImageGetBlock

Return the pixel block for the cached image. Computing the exact
start for a particular column is left as an exercise to the caller.
Never returns NULL.
@c

const byte *W_ImageGetBlock(const cached_image_t *c)
{
  real_cached_image_t *rc;
 
  DEV_ASSERT2(c);

  // Intentional Const Override
  rc = ((real_cached_image_t *) c) - 1;

  DEV_ASSERT2(rc-&gt;parent);
  DEV_ASSERT2(rc-&gt;mode == IMG_Block);

  DEV_ASSERT2(rc-&gt;info.block.pixels);

  return rc-&gt;info.block.pixels;
}
</t>
<t tx="T73">

#ifdef USE_GL

//
// W_ImageGetOGL
//
GLuint W_ImageGetOGL(const cached_image_t *c)
{
  real_cached_image_t *rc;

  DEV_ASSERT2(c);

  // Intentional Const Override
  rc = ((real_cached_image_t *) c) - 1;

  DEV_ASSERT2(rc-&gt;parent);
  DEV_ASSERT2(rc-&gt;mode == IMG_OGL);

  return rc-&gt;info.ogl.tex_id;
}
</t>
<t tx="T74">
#endif  // USE_GL


static void FlushImageCaches(z_urgency_e urge)
{
  int bytes_to_free = 0;
  real_cached_image_t *rc, *next;

  if (w_locked_ogl)
    return;

  //!!! FIXME: make triple sure that if this is called from _within_
  //!!! one of routines above, nothing bad will happen.

  switch (urge)
  {
    case Z_UrgencyLow: bytes_to_free = cache_size / 16; break;
    case Z_UrgencyMedium: bytes_to_free = cache_size / 8; break;
    case Z_UrgencyHigh: bytes_to_free = cache_size / 2; break;
    case Z_UrgencyExtreme: bytes_to_free = INT_MAX; break;

    default:
      I_Error("FlushImageCaches: Invalid urgency level %d\n", urge);
  }

  // the Least Recently Used (LRU) images are at the head of the image
  // cache list, so we unload those ones first.
 
  for (rc = imagecachehead.next; 
       rc != &amp;imagecachehead &amp;&amp; bytes_to_free &gt; 0; rc = next)
  {
    next = rc-&gt;next;

    if (rc-&gt;users == 0)
    {
      bytes_to_free -= rc-&gt;size;
      UnloadImage(rc);
    }
  }
}
</t>
<t tx="T75">@ W_ImagePreCache
@c

void W_ImagePreCache(const image_t *image)
{
#ifdef USE_GL
  W_ImageDone(W_ImageCache(image, IMG_OGL, 0, false));
#else
  W_ImageDone(W_ImageCache(image, IMG_Block, 0, false));
#endif
}
</t>
<t tx="T76">@ ----------------------------------------------------------------------------

W_InitImages

Initialises the image system.
@c

boolean_t W_InitImages(void)
{
  // the only initialisation the cache list needs
  imagecachehead.next = imagecachehead.prev = &amp;imagecachehead;

  Z_RegisterCacheFlusher(FlushImageCaches);

  Z_InitStackArray(&amp;real_images_a, (void ***)&amp;real_images, 
      sizeof(real_image_t), 0);

  // setup dummy images
  AddImageDummy(IMSRC_Texture);
  AddImageDummy(IMSRC_Flat);
  AddImageDummy(IMSRC_Flat);  // this one is for sky
  AddImageDummy(IMSRC_Patch);
  AddImageDummy(IMSRC_Sprite);
  AddImageDummy(IMSRC_Font);
  AddImageDummy(IMSRC_Halo);

  skyflatimage = &amp;RIM_SKY_FLAT-&gt;pub;

  // check options
  M_CheckBooleanParm("smoothing", &amp;use_smoothing, false);
  M_CheckBooleanParm("dither", &amp;use_dithering, false);

  if (M_CheckParm("-nomipmap"))
    use_mipmapping = 0;
  else if (M_CheckParm("-mipmap"))
    use_mipmapping = 1;
  else if (M_CheckParm("-trilinear"))
    use_mipmapping = 2;

  return true;
}
</t>
<t tx="T77">@ W_UpdateImageAnims

Animate all the images.
@c

void W_UpdateImageAnims(void)
{
  int i;

  for (i=0; i &lt; num_real_images; i++)
  {
    real_image_t *rim = real_images[i];
    
    // not animated ?
    if (rim-&gt;anim.speed == 0)
      continue;

    DEV_ASSERT2(rim-&gt;anim.count &gt; 0);

    rim-&gt;anim.count--;

    if (rim-&gt;anim.count == 0 &amp;&amp; rim-&gt;anim.cur-&gt;anim.next)
    {
      rim-&gt;anim.cur = rim-&gt;anim.cur-&gt;anim.next;
      rim-&gt;anim.count = rim-&gt;anim.speed;
    }
  }
}
</t>
<t tx="T78">@ W_ResetImages

Resets all images, causing all cached images to be invalidated.
Needs to be called when gamma changes (GL renderer only), or when
certain other parameters change (e.g. GL mipmapping modes).
@c

void W_ResetImages(void)
{
  real_cached_image_t *rc, *next;

  for (rc=imagecachehead.next; rc != &amp;imagecachehead; rc=next)
  {
    next = rc-&gt;next;
    
    if (rc-&gt;users == 0)
      UnloadImage(rc);
    else
      rc-&gt;invalidated = true;
  }
}
</t>
<t tx="T79">@ W_LockImagesOGL

Prevents OGL texture ids from being deleted. Essentially this
routine is like giving all cached images an extra user. It is
needed due to the curreny way the RGL_UNIT code works.
@c

void W_LockImagesOGL(void)
{
  DEV_ASSERT(!w_locked_ogl, ("W_LockImagesOGL: Already locked."));

  w_locked_ogl = true;
}
</t>
<t tx="T80">@ W_UnlockImagesOGL
@c

void W_UnlockImagesOGL(void)
{
  DEV_ASSERT(w_locked_ogl, ("W_UnlockImagesOGL: NOT locked."));

  w_locked_ogl = false;
}
</t>
<t tx="T81">@ W_AnimateImageSet

Sets up the images so they will animate properly.

NOTE: modifies the input array of images.
@c

void W_AnimateImageSet(const image_t ** images, int number, int speed)
{
  int i, total;
  real_image_t *rim, *other;

  DEV_ASSERT2(images);
  DEV_ASSERT2(speed &gt; 0);

  // ignore images that are already animating
  for (i=0, total=0; i &lt; number; i++)
  {
    // Intentional Const Override
    rim = (real_image_t *) images[i];

    if (rim-&gt;anim.speed &gt; 0)
      continue;

    images[total++] = images[i];
  }

  // anything left to animate ?
  if (total &lt; 2)
    return;

  for (i=0; i &lt; total; i++)
  {
    // Intentional Const Override
    rim   = (real_image_t *) images[i];
    other = (real_image_t *) images[(i+1) % total];

    rim-&gt;anim.next = other;
    rim-&gt;anim.speed = rim-&gt;anim.count = speed;
  }
}
</t>
<t tx="T82">@ignore
@language c

//  Texture Conversion and Caching code

// This module converts image lumps on disk to usable structures, and also
// provides a caching system for these.

// -ES- 2000/02/12 Written.

&lt;&lt; w_textur #includes &gt;&gt;
&lt;&lt; w_textur declarations &gt;&gt;
@others
</t>
<t tx="T83">#include "i_defs.h"
#include "w_textur.h"

#include "e_search.h"
#include "dm_state.h"
#include "dm_defs.h"
#include "m_argv.h"
#include "m_misc.h"
#include "m_swap.h"
#include "p_local.h"
#include "r_local.h"
#include "r_sky.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T84">

typedef struct texture_set_s
{
  texturedef_t ** textures;
  int numtextures;
}
texture_set_t;

static texture_set_t *tex_sets = NULL;
static int num_tex_sets = 0;
</t>
<t tx="T85">@ InstallTextureLumps

-ACB- 1998/09/09 Removed the Doom II SkyName change: unnecessary and not DDF.
Reformatted and cleaned up.
@c

static void InstallTextureLumps(int file, int pnames, int palette,
    int texture1, int texture2)
{
  const maptexture_t *mtexture;
  const mappatch_t *mpatch;

  texturedef_t *texture;
  texpatch_t *patch;
  texture_set_t *cur_set;

  int i, j;
  int nummappatches;
  int offset;
  int maxoff;
  int maxoff2;
  int numtextures1;
  int numtextures2;
  int patchcount;

  const int *maptex;
  const int *maptex1;
  const int *maptex2;
  int *patchlookup;
  const int *directory;

  char name[9];
  const char *names;
  const char *name_p;

  int base_size;
  int width;
  byte *base;

  // Load the patch names from pnames.lmp.
  name[8] = 0;

  names = W_CacheLumpNum(pnames);
  nummappatches = LONG(*((const int *)names));
  name_p = names + 4;

  patchlookup = Z_New(int, nummappatches);

  for (i = 0; i &lt; nummappatches; i++)
  {
    Z_StrNCpy(name, name_p + i * 8, 8);
    patchlookup[i] = W_CheckNumForName(name);
  }

  W_DoneWithLump(names);

  //
  // Load the map texture definitions from textures.lmp.
  //
  // The data is contained in one or two lumps:
  //   TEXTURE1 for shareware
  //   TEXTURE2 for commercial.
  //
  maptex = maptex1 = W_CacheLumpNum(texture1);
  numtextures1 = LONG(*maptex);
  maxoff = W_LumpLength(texture1);
  directory = maptex + 1;

  if (texture2 != -1)
  {
    maptex2 = W_CacheLumpNum(texture2);
    numtextures2 = LONG(*maptex2);
    maxoff2 = W_LumpLength(texture2);
  }
  else
  {
    maptex2 = NULL;
    numtextures2 = 0;
    maxoff2 = 0;
  }

  Z_Resize(tex_sets, texture_set_t, num_tex_sets + 1);
  cur_set = tex_sets + num_tex_sets;
  num_tex_sets++;

  cur_set-&gt;numtextures = numtextures1 + numtextures2;
  cur_set-&gt;textures = Z_New(texturedef_t *, cur_set-&gt;numtextures);

  for (i = 0; i &lt; cur_set-&gt;numtextures; i++, directory++)
  {
    if (i == numtextures1)
    {
      // Start looking in second texture file.
      maptex = maptex2;
      maxoff = maxoff2;
      directory = maptex + 1;
    }

    offset = LONG(*directory);
    if (offset &gt; maxoff)
      I_Error("W_InitTextures: bad texture directory");

    mtexture = (const maptexture_t *) ((const byte *) maptex + offset);

    // -ES- 2000/02/10 Texture must have patches.
    patchcount = SHORT(mtexture-&gt;patchcount);
    if (!patchcount)
      I_Error("W_InitTextures: Texture '%.8s' has no patches", mtexture-&gt;name);

    width = SHORT(mtexture-&gt;width);
    if (width == 0)
      I_Error("W_InitTextures: Texture '%.8s' has zero width", mtexture-&gt;name);

    // -ES- Allocate texture, patches and columnlump/ofs in one big chunk
    base_size = sizeof(texturedef_t) + sizeof(texpatch_t) * (patchcount - 1);
    texture = cur_set-&gt;textures[i] = (texturedef_t *) Z_Malloc(base_size + width * (sizeof(byte) + sizeof(short)));
    base = (byte *)texture + base_size;

    texture-&gt;columnofs = (unsigned short *)base;
    
    texture-&gt;width = width;
    texture-&gt;height = SHORT(mtexture-&gt;height);
    texture-&gt;file = file;
    texture-&gt;palette_lump = palette;
    texture-&gt;patchcount = patchcount;

    Z_StrNCpy(texture-&gt;name, mtexture-&gt;name, 8);
    strupr(texture-&gt;name);

    mpatch = &amp;mtexture-&gt;patches[0];
    patch = &amp;texture-&gt;patches[0];

    for (j = 0; j &lt; texture-&gt;patchcount; j++, mpatch++, patch++)
    {
      patch-&gt;originx = SHORT(mpatch-&gt;originx);
      patch-&gt;originy = SHORT(mpatch-&gt;originy);
      patch-&gt;patch = patchlookup[SHORT(mpatch-&gt;patch)];

      if (patch-&gt;patch == -1)
      {
        I_Warning("Missing patch in texture \'%.8s\'\n", texture-&gt;name);
        
        // mark texture as a dud
        texture-&gt;patchcount = 0;
        break;
      }
    }
  }
  
  // free stuff
  W_DoneWithLump(maptex1);

  if (maptex2)
    W_DoneWithLump(maptex2);
  
  Z_Free(patchlookup);
}
</t>
<t tx="T86">@ W_InitTextures

Initialises the texture list with the textures from the world map.

-ACB- 1998/09/09 Fixed the Display routine from display rubbish.
@c

boolean_t W_InitTextures(void)
{
  int max_file = W_GetNumFiles();
  int j, t, file;
  
  texturedef_t ** textures = NULL;
  texturedef_t ** cur;
  int numtextures = 0;

  I_Printf("W_InitTextures...\n");

  DEV_ASSERT2(num_tex_sets == 0);

  // iterate over each file, creating our sets of textures
  // -ACB- 1998/09/09 Removed the Doom II SkyName change: unnecessary and not DDF.

  for (file=0; file &lt; max_file; file++)
  {
    wadtex_resource_t WT;
  
    W_GetTextureLumps(file, &amp;WT);
 
    if (WT.pnames &lt; 0)
      continue;

    if (WT.texture1 &gt;= 0)
      InstallTextureLumps(file, WT.pnames, WT.palette, WT.texture1, WT.texture2);
    else if (WT.texture2 &gt;= 0)
      InstallTextureLumps(file, WT.pnames, WT.palette, WT.texture2, WT.texture1);
  }

  if (num_tex_sets == 0)
    I_Error("No textures found !  Make sure the chosen IWAD is valid.\n");

  // now clump all of the texturedefs together and sort 'em, primarily
  // by increasing name, secondarily by increasing file number
  // (measure of newness).  We ignore "dud" textures (missing
  // patches).

  for (j=0; j &lt; num_tex_sets; j++)
    numtextures += tex_sets[j].numtextures;

  textures = cur = Z_New(texturedef_t *, numtextures);

  for (j=0; j &lt; num_tex_sets; j++)
  {
    for (t=0; t &lt; tex_sets[j].numtextures; t++)
      if (tex_sets[j].textures[t]-&gt;patchcount &gt; 0)
        *cur++ = tex_sets[j].textures[t];
  }

  numtextures = cur - textures;

#define CMP(a, b)  \
    (strcmp(a-&gt;name, b-&gt;name) &lt; 0 || \
     (strcmp(a-&gt;name, b-&gt;name) == 0 &amp;&amp; a-&gt;file &lt; b-&gt;file))
  QSORT(texturedef_t *, textures, numtextures, CUTOFF);
#undef CMP

  // remove duplicate names.  Because the QSORT took newness into
  // account, only the last entry in a run of identically named
  // textures needs to be kept.

  for (j=1; j &lt; numtextures; j++)
  {
    texturedef_t * a = textures[j - 1];
    texturedef_t * b = textures[j];

    if (strcmp(a-&gt;name, b-&gt;name) == 0)
    {
      Z_Free(a);
      textures[j - 1] = NULL;
    }
  }

#if 0  // DEBUGGING
  for (j=0; j &lt; numtextures; j++)
  {
    if (textures[j] == NULL)
    {
      L_WriteDebug("TEXTURE #%d was a dupicate\n", j);
      continue;
    }
    L_WriteDebug("TEXTURE #%d:  name=[%s]  file=%d  size=%dx%d\n", j,
        textures[j]-&gt;name, textures[j]-&gt;file,
        textures[j]-&gt;width, textures[j]-&gt;height);
  }
#endif
  
  W_ImageCreateTextures(textures, numtextures); 

  // free pointer array.  We need to keep the definitions in memory
  // for (a) the image system and (b) texture anims.
  Z_Free(textures);

  return true;
}
</t>
<t tx="T87">@ W_FindTextureSequence

Returns the set number containing the texture names (with the
offset values updated to the indexes), or -1 if none could be
found. Used by animation code.

Note: search is from latest set to earliest set.
@c

int W_FindTextureSequence(const char *start, const char *end,
    int *s_offset, int *e_offset)
{
  int i, j;

  for (i=num_tex_sets-1; i &gt;= 0; i--)
  {
    // look for start name
    for (j=0; j &lt; tex_sets[i].numtextures; j++)
      if (stricmp(start, tex_sets[i].textures[j]-&gt;name) == 0)
        break;
    
    if (j &gt;= tex_sets[i].numtextures)
      continue;

    (*s_offset) = j;

    // look for end name
    for (j++; j &lt; tex_sets[i].numtextures; j++)
    {
      if (stricmp(end, tex_sets[i].textures[j]-&gt;name) == 0)
      {
        (*e_offset) = j;
        return i;
      }
    }
  }

  // not found
  return -1;
}
</t>
<t tx="T88">@ W_TextureNameInSet
@c

const char *W_TextureNameInSet(int set, int offset)
{
  DEV_ASSERT2(0 &lt;= set &amp;&amp; set &lt; num_tex_sets);
  DEV_ASSERT2(0 &lt;= offset &amp;&amp; offset &lt; tex_sets[set].numtextures);

  return tex_sets[set].textures[offset]-&gt;name;
}
</t>
<t tx="T89">@ignore
@language c

// WAD Support Code

// This file contains various levels of support for using sprites and
// flats directly from a PWAD as well as some minor optimisations for
// patches. Because there are some PWADs that do arcane things with
// sprites, it is possible that this feature may not always work (at
// least, not until I become aware of them and support them) and so
// this feature can be turned off from the command line if necessary.

// -MH- 1998/03/04

&lt;&lt; w_wad #includes &gt;&gt;
&lt;&lt; w_wad declarations &gt;&gt;
@others
</t>
<t tx="T90">#include "i_defs.h"
#include "w_wad.h"

#include "dm_type.h"
#include "e_main.h"
#include "e_search.h"
#include "m_argv.h"
#include "m_misc.h"
#include "m_swap.h"
#include "e_player.h"
#include "rad_trig.h"
#include "w_textur.h"
#include "w_image.h"
#include "z_zone.h"
</t>
<t tx="T91">

typedef struct
{
  const char *file_name;
  enum {FILE_WAD, FILE_SINGLELUMP} type;

  // file handle, as returned from open().
  int handle;

  // sprite list
  // Note: we allocate 16 integers at a time
  int *sprite_lumps;
  int sprite_num;

  // flat list (also 16 at a time)
  int *flat_lumps;
  int flat_num;

  // texture information
  wadtex_resource_t wadtex;
}
data_file_t;

// Raw filenames
typedef struct raw_filename_s
{
  const char *file_name;
  boolean_t allow_ddf;
}
raw_filename_t;

typedef struct
{
  char name[10];
  int position;
  int size;

  // file number (an index into data_files[]).
  short file;

  // value used when sorting.  When lumps have the same name, the one
  // with the highest sort_index is used (W_CheckNumForName).  This is
  // closely related to the `file' field, with some tweaks for
  // handling GWA files (especially dynamic ones).
  short sort_index;
}
lumpinfo_t;

// Create the start and end markers

//
//  GLOBALS
//

// Location of each lump on disk.
lumpinfo_t *lumpinfo;
static int *lumpmap = NULL;
int numlumps;

typedef struct lumpheader_s
{
#ifdef DEVELOPERS
#define LUMPID ((int)0xAC45197e)
  // Should be LUMPID
  int id;
#endif

  // number of users.
  int users;

  // index in lumplookup
  int lumpindex;
  struct lumpheader_s *next, *prev;
}
lumpheader_t;

static lumpheader_t **lumplookup;
static lumpheader_t lumphead;

// number of freeable bytes in cache (excluding headers).
// Used to decide how many bytes we should flush.
static int cache_size = 0;

static data_file_t *data_files = NULL;
static int datafile = -1;

// the first datafile which contains a PLAYPAL lump
static int palette_datafile = -1;

// Sprites &amp; Flats
boolean_t within_sprite_list;
boolean_t within_flat_list;

int addwadnum = 0;
static int maxwadfiles = 0;
static raw_filename_t *wadfiles = NULL;
</t>
<t tx="T92">@ Is the name a sprite list start flag?
If lax syntax match, fix up to standard syntax.
@c

static boolean_t IsS_START(char *name)
{
  if (strncmp(name, "SS_START", 8) == 0)
  {
    // fix up flag to standard syntax
    // Note: strncpy will pad will nulls
    strncpy(name, "S_START", 8);
    return 1;
  }

  return (strncmp(name, "S_START", 8) == 0);
}
</t>
<t tx="T93">@ Is the name a sprite list end flag?
If lax syntax match, fix up to standard syntax.
@c

static boolean_t IsS_END(char *name)
{
  if (strncmp(name, "SS_END", 8) == 0)
  {
    // fix up flag to standard syntax
    strncpy(name, "S_END", 8);
    return 1;
  }

  return (strncmp(name, "S_END", 8) == 0);
}
</t>
<t tx="T94">@ Is the name a flat list start flag?
If lax syntax match, fix up to standard syntax.
@c

static boolean_t IsF_START(char *name)
{
  if (strncmp(name, "FF_START", 8) == 0)
  {
    // fix up flag to standard syntax
    strncpy(name, "F_START", 8);
    return 1;
  }

  return (strncmp(name, "F_START", 8) == 0);
}
</t>
<t tx="T95">@ Is the name a flat list end flag?
If lax syntax match, fix up to standard syntax.
@c

static boolean_t IsF_END(char *name)
{
  if (strncmp(name, "FF_END", 8) == 0)
  {
    // fix up flag to standard syntax
    strncpy(name, "F_END", 8);
    return 1;
  }

  return (strncmp(name, "F_END", 8) == 0);
}
</t>
<t tx="T96">@ Is the name a dummy sprite/flat flag ?
@c

static boolean_t IsDummySF(const char *name)
{
  return (strncmp(name, "S1_START", 8) == 0 ||
          strncmp(name, "S2_START", 8) == 0 ||
          strncmp(name, "S3_START", 8) == 0 ||
          strncmp(name, "F1_START", 8) == 0 ||
          strncmp(name, "F2_START", 8) == 0 ||
          strncmp(name, "F3_START", 8) == 0);
}
</t>
<t tx="T97">
static int FileLength(int handle)
{
  struct stat fileinfo;

  if (fstat(handle, &amp;fileinfo) == -1)
    I_Error("Error fstating");

  return fileinfo.st_size;
}
</t>
<t tx="T98">
static void ExtractFileBase(const char *path, char *dest)
{
  const char *src;
  int length;

  src = path + strlen(path) - 1;

  // back up until a \ or the start
  while (src != path
      &amp;&amp; *(src - 1) != '\\'
      &amp;&amp; *(src - 1) != '/'
      &amp;&amp; *(src - 1) != ':')  // Kester added :
  {
    src--;
  }

  // copy up to eight characters
  Z_Clear(dest, char, 8);
  length = 0;

  while (*src &amp;&amp; *src != '.')
  {
    if (++length == 9)
      I_Error("Filename base of %s &gt;8 chars", path);

    *dest++ = toupper((int)*src++);
  }
}
</t>
<t tx="T99">@ W_GetTextureLumps
@c

void W_GetTextureLumps(int file, wadtex_resource_t *res)
{
  DEV_ASSERT2(0 &lt;= file &amp;&amp; file &lt;= datafile);
  DEV_ASSERT2(res);

  res-&gt;palette  = data_files[file].wadtex.palette;
  res-&gt;pnames   = data_files[file].wadtex.pnames;
  res-&gt;texture1 = data_files[file].wadtex.texture1;
  res-&gt;texture2 = data_files[file].wadtex.texture2;

  // find an earlier PNAMES lump when missing.
  // Ditto for palette.

  if (res-&gt;texture1 &gt;= 0 || res-&gt;texture2 &gt;= 0)
  {
    int cur;

    for (cur=file; res-&gt;pnames == -1 &amp;&amp; cur &gt; 0; cur--)
      res-&gt;pnames = data_files[cur].wadtex.pnames;

    for (cur=file; res-&gt;palette == -1 &amp;&amp; cur &gt; 0; cur--)
      res-&gt;palette = data_files[cur].wadtex.palette;
  }
}
</t>
<t tx="T100">@ SortLumps

Create the lumpmap[] array, which is sorted by name for fast
searching. It also makes sure that entries with the same name all
refer to the same lump (prefering lumps in later WADs over those in
earlier ones).

-AJA- 2000/10/14: simplified.
@c

static void SortLumps(void)
{
  int i;

  Z_Resize(lumpmap, int, numlumps);

  for (i = 0; i &lt; numlumps; i++)
    lumpmap[i] = i;
    
  // sort it, primarily by increasing name, secondarily by decreasing
  // file number.

#define CMP(a, b)  \
    (strncmp(lumpinfo[a].name, lumpinfo[b].name, 8) &lt; 0 ||    \
     (strncmp(lumpinfo[a].name, lumpinfo[b].name, 8) == 0 &amp;&amp;  \
      lumpinfo[a].sort_index &gt; lumpinfo[b].sort_index))
  QSORT(int, lumpmap, numlumps, CUTOFF);
#undef CMP

  for (i=1; i &lt; numlumps; i++)
  {
    int a = lumpmap[i - 1];
    int b = lumpmap[i];

    if (strncmp(lumpinfo[a].name, lumpinfo[b].name, 8) == 0)
      lumpmap[i] = lumpmap[i - 1];
  }
}
</t>
<t tx="T101">@ SortSpriteLumps

Put the sprite list in sorted order (of name), required by
R_InitSprites (speed optimisation).
@c

static void SortSpriteLumps(data_file_t *f)
{
  if (f-&gt;sprite_num &lt; 2)
    return;

#define CMP(a, b) (strncmp(lumpinfo[a].name, lumpinfo[b].name, 8) &lt; 0)
  QSORT(int, f-&gt;sprite_lumps, f-&gt;sprite_num, CUTOFF);
#undef CMP

#if 0  // DEBUGGING
  {
    int i, lump;
    
    for (i=0; i &lt; f-&gt;sprite_num; i++)
    {
      lump = f-&gt;sprite_lumps[i];

      L_WriteDebug("Sorted sprite %d = lump %d [%s]\n", i, lump,
          lumpinfo[lump].name);
    }
  }
#endif
}
</t>
<t tx="T102">@ LUMP BASED ROUTINES.


W_AddFile

All files are optional, but at least one file must be
found (PWAD, if all required lumps are present).
Files with a .wad extension are wadlink files
with multiple lumps.
Other files are single lumps with the base filename
for the lump name.

-KM- 1999/01/31 Order is important, Languages are loaded before sfx, etc...
@c

typedef struct ddf_reader_s
{
  char *name;
  void (* func)(void *data, int size);
  int lump;
}
ddf_reader_t;

static ddf_reader_t DDF_Readers[] =
{
  { "DDFLANG", DDF_ReadLangs, 0 } ,
  { "DDFSFX",  DDF_ReadSFX, 0 } ,
  { "DDFCOLM", DDF_ReadColourMaps, 0 } ,  // -AJA- 1999/07/09.
  { "DDFATK",  DDF_ReadAtks, 0 } ,
  { "DDFWEAP", DDF_ReadWeapons, 0 } ,
  { "DDFTHING",DDF_ReadThings, 0 } ,
  { "DDFPLAY", DDF_ReadMusicPlaylist, 0 } ,
  { "DDFLINE", DDF_ReadLines, 0 } ,
  { "DDFSECT", DDF_ReadSectors, 0 } ,
  { "DDFSWTH", DDF_ReadSW, 0 } ,
  { "DDFANIM", DDF_ReadAnims, 0 } ,
  { "DDFGAME", DDF_ReadGames, 0 } ,
  { "DDFLEVL", DDF_ReadLevels, 0 },
  { "RSCRIPT", RAD_LoadLump, 0 }       // -AJA- 2000/04/21.
};

#define NUM_DDF_READERS  (sizeof(DDF_Readers) / sizeof(ddf_reader_t))

//
// FreeLump
//
static void FreeLump(lumpheader_t *h)
{
  int lumpnum = h-&gt;lumpindex;

  cache_size -= W_LumpLength(lumpnum);
#ifdef DEVELOPERS
  if (h-&gt;id != LUMPID)
    I_Error("FreeLump: id != LUMPID");
  h-&gt;id = 0;
  if (h == NULL)
    I_Error("FreeLump: NULL lump");
  if (h-&gt;users)
    I_Error("FreeLump: lump %d has %d users!", lumpnum, h-&gt;users);
  if (lumplookup[lumpnum] != h)
    I_Error("FreeLump: Internal error, lump %d", lumpnum);
#endif
  lumplookup[lumpnum] = NULL;
  h-&gt;prev-&gt;next = h-&gt;next;
  h-&gt;next-&gt;prev = h-&gt;prev;
  Z_Free(h);
}
</t>
<t tx="T103">@ MarkAsCached
@c

static void MarkAsCached(lumpheader_t *item)
{
#ifdef DEVELOPERS
  if (item-&gt;id != LUMPID)
    I_Error("MarkAsCached: id != LUMPID");
  if (!item)
    I_Error("MarkAsCached: lump %d is NULL", item-&gt;lumpindex);
  if (item-&gt;users)
    I_Error("MarkAsCached: lump %d has %d users!", item-&gt;lumpindex, item-&gt;users);
  if (lumplookup[item-&gt;lumpindex] != item)
    I_Error("MarkAsCached: Internal error, lump %d", item-&gt;lumpindex);
#endif

  cache_size += W_LumpLength(item-&gt;lumpindex);
}
</t>
<t tx="T104">
static INLINE void AddSpriteOrFlat(int **list, int *count, int item)
{
  // no more room ?
  if (((*count) % 16) == 0)
  {
    Z_Resize((*list), int, (*count) + 16);
  }
  
  (*list)[*count] = item;

  (*count) += 1;
}
</t>
<t tx="T105">@ AddLump
@c

static void AddLump(int lump, int pos, int size, int file, 
    int sort_index, const char *name, boolean_t allow_ddf)
{
  int j;
  lumpinfo_t *lump_p = lumpinfo + lump;
  
  lump_p-&gt;position = pos;
  lump_p-&gt;size = size;
  lump_p-&gt;file = file;
  lump_p-&gt;sort_index = sort_index;

  Z_StrNCpy(lump_p-&gt;name, name, 8);
  strupr(lump_p-&gt;name);

  // -- handle special names --

  if (!strncmp(name, "PLAYPAL", 8))
  {
    data_files[file].wadtex.palette = lump;
    if (palette_datafile &lt; 0)
      palette_datafile = file;
    return;
  }
  else if (!strncmp(name, "PNAMES", 8))
  {
    data_files[file].wadtex.pnames = lump;
    return;
  }
  else if (!strncmp(name, "TEXTURE1", 8))
  {
    data_files[file].wadtex.texture1 = lump;
    return;
  }
  else if (!strncmp(name, "TEXTURE2", 8))
  {
    data_files[file].wadtex.texture2 = lump;
    return;
  }

  // -KM- 1998/12/16 Load DDF/RSCRIPT file from wad.
  if (allow_ddf)
  {
    for (j=0; j &lt; NUM_DDF_READERS; j++)
    {
      if (!strncmp(name, DDF_Readers[j].name, 8))
      {
        DDF_Readers[j].lump = lump;
        return;
      }
    }
  }

  // -- handle sprite &amp; flat lists --
  
  if (IsS_START(lump_p-&gt;name))
  {
    within_sprite_list = true;
    return;
  }
  else if (IsS_END(lump_p-&gt;name))
  {
    if (!within_sprite_list)
      I_Warning("Unexpected S_END marker in wad.\n");

    within_sprite_list = false;
    return;
  }
  else if (IsF_START(lump_p-&gt;name))
  {
    within_flat_list = true;
    return;
  }
  else if (IsF_END(lump_p-&gt;name))
  {
    if (!within_flat_list)
      I_Warning("Unexpected F_END marker in wad.\n");

    within_flat_list = false;
    return;
  }

  // ignore zero size lumps or dummy markers
  if (lump_p-&gt;size &gt; 0 &amp;&amp; !IsDummySF(lump_p-&gt;name))
  {
    if (within_sprite_list)
      AddSpriteOrFlat(&amp;data_files[file].sprite_lumps,
          &amp;data_files[file].sprite_num, lump);
    
    if (within_flat_list)
      AddSpriteOrFlat(&amp;data_files[file].flat_lumps,
          &amp;data_files[file].flat_num, lump);
  }
}
</t>
<t tx="T106">@ AddFile

-AJA- New `dyn_index' parameter -- this is for adding GWA files
which have been built by the GLBSP plugin. Nothing else is
supported, e.g. wads with textures/sprites/DDF/RTS.

The dyn_index value is -1 for normal (non-dynamic) files,
otherwise it is the sort_index for the lumps (typically the
file number of the wad which the GWA is a companion for).
@c

static void AddFile(const char *filename, boolean_t allow_ddf,
    int dyn_index)
{
  int j;
  int handle;
  int length;
  int startlump;

  wad_header_t header;
  wad_entry_t *fileinfo, *curinfo;

  // reset the sprite/flat list stuff
  within_sprite_list = within_flat_list = false;

  // open the file and add to directory
  for (j=0; j &lt; NUM_DDF_READERS; j++)
    DDF_Readers[j].lump = -1;

  if ((handle = open(filename, O_RDONLY | O_BINARY)) == -1)
  {
    I_Printf(" couldn't open %s\n", filename);
    return;
  }

  I_Printf("  adding %s", filename);

  startlump = numlumps;
  datafile++;
  Z_Resize(data_files, data_file_t, datafile + 1);

  data_files[datafile].file_name = Z_StrDup(filename);
  data_files[datafile].handle = handle;
  data_files[datafile].sprite_lumps = NULL;
  data_files[datafile].sprite_num = 0;
  data_files[datafile].flat_lumps = NULL;
  data_files[datafile].flat_num = 0;
  data_files[datafile].wadtex.palette = -1;
  data_files[datafile].wadtex.pnames = -1;
  data_files[datafile].wadtex.texture1 = -1;
  data_files[datafile].wadtex.texture2 = -1;

  if (M_CheckExtension("wad", filename) == EXT_MATCHING ||
      M_CheckExtension("gwa", filename) == EXT_MATCHING)
  {
    // WAD file
    data_files[datafile].type = FILE_WAD;
    read(handle, &amp;header, sizeof(wad_header_t));

    if (strncmp(header.identification, "IWAD", 4))
    {
      // Homebrew levels?
      if (strncmp(header.identification, "PWAD", 4))
      {
        I_Error("Wad file %s doesn't have IWAD or PWAD id\n", filename);
      }
    }

    header.numlumps = LONG(header.numlumps);
    header.infotableofs = LONG(header.infotableofs);

    length = header.numlumps * sizeof(wad_entry_t);
    fileinfo = Z_New(wad_entry_t, header.numlumps);

    lseek(handle, header.infotableofs, SEEK_SET);
    read(handle, fileinfo, length);

    // Fill in lumpinfo
    numlumps += header.numlumps;
    Z_Resize(lumpinfo, lumpinfo_t, numlumps);

    for (j=startlump,curinfo=fileinfo; j &lt; numlumps; j++,curinfo++)
    {
      AddLump(j, LONG(curinfo-&gt;pos), LONG(curinfo-&gt;size),
          datafile, (dyn_index &gt;= 0) ? dyn_index : datafile, 
          curinfo-&gt;name, allow_ddf);
    }

    Z_Free(fileinfo);
  }
  else
  {
    char lump_name[32];

    DEV_ASSERT2(dyn_index &lt; 0);

    // single lump file
    data_files[datafile].type = FILE_SINGLELUMP;

    ExtractFileBase(filename, lump_name);

    // Fill in lumpinfo
    numlumps++;
    Z_Resize(lumpinfo, lumpinfo_t, numlumps);

    AddLump(startlump, 0, FileLength(handle), datafile, datafile, 
        lump_name, allow_ddf);
  }

  SortLumps();
  SortSpriteLumps(data_files + datafile);

  // set up caching
  Z_Resize(lumplookup, lumpheader_t *, numlumps);
  for (j=startlump; j &lt; numlumps; j++)
    lumplookup[j] = NULL;

  // -KM- 1999/01/31 Load lumps in correct order.
  for (j=0; j &lt; NUM_DDF_READERS; j++)
  {
    if (DDF_Readers[j].lump &gt;= 0)
    {
      char *data;

      DEV_ASSERT2(dyn_index &lt; 0);

      data = Z_New(char, W_LumpLength(DDF_Readers[j].lump) + 1);
      W_ReadLump(DDF_Readers[j].lump, data);
      data[W_LumpLength(DDF_Readers[j].lump)] = 0;

      // call read function
      (* DDF_Readers[j].func)(data, W_LumpLength(DDF_Readers[j].lump));

      Z_Free(data);
    }
  }

  I_Printf("\n");

  // check for unclosed sprite/flat lists
  if (within_sprite_list)
    I_Warning("Missing S_END marker in %s.\n", filename);

  if (within_flat_list)
    I_Warning("Missing F_END marker in %s.\n", filename);
   
  // -AJA- 1999/12/25: What did Santa bring EDGE ?  Just some support
  //       for "GWA" files (part of the "GL-Friendly Nodes" specs).
  
  if (M_CheckExtension("wad", filename) == EXT_MATCHING)
  {
    char namebuf[1024];

    int len = strlen(filename);

    DEV_ASSERT2(dyn_index &lt; 0);

    // replace WAD extension with GWA
    strcpy(namebuf, filename);

    Z_StrNCpy(namebuf + len - 3, EDGEGWAEXT, 3);

    if (I_Access(namebuf))
    {
      i_time_t gwa_time;
      i_time_t wad_time;

      // OK, the GWA file exists. so check the time and date 
      // against the WAD file to see if we should include this
      // file or force the recreation of the GWA.

      if (!I_GetModifiedTime(filename, &amp;wad_time))
        I_Error("AddFile: I_GetModifiedTime failed on %s\n",filename);

      if (!I_GetModifiedTime(namebuf, &amp;gwa_time))
        I_Error("AddFile: I_GetModifiedTime failed on %s\n",namebuf);

      // Load it.  This recursion bit is
      // rather sneaky, hopefully it doesn't break anything...
      if (L_CompareTimeStamps(&amp;gwa_time, &amp;wad_time) &gt;= 0)
        AddFile(namebuf, false, datafile);
    }
  }
}
</t>
<t tx="T107">@ FlushLumpCache

Flushes parts of the cache. High urgency means more is flushed.
@c

static void FlushLumpCache(z_urgency_e urgency)
{
  int bytes_to_free = 0;
  lumpheader_t *h;

  switch (urgency)
  {
    case Z_UrgencyLow: bytes_to_free = cache_size / 16; break;
    case Z_UrgencyMedium: bytes_to_free = cache_size / 8; break;
    case Z_UrgencyHigh: bytes_to_free = cache_size / 2; break;
    case Z_UrgencyExtreme: bytes_to_free = INT_MAX; break;
    default: I_Error("FlushLumpCache: Invalid urgency level %d", urgency);
  }

  for (h = &amp;lumphead; h-&gt;next != &amp;lumphead &amp;&amp; bytes_to_free &gt; 0;)
  {
    if (h-&gt;next-&gt;users == 0)
    {
      bytes_to_free -= W_LumpLength(h-&gt;next-&gt;lumpindex);
      FreeLump(h-&gt;next);
    }
    else
      h = h-&gt;next;
  }
}
</t>
<t tx="T108">
static void InitCaches(void)
{
  lumphead.next = lumphead.prev = &amp;lumphead;
  Z_RegisterCacheFlusher(FlushLumpCache);
}
</t>
<t tx="T109">@ W_AddRawFilename
@c

void W_AddRawFilename(const char *file, boolean_t allow_ddf)
{
  raw_filename_t *r;

  L_WriteDebug("Added: %s\n", file);

  if (addwadnum == maxwadfiles)
    Z_Resize(wadfiles, raw_filename_t, ++maxwadfiles + 1);
  
  r = &amp;wadfiles[addwadnum++];

  r-&gt;file_name = Z_StrDup(file);
  r-&gt;allow_ddf = allow_ddf;
}
</t>
<t tx="T110">@ W_InitMultipleFiles

Pass a null terminated list of files to use.
All files are optional, but at least one file must be found.
Files with a .wad extension are idlink files with multiple lumps.
Other files are single lumps with the base filename for the lump name.
Lump names can appear multiple times.
The name searcher looks backwards, so a later file
does override all earlier ones.
@c

boolean_t W_InitMultipleFiles(void)
{
  int r;

  InitCaches();

  // open all the files, load headers, and count lumps
  numlumps = 0;

  // will be realloced as lumps are added
  lumpinfo = NULL;

  for (r=0; r &lt; addwadnum; r++)
    AddFile(wadfiles[r].file_name, wadfiles[r].allow_ddf, -1);

  if (!numlumps)
  {
    I_Error("W_InitMultipleFiles: no files found");
    return false;
  }

  return true;
}
</t>
<t tx="T111">@ W_GetFileName

Returns the filename of the WAD file containing the given lump, or
NULL if it wasn't a WAD file (e.g. a pure lump).
@c

const char *W_GetFileName(int lump)
{
  lumpinfo_t *l;
  data_file_t *f;

  DEV_ASSERT2(0 &lt;= lump &amp;&amp; lump &lt; numlumps);

  l = lumpinfo + lump;
  f = data_files + l-&gt;file;

  if (f-&gt;type != FILE_WAD)
    return NULL;
  
  return f-&gt;file_name;
}
</t>
<t tx="T112">@ W_GetPaletteForLump

Returns the palette lump that should be used for the given lump
(presumably an image), otherwise -1 (indicating that the global
palette should be used).

NOTE: when the same WAD as the lump does not contain a palette,
there are two possibilities: search backwards for the "closest"
palette, or simply return -1. Neither one is ideal, though I tend
to think that searching backwards is more intuitive.

NOTE 2: the palette_datafile stuff is there so we always return -1
for the "GLOBAL" palette.
@c

int W_GetPaletteForLump(int lump)
{
  lumpinfo_t *l;
  data_file_t *f;

  DEV_ASSERT2(0 &lt;= lump &amp;&amp; lump &lt; numlumps);

  l = lumpinfo + lump;
  f = data_files + l-&gt;file;

  for (; f &gt; (data_files + palette_datafile); f--)
  {
    if (f-&gt;type != FILE_WAD)
      continue;

    if (f-&gt;wadtex.palette &gt;= 0)
      return f-&gt;wadtex.palette;
  }

  // none found
  return -1;
}
</t>
<t tx="T113">@ W_AddDynamicGWA

This is only used to dynamically add a GWA file after being built
by the GLBSP plugin.
@c

void W_AddDynamicGWA(const char *filename, int map_lump)
{
  DEV_ASSERT2(0 &lt;= map_lump &amp;&amp; map_lump &lt; numlumps);

  AddFile(filename, false, lumpinfo[map_lump].file);
}
</t>
<t tx="T114">@ W_CheckNumForName

Returns -1 if name not found.

-ACB- 1998/08/09 Removed ifdef 0 stuff.
-ACB- 1999/09/18 Added name to error message
@c

int W_CheckNumForName2(const char *name)
{
  int i;
  char buf[9];

  for (i = 0; name[i]; i++)
  {
#ifdef DEVELOPERS
    if (i &gt; 8)
      I_Error("W_CheckNumForName: Name '%s' longer than 8 chars!", name);
#endif
    buf[i] = toupper(name[i]);
  }
  buf[i] = 0;

#define CMP(a) (strncmp(lumpinfo[lumpmap[a]].name, buf, 8) &lt; 0)
  BSEARCH(numlumps, i);
#undef CMP

  if (i &gt;= 0 &amp;&amp; i &lt; numlumps &amp;&amp;
      !strncmp(lumpinfo[lumpmap[i]].name, buf, 8))
  {
    return lumpmap[i];
  }

  return -1;
}
</t>
<t tx="T115">@ W_GetNumForName

Calls W_CheckNumForName, but bombs out if not found.
@c

int W_GetNumForName2(const char *name)
{
  int i;

  if ((i = W_CheckNumForName2(name)) == -1)
    I_Error("W_GetNumForName: \'%.8s\' not found!", name);

  return i;
}
</t>
<t tx="T116">@ W_VerifyLumpName

Verifies that the given lump number is valid and has the given
name.

-AJA- 1999/11/26: written.
@c

boolean_t W_VerifyLumpName(int lump, const char *name)
{
  if (lump &gt;= numlumps)
    return false;
  
  return (strncmp(lumpinfo[lump].name, name, 8) == 0);
}
</t>
<t tx="T117">@ W_LumpLength

Returns the buffer size needed to load the given lump.
@c

int W_LumpLength(int lump)
{
  if (lump &gt;= numlumps)
    I_Error("W_LumpLength: %i &gt;= numlumps", lump);

  return lumpinfo[lump].size;
}
</t>
<t tx="T118">@ W_FindFlatSequence

Returns the file number containing the sequence, or -1 if not
found. Search is from newest wad file to oldest wad file.
@c

int W_FindFlatSequence(const char *start, const char *end, 
    int *s_offset, int *e_offset)
{
  int i, file;
  data_file_t *f;
  
  for (file=datafile; file &gt;= 0; file--)
  {
    f = data_files + file;

    // look for start name
    for (i=0; i &lt; f-&gt;flat_num; i++)
    {
      if (strncmp(start, W_GetLumpName(f-&gt;flat_lumps[i]), 8) == 0)
        break;
    }

    if (i &gt;= f-&gt;flat_num)
      continue;

    (*s_offset) = i;

    // look for end name
    for (i++; i &lt; f-&gt;flat_num; i++)
    {
      if (strncmp(end, W_GetLumpName(f-&gt;flat_lumps[i]), 8) == 0)
      {
        (*e_offset) = i;
        return file;
      }
    } 
  }

  // not found
  return -1;
}
</t>
<t tx="T119">@ W_GetListLumps

Returns NULL for an empty list.
@c

const int *W_GetListLumps(int file, lumplist_e which, int *count)
{
  DEV_ASSERT2(0 &lt;= file &amp;&amp; file &lt;= datafile);

  switch (which)
  {
    case LMPLST_Sprites:
      (*count) = data_files[file].sprite_num;
      return data_files[file].sprite_lumps;
    
    case LMPLST_Flats:
      (*count) = data_files[file].flat_num;
      return data_files[file].flat_lumps;
  }

#ifdef DEVELOPERS
  I_Error("W_GetListLumps: bad `which' (%d)\n", which);
#endif
  return NULL;
}
</t>
<t tx="T120">@ W_GetNumFiles
@c

int W_GetNumFiles(void)
{
  return (datafile + 1);
}
</t>
<t tx="T121">@ W_LumpRawInfo

Retrieves the raw information about the lump: file handle, position
within file, and size in bytes. Returns true if successful, or
false if (for some reason) the lump cannot be accessed externally.

Note: this call designed to allow MP3 lumps to be accessed by the
L_MP3 code -- it shouldn't otherwise be used.
@c

boolean_t W_LumpRawInfo(int lump, int *handle, int *pos, int *size)
{
  lumpinfo_t *l;
  data_file_t *f;

  if (lump &gt;= numlumps)
    I_Error("W_LumpRawInfo: %i &gt;= numlumps", lump);

  l = lumpinfo + lump;
  f = data_files + l-&gt;file;

  (*handle) = f-&gt;handle;
  (*pos)    = l-&gt;position;
  (*size)   = l-&gt;size;
  
  return true;
}
</t>
<t tx="T122">@ W_ReadLump

Loads the lump into the given buffer,
which must be &gt;= W_LumpLength().
@c

void W_ReadLump(int lump, void *dest)
{
  int c;
  lumpinfo_t *l;
  data_file_t *f;

  if (lump &gt;= numlumps)
    I_Error("W_ReadLump: %i &gt;= numlumps", lump);

  l = lumpinfo + lump;
  f = data_files + l-&gt;file;

  // -KM- 1998/07/31 This puts the loading icon in the corner of the screen :-)
  display_disk = true;

  lseek(f-&gt;handle, l-&gt;position, SEEK_SET);

  c = read(f-&gt;handle, dest, l-&gt;size);

  if (c &lt; l-&gt;size)
    I_Error("W_ReadLump: only read %i of %i on lump %i", c, l-&gt;size, lump);
}
</t>
<t tx="T123">@ W_DoneWithLump
@c

void W_DoneWithLump(const void *ptr)
{
  lumpheader_t *h = ((lumpheader_t *)ptr); // Intentional Const Override

#ifdef DEVELOPERS
  if (h == NULL)
    I_Error("W_DoneWithLump: NULL pointer");
  if (h[-1].id != LUMPID)
    I_Error("W_DoneWithLump: id != LUMPID");
  if (h[-1].users == 0)
    I_Error("W_DoneWithLump: lump %d has no users!", h[-1].lumpindex);
#endif
  h--;
  h-&gt;users--;
  if (h-&gt;users == 0)
  {
    // Move the item to the tail.
    h-&gt;prev-&gt;next = h-&gt;next;
    h-&gt;next-&gt;prev = h-&gt;prev;
    h-&gt;prev = lumphead.prev;
    h-&gt;next = &amp;lumphead;
    h-&gt;prev-&gt;next = h;
    h-&gt;next-&gt;prev = h;
    MarkAsCached(h);
  }
}
</t>
<t tx="T124">@ W_DoneWithLump_Flushable

Call this if the lump probably won't be used for a while, to hint the
system to flush it early.

Useful if you are creating a cache for e.g. some kind of lump
conversions (like the sound cache).
@c

void W_DoneWithLump_Flushable(const void *ptr)
{
  lumpheader_t *h = ((lumpheader_t *)ptr); // Intentional Const Override

#ifdef DEVELOPERS
  if (h == NULL)
    I_Error("W_DoneWithLump: NULL pointer");
  h--;
  if (h-&gt;id != LUMPID)
    I_Error("W_DoneWithLump: id != LUMPID");
  if (h-&gt;users == 0)
    I_Error("W_DoneWithLump: lump %d has no users!", h-&gt;lumpindex);
#endif
  h-&gt;users--;
  if (h-&gt;users == 0)
  {
    // Move the item to the head of the list.
    h-&gt;prev-&gt;next = h-&gt;next;
    h-&gt;next-&gt;prev = h-&gt;prev;
    h-&gt;next = lumphead.next;
    h-&gt;prev = &amp;lumphead;
    h-&gt;prev-&gt;next = h;
    h-&gt;next-&gt;prev = h;
    MarkAsCached(h);
  }
}
</t>
<t tx="T125">@ W_CacheLumpNum
@c

const void *W_CacheLumpNum2 (int lump)
{
  lumpheader_t *h;

#ifdef DEVELOPERS
  if ((unsigned int)lump &gt;= (unsigned int)numlumps)
    I_Error("W_CacheLumpNum: %i &gt;= numlumps", lump);
#endif

  h = lumplookup[lump];

  if (h)
  {
    // cache hit
    if (h-&gt;users == 0)
      cache_size -= W_LumpLength(h-&gt;lumpindex);
    h-&gt;users++;
  }
  else
  {
    // cache miss. load the new item.
    h = (lumpheader_t *) Z_Malloc(sizeof(lumpheader_t) + W_LumpLength(lump));
    lumplookup[lump] = h;
#ifdef DEVELOPERS
    h-&gt;id = LUMPID;
#endif
    h-&gt;lumpindex = lump;
    h-&gt;users = 1;
    h-&gt;prev = lumphead.prev;
    h-&gt;next = &amp;lumphead;
    h-&gt;prev-&gt;next = h;
    lumphead.prev = h;

    W_ReadLump(lump, (void *)(h + 1));
  }

  return (void *)(h + 1);
}
</t>
<t tx="T126">@ W_CacheLumpName
@c

const void *W_CacheLumpName2(const char *name)
{
  return W_CacheLumpNum2(W_GetNumForName2(name));
}
</t>
<t tx="T127">@ W_PreCacheLumpNum

Attempts to load lump into the cache, if it isn't already there
@c

void W_PreCacheLumpNum(int lump)
{
  W_DoneWithLump(W_CacheLumpNum(lump));
}
</t>
<t tx="T128">@ W_PreCacheLumpName
@c

void W_PreCacheLumpName(const char *name)
{
  W_DoneWithLump(W_CacheLumpName(name));
}
</t>
<t tx="T129">@ W_CacheInfo
@c

int W_CacheInfo(int level)
{
  lumpheader_t *h;
  int value = 0;

  for (h = lumphead.next; h != &amp;lumphead; h = h-&gt;next)
  {
    if ((level &amp; 1) &amp;&amp; h-&gt;users)
      value += W_LumpLength(h-&gt;lumpindex);
    if ((level &amp; 2) &amp;&amp; !h-&gt;users)
      value += W_LumpLength(h-&gt;lumpindex);
  }
  return value;
}
</t>
<t tx="T130">@ W_LoadLumpNum

Returns a copy of the lump (it is your responsibility to free it)
@c

void *W_LoadLumpNum(int lump)
{
  void *p;
  const void *cached;
  int length = W_LumpLength(lump);
  p = (void *) Z_Malloc(length);
  cached = W_CacheLumpNum2(lump);
  memcpy(p, cached, length);
  W_DoneWithLump(cached);
  return p;
}
</t>
<t tx="T131">@ W_LoadLumpName
@c

void *W_LoadLumpName(const char *name)
{
  return W_LoadLumpNum(W_GetNumForName2(name));
}
</t>
<t tx="T132">@ W_GetLumpName
@c

const char *W_GetLumpName(int lump)
{
  return lumpinfo[lump].name;
}
</t>
<t tx="T133">@ignore
@language c

// Intermission Code

// -KM- 1998/12/16 Nuked half of this for DDF. DOOM 1 works now!

&lt;&lt; wi_stuff #includes &gt;&gt;
&lt;&lt; wi_stuff declarations &gt;&gt;
@others
</t>
<t tx="T134">#include "i_defs.h"
#include "wi_stuff.h"

#include "dm_state.h"
#include "g_game.h"
#include "hu_lib.h"
#include "m_random.h"
#include "m_menu.h"
#include "m_swap.h"
#include "p_local.h"
#include "r_local.h"
#include "r_view.h"
#include "s_sound.h"
#include "v_ctx.h"
#include "v_colour.h"
#include "v_res.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T135">
//
// Data needed to add patches to full screen intermission pics.
// Patches are statistics messages, and animations.
// Loads of by-pixel layout and placement, offsets etc.
//

// GLOBAL LOCATIONS
#define WI_TITLEY   6
#define WI_SPACINGY 33

// SINGPLE-PLAYER STUFF
#define SP_STATSX 50
#define SP_STATSY 50

#define SP_TIMEX 16
#define SP_TIMEY (200-32)

//
// GENERAL DATA
//

//
// Locally used stuff.
//

// States for single-player
#define SP_KILLS  0
#define SP_ITEMS  2
#define SP_SECRET 4
#define SP_FRAGS  6
#define SP_TIME   8
#define SP_PAR    ST_TIME

#define SP_PAUSE 1

// in seconds
#define SHOWNEXTLOCDELAY 4
#define SHOWLASTLOCDELAY SHOWNEXTLOCDELAY

// used to accelerate or skip a stage
static boolean_t acceleratestage;

// wbs-&gt;pnum
static int me;

 // specifies current state
static stateenum_t state;

// contains information passed into intermission
static wbstartstruct_t *wbs;

static wbplayerstruct_t *plrs;  // wbs-&gt;plyr[]

// used for general timing
static int cnt;

// used for timing of background animation
static int bcnt;

// signals to refresh everything for one frame
static int firstrefresh;

static int cnt_kills[10];
static int cnt_items[10];
static int cnt_secret[10];
static int cnt_time;
static int cnt_par;
static int cnt_pause;

// GRAPHICS

// background
static const image_t *bg_image;

// You Are Here graphic
static const image_t *yah[2] = {NULL, NULL};

// splat
static const image_t *splat[2] = {NULL, NULL};

// %, : graphics
static const image_t *percent;
static const image_t *colon;

// 0-9 graphic
static const image_t *digits[10];

// minus sign
static const image_t *wiminus;

// "Finished!" graphics
static const image_t *finished;

// "Entering" graphic
static const image_t *entering;

// "secret"
static const image_t *sp_secret;

 // "Kills", "Scrt", "Items", "Frags"
static const image_t *kills;
static const image_t *secret;
static const image_t *items;
static const image_t *frags;

// Time sucks.
static const image_t *time_image; // -ACB- 1999/09/19 Removed Conflict with &lt;time.h&gt;
static const image_t *par;
static const image_t *sucks;

// "killers", "victims"
static const image_t *killers;
static const image_t *victims;

// "Total", your face, your dead face
static const image_t *total;
static const image_t *star;
static const image_t *bstar;

// Name graphics of each level (centered)
static const image_t *lnames[2];

// -KM- 1998/12/17 Needs access from savegame code
wi_map_t worldmap;
</t>
<t tx="T136">@ CODE

Called everytime the map changes.
-KM- 1998/12/17 Beefed up: if worldmap.name == NULL we haven't
inited yet. if map == NULL reload the intermission anyway
(we are starting a new game.)
@c

void WI_MapInit(const wi_map_t * map)
{
  if (!map)
    worldmap.ddf.name = NULL;
  else
  {
    if (!worldmap.ddf.name || strcmp(map-&gt;ddf.name, worldmap.ddf.name))
    {
      worldmap = *map;
      Z_Clear(worldmap.mapdone, boolean_t, worldmap.nummaps);
    }
  }
}
</t>
<t tx="T137">@ Draws "&lt;Levelname&gt; Finished!"
@c

static void DrawLevelFinished(void)
{
  int y = WI_TITLEY;
  int w, w2, h;

  // draw &lt;LevelName&gt; 
  DEV_ASSERT2(lnames[0]);

  w = IM_WIDTH(lnames[0]);
  h = IM_HEIGHT(lnames[0]);

  w2 = IM_WIDTH(finished);

  VCTX_ImageEasy320(160 - w/2,  y, lnames[0]);
  VCTX_ImageEasy320(160 - w2/2, y + h * 5/4, finished);
}
</t>
<t tx="T138">@ Draws "Entering &lt;LevelName&gt;"
@c

static void DrawEnteringLevel(void)
{
  int y = WI_TITLEY;
  int w, w2, h;

  // -KM- 1998/11/25 If there is no level to enter, don't draw it.
  //      (Stop Map30 from crashing)
  if (! lnames[1])
    return;

  h = IM_HEIGHT(entering);
  w = IM_WIDTH(entering);
  w2 = IM_WIDTH(lnames[1]);

  VCTX_ImageEasy320(160 - w/2,  y, entering);
  VCTX_ImageEasy320(160 - w2/2, y + h * 5/4, lnames[1]);
}
</t>
<t tx="T139">
static void DrawOnLnode(int n, const image_t * images[2])
{
  int i;
  int left, top, right, bottom;

  boolean_t fits = false;
  mappos_t *mappos = &amp;worldmap.mappos[n];

  for (i=0; i &lt; 2; i++)
  {
    // -AJA- something fishy going on here. The following is just a
    //       band-aid solution.
    if (images[i] == NULL)
    {
      i++;
      continue;
    }

    left = mappos-&gt;pos.x - images[i]-&gt;offset_x;
    top  = mappos-&gt;pos.y - images[i]-&gt;offset_y;
    right  = left + IM_WIDTH(images[i]);
    bottom = top + IM_HEIGHT(images[i]);

    if (left &gt;= 0 &amp;&amp; right &lt; 320 &amp;&amp; top &gt;= 0 &amp;&amp; bottom &lt; 200)
    {
      fits = true;
      break;
    }
    else
    {
      i++;
    }
  }

  if (fits &amp;&amp; i &lt; 2)
  {
    VCTX_ImageEasy320(mappos-&gt;pos.x, mappos-&gt;pos.y, images[i]);
  }
  else
  {
    L_WriteDebug("Could not place patch on level '%s'\n", mappos[n].name);
  }
}
</t>
<t tx="T140">@ Draws a number.

If numdigits &gt; 0, then use that many digits minimum,
otherwise only use as many as necessary.
Returns new x position.
@c

static int DrawNum(int x, int y, int n, int numdigits)
{
  int neg;
  int temp;

  neg = n &lt; 0;

  if (neg)
    n = -n;

  // if non-number, do not draw it
  if (n == 1994)
    return 0;

  if (numdigits &lt; 0)
  {
    if (!n)
    {
      // make variable-length zeros 1 digit long
      numdigits = 1;
    }
    else
    {
      // figure out # of digits in #
      numdigits = 0;
      temp = n;

      while (temp)
      {
        temp /= 10;
        numdigits++;
      }
    }
  }

  // draw the new number
  for (; numdigits &gt; 0; n /= 10, numdigits--)
  {
    x -= IM_WIDTH(digits[0]);
    VCTX_ImageEasy320(x, y, digits[n % 10]);
  }

  // draw a minus sign if necessary
  if (neg)
  {
    x -= IM_WIDTH(wiminus);
    VCTX_ImageEasy320(x, y, wiminus);
  }

  return x;
}
</t>
<t tx="T141">
static void DrawPercent(int x, int y, int p)
{
  if (p &lt; 0)
    return;

  VCTX_ImageEasy320(x, y, percent);

  DrawNum(x, y, p, -1);
}
</t>
<t tx="T142">@ Display level completion time and par,
or "sucks" message if overflow.
@c

static void DrawTime(int x, int y, int t)
{
  int div;
  int n;

  if (t &lt; 0)
    return;

  if (t &lt;= 61 * 59)
  {
    div = 1;

    do
    {
      n = (t / div) % 60;
      x = DrawNum(x, y, n, 2) - IM_WIDTH(colon);
      div *= 60;

      // draw
      if (div == 60 || t / div)
        VCTX_ImageEasy320(x, y, colon);
    }
    while (t / div);
  }
  else
  {
    // "sucks"
    VCTX_ImageEasy320(x - IM_WIDTH(sucks), y, sucks);
  }
}
</t>
<t tx="T143">
static void UnloadData(void)
{
#if 0  // OLD STUFF
  int i, j;

  W_DoneWithLump(bg);

  for (i = 0; i &lt; 2; i++)
  {
    if (lnames[i])
      W_DoneWithLump(lnames[i]);
    if (yah[i])
      W_DoneWithLump(yah[i]);
    if (splat[i])
      W_DoneWithLump(splat[i]);
    lnames[i] = NULL;
    yah[i] = NULL;
    splat[i] = NULL;
  }
  W_DoneWithLump(wiminus);
  W_DoneWithLump(percent);
  W_DoneWithLump(finished);
  W_DoneWithLump(entering);
  W_DoneWithLump(kills);
  W_DoneWithLump(secret);
  W_DoneWithLump(sp_secret);
  W_DoneWithLump(items);
  W_DoneWithLump(frags);
  W_DoneWithLump(colon);
  W_DoneWithLump(time_image);
  W_DoneWithLump(sucks);
  W_DoneWithLump(par);
  W_DoneWithLump(killers);
  W_DoneWithLump(victims);
  W_DoneWithLump(total);
  W_DoneWithLump(star);
  W_DoneWithLump(bstar);

  for (i = 0; i &lt; 10; i++)
    W_DoneWithLump(digits[i]);

  for (i = 0; i &lt; worldmap.numanims; i++)
    for (j = 0; j &lt; worldmap.anims[i].numframes; j++)
      W_DoneWithLump(worldmap.anims[i].frames[j].p);
#endif
}
</t>
<t tx="T144">
static void WI_End(void)
{
  UnloadData();

  background_camera_mo = NULL;
  R_ExecuteSetViewSize();
}
</t>
<t tx="T145">
static void InitNoState(void)
{
  state = NoState;
  acceleratestage = false;
  cnt = 10;
}
</t>
<t tx="T146">
static void UpdateNoState(void)
{
  if (!--cnt)
  {
    WI_End();
    G_WorldDone();
  }

}
</t>
<t tx="T147">
static boolean_t snl_pointeron = false;

static void InitShowNextLoc(void)
{
  int i;

  state = ShowNextLoc;
  acceleratestage = false;
  cnt = SHOWNEXTLOCDELAY * TICRATE;

  for (i = 0; i &lt; worldmap.nummaps; i++)
    if (!strcmp(worldmap.mappos[i].name, wbs-&gt;last-&gt;ddf.name))
      worldmap.mapdone[i] = true;
}
</t>
<t tx="T148">
static void UpdateShowNextLoc(void)
{
  if (!--cnt || acceleratestage)
    InitNoState();
  else
    snl_pointeron = (cnt &amp; 31) &lt; 20;
}
</t>
<t tx="T149">
static void DrawShowNextLoc(void)
{
  int i;

  for (i = 0; i &lt; worldmap.nummaps; i++)
  {
    if (worldmap.mapdone[i])
      DrawOnLnode(i, splat);

    if (wbs-&gt;next)
      if (snl_pointeron &amp;&amp; !strcmp(wbs-&gt;next-&gt;ddf.name, worldmap.mappos[i].name))
        DrawOnLnode(i, yah);
  }

  DrawEnteringLevel();
}
</t>
<t tx="T150">
static void DrawNoState(void)
{
  snl_pointeron = true;
  DrawShowNextLoc();
}
</t>
<t tx="T151">
static int dm_state;
static int dm_frags[10];
static int dm_totals[10];
static int dm_rank[10];

static int WI_DeathmatchScore(int pl)
{
  if (pl &gt;= 0)
  {
    return plrs[pl].totalfrags * 2 + plrs[pl].frags;
  }
  return INT_MIN;
}
</t>
<t tx="T152">
static void InitDeathmatchStats(void)
{

  int i;
  int j;
  boolean_t done = false;
  int *rank;

  rank = Z_New(int, MAXPLAYERS);
  state = StatCount;
  acceleratestage = false;
  dm_state = 1;

  cnt_pause = TICRATE;

  for (i = 0; i &lt; MAXPLAYERS; i++)
    rank[i] = plrs[i].in ? i : -1;
  for (i = 0; i &lt; 10; i++)
    dm_frags[i] = dm_totals[i] = 0;

  // bubble sort the rank list
  while (!done)
  {
    for (i = 0; i &lt; MAXPLAYERS - 1; i++)
    {
      if (WI_DeathmatchScore(rank[i]) &lt; WI_DeathmatchScore(rank[i + 1]))
      {
        j = rank[i];
        rank[i] = rank[i + 1];
        rank[i + 1] = j;
      }
    }
    done = true;
    for (i = 0; i &lt; MAXPLAYERS - 1; i++)
    {
      if (WI_DeathmatchScore(rank[i]) &lt; WI_DeathmatchScore(rank[i + 1]))
      {
        done = false;
        break;
      }
    }
  }
  for (i = 0; i &lt; (10 &gt; MAXPLAYERS ? MAXPLAYERS : 10); i++)
    dm_rank[i] = rank[i];
  for (; i &lt; 10; i++)
    dm_rank[i] = -1;

  Z_Free(rank);
}
</t>
<t tx="T153">
static void UpdateDeathmatchStats(void)
{
  int i;
  int p;

  boolean_t stillticking;

  if (acceleratestage &amp;&amp; dm_state != 4)
  {
    acceleratestage = false;

    for (i = 0; i &lt; 10 &amp;&amp; i &lt; MAXPLAYERS; i++)
    {
      p = dm_rank[i];
      if (p &gt;= 0)
      {
        if (playerlookup[p] &amp;&amp; playerlookup[p]-&gt;in_game)
        {
          dm_frags[i] = plrs[p].frags;
          dm_totals[i] = plrs[p].totalfrags;
        }
      }
    }

    S_StartSound(NULL, worldmap.done);
    dm_state = 4;
  }

  switch (dm_state)
  {
    case 2:
      if (!(bcnt &amp; 3))
        S_StartSound(NULL, worldmap.percent);

      stillticking = false;
      for (i = 0; i &lt; 10; i++)
      {
        p = dm_rank[i];
        if (p &gt;= 0)
        {
          if (playerlookup[p] &amp;&amp; playerlookup[p]-&gt;in_game)
          {
            if (dm_frags[i] &lt; plrs[p].frags)
            {
              dm_frags[i]++;
              stillticking = true;
            }
            if (dm_totals[i] &lt; plrs[p].totalfrags)
            {
              dm_totals[i]++;
              stillticking = true;
            }
          }
        }
      }
      if (!stillticking)
      {
        S_StartSound(NULL, worldmap.done);
        dm_state++;
      }
      break;

    case 4:
      if (acceleratestage)
      {
        S_StartSound(NULL, worldmap.accel_snd);

        if (!worldmap.nummaps)
          InitNoState();
        else
          InitShowNextLoc();
      }
      break;

    default:
      if (!--cnt_pause)
      {
        dm_state++;
        cnt_pause = TICRATE;
      }
      break;
  }
}
</t>
<t tx="T154">
static void DrawDeathmatchStats(void)
{
  int i;
  int y;
  int p;

  char temp[16];

  DrawLevelFinished();

  HL_WriteText(20, 40, "Player");
  HL_WriteText(100, 40, "Frags");
  HL_WriteText(200, 40, "Total Frags");
  y = 40;

  for (i = 0; i &lt; 10; i++)
  {
    p = dm_rank[i];
    if (p &gt;= 0 &amp;&amp; playerlookup[p] &amp;&amp; playerlookup[p]-&gt;in_game)
    {
      y += 12;
      if (p == me &amp;&amp; ((bcnt &amp; 31) &lt; 16))
        continue;

      HL_WriteTextTrans(20, y, text_white_map, 
          playerlookup[p]-&gt;playername);
      sprintf(temp, "%5d", dm_frags[i]);
      HL_WriteTextTrans(100, y, text_white_map, temp);
      sprintf(temp, "%11d", dm_totals[i]);
      HL_WriteTextTrans(200, y, text_white_map, temp);
    }
  }
}
</t>
<t tx="T155">
static int cnt_frags[10];
static int cnt_tfrags[10];
static int dofrags;
static int ng_state;

// Calculates value of this player for ranking
static int NetgameScore(int pl)
{
  if (pl &gt;= 0)
  {
    int kills = plrs[pl].skills * 400 / wbs-&gt;maxkills;
    int items = plrs[pl].sitems * 100 / wbs-&gt;maxitems;
    int secret = plrs[pl].ssecret * 200 / wbs-&gt;maxsecret;
    int frags = (plrs[pl].frags + plrs[pl].totalfrags) * 25;

    return kills + items + secret - frags;
  }
  return INT_MIN;
}
</t>
<t tx="T156">
static void InitNetgameStats(void)
{
  int *rank;
  int i, j;
  boolean_t done = false;

  rank = Z_New(int, MAXPLAYERS);
  state = StatCount;
  acceleratestage = false;
  ng_state = 1;

  cnt_pause = TICRATE;

  for (i = 0; i &lt; (10 &gt; MAXPLAYERS ? MAXPLAYERS : 10); i++)
    rank[i] = plrs[i].in ? i : -1;

  while (!done)
  {
    for (i = 0; i &lt; MAXPLAYERS - 1; i++)
    {
      if (NetgameScore(rank[i]) &lt; NetgameScore(rank[i + 1]))
      {
        j = rank[i];
        rank[i] = rank[i + 1];
        rank[i + 1] = j;
      }
    }
    done = true;
    for (i = 0; i &lt; MAXPLAYERS - 1; i++)
    {
      if (NetgameScore(rank[i]) &lt; NetgameScore(rank[i + 1]))
      {
        done = false;
        break;
      }
    }
  }
  for (i = 0; i &lt; 10; i++)
    dm_rank[i] = (i &gt;= MAXPLAYERS) ? -1 : rank[i];

  for (i = 0; i &lt; 10; i++)
  {
    if (dm_rank[i] &lt; 0)
      continue;
    if (!playerlookup[dm_rank[i]] || !playerlookup[dm_rank[i]]-&gt;in_game)
      continue;

    cnt_kills[i] = cnt_items[i] = cnt_secret[i] = cnt_frags[i] = cnt_tfrags[i] = 0;

    dofrags += plrs[dm_rank[i]].frags + plrs[dm_rank[i]].totalfrags;
  }

  Z_Free(rank);
}
</t>
<t tx="T157">
static void UpdateNetgameStats(void)
{
  int i;
  int p;

  boolean_t stillticking;

  if (acceleratestage &amp;&amp; ng_state != 10)
  {
    acceleratestage = false;

    for (i = 0; i &lt; 10; i++)
    {
      p = dm_rank[i];
      if (p &lt; 0)
        continue;
      if (!playerlookup[p] || !playerlookup[p]-&gt;in_game)
        continue;

      cnt_kills[i] = (plrs[p].skills * 100) / wbs-&gt;maxkills;
      cnt_items[i] = (plrs[p].sitems * 100) / wbs-&gt;maxitems;
      cnt_secret[i] = (plrs[p].ssecret * 100) / wbs-&gt;maxsecret;

      if (dofrags)
      {
        cnt_frags[i] = plrs[p].frags;
        cnt_tfrags[i] = plrs[p].totalfrags;
      }
    }
    S_StartSound(NULL, worldmap.done);
    ng_state = 10;
  }

  switch (ng_state)
  {
    case 2:
      if (!(bcnt &amp; 3))
        S_StartSound(NULL, worldmap.percent);

      stillticking = false;

      for (i = 0; i &lt; 10; i++)
      {
        p = dm_rank[i];
        if (p &lt; 0)
          break;
        if (!playerlookup[p] || playerlookup[p]-&gt;in_game)
          continue;

        cnt_kills[i] += 2;

        if (cnt_kills[i] &gt;= (plrs[p].skills * 100) / wbs-&gt;maxkills)
          cnt_kills[i] = (plrs[p].skills * 100) / wbs-&gt;maxkills;
        else
          stillticking = true;
      }

      if (!stillticking)
      {
        S_StartSound(NULL, worldmap.done);
        ng_state++;
      }
      break;

    case 4:
      if (!(bcnt &amp; 3))
        S_StartSound(NULL, worldmap.percent);

      stillticking = false;

      for (i = 0; i &lt; 10; i++)
      {
        p = dm_rank[i];
        if (p &lt; 0)
          break;
        if (!playerlookup[p] || playerlookup[p]-&gt;in_game)
          continue;

        cnt_items[i] += 2;
        if (cnt_items[i] &gt;= (plrs[p].sitems * 100) / wbs-&gt;maxitems)
          cnt_items[i] = (plrs[p].sitems * 100) / wbs-&gt;maxitems;
        else
          stillticking = true;
      }
      if (!stillticking)
      {
        S_StartSound(NULL, worldmap.done);
        ng_state++;
      }
      break;

    case 6:
      if (!(bcnt &amp; 3))
        S_StartSound(NULL, worldmap.percent);

      stillticking = false;

      for (i = 0; i &lt; 10; i++)
      {
        p = dm_rank[i];
        if (p &lt; 0)
          break;
        if (!playerlookup[p] || playerlookup[p]-&gt;in_game)
          continue;

        cnt_secret[i] += 2;

        if (cnt_secret[i] &gt;= (plrs[p].ssecret * 100) / wbs-&gt;maxsecret)
          cnt_secret[i] = (plrs[p].ssecret * 100) / wbs-&gt;maxsecret;
        else
          stillticking = true;
      }

      if (!stillticking)
      {
        S_StartSound(NULL, worldmap.done);
        ng_state += 1 + 2 * !dofrags;
      }
      break;

    case 8:
      if (!(bcnt &amp; 3))
        S_StartSound(NULL, worldmap.percent);

      stillticking = false;

      for (i = 0; i &lt; 10; i++)
      {
        p = dm_rank[i];
        if (p &lt; 0)
          break;

        if (!playerlookup[p] || playerlookup[p]-&gt;in_game)
          continue;

        cnt_frags[i]++;
        cnt_tfrags[i]++;

        if (cnt_frags[i] &gt;= plrs[p].frags)
          cnt_frags[i] = plrs[p].frags;
        else if (cnt_tfrags[i] &gt;= plrs[p].totalfrags)
          cnt_tfrags[i] = plrs[p].totalfrags;
        else
          stillticking = true;
      }

      if (!stillticking)
      {
        S_StartSound(NULL, worldmap.frag_snd);
        ng_state++;
      }
      break;

    case 10:
      if (acceleratestage)
      {
        S_StartSound(NULL, worldmap.nextmap);
        if (!worldmap.nummaps)
          InitNoState();
        else
          InitShowNextLoc();
      }

    default:
      if (!--cnt_pause)
      {
        ng_state++;
        cnt_pause = TICRATE;
      }
  }
}
</t>
<t tx="T158">
static void DrawNetgameStats(void)
{
  int i;
  int y;
  int p;
  char temp[16];

  DrawLevelFinished();

  HL_WriteText(6, 40, "Player");
  HL_WriteText(56, 40, "Kills");
  HL_WriteText(98, 40, "Items");
  HL_WriteText(142, 40, "Secret");
  if (dofrags)
  {
    HL_WriteText(190, 40, "Frags");
    HL_WriteText(232, 40, "Total Frags");
  }

  y = 40;
  for (i = 0; i &lt; 10; i++)
  {
    p = dm_rank[i];
    if (p &lt; 0)
      break;
    y += 12;
    if (p == me &amp;&amp; ((bcnt &amp; 31) &lt; 16))
      continue;

    sprintf(temp, "%s", (playerlookup[p] &amp;&amp; playerlookup[p]-&gt;in_game)
         ? playerlookup[p]-&gt;playername : "NOBODY");
    HL_WriteTextTrans(6, y, text_white_map, temp);
    sprintf(temp, "%%%3d", cnt_kills[i]);
    HL_WriteTextTrans(64, y, text_white_map, temp);
    sprintf(temp, "%%%3d", cnt_items[i]);
    HL_WriteTextTrans(106, y, text_white_map, temp);
    sprintf(temp, "%%%3d", cnt_secret[i]);
    HL_WriteTextTrans(158, y, text_white_map, temp);

    if (dofrags)
    {
      sprintf(temp, "%5d", cnt_frags[i]);
      HL_WriteTextTrans(190, y, text_white_map, temp);
      sprintf(temp, "%11d", cnt_tfrags[i]);
      HL_WriteTextTrans(232, y, text_white_map, temp);
    }
  }
}
</t>
<t tx="T159">
typedef enum
{
  sp_paused = 1,
  sp_kills = 2,
  sp_items = 4,
  sp_scrt = 6,
  sp_time = 8,
  sp_end = 10
}
sp_state_t;

static sp_state_t sp_state;

static void InitStats(void)
{
  state = StatCount;
  acceleratestage = false;
  sp_state = 1;
  cnt_kills[0] = cnt_items[0] = cnt_secret[0] = -1;
  cnt_time = cnt_par = -1;
  cnt_pause = TICRATE;

  //WI_initAnimatedBack()
}
</t>
<t tx="T160">
static void UpdateStats(void)
{

  //WI_updateAnimatedBack();

  if (acceleratestage &amp;&amp; sp_state != sp_end)
  {
    acceleratestage = false;
    cnt_kills[0] = (plrs[me].skills * 100) / wbs-&gt;maxkills;
    cnt_items[0] = (plrs[me].sitems * 100) / wbs-&gt;maxitems;
    cnt_secret[0] = (plrs[me].ssecret * 100) / wbs-&gt;maxsecret;
    cnt_time = plrs[me].stime / TICRATE;
    cnt_par = wbs-&gt;partime / TICRATE;
    S_StartSound(NULL, worldmap.done);
    sp_state = sp_end;
  }

  if (sp_state == sp_kills)
  {
    cnt_kills[0] += 2;

    if (!(bcnt &amp; 3))
      S_StartSound(NULL, worldmap.percent);

    if (cnt_kills[0] &gt;= (plrs[me].skills * 100) / wbs-&gt;maxkills)
    {
      cnt_kills[0] = (plrs[me].skills * 100) / wbs-&gt;maxkills;
      S_StartSound(NULL, worldmap.done);
      sp_state++;
    }
  }
  else if (sp_state == sp_items)
  {
    cnt_items[0] += 2;

    if (!(bcnt &amp; 3))
      S_StartSound(NULL, worldmap.percent);

    if (cnt_items[0] &gt;= (plrs[me].sitems * 100) / wbs-&gt;maxitems)
    {
      cnt_items[0] = (plrs[me].sitems * 100) / wbs-&gt;maxitems;
      S_StartSound(NULL, worldmap.done);
      sp_state++;
    }
  }
  else if (sp_state == sp_scrt)
  {
    cnt_secret[0] += 2;

    if (!(bcnt &amp; 3))
      S_StartSound(NULL, worldmap.percent);

    if (cnt_secret[0] &gt;= (plrs[me].ssecret * 100) / wbs-&gt;maxsecret)
    {
      cnt_secret[0] = (plrs[me].ssecret * 100) / wbs-&gt;maxsecret;
      S_StartSound(NULL, worldmap.done);
      sp_state++;
    }
  }

  else if (sp_state == sp_time)
  {
    if (!(bcnt &amp; 3))
      S_StartSound(NULL, worldmap.percent);

    cnt_time += 3;

    if (cnt_time &gt;= plrs[me].stime / TICRATE)
      cnt_time = plrs[me].stime / TICRATE;

    cnt_par += 3;

    if (cnt_par &gt;= wbs-&gt;partime / TICRATE)
    {
      cnt_par = wbs-&gt;partime / TICRATE;

      if (cnt_time &gt;= plrs[me].stime / TICRATE)
      {
        S_StartSound(NULL, worldmap.done);
        sp_state++;
      }
    }
  }
  else if (sp_state == sp_end)
  {
    if (acceleratestage)
    {
      S_StartSound(NULL, worldmap.nextmap);

      if (!worldmap.nummaps)
        InitNoState();
      else
        InitShowNextLoc();
    }
  }
  else if (sp_state &amp; sp_paused)
  {
    if (!--cnt_pause)
    {
      sp_state++;
      cnt_pause = TICRATE;
    }
  }

}
</t>
<t tx="T161">
static void DrawStats(void)
{
  // line height
  int lh;

  lh = IM_HEIGHT(digits[0]) * 3/2;

  // draw animated background
  //WI_drawAnimatedBack();

  DrawLevelFinished();

  VCTX_ImageEasy320(SP_STATSX, SP_STATSY, kills);
  DrawPercent(320 - SP_STATSX, SP_STATSY, cnt_kills[0]);

  VCTX_ImageEasy320(SP_STATSX, SP_STATSY + lh, items);
  DrawPercent(320 - SP_STATSX, SP_STATSY + lh, cnt_items[0]);

  VCTX_ImageEasy320(SP_STATSX, SP_STATSY + 2 * lh, sp_secret);
  DrawPercent(320 - SP_STATSX, SP_STATSY + 2 * lh, cnt_secret[0]);

  VCTX_ImageEasy320(SP_TIMEX, SP_TIMEY, time_image);
  DrawTime(160 - SP_TIMEX, SP_TIMEY, cnt_time);

  // -KM- 1998/11/25 Removed episode check. Replaced with partime check
  if (wbs-&gt;partime)
  {
    VCTX_ImageEasy320(160 + SP_TIMEX, SP_TIMEY, par);
    DrawTime(320 - SP_TIMEX, SP_TIMEY, cnt_par);
  }
}
</t>
<t tx="T162">
static void CheckForAccelerate(void)
{
  player_t *player;

  // check for button presses to skip delays
  for (player = players; player; player = player-&gt;next)
  {
    if (player-&gt;cmd.buttons &amp; BT_ATTACK)
    {
      if (!player-&gt;attackdown)
        acceleratestage = true;
      player-&gt;attackdown = true;
    }
    else
      player-&gt;attackdown = false;
    if (player-&gt;cmd.buttons &amp; BT_USE)
    {
      if (!player-&gt;usedown)
        acceleratestage = true;
      player-&gt;usedown = true;
    }
    else
      player-&gt;usedown = false;
  }
}
</t>
<t tx="T163">@ Updates stuff each tick
@c

void WI_Ticker(void)
{
  int i;

  // counter for general background animation
  bcnt++;

  if (bcnt == 1)
  {
    // intermission music
    S_ChangeMusic(worldmap.music, true);
  }

  CheckForAccelerate();

  for (i = 0; i &lt; worldmap.numanims; i++)
  {
    if (worldmap.anims[i].count &gt;= 0)
    {
      if (!worldmap.anims[i].count)
      {
        worldmap.anims[i].frameon
            = (worldmap.anims[i].frameon + 1) % worldmap.anims[i].numframes;
        worldmap.anims[i].count
            = worldmap.anims[i].frames[worldmap.anims[i].frameon].tics;
      }
      worldmap.anims[i].count--;
    }
  }

  switch (state)
  {
    case StatCount:
      if (deathmatch)
        UpdateDeathmatchStats();
      else if (netgame)
        UpdateNetgameStats();
      else
        UpdateStats();
      break;

    case ShowNextLoc:
      UpdateShowNextLoc();
      break;

    case NoState:
      UpdateNoState();
      break;
  }
}
</t>
<t tx="T164">
static void LoadData(void)
{
  int i, j;
  char name[10];

  // background
  bg_image = W_ImageFromPatch(worldmap.background);

  lnames[0] = W_ImageFromPatch(wbs-&gt;last-&gt;namegraphic);

  if (wbs-&gt;next)
    lnames[1] = W_ImageFromPatch(wbs-&gt;next-&gt;namegraphic);

  if (worldmap.yah[0][0])
    yah[0] = W_ImageFromPatch(worldmap.yah[0]);
  if (worldmap.yah[1][0])
    yah[1] = W_ImageFromPatch(worldmap.yah[1]);
  if (worldmap.splatpic[0])
    splat[0] = W_ImageFromPatch(worldmap.splatpic);

  wiminus = W_ImageFromFont("WIMINUS");
  percent = W_ImageFromFont("WIPCNT");
  colon = W_ImageFromFont("WICOLON");

  finished = W_ImageFromPatch("WIF");
  entering = W_ImageFromPatch("WIENTER");
  kills = W_ImageFromPatch("WIOSTK");
  secret = W_ImageFromPatch("WIOSTS");  // "scrt"

  sp_secret = W_ImageFromPatch("WISCRT2");  // "secret"

  items = W_ImageFromPatch("WIOSTI");
  frags = W_ImageFromPatch("WIFRGS");
  time_image = W_ImageFromPatch("WITIME");
  sucks = W_ImageFromPatch("WISUCKS");
  par = W_ImageFromPatch("WIPAR");
  killers = W_ImageFromPatch("WIKILRS");  // "killers" (vertical)

  victims = W_ImageFromPatch("WIVCTMS");  // "victims" (horiz)

  total = W_ImageFromPatch("WIMSTT");
  star = W_ImageFromPatch("STFST01");  // your face

  bstar = W_ImageFromPatch("STFDEAD0");  // dead face

  for (i = 0; i &lt; 10; i++)
  {
    // numbers 0-9
    sprintf(name, "WINUM%d", i);
    digits[i] = W_ImageFromFont(name);
  }

  for (i = 0; i &lt; worldmap.numanims; i++)
  {
    for (j = 0; j &lt; worldmap.anims[i].numframes; j++)
    {
      L_WriteDebug("WI_LoadData: '%s'\n", worldmap.anims[i].frames[j].pic);

      worldmap.anims[i].frames[j].image = 
          W_ImageFromPatch(worldmap.anims[i].frames[j].pic);
    }
  }
}
</t>
<t tx="T165">
void WI_Drawer(void)
{
  int i;
  wi_anim_t *a;
  wi_frame_t *f;

  if (background_camera_mo)
  {
    R_Render();
  } 
  else
  {
    VCTX_Image(0, 0, SCREENWIDTH, SCREENHEIGHT, bg_image);
  }

  for (i = 0; i &lt; worldmap.numanims; i++)
  {
    a = &amp;worldmap.anims[i];

    if (a-&gt;frameon == -1)
      continue;

    f = NULL;

    if (a-&gt;type == WI_LEVEL)
    {
      if (!wbs-&gt;next)
        f = NULL;
      else if (!strcmp(wbs-&gt;next-&gt;ddf.name, a-&gt;level))
        f = &amp;a-&gt;frames[a-&gt;frameon];
    }
    else
      f = &amp;a-&gt;frames[a-&gt;frameon];

    if (f)
      VCTX_ImageEasy320(f-&gt;pos.x, f-&gt;pos.y, f-&gt;image);
  }

  switch (state)
  {
    case StatCount:
      if (deathmatch)
        DrawDeathmatchStats();
      else if (netgame)
        DrawNetgameStats();
      else
        DrawStats();
      break;

    case ShowNextLoc:
      DrawShowNextLoc();
      break;

    case NoState:
      DrawNoState();
      break;
  }
}
</t>
<t tx="T166">
static void InitVariables(wbstartstruct_t * wbstartstruct)
{
  int i;

  wbs = wbstartstruct;

  acceleratestage = false;
  cnt = bcnt = 0;
  firstrefresh = 1;
  me = wbs-&gt;pnum;
  plrs = wbs-&gt;plyr;

  if (!wbs-&gt;maxkills)
    wbs-&gt;maxkills = 1;

  if (!wbs-&gt;maxitems)
    wbs-&gt;maxitems = 1;

  if (!wbs-&gt;maxsecret)
    wbs-&gt;maxsecret = 1;

  WI_MapInit(DDF_GameLookup(wbs-&gt;last-&gt;episode_name));

  for (i = 0; i &lt; worldmap.numanims; i++)
  {
    worldmap.anims[i].count = 0;
    worldmap.anims[i].frameon = -1;
  }
}
</t>
<t tx="T167">
void WI_Start(wbstartstruct_t * wbstartstruct)
{
  player_t *p;

  InitVariables(wbstartstruct);
  LoadData();

  if (deathmatch)
    InitDeathmatchStats();
  else if (netgame)
    InitNetgameStats();
  else
    InitStats();

  // -AJA- 1999/10/22: background cameras.
  background_camera_mo = NULL;

  if (worldmap.bg_camera[0])
  {
    mobj_t *mo;

    for (mo = mobjlisthead; mo != NULL; mo = mo-&gt;next)
    {
      if (DDF_CompareName(mo-&gt;info-&gt;ddf.name, worldmap.bg_camera) == 0)
      {
        background_camera_mo = mo;
        R_ExecuteSetViewSize();

        // we don't want to see players
        for (p = players; p; p = p-&gt;next)
        {
          if (!p-&gt;mo)
            continue;
           
          p-&gt;mo-&gt;visibility = p-&gt;mo-&gt;vis_target = INVISIBLE;
        }

        break;
      }
    }
  }
}
</t>
<t tx="T168">@ignore
@language c

// Wipe Main

&lt;&lt; wp_main #includes &gt;&gt;
@others
</t>
<t tx="T169">#include "i_defs.h"
#include "wp_main.h"

#include "v_res.h"
#include "z_zone.h"
</t>
<t tx="T170">
wipeinfo_t *WIPE_CreateWipeInfo(void)
{
  wipeinfo_t *wi;
  wi = Z_ClearNew(wipeinfo_t, 1);
  return wi;
}
</t>
<t tx="T171">
void WIPE_DestroyWipeInfo(wipeinfo_t * wi)
{
  if (wi-&gt;parms.data &amp;&amp; wi-&gt;type-&gt;destroy_info)
    wi-&gt;type-&gt;destroy_info(&amp;wi-&gt;parms);

  Z_Free(wi);
}
</t>
<t tx="T172">
void WIPE_StopWipe(screen_t * dest, screen_t * start, screen_t * end, wipeinfo_t * wi)
{
#ifndef USE_GL
  if (wi-&gt;parms.data &amp;&amp; wi-&gt;type-&gt;destroy_info)
    wi-&gt;type-&gt;destroy_info(&amp;wi-&gt;parms);

  if (dest &amp;&amp; end &amp;&amp; dest-&gt;id == wi-&gt;dest.id &amp;&amp; end-&gt;id == wi-&gt;end.id &amp;&amp; wi-&gt;end.id != wi-&gt;dest.id)
  {
    // the dest and end screens are still valid.
    // Output the final screen.
    V_CopyScreen(wi-&gt;dest.scr, wi-&gt;end.scr);
  }

  V_DestroyScreen(wi-&gt;end.scr);
  V_DestroyScreen(wi-&gt;start.scr);
  V_DestroyScreen(wi-&gt;dest.scr);

  Z_Clear(wi, wipeinfo_t, 1);
#endif
}
</t>
<t tx="T173">@ internally used by InitWipe
@c

static void InitWipeScr(wipescr_t * ws, screen_t * scr, int x, int y, int width,
    int height, int isconst, int allow_sharing, screen_t * dest)
{
  boolean_t subscreen = true;

  ws-&gt;id = scr-&gt;id;

  // hack: dest is set to null when handling dest. Special case,
  // the wi-&gt;dest.scr will always be a subscreen.
  if (dest)
  {
    // if the screen intersects with the destination, and
    // we don't have the very special case where scr is exactly dest and
    // this is allowed, then we must use a shadow of the screen.
    if (V_ScreensIntersect(scr, dest) &amp;&amp; !(allow_sharing &amp;&amp; scr == dest &amp;&amp; !isconst))
    {
      subscreen = false;

      if (isconst)
      {
        ws-&gt;update_scr = false;
      }
      else
      {
        ws-&gt;update_scr = true;
        ws-&gt;update_x = x;
        ws-&gt;update_y = y;
      }
    }
    else
    {
      subscreen = true;
    }
  }

  if (subscreen)
  {
    ws-&gt;scr = V_CreateSubScreen(scr, x, y, width, height);
    ws-&gt;update_scr = false;
  }
  else
  {
    ws-&gt;scr = V_CreateScreen(width, height, scr-&gt;bytepp);
    if (!ws-&gt;update_scr)
      // if scr isn't updated each frame, it must be updated once now.
      V_CopyRect(ws-&gt;scr, scr, x, y, width, height, 0, 0);
  }
}
</t>
<t tx="T174">@ dest/start/end/x/y/width/height: positions of the wiping
cstart/cend: Tells whether start/end screens are constant.
duration tells the number of steps the effect should last, pass -1
to use the default.
wi is the wipeinfo that should be used for this effect. It can be a good
idea to recycle wipeinfos, and use a static variable for each place where
wiping can be used: if one wiping interrupts another one, the new one
will kill off the old one if the same wi is used (otherwise everything
will look very strange).
reverse tells whether the effect should be reversed.
effect shows which effect to use
@c

wipeinfo_t *WIPE_InitWipe(screen_t * dest, int destx, int desty,
    screen_t * start, int startx, int starty, int cstart,
    screen_t * end, int endx, int endy, int cend,
    int width, int height, wipeinfo_t * wi,
    int duration, boolean_t reversed, wipetype_e effect)
{
  if (!wi)
    wi = WIPE_CreateWipeInfo();
  if (wi-&gt;active)
    WIPE_StopWipe(dest, start, end, wi);

#ifndef USE_GL

  wi-&gt;active = true;
  wi-&gt;reversed = reversed;

  wi-&gt;type = &amp;wipes[effect];

  if (dest-&gt;bytepp != start-&gt;bytepp || dest-&gt;bytepp != end-&gt;bytepp)
    I_Error("WIPE_InitWipe: Screens have different BPP!");

  if (reversed)
  {
    InitWipeScr(&amp;wi-&gt;start, start, startx, starty, width, height, cstart, wi-&gt;type-&gt;allow_end_dest, dest);
    InitWipeScr(&amp;wi-&gt;end, end, endx, endy, width, height, cend, wi-&gt;type-&gt;allow_start_dest, dest);
    wi-&gt;parms.end = wi-&gt;start.scr;
    wi-&gt;parms.start = wi-&gt;end.scr;
  }
  else
  {
    InitWipeScr(&amp;wi-&gt;start, start, startx, starty, width, height, cstart, wi-&gt;type-&gt;allow_start_dest, dest);
    InitWipeScr(&amp;wi-&gt;end, end, endx, endy, width, height, cend, wi-&gt;type-&gt;allow_end_dest, dest);
    wi-&gt;parms.start = wi-&gt;start.scr;
    wi-&gt;parms.end = wi-&gt;end.scr;
  }

  InitWipeScr(&amp;wi-&gt;dest, dest, destx, desty, width, height, false, false, NULL);

  wi-&gt;width = wi-&gt;dest.scr-&gt;width;
  wi-&gt;height = wi-&gt;dest.scr-&gt;height;

  // NOTE: duration can depend on wi-&gt;height
  if (duration &lt; 0)
    duration = wi-&gt;type-&gt;def_duration(wi);
  
  wi-&gt;duration = duration;

  wi-&gt;parms.dest = wi-&gt;dest.scr;

  if (wi-&gt;type-&gt;init_info)
    wi-&gt;type-&gt;init_info(&amp;wi-&gt;parms);
#endif // USE_GL

  return wi;
}
</t>
<t tx="T175">
boolean_t WIPE_DoWipe(screen_t * dest, screen_t * start, screen_t * end,
    int progress, wipeinfo_t * wi)
{
#ifdef USE_GL
  return true;
#else
  
  // the wipe must be active
  if (!wi-&gt;active)
    return true;

  if (progress &lt; 0)
    progress = 0;

  // we kill the wiping if any of the screens has changed
  // or if the wiping it completed
  // 
  if (!dest || !start || !end || dest-&gt;id != wi-&gt;dest.id ||
      start-&gt;id != wi-&gt;start.id || end-&gt;id != wi-&gt;end.id ||
      progress &gt;= wi-&gt;duration)
  {
    WIPE_StopWipe(dest, start, end, wi);
    return true;
  }

  if (wi-&gt;reversed)
    wi-&gt;parms.progress = ((wi-&gt;duration - progress) - 0.5f) / wi-&gt;duration;
  else
    wi-&gt;parms.progress = (progress + 0.5f) / wi-&gt;duration;

  if (wi-&gt;start.update_scr)
    V_CopyRect(wi-&gt;start.scr, start, wi-&gt;start.update_x, wi-&gt;start.update_y,
        wi-&gt;width, wi-&gt;height, 0, 0);
  
  if (wi-&gt;end.update_scr)
    V_CopyRect(wi-&gt;end.scr, end, wi-&gt;end.update_x, wi-&gt;end.update_y,
        wi-&gt;width, wi-&gt;height, 0, 0);

  wi-&gt;type-&gt;do_wipe(&amp;wi-&gt;parms);

  return false;
#endif // USE_GL
}
</t>
<t tx="T176">@ignore
@language c

// Wipe Functions

&lt;&lt; wp_wipe #includes &gt;&gt;
@others

wipetype_t wipes[WIPE_NUMWIPES] =
{
  // None
  {1, 1, NULL, NULL, DefDuration_None, DoWipe_None},
  // Melt down
  {0, 1, InitData_Melt, DestroyData_ZFree, DefDuration_Melt, DoWipe_Melt},
  // Crossfade
  {1, 1, NULL, NULL, DefDuration_Fade, DoWipe_Crossfade},
  // Pixelfade
  {1, 1, NULL, NULL, DefDuration_Fade, DoWipe_Pixelfade},
  // scrolls in from top
  {1, 0, NULL, NULL, DefDuration_VScroll, DoWipe_Top},
  // scrolls in from bottom
  {1, 0, NULL, NULL, DefDuration_VScroll, DoWipe_Bottom},
  // scrolls in from left
  {1, 0, NULL, NULL, DefDuration_HScroll, DoWipe_Left},
  // scrolls in from right
  {1, 0, NULL, NULL, DefDuration_HScroll, DoWipe_Right},
  // scrolls in from all corners
  {1, 0, NULL, NULL, DefDuration_HScroll, DoWipe_Corners},
  // opening doors
  {0, 0, InitData_Doors, DestroyData_ZFree, DefDuration_Doors, DoWipe_Doors}
};

// for CVar enums
const char WIPE_EnumStr[] = "none/melt/crossfade/pixelfade/top/bottom/left/right/corners/doors";
</t>
<t tx="T177">#include "i_defs.h"

#include "dm_state.h"
#include "m_inline.h"
#include "m_random.h"
#include "v_res.h"
#include "v_colour.h"
#include "wp_main.h"
#include "z_zone.h"
</t>
<t tx="T178">
#ifndef NOHICOLOUR
// -ES- 1999/06/14 Unrolled loop and changed algorithm
static void DoWipe_Crossfade16(wipeparm_t * wp)
{
  unsigned long *d;
  unsigned long *e;
  unsigned long *s;

  int height = wp-&gt;dest-&gt;height;
  int width = wp-&gt;dest-&gt;width;
  int level = (int)(wp-&gt;progress * 64.0f + 0.5f);

  unsigned long (*s2rgb)[2], (*e2rgb)[2];
  unsigned long c1, c2;  // source colours

  unsigned long d1, d2;  // destination colours

  int y;
  int i;

  s2rgb = col2rgb16[64 - level];
  e2rgb = col2rgb16[level];

  for (y = 0; y &lt; height; y++)
  {
    d = (unsigned long *)(wp-&gt;dest-&gt;data + y * wp-&gt;dest-&gt;pitch + width * 2);
    e = (unsigned long *)(wp-&gt;end-&gt;data + y * wp-&gt;end-&gt;pitch + width * 2);
    s = (unsigned long *)(wp-&gt;start-&gt;data + y * wp-&gt;start-&gt;pitch + width * 2);

    for (i = (-width) &gt;&gt; 1; i &lt; 0; i++)
    {
      // -ES- 1998/11/29 Use the new algorithm
      c1 = s[i];
      c2 = e[i];

      d1 = s2rgb[(unsigned char)c1][0] +
          s2rgb[(unsigned char)(c1 &gt;&gt; 8)][1] +
          e2rgb[(unsigned char)c2][0] +
          e2rgb[(unsigned char)(c2 &gt;&gt; 8)][1];
      c1 &gt;&gt;= 16;
      c2 &gt;&gt;= 16;
      d2 = s2rgb[(unsigned char)c1][0] +
          s2rgb[(unsigned char)(c1 &gt;&gt; 8)][1] +
          e2rgb[(unsigned char)c2][0] +
          e2rgb[(unsigned char)(c2 &gt;&gt; 8)][1];
      d1 |= hicolourtransmask;
      d2 |= hicolourtransmask;

      d[i] = (d1 &amp; (d1 &gt;&gt; 16)) | (d2 &amp; (d2 &lt;&lt; 16));
    }
  }

}
</t>
<t tx="T179">#endif

// -ES- 1999/06/14 Changed col2rgb format
static void DoWipe_Crossfade8(wipeparm_t * wp)
{
  byte *d;
  byte *e;
  byte *s;
  int y;
  int i;
  int height = wp-&gt;dest-&gt;height;
  int width = wp-&gt;dest-&gt;width;
  int level = (int)(wp-&gt;progress * 64.0f + 0.5f);

  unsigned long *s2rgb, *e2rgb;
  unsigned long c;

  s2rgb = col2rgb8[64 - level];
  e2rgb = col2rgb8[level];

  for (y = 0; y &lt; height; y++)
  {
    d = wp-&gt;dest-&gt;data + y * wp-&gt;dest-&gt;pitch + width;
    e = wp-&gt;end-&gt;data + y * wp-&gt;end-&gt;pitch + width;
    s = wp-&gt;start-&gt;data + y * wp-&gt;start-&gt;pitch + width;
    for (i = -width; i &lt; 0; i++)
    {
      c = (s2rgb[s[i]] + e2rgb[e[i]]) | 0x07c1Fc1F;
      d[i] = rgb_32k[0][0][c &amp; (c &gt;&gt; 17)];
    }
  }
}
</t>
<t tx="T180">
static void DoWipe_Crossfade(wipeparm_t * wp)
{
#ifndef NOHICOLOUR
// FIXME: Move to v_res.c?
  if (BPP == 1)
    DoWipe_Crossfade8(wp);
  else
    DoWipe_Crossfade16(wp);
#else
  DoWipe_Crossfade8(wp);
#endif
}
</t>
<t tx="T181">
static void Wipe_Pixelfade8(byte * src, byte * dest, int offs, byte i, int w, int progress)
{
  int x;
  int offset[2];

  offset[0] = 0;
  offset[1] = offs;

  dest += w;
  src += w;
  for (x = -w; x &lt; 0; x++)
  {
    dest[x] = src[x + offset[(progress + rndtable[i++]) &gt;&gt; 8]];
  }
}
</t>
<t tx="T182">
static void Wipe_Pixelfade16(byte * src, byte * dest, int offs, byte i, int w, int progress)
{
  int x;
  int offset[2];
  
  offset[0] = 0;
  offset[1] = offs;

  dest += w * 2;
  src += w * 2;

  for (x = -w; x &lt; 0; x++)
  {
    *(short *)(dest + 2 * x) = *(short *)(src + 2 * x + offset[(progress + rndtable[i++]) &gt;&gt; 8]);
  }
}
</t>
<t tx="T183">
static void DoWipe_Pixelfade(wipeparm_t * wp)
{
  int y, progress;
  byte *src;
  byte *dest;
  int width = wp-&gt;dest-&gt;width;
  int dpitch = wp-&gt;dest-&gt;pitch;
  int spitch = wp-&gt;start-&gt;pitch;
  int epitch = wp-&gt;end-&gt;pitch;
  int offs;
  void (*fadefunc) (byte * src, byte * dest, int offs, byte i, int w, int progress);

#ifndef NOHICOLOUR
  fadefunc = BPP == 1 ? Wipe_Pixelfade8 : Wipe_Pixelfade16;
#else
  fadefunc = Wipe_Pixelfade8;
#endif

  progress = (int)(wp-&gt;progress * 256.0f);

  src = wp-&gt;start-&gt;data;
  offs = wp-&gt;end-&gt;data - src;
  dest = wp-&gt;dest-&gt;data;
  for (y = 0; y &lt; wp-&gt;dest-&gt;height; y++)
  {
    fadefunc(src, dest, offs, rndtable[(byte) y], width, progress);

    src += spitch;
    offs += epitch - spitch;
    dest += dpitch;
  }
}
</t>
<t tx="T184">
typedef struct
{
  float_t max;
  float_t yoffs[1];
}
meltdata_t;

/*
   Melting

   yoffs contains an array of randomised values, telling the relative y offset
   of each of the end columns.

   This copies two pixels at a time, and will thereby work in 16-bit modes too.
 */
static void DoWipe_Melt(wipeparm_t * wp)
{
  int y, h, x;
  meltdata_t *data = wp-&gt;data;
  float_t *yoffs;
  float_t extray;
  int bpp = wp-&gt;dest-&gt;bytepp;
  int width = wp-&gt;dest-&gt;width / 2 * bpp;
  int height = wp-&gt;dest-&gt;height;
  int skiprows;
  short *d;
  short *s;
  int dpitch = wp-&gt;dest-&gt;pitch / 2;
  int spitch = wp-&gt;start-&gt;pitch / 2;
  int epitch = wp-&gt;end-&gt;pitch / 2;

  yoffs = data-&gt;yoffs;

  extray = wp-&gt;progress * height + data-&gt;max;

  // optimisation: the top rectangle of end screen can be copied right away
  // (CopyRect is faster than the wipe inner loops)
  skiprows = (int)(extray - data-&gt;max);
  if (skiprows &lt;= 0)
    skiprows = 0;
  else
    V_CopyRect(wp-&gt;dest, wp-&gt;end, 0, 0, wp-&gt;dest-&gt;width, skiprows, 0, 0);

  for (x = 0; x &lt; width; x++)
  {
    h = (int)(extray - yoffs[x]);
    if (h &gt; height)
      h = height;

    d = ((short *)wp-&gt;dest-&gt;data + skiprows * dpitch) + x;
    s = ((short *)wp-&gt;end-&gt;data + skiprows * epitch) + x;
    for (y = skiprows; y &lt; h; y++)
    {
      *d = *s;
      d += dpitch;
      s += epitch;
    }
    s = ((short *)wp-&gt;start-&gt;data) + x;
    for (; y &lt; height; y++)
    {
      *d = *s;
      d += dpitch;
      s += spitch;
    }
  }
}
</t>
<t tx="T185">
static void InitData_Melt(wipeparm_t * wp)
{
  float_t *yoffs;
  int width = wp-&gt;dest-&gt;width / 2 * wp-&gt;dest-&gt;bytepp;
  meltdata_t *data;
  int x;
  float_t r;
  float_t max;
  float_t highest, lowest;
  float_t scale = (float_t)(((3.0f * 8.0f * 320.0f / 200.0f / 256.0f) / wp-&gt;dest-&gt;bytepp) * wp-&gt;dest-&gt;height / wp-&gt;dest-&gt;width);

  data = wp-&gt;data = (meltdata_t *) Z_Malloc(sizeof(meltdata_t) + (width - 1) * sizeof(float_t));

  yoffs = data-&gt;yoffs;
  max = (float_t)(wp-&gt;dest-&gt;height * (16.0f * 8.0f / 200.0f));

  // keep track of top and bottom of the array
  highest = 0;
  lowest = max;

  r = M_Random() * max / 256;

  for (x = 0; x &lt; width; x++)
  {
    r += (M_Random() - 128) * scale;
    if (r &gt; max)
      r = max;
    if (r &lt; 0)
      r = 0;

    if (r &gt; highest)
      highest = r;
    if (r &lt; lowest)
      lowest = r;

    yoffs[x] = r;
  }

  // clean up: the lowest one should be at zero
  for (x = 0; x &lt; width; x++)
  {
    yoffs[x] -= lowest;
  }

  data-&gt;max = highest - lowest;
}
</t>
<t tx="T186">
static void DestroyData_ZFree(wipeparm_t * wp)
{
  Z_Free(wp-&gt;data);
}
</t>
<t tx="T187">
static int DefDuration_Doors(wipeinfo_t * wi)
{
  return 35;
}
</t>
<t tx="T188">
static int DefDuration_Fade(wipeinfo_t * wi)
{
  return 35;
}
</t>
<t tx="T189">
static int DefDuration_Melt(wipeinfo_t * wi)
{
  // in original DOOM, screen melted down at a speed of 8 pixels per tic, so
  // in 320x200 the wiping took 200/8=25 tics.
  return 5 + 25 * wi-&gt;height / 200;
}
</t>
<t tx="T190">static int DefDuration_VScroll(wipeinfo_t * wi)
{
  return 35;
}
</t>
<t tx="T191">static int DefDuration_HScroll(wipeinfo_t * wi)
{
  return 35;
}
</t>
<t tx="T192">
static int DefDuration_None(wipeinfo_t * wi)
{
  return 0;
}
</t>
<t tx="T193">
static void DoWipe_Top(wipeparm_t * wp)
{
  int y, h;

  y = (int)(wp-&gt;progress * wp-&gt;dest-&gt;height);
  h = wp-&gt;dest-&gt;height - y;

  V_CopyRect(wp-&gt;dest, wp-&gt;end, 0, h, wp-&gt;end-&gt;width, y, 0, 0);
  // optimisation: the start screen might already be there
  if (wp-&gt;dest-&gt;data != wp-&gt;start-&gt;data)
    V_CopyRect(wp-&gt;dest, wp-&gt;start, 0, y, wp-&gt;end-&gt;width, h, 0, y);
}
</t>
<t tx="T194">static void DoWipe_Bottom(wipeparm_t * wp)
{
  int y, h;

  y = (int)(wp-&gt;progress * wp-&gt;dest-&gt;height);
  h = (int)(wp-&gt;dest-&gt;height - y);

  V_CopyRect(wp-&gt;dest, wp-&gt;end, 0, 0, wp-&gt;end-&gt;width, y, 0, h);
  // optimisation: the start screen might already be there
  if (wp-&gt;dest-&gt;data != wp-&gt;start-&gt;data)
    V_CopyRect(wp-&gt;dest, wp-&gt;start, 0, 0, wp-&gt;end-&gt;width, h, 0, 0);
}
</t>
<t tx="T195">
static void DoWipe_Left(wipeparm_t * wp)
{
  int x, w;

  x = (int)(wp-&gt;progress * wp-&gt;dest-&gt;width);
  w = (int)(wp-&gt;dest-&gt;width - x);

  V_CopyRect(wp-&gt;dest, wp-&gt;end, w, 0, x, wp-&gt;end-&gt;height, 0, 0);
  // optimisation: the start screen might already be there
  if (wp-&gt;dest-&gt;data != wp-&gt;start-&gt;data)
    V_CopyRect(wp-&gt;dest, wp-&gt;start, x, 0, w, wp-&gt;end-&gt;height, x, 0);
}
</t>
<t tx="T196">
static void DoWipe_Right(wipeparm_t * wp)
{
  int x, w;

  x = (int)(wp-&gt;progress * wp-&gt;dest-&gt;width);
  w = (int)(wp-&gt;dest-&gt;width - x);

  V_CopyRect(wp-&gt;dest, wp-&gt;end, 0, 0, x, wp-&gt;end-&gt;height, w, 0);
  // optimisation: the start screen might already be there
  if (wp-&gt;dest-&gt;data != wp-&gt;start-&gt;data)
    V_CopyRect(wp-&gt;dest, wp-&gt;start, 0, 0, w, wp-&gt;end-&gt;height, 0, 0);
}
</t>
<t tx="T197">
static void DoWipe_Corners(wipeparm_t * wp)
{
  int x, w, y, h;

  w = (int)(wp-&gt;progress * wp-&gt;dest-&gt;width / 2.0f);
  x = wp-&gt;dest-&gt;width;
  h = (int)(wp-&gt;progress * wp-&gt;dest-&gt;height / 2.0f);
  y = wp-&gt;dest-&gt;height;

  V_CopyRect(wp-&gt;dest, wp-&gt;end, x / 2 - w, y / 2 - h, w, h, 0, 0);
  V_CopyRect(wp-&gt;dest, wp-&gt;start, w, 0, x - 2 * w, h, w, 0);
  V_CopyRect(wp-&gt;dest, wp-&gt;end, x / 2, y / 2 - h, w, h, x - w, 0);

  V_CopyRect(wp-&gt;dest, wp-&gt;start, 0, h, x, y - 2 * h, 0, h);

  V_CopyRect(wp-&gt;dest, wp-&gt;end, x / 2 - w, y / 2, w, h, 0, y - h);
  V_CopyRect(wp-&gt;dest, wp-&gt;start, w, y - h, x - 2 * w, h, w, y - h);
  V_CopyRect(wp-&gt;dest, wp-&gt;end, x / 2, y / 2, w, h, x - w, y - h);
}
</t>
<t tx="T198">@ doordata is an array where index i contains start-&gt;pitch*i.
@c

typedef int *doordata_t;
static void InitData_Doors(wipeparm_t * wp)
{
  doordata_t data;
  int h = wp-&gt;start-&gt;height;
  int d = wp-&gt;start-&gt;pitch;
  int i;
  int v;

  data = Z_New(int, h);

  for (i = 0, v = 0; i &lt; h; i++, v += d)
    data[i] = v;

  wp-&gt;data = data;
}
</t>
<t tx="T199">
#ifndef NOHICOLOUR
static void DrawDoorCol16(screen_t * dest, int destx, screen_t * src, int srcx, int y, int h, fixed_t yscale, doordata_t yoffs)
{
  byte *d;
  byte *s;
  int i;
  int srcy;
  int dpitch = dest-&gt;pitch;

  d = dest-&gt;data + y * dpitch + destx * 2;
  s = src-&gt;data + srcx * 2;

  srcy = src-&gt;height * FRACUNIT / 2 - yscale * h / 2;  // + FRACUNIT/2;

  for (i = 0; i &lt; h; i++)
  {
    *(short *)d = *(short *)(s + yoffs[srcy &gt;&gt; FRACBITS]);
    srcy += yscale;
    d += dpitch;
  }
}
</t>
<t tx="T200">#endif
static void DrawDoorCol8(screen_t * dest, int destx, screen_t * src, int srcx, int y, int h, fixed_t yscale, doordata_t yoffs)
{
  byte *d;
  byte *s;
  int i;
  int srcy;
  int dpitch = dest-&gt;pitch;

  d = dest-&gt;data + y * dpitch + destx;
  s = src-&gt;data + srcx;

  srcy = src-&gt;height * FRACUNIT / 2 - yscale * h / 2;

  for (i = 0; i &lt; h; i++)
  {
    *d = s[yoffs[srcy &gt;&gt; FRACBITS]];
    srcy += yscale;
    d += dpitch;
  }
}
</t>
<t tx="T201">
static int GetDoorCol(int width, int x, fixed_t sinval, fixed_t cosval)
{
// distance to door is width: FOV=90
#define DOORDIST width
  fixed_t retval;

  // the *2 and +1)/2 rounds retval instead of truncating it
  retval = FixedDiv(2 * DOORDIST * x, (width - x) * sinval + DOORDIST * cosval);
  retval = (retval + 1) / 2;
  if (retval &gt; width)
    return -1;
  return retval;
}
</t>
<t tx="T202">
static fixed_t GetDoorScale(int width, int x, fixed_t sinval, fixed_t cosval)
{
  return FixedDiv(DOORDIST * cosval + width * sinval, DOORDIST * cosval + (width - x) * sinval);
#undef DOORDIST
}
</t>
<t tx="T203">
static void DoWipe_Doors(wipeparm_t * wp)
{
  int srcx, destx;
  fixed_t yscale;
  int width = wp-&gt;dest-&gt;width;
  int height = wp-&gt;dest-&gt;height;
  int h;
  angle_t angle;
  fixed_t sinval;
  fixed_t cosval;

  void (*DrawDoorCol) (screen_t * dest, int destx, screen_t * src, int srcx, int y, int h, fixed_t yscale, doordata_t yoffs);

#ifndef NOHICOLOUR
  DrawDoorCol = BPP == 1 ? DrawDoorCol8 : DrawDoorCol16;
#else
  DrawDoorCol = DrawDoorCol8;
#endif

  // optimise me
  V_CopyScreen(wp-&gt;dest, wp-&gt;start);

  // max angle is a bit lower than 135 degrees
  angle = (angle_t)((1.0f - wp-&gt;progress) * (ANG90 + ANG45 - ANG1));

  sinval = M_FloatToFixed(M_Sin(angle));
  cosval = M_FloatToFixed(M_Cos(angle));

  // left door
  for (destx = 0; destx &lt; width / 2; destx++)
  {
    srcx = GetDoorCol(width / 2, destx, sinval, cosval);
    if (srcx == -1)
      break;

    yscale = GetDoorScale(width / 2, destx, sinval, cosval);
    h = FixedDiv(height, yscale);

    DrawDoorCol(wp-&gt;dest, destx, wp-&gt;end, srcx, (height - h) / 2, h, yscale, wp-&gt;data);
  }
  // right door
  for (destx = 0; destx &lt; width / 2; destx++)
  {
    srcx = GetDoorCol(width / 2, destx, sinval, cosval);
    if (srcx == -1)
      break;

    yscale = GetDoorScale(width / 2, destx, sinval, cosval);
    h = FixedDiv(height, yscale);

    DrawDoorCol(wp-&gt;dest, width - destx - 1, wp-&gt;end, width - srcx - 1, (height - h) / 2, h, yscale, wp-&gt;data);
  }
}
</t>
<t tx="T204">
static void DoWipe_None(wipeparm_t * wp)
{
}
</t>
<t tx="T205">@ignore
@language c

// Zone Memory Allocation Code 

&lt;&lt; z_zone #includes &gt;&gt;
&lt;&lt; z_zone declarations &gt;&gt;
@others
</t>
<t tx="T206">#include "i_defs.h"
#include "z_zone.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "s_sound.h"
#include "w_wad.h"
#include "w_textur.h"
</t>
<t tx="T207">
static stack_array_t *stack_arrays = NULL;

static cache_flusher_f **cache_flushers = NULL;
static int num_flushers = 0;
</t>
<t tx="T208">@ Z_StrDup

Duplicates the string.
@c

char *Z_StrDup(const char *s)
{
  int size;
  char *ret;

  if (s == NULL)
    return NULL;

  size = strlen(s) + 1;

  ret = Z_New(char, size);

  Z_MoveData(ret, s, char, size);

  return ret;
}
</t>
<t tx="T209">@ Z_ClearStackArray

Deletes the contents of the growable array, but doesn't free it.
@c

void Z_ClearStackArray(stack_array_t *a)
{
  int i;
  void **p = *a-&gt;ptr;
  stack_array_t *prev;

#ifdef DEVELOPERS
  if (a-&gt;locked)
    I_Error("Z_ClearStackArray: Locked!");
#endif

  // kill all the elements
  if (a-&gt;alloc_bunch &gt; 0)
  {
    for (i = 0; i &lt; a-&gt;max; i += a-&gt;alloc_bunch)
    {
      Z_Free(p[i]);
    }
  }

  // kill the array itself
  Z_Free(p);

  // kill the pointer reference
  *a-&gt;ptr = NULL;
  // kill this ref too: A stack array is defined to be uninitialised iff
  // ptr is null.
  a-&gt;ptr = NULL;

  // unlink it from the list.
  if (a == stack_arrays)
    // special case if we were first in the list
    stack_arrays = a-&gt;next;
  else
  {
    // search for the element before a, and change its pointer
    for (prev = stack_arrays; prev-&gt;next != a; prev = prev-&gt;next)
      DEV_ASSERT(prev-&gt;next, ("Z_ClearStackArray: List is broken"));

    prev-&gt;next = a-&gt;next;
  }
}
</t>
<t tx="T210">@ Z_DeleteStackArray

Kills &amp; frees a growable array
@c

void Z_DeleteStackArray(stack_array_t *a)
{
  Z_ClearStackArray(a);
  Z_Free(a);
}
</t>
<t tx="T211">@ If you for some reason must set a pointer directly to the address of
one of the elements of *ptr, you must first lock the array. This means
that it won't be flushed by the cache code, and that it can't
increase its size, so *ptr will never need to be reallocated.
You must remember to unlock the stack array, otherwise the next
Z_SetArraySize will probably fail.
@c

void Z_LockStackArray(stack_array_t *a)
{
  a-&gt;locked++;
}
</t>
<t tx="T212">
void Z_UnlockStackArray(stack_array_t *a)
{
#ifdef DEVELOPERS
  if (a-&gt;locked == 0)
    I_Error("Z_UnlockStackArray: Already unlocked!");
#endif
  a-&gt;locked--;
}
</t>
<t tx="T213">@ Z_InitStackArray

Initialises the growable array.
A growable array is a type that can be used for dynamic arrays, whose sizes
will vary. With a single function call, you will be able to tell how much
of the array you need, and it will see that there are that many elements,
without moving any of the existing elements (and thereby spoiling any
pointers to them). It will also reduce the number of memory allocation
calls and memory blocks.

ptr    : Points to the array pointer.
elem_size : The size of each element.
alloc_bunch: Number of elements to allocate at a time. 0 for default value.
@c

void Z_InitStackArray(stack_array_t *a, void ***ptr, int elem_size, int alloc_bunch)
{
  // a-&gt;ptr must always be set to NULL. The point is that it is possible
  // to do this kind of checks.
  DEV_ASSERT(a-&gt;ptr == NULL, ("Z_InitStackArray: Array already initialised"));

  a-&gt;elem_size = elem_size;

  if (alloc_bunch == 0)
  {
    // Assuming that about 16 bytes are wasted in some way per allocated
    // block, the default is to let no more than 1/16 of the memory be wasted
    // in that way.
    alloc_bunch = 1 + 16 * 16 / elem_size;
  }

  a-&gt;alloc_bunch = alloc_bunch;

  a-&gt;ptr = ptr;
  *ptr = NULL;
  // these will be initialised later.
  a-&gt;num = a-&gt;max = 0;
  a-&gt;locked = 0;

  // insert array into the head of the list.
  a-&gt;next = stack_arrays;
  stack_arrays = a;
}
</t>
<t tx="T214">@ Z_CreateStackArray

Allocates and initialises a growable array.
@c

stack_array_t *Z_CreateStackArray(void ***ptr, int elem_size, int alloc_bunch)
{
  stack_array_t *a;

  a = Z_New(stack_array_t, 1);
  a-&gt;ptr = NULL;
  Z_InitStackArray(a, ptr, elem_size, alloc_bunch);
  return a;
}
</t>
<t tx="T215">@ Does the actual array reallocations.
@c

static void SetActualArraySize(stack_array_t *a, int num)
{
  int newmax;
  int i;
  byte *elem;

#ifdef DEVELOPERS
  if (a-&gt;locked)
    I_Error("SetActualArraySize: Locked!");
#endif

  // alloc_bunch &lt; 0 means that it is an array of elements, not
  // an array of element pointers. The array will grow -alloc_bunch
  // elements at a time.
  if (a-&gt;alloc_bunch &lt; 0)
  {
    *a-&gt;ptr = Z_ReMalloc(*a-&gt;ptr, a-&gt;elem_size * num);
    a-&gt;max = num;
  }
  else
  {
    newmax = num + a-&gt;alloc_bunch - 1;
    newmax -= newmax % a-&gt;alloc_bunch;
    // if we are shrinking the array, just free the unneeded blocks.
    while (num &lt;= a-&gt;max - a-&gt;alloc_bunch)
    {
      a-&gt;max -= a-&gt;alloc_bunch;
      Z_Free((*a-&gt;ptr)[a-&gt;max]);
    }
    Z_Resize(*a-&gt;ptr, void *, newmax);
    // allocate one bunch at a time, and init elements.
    while (num &gt; a-&gt;max)
    {
      elem = (byte *) Z_Malloc(a-&gt;alloc_bunch * a-&gt;elem_size);

      for (i = 0; i &lt; a-&gt;alloc_bunch; i++, elem += a-&gt;elem_size)
        (*a-&gt;ptr)[a-&gt;max+i] = elem;

      a-&gt;max += a-&gt;alloc_bunch;
    }
#ifdef DEVELOPERS
    // should never happen...
    if (newmax != a-&gt;max)
      I_Error("Z_SetArraySize: Internal Error");
#endif
  }
}
</t>
<t tx="T216">@ Z_SetArraySize

Sets the number of used elements in a to num, allocating extra space if
needed.
@c

void Z_SetArraySize(stack_array_t *a, int num)
{
#ifdef DEVELOPERS
  if (a-&gt;locked &amp;&amp; num &gt; a-&gt;num)
    I_Error("Z_SetArraySize: Locked!");
#endif
  // we are done if the new size is below the maximum.
  if (num &gt; a-&gt;max)
  {
    if (a-&gt;alloc_bunch &lt; 0)
      // allocate some extra elements
      SetActualArraySize(a, num - a-&gt;alloc_bunch);
    else
      // extra allocation will be done automatically
      SetActualArraySize(a, num);
  }
  a-&gt;num = num;
}
</t>
<t tx="T217">@ Frees all unused elements of the arrays.
@c

static void FlushStackArrays(z_urgency_e urge)
{
  stack_array_t *a;

  for (a = stack_arrays; a; a = a-&gt;next)
  {
    if (!a-&gt;locked)
      SetActualArraySize(a, a-&gt;num);
  }
}
</t>
<t tx="T218">
#ifdef DEVELOPERS
typedef struct mallocheader_s
{
  int size;
} mallocheader_t;

#define CHECK_PTR(h) DEV_ASSERT((*(int *)((char *)(h) + (h)-&gt;size + sizeof(mallocheader_t)) == ZONEID), ("Block without ZONEID"))
#endif

//
// Z_Free
//
void Z_Free(void *ptr)
{
  // -ES- FIXME: Decide whether we should allow Z_Free(NULL) and Z_Malloc(0)
  if (ptr == NULL)
    return;
#ifdef DEVELOPERS
  {
    mallocheader_t *h = (mallocheader_t *)ptr - 1;
    CHECK_PTR(h);
#ifdef INTOLERANT_MATH
    // -ES- 2000/04/08 Trash all data.
    memset(h, -1, h-&gt;size + sizeof(mallocheader_t) + sizeof(int));
#endif
    free(h);
  }
#else
  free(ptr);
#endif
}
</t>
<t tx="T219">@ Z_RegisterCacheFlusher

Tells the memory system that f can be called to free up some memory.
@c

void Z_RegisterCacheFlusher(cache_flusher_f *f)
{
  Z_Resize(cache_flushers, cache_flusher_f *, num_flushers + 1);
  cache_flushers[num_flushers] = f;
  num_flushers++;
}
</t>
<t tx="T220">@ FlushCaches

Calls other parts of the code to trim any "cached" data, like
unused structures stored on an quick-alloc list. It gets called
when the zone cannot fulfill a ZMalloc request, in the hope that
after flushing the memory will be available.

`urge' is one of the Z_Urgency* values, and the more urgent the
request is, the harder that the cache flushing code should try to
free memory. For example, sprites &amp; textures can be reconstructed
(albeit slowly) from info in the WAD file(s), and in the worst case
scenario (urge == Z_UrgencyExtreme) the memory could be freed.

-AJA- 1999/09/16: written.
-ES- 1999/12/18 Written.
@c

static void FlushCaches(z_urgency_e urge, int size)
{
  int i;

  // Call all cache flusher at the current urgency level
  for (i = 0; i &lt; num_flushers; i++)
    (*cache_flushers[i])(urge);

#ifdef DEVELOPERS
  {
    // Output flush count.
    static int count = 0;
    L_WriteDebug("Flush %d", count++);
  }
#endif
}
</t>
<t tx="T221">@ Z_Calloc

Just allocates memory and clears it.
@c

void *Z_Calloc2(int size)
{
  byte *data = (byte *) Z_Malloc(size);
  Z_Clear(data, byte, size);
  return (void *) data;
}
</t>
<t tx="T222">@ Z_ReMalloc

Zone reallocation.
@c

void *Z_ReMalloc2(void *ptr, int size)
{
#if defined INTOLERANT_MATH &amp;&amp; defined DEVELOPERS
  // The intolerant remalloc will always trash the old memory block with -1:s,
  // and also trash anything undefined in the new block.
  void *newp;
  mallocheader_t *h;

  if (size == 0)
  {
    if (ptr)
      Z_Free(ptr);
    return NULL;
  }
  
  if (ptr == NULL)
    return Z_Malloc(size);

  // All trashing of undefined data will be done by Z_Malloc/Z_Free.
  newp = Z_Malloc(size);
  h = (mallocheader_t *)ptr - 1;
  CHECK_PTR(h);
  I_MoveData(newp, ptr, MIN(size, h-&gt;size));
  Z_Free(ptr);
  
  return newp;
#else

#ifdef DEVELOPERS
  mallocheader_t *h, *newp;
#else
  void *h, *newp;
#endif
  int allocsize;
  z_urgency_e flush_urge = 0;

  if (size == 0)
  {
    if (ptr)
      Z_Free(ptr);

    return NULL;
  }

#ifdef DEVELOPERS
  if (ptr == NULL)
  {
    h = NULL;
  }
  else
  {
    h = (mallocheader_t *)ptr - 1;
    CHECK_PTR(h);
  }
  allocsize = size + sizeof(mallocheader_t) + sizeof(int);
#else
  h = ptr;
  allocsize = size;
#endif

  while (NULL == (newp = realloc(h, allocsize)))
  {
    if (flush_urge == Z_UrgencyExtreme)
      I_Error("Z_ReMalloc: failed on allocation of %i bytes", size);
    flush_urge++;
    FlushCaches(flush_urge, allocsize);
  }

#ifdef DEVELOPERS
  newp-&gt;size = size;
  newp++;
  *(int *)((char *)newp + size) = ZONEID;
#endif
  return newp;
#endif
}
</t>
<t tx="T223">@ Z_Malloc

Zone allocation.
@c

void *Z_Malloc2(int size)
{
#ifdef DEVELOPERS
  mallocheader_t *p;
#else
  void *p;
#endif
  int allocsize;
  z_urgency_e flush_urge = 0;

  if (size == 0)
    return NULL;

#ifdef DEVELOPERS
  allocsize = sizeof(mallocheader_t) + size + sizeof(int);
#else
  allocsize = size;
#endif

  while (NULL == (p = malloc(allocsize)))
  {
    if (flush_urge == Z_UrgencyExtreme)
      I_Error("Z_Malloc: failed on allocation of %i bytes", size);
    flush_urge++;
    FlushCaches(flush_urge, allocsize);
  }
#ifdef DEVELOPERS
  p-&gt;size = size;
  p++;
  *(int *)((char *)p + size) = ZONEID;
#ifdef INTOLERANT_MATH
  // -ES- 2000/03/28 Will turn all floats into -NaN, making uninitialised
  // elements easier to find.
  memset(p, -1, size);
#endif
#endif
  return p;
}
</t>
<t tx="T224">
#ifdef LEAK_HUNT
//
// Z_RegisterMalloc
//
// Registers the allocater of Z_Malloced memory
void *Z_RegisterMalloc(void *ptr, const char *file, int line)
{
  memblock_t *b = ptr;

  b[-1].file = file;
  b[-1].line = line;
  return ptr;
}
</t>
<t tx="T225">@ Z_UnRegisterTmpFree
@c

void *Z_UnRegisterTmpMalloc(void *ptr, const char *function)
{
  memblock_t *b = ptr;

  if (function != b[-1].file)
    I_Error("I_TmpFree: Allocation from %s (line %d) freed in %s!", b[-1].file, b[-1].line, function);

  return ptr;
}
</t>
<t tx="T226">

typedef struct
{
  const char *file;
  int line;
  int count;
}
leak_info_item;

//
// Z_DumpLeakInfo
//
// Scans through &amp; analyses all the memory blocks.
// This routine uses malloc to allocate mem, to avoid trouble. Therefore, the
// heapsize must be slightly smaller than maximum.

void Z_DumpLeakInfo(int level)
{
  int i,j;
  int numblocks = 0;
  int pos;
  memblock_t *block;
  leak_info_item *list = NULL;
  int listsize = 0;
  boolean_t done;
  FILE *f;

  f = fopen("leakinfo", "wt");
  if (!f)
    I_Error("Z_DumpLeakInfo: Couldn't open file!");

  for (block = mainzone-&gt;blocklist.next; block != &amp;mainzone-&gt;blocklist; block = block-&gt;next)
  {
    if (block-&gt;user == 0)
      continue;
    if (level != -1 &amp;&amp; block-&gt;tag &gt;= level)
      continue;

    done = false;
    for (i = 0; i &lt; numblocks; i++)
    {
      // we can actually compare the string pointers directly here.
      if (list[i].file == block-&gt;file &amp;&amp; list[i].line == block-&gt;line)
      {
        list[i].count++;
        done = true;
        break;
      }
    }

    if (done)
      continue;

    numblocks++;
    if (numblocks &gt; listsize)
    {
      listsize += 64;
      list = realloc(list, listsize * sizeof(leak_info_item));
      if (list == NULL)
        I_Error("Z_DumpLeakInfo: Out of memory!\n");
    }

    list[numblocks - 1].file = block-&gt;file;
    list[numblocks - 1].line = block-&gt;line;
    list[numblocks - 1].count = 0;
  }

  // ignore all calls that only alloced 1 block.
  pos = 0;
  for (i = 0; i &lt; numblocks; i++)
  {
    if (list[i].count)
    {
      list[pos] = list[i];
      pos++;
    }
  }
  numblocks = pos;

  for (i = 0; i &lt; numblocks; i++)
  {
    fprintf(f, "%3d %s:%d\n", list[i].count+1, list[i].file, list[i].line);
  }

  numblocks = 0;
  // Save the memory usage of each malloc call
  for (block = mainzone-&gt;blocklist.next; block != &amp;mainzone-&gt;blocklist; block = block-&gt;next)
  {
    if (block-&gt;user == 0)
      continue;
    if (level != -1 &amp;&amp; block-&gt;tag &gt;= level)
      continue;

    done = false;
    for (i = 0; i &lt; numblocks; i++)
    {
      // we can actually compare the string pointers directly here.
      if (list[i].file == block-&gt;file &amp;&amp; list[i].line == block-&gt;line)
      {
        list[i].count += block-&gt;size;
        done = true;
        break;
      }
    }

    if (done)
      continue;

    numblocks++;
    if (numblocks &gt; listsize)
    {
      listsize += 64;
      list = realloc(list, listsize * sizeof(leak_info_item));
      if (list == NULL)
        I_Error("Z_DumpLeakInfo: Out of memory!\n");
    }

    list[numblocks - 1].file = block-&gt;file;
    list[numblocks - 1].line = block-&gt;line;
    list[numblocks - 1].count = block-&gt;size;
  }

  // output from one source file at a time.
  fprintf(f, "\nMem usage:\n");
  for (i = 0; i &lt; numblocks; i++)
  {
    if (list[i].count)
    {
      j = 0;
      fprintf(f, "%s:\n", list[i].file);
      for (pos = i; pos &lt; numblocks; pos++)
      {
        if (list[i].file == list[pos].file)
        {
          j += list[pos].count;
          fprintf(f, " %d: %d\n", list[pos].line, list[pos].count);
          list[pos].count = 0;
        }
      }
      fprintf(f, "%s total: %d bytes\n\n", list[i].file, j);
    }
  }

  fclose(f);
  free(list);
}
</t>
<t tx="T227">#endif

//
// Z_CheckHeap
//
void Z_CheckHeap(void)
{
}
</t>
<t tx="T228">@ Z_UsedMemory

Shows how much memory that is allocated (malloc headers not included).
If level is non-negative, any tags with tag&gt;=level are treated as unused.
@c

int Z_UsedMemory(int level)
{
  return W_CacheInfo(level);
}
</t>
<t tx="T229">@ Z_FreeMemory

Shows the amount of free memory.
If level is non-negative, any tags with tag&gt;=level are treated as free.
@c

int Z_FreeMemory(int level)
{
  return 0;
}
</t>
<t tx="T230">@ Z_Init
@c

void Z_Init(void)
{
  // Register stack array flusher. That system doesn't need any
  // initialisation first.
  Z_RegisterCacheFlusher(FlushStackArrays);
}
</t>
<t tx="T231">@ Z_CheckIfZero

Return true if the memory is completely clear.
@c

boolean_t Z_CheckIfZero(const byte *ptr, int size)
{
  for (; size &gt; 0; size--, ptr++)
    if (*ptr)
      return false;
 
  return true;
}
</t>
<t tx="T233">@ignore
@language c

// OpenGL Rendering (Wipes)

// this conditional applies to the whole file
#ifdef USE_GL

&lt;&lt; rgl_wipe #includes &gt;&gt;
&lt;&lt; rgl_wipe declarations &gt;&gt;
@others

#endif  // USE_GL
</t>
<t tx="T234">#include "i_defs.h"

#include "m_random.h"
#include "r2_defs.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "v_res.h"
#include "w_image.h"
#include "w_wad.h"
#include "wp_main.h"
#include "z_zone.h"
</t>
<t tx="T235">

// we're limited to one wipe at a time...
static int cur_wipe_reverse = 0;
static int cur_wipe_effect  = WIPE_None;
static int cur_wipe_start;

static GLuint cur_wipe_tex  = 0;

#define MELT_DIVS  128
static int melt_yoffs[MELT_DIVS+1];
static int melt_last_progress;
</t>
<t tx="T236">

static GLuint SendWipeTexture(byte *rgb_src, int total_w, int total_h)
{
  GLuint id;
  
  DEV_ASSERT2(0 &lt; total_w &amp;&amp; total_w &lt;= glmax_tex_size);
  DEV_ASSERT2(0 &lt; total_h &amp;&amp; total_h &lt;= glmax_tex_size);

  glEnable(GL_TEXTURE_2D);

  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

  glGenTextures(1, &amp;id);
  glBindTexture(GL_TEXTURE_2D, id);

  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

  glTexImage2D(GL_TEXTURE_2D, 0, 3, total_w, total_h,
               0, GL_RGB, GL_UNSIGNED_BYTE, rgb_src);
    
  glDisable(GL_TEXTURE_2D);

  return id;
}
</t>
<t tx="T237">
static GLuint CaptureScreenAsTexture(void)
{
  int total_w, total_h;
  int x, y, id;

  byte *pixels;
  byte *line_buf;

  total_w = W_MakeValidSize(SCREENWIDTH);
  total_h = W_MakeValidSize(SCREENHEIGHT);

  while (total_w &gt; glmax_tex_size)
    total_w /= 2;

  while (total_h &gt; glmax_tex_size)
    total_h /= 2;

  pixels = Z_New(byte, total_w * total_h * 3);

  line_buf = Z_New(byte, SCREENWIDTH * 3);

  // read pixels from screen, scaling down to target size which must
  // be both power-of-two and within the GL's tex_size limitation.

  glReadBuffer(GL_FRONT);
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
  
  for (y=0; y &lt; total_h; y++)
  {
    int px;
    int py = y * SCREENHEIGHT / total_h;

    glReadPixels(0, py, SCREENWIDTH, 1, GL_RGB, GL_UNSIGNED_BYTE, line_buf);

    for (x=0; x &lt; total_w; x++)
    {
      byte *dest_p = pixels + ((y * total_w + x) * 3);
      
      px = x * SCREENWIDTH / total_w;

      dest_p[0] = line_buf[px*3 + 0];
      dest_p[1] = line_buf[px*3 + 1];
      dest_p[2] = line_buf[px*3 + 2];
    }
  }

  id = SendWipeTexture(pixels, total_w, total_h);
   
  Z_Free(line_buf);
  Z_Free(pixels);

  return id;
}
</t>
<t tx="T238">
static void RGL_Init_Melt(void)
{
  int x, r;

  melt_last_progress = 0;

  melt_yoffs[0] = - (M_Random() % 16);

  for (x=1; x &lt;= MELT_DIVS; x++)
  {
    r = (M_Random() % 3) - 1;

    melt_yoffs[x] = melt_yoffs[x-1] + r;
    melt_yoffs[x] = MAX(-15, MIN(0, melt_yoffs[x]));
  }
}
</t>
<t tx="T239">
static void RGL_Update_Melt(int tics)
{
  int x, r;

  for (; tics &gt; 0; tics--)
  {
    for (x=0; x &lt;= MELT_DIVS; x++)
    {
      r = melt_yoffs[x];

      if (r &lt; 0)
        r = 1;
      else if (r &gt; 15)
        r = 8;
      else
        r += 1;

      melt_yoffs[x] += r;
    }
  }
}
</t>
<t tx="T240">@ RGL_InitWipe
@c

void RGL_InitWipe(int reverse, int effect)
{
  cur_wipe_reverse = reverse;
  cur_wipe_effect  = effect;

  cur_wipe_start = -1;
  cur_wipe_tex = CaptureScreenAsTexture();

  RGL_Init_Melt();
}
</t>
<t tx="T241">@ RGL_StopWipe
@c

void RGL_StopWipe(void)
{
  cur_wipe_effect = WIPE_None;

  if (cur_wipe_tex != 0)
  {
    glDeleteTextures(1, &amp;cur_wipe_tex);
  }
}
</t>
<t tx="T242">@ ----------------------------------------------------------------------------
@c

static void RGL_Wipe_Fading(float_t how_far)
{
  glEnable(GL_TEXTURE_2D);
  glEnable(GL_BLEND);

  glBindTexture(GL_TEXTURE_2D, cur_wipe_tex);
  glColor4f(1.0, 1.0, 1.0, 1.0 - how_far);
  
  glBegin(GL_QUADS);

  glTexCoord2f(0.0, 0.0);
  glVertex2i(0, 0);

  glTexCoord2f(0.0, 1.0);
  glVertex2i(0, SCREENHEIGHT);

  glTexCoord2f(1.0, 1.0);
  glVertex2i(SCREENWIDTH, SCREENHEIGHT);

  glTexCoord2f(1.0, 0.0);
  glVertex2i(SCREENWIDTH, 0);

  glEnd();

  glDisable(GL_BLEND);
  glDisable(GL_TEXTURE_2D);
}
</t>
<t tx="T243">
static void RGL_Wipe_Melt(void)
{
  int x;

  glEnable(GL_TEXTURE_2D);
  glEnable(GL_BLEND);

  glBindTexture(GL_TEXTURE_2D, cur_wipe_tex);
  glColor3f(1.0, 1.0, 1.0);
  
  glBegin(GL_QUAD_STRIP);

  for (x=0; x &lt;= MELT_DIVS; x++)
  {
    int yoffs = MAX(0, melt_yoffs[x]);

    float_t tx = (float_t) x / MELT_DIVS;
    float_t sx = (float_t) x * SCREENWIDTH / MELT_DIVS;
    float_t sy = (float_t) (200 - yoffs) * SCREENHEIGHT / 200.0;
    
    glTexCoord2f(tx, 1.0);
    glVertex2f(sx, sy);

    glTexCoord2f(tx, 0.0);
    glVertex2f(sx, sy - SCREENHEIGHT);
  }

  glEnd();

  glDisable(GL_BLEND);
  glDisable(GL_TEXTURE_2D);
}
</t>
<t tx="T244">
static void RGL_Wipe_Slide(float_t how_far, float_t dx, float_t dy)
{
  dx *= how_far;
  dy *= how_far;

  glEnable(GL_TEXTURE_2D);
  glEnable(GL_BLEND);

  glBindTexture(GL_TEXTURE_2D, cur_wipe_tex);
  glColor3f(1.0, 1.0, 1.0);
  
  glBegin(GL_QUADS);

  glTexCoord2f(0.0, 0.0);
  glVertex2f(dx, dy);

  glTexCoord2f(0.0, 1.0);
  glVertex2f(dx, dy + SCREENHEIGHT);

  glTexCoord2f(1.0, 1.0);
  glVertex2f(dx + SCREENWIDTH, dy + SCREENHEIGHT);

  glTexCoord2f(1.0, 0.0);
  glVertex2f(dx + SCREENWIDTH, dy);

  glEnd();

  glDisable(GL_BLEND);
  glDisable(GL_TEXTURE_2D);
}
</t>
<t tx="T245">
static void RGL_Wipe_Doors(float_t how_far)
{
  float_t dx = cos(how_far * M_PI / 2) * (SCREENWIDTH/2);
  float_t dy = sin(how_far * M_PI / 2) * (SCREENHEIGHT/3);
   
  glEnable(GL_TEXTURE_2D);
  glEnable(GL_BLEND);

  glBindTexture(GL_TEXTURE_2D, cur_wipe_tex);
  glColor3f(1.0, 1.0, 1.0);
  
  // left side
  glBegin(GL_QUADS);

    glTexCoord2f(0.0, 0.0);
    glVertex2f(0, 0);

    glTexCoord2f(0.0, 1.0);
    glVertex2f(0, SCREENHEIGHT);

    glTexCoord2f(0.5, 1.0);
    glVertex2f(dx, SCREENHEIGHT - dy);

    glTexCoord2f(0.5, 0.0);
    glVertex2f(dx, dy);

  glEnd();

  // right side
  glBegin(GL_QUADS);

    glTexCoord2f(0.5, 0.0);
    glVertex2f(SCREENWIDTH - dx, dy);

    glTexCoord2f(0.5, 1.0);
    glVertex2f(SCREENWIDTH - dx, SCREENHEIGHT - dy);

    glTexCoord2f(1.0, 1.0);
    glVertex2f(SCREENWIDTH, SCREENHEIGHT);

    glTexCoord2f(1.0, 0.0);
    glVertex2f(SCREENWIDTH, 0);

  glEnd();

  glDisable(GL_BLEND);
  glDisable(GL_TEXTURE_2D);
}
</t>
<t tx="T246">@ RGL_DoWipe

NOTE: we assume 2D project matrix is already setup.
@c

boolean_t RGL_DoWipe(void)
{
  int progress;
  float_t how_far;
  
  if (cur_wipe_effect == WIPE_None || cur_wipe_tex == 0)
    return true;

  // determine how many tics since we started.  If this is the first
  // call to DoWipe() since InitWipe(), then the clock starts now.
  // 
  progress = I_GetTime();

  if (cur_wipe_start &lt; 0)
    cur_wipe_start = progress;

  progress = MAX(0, progress - cur_wipe_start);

  if (progress &gt; 40)
    return true;

  how_far = (float_t) progress / 40.0;

  switch (cur_wipe_effect)
  {
    case WIPE_Melt:
      RGL_Wipe_Melt();
      RGL_Update_Melt(progress - melt_last_progress);
      melt_last_progress = progress;
      break;

    case WIPE_Top:
      RGL_Wipe_Slide(how_far, 0, +SCREENHEIGHT);
      break;

    case WIPE_Bottom:
      RGL_Wipe_Slide(how_far, 0, -SCREENHEIGHT);
      break;

    case WIPE_Left:
      RGL_Wipe_Slide(how_far, -SCREENWIDTH, 0);
      break;

    case WIPE_Corners:  // Fixme
    case WIPE_Right:
      RGL_Wipe_Slide(how_far, +SCREENWIDTH, 0);
      break;

    case WIPE_Doors:
      RGL_Wipe_Doors(how_far);
      break;

    case WIPE_Crossfade:
    case WIPE_Pixelfade:
    default:
      RGL_Wipe_Fading(how_far);
      break;
  }

  return false;
}
</t>
<t tx="T247">@ignore
@language c

// Music handling Code

// -ACB- 1999/11/13 Written

&lt;&lt; s_music #includes &gt;&gt;
&lt;&lt; s_music declarations &gt;&gt;
@others
</t>
<t tx="T248">#include "i_defs.h"
#include "ddf_main.h"
#include "m_misc.h"
#include "s_sound.h"
#include "w_wad.h"
</t>
<t tx="T249">
// Current music handle
static int musichandle = -1;
static int musicvolume;

boolean_t nomusic = false;
</t>
<t tx="T250">@ =================== INTERNALS ====================
HELPER Functions
@c

static INLINE int edgemin(int a, int b)
{
  return (a &lt; b) ? a : b;
}
</t>
<t tx="T251">
static INLINE int edgemax(int a, int b)
{
  return (a &gt; b) ? a : b;
}
</t>
<t tx="T252">
static INLINE int edgemid(int a, int b, int c)
{
  return edgemax(a, edgemin(b, c));
}
</t>
<t tx="T253">@ ================ END OF INTERNALS =================

S_ChangeMusic
@c

void S_ChangeMusic(int entrynum, boolean_t looping)
{
  const playlist_t *play;
  byte *data;
  int datlength;
  int datnum;
  i_music_info_t musdat;

  if (nomusic)
    return;

  // -AJA- playlist number 0 reserved to mean "no music"
  if (entrynum &lt;= 0)
  {
    S_StopMusic();
    return;
  }
  
  play = DDF_MusicLookupNum(entrynum);

  if (!play)
    return;

  S_StopMusic();

  // Exception one...
  if (play-&gt;type == MUS_MP3)
  {
    if (play-&gt;infotype != MUSINF_FILE)
    {
      I_Warning("S_ChangeMusic: MP3's only in file format\n");
      return;
    } 

    musdat.format = IMUSF_FILE;
    musdat.info.file.name = (char*) play-&gt;info;

    musichandle = I_MusicPlayback(&amp;musdat, play-&gt;type, looping);
    if (musichandle != -1)
      I_SetMusicVolume(&amp;musichandle, musicvolume);

/*
    musichandle = I_MusicPlayback((void*)play-&gt;info, 0, play-&gt;type, looping);
    if (musichandle != -1)
      I_SetMusicVolume(&amp;musichandle, musicvolume);
*/

    return;
  }

  // -ACB- 2000/06/06 This is not system specific
  if (play-&gt;infotype == MUSINF_FILE)
  {
    data = M_GetFileData(play-&gt;info, &amp;datlength);
    if (!data)
    {
      I_Warning("S_ChangeMusic: Can't Load File '%s'\n", play-&gt;info);
      return;
    }

    musdat.format = IMUSF_DATA;
    musdat.info.data.ptr = data;
    musdat.info.data.size = datlength;

    musichandle = I_MusicPlayback(&amp;musdat, play-&gt;type, looping);

/*
    musichandle = I_MusicPlayback((void*)data, datlength, play-&gt;type, looping);
*/

    Z_Free(data);
  }

  if (play-&gt;infotype == MUSINF_LUMP)
  {
    datnum = W_CheckNumForName(play-&gt;info);
    if (datnum != -1)
    {
      datlength = W_LumpLength(datnum);
      data = (byte*)W_CacheLumpName(play-&gt;info);

      musdat.format = IMUSF_DATA;
      musdat.info.data.ptr = data;
      musdat.info.data.size = datlength;

      musichandle = I_MusicPlayback(&amp;musdat, play-&gt;type, looping);
/*
      musichandle = I_MusicPlayback((void*)data, datlength, play-&gt;type, looping);
*/
      W_DoneWithLump(data);
    }
    else
    {
      I_Warning("S_ChangeMusic: LUMP '%s' not found.\n", play-&gt;info); 
      return;
    }
  }

  if (play-&gt;infotype == MUSINF_TRACK)
  {
    musdat.format = IMUSF_CD;
    musdat.info.cd.track = atoi(play-&gt;info);

    musichandle = I_MusicPlayback(&amp;musdat, play-&gt;type, looping);
  }

  // if the music handle is returned, set the volume.
  if (musichandle != -1)
    I_SetMusicVolume(&amp;musichandle, musicvolume);

  return;
}
</t>
<t tx="T254">@ S_ResumeMusic
@c

void S_ResumeMusic(void)
{
  if (nomusic || musichandle == -1)
    return;

  I_MusicResume(&amp;musichandle);
  return;
}
</t>
<t tx="T255">@ S_PauseMusic
@c

void S_PauseMusic(void)
{
  if (nomusic || musichandle == -1)
    return;

  I_MusicPause(&amp;musichandle);
  return;
}
</t>
<t tx="T256">@ S_StopMusic
@c

void S_StopMusic(void)
{
  if (nomusic || musichandle == -1)
    return;

  I_MusicKill(&amp;musichandle);
  return;
}
</t>
<t tx="T257">@ S_MusicTicker
@c

void S_MusicTicker(void)
{
  I_MusicTicker(&amp;musichandle);
  return;
}
</t>
<t tx="T258">@ S_GetMusicVolume
@c

int S_GetMusicVolume(void)
{
  return musicvolume;
}
</t>
<t tx="T259">@ S_SetMusicVolume
@c

void S_SetMusicVolume(int volume)
{
  musicvolume = edgemid(S_MIN_VOLUME, volume, S_MAX_VOLUME);

  if (nomusic || musichandle == -1)
    return;

  I_SetMusicVolume(&amp;musichandle, volume);
}
</t>
<t tx="T260">@ignore
@language c

// Sound Handling Code (ENGINE LEVEL)

// -KM- 1998/09/27 Sounds.ddf. nosound is now global.
//   Reduced the pitching a little.
//
// -AJA- 1999/09/10: Made `volume' in various places have the range 0
//       to 255.  Note that value in snd_SfxVolume is still in the
//       range 0 to 15.
//
// -ACB- 1999/09/20 We are assuming nosound temporary like
//
// -ACB- 1999/10/06 Purged music info. This is a sound handling file

&lt;&lt; s_sound #includes &gt;&gt;
&lt;&lt; s_sound declarations &gt;&gt;
@others
</t>
<t tx="T261">#include "i_defs.h"
#include "s_sound.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_argv.h"
#include "m_random.h"
#include "p_local.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T262">
#define DEBUG_SOUND  0

// -KM- 1999/01/31 VSOUND, the speed of sound. Guessed at 500.
#define VSOUND  (500&lt;&lt;16)

// slider-scale volume control
static int soundvolume;

// for everything else
#define MAX_VOLUME 255

#define SLIDER_TO_VOL(v)  \
    (((v) - S_MIN_VOLUME) * MAX_VOLUME / (S_MAX_VOLUME-S_MIN_VOLUME))

// when to clip out sounds
// Does not fit the large outdoor areas. 1600 ** 2
// Distance to origin when sounds should be maxed out.
// This should relate to movement clipping resolution
#define S_CLOSE_DIST2    (S_CLOSE_DIST * S_CLOSE_DIST)
#define S_CLIPPING_DIST2 (S_CLIPPING_DIST * S_CLIPPING_DIST)

// Adjustable by menu.
#define NORM_PRIORITY           64
#define NORM_SEP                128
#define S_STEREO_SWING          96.0f

// If true, sound system is disabled/not working. Changed to false if sound init ok.
boolean_t nosound = false;

typedef struct
{
  sfxinfo_t *sfxinfo; // sound information (if null, channel avail.)
  mobj_t *origin;     // origin of sound
  int orig_vol;       // volume sound was started at (0 to 255).
  int channel;        // handle of the sound being played
  boolean_t paused;   // is sound paused?
  boolean_t looping;  // is sound looping?     -ACB- 2001/01/09 Added
}
playsfx_t;

typedef struct free_origin_s
{
  mobj_t *origin;
  void *block;
  struct free_origin_s *next;
}
free_origin_t;

static free_origin_t *free_queue = NULL;

// playing sfx list
#define PLAYINGSFXLIMIT 64
static playsfx_t playingsfx[PLAYINGSFXLIMIT];
static int playingsfxnum = PLAYINGSFXLIMIT;

// dummy head/tail in sound linked list
static sfxinfo_t sfxcachehead;

// number of sounds currently in cache.
static int numcachedsfx;
</t>
<t tx="T263">@ ===================Internal====================
HELPER Functions
@c

static INLINE int edgemin(int a, int b)
{
  return (a &lt; b) ? a : b;
}
</t>
<t tx="T264">
static INLINE int edgemax(int a, int b)
{
  return (a &gt; b) ? a : b;
}
</t>
<t tx="T265">
static INLINE int edgemid(int a, int b, int c)
{
  return edgemax(a, edgemin(b, c));
}
</t>
<t tx="T266">@ --- Small linking functions ---

InsertAtTail
@c

static INLINE void InsertAtTail(sfxinfo_t *sound)
{
  sound-&gt;next = &amp;sfxcachehead;
  sound-&gt;prev = sfxcachehead.prev;
  sound-&gt;next-&gt;prev = sound;
  sound-&gt;prev-&gt;next = sound;
}
</t>
<t tx="T267">@ InsertAtHead
@c

static INLINE void InsertAtHead(sfxinfo_t *sound)
{
  sound-&gt;next = sfxcachehead.next;
  sound-&gt;prev = &amp;sfxcachehead;
  sound-&gt;next-&gt;prev = sound;
  sound-&gt;prev-&gt;next = sound;
}
</t>
<t tx="T268">@ UnlinkSound
@c

static INLINE void UnlinkSound(sfxinfo_t *sound)
{
  sound-&gt;next-&gt;prev = sound-&gt;prev;
  sound-&gt;prev-&gt;next = sound-&gt;next;
  sound-&gt;next = NULL;
  sound-&gt;prev = NULL;
}
</t>
<t tx="T269">@ RemoveSoundFromCache
@c

static void RemoveSoundFromCache(sfxinfo_t *sound)
{
  int snd_num = sound-&gt;normal.sounds[0];

  DEV_ASSERT(sound-&gt;next, ("RemoveSoundFromCache: Sound not in cache"));
  UnlinkSound(sound);

  I_UnloadSfx(snd_num);
  numcachedsfx--;
}
</t>
<t tx="T270">@ GetSfxLumpNum

Retrieve the raw data lump index for a given SFX name.

-KM- 1998/10/29 handles links correctly
-KM- 1998/12/16 If an sfx doesn't exist, use pistol sound.
-ACB- 1999/09/20 Renamed to S_GetSfxLumpNum. Moved from I_Sound.C
@c

static int GetSfxLumpNum(sfxinfo_t *sfx)
{
  char *name = sfx-&gt;lump_name;
  int i;

  i = W_CheckNumForName(name);

  if (!strict_errors &amp;&amp; i == -1)
  {
    I_Warning("Unknown sound lump %s, using DSPISTOL.\n", name);
    name = "DSPISTOL";
    i = W_CheckNumForName(name);
  }

  return i;
}
</t>
<t tx="T271">@ CacheSound

Loads the sound if it isn't already loaded, and moves it to the tail
of the cache's linked list. Returns true if successful, or false
if sound didn't exist.
@c

static boolean_t CacheSound(sfxinfo_t *sound)
{
  int snd_num = sound-&gt;normal.sounds[0];
  int length, freq;
  boolean_t success;
  const byte *lump;
  int lumpnum;
  const char *error;

  if (sound-&gt;next)
  {
    // already cached.
    // unlink it, so we can re-insert it at tail
    UnlinkSound(sound);
  }
  else
  {
    // cache the sound

    // get the lumpnumber
    lumpnum = GetSfxLumpNum(sound);

    if (lumpnum &lt; 0)
      return false;

    // Cache the sound data
    lump = W_CacheLumpNum(lumpnum);

    freq   = lump[2] + (lump[3] &lt;&lt; 8);
    length = W_LumpLength(lumpnum) - 8;

    // Load the sound effect. Jump over the sound header
    success = I_LoadSfx(lump + 8, length, freq, snd_num);

    // the lump is particularly useless, since it won't be needed until
    // the sound itself has been flushed. It should be flushed sometime
    // before the sound, so why not just flush it as early as possible.
    W_DoneWithLump_Flushable(lump);

    if (!success)
    {
      error = I_SoundReturnError();
      I_Warning("%s\n", error);
    }

    numcachedsfx++;
  }

  InsertAtTail(sound);

  return true;
}
</t>
<t tx="T272">@ AdjustSoundParams

Changes volume, and stereo-separation
from the norm of a sound effect to be played.

If the sound is not audible, returns a 0.
Otherwise, modifies parameters and returns 1.
The 2s here mean squared, eg S_CLOSE_DIST2 is S_CLOSE_DIST squared.

-AJA- 1999/09/10: made static, and updated for volume in range
from 0 to 255.

-AJA- 2000/04/21: max_distance for sounds.ddf, and 3D distance.
@c

static int AdjustSoundParams(sfxinfo_t *sfx, mobj_t *listener, 
    mobj_t *source, int *vol, int *sep)
{
  float_t approx_dist;
  float_t adx, ady, adz;
  angle_t angle;

  // calculate the distance to sound origin
  //  and clip it if necessary
  adx = fabs(listener-&gt;x - source-&gt;x);
  ady = fabs(listener-&gt;y - source-&gt;y);
  adz = fabs(listener-&gt;z - source-&gt;z);

  // From _GG1_ p.428. Approx. euclidian distance fast.
  //    approx_dist = adx + ady - ((adx &lt; ady ? adx : ady)&gt;&gt;1);
  // Pythagoras.  Results are optimised:
  // Square Root here cancels with square down there

  approx_dist = adx * adx + ady * ady + adz * adz;

  if (approx_dist &gt; sfx-&gt;max_distance * sfx-&gt;max_distance)
    return 0;

  // angle of source to listener
  angle = R_PointToAngle(listener-&gt;x, listener-&gt;y, source-&gt;x, source-&gt;y);

  angle = angle - listener-&gt;angle;

  // stereo separation
  *sep = 128.0f - S_STEREO_SWING * M_Sin(angle);

  // volume calculation
  if (approx_dist &gt; S_CLOSE_DIST2)
  {
    // Kester's Physics Model v1.1
    // -KM- 1998/07/31 Use Full dynamic range
    *vol *= (S_CLIPPING_DIST2 - approx_dist) / 
            (S_CLIPPING_DIST2 - S_CLOSE_DIST2);

    if (*vol &gt; MAX_VOLUME)
      *vol = MAX_VOLUME;
  }

  return (*vol &gt; 0);
}
</t>
<t tx="T273">@ GetSoundChannel

if none available, return -1. Otherwise channel #.

-AJA- 1999/09/10: made static.
@c

static int GetSoundChannel(mobj_t *origin, sfxinfo_t *sfxinfo)
{
  // channel number to use
  int cnum = -1;
  int i;
  int lowest_priority;

  // Check all channels for singularity test
  if (sfxinfo-&gt;singularity)
  {
    for (i = 0; i &lt; playingsfxnum; i++)
    {
      if (!playingsfx[i].sfxinfo)
        continue;

      // only ONE singular sound allowed from each object
      if (playingsfx[i].origin == origin &amp;&amp; 
          playingsfx[i].sfxinfo-&gt;singularity == sfxinfo-&gt;singularity)
      {
        if (playingsfx[i].sfxinfo-&gt;precious)
          return -1;

        S_StopChannel(i);
        cnum = i;
        break;
      }
    }
  }

  // Find an open channel
  // -KM- 1998/12/16 New SFX code.
  for (i = 0; i &lt; playingsfxnum; i++)
  {
    if (!playingsfx[i].sfxinfo)
    {
      cnum = i;
      break;
    }
  }

  // None available ?
  if (cnum == -1)
  {
    // Look for the lowest priority sound
    // (which has the highest priority value!).
    lowest_priority = sfxinfo-&gt;priority;
    for (i = 0; i &lt; playingsfxnum; i++)
    {
      if (playingsfx[i].sfxinfo-&gt;priority &gt;= lowest_priority)
      {
        // if equal priority, prefer to keep precious sounds
        if (playingsfx[i].sfxinfo-&gt;precious &amp;&amp; 
            playingsfx[i].sfxinfo-&gt;priority == lowest_priority)
          continue;

        cnum = i;
        lowest_priority = playingsfx[i].sfxinfo-&gt;priority;
        break;
      }
    }

    // This is the lowest priority sound
    if (lowest_priority == sfxinfo-&gt;priority)
      return -1;

    // Stop lower priority sound
    S_StopChannel(cnum);
  }

  return cnum;
}
</t>
<t tx="T274">@ StartSoundAtVolume

Start playing a sound at the given volume (in the range 0 to 255).

-ACB- 1998/08/10: Altered Error Messages
-KM- 1998/09/01: Looping support
-AJA- 1999/09/10: Made static.
@c

static int StartSoundAtVolume(mobj_t *origin, sfxinfo_t *sfx, int volume)
{
  int snd_num = sfx-&gt;normal.sounds[0];
  int rc, sep;
  int cnum, orig_vol;

  boolean_t looping;
  const char *error;

  if (nosound)
    return -1;

  looping = false;

  if (! CacheSound(sfx))
    return -1;

  volume = MIN(255, (int)(volume * sfx-&gt;volume));
  orig_vol = volume;

  if (origin &amp;&amp; sfx-&gt;looping)
    looping = true;
  
  // Check to see if it is audible,
  //  and if not, modify the params

  if (origin &amp;&amp; origin != consoleplayer-&gt;mo)
  {
    rc = AdjustSoundParams(sfx, consoleplayer-&gt;mo, origin,
        &amp;volume, &amp;sep);

    if (!rc)
      return -1;

    if (origin-&gt;x == consoleplayer-&gt;mo-&gt;x &amp;&amp; origin-&gt;y == consoleplayer-&gt;mo-&gt;y)
    {
      sep = NORM_SEP;
    }
  }
  else
  {
    sep = NORM_SEP;
    volume = edgemin(volume, MAX_VOLUME);
  }

  // try to find a channel
  cnum = GetSoundChannel(origin, sfx);

  if (cnum &lt; 0)
    return -1;

  playingsfx[cnum].looping  = looping;
  playingsfx[cnum].sfxinfo  = sfx;
  playingsfx[cnum].origin   = origin;
  playingsfx[cnum].orig_vol = orig_vol;
  playingsfx[cnum].channel  = I_SoundPlayback(snd_num, sep, volume, looping);

  // Hardware cannot cope. Channel not allocated
  if (playingsfx[cnum].channel == -1)
  {
    playingsfx[cnum].orig_vol = 0;
    playingsfx[cnum].origin   = NULL;
    playingsfx[cnum].sfxinfo  = NULL;
    playingsfx[cnum].looping  = false;

    error = I_SoundReturnError();
    L_WriteDebug("%s\n",error);
    return -1;
  }

#if (DEBUG_SOUND)
  L_WriteDebug("StartSoundAtVolume: playing sound %s vol %d chan %d "
      "voice %d\n", sfx-&gt;ddf.name, volume, cnum, playingsfx[cnum].channel);
#endif

  return cnum;
}
</t>
<t tx="T275">@ ===============End of Internals================

FlushSoundCaches

Destroys unused sounds.
At extreme urgency, also destroys used sounds.

-ES- 2000/02/07 Written.
@c

static void FlushSoundCaches(z_urgency_e urge)
{
  int i;
  int n = 0;
  sfxinfo_t *sfx;

  switch (urge)
  {
    case Z_UrgencyLow: n = numcachedsfx / 32; break;
    case Z_UrgencyMedium: n = numcachedsfx / 8; break;
    case Z_UrgencyHigh: n = numcachedsfx / 2; break;
    case Z_UrgencyExtreme: n = numcachedsfx; break;
  }

  for (i = 0, sfx = sfxcachehead.next; i &lt; n; i++)
  {
    DEV_ASSERT(sfx != &amp;sfxcachehead, ("S_FlushSoundCaches: Internal Error: miscount"));
    sfx = sfx-&gt;next;
    // Do not kill playing sounds unless urge is extreme.
    // Fixme: Implement SoundIsPlaying.
    // if (!I_SoundIsPlaying(sfx-&gt;prev-&gt;id) || urge == Z_UrgencyExtreme)
    {
      RemoveSoundFromCache(sfx-&gt;prev);
    }
  }
}
</t>
<t tx="T276">@ S_Init

Sets up non-system specific sound system. Loads all the sfx listed from
the DDF file.

-ACB- 1999/10/09 Re-written from scratch.
@c

boolean_t S_Init(void)
{
  int i;
  
  sfxcachehead.next = sfxcachehead.prev = &amp;sfxcachehead;
  Z_RegisterCacheFlusher(FlushSoundCaches);

  if (nosound)
    return true; // we allowed to fail with no sound

  for (i = 0; i &lt; playingsfxnum; i++)
  {
    playingsfx[i].sfxinfo = NULL;
    playingsfx[i].origin = NULL;
    playingsfx[i].orig_vol = 0;
    playingsfx[i].channel = -1;
    playingsfx[i].paused = false;
    playingsfx[i].looping = false;
  }

  return true;
}
</t>
<t tx="T277">@ S_SoundLevelInit

Pre-level startup code. Kills playing sounds at start of level.
@c

void S_SoundLevelInit(void)
{
  int cnum;

  if (nosound)
    return;

  // kill all playing sounds at start of level (trust me - a good idea)
  for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
    S_StopChannel(cnum);
}
</t>
<t tx="T278">@ S_StartSound
@c

int S_StartSound(mobj_t *origin, sfx_t *sound_id)
{
  int volume;

  if (nosound)
    return -1;

  // No volume - don't play any sounds
  if (!soundvolume)
    return -1;

  volume = (MAX_VOLUME - (S_MAX_VOLUME*8)) + (soundvolume*8);

  // -KM- 1998/11/25 Fixed this, added origin check
  if (!sound_id)
  {
// -ACB- 2000/01/09 Quick hack to test the system specifics - START
//    if (origin)
//      S_StopSound(origin);
    if (origin)
      S_StopLoopingSound(origin);
// -ACB- 2000/01/09 Quick hack to test the system specifics - END

    return -1;
  }

  return StartSoundAtVolume(origin, DDF_SfxSelect(sound_id), volume);
}
</t>
<t tx="T279">@ S_ResumeSounds

This resumes the playing of all paused effects

-ACB- 1999/10/17
@c

void S_ResumeSounds(void)
{
  int cnum;
  const char *error;

  for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
  {
    if (playingsfx[cnum].paused == true)
    {
      if (!I_SoundResume(playingsfx[cnum].channel))
      {
        error = I_SoundReturnError();
        L_WriteDebug("%s\n", error);
        return;
      }

      playingsfx[cnum].paused = false;
    }
  }
}
</t>
<t tx="T280">@ S_PauseSounds

This stops all the sound effects playing

-ACB- 1999/10/17
@c

void S_PauseSounds(void)
{
  int cnum;
  const char *error;

  for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
  {
    if (playingsfx[cnum].sfxinfo &amp;&amp; I_SoundCheck(playingsfx[cnum].channel))
    {
      if(!I_SoundPause(playingsfx[cnum].channel))
      {
        error = I_SoundReturnError();
        L_WriteDebug("%s\n", error);
        return;
      }

      playingsfx[cnum].paused = true;
    }
  }
}
</t>
<t tx="T281">@ S_StopSound

Store sounds from this object
@c

void S_StopSound(mobj_t *origin)
{
  int cnum;

  if (nosound)
    return;

  for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
  {
    if (playingsfx[cnum].sfxinfo &amp;&amp; (playingsfx[cnum].origin == origin))
      S_StopChannel(cnum);
  }
}
</t>
<t tx="T282">@ S_RemoveSoundOrigin

Removes all dependencies to the object, but doesn't stop its sounds
(they will be played until they end)
-ES- FIXME: Implement properly (now it just cuts off the sound)
@c

void S_RemoveSoundOrigin(mobj_t *origin)
{
  int cnum;

  if (nosound)
    return;

  for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
  {
    if (playingsfx[cnum].sfxinfo &amp;&amp; (playingsfx[cnum].origin == origin))
      S_StopChannel(cnum);
  }
}
</t>
<t tx="T283">@ S_AddToFreeQueue

Sound origins can be killed sometimes, when the sounds should go on.
This routine makes sure that the origin isn't removed until the sound
has finished.
@c

void S_AddToFreeQueue(mobj_t *origin, void *block)
{
  int cnum;
  free_origin_t *q;

  if (nosound)
  {
    Z_Free(block);
    return;
  }

  for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
  {
    if (playingsfx[cnum].sfxinfo &amp;&amp; (playingsfx[cnum].origin == origin))
    {
      // The origin is playing a sound, so we must add it to the queue.
      for (q = free_queue; q; q = q-&gt;next)
      {
        if (q-&gt;origin == origin)
          return;                // it's already queued
      }

      // create new queue element
      q         = Z_New(free_origin_t, 1);
      q-&gt;next   = free_queue;
      q-&gt;origin = origin;
      q-&gt;block  = block;
      return;
    }
  }

  // No sound playing, so we can remove the block.
  Z_Free(block);
}
</t>
<t tx="T284">@ S_UpdateSounds

Updates sounds
@c

void S_UpdateSounds(mobj_t *listener)
{
  int audible;
  int cnum;
  int volume;
  int sep;
  playsfx_t *c;
  free_origin_t *q, *next, *prev;
  boolean_t kill;

  if (nosound)
    return;

  for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
  {
    c = &amp;playingsfx[cnum];

    if (! c-&gt;sfxinfo || c-&gt;paused)
      continue;

    if (! I_SoundCheck(c-&gt;channel))
    {
      // if channel is allocated but sound has stopped, free it
      S_StopChannel(cnum);
      continue;
    }
    
    // initialise parameters
    volume = c-&gt;orig_vol;
    sep = NORM_SEP;

    // check non-local sounds for distance clipping
    //  or modify their params
    if (c-&gt;origin &amp;&amp; (listener != c-&gt;origin))
    {
      // Check for freed origin in intolerant mode
      DEV_ASSERT2(*(int *)(&amp;c-&gt;origin-&gt;x) != -1);

      audible = AdjustSoundParams(c-&gt;sfxinfo, listener, c-&gt;origin, 
          &amp;volume, &amp;sep);

      if (!audible)
        S_StopChannel(cnum);
      else
        I_SoundAlter(c-&gt;channel, sep, volume);
    }
  }

  prev = NULL;
  for (q = free_queue; q; q = next)
  {
    next = q-&gt;next;

    // check if the sound has stopped, so we can kill it
    kill = true;
    for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
    {
      if (playingsfx[cnum].sfxinfo &amp;&amp; (playingsfx[cnum].origin == q-&gt;origin))
      {
        // it's still playing
        kill = false;
        break;
      }
    }

    if (kill)
    {
      // Wheee, it doesn't play anymore. Kill.
      if (prev)
        prev-&gt;next = q-&gt;next;
      else
        free_queue = q-&gt;next;

      Z_Free(q-&gt;block);
      Z_Free(q);
    }
    else
      prev = q;
  }
}
</t>
<t tx="T285">@ S_Ticker

Called each tick.

-AJA- 1999/09/10: Written.
-ACB- 1999/10/06: Include update sound routines here.
@c

void S_SoundTicker(void)
{
  I_SoundTicker();
  S_UpdateSounds(consoleplayer-&gt;mo);
}
</t>
<t tx="T286">@ S_GetSfxVolume
@c

int S_GetSfxVolume(void)
{
  return soundvolume;
}
</t>
<t tx="T287">@ S_SetSfxVolume
@c

void S_SetSfxVolume(int volume)
{
  soundvolume = edgemid(S_MIN_VOLUME, volume, S_MAX_VOLUME);
}
</t>
<t tx="T288">@ S_StopLoopingChannel
@c

void S_StopLoopingChannel(int cnum)
{
  playsfx_t *c;

  if (nosound)
    return;

  c = &amp;playingsfx[cnum];

  if (c-&gt;sfxinfo)
  {
    I_SoundStopLooping(c-&gt;channel);
    c-&gt;looping = false;
  }

  return;
}
</t>
<t tx="T289">@ S_StopLoopingSound

Stops all sounds looping for this object
@c

void S_StopLoopingSound(mobj_t *origin)
{
  int cnum;

  if (nosound)
    return;

  for (cnum = 0; cnum &lt; playingsfxnum; cnum++)
  {
    if (playingsfx[cnum].looping &amp;&amp;
        playingsfx[cnum].sfxinfo &amp;&amp;
        (playingsfx[cnum].origin == origin))
    {
      S_StopLoopingChannel(cnum);
    }
  }

  return;
}
</t>
<t tx="T290">@ S_StopChannel

Stop this internal channel playing
@c

void S_StopChannel(int cnum)
{
  playsfx_t *c;

  if (nosound)
    return;

  c = &amp;playingsfx[cnum];

  if (c-&gt;sfxinfo)
  {
    // stop the sound, be it playing or finished
    I_SoundKill(c-&gt;channel);

    c-&gt;sfxinfo = NULL;
    c-&gt;looping = false;
    c-&gt;paused  = false;
  }

  return;
}
</t>
<t tx="T291">@ignore
@language c

// Status Bar Library Code

&lt;&lt; st_lib #includes &gt;&gt;
@others
</t>
<t tx="T292">#include "i_defs.h"
#include "st_lib.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_swap.h"
#include "st_stuff.h"
#include "r_local.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "v_res.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T293">
void STLIB_Init(void)
{
  /* does nothing */
}
</t>
<t tx="T294">
void STLIB_InitNum(st_number_t * n, int x, int y, 
    const image_t ** digits, const image_t *minus, int *num, 
    boolean_t * on, int width)
{
  n-&gt;x = x;
  n-&gt;y = y;
  n-&gt;oldnum = 0;
  n-&gt;width = width;
  n-&gt;num = num;
  n-&gt;on = on;
  n-&gt;digits = digits;
  n-&gt;minus = minus;
  n-&gt;colmap = text_red_map;
}
</t>
<t tx="T295">
void STLIB_InitFloat(st_float_t * n, int x, int y, 
    const image_t ** digits, float_t *num, boolean_t * on, int width)
{
  STLIB_InitNum(&amp;n-&gt;num, x,y, digits,NULL, NULL, on, width);
  n-&gt;f = num;
}
</t>
<t tx="T296">
#define DrawDigit(X,Y,Image,Map)  \
vctx.DrawImage(FROM_320((X)-(Image)-&gt;offset_x), \
   FROM_200((Y)-(Image)-&gt;offset_y), \
   FROM_320(IM_WIDTH(Image)), FROM_200(IM_HEIGHT(Image)),  \
   (Image),0,0,IM_RIGHT(Image),IM_BOTTOM(Image),(Map),1.0)

static void DrawNum(st_number_t * n, boolean_t refresh)
{
int numdigits = n-&gt;width;
int num = *n-&gt;num;
int x;

boolean_t neg = false;

n-&gt;oldnum = *n-&gt;num;

// if non-number, do not draw it
if (num == 1994)
return;

if (num &lt; 0)
{
neg = true;

num = -num;
numdigits--;
}

#if 0
if (numdigits == 1 &amp;&amp; num &gt; 9)
num = 9;
else if (numdigits == 2 &amp;&amp; num &gt; 99)
num = 99;
else if (numdigits == 3 &amp;&amp; num &gt; 999)
num = 999;
else if (numdigits == 4 &amp;&amp; num &gt; 9999)
num = 9999;
#endif

x = n-&gt;x;

// in the special case of 0, you draw 0
if (num == 0)
{
x -= IM_WIDTH(n-&gt;digits[0]);
DrawDigit(x, n-&gt;y, n-&gt;digits[0], n-&gt;colmap);
}
else
{
DEV_ASSERT2(num &gt; 0);

// draw the new number
for (; num &amp;&amp; (numdigits &gt; 0); num /= 10, numdigits--)
{
  x -= IM_WIDTH(n-&gt;digits[num % 10]);
  DrawDigit(x, n-&gt;y, n-&gt;digits[num % 10], n-&gt;colmap);
}
}

if (neg &amp;&amp; n-&gt;minus)
{
x -= IM_WIDTH(n-&gt;minus);
DrawDigit(x, n-&gt;y, n-&gt;minus, n-&gt;colmap);
}
}
</t>
<t tx="T297">
void STLIB_UpdateNum(st_number_t * n, boolean_t refresh)
{
  if (*n-&gt;on)
    DrawNum(n, refresh);
}
</t>
<t tx="T298">
void STLIB_UpdateFloat(st_float_t * n, boolean_t refresh)
{
  int i = *n-&gt;f;
  
  // HACK: Display 1 for numbers between 0 and 1. This is just because a
  // health of 0.3 otherwise would be displayed as 0%, which would make it
  // seem like you were a living dead.
  
  if (*n-&gt;f &gt; 0 &amp;&amp; *n-&gt;f &lt; 1.0)
    i = 1;

  n-&gt;num.num = &amp;i;
  STLIB_UpdateNum(&amp;n-&gt;num, refresh);
  n-&gt;num.num = NULL;
}
</t>
<t tx="T299">
void STLIB_InitPercent(st_percent_t * p, int x, int y, 
    const image_t ** digits, const image_t *percsign,
    float_t *num, boolean_t * on)
{
  STLIB_InitFloat(&amp;p-&gt;f, x, y, digits, num, on, 3);
  p-&gt;percsign = percsign;
}
</t>
<t tx="T300">
void STLIB_UpdatePercent(st_percent_t * per, int refresh)
{
  st_number_t *num = &amp;per-&gt;f.num;

  if (refresh &amp;&amp; *num-&gt;on)
  {
    DrawDigit(num-&gt;x, num-&gt;y, per-&gt;percsign, num-&gt;colmap);
  }

  STLIB_UpdateFloat(&amp;per-&gt;f, refresh);
}
</t>
<t tx="T301">
void STLIB_InitMultIcon(st_multicon_t * i, int x, int y, 
    const image_t ** icons, int *inum, boolean_t * on)
{
  i-&gt;x = x;
  i-&gt;y = y;
  i-&gt;oldinum = -1;
  i-&gt;inum = inum;
  i-&gt;on = on;
  i-&gt;icons = icons;
}
</t>
<t tx="T302">
void STLIB_UpdateMultIcon(st_multicon_t * mi, boolean_t refresh)
{
  const image_t *image;

  if (*mi-&gt;on &amp;&amp; (mi-&gt;oldinum != *mi-&gt;inum || refresh)
      &amp;&amp; (*mi-&gt;inum != -1))
  {
    image = mi-&gt;icons[*mi-&gt;inum];

    VCTX_ImageEasy320(mi-&gt;x, mi-&gt;y, image);

    mi-&gt;oldinum = *mi-&gt;inum;
  }
}
</t>
<t tx="T303">
void STLIB_InitBinIcon(st_binicon_t * b, int x, int y, 
    const image_t * icon, boolean_t * val, boolean_t * on)
{
  b-&gt;x = x;
  b-&gt;y = y;
  b-&gt;oldval = 0;
  b-&gt;val = val;
  b-&gt;on = on;
  b-&gt;icon = icon;
}
</t>
<t tx="T304">
void STLIB_UpdateBinIcon(st_binicon_t * bi, boolean_t refresh)
{
  if (*bi-&gt;on &amp;&amp; (bi-&gt;oldval != *bi-&gt;val || refresh))
  {
    if (*bi-&gt;val)
    {
      VCTX_ImageEasy320(bi-&gt;x, bi-&gt;y, bi-&gt;icon);
    }

    bi-&gt;oldval = *bi-&gt;val;
  }
}
</t>
<t tx="T305">@ignore
@language c

// Status Bar Code

// -KM- 1998/07/21 Removed Cheats from this file to m_cheat.c.

&lt;&lt; st_stuff #includes &gt;&gt;
&lt;&lt; st_stuff declarations &gt;&gt;
@others
</t>
<t tx="T306">#include "i_defs.h"
#include "st_stuff.h"

#include "am_map.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "dstrings.h"
#include "ddf_main.h"
#include "g_game.h"
#include "m_fixed.h"
#include "m_random.h"
#include "st_lib.h"
#include "r_local.h"
#include "p_local.h"
#include "p_mobj.h"
#include "m_cheat.h"
#include "m_menu.h"
#include "s_sound.h"
#include "v_ctx.h"
#include "v_res.h"
#include "v_colour.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T307">
//
// STATUS BAR DATA
//

// N/256*100% probability that the normal face state will change
#define ST_FACEPROBABILITY   96

#define ST_FX  143
#define ST_FY  169

#define ST_FACESX  143
#define ST_FACESY  168

// Should be set to patch width
//  for tall numbers later on
#define ST_TALLNUMWIDTH         (tallnum[0]-&gt;width)

// Number of status faces.
#define ST_NUMPAINFACES         5
#define ST_NUMSTRAIGHTFACES     3
#define ST_NUMTURNFACES         2
#define ST_NUMSPECIALFACES      3

#define ST_FACESTRIDE \
          (ST_NUMSTRAIGHTFACES+ST_NUMTURNFACES+ST_NUMSPECIALFACES)

#define ST_NUMEXTRAFACES        2

#define ST_NUMFACES \
          (ST_FACESTRIDE*ST_NUMPAINFACES+ST_NUMEXTRAFACES)

#define ST_TURNOFFSET           (ST_NUMSTRAIGHTFACES)
#define ST_OUCHOFFSET           (ST_TURNOFFSET + ST_NUMTURNFACES)
#define ST_EVILGRINOFFSET       (ST_OUCHOFFSET + 1)
#define ST_RAMPAGEOFFSET        (ST_EVILGRINOFFSET + 1)
#define ST_GODFACE              (ST_NUMPAINFACES*ST_FACESTRIDE)
#define ST_DEADFACE             (ST_GODFACE+1)

#define ST_STRAIGHTFACECOUNT    (TICRATE/2)
#define ST_TURNCOUNT            (1*TICRATE)
#define ST_OUCHCOUNT            (1*TICRATE)
#define ST_RAMPAGEDELAY         (2*TICRATE)
#define ST_SHORT_DELAY          (TICRATE/5)

#define ST_MUCHPAIN   20

// Location and size of statistics,
//  justified according to widget type.
// Problem is, within which space? STbar? Screen?
// Note: this could be read in by a lump.
//       Problem is, is the stuff rendered
//       into a buffer,
//       or into the frame buffer?

// AMMO number pos.
#define ST_AMMOWIDTH            3
#define ST_AMMOX                (ST_X+44)
#define ST_AMMOY                (171)

// HEALTH number pos.
#define ST_HEALTHWIDTH          3
#define ST_HEALTHX              (ST_X+90)
#define ST_HEALTHY              ((171))

// Weapon pos.
#define ST_ARMSX                (ST_X+111)
#define ST_ARMSY                ((172))
#define ST_ARMSBGX              (ST_X+104)
#define ST_ARMSBGY              ((168))
#define ST_ARMSXSPACE           12
#define ST_ARMSYSPACE           10

// Frags pos.
#define ST_FRAGSX               (ST_X+138)
#define ST_FRAGSY               ((171))
#define ST_FRAGSWIDTH           2

// ARMOUR number pos.
#define ST_ARMOURWIDTH          3
#define ST_ARMOURX              (ST_X+221)
#define ST_ARMOURY              ((171))

// Key icon positions.
#define ST_KEY0WIDTH            8
#define ST_KEY0HEIGHT           5
#define ST_KEY0X                (ST_X+239)
#define ST_KEY0Y                ((171))
#define ST_KEY1WIDTH            ST_KEY0WIDTH
#define ST_KEY1X                (ST_X+239)
#define ST_KEY1Y                ((181))
#define ST_KEY2WIDTH            ST_KEY0WIDTH
#define ST_KEY2X                (ST_X+239)
#define ST_KEY2Y                ((191))

// Ammunition counter.
#define ST_AMMO0WIDTH           3
#define ST_AMMO0HEIGHT          6
#define ST_AMMO0X               (ST_X+288)
#define ST_AMMO0Y               ((173))
#define ST_AMMO1WIDTH           ST_AMMO0WIDTH
#define ST_AMMO1X               (ST_X+288)
#define ST_AMMO1Y               ((179))
#define ST_AMMO2WIDTH           ST_AMMO0WIDTH
#define ST_AMMO2X               (ST_X+288)
#define ST_AMMO2Y               ((185))
#define ST_AMMO3WIDTH           ST_AMMO0WIDTH
#define ST_AMMO3X               (ST_X+288)
#define ST_AMMO3Y               ((191))

// Indicate maximum ammunition.
// Only needed because backpack exists.
#define ST_MAXAMMO0WIDTH        3
#define ST_MAXAMMO0HEIGHT       5
#define ST_MAXAMMO0X            (ST_X+314)
#define ST_MAXAMMO0Y            ((173))
#define ST_MAXAMMO1WIDTH        ST_MAXAMMO0WIDTH
#define ST_MAXAMMO1X            (ST_X+314)
#define ST_MAXAMMO1Y            ((179))
#define ST_MAXAMMO2WIDTH        ST_MAXAMMO0WIDTH
#define ST_MAXAMMO2X            (ST_X+314)
#define ST_MAXAMMO2Y            ((185))
#define ST_MAXAMMO3WIDTH        ST_MAXAMMO0WIDTH
#define ST_MAXAMMO3X            (ST_X+314)
#define ST_MAXAMMO3Y            ((191))

// used to update the whole status bar
boolean_t stbar_update = true;

// colorise health/ammo/armour
boolean_t stbar_colours = false;

// used to execute ST_Init() only once
static int veryfirsttime = 1;

// used for making messages go away
static int st_msgcounter = 0;

// used when in chat 
static st_chatstateenum_t st_chatstate;

// whether left-side main status bar is active
static boolean_t st_statusbaron;

// whether status bar chat is active
static boolean_t st_chat;

// value of st_chat before message popped up
static boolean_t st_oldchat;

// whether chat window has the cursor on
static boolean_t st_cursoron;

// !deathmatch
static boolean_t st_notdeathmatch;

// !deathmatch &amp;&amp; st_statusbaron
static boolean_t st_armson;

// !deathmatch
static boolean_t st_fragson;

// main bar left
static const image_t *sbar_image;

// 0-9, tall numbers
static const image_t *tallnum[10];

// tall % sign
static const image_t *tallpercent;

static const image_t *sttminus;

// 0-9, short, yellow (,different!) numbers
static const image_t *shortnum[10];

// 3 key-cards, 3 skulls &amp; 3 Combination -ACB- 1998/09/11
static const image_t *keys[9];

// face status patches
static const image_t *faces[ST_NUMFACES];

// face background
static const image_t *faceback;

 // main bar right
static const image_t *armsbg;

// weapon ownership patches
static const image_t *arms[6][2];

// ready-weapon widget
static st_number_t w_ready;

 // in deathmatch only, summary of frags stats
static st_number_t w_frags;

// health widget
static st_percent_t w_health;

// arms background
static st_binicon_t w_armsbg;

// weapon ownership widgets
static st_multicon_t w_arms[6];

// face status widget
static st_multicon_t w_faces;

// keycard widgets
static st_multicon_t w_keyboxes[3];

// armour widget
static st_percent_t w_armour;

// ammo widgets
static st_number_t w_ammo[4];

// max ammo widgets
static st_number_t w_maxammo[4];

 // number of frags so far in deathmatch
static int st_fragscount;

// holds key-type for each key box on bar
static int keyboxes[3];

static boolean_t st_stopped = true;


//
// STATUS BAR CODE
//
void ST_Stop(void);
</t>
<t tx="T308">
static void RefreshBackground(void)
{
  if (st_statusbaron)
  {
#ifdef USE_GL  // -AJA- hack fix for red line at bottom of screen
    VCTX_Image320(ST_X, ST_Y, ST_WIDTH, ST_HEIGHT+1, sbar_image);
#else
    VCTX_Image320(ST_X, ST_Y, ST_WIDTH, ST_HEIGHT, sbar_image);
#endif
  }
}
</t>
<t tx="T309">@ ST_Responder
@c

boolean_t ST_Responder(event_t * ev)
{
  // does nothing at the moment
  return false;
}
</t>
<t tx="T310">
static int ST_CalcPainOffset(void)
{
  float_t base, health;
  int index;

  if (! consoleplayer-&gt;mo)
    return 0;

  base = consoleplayer-&gt;mo-&gt;info-&gt;spawnhealth;

  DEV_ASSERT2(base &gt; 0);

  health = (base - MIN(base, consoleplayer-&gt;health)) / base;
  index = MIN(ST_NUMPAINFACES-1, (int)(health * ST_NUMPAINFACES));

  return ST_FACESTRIDE * index;
}
</t>
<t tx="T311">
static void DrawWidgets(boolean_t refresh)
{
  int i;

  // used by w_arms[] widgets
  st_armson = st_statusbaron &amp;&amp; !deathmatch;

  // used by w_frags widget
  st_fragson = deathmatch &amp;&amp; st_statusbaron;

  STLIB_UpdateNum(&amp;w_ready, refresh);

  for (i = 0; i &lt; 4; i++)
  {
    STLIB_UpdateNum(&amp;w_ammo[i], refresh);
    STLIB_UpdateNum(&amp;w_maxammo[i], refresh);
  }

  STLIB_UpdatePercent(&amp;w_health, refresh);
  STLIB_UpdatePercent(&amp;w_armour, refresh);

  STLIB_UpdateBinIcon(&amp;w_armsbg, refresh);

  for (i = 0; i &lt; 6; i++)
    STLIB_UpdateMultIcon(&amp;w_arms[i], refresh);

  STLIB_UpdateMultIcon(&amp;w_faces, refresh);

  for (i = 0; i &lt; 3; i++)
    STLIB_UpdateMultIcon(&amp;w_keyboxes[i], refresh);

  STLIB_UpdateNum(&amp;w_frags, refresh);
}
</t>
<t tx="T312">@ ST_UpdateFaceWidget

This routine handles the face states and their timing.
The precedence of expressions is:

dead &gt; evil grin &gt; turned head &gt; straight ahead
@c

static void ST_UpdateFaceWidget(void)
{
  angle_t badguyangle;
  angle_t diffang;

  if (consoleplayer-&gt;face_count &gt; 0)
  {
    consoleplayer-&gt;face_count--;
    return;
  }

  // dead ?
  if (consoleplayer-&gt;health &lt;= 0)
  {
    consoleplayer-&gt;face_index = ST_DEADFACE;
    consoleplayer-&gt;face_count = TICRATE;
    return;
  }

  // evil grin if just picked up weapon
  if (consoleplayer-&gt;grin_count)
  {
    consoleplayer-&gt;face_index = ST_CalcPainOffset() + ST_EVILGRINOFFSET;
    consoleplayer-&gt;face_count = ST_SHORT_DELAY;
    return;
  }

  // being attacked ?
  if (consoleplayer-&gt;damagecount &amp;&amp; consoleplayer-&gt;attacker &amp;&amp; consoleplayer-&gt;attacker != consoleplayer-&gt;mo)
  {
    if ((consoleplayer-&gt;old_health - consoleplayer-&gt;health) &gt; ST_MUCHPAIN)
    {
      consoleplayer-&gt;face_index = ST_CalcPainOffset() + ST_OUCHOFFSET;
      consoleplayer-&gt;face_count = ST_TURNCOUNT;
      return;
    }

    badguyangle = R_PointToAngle(consoleplayer-&gt;mo-&gt;x, consoleplayer-&gt;mo-&gt;y,
        consoleplayer-&gt;attacker-&gt;x, consoleplayer-&gt;attacker-&gt;y);

    diffang = badguyangle - consoleplayer-&gt;mo-&gt;angle;

    consoleplayer-&gt;face_index = ST_CalcPainOffset();
    consoleplayer-&gt;face_count = ST_TURNCOUNT;

    if (diffang &lt; ANG45 || diffang &gt; ANG315 ||
        (diffang &gt; ANG135 &amp;&amp; diffang &lt; ANG225))
    {
      // head-on  
      consoleplayer-&gt;face_index += ST_RAMPAGEOFFSET;
    }
    else if (diffang &gt;= ANG45 &amp;&amp; diffang &lt;= ANG135)
    {
      // turn face left
      consoleplayer-&gt;face_index += ST_TURNOFFSET + 1;
    }
    else
    {
      // turn face right
      consoleplayer-&gt;face_index += ST_TURNOFFSET;
    }
    return;
  }

  // getting hurt because of your own damn stupidity
  if (consoleplayer-&gt;damagecount)
  {
    if ((consoleplayer-&gt;old_health - consoleplayer-&gt;health) &gt; ST_MUCHPAIN)
    {
      consoleplayer-&gt;face_index = ST_CalcPainOffset() + ST_OUCHOFFSET;
      consoleplayer-&gt;face_count = ST_TURNCOUNT;
      return;
    }

    consoleplayer-&gt;face_index = ST_CalcPainOffset() + ST_RAMPAGEOFFSET;
    consoleplayer-&gt;face_count = ST_TURNCOUNT;
    return;
  }

  // rapid firing
  if (consoleplayer-&gt;attackdown_count &gt; ST_RAMPAGEDELAY)
  {
    consoleplayer-&gt;face_index = ST_CalcPainOffset() + ST_RAMPAGEOFFSET;
    consoleplayer-&gt;face_count = ST_SHORT_DELAY;
    return;
  }

  // invulnerability
  if ((consoleplayer-&gt;cheats &amp; CF_GODMODE)
      || consoleplayer-&gt;powers[PW_Invulnerable] &gt; 0)
  {
    consoleplayer-&gt;face_index = ST_GODFACE;
    consoleplayer-&gt;face_count = ST_SHORT_DELAY;
    return;
  }

  // default: look about the place...
  consoleplayer-&gt;face_index = ST_CalcPainOffset() + (M_Random() % 3);
  consoleplayer-&gt;face_count = ST_STRAIGHTFACECOUNT;
}
</t>
<t tx="T313">
static keys_e st_key_list[6] =
{
  KF_BlueCard, KF_YellowCard, KF_RedCard,
  KF_BlueSkull, KF_YellowSkull, KF_RedSkull
};

static void UpdateWidgets(void)
{
  static int largeammo = 1994;  // means "n/a"

  int i;
  keys_e cards;

  // set health colour, as in BOOM.  -AJA- Experimental !!
  if (!stbar_colours || consoleplayer-&gt;health &lt; 25.0)
    w_health.f.num.colmap = text_red_map;
  else if (consoleplayer-&gt;health &lt; 60.0)
    w_health.f.num.colmap = text_green_map;
  else if (consoleplayer-&gt;health &lt;= 100.0)
    w_health.f.num.colmap = text_yellow_map;
  else
    w_health.f.num.colmap = text_blue_map;
  
  // find ammo amount to show -- or leave it blank
  w_ready.num = &amp;largeammo;
      
  if (consoleplayer-&gt;ready_wp &gt;= 0)
  {
    playerweapon_t *pw = &amp;consoleplayer-&gt;weapons[consoleplayer-&gt;ready_wp];

    if (pw-&gt;info-&gt;ammo != AM_NoAmmo)
    {
      if (pw-&gt;info-&gt;show_clip)
      {
        w_ready.num = &amp;pw-&gt;clip_size;
        w_ready.colmap = text_brown_map;
      }
      else
      {
        w_ready.num = &amp;consoleplayer-&gt;ammo[pw-&gt;info-&gt;ammo].num;

        // set ammo colour as in BOOM.  -AJA- Experimental !!
        if (! stbar_colours || *(w_ready.num) &lt; 20)
          w_ready.colmap = text_red_map;
        else if (*(w_ready.num) &lt;= 50)
          w_ready.colmap = text_green_map;
        else
          w_ready.colmap = text_yellow_map;
      }
    }
  }

  // choose largest armour to show
  w_armour.f.f = &amp;consoleplayer-&gt;armours[0];
  w_armour.f.num.colmap = stbar_colours ? text_green_map : text_red_map;

  for (i=NUMARMOUR-1; i &gt;= 1; i--)
  {
    if (consoleplayer-&gt;armours[i] &gt; 0)
    {
      w_armour.f.f = &amp;consoleplayer-&gt;armours[i];
      if (stbar_colours)
        w_armour.f.num.colmap = (i == ARMOUR_Blue) ? text_blue_map :
            (i == ARMOUR_Yellow) ? text_yellow_map : text_red_map;
      break;
    }
  }

  cards = consoleplayer-&gt;cards;

  // update keycard multiple widgets
  // -ACB- 1998/09/11 Include Combo Cards
  for (i = 0; i &lt; 3; i++)
  {
    if ((cards &amp; st_key_list[i]) &amp;&amp; (cards &amp; st_key_list[i + 3]))
      keyboxes[i] = i + 6;
    else if (cards &amp; st_key_list[i + 3])
      keyboxes[i] = i + 3;
    else if (cards &amp; st_key_list[i])
      keyboxes[i] = i;
    else
      keyboxes[i] = -1;
  }

  // refresh everything if this is him coming back to life
  ST_UpdateFaceWidget();

  // used by the w_armsbg widget
  st_notdeathmatch = !deathmatch;

  // used by w_arms[] widgets
  st_armson = st_statusbaron &amp;&amp; !deathmatch;

  // used by w_frags widget
  st_fragson = deathmatch &amp;&amp; st_statusbaron;
  st_fragscount = 0;

  st_fragscount = consoleplayer-&gt;frags;

  // get rid of chat window if up because of message
  if (!--st_msgcounter)
    st_chat = st_oldchat;
}
</t>
<t tx="T314">
void ST_Ticker(void)
{
  UpdateWidgets();

  consoleplayer-&gt;old_health = consoleplayer-&gt;health;
}
</t>
<t tx="T315">@ -AJA- 1999/07/03: Rewrote this routine, since the palette handling
has been moved to v_colour.c/h (and made more flexible). Later on it
might be good to DDF-ify all this, allowing other palette lumps and
being able to set priorities for the different effects.
@c

static void DoPaletteStuff(void)
{
  int palette = PALETTE_NORMAL;
  float_t amount = 0;
  int cnt;
  int bzc;

  cnt = consoleplayer-&gt;damagecount;

  if (consoleplayer-&gt;powers[PW_Berserk] &gt; 0)
  {
    // slowly fade the berzerk out
    bzc = MIN(20, consoleplayer-&gt;powers[PW_Berserk]);

    if (bzc &gt; cnt)
      cnt = bzc;
  }

  if (cnt)
  {
    palette = PALETTE_PAIN;
    amount = (cnt + 7) / 64.0;
  }
  else if (consoleplayer-&gt;bonuscount)
  {
    palette = PALETTE_BONUS;
    amount = (consoleplayer-&gt;bonuscount + 7) / 32.0;
  }
  else if (consoleplayer-&gt;powers[PW_AcidSuit] &gt; 4 * 32 ||
      fmod(consoleplayer-&gt;powers[PW_AcidSuit], 16) &gt;= 8)
  {
    palette = PALETTE_SUIT;
    amount = 1.0;
  }

  // This routine will limit `amount' to acceptable values, and will
  // only update the video palette/colourmaps when the palette actually
  // changes.
  V_SetPalette(palette, amount);
}
</t>
<t tx="T316">
static void DoRefresh(void)
{
  // draw status bar background to off-screen buff
  RefreshBackground();

  // and refresh all widgets
  DrawWidgets(true);

  stbar_update = false;
}
</t>
<t tx="T317">
static void DiffDraw(void)
{
  // update all widgets
  DrawWidgets(false);
}
</t>
<t tx="T318">
void ST_Drawer(boolean_t fullscreen, boolean_t refresh)
{
  st_statusbaron = (!fullscreen) || automapactive;

#if 1 
  // -AJA- one small hack for GL, one *giant* HACK for software 
  refresh = true;
#endif
  
  // Do red-/gold-shifts from damage/items
  DoPaletteStuff();

  // If just after ST_Start(), refresh all
  if (stbar_update || refresh)
  {
    DoRefresh();
    return;
  }

  // Otherwise, update as little as possible
  DiffDraw();
}
</t>
<t tx="T319">
static void LoadGraphics(void)
{
  int i;
  int j;
  int facenum;

  char namebuf[9];

  // Load the numbers, tall and short
  for (i = 0; i &lt; 10; i++)
  {
    sprintf(namebuf, "STTNUM%d", i);
    tallnum[i] = W_ImageFromFont(namebuf);

    sprintf(namebuf, "STYSNUM%d", i);
    shortnum[i] = W_ImageFromFont(namebuf);
  }

  // Load percent key.
  tallpercent = W_ImageFromFont("STTPRCNT");

  // Load '-'
  sttminus = W_ImageFromFont("STTMINUS");

  // key cards
  // -ACB- 1998/09/11 Include dual card/skull graphics
  for (i = 0; i &lt; 9; i++)
  {
    sprintf(namebuf, "STKEYS%d", i);
    keys[i] = W_ImageFromPatch(namebuf);
  }

  // arms background
  armsbg = W_ImageFromPatch("STARMS");

  // arms ownership widgets
  for (i = 0; i &lt; 6; i++)
  {
    sprintf(namebuf, "STGNUM%d", i + 2);

    // gray #
    arms[i][0] = W_ImageFromPatch(namebuf);

    // yellow #
    arms[i][1] = shortnum[i + 2];
  }

  // face backgrounds for different colour players
  sprintf(namebuf, "STFB%d", consoleplayer-&gt;pnum);
  faceback = W_ImageFromPatch(namebuf);

  // status bar background bits
  sbar_image = W_ImageFromPatch("STBAR");

  // face states
  facenum = 0;
  for (i = 0; i &lt; ST_NUMPAINFACES; i++)
  {
    for (j = 0; j &lt; ST_NUMSTRAIGHTFACES; j++)
    {
      sprintf(namebuf, "STFST%d%d", i, j);
      faces[facenum++] = W_ImageFromPatch(namebuf);
    }

    // turn right
    sprintf(namebuf, "STFTR%d0", i);
    faces[facenum++] = W_ImageFromPatch(namebuf);
    
    // turn left
    sprintf(namebuf, "STFTL%d0", i);
    faces[facenum++] = W_ImageFromPatch(namebuf);
    
    // ouch!
    sprintf(namebuf, "STFOUCH%d", i);
    faces[facenum++] = W_ImageFromPatch(namebuf);

    // evil grin ;)
    sprintf(namebuf, "STFEVL%d", i);
    faces[facenum++] = W_ImageFromPatch(namebuf);

    // pissed off
    sprintf(namebuf, "STFKILL%d", i);
    faces[facenum++] = W_ImageFromPatch(namebuf);
  }

  faces[facenum++] = W_ImageFromPatch("STFGOD0");
  faces[facenum]   = W_ImageFromPatch("STFDEAD0");
}
</t>
<t tx="T320">
static void LoadData(void)
{
  LoadGraphics();
}
</t>
<t tx="T321">
#if 0  // NOT YET USED ?
static void UnloadGraphics(void)
{
  int i;

  // unload the numbers, tall and short
  for (i = 0; i &lt; 10; i++)
  {
    W_DoneWithLump(tallnum[i]);
    W_DoneWithLump(shortnum[i]);
  }
  // unload tall percent
  W_DoneWithLump(tallpercent);

  // unload '-'
  W_DoneWithLump(sttminus);

  // unload the key cards (include combo widgets) -ACB- 1998/09/11
  for (i = 0; i &lt; 9; i++)
    W_DoneWithLump(keys[i]);

  // unload arms background
  W_DoneWithLump(armsbg);

  // unload gray #'s
  for (i = 0; i &lt; 6; i++)
    W_DoneWithLump(arms[i][0]);

  W_DoneWithLump(faceback);
  W_DoneWithLump(sbar);

  for (i = 0; i &lt; ST_NUMFACES; i++)
    W_DoneWithLump(faces[i]);
}
</t>
<t tx="T322">
static void UnloadData(void)
{
  UnloadGraphics();
}
</t>
<t tx="T323">#endif

static void InitData(void)
{
  int i;

  st_chatstate = StartChatState;
  st_statusbaron = true;
  st_oldchat = st_chat = false;
  st_cursoron = false;
  consoleplayer-&gt;face_index = 0;

  for (i = 0; i &lt; 3; i++)
    keyboxes[i] = -1;

  STLIB_Init();
}
</t>
<t tx="T324">
static void CreateWidgets(void)
{
  int i;

  // ready weapon ammo
  STLIB_InitNum(&amp;w_ready, ST_AMMOX, ST_AMMOY, tallnum, sttminus,
      &amp;consoleplayer-&gt;ammo[0].num,  // FIXME
      &amp;st_statusbaron, ST_AMMOWIDTH);

  // health percentage
  STLIB_InitPercent(&amp;w_health, ST_HEALTHX, ST_HEALTHY, tallnum, tallpercent,
      &amp;consoleplayer-&gt;health, &amp;st_statusbaron);

  // arms background
  STLIB_InitBinIcon(&amp;w_armsbg, ST_ARMSBGX, ST_ARMSBGY, armsbg,
      &amp;st_notdeathmatch, &amp;st_statusbaron);

  // weapons owned
  for (i = 0; i &lt; 6; i++)
  {
    STLIB_InitMultIcon(&amp;w_arms[i],
        ST_ARMSX + (i % 3) * ST_ARMSXSPACE,
        ST_ARMSY + (i / 3) * ST_ARMSYSPACE,
        arms[i], (int *)&amp;consoleplayer-&gt;avail_weapons[2 + i], &amp;st_armson);
  }

  // frags sum
  STLIB_InitNum(&amp;w_frags, ST_FRAGSX, ST_FRAGSY, tallnum, sttminus,
      &amp;st_fragscount, &amp;st_fragson, ST_FRAGSWIDTH);

  // faces
  STLIB_InitMultIcon(&amp;w_faces, ST_FACESX, ST_FACESY, faces,
      &amp;consoleplayer-&gt;face_index, &amp;st_statusbaron);

  // armour percentage - should be coloured later
  STLIB_InitPercent(&amp;w_armour, ST_ARMOURX, ST_ARMOURY, tallnum, tallpercent,
      &amp;consoleplayer-&gt;armours[0],   //!!! FIXME
      &amp;st_statusbaron);

  // keyboxes 0-2
  STLIB_InitMultIcon(&amp;w_keyboxes[0], ST_KEY0X, ST_KEY0Y, keys,
      &amp;keyboxes[0], &amp;st_statusbaron);

  STLIB_InitMultIcon(&amp;w_keyboxes[1], ST_KEY1X, ST_KEY1Y, keys,
      &amp;keyboxes[1], &amp;st_statusbaron);

  STLIB_InitMultIcon(&amp;w_keyboxes[2], ST_KEY2X, ST_KEY2Y, keys,
      &amp;keyboxes[2], &amp;st_statusbaron);

  // ammo count (all four kinds)
  STLIB_InitNum(&amp;w_ammo[0], ST_AMMO0X, ST_AMMO0Y, shortnum, NULL,
      &amp;consoleplayer-&gt;ammo[0].num, &amp;st_statusbaron, ST_AMMO0WIDTH);

  STLIB_InitNum(&amp;w_ammo[1], ST_AMMO1X, ST_AMMO1Y, shortnum, NULL,
      &amp;consoleplayer-&gt;ammo[1].num, &amp;st_statusbaron, ST_AMMO1WIDTH);

  STLIB_InitNum(&amp;w_ammo[2], ST_AMMO2X, ST_AMMO2Y, shortnum, NULL,
      &amp;consoleplayer-&gt;ammo[2].num, &amp;st_statusbaron, ST_AMMO2WIDTH);

  STLIB_InitNum(&amp;w_ammo[3], ST_AMMO3X, ST_AMMO3Y, shortnum, NULL,
      &amp;consoleplayer-&gt;ammo[3].num, &amp;st_statusbaron, ST_AMMO3WIDTH);

  // max ammo count (all four kinds)
  STLIB_InitNum(&amp;w_maxammo[0], ST_MAXAMMO0X, ST_MAXAMMO0Y, shortnum, NULL,
      &amp;consoleplayer-&gt;ammo[0].max, &amp;st_statusbaron, ST_MAXAMMO0WIDTH);

  STLIB_InitNum(&amp;w_maxammo[1], ST_MAXAMMO1X, ST_MAXAMMO1Y, shortnum, NULL,
      &amp;consoleplayer-&gt;ammo[1].max, &amp;st_statusbaron, ST_MAXAMMO1WIDTH);

  STLIB_InitNum(&amp;w_maxammo[2], ST_MAXAMMO2X, ST_MAXAMMO2Y, shortnum, NULL,
      &amp;consoleplayer-&gt;ammo[2].max, &amp;st_statusbaron, ST_MAXAMMO2WIDTH);

  STLIB_InitNum(&amp;w_maxammo[3], ST_MAXAMMO3X, ST_MAXAMMO3Y, shortnum, NULL,
      &amp;consoleplayer-&gt;ammo[3].max, &amp;st_statusbaron, ST_MAXAMMO3WIDTH);

  for (i=0; i &lt; 4; i++)
    w_ammo[i].colmap = w_maxammo[i].colmap = text_yellow_map;
}
</t>
<t tx="T325">
void ST_Start(void)
{
  if (!st_stopped)
    ST_Stop();

  InitData();
  CreateWidgets();
  UpdateWidgets();  // make sure colours are set right
  
  st_stopped = false;
}
</t>
<t tx="T326">
void ST_Stop(void)
{
  if (st_stopped)
    return;

  // -AJA- 1999/07/03: removed PLAYPAL reference.
  V_SetPalette(PALETTE_NORMAL, 0);

  st_stopped = true;
}
</t>
<t tx="T327">@ ST_ReInit
Re-inits status bar after a resolution change.
-ES- 1998/08/20 Added this
-ES- 1999/03/29 Fixed Low Resolutions
@c

void ST_ReInit(void)
{
//!!! -AJA- FIXME: this gets called too early
//!!! ST_Start();
}
</t>
<t tx="T328">@ ST_Init

Called once at startup
@c

boolean_t ST_Init(void)
{
  DEV_ASSERT2(veryfirsttime);

  veryfirsttime = 0;

  LoadData();
  M_CheatInit();

  return true;
}
</t>
<t tx="T329">@ignore
@language c

// New SaveGame Handling (Chunks)

// -AJA- 2000/07/13: Wrote this file.

&lt;&lt; sv_chunk #includes &gt;&gt;
&lt;&lt; sv_chunk declarations &gt;&gt;
@others
</t>
<t tx="T330">#include "i_defs.h"
#include "sv_chunk.h"

#include "dm_state.h"
#include "m_math.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_state.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"

#include "lzo/minilzo.h"

#include &lt;math.h&gt;
</t>
<t tx="T331">

// Note: only disable this for debugging purposes
#define COMPRESS_ENABLE  1

#define DEBUG_GETBYTE  0
#define DEBUG_PUTBYTE  0


#define XOR_STRING  "EDGE!"
#define XOR_LEN     5


#define STRING_MARKER   0xAA
#define NULLSTR_MARKER  0xDE

#define EDGESAVE_MAGIC   "EdgeSave"
#define FIRST_CHUNK_OFS  16L


static int last_error = 0;


// maximum size that compressing could give (worst-case scenario)
#define MAX_COMP_SIZE(orig)  ((orig) + (orig)/16 + 20)


// The chunk stack will never get any deeper than this
#define MAX_CHUNK_DEPTH  16

typedef struct chunk_s
{
  char s_mark[6];
  char e_mark[6];

  // read/write data.  When reading, this is only allocated/freed for
  // top level chunks (depth 0), lower chunks just point inside their
  // parent's data.  When writing, all chunks are allocated (and grow
  // bigger as needed).  Note: `end' is the byte _after_ the last one.

  unsigned char *start; 
  unsigned char *end; 
  unsigned char *pos;
}
chunk_t;

static chunk_t chunk_stack[MAX_CHUNK_DEPTH];
static int chunk_stack_size = 0;

static FILE *current_fp = NULL;
static unsigned long current_crc;
</t>
<t tx="T332">
#if (COMPRESS_ENABLE)
static long compress_wrkmem[LZO1X_1_MEM_COMPRESS/sizeof(long) + 2];
#endif


static boolean_t CheckMagic(void)
{
  int i;
  int len = strlen(EDGESAVE_MAGIC);

  for (i=0; i &lt; len; i++)
    if (SV_GetByte() != EDGESAVE_MAGIC[i])
      return false;
  
  return true;
}
</t>
<t tx="T333">
static void PutMagic(void)
{
  int i;
  int len = strlen(EDGESAVE_MAGIC);

  for (i=0; i &lt; len; i++)
    SV_PutByte(EDGESAVE_MAGIC[i]);
}
</t>
<t tx="T334">
static void PutPadding(void)
{
  SV_PutByte(0x1A);
  SV_PutByte(0x0D);
  SV_PutByte(0x0A);
  SV_PutByte(0x00);
}
</t>
<t tx="T335">
static INLINE boolean_t VerifyMarker(const char *id)
{
  return isalnum(id[0]) &amp;&amp; isalnum(id[1]) &amp;&amp;
         isalnum(id[2]) &amp;&amp; isalnum(id[3]);
}
</t>
<t tx="T336">@ SV_ChunkInit
@c

boolean_t SV_ChunkInit(void)
{
  if (lzo_init() != LZO_E_OK)
    I_Error("SV_ChunkInit: LZO initialisation error !\n");

  return true;
}
</t>
<t tx="T337">@ SV_ChunkShutdown
@c

void SV_ChunkShutdown(void)
{
  // nothing to do
}
</t>
<t tx="T338">@ SV_GetError
@c

int SV_GetError(void)
{
  int result = last_error;
  last_error = 0;

  return result;
}
</t>
<t tx="T339">@ ----------------------------------------------------------------------------

READING PRIMITIVES


SV_OpenReadFile
@c

boolean_t SV_OpenReadFile(const char *filename)
{
  chunk_stack_size = 0;
  last_error = 0;

  CRC32_Init(&amp;current_crc);

  current_fp = fopen(filename, "rb");

  if (! current_fp)
  {
    /// I_Warning("LOADGAME: Couldn't open file: %s\n", filename);
    return false;
  }

  return true;
}
</t>
<t tx="T340">@ SV_CloseReadFile
@c

boolean_t SV_CloseReadFile(void)
{
  DEV_ASSERT2(current_fp);

  DEV_ASSERT(chunk_stack_size == 0,
      ("SV_CloseReadFile: Too many Pushes (missing Pop somewhere).\n"));

  fclose(current_fp);

  if (last_error)
    I_Warning("LOADGAME: Error(s) occurred during reading.\n");
  
  return true;
}
</t>
<t tx="T341">@ SV_VerifyHeader

Sets the version field, which is BCD, with the patch level in the
two least significant digits.
@c

boolean_t SV_VerifyHeader(int *version)
{
  // check header

  if (! CheckMagic())
  {
    I_Warning("LOADGAME: Bad magic in savegame file\n");
    return false;
  }

  // skip padding
  SV_GetByte();
  SV_GetByte();
  SV_GetByte();
  SV_GetByte();

  (*version) = SV_GetInt();

  if (last_error)
  {
    I_Warning("LOADGAME: Bad header in savegame file\n");
    return false;
  }

  return true;
}
</t>
<t tx="T342">@ SV_VerifyContents
@c

boolean_t SV_VerifyContents(void)
{
  unsigned int final_crc, read_crc;

  DEV_ASSERT2(current_fp);
  DEV_ASSERT2(chunk_stack_size == 0);

  // skip top-level chunks until end...
  for (;;)
  {
#if (COMPRESS_ENABLE)
    unsigned int orig_len;
#endif
    unsigned int file_len;

    char start_marker[6];
    char end_marker[6];

    SV_GetMarker(start_marker);

    if (! VerifyMarker(start_marker))
    {
      I_Warning("LOADGAME: Verify failed: Invalid start marker: "
          "%02X %02X %02X %02X\n", start_marker[0], start_marker[1],
          start_marker[2], start_marker[3]);
      return false;
    }

    if (strcmp(start_marker, DATA_END_MARKER) == 0)
      break;

    // read chunk length
    file_len = SV_GetInt();

#if (COMPRESS_ENABLE)
    // read original, uncompressed size
    orig_len = SV_GetInt();

    if ((orig_len &amp; 3) != 0 || file_len &gt; MAX_COMP_SIZE(orig_len))
    {
      I_Warning("LOADGAME: Verify failed: Chunk has bad size: "
          "(file=%d orig=%d)\n", file_len, orig_len);
      return false;
    }
#endif

    // skip data bytes (merely compute the CRC)
    for (; (file_len &gt; 0) &amp;&amp; !last_error; file_len--)
      SV_GetByte();

    SV_GetMarker(end_marker);

    // run out of data ?
    if (last_error)
    {
      I_Warning("LOADGAME: Verify failed: Chunk corrupt or "
          "File truncated.\n");
      return false;
    }

    // check for matching markers

    if (! VerifyMarker(end_marker))
    {
      I_Warning("LOADGAME: Verify failed: Invalid end marker: "
          "%02X %02X %02X %02X\n", end_marker[0], end_marker[1],
          end_marker[2], end_marker[3]);
      return false;
    }
    else if (stricmp(start_marker, end_marker) != 0)
    {
      I_Warning("LOADGAME: Verify failed: Mismatched markers: "
          "%s != %s\n", start_marker, end_marker);
      return false;
    }
  }

  // check trailer
  if (! CheckMagic())
  {
    I_Warning("LOADGAME: Verify failed: Bad trailer.\n");
    return false;
  }

  CRC32_Done(&amp;current_crc);
  
  final_crc = current_crc;
  read_crc = SV_GetInt();

  if (read_crc != final_crc)
  {
    I_Warning("LOADGAME: Verify failed: Bad CRC: %08X != %08X\n", 
        final_crc, read_crc);
    return false;
  }

  // Move file pointer back to beginning
  fseek(current_fp, FIRST_CHUNK_OFS, SEEK_SET);
  clearerr(current_fp);

  return true;
}
</t>
<t tx="T343">@ SV_GetByte
@c

unsigned char SV_GetByte(void) 
{ 
  chunk_t *cur;
  unsigned char result;

  if (last_error)
    return 0;

  // read directly from file when no chunks are on the stack
  if (chunk_stack_size == 0)
  {
    int c = fgetc(current_fp);

    if (c == EOF)
    {
      I_Error("LOADGAME: Corrupt Savegame (reached EOF).\n");
      last_error = 1;
      return 0;
    }
    
    CRC32_ProcessByte(&amp;current_crc, c);
    
#if DEBUG_GETBYTE
  { 
    static int pos=0; pos++;
    L_WriteDebug("0.%02X%s", result, ((pos % 10)==0) ? "\n" : " ");
  }
#endif

    return (unsigned char) c;
  }

  cur = &amp;chunk_stack[chunk_stack_size - 1];

  DEV_ASSERT2(cur-&gt;start);
  DEV_ASSERT2(cur-&gt;pos &gt;= cur-&gt;start);
  DEV_ASSERT2(cur-&gt;pos &lt;= cur-&gt;end);

  if (cur-&gt;pos == cur-&gt;end)
  {
    //!!!
    I_Error("LOADGAME: Corrupt Savegame (reached end of [%s] chunk).\n", cur-&gt;s_mark);
    last_error = 2;
    return 0;
  }

  result = cur-&gt;pos[0];
  cur-&gt;pos++;

#if DEBUG_GETBYTE
  { 
    static int pos=0; pos++;
    L_WriteDebug("%d.%02X%s", chunk_stack_size, result, 
        ((pos % 10)==0) ? "\n" : " ");
  }
#endif

  return result;
}
</t>
<t tx="T344">@ SV_PushReadChunk
@c

boolean_t SV_PushReadChunk(const char *id)
{
  chunk_t *cur;
  unsigned int file_len;
  char marker[6];

  DEV_ASSERT(chunk_stack_size &lt; MAX_CHUNK_DEPTH,
      ("SV_PushReadChunk: Too many Pushes (missing Pop somewhere)."));

  // read chunk length
  file_len = SV_GetInt();

  // create new chunk_t
  cur = &amp;chunk_stack[chunk_stack_size];

  strcpy(cur-&gt;s_mark, id);
  strcpy(cur-&gt;e_mark, id);
  strupr(cur-&gt;e_mark);

  // top level chunk ?
  if (chunk_stack_size == 0)
  {
    unsigned int i;

#if (COMPRESS_ENABLE)
    unsigned int orig_len;
    unsigned int decomp_len;
    byte *file_data;

    // read uncompressed size
    orig_len = SV_GetInt();

    DEV_ASSERT2(file_len &lt;= MAX_COMP_SIZE(orig_len));

    file_data = Z_New(byte, file_len);
    
    for (i=0; (i &lt; file_len) &amp;&amp; !last_error; i++)
      file_data[i] = SV_GetByte();
    
    DEV_ASSERT2(!last_error);

    cur-&gt;start = Z_New(byte, orig_len);
    cur-&gt;end = cur-&gt;start + orig_len;

    // decompress data
    decomp_len = orig_len;

    i = lzo1x_decompress_safe(file_data, file_len,
        cur-&gt;start, &amp;decomp_len, NULL);

    if (i != LZO_E_OK)
    {
      I_Error("LOADGAME: ReadChunk [%s] failed: Decompress error.\n", id);
    }

    DEV_ASSERT2(decomp_len == orig_len);
    
    for (i=0; i &lt; decomp_len; i++)
      cur-&gt;start[i] ^= (byte)(XOR_STRING[i % XOR_LEN]);
#else
    cur-&gt;start = Z_New(byte, file_len);
    cur-&gt;end = cur-&gt;start + file_len;

    for (i=0; (i &lt; file_len) &amp;&amp; !last_error; i++)
      cur-&gt;start[i] = SV_GetByte();
    
    DEV_ASSERT2(!last_error);
#endif
  }
  else
  {
    chunk_t *parent = &amp;chunk_stack[chunk_stack_size - 1];

    cur-&gt;start = parent-&gt;pos;
    cur-&gt;end = cur-&gt;start + file_len;

    // skip data in parent
    parent-&gt;pos += file_len;

    DEV_ASSERT2(parent-&gt;pos &gt;= parent-&gt;start);
    DEV_ASSERT2(parent-&gt;pos &lt;= parent-&gt;end);
  }

  cur-&gt;pos = cur-&gt;start;

  // check for matching markers

  SV_GetMarker(marker);

  if (strcmp(cur-&gt;e_mark, marker) != 0)
  {
    I_Error("LOADGAME: ReadChunk [%s] failed: Bad markers.\n", id);
  }

  // let the SV_GetByte routine (etc) see the new chunk
  chunk_stack_size++;
  return true;
}
</t>
<t tx="T345">@ SV_PopReadChunk
@c

boolean_t SV_PopReadChunk(void)
{
  chunk_t *cur;

  DEV_ASSERT(chunk_stack_size &gt; 0, 
      ("SV_PopReadChunk: Too many Pops (missing Push somewhere)."));

  cur = &amp;chunk_stack[chunk_stack_size - 1];
  
  if (chunk_stack_size == 1)
  {
    // free the data
    Z_Free(cur-&gt;start);
  }

  cur-&gt;start = cur-&gt;pos = cur-&gt;end = NULL;
  chunk_stack_size--;

  return true;
}
</t>
<t tx="T346">@ SV_RemainingChunkSize
@c

int SV_RemainingChunkSize(void)
{
  chunk_t *cur;
  
  DEV_ASSERT2(chunk_stack_size &gt; 0);

  cur = &amp;chunk_stack[chunk_stack_size - 1];
  
  DEV_ASSERT2(cur-&gt;pos &gt;= cur-&gt;start);
  DEV_ASSERT2(cur-&gt;pos &lt;= cur-&gt;end);

  return (cur-&gt;end - cur-&gt;pos);
}
</t>
<t tx="T347">@ SV_SkipReadChunk
@c

boolean_t SV_SkipReadChunk(const char *id)
{
  if (! SV_PushReadChunk(id))
    return false;
  
  return SV_PopReadChunk();
}
</t>
<t tx="T348">@ ----------------------------------------------------------------------------

WRITING PRIMITIVES


SV_OpenWriteFile
@c

boolean_t SV_OpenWriteFile(const char *filename, int version)
{
  chunk_stack_size = 0;
  last_error = 0;

  CRC32_Init(&amp;current_crc);

  current_fp = fopen(filename, "wb");

  if (! current_fp)
  {
    I_Warning("SAVEGAME: Couldn't open file: %s\n", filename);
    return false;
  }

  // write header

  PutMagic();
  PutPadding();
  SV_PutInt(version);

  return true;
}
</t>
<t tx="T349">@ SV_CloseWriteFile
@c

boolean_t SV_CloseWriteFile(void)
{
  unsigned int final_crc;

  DEV_ASSERT2(current_fp);

  DEV_ASSERT(chunk_stack_size == 0,
      ("SV_CloseWriteFile: Too many Pushes (missing Pop somewhere).\n"));

  // write trailer

  SV_PutMarker(DATA_END_MARKER);
  PutMagic();

  CRC32_Done(&amp;current_crc);
  final_crc = current_crc;

  SV_PutInt(final_crc);

  if (last_error)
    I_Warning("SAVEGAME: Error(s) occurred during writing.\n");
  
  fclose(current_fp);

  return true;
}
</t>
<t tx="T350">@ SV_PushWriteChunk
@c

boolean_t SV_PushWriteChunk(const char *id)
{
  chunk_t *cur;

  DEV_ASSERT(chunk_stack_size &lt; MAX_CHUNK_DEPTH,
      ("SV_PushWriteChunk: Too many Pushes (missing Pop somewhere)."));

  // create new chunk_t
  cur = &amp;chunk_stack[chunk_stack_size];
  chunk_stack_size++;

  strcpy(cur-&gt;s_mark, id);
  strcpy(cur-&gt;e_mark, id);
  strupr(cur-&gt;e_mark);

  // create initial buffer
  cur-&gt;start = Z_New(byte, 1024);
  cur-&gt;pos   = cur-&gt;start;
  cur-&gt;end   = cur-&gt;start + 1024;

  return true;
}
</t>
<t tx="T351">@ SV_PopWriteChunk
@c

boolean_t SV_PopWriteChunk(void)
{
  int i;
  chunk_t *cur;
  int len;

  DEV_ASSERT(chunk_stack_size &gt; 0, 
      ("SV_PopWriteChunk: Too many Pops (missing Push somewhere)."));

  cur = &amp;chunk_stack[chunk_stack_size - 1];
  
  DEV_ASSERT2(cur-&gt;start);
  DEV_ASSERT2(cur-&gt;pos &gt;= cur-&gt;start);
  DEV_ASSERT2(cur-&gt;pos &lt;= cur-&gt;end);

  len = cur-&gt;pos - cur-&gt;start;

  // pad chunk to multiple of 4 characters
  for (; len &amp; 3; len++)
    SV_PutByte(0);

  // decrement stack size, so future PutBytes go where they should
  chunk_stack_size--;

  // firstly, write out marker
  SV_PutMarker(cur-&gt;s_mark);

  // write out data.  For top-level chunks, compress it.

  if (chunk_stack_size == 0)
  {
#if (COMPRESS_ENABLE)
    unsigned char *out_buf;
    unsigned int out_len;

    for (i=0; i &lt; len; i++)
      cur-&gt;start[i] ^= (byte)(XOR_STRING[i % XOR_LEN]);

    out_buf = Z_New(byte, MAX_COMP_SIZE(len));

    i = lzo1x_1_compress(cur-&gt;start, len, out_buf, &amp;out_len,
        compress_wrkmem);
    
    if (i != LZO_E_OK)
    {
      I_Error("SAVEGAME: WriteChunk [%s] failed: Decompress error.\n",
          cur-&gt;e_mark);
    }

    DEV_ASSERT2(out_len &lt;= MAX_COMP_SIZE(len));

    // write compressed length
    SV_PutInt(out_len);
    
    // write original length to parent
    SV_PutInt(len);

    for (i=0; (i &lt; out_len) &amp;&amp; !last_error; i++)
      SV_PutByte(out_buf[i]);
    
    DEV_ASSERT2(!last_error);

    Z_Free(out_buf);
#else
    // write chunk length to parent
    SV_PutInt(len);

    for (i=0; i &lt; len; i++)
      SV_PutByte(cur-&gt;start[i]);
#endif
  }
  else
  {
    // write chunk length to parent
    SV_PutInt(len);

    // FIXME: optimise this (transfer data directly into parent)
    for (i=0; i &lt; len; i++)
      SV_PutByte(cur-&gt;start[i]);
  }

  // write end marker
  SV_PutMarker(cur-&gt;e_mark);

  // all done, free stuff
  Z_Free(cur-&gt;start);

  cur-&gt;start = cur-&gt;pos = cur-&gt;end = NULL;
  return true;
}
</t>
<t tx="T352">@ SV_PutByte
@c

void SV_PutByte(unsigned char value) 
{
  chunk_t *cur;

#if DEBUG_PUTBYTE
  { 
    static int pos=0; pos++;
    L_WriteDebug("%d.%02x%s", chunk_stack_size, value, 
        ((pos % 10)==0) ? "\n" : " ");
  }
#endif

  if (last_error)
    return;

  // write directly to the file when chunk stack is empty
  if (chunk_stack_size == 0)
  {
    fputc(value, current_fp);

    if (ferror(current_fp))
    {
      I_Warning("SAVEGAME: Write error occurred !\n");
      last_error = 3;
      return;
    }
    
    CRC32_ProcessByte(&amp;current_crc, value);
    return;
  }

  cur = &amp;chunk_stack[chunk_stack_size - 1];

  DEV_ASSERT2(cur-&gt;start);
  DEV_ASSERT2(cur-&gt;pos &gt;= cur-&gt;start);
  DEV_ASSERT2(cur-&gt;pos &lt;= cur-&gt;end);

  // space left in chunk ?  If not, resize it.
  if (cur-&gt;pos == cur-&gt;end)
  {
    int new_len = (cur-&gt;end - cur-&gt;start) + 1024;
    int pos_idx = (cur-&gt;pos - cur-&gt;start);

    Z_Resize(cur-&gt;start, byte, new_len);

    cur-&gt;end = cur-&gt;start + new_len;
    cur-&gt;pos = cur-&gt;start + pos_idx;
  }

  *(cur-&gt;pos++) = value;
}
</t>
<t tx="T353">@ ----------------------------------------------------------------------------

BASIC DATATYPES
@c

void SV_PutShort(unsigned short value) 
{
  SV_PutByte(value &amp; 0xff);
  SV_PutByte(value &gt;&gt; 8);
}
</t>
<t tx="T354">
void SV_PutInt(unsigned int value) 
{
  SV_PutShort(value &amp; 0xffff);
  SV_PutShort(value &gt;&gt; 16);
}
</t>
<t tx="T355">
unsigned short SV_GetShort(void) 
{ 
  return SV_GetByte() | (SV_GetByte() &lt;&lt; 8);
}
</t>
<t tx="T356">
unsigned int SV_GetInt(void) 
{ 
  return SV_GetShort() | (SV_GetShort() &lt;&lt; 16);
}
</t>
<t tx="T357">@ ----------------------------------------------------------------------------

FIXED POINT &amp; ANGLES
@c

void SV_PutFixed(fixed_t value) 
{ 
  SV_PutInt((unsigned int) value);
}
</t>
<t tx="T358">
void SV_PutAngle(angle_t value) 
{ 
  SV_PutInt((unsigned int) value);
}
</t>
<t tx="T359">
fixed_t SV_GetFixed(void) 
{
  return (fixed_t) SV_GetInt();
}
</t>
<t tx="T360">
angle_t SV_GetAngle(void) 
{
  return (angle_t) SV_GetInt();
}
</t>
<t tx="T361">@ ----------------------------------------------------------------------------

FLOATING POINT
@c

void SV_PutFloat(float value) 
{ 
  int exp;
  int mant;
  boolean_t neg;

  neg = (value &lt; 0.0);
  value = fabs(value);

  mant = (int) ldexp(frexp(value, &amp;exp), 30);

  SV_PutShort(256 + exp);
  SV_PutInt((unsigned int) (neg ? -mant : mant));
}
</t>
<t tx="T362">
float_t SV_GetFloat(void) 
{ 
  int exp;
  int mant;

  exp = SV_GetShort() - 256;
  mant = (int) SV_GetInt();

  return ldexp((float) mant, -30 + exp);
}
</t>
<t tx="T363">@ ----------------------------------------------------------------------------

STRINGS &amp; MARKERS
@c

void SV_PutString(const char *str) 
{ 
  if (str == NULL)
  {
    SV_PutByte(NULLSTR_MARKER);
    return;
  }
  
  SV_PutByte(STRING_MARKER);
  SV_PutShort(strlen(str));

  for (; *str; str++)
    SV_PutByte(*str);
}
</t>
<t tx="T364">
void SV_PutMarker(const char *id)
{
  int i;

  DEV_ASSERT2(id);
  DEV_ASSERT2(strlen(id) == 4);

  for (i=0; i &lt; 4; i++)
    SV_PutByte((unsigned char) id[i]);
}
</t>
<t tx="T365">
const char *SV_GetString(void) 
{
  int len, i;
  char *result;
  
  int type = SV_GetByte();

  if (type == NULLSTR_MARKER)
    return NULL;
  
  if (type != STRING_MARKER)
    I_Error("Corrupt savegame (invalid string).\n");

  len = SV_GetShort();

  result = Z_New(char, len + 1);
  result[len] = 0;

  for (i = 0; i &lt; len; i++)
    result[i] = (char) SV_GetByte();

  // Intentional Const Override
  return (const char *) result;
}
</t>
<t tx="T366">
boolean_t SV_GetMarker(char id[5])
{ 
  int i;

  for (i=0; i &lt; 4; i++)
    id[i] = (char) SV_GetByte();

  id[4] = 0;

  return VerifyMarker(id);
}
</t>
<t tx="T367">@ignore
@language c

// New SaveGame Handling (Debugging)

// TODO HERE:
//   + DumpGLOB: handle Push/PopChunk in outer, not inner.
//   - implement DumpWADS and DumpVIEW.

&lt;&lt; sv_dump #includes &gt;&gt;
@others
</t>
<t tx="T368">#include "i_defs.h"
#include "sv_chunk.h"

#include "dm_state.h"
#include "e_main.h"
#include "g_game.h"
#include "m_math.h"
#include "m_random.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_state.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"
</t>
<t tx="T369">@ ----------------------------------------------------------------------------

DUMP GLOBALS
@c

static boolean_t GlobDumpVARI(void)
{
  const char *var_name;
  const char *var_data;

  if (! SV_PushReadChunk("Vari")) //!!!
    return false;

  var_name = SV_GetString();
  var_data = SV_GetString();

  if (! SV_PopReadChunk() || !var_name || !var_data)
  {
    if (var_name) Z_Free((char *)var_name);
    if (var_data) Z_Free((char *)var_data);

    return false;
  }
  
  L_WriteDebug("      Var: %s=%s\n", var_name, var_data);

  Z_Free((char *)var_name);
  Z_Free((char *)var_data);

  return true;
}
</t>
<t tx="T370">
static boolean_t GlobDumpWADS(void)
{
  L_WriteDebug("      Wad info\n");

  //!!! IMPLEMENT THIS
  return true;
}
</t>
<t tx="T371">
static boolean_t GlobDumpVIEW(void)
{
  L_WriteDebug("      Screenshot\n");

  //!!! IMPLEMENT THIS
  return true;
}
</t>
<t tx="T372">
static boolean_t SV_DumpGLOB(void)
{
  char marker[6];
  
  L_WriteDebug("   Global Area:\n");

  // read through all the chunks, picking the bits we need

  for (;;)
  {
    if (SV_GetError() != 0)
    {
      L_WriteDebug("   *  Unknown Error !\n");
      return false;
    }

    if (SV_RemainingChunkSize() &lt; 4)
      break;

    SV_GetMarker(marker);

    if (strcmp(marker, "Vari") == 0)
    {
      GlobDumpVARI();
      continue;
    }
    if (strcmp(marker, "Wads") == 0)
    {
      GlobDumpWADS();
      continue;
    }
    if (strcmp(marker, "View") == 0)
    {
      GlobDumpVIEW();
      continue;
    }

    // skip unknown chunk
    L_WriteDebug("      Unknown GLOB chunk [%s]\n", marker);
    
    if (! SV_SkipReadChunk(marker))
    {
      L_WriteDebug("   *  Skipping unknown chunk failed !\n");
      return false;
    }
  }

  L_WriteDebug("   *  End of globals\n");

  return true;
}
</t>
<t tx="T373">@ ----------------------------------------------------------------------------

DUMP STRUCTURE / ARRAY / DATA
@c

static boolean_t SV_DumpSTRU(void)
{
  const char *struct_name;
  const char *marker;

  int i, fields;

  fields = SV_GetInt();
  struct_name = SV_GetString();
  marker = SV_GetString();

  L_WriteDebug("   Struct def: %s  Fields: %d  Marker: [%s]\n",
      struct_name, fields, marker);

  Z_Free((char *)struct_name);
  Z_Free((char *)marker);

  // -- now dump all the fields --
  
  for (i=0; i &lt; fields; i++)
  {
    savefieldkind_e kind;
    int size, count;

    const char *field_name;
    const char *sub_type = NULL;
    char count_buf[40];

    kind = (savefieldkind_e) SV_GetByte();
    size = SV_GetByte();
    count = SV_GetShort();
    field_name = SV_GetString();

    if (kind == SFKIND_Struct ||
        kind == SFKIND_Index)
    {
      sub_type = SV_GetString();
    }

    if (count == 1)
      count_buf[0] = 0;
    else
      sprintf(count_buf, "[%d]", count);
    
    L_WriteDebug("      Field: %s%s  Kind: %s%s  Size: %d\n",
        field_name, count_buf,
        (kind == SFKIND_Numeric) ? "Numeric" :
        (kind == SFKIND_String) ? "String" :
        (kind == SFKIND_Index) ? "Index in " :
        (kind == SFKIND_Struct) ? "Struct " : "???",
        sub_type ? sub_type : "", size);

    Z_Free((char *)field_name);

    if (sub_type)
      Z_Free((char *)sub_type);
  }

  return true;
}
</t>
<t tx="T374">
static boolean_t SV_DumpARRY(void)
{
  const char *array_name;
  const char *struct_name;

  int count;

  count = SV_GetInt();
  array_name  = SV_GetString();
  struct_name = SV_GetString();
  
  L_WriteDebug("   Array def: %s  Count: %d  Struct: %s\n",
      array_name, count, struct_name);
  
  Z_Free((char *)array_name);
  Z_Free((char *)struct_name);

  return true;
}
</t>
<t tx="T375">
static boolean_t SV_DumpDATA(void)
{
  const char *array_name = SV_GetString();

  L_WriteDebug("   Data for array %s  Size: %d\n", array_name,
      SV_RemainingChunkSize());

  Z_Free((char *)array_name);

  return true;
}
</t>
<t tx="T376">@ ----------------------------------------------------------------------------

SV_DumpSaveGame

Dumps the contents of a savegame file to the debug file. Very
useful for debugging.
@c

void SV_DumpSaveGame(int slot)
{
  char *filename;
  int version;
//  boolean_t result;
  char marker[6];

  filename = G_FileNameFromSlot(slot);

  L_WriteDebug("DUMPING SAVE GAME: %d  FILE: %s\n", slot, filename);

  if (! SV_OpenReadFile(filename))
  {
    L_WriteDebug("*  Unable to open file !\n");
    Z_Free(filename);
    return;
  }
  
  L_WriteDebug("   File opened OK.\n");

  Z_Free(filename);

  if (! SV_VerifyHeader(&amp;version))
  {
    L_WriteDebug("*  VerifyHeader failed !\n");
    SV_CloseReadFile();
    return;
  }

  L_WriteDebug("   Header OK.  Version: %x.%02x  PL: %x\n",
      (version &gt;&gt; 16) &amp; 0xFF, (version &gt;&gt; 8) &amp; 0xFF, version &amp; 0xFF);
   
  if (! SV_VerifyContents())
  {
    L_WriteDebug("*  VerifyContents failed !\n");
    SV_CloseReadFile();
    return;
  }

  L_WriteDebug("   Body OK.\n");

  for (;;)
  {
    if (SV_GetError() != 0)
    {
      L_WriteDebug("   Unknown Error !\n");
      break;
    }

    SV_GetMarker(marker);

    if (strcmp(marker, DATA_END_MARKER) == 0)
    {
      L_WriteDebug("   End-of-Data marker found.\n");
      break;
    }
    
    // global area
    if (strcmp(marker, "Glob") == 0)
    {
      SV_PushReadChunk("Glob");

      if (! SV_DumpGLOB())
      {
        L_WriteDebug("   Error while dumping [GLOB]\n");
        break;
      }

      if (! SV_PopReadChunk())
      {
        L_WriteDebug("   Error popping [GLOB]\n");
        break;
      }

      continue;
    }
    
    // structure area
    if (strcmp(marker, "Stru") == 0)
    {
      SV_PushReadChunk("Stru");

      if (! SV_DumpSTRU())
      {
        L_WriteDebug("   Error while dumping [STRU]\n");
        break;
      }

      if (! SV_PopReadChunk())
      {
        L_WriteDebug("   Error popping [STRU]\n");
        break;
      }

      continue;
    }
    
    // array area
    if (strcmp(marker, "Arry") == 0)
    {
      SV_PushReadChunk("Arry");

      if (! SV_DumpARRY())
      {
        L_WriteDebug("   Error while dumping [ARRY]\n");
        break;
      }

      if (! SV_PopReadChunk())
      {
        L_WriteDebug("   Error popping [ARRY]\n");
        break;
      }

      continue;
    }

    // data area
    if (strcmp(marker, "Data") == 0)
    {
      SV_PushReadChunk("Data");

      if (! SV_DumpDATA())
      {
        L_WriteDebug("   Error while dumping [DATA]\n");
        break;
      }

      if (! SV_PopReadChunk())
      {
        L_WriteDebug("   Error popping [DATA]\n");
        break;
      }

      continue;
    }

    // skip unknown chunk
    L_WriteDebug("   Unknown top-level chunk [%s]\n", marker);

    if (! SV_SkipReadChunk(marker))
    {
      L_WriteDebug("   Skipping unknown chunk failed !\n");
      break;
    }
  }

  SV_CloseReadFile();

  L_WriteDebug("*  DUMP FINISHED\n");
}
</t>
<t tx="T377">@ignore
@language c

// New SaveGame Handling (Globals)

// TODO HERE:
//   + implement ReadWADS and ReadVIEW.

&lt;&lt; sv_glob #includes &gt;&gt;
&lt;&lt; sv_glob declarations &gt;&gt;
@others
</t>
<t tx="T378">#include "i_defs.h"
#include "sv_chunk.h"

#include "ddf_locl.h"  // needed for FIELD_OFF

#include "dm_state.h"
#include "e_main.h"
#include "g_game.h"
#include "m_math.h"
#include "m_random.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_state.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"
</t>
<t tx="T379">

// forward decls:
static void GV_GetInt(const char *info, void *storage);
static void GV_GetString(const char *info, void *storage);
static void GV_GetCheckCRC(const char *info, void *storage);
static void GV_GetLevelFlags(const char *info, void *storage);

static const char *GV_PutInt(void *storage);
static const char *GV_PutString(void *storage);
static const char *GV_PutCheckCRC(void *storage);
static const char *GV_PutLevelFlags(void *storage);


static saveglobals_t dummy_glob;
static saveglobals_t *cur_globs = NULL;

typedef struct
{
  // global name
  const char *name;

  // parse function.  `storage' is where the data should go (for
  // routines that don't modify the cur_globs structure directly).
  void (* parse_func)(const char *info, void *storage);

  // stringify function.  Return string must be freed.
  const char * (* stringify_func)(void *storage);

  // field offset
  int offset;
}
global_command_t;


#define GLOB_OFF(field)  FIELD_OFF(dummy_glob, field)

static const global_command_t global_commands[] =
{
  { "GAME",  GV_GetString, GV_PutString, GLOB_OFF(game) },
  { "LEVEL", GV_GetString, GV_PutString, GLOB_OFF(level) },
  { "FLAGS", GV_GetLevelFlags, GV_PutLevelFlags, GLOB_OFF(flags) },
  { "GRAVITY", GV_GetInt, GV_PutInt, GLOB_OFF(gravity) },
  { "LEVEL_TIME", GV_GetInt, GV_PutInt, GLOB_OFF(level_time) },
  { "P_RANDOM", GV_GetInt, GV_PutInt, GLOB_OFF(p_random) },
  { "TOTAL_KILLS",   GV_GetInt, GV_PutInt, GLOB_OFF(total_kills) },
  { "TOTAL_ITEMS",   GV_GetInt, GV_PutInt, GLOB_OFF(total_items) },
  { "TOTAL_SECRETS", GV_GetInt, GV_PutInt, GLOB_OFF(total_secrets) },
  { "CONSOLE_PLAYER", GV_GetInt, GV_PutInt, GLOB_OFF(console_player) },
  { "SKILL", GV_GetInt, GV_PutInt, GLOB_OFF(skill) },
  { "NETGAME", GV_GetInt, GV_PutInt, GLOB_OFF(netgame) },
  { "DESCRIPTION", GV_GetString, GV_PutString, GLOB_OFF(description) },
  { "DESC_DATE", GV_GetString, GV_PutString, GLOB_OFF(desc_date) },

  { "MAPSECTOR", GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(mapsector) },
  { "MAPLINE",   GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(mapline) },
  { "MAPTHING",  GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(mapthing) },

  { "RSCRIPT", GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(rscript) },
  { "DDFATK",  GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(ddfatk) },
  { "DDFGAME", GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(ddfgame) },
  { "DDFLEVL", GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(ddflevl) },
  { "DDFLINE", GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(ddfline) },
  { "DDFSECT", GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(ddfsect) },
  { "DDFMOBJ", GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(ddfmobj) },
  { "DDFWEAP", GV_GetCheckCRC, GV_PutCheckCRC, GLOB_OFF(ddfweap) },
  { NULL, NULL, 0 }
};
</t>
<t tx="T380">@ ----------------------------------------------------------------------------

PARSERS
@c

static void GV_GetInt(const char *info, void *storage)
{
  int *dest = (int *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  *dest = strtol(info, NULL, 0);
}
</t>
<t tx="T381">
static void GV_GetString(const char *info, void *storage)
{
  char **dest = (char **)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  // free any previous string
  if (*dest)
    Z_Free(*dest);

  if (info[0] == 0)
    *dest = NULL;
  else
    *dest = Z_StrDup(info);
}
</t>
<t tx="T382">
static void GV_GetCheckCRC(const char *info, void *storage)
{
  crc_check_t *dest = (crc_check_t *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  sscanf(info, "%d %ld", &amp;dest-&gt;count, &amp;dest-&gt;crc);
}
</t>
<t tx="T383">
static void GV_GetLevelFlags(const char *info, void *storage)
{
  gameflags_t *dest = (gameflags_t *)storage;
  int flags;

  DEV_ASSERT2(info &amp;&amp; storage);

  flags = strtol(info, NULL, 0);

  Z_Clear(dest, gameflags_t, 1);

  #define HANDLE_FLAG(var, specflag)  \
      (var) = (flags &amp; (specflag)) ? true : false;

  HANDLE_FLAG(dest-&gt;jump, MPF_Jumping);
  HANDLE_FLAG(dest-&gt;crouch, MPF_Crouching);
  HANDLE_FLAG(dest-&gt;mlook, MPF_Mlook);
  HANDLE_FLAG(dest-&gt;itemrespawn, MPF_ItemRespawn);
  HANDLE_FLAG(dest-&gt;fastparm, MPF_FastParm);
  HANDLE_FLAG(dest-&gt;true3dgameplay, MPF_True3D);
  HANDLE_FLAG(dest-&gt;more_blood, MPF_MoreBlood);
  HANDLE_FLAG(dest-&gt;cheats, MPF_Cheats);
  HANDLE_FLAG(dest-&gt;trans, MPF_Translucency);
  HANDLE_FLAG(dest-&gt;respawn, MPF_Respawn);
  HANDLE_FLAG(dest-&gt;res_respawn, MPF_ResRespawn);
  HANDLE_FLAG(dest-&gt;have_extra, MPF_Extras);
  HANDLE_FLAG(dest-&gt;limit_zoom, MPF_LimitZoom);
  HANDLE_FLAG(dest-&gt;shadows, MPF_Shadows);
  HANDLE_FLAG(dest-&gt;halos, MPF_Halos);
  HANDLE_FLAG(dest-&gt;kicking, MPF_Kicking);

  #undef HANDLE_FLAG

  dest-&gt;compat_mode = (flags &amp; MPF_BoomCompat) ? CM_BOOM : CM_EDGE;
    
  dest-&gt;autoaim = (flags &amp; MPF_AutoAim) ? 
      ((flags &amp; MPF_AutoAimMlook) ? AA_MLOOK : AA_ON) : AA_OFF;
}
</t>
<t tx="T384">@ ----------------------------------------------------------------------------

STRINGIFIERS
@c

static const char *GV_PutInt(void *storage)
{
  int *src = (int *)storage;
  char buffer[40];

  DEV_ASSERT2(storage);

  sprintf(buffer, "%d", *src);

  return Z_StrDup(buffer);
}
</t>
<t tx="T385">
static const char *GV_PutString(void *storage)
{
  char **src = (char **)storage;

  DEV_ASSERT2(storage);

  if (*src == NULL)
    return (const char *) Z_ClearNew(char, 1);

  return Z_StrDup(*src);
}
</t>
<t tx="T386">
static const char *GV_PutCheckCRC(void *storage)
{
  crc_check_t *src = (crc_check_t *)storage;
  char buffer[80];

  DEV_ASSERT2(storage);

  sprintf(buffer, "%d %ld", src-&gt;count, src-&gt;crc);

  return Z_StrDup(buffer);
}
</t>
<t tx="T387">
static const char *GV_PutLevelFlags(void *storage)
{
  gameflags_t *src = (gameflags_t *)storage;
  int flags;

  DEV_ASSERT2(storage);

  flags = 0;

  #define HANDLE_FLAG(var, specflag)  \
      if (var) flags |= (specflag);

  HANDLE_FLAG(src-&gt;jump, MPF_Jumping);
  HANDLE_FLAG(src-&gt;crouch, MPF_Crouching);
  HANDLE_FLAG(src-&gt;mlook, MPF_Mlook);
  HANDLE_FLAG(src-&gt;itemrespawn, MPF_ItemRespawn);
  HANDLE_FLAG(src-&gt;fastparm, MPF_FastParm);
  HANDLE_FLAG(src-&gt;true3dgameplay, MPF_True3D);
  HANDLE_FLAG(src-&gt;more_blood, MPF_MoreBlood);
  HANDLE_FLAG(src-&gt;cheats, MPF_Cheats);
  HANDLE_FLAG(src-&gt;trans, MPF_Translucency);
  HANDLE_FLAG(src-&gt;respawn, MPF_Respawn);
  HANDLE_FLAG(src-&gt;res_respawn, MPF_ResRespawn);
  HANDLE_FLAG(src-&gt;have_extra, MPF_Extras);
  HANDLE_FLAG(src-&gt;limit_zoom, MPF_LimitZoom);
  HANDLE_FLAG(src-&gt;shadows, MPF_Shadows);
  HANDLE_FLAG(src-&gt;halos, MPF_Halos);
  HANDLE_FLAG(src-&gt;kicking, MPF_Kicking);

  #undef HANDLE_FLAG

  if (src-&gt;compat_mode == CM_BOOM)
    flags |= MPF_BoomCompat;

  if (src-&gt;autoaim != AA_OFF)
    flags |= MPF_AutoAim;
  if (src-&gt;autoaim == AA_MLOOK)
    flags |= MPF_AutoAimMlook;

  return GV_PutInt(&amp;flags);
}
</t>
<t tx="T388">@ ----------------------------------------------------------------------------

MISCELLANY
@c

saveglobals_t *SV_NewGLOB(void)
{
  saveglobals_t *globs;

  globs = Z_ClearNew(saveglobals_t, 1);

  return globs;
}
</t>
<t tx="T389">
void SV_FreeGLOB(saveglobals_t *globs)
{
  if (globs-&gt;game)
    Z_Free((char *)globs-&gt;game);

  if (globs-&gt;level)
    Z_Free((char *)globs-&gt;level);

  if (globs-&gt;description)
    Z_Free((char *)globs-&gt;description);

  if (globs-&gt;desc_date)
    Z_Free((char *)globs-&gt;desc_date);

  if (globs-&gt;view_pixels)
    Z_Free(globs-&gt;view_pixels);

  if (globs-&gt;wad_names)
    Z_Free(globs-&gt;wad_names);

  Z_Free(globs);
}
</t>
<t tx="T390">@ ----------------------------------------------------------------------------

LOADING GLOBALS
@c

static boolean_t GlobReadVARI(saveglobals_t *globs)
{
  const char *var_name;
  const char *var_data;

  int i;
  void *storage;

  if (! SV_PushReadChunk("Vari"))
    return false;

  var_name = SV_GetString();
  var_data = SV_GetString();

  if (! SV_PopReadChunk() || !var_name || !var_data)
  {
    if (var_name) Z_Free((char *)var_name);
    if (var_data) Z_Free((char *)var_data);

    return false;
  }
  
  // find variable in list 
  for (i=0; global_commands[i].name; i++)
  {
    if (strcmp(global_commands[i].name, var_name) == 0)
      break;
  }

  if (global_commands[i].name)
  {
    // found it, so parse it
    storage = ((char *) globs) + global_commands[i].offset;

    (* global_commands[i].parse_func)(var_data, storage);
  }
  else
  {
    I_Warning("GlobReadVARI: unknown global: %s\n", var_name);
  }

  Z_Free((char *)var_name);
  Z_Free((char *)var_data);

  return true;
}
</t>
<t tx="T391">
static boolean_t GlobReadWADS(saveglobals_t *glob)
{
  //!!! IMPLEMENT THIS
  return true;
}
</t>
<t tx="T392">
static boolean_t GlobReadVIEW(saveglobals_t *glob)
{
  //!!! IMPLEMENT THIS
  return true;
}
</t>
<t tx="T393">@ SV_LoadGLOB
@c

saveglobals_t *SV_LoadGLOB(void)
{
  char marker[6];
  
  saveglobals_t *globs;

  SV_GetMarker(marker);

  if (strcmp(marker, "Glob") != 0 || ! SV_PushReadChunk("Glob"))
    return false;

  cur_globs = globs = SV_NewGLOB();

  // read through all the chunks, picking the bits we need

  for (;;)
  {
    if (SV_GetError() != 0)
      break;  /// set error !!

    if (SV_RemainingChunkSize() == 0)
      break;

    SV_GetMarker(marker);

    if (strcmp(marker, "Vari") == 0)
    {
      GlobReadVARI(globs);
      continue;
    }
    if (strcmp(marker, "Wads") == 0)
    {
      GlobReadWADS(globs);
      continue;
    }
    if (strcmp(marker, "View") == 0)
    {
      GlobReadVIEW(globs);
      continue;
    }

    // skip chunk
    I_Warning("LOADGAME: Unknown GLOB chunk [%s]\n", marker);
    
    if (! SV_SkipReadChunk(marker))
      break;
  }

  SV_PopReadChunk();  /// check err

  return globs;
}
</t>
<t tx="T394">@ ----------------------------------------------------------------------------

SAVING GLOBALS
@c

static void GlobWriteVARIs(saveglobals_t *globs)
{
  int i;

  for (i=0; global_commands[i].name; i++)
  {
    const char *data;
    void *storage = ((char *) globs) + global_commands[i].offset;
    
    data = (* global_commands[i].stringify_func)(storage);
    DEV_ASSERT2(data);
     
    SV_PushWriteChunk("Vari");
    SV_PutString(global_commands[i].name);
    SV_PutString(data);
    SV_PopWriteChunk();

    Z_Free((char *)data);
  }
}
</t>
<t tx="T395">
static void GlobWriteWADS(saveglobals_t *globs)
{
  int i;
  
  if (! globs-&gt;wad_names)
    return;

  DEV_ASSERT2(globs-&gt;wad_num &gt; 0);

  SV_PushWriteChunk("Wads");
  SV_PutInt(globs-&gt;wad_num);
 
  for (i=0; i &lt; globs-&gt;wad_num; i++)
    SV_PutString(globs-&gt;wad_names[i]);

  SV_PopWriteChunk();
}
</t>
<t tx="T396">
static void GlobWriteVIEW(saveglobals_t *globs)
{
  int x, y;
  
  if (! globs-&gt;view_pixels)
    return;

  DEV_ASSERT2(globs-&gt;view_width  &gt; 0);
  DEV_ASSERT2(globs-&gt;view_height &gt; 0);

  SV_PushWriteChunk("View");

  SV_PutInt(globs-&gt;view_width);
  SV_PutInt(globs-&gt;view_height);
  
  for (y=0; y &lt; globs-&gt;view_height; y++)
  for (x=0; x &lt; globs-&gt;view_width;  x++)
  {
    SV_PutShort(globs-&gt;view_pixels[y * globs-&gt;view_width + x]);
  }

  SV_PopWriteChunk();
}
</t>
<t tx="T397">@ SV_SaveGLOB
@c

void SV_SaveGLOB(saveglobals_t *globs)
{
  cur_globs = globs;

  SV_PushWriteChunk("Glob");

  GlobWriteVARIs(globs);
  GlobWriteWADS(globs);
  GlobWriteVIEW(globs);

  // all done
  SV_PopWriteChunk();
}
</t>
<t tx="T398">@ignore
@language c

// New SaveGame Handling (Level Data)

// This file handles:
//    surface_t      [SURF]
//    side_t         [SIDE]
//    line_t         [LINE]
//
//    region_properties_t  [RPRP]
//    extrafloor_t         [EXFL]
//    sector_t             [SECT]
// 

&lt;&lt; sv_level #includes &gt;&gt;
&lt;&lt; sv_level declarations &gt;&gt;
@others
#endif

</t>
<t tx="T399">#include "i_defs.h"

#include "dm_state.h"
#include "e_player.h"
#include "p_local.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "r_state.h"
#include "z_zone.h"
</t>
<t tx="T400">
#undef SF
#define SF  SVFIELD


// forward decls.
int SV_SideCountElems(void);
int SV_SideFindElem(side_t *elem);
void * SV_SideGetElem(int index);
void SV_SideCreateElems(int num_elems);
void SV_SideFinaliseElems(void);

int SV_LineCountElems(void);
int SV_LineFindElem(line_t *elem);
void * SV_LineGetElem(int index);
void SV_LineCreateElems(int num_elems);
void SV_LineFinaliseElems(void);

int SV_ExfloorCountElems(void);
int SV_ExfloorFindElem(extrafloor_t *elem);
void * SV_ExfloorGetElem(int index);
void SV_ExfloorCreateElems(int num_elems);
void SV_ExfloorFinaliseElems(void);

int SV_SectorCountElems(void);
int SV_SectorFindElem(sector_t *elem);
void * SV_SectorGetElem(int index);
void SV_SectorCreateElems(int num_elems);
void SV_SectorFinaliseElems(void);

boolean_t SR_LevelGetImage(void *storage, int index, void *extra);
boolean_t SR_LevelGetColmap(void *storage, int index, void *extra);
boolean_t SR_LevelGetSurface(void *storage, int index, void *extra);
boolean_t SR_LevelGetSurfPtr(void *storage, int index, void *extra);
boolean_t SR_LineGetSpecial(void *storage, int index, void *extra);
boolean_t SR_SectorGetSpecial(void *storage, int index, void *extra);
boolean_t SR_SectorGetProps(void *storage, int index, void *extra);
boolean_t SR_SectorGetPropRef(void *storage, int index, void *extra);
boolean_t SR_SectorGetGenMove(void *storage, int index, void *extra);

void SR_LevelPutImage(void *storage, int index, void *extra);
void SR_LevelPutColmap(void *storage, int index, void *extra);
void SR_LevelPutSurface(void *storage, int index, void *extra);
void SR_LevelPutSurfPtr(void *storage, int index, void *extra);
void SR_LinePutSpecial(void *storage, int index, void *extra);
void SR_SectorPutSpecial(void *storage, int index, void *extra);
void SR_SectorPutProps(void *storage, int index, void *extra);
void SR_SectorPutPropRef(void *storage, int index, void *extra);
void SR_SectorPutGenMove(void *storage, int index, void *extra);


//----------------------------------------------------------------------------
//
//  SURFACE STRUCTURE
//
static surface_t sv_dummy_surface;

#define SV_F_BASE  sv_dummy_surface

static savefield_t sv_fields_surface[] =
{
  SF(image, "image", 1, SVT_STRING, SR_LevelGetImage, SR_LevelPutImage),
  SF(translucency, "translucency", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),

  SF(offset, "offset", 1, SVT_VEC2, SR_GetVec2, SR_PutVec2),
  SF(scroll, "scroll", 1, SVT_VEC2, SR_GetVec2, SR_PutVec2),
  SF(x_mat, "x_mat", 1, SVT_VEC2, SR_GetVec2, SR_PutVec2),
  SF(y_mat, "y_mat", 1, SVT_VEC2, SR_GetVec2, SR_PutVec2),

  SF(override_p, "override_p", 1, SVT_STRING, 
      SR_SectorGetPropRef, SR_SectorPutPropRef),

  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_surface =
{
  NULL,                  // link in list
  "surface_t",           // structure name
  "surf",                // start marker
  sv_fields_surface,     // field descriptions
  true,                  // define_me
  NULL                   // pointer to known struct
};


//----------------------------------------------------------------------------
//
//  SIDE STRUCTURE
//
static side_t sv_dummy_side;

#define SV_F_BASE  sv_dummy_side

static savefield_t sv_fields_side[] =
{
  SF(top, "top", 1, SVT_STRUCT("surface_t"), 
      SR_LevelGetSurface, SR_LevelPutSurface),
  SF(middle, "middle", 1, SVT_STRUCT("surface_t"), 
      SR_LevelGetSurface, SR_LevelPutSurface),
  SF(bottom, "bottom", 1, SVT_STRUCT("surface_t"), 
      SR_LevelGetSurface, SR_LevelPutSurface),

  // NOT HERE:
  //   sector: value is kept from level load.
 
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_side =
{
  NULL,          // link in list
  "side_t",      // structure name
  "side",        // start marker
  sv_fields_side,  // field descriptions
  true,          // define_me
  NULL           // pointer to known struct
};

savearray_t sv_array_side =
{
  NULL,               // link in list
  "sides",            // array name
  &amp;sv_struct_side,    // array type
  true,               // define_me

  SV_SideCountElems,     // count routine
  SV_SideGetElem,        // index routine
  SV_SideCreateElems,    // creation routine
  SV_SideFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  LINE STRUCTURE
//
static line_t sv_dummy_line;

#define SV_F_BASE  sv_dummy_line

static savefield_t sv_fields_line[] =
{
  SF(flags, "flags", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(tag,   "tag",   1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(count, "count", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(special, "special", 1, SVT_STRING, SR_LineGetSpecial, SR_LinePutSpecial),

  // NOT HERE:
  //   (many): values are kept from level load.
  //   gap stuff: regenerated from sector heights.
  //   validcount: only a temporary value for some routines.
  //   slider_move: regenerated by a pass of the active part list.
  //   animate_next: regenerated by testing stuff.
 
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_line =
{
  NULL,          // link in list
  "line_t",      // structure name
  "line",        // start marker
  sv_fields_line,  // field descriptions
  true,          // define_me
  NULL           // pointer to known struct
};

savearray_t sv_array_line =
{
  NULL,               // link in list
  "lines",            // array name
  &amp;sv_struct_line,    // array type
  true,               // define_me

  SV_LineCountElems,     // count routine
  SV_LineGetElem,        // index routine
  SV_LineCreateElems,    // creation routine
  SV_LineFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  REGION_PROPERTIES STRUCTURE
//
static region_properties_t sv_dummy_regprops;

#define SV_F_BASE  sv_dummy_regprops

static savefield_t sv_fields_regprops[] =
{
  SF(lightlevel, "lightlevel_i", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(colourmap,  "colourmap", 1, SVT_STRING, SR_LevelGetColmap, 
      SR_LevelPutColmap),
  SF(special, "special", 1, SVT_STRING, SR_SectorGetSpecial, 
      SR_SectorPutSpecial),

  SF(gravity, "gravity", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(friction, "friction", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(viscosity, "viscosity", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(drag, "drag", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(push, "push", 1, SVT_VEC3, SR_GetVec3, SR_PutVec3),
 
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_regprops =
{
  NULL,                   // link in list
  "region_properties_t",  // structure name
  "rprp",                 // start marker
  sv_fields_regprops,     // field descriptions
  true,                   // define_me
  NULL                    // pointer to known struct
};


//----------------------------------------------------------------------------
//
//  EXTRAFLOOR STRUCTURE
//
static extrafloor_t sv_dummy_exfloor;

#define SV_F_BASE  sv_dummy_exfloor

static savefield_t sv_fields_exfloor[] =
{
  SF(higher, "higher", 1, SVT_INDEX("extrafloors"),
      SR_SectorGetEF, SR_SectorPutEF),
  SF(lower, "lower", 1, SVT_INDEX("extrafloors"),
      SR_SectorGetEF, SR_SectorPutEF),
  SF(sector, "sector", 1, SVT_INDEX("sectors"), 
      SR_SectorGetSector, SR_SectorPutSector),

  SF(top_h, "top_h", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(bottom_h, "bottom_h", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(top, "top", 1, SVT_STRING, 
      SR_LevelGetSurfPtr, SR_LevelPutSurfPtr),
  SF(bottom, "bottom", 1, SVT_STRING, 
      SR_LevelGetSurfPtr, SR_LevelPutSurfPtr),
  SF(p, "p", 1, SVT_STRING, SR_SectorGetPropRef, SR_SectorPutPropRef),

  SF(ef_line, "ef_line", 1, SVT_INDEX("lines"), 
      SR_LineGetLine, SR_LinePutLine),
  SF(ctrl_next, "ctrl_next", 1, SVT_INDEX("extrafloors"),
      SR_SectorGetEF, SR_SectorPutEF),

  // NOT HERE:
  //   - sector: can be regenerated.
  //   - ef_info: cached value, regenerated from ef_line.
 
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_exfloor =
{
  NULL,              // link in list
  "extrafloor_t",    // structure name
  "exfl",            // start marker
  sv_fields_exfloor, // field descriptions
  true,              // define_me
  NULL               // pointer to known struct
};

savearray_t sv_array_exfloor =
{
  NULL,               // link in list
  "extrafloors",      // array name
  &amp;sv_struct_exfloor, // array type
  true,               // define_me

  SV_ExfloorCountElems,     // count routine
  SV_ExfloorGetElem,        // index routine
  SV_ExfloorCreateElems,    // creation routine
  SV_ExfloorFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  SECTOR STRUCTURE
//
static sector_t sv_dummy_sector;

#define SV_F_BASE  sv_dummy_sector

static savefield_t sv_fields_sector[] =
{
  SF(floor, "floor", 1, SVT_STRUCT("surface_t"), 
      SR_LevelGetSurface, SR_LevelPutSurface),
  SF(ceil, "ceil", 1, SVT_STRUCT("surface_t"), 
      SR_LevelGetSurface, SR_LevelPutSurface),
  SF(f_h, "f_h", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(c_h, "c_h", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),

  SF(props, "props", 1, SVT_STRUCT("region_properties_t"), 
      SR_SectorGetProps, SR_SectorPutProps),
  SF(p, "p", 1, SVT_STRING, SR_SectorGetPropRef, SR_SectorPutPropRef),

  SF(exfloor_used, "exfloor_used", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(control_floors, "control_floors", 1, SVT_INDEX("extrafloors"),
      SR_SectorGetEF, SR_SectorPutEF),
  SF(sound_player, "sound_player", 1, SVT_INT, SR_GetInt, SR_PutInt),
 
  SF(bottom_ef, "bottom_ef", 1, SVT_INDEX("extrafloors"),
      SR_SectorGetEF, SR_SectorPutEF),
  SF(top_ef, "top_ef", 1, SVT_INDEX("extrafloors"),
      SR_SectorGetEF, SR_SectorPutEF),
  SF(bottom_liq, "bottom_liq", 1, SVT_INDEX("extrafloors"),
      SR_SectorGetEF, SR_SectorPutEF),
  SF(top_liq, "top_liq", 1, SVT_INDEX("extrafloors"),
      SR_SectorGetEF, SR_SectorPutEF),

  // NOT HERE:
  //   - floor_move, ceil_move: can be regenerated
  //   - (many): values remaining from level load are OK
  //   - soundtraversed &amp; validcount: temp values, don't need saving
  //   - animate_next: regenerated by testing stuff.

  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_sector =
{
  NULL,              // link in list
  "sector_t",        // structure name
  "sect",            // start marker
  sv_fields_sector,  // field descriptions
  true,              // define_me
  NULL               // pointer to known struct
};

savearray_t sv_array_sector =
{
  NULL,               // link in list
  "sectors",          // array name
  &amp;sv_struct_sector,  // array type
  true,               // define_me

  SV_SectorCountElems,     // count routine
  SV_SectorGetElem,        // index routine
  SV_SectorCreateElems,    // creation routine
  SV_SectorFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};
</t>
<t tx="T401">@ ----------------------------------------------------------------------------

SV_SideCountElems
@c

int SV_SideCountElems(void)
{
  return numsides;
}
</t>
<t tx="T402">@ SV_SideGetElem
@c

void *SV_SideGetElem(int index)
{
  if (index &lt; 0 || index &gt;= numsides)
  {
    I_Warning("LOADGAME: Invalid Side: %d\n", index);
    index = 0;
  }
  
  return sides + index;
}
</t>
<t tx="T403">@ SV_SideFindElem
@c

int SV_SideFindElem(side_t *elem)
{
  DEV_ASSERT2(sides &lt;= elem &amp;&amp; elem &lt; (sides + numsides));

  return elem - sides;
}
</t>
<t tx="T404">@ SV_SideCreateElems
@c

void SV_SideCreateElems(int num_elems)
{
  /* nothing much to do -- sides created from level load, and defaults
   * are initialised there.
   */

  if (num_elems != numsides)
    I_Error("LOADGAME: SIDE MISMATCH !  (%d != %d)\n",
        num_elems, numsides);
}
</t>
<t tx="T405">@ SV_SideFinaliseElems
@c

void SV_SideFinaliseElems(void)
{
  /* nothing to do */
}
</t>
<t tx="T406">@ ----------------------------------------------------------------------------

SV_LineCountElems
@c

int SV_LineCountElems(void)
{
  return numlines;
}
</t>
<t tx="T407">@ SV_LineGetElem
@c

void *SV_LineGetElem(int index)
{
  if (index &lt; 0 || index &gt;= numlines)
  {
    I_Warning("LOADGAME: Invalid Line: %d\n", index);
    index = 0;
  }
  
  return lines + index;
}
</t>
<t tx="T408">@ SV_LineFindElem
@c

int SV_LineFindElem(line_t *elem)
{
  DEV_ASSERT2(lines &lt;= elem &amp;&amp; elem &lt; (lines + numlines));

  return elem - lines;
}
</t>
<t tx="T409">@ SV_LineCreateElems
@c

void SV_LineCreateElems(int num_elems)
{
  /* nothing much to do -- lines are created from level load, and
   * defaults are initialised there.
   */

  if (num_elems != numlines)
    I_Error("LOADGAME: LINE MISMATCH !  (%d != %d)\n",
        num_elems, numlines);

  // clear animate list
  line_speciallist = NULL;
}
</t>
<t tx="T410">@ SV_LineFinaliseElems

NOTE: line gaps done in Sector finaliser.
@c

void SV_LineFinaliseElems(void)
{
  int i;
  
  gen_move_t *gen;
  slider_move_t *smov;

  // clear animate list
  line_speciallist = NULL;

  for (i=0; i &lt; numlines; i++)
  {
    line_t *ld = lines + i;
    side_t *s1, *s2;

    s1 = ld-&gt;side[0];
    s2 = ld-&gt;side[1];

    // check for animation
    if (s1 &amp;&amp; (s1-&gt;top.scroll.x || s1-&gt;top.scroll.y ||
        s1-&gt;middle.scroll.x || s1-&gt;middle.scroll.y ||
        s1-&gt;bottom.scroll.x || s1-&gt;bottom.scroll.y))
    {
      P_AddSpecialLine(ld);
    }

    if (s2 &amp;&amp; (s2-&gt;top.scroll.x || s2-&gt;top.scroll.y ||
        s2-&gt;middle.scroll.x || s2-&gt;middle.scroll.y ||
        s2-&gt;bottom.scroll.x || s2-&gt;bottom.scroll.y))
    {
      P_AddSpecialLine(ld);
    }
  }
  
  // scan active parts, regenerate slider_move field
  for (gen = active_movparts; gen; gen = gen-&gt;next)
  {
    if (gen-&gt;whatiam != MDT_SLIDER)
      continue;

    smov = (slider_move_t *)gen;
    DEV_ASSERT2(smov-&gt;line);

    smov-&gt;line-&gt;slider_move = smov;
  }
}
</t>
<t tx="T411">@ ----------------------------------------------------------------------------

SV_ExfloorCountElems
@c

int SV_ExfloorCountElems(void)
{
  return numextrafloors;
}
</t>
<t tx="T412">@ SV_ExfloorGetElem
@c

void *SV_ExfloorGetElem(int index)
{
  if (index &lt; 0 || index &gt;= numextrafloors)
  {
    I_Warning("LOADGAME: Invalid Extrafloor: %d\n", index);
    index = 0;
  }
  
  return extrafloors + index;
}
</t>
<t tx="T413">@ SV_ExfloorFindElem
@c

int SV_ExfloorFindElem(extrafloor_t *elem)
{
  DEV_ASSERT2(extrafloors &lt;= elem &amp;&amp; elem &lt; (extrafloors + numextrafloors));

  return elem - extrafloors;
}
</t>
<t tx="T414">@ SV_ExfloorCreateElems
@c

void SV_ExfloorCreateElems(int num_elems)
{
  /* nothing much to do -- extrafloors are created from level load, and
   * defaults are initialised there.
   */

  if (num_elems != numextrafloors)
    I_Error("LOADGAME: Extrafloor MISMATCH !  (%d != %d)\n",
        num_elems, numextrafloors);
}
</t>
<t tx="T415">@ SV_ExfloorFinaliseElems
@c

void SV_ExfloorFinaliseElems(void)
{
  int i;

  // need to regenerate the ef_info fields
  for (i=0; i &lt; numextrafloors; i++)
  {
    extrafloor_t *ef = extrafloors + i;

    // skip unused extrafloors
    if (ef-&gt;ef_line == NULL)
      continue;

    if (!ef-&gt;ef_line-&gt;special ||
        !(ef-&gt;ef_line-&gt;special-&gt;ef.type &amp; EXFL_Present))
    {
      I_Warning("LOADGAME: Missing Extrafloor Special !\n");
      ef-&gt;ef_info = &amp;ddf_linetypes[0]-&gt;ef;
      continue;
    }

    ef-&gt;ef_info = &amp;ef-&gt;ef_line-&gt;special-&gt;ef;
  }
}
</t>
<t tx="T416">@ ----------------------------------------------------------------------------

SV_SectorCountElems
@c

int SV_SectorCountElems(void)
{
  return numsectors;
}
</t>
<t tx="T417">@ SV_SectorGetElem
@c

void *SV_SectorGetElem(int index)
{
  if (index &lt; 0 || index &gt;= numsectors)
  {
    I_Warning("LOADGAME: Invalid Sector: %d\n", index);
    index = 0;
  }
  
  return sectors + index;
}
</t>
<t tx="T418">@ SV_SectorFindElem
@c

int SV_SectorFindElem(sector_t *elem)
{
  DEV_ASSERT2(sectors &lt;= elem &amp;&amp; elem &lt; (sectors + numsectors));

  return elem - sectors;
}
</t>
<t tx="T419">@ SV_SectorCreateElems
@c

void SV_SectorCreateElems(int num_elems)
{
  /* nothing much to do -- sectors are created from level load, and
   * defaults are initialised there.
   */

  if (num_elems != numsectors)
    I_Error("LOADGAME: SECTOR MISMATCH !  (%d != %d)\n",
        num_elems, numsectors);
}
</t>
<t tx="T420">@ SV_SectorFinaliseElems
@c

void SV_SectorFinaliseElems(void)
{
  int i;
  
  gen_move_t *gen;
  plane_move_t *pmov;

  // clear animate list
  sect_speciallist = NULL;

  for (i=0; i &lt; numsectors; i++)
  {
    sector_t *sec = sectors + i;

    P_RecomputeGapsAroundSector(sec);
    P_RecomputeTilesInSector(sec);
    P_FloodExtraFloors(sec);

    // check for animation
    if (sec-&gt;floor.scroll.x || sec-&gt;floor.scroll.y ||
        sec-&gt;ceil.scroll.x  || sec-&gt;ceil.scroll.y)
    {
      P_AddSpecialSector(sec);
    }
  }
  
  // scan active parts, regenerate floor_move and ceil_move
  for (gen = active_movparts; gen; gen = gen-&gt;next)
  {
    switch (gen-&gt;whatiam)
    {
      case MDT_PLANE:
        pmov = (plane_move_t *)gen;
        DEV_ASSERT2(pmov-&gt;sector);
        
        if (pmov-&gt;is_ceiling)
          pmov-&gt;sector-&gt;ceil_move = gen;
        else
          pmov-&gt;sector-&gt;floor_move = gen;
        break;

      default:
        break;
    }
  }
}
</t>
<t tx="T421">@ ----------------------------------------------------------------------------

SR_LevelGetSurface
@c

boolean_t SR_LevelGetSurface(void *storage, int index, void *extra)
{
  surface_t *dest = (surface_t *)storage + index;

  if (! sv_struct_surface.counterpart)
    return true;

  return SV_LoadStruct(dest, sv_struct_surface.counterpart);
}
</t>
<t tx="T422">@ SR_LevelPutSurface
@c

void SR_LevelPutSurface(void *storage, int index, void *extra)
{
  surface_t *src = (surface_t *)storage + index;

  SV_SaveStruct(src, &amp;sv_struct_surface);
}
</t>
<t tx="T423">@ SR_LevelGetSurfPtr
@c

boolean_t SR_LevelGetSurfPtr(void *storage, int index, void *extra)
{
  surface_t ** dest = (surface_t **)storage + index;

  const char *str;
  int num;

  str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  if (str[1] != ':')
    I_Error("SR_LevelGetSurfPtr: invalid surface string `%s'\n", str);

  num = strtol(str+2, NULL, 0);

  if (num &lt; 0 || num &gt;= numsectors)
  {
    I_Warning("SR_LevelGetSurfPtr: bad sector ref %d\n", num);
    num = 0;
  }

  if (str[0] == 'F')
    (*dest) = &amp;sectors[num].floor;
  else if (str[0] == 'C')
    (*dest) = &amp;sectors[num].ceil;
  else
    I_Error("SR_LevelGetSurfPtr: invalid surface plane `%s'\n", str);

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T424">@ SR_LevelPutSurfPtr

Format of the string:

&lt;floor/ceil&gt; `:' &lt;sector num&gt;

The first character is `F' for the floor surface of the sector,
otherwise `C' for its ceiling.
@c

void SR_LevelPutSurfPtr(void *storage, int index, void *extra)
{
  surface_t *src = ((surface_t **)storage)[index];

  char buffer[64];
  int i;

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  // not optimal, but safe
  for (i=0; i &lt; numsectors; i++)
  {
    if (src == &amp;sectors[i].floor)
    {
      sprintf(buffer, "F:%d", i);
      SV_PutString(buffer);
      return;
    }
    else if (src == &amp;sectors[i].ceil)
    {
      sprintf(buffer, "C:%d", i);
      SV_PutString(buffer);
      return;
    }
  }
   
  I_Warning("SR_LevelPutSurfPtr: surface %p not found !\n", src);
  SV_PutString("F:0");
}
</t>
<t tx="T425">@ SR_LevelGetImage
@c

boolean_t SR_LevelGetImage(void *storage, int index, void *extra)
{
  const image_t ** dest = (const image_t **)storage + index;
  const char *str;

  str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  if (str[1] != ':')
    I_Warning("SR_LevelGetImage: invalid image string `%s'\n", str);

  (*dest) = W_ImageFromString(str[0], str + 2);

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T426">@ SR_LevelPutImage

Format of the string is:

&lt;type char&gt; `:' &lt;name&gt;

The type character is `F' for flat, `T' for texture, etc etc..
Also `*' is valid and means that type is not important. Some
examples: "F:FLAT10" and "T:STARTAN3".
@c

void SR_LevelPutImage(void *storage, int index, void *extra)
{
  const image_t *src = ((const image_t **)storage)[index];

  char buffer[64];

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  W_ImageToString(src, buffer, buffer + 2);
  buffer[1] = ':';

  SV_PutString(buffer);
}
</t>
<t tx="T427">@ SR_LevelGetColmap
@c

boolean_t SR_LevelGetColmap(void *storage, int index, void *extra)
{
  const colourmap_t ** dest = (const colourmap_t **)storage + index;
  const char *str;

  str = SV_GetString();

  if (! str)
    I_Error("SR_LevelGetColmap: NULL found !\n");

  (*dest) = DDF_ColmapLookup(str);

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T428">@ SR_LevelPutColmap

The string is the name of the colourmap. NULL strings are not
allowed or used.
@c

void SR_LevelPutColmap(void *storage, int index, void *extra)
{
  const colourmap_t *src = ((const colourmap_t **)storage)[index];

  DEV_ASSERT2(src);

  SV_PutString(src-&gt;ddf.name);
}
</t>
<t tx="T429">@ SR_LineGetSpecial
@c

boolean_t SR_LineGetSpecial(void *storage, int index, void *extra)
{
  const linedeftype_t ** dest = (const linedeftype_t **)storage + index;
  const char *str;

  str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  if (str[0] != ':')
    I_Error("SR_LineGetSpecial: invalid special `%s'\n", str);

  (*dest) = DDF_LineLookupNum(strtol(str+1, NULL, 0));

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T430">@ SR_LinePutSpecial

Format of the string will usually be a colon followed by the
linedef number (e.g. ":123"). Alternatively it can be the ddf
name, but this shouldn't be needed currently (reserved for future
use).
@c

void SR_LinePutSpecial(void *storage, int index, void *extra)
{
  const linedeftype_t *src = ((const linedeftype_t **)storage)[index];

  char buffer[64];

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  sprintf(buffer, ":%d", src-&gt;ddf.number);
  SV_PutString(buffer);
}
</t>
<t tx="T431">@ SR_SectorGetSpecial
@c

boolean_t SR_SectorGetSpecial(void *storage, int index, void *extra)
{
  const specialsector_t ** dest = (const specialsector_t **)storage + index;
  const char *str;

  str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  if (str[0] != ':')
    I_Error("SR_SectorGetSpecial: invalid special `%s'\n", str);

  (*dest) = DDF_SectorLookupNum(strtol(str+1, NULL, 0));

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T432">@ SR_SectorPutSpecial

Format of the string will usually be a colon followed by the
sector number (e.g. ":123"). Alternatively it can be the ddf
name, but this shouldn't be needed currently (reserved for future
use).
@c

void SR_SectorPutSpecial(void *storage, int index, void *extra)
{
  const specialsector_t *src = ((const specialsector_t **)storage)[index];

  char buffer[64];

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  sprintf(buffer, ":%d", src-&gt;ddf.number);
  SV_PutString(buffer);
}
</t>
<t tx="T433">@ ----------------------------------------------------------------------------

SR_SectorGetProps
@c

boolean_t SR_SectorGetProps(void *storage, int index, void *extra)
{
  region_properties_t *dest = (region_properties_t *)storage + index;

  if (! sv_struct_regprops.counterpart)
    return true;

  return SV_LoadStruct(dest, sv_struct_regprops.counterpart);
}
</t>
<t tx="T434">@ SR_SectorPutProps
@c

void SR_SectorPutProps(void *storage, int index, void *extra)
{
  region_properties_t *src = (region_properties_t *)storage + index;

  SV_SaveStruct(src, &amp;sv_struct_regprops);
}
</t>
<t tx="T435">@ SR_SectorGetPropRef
@c

boolean_t SR_SectorGetPropRef(void *storage, int index, void *extra)
{
  region_properties_t ** dest = (region_properties_t **)storage + index;

  const char *str;
  int num;

  str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  num = strtol(str, NULL, 0);

  if (num &lt; 0 || num &gt;= numsectors)
  {
    I_Warning("SR_SectorGetPropRef: bad sector ref %d\n", num);
    num = 0;
  }

  (*dest) = &amp;sectors[num].props;

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T436">@ SR_SectorPutPropRef

Format of the string is just the sector number containing the
properties.
@c

void SR_SectorPutPropRef(void *storage, int index, void *extra)
{
  region_properties_t *src = ((region_properties_t **)storage)[index];

  char buffer[64];
  int i;

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  // not optimal, but safe
  for (i=0; i &lt; numsectors; i++)
  {
    if (&amp;sectors[i].props == src)
      break;
  }
   
  if (i &gt;= numsectors)
  {
    I_Warning("SR_SectorPutPropRef: properties %p not found !\n", src);
    i = 0;
  }

  sprintf(buffer, "%d", i);
  SV_PutString(buffer);
}
</t>
<t tx="T437">@ SR_LineGetLine
@c

boolean_t SR_LineGetLine(void *storage, int index, void *extra)
{
  line_t ** dest = (line_t **)storage + index;

  int swizzle = SV_GetInt();

  *dest = (swizzle == 0) ? NULL : SV_LineGetElem(swizzle - 1);
  return true;
}
</t>
<t tx="T438">@ SR_LinePutLine
@c

void SR_LinePutLine(void *storage, int index, void *extra)
{
  line_t *elem = ((line_t **)storage)[index];

  int swizzle = (elem == NULL) ? 0 : SV_LineFindElem(elem) + 1;

  SV_PutInt(swizzle);
}
</t>
<t tx="T439">@ SR_SectorGetSector
@c

boolean_t SR_SectorGetSector(void *storage, int index, void *extra)
{
  sector_t ** dest = (sector_t **)storage + index;

  int swizzle = SV_GetInt();

  *dest = (swizzle == 0) ? NULL : SV_SectorGetElem(swizzle - 1);
  return true;
}
</t>
<t tx="T440">@ SR_SectorPutSector
@c

void SR_SectorPutSector(void *storage, int index, void *extra)
{
  sector_t *elem = ((sector_t **)storage)[index];

  int swizzle = (elem == NULL) ? 0 : SV_SectorFindElem(elem) + 1;

  SV_PutInt(swizzle);
}
</t>
<t tx="T441">@ SR_SectorGetEF
@c

boolean_t SR_SectorGetEF(void *storage, int index, void *extra)
{
  extrafloor_t ** dest = (extrafloor_t **)storage + index;

  int swizzle = SV_GetInt();

  *dest = (swizzle == 0) ? NULL : SV_ExfloorGetElem(swizzle - 1);
  return true;
}
</t>
<t tx="T442">@ SR_SectorPutEF
@c

void SR_SectorPutEF(void *storage, int index, void *extra)
{
  extrafloor_t *elem = ((extrafloor_t **)storage)[index];

  int swizzle = (elem == NULL) ? 0 : SV_ExfloorFindElem(elem) + 1;

  SV_PutInt(swizzle);
}
</t>
<t tx="T443">

#if 0  // NOT NEEDED AFTER ALL
//
// SR_ExtrafloorGetInfo
//
boolean_t SR_ExtrafloorGetInfo(void *storage, int index, void *extra)
{
  const extrafloor_info_t ** dest = 
      (const extrafloor_info_t **)storage + index;

  const char *str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  if (str[0] != ':')
    I_Error("SR_ExtrafloorGetInfo: invalid string `%s'\n", str);

  (*dest) = &amp;DDF_LineLookupNum(strtol(str+1, NULL, 0))-&gt;ef;

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T444">@ SR_ExtrafloorPutInfo

Format of the string is a colon followed by the linedef number that
defines the extrafloor, for example ":123".
@c

void SR_ExtrafloorPutInfo(void *storage, int index, void *extra)
{
  const extrafloor_info_t *src = 
      ((const extrafloor_info_t **)storage)[index];

  char buffer[64];
  int i;

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  // find the correct linedeftype
  for (i=0; i &lt; num_ddf_linetypes; i++)
  {
    if (src == &amp;ddf_linetypes[i]-&gt;ef)
    {
      sprintf(buffer, ":%d", ddf_linetypes[i]-&gt;ddf.number);
      SV_PutString(buffer);
    }
  }

  I_Error("SR_ExtrafloorPutInfo: could not find info %p\n", src);
}
</t>
<t tx="T445">#endif


#if 0  // NOT NEEDED AFTER ALL
//
// SR_SectorGetGenMove
//
boolean_t SR_SectorGetGenMove(void *storage, int index, void *extra)
{
  gen_move_t ** dest = (gen_move_t **)storage + index;
  gen_move_t *cur;

  const char *str;
  int i, num;

  str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  num = strtol(str, NULL, 0);

  for (i=0, cur=active_movparts; i &lt; num &amp;&amp; cur; i++, cur=cur-&gt;next)
  { /* nothing here */ }
   
  if (! cur)
  {
    I_Warning("SR_SectorGetGenMove: bad gen_move ref %s\n", str);
  }

  (*dest) = cur;

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T446">@ SR_SectorPutGenMove

Format of the string: the index into the active_part list, starting
at zero.
@c

void SR_SectorPutGenMove(void *storage, int index, void *extra)
{
  gen_move_t *src = ((gen_move_t **)storage)[index];
  gen_move_t *cur;

  char buffer[64];
  int i;

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  // compute index
  for (i=0, cur=src; cur-&gt;prev; i++, cur=cur-&gt;prev)
  { /* nothing here */ }
  
  if (cur != active_movparts)
    I_Error("SR_SectorPutGenMove: could not find gen_move %p\n", src);

  sprintf(buffer, "%d", i);
  SV_PutString(buffer);
}
</t>
<t tx="T447">@ignore
@language c

// New SaveGame Handling (Loading)

&lt;&lt; sv_load #includes &gt;&gt;
&lt;&lt; sv_load declarations &gt;&gt;
@others
</t>
<t tx="T448">#include "i_defs.h"
#include "sv_chunk.h"

#include "dm_state.h"
#include "e_main.h"
#include "g_game.h"
#include "m_math.h"
#include "m_random.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_state.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"
</t>
<t tx="T449">

static savestruct_t *loaded_struct_list;
static savearray_t  *loaded_array_list;
</t>
<t tx="T450">@ ----------------------------------------------------------------------------

ADMININISTRATION
@c

static void AddLoadedStruct(savestruct_t *S)
{
  S-&gt;next = loaded_struct_list;
  loaded_struct_list = S;
}
</t>
<t tx="T451">
static void AddLoadedArray(savearray_t *A)
{
  A-&gt;next = loaded_array_list;
  loaded_array_list = A;
}
</t>
<t tx="T452">@ SV_LookupLoadedStruct
@c

savestruct_t *SV_LookupLoadedStruct(const char *name)
{
  savestruct_t *cur;

  for (cur=loaded_struct_list; cur; cur=cur-&gt;next)
    if (strcmp(cur-&gt;struct_name, name) == 0)
      return cur;
    
  // not found
  return NULL;
}
</t>
<t tx="T453">@ SV_LookupLoadedArray
@c

savearray_t *SV_LookupLoadedArray(const char *name)
{
  savearray_t *cur;

  for (cur=loaded_array_list; cur; cur=cur-&gt;next)
    if (strcmp(cur-&gt;array_name, name) == 0)
      return cur;

  // not found
  return NULL;
}
</t>
<t tx="T454">@ ----------------------------------------------------------------------------

LOADING STUFF


SV_BeginLoad

Prepare main code for loading, e.g. initialise some lists.
@c

void SV_BeginLoad(void)
{
  savestruct_t *S;
  savearray_t *A;

  L_WriteDebug("SV_BeginLoad...\n");

  loaded_struct_list = NULL;
  loaded_array_list  = NULL;

  // clear counterpart fields
  for (S=sv_known_structs; S; S=S-&gt;next)
    S-&gt;counterpart = NULL;

  for (A=sv_known_arrays; A; A=A-&gt;next)
    A-&gt;counterpart = NULL;
}
</t>
<t tx="T455">
static void LoadFreeStruct(savestruct_t *cur)
{
  Z_Free((char *)cur-&gt;struct_name);
  Z_Free((char *)cur-&gt;marker);
  Z_Free(cur-&gt;fields);
  Z_Free(cur);
}
</t>
<t tx="T456">
static void LoadFreeArray(savearray_t *cur)
{
  Z_Free((char *)cur-&gt;array_name);
  Z_Free(cur);
}
</t>
<t tx="T457">@ SV_FinishLoad

Finalise all the arrays, and free some stuff after loading has
finished.
@c

void SV_FinishLoad(void)
{
  L_WriteDebug("SV_FinishLoad...\n");

  while (loaded_struct_list)
  {
    savestruct_t *cur = loaded_struct_list;
    loaded_struct_list = cur-&gt;next;

    LoadFreeStruct(cur);
  }

  while (loaded_array_list)
  {
    savearray_t *cur = loaded_array_list;
    loaded_array_list = cur-&gt;next;

    if (cur-&gt;counterpart)
    {
      (* cur-&gt;counterpart-&gt;finalise_elems)();
    }

    LoadFreeArray(cur);
  }
}
</t>
<t tx="T458">
static savefield_t *StructFindField(savestruct_t *info, const char *name)
{
  savefield_t *cur;

  for (cur=info-&gt;fields; cur-&gt;type.kind != SFKIND_Invalid; cur++)
  {
    if (strcmp(name, cur-&gt;field_name) == 0)
      return cur;
  }

  return NULL;
}
</t>
<t tx="T459">
static void StructSkipField(savefield_t *field)
{
  char marker[6];
  const char *str;
  int i;

  switch (field-&gt;type.kind)
  {
    case SFKIND_Struct:
      SV_GetMarker(marker);
      //!!! compare marker with field-&gt;type.name
      SV_SkipReadChunk(marker);
      break;

    case SFKIND_String:
      str = SV_GetString();
      Z_Free((char *)str);
      break;

    case SFKIND_Numeric:
    case SFKIND_Index:
      for (i=0; i &lt; field-&gt;type.size; i++)
        SV_GetByte();
      break;

    default:
      I_Error("SV_LoadStruct: BAD TYPE IN FIELD.\n");
  }
}
</t>
<t tx="T460">@ SV_LoadStruct

The savestruct_t here is the "loaded" one.
@c

boolean_t SV_LoadStruct(void *base, savestruct_t *info)
{
  char marker[6];
  savefield_t *cur, *actual;
  char *storage;
  int i;

  SV_GetMarker(marker);

  if (strcmp(marker, info-&gt;marker) != 0 || ! SV_PushReadChunk(marker))
    return false;

  for (cur=info-&gt;fields; cur-&gt;type.kind != SFKIND_Invalid; cur++)
  {
    actual = cur-&gt;known_field;

    // if this field no longer exists, ignore it
    if (! actual)
    {
      for (i=0; i &lt; cur-&gt;count; i++)
        StructSkipField(cur);
      continue;
    }
    
    DEV_ASSERT2(actual-&gt;field_get);

    storage = ((char *) base) + actual-&gt;offset;

    for (i=0; i &lt; cur-&gt;count; i++)
    {
      // if there are extra elements in the savegame, ignore them
      if (i &gt;= actual-&gt;count)
      {
        StructSkipField(cur);
        continue;
      }
      switch (actual-&gt;type.kind)
      {
        case SFKIND_Struct:
        case SFKIND_Index:
          (* actual-&gt;field_get)(storage, i, (char *)actual-&gt;type.name);
          break;

        default:
          (* actual-&gt;field_get)(storage, i, NULL);
          break;
      }
    }
  }

  SV_PopReadChunk();

  return true;
}
</t>
<t tx="T461">
static boolean_t SV_LoadSTRU(void)
{
  savestruct_t *S;
  savefield_t *F;

  int i, numfields;

  S = Z_ClearNew(savestruct_t, 1);

  numfields = SV_GetInt();

  S-&gt;struct_name = SV_GetString();
  S-&gt;counterpart = SV_MainLookupStruct(S-&gt;struct_name);

  // make the counterparts refer to each other
  if (S-&gt;counterpart)
  {
    DEV_ASSERT2(S-&gt;counterpart-&gt;counterpart == NULL);
    S-&gt;counterpart-&gt;counterpart = S;
  }

  S-&gt;marker = SV_GetString();

  if (strlen(S-&gt;marker) != 4)
    I_Error("LOADGAME: Corrupt savegame (STRU bad marker)\n");
 
  S-&gt;fields = Z_ClearNew(savefield_t, numfields+1);

  //
  // -- now load in all the fields --
  //

  for (i=0, F=S-&gt;fields; i &lt; numfields; i++, F++)
  {
    F-&gt;type.kind = (savefieldkind_e) SV_GetByte();
    F-&gt;type.size = SV_GetByte();
    F-&gt;count = SV_GetShort();
    F-&gt;field_name = SV_GetString();

    if (F-&gt;type.kind == SFKIND_Struct ||
        F-&gt;type.kind == SFKIND_Index)
    {
      F-&gt;type.name = SV_GetString();
    }

    F-&gt;known_field = NULL;

    if (S-&gt;counterpart)
      F-&gt;known_field = StructFindField(S-&gt;counterpart, F-&gt;field_name);

    // ??? compare names for STRUCT and INDEX
  }

  // terminate the array
  F-&gt;type.kind = SFKIND_Invalid;
 
  AddLoadedStruct(S);

  return true;
}
</t>
<t tx="T462">
static boolean_t SV_LoadARRY(void)
{
  const char *struct_name;

  savearray_t *A;

  A = Z_ClearNew(savearray_t, 1);

  A-&gt;loaded_size = SV_GetInt();

  A-&gt;array_name = SV_GetString();
  A-&gt;counterpart = SV_MainLookupArray(A-&gt;array_name);

  // make the counterparts refer to each other
  if (A-&gt;counterpart)
  {
    DEV_ASSERT2(A-&gt;counterpart-&gt;counterpart == NULL);
    A-&gt;counterpart-&gt;counterpart = A;
  }

  struct_name = SV_GetString();
  A-&gt;sdef = SV_LookupLoadedStruct(struct_name);
  
  if (A-&gt;sdef == NULL)
    I_Error("LOADGAME: Coding Error ! (no STRU `%s' for ARRY)\n", struct_name);

  Z_Free((char *)struct_name);

  // create array
  if (A-&gt;counterpart)
  {
    (* A-&gt;counterpart-&gt;create_elems)(A-&gt;loaded_size);
  }

  AddLoadedArray(A);

  return true;
}
</t>
<t tx="T463">
static boolean_t SV_LoadDATA(void)
{
  const char *array_name;
  savearray_t *A;

  int i;

  array_name = SV_GetString();

  A = SV_LookupLoadedArray(array_name);

  if (! A)
    I_Error("LOADGAME: Coding Error ! (no ARRY `%s' for DATA)\n", array_name);

  Z_Free((char *)array_name);

  // nothing to load if not known
  if (! A-&gt;counterpart)
    return true;

  for (i=0; i &lt; A-&gt;loaded_size; i++)
  {
    //??? check error too ???
    if (SV_RemainingChunkSize() == 0)
      return false;

    sv_current_elem = (* A-&gt;counterpart-&gt;get_elem)(i);

    if (! sv_current_elem)
      I_Error("SV_LoadDATA: FIXME: skip elems\n");
      
    if (! SV_LoadStruct(sv_current_elem, A-&gt;sdef))
      return false;
  }

///  if (SV_RemainingChunkSize() != 0)   //???
///    return false;

  return true;
}
</t>
<t tx="T464">@ SV_LoadEverything
@c

boolean_t SV_LoadEverything(void)
{
  char marker[6];
  boolean_t result;

  for (;;)
  {
    if (SV_GetError() != 0)
      break;  /// FIXME: set error !!

    SV_GetMarker(marker);

    if (strcmp(marker, DATA_END_MARKER) == 0)
      break;
    
    // Structure Area
    if (strcmp(marker, "Stru") == 0)
    {
      SV_PushReadChunk("Stru");
      result = SV_LoadSTRU();
      result = SV_PopReadChunk() &amp;&amp; result;
      
      if (! result)
        return false;

      continue;
    }
    
    // Array Area
    if (strcmp(marker, "Arry") == 0)
    {
      SV_PushReadChunk("Arry");
      result = SV_LoadARRY();
      result = SV_PopReadChunk() &amp;&amp; result;
      
      if (! result)
        return false;

      continue;
    }

    // Data Area
    if (strcmp(marker, "Data") == 0)
    {
      SV_PushReadChunk("Data");
      result = SV_LoadDATA();
      result = SV_PopReadChunk() &amp;&amp; result;
      
      if (! result)
        return false;

      continue;
    }

    I_Warning("LOADGAME: Unexpected top-level chunk [%s]\n", marker);

    if (! SV_SkipReadChunk(marker))
      return false;
  }

  return true;
}
</t>
<t tx="T465">@ignore
@language c

// New SaveGame Handling (Main)

&lt;&lt; sv_main #includes &gt;&gt;
&lt;&lt; sv_main declarations &gt;&gt;
@others

#endif  // TEST CODE
</t>
<t tx="T466">#include "i_defs.h"
#include "sv_chunk.h"

#include "dm_state.h"
#include "e_main.h"
#include "g_game.h"
#include "m_inline.h"
#include "m_math.h"
#include "m_random.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_state.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"
</t>
<t tx="T467">

savestruct_t *sv_known_structs;
savearray_t  *sv_known_arrays;

// the current element of an array being read/written
void *sv_current_elem;


// sv_mobj.c
extern savestruct_t sv_struct_mobj;
extern savestruct_t sv_struct_spawnpoint;
extern savestruct_t sv_struct_iteminque;
extern savearray_t sv_array_mobj;
extern savearray_t sv_array_iteminque;

// sv_play.c
extern savestruct_t sv_struct_player;
extern savestruct_t sv_struct_playerweapon;
extern savestruct_t sv_struct_playerammo;
extern savestruct_t sv_struct_psprite;
extern savearray_t sv_array_player;

// sv_level.c
extern savestruct_t sv_struct_surface;
extern savestruct_t sv_struct_side;
extern savestruct_t sv_struct_line;
extern savestruct_t sv_struct_regprops;
extern savestruct_t sv_struct_exfloor;
extern savestruct_t sv_struct_sector;
extern savearray_t sv_array_side;
extern savearray_t sv_array_line;
extern savearray_t sv_array_exfloor;
extern savearray_t sv_array_sector;

// sv_misc.c
extern savestruct_t sv_struct_button;
extern savestruct_t sv_struct_light;
extern savestruct_t sv_struct_trigger;
extern savestruct_t sv_struct_drawtip;
extern savestruct_t sv_struct_plane_move;
extern savearray_t sv_array_button;
extern savearray_t sv_array_light;
extern savearray_t sv_array_trigger;
extern savearray_t sv_array_drawtip;
extern savearray_t sv_array_plane_move;
</t>
<t tx="T468">@ ----------------------------------------------------------------------------

GET ROUTINES


SR_GetByte
@c

boolean_t SR_GetByte(void *storage, int index, void *extra)
{
  ((unsigned char *)storage)[index] = SV_GetByte();
  return true;
}
</t>
<t tx="T469">@ SR_GetShort
@c

boolean_t SR_GetShort(void *storage, int index, void *extra)
{
  ((unsigned short *)storage)[index] = SV_GetShort();
  return true;
}
</t>
<t tx="T470">@ SR_GetInt
@c

boolean_t SR_GetInt(void *storage, int index, void *extra)
{
  ((unsigned int *)storage)[index] = SV_GetInt();
  return true;
}
</t>
<t tx="T471">@ SR_GetFixed
@c

boolean_t SR_GetFixed(void *storage, int index, void *extra)
{
  ((fixed_t *)storage)[0] = SV_GetFixed();
  return true;
}
</t>
<t tx="T472">@ SR_GetAngle
@c

boolean_t SR_GetAngle(void *storage, int index, void *extra)
{
  ((angle_t *)storage)[index] = SV_GetAngle();
  return true;
}
</t>
<t tx="T473">@ SR_GetFloat
@c

boolean_t SR_GetFloat(void *storage, int index, void *extra)
{
  ((float_t *)storage)[index] = SV_GetFloat();
  return true;
}
</t>
<t tx="T474">@ SR_GetVec2
@c

boolean_t SR_GetVec2(void *storage, int index, void *extra)
{
  ((vec2_t *)storage)[index].x = SV_GetFloat();
  ((vec2_t *)storage)[index].y = SV_GetFloat();
  return true;
}
</t>
<t tx="T475">@ SR_GetVec3
@c

boolean_t SR_GetVec3(void *storage, int index, void *extra)
{
  ((vec3_t *)storage)[index].x = SV_GetFloat();
  ((vec3_t *)storage)[index].y = SV_GetFloat();
  ((vec3_t *)storage)[index].z = SV_GetFloat();
  return true;
}
</t>
<t tx="T476">@ SR_GetIntAsFloat
@c

boolean_t SR_GetIntAsFloat(void *storage, int index, void *extra)
{
  ((float_t *)storage)[index] = (float_t)SV_GetInt();
  return true;
}
</t>
<t tx="T477">@ ----------------------------------------------------------------------------

COMMON PUT ROUTINES


SR_PutByte
@c

void SR_PutByte(void *storage, int index, void *extra)
{
  SV_PutByte(((unsigned char *)storage)[index]);
}
</t>
<t tx="T478">@ SR_PutShort
@c

void SR_PutShort(void *storage, int index, void *extra)
{
  SV_PutShort(((unsigned short *)storage)[index]);
}
</t>
<t tx="T479">@ SR_PutInt
@c

void SR_PutInt(void *storage, int index, void *extra)
{
  SV_PutInt(((unsigned int *)storage)[index]);
}
</t>
<t tx="T480">@ SR_PutFixed
@c

void SR_PutFixed(void *storage, int index, void *extra)
{
  SV_PutFixed(((fixed_t *)storage)[index]);
}
</t>
<t tx="T481">@ SR_PutAngle
@c

void SR_PutAngle(void *storage, int index, void *extra)
{
  SV_PutAngle(((angle_t *)storage)[index]);
}
</t>
<t tx="T482">@ SR_PutFloat
@c

void SR_PutFloat(void *storage, int index, void *extra)
{
  SV_PutFloat(((float_t *)storage)[index]);
}
</t>
<t tx="T483">@ SR_PutVec2
@c

void SR_PutVec2(void *storage, int index, void *extra)
{
  SV_PutFloat(((vec2_t *)storage)[index].x);
  SV_PutFloat(((vec2_t *)storage)[index].y);
}
</t>
<t tx="T484">@ SR_PutVec3
@c

void SR_PutVec3(void *storage, int index, void *extra)
{
  SV_PutFloat(((vec3_t *)storage)[index].x);
  SV_PutFloat(((vec3_t *)storage)[index].y);
  SV_PutFloat(((vec3_t *)storage)[index].z);
}
</t>
<t tx="T485">@ ----------------------------------------------------------------------------

ADMININISTRATION
@c

static void AddKnownStruct(savestruct_t *S)
{
  S-&gt;next = sv_known_structs;
  sv_known_structs = S;
}
</t>
<t tx="T486">
static void AddKnownArray(savearray_t *A)
{
  A-&gt;next = sv_known_arrays;
  sv_known_arrays = A;
}
</t>
<t tx="T487">@ SV_MainInit

One-time initialisation. Sets up lists of known structures and
arrays.
@c

boolean_t SV_MainInit(void)
{
  // sv_mobj.c
  AddKnownStruct(&amp;sv_struct_mobj);
  AddKnownStruct(&amp;sv_struct_spawnpoint);
  AddKnownStruct(&amp;sv_struct_iteminque);
  
  AddKnownArray(&amp;sv_array_mobj);
  AddKnownArray(&amp;sv_array_iteminque);

  // sv_play.c
  AddKnownStruct(&amp;sv_struct_player);
  AddKnownStruct(&amp;sv_struct_playerweapon);
  AddKnownStruct(&amp;sv_struct_playerammo);
  AddKnownStruct(&amp;sv_struct_psprite);
  
  AddKnownArray(&amp;sv_array_player);

  // sv_level.c
  AddKnownStruct(&amp;sv_struct_surface);
  AddKnownStruct(&amp;sv_struct_side);
  AddKnownStruct(&amp;sv_struct_line);
  AddKnownStruct(&amp;sv_struct_regprops);
  AddKnownStruct(&amp;sv_struct_exfloor);
  AddKnownStruct(&amp;sv_struct_sector);

  AddKnownArray(&amp;sv_array_side);
  AddKnownArray(&amp;sv_array_line);
  AddKnownArray(&amp;sv_array_exfloor);
  AddKnownArray(&amp;sv_array_sector);

  // sv_misc.c
  AddKnownStruct(&amp;sv_struct_button);
  AddKnownStruct(&amp;sv_struct_light);
  AddKnownStruct(&amp;sv_struct_trigger);
  AddKnownStruct(&amp;sv_struct_drawtip);
  AddKnownStruct(&amp;sv_struct_plane_move);

  AddKnownArray(&amp;sv_array_button);
  AddKnownArray(&amp;sv_array_light);
  AddKnownArray(&amp;sv_array_trigger);
  AddKnownArray(&amp;sv_array_drawtip);
  AddKnownArray(&amp;sv_array_plane_move);

  return true;
}
</t>
<t tx="T488">@ SV_MainLookupStruct
@c

savestruct_t *SV_MainLookupStruct(const char *name)
{
  savestruct_t *cur;

  for (cur=sv_known_structs; cur; cur=cur-&gt;next)
    if (strcmp(cur-&gt;struct_name, name) == 0)
      return cur;
    
  // not found
  return NULL;
}
</t>
<t tx="T489">@ SV_MainLookupArray
@c

savearray_t *SV_MainLookupArray(const char *name)
{
  savearray_t *cur;

  for (cur=sv_known_arrays; cur; cur=cur-&gt;next)
    if (strcmp(cur-&gt;array_name, name) == 0)
      return cur;

  // not found
  return NULL;
}
</t>
<t tx="T490">@ ----------------------------------------------------------------------------

TEST CODE
@c

#if 0
void SV_MainTestPrimitives(void)
{
  int i;
  int version;

  if (! SV_OpenWriteFile("savegame/prim.tst", 0x7654))
    I_Error("SV_MainTestPrimitives: couldn't create output\n");
  
  SV_PutByte(0x00);
  SV_PutByte(0x55);
  SV_PutByte(0xAA);
  SV_PutByte(0xFF);

  SV_PutShort(0x0000);
  SV_PutShort(0x4567);
  SV_PutShort(0xCDEF);
  SV_PutShort(0xFFFF);

  SV_PutInt(0x00000000);
  SV_PutInt(0x11223344);
  SV_PutInt(0xbbccddee);
  SV_PutInt(0xffffffff);

  SV_PutFixed(0);
  SV_PutFixed(FRACUNIT);
  SV_PutFixed(M_FloatToFixed(123.456));
  SV_PutFixed(-FRACUNIT);
  SV_PutFixed(-M_FloatToFixed(345.789));

  SV_PutAngle(ANG1);
  SV_PutAngle(ANG45);
  SV_PutAngle(ANG135);
  SV_PutAngle(ANG180);
  SV_PutAngle(ANG270);
  SV_PutAngle(ANG315);
  SV_PutAngle(0 - ANG1);

  SV_PutFloat(0.0);
  SV_PutFloat(0.001);   SV_PutFloat(-0.001);
  SV_PutFloat(0.1);     SV_PutFloat(-0.1);
  SV_PutFloat(0.25);    SV_PutFloat(-0.25);
  SV_PutFloat(1.0);     SV_PutFloat(-1.0);
  SV_PutFloat(2.0);     SV_PutFloat(-2.0);
  SV_PutFloat(3.1416);  SV_PutFloat(-3.1416);
  SV_PutFloat(1000.0);  SV_PutFloat(-1000.0);
  SV_PutFloat(1234567890.0);  
  SV_PutFloat(-1234567890.0);
  
  SV_PutString(NULL);
  SV_PutString("");
  SV_PutString("A");
  SV_PutString("123");
  SV_PutString("HELLO world !");

  SV_PutMarker("ABCD");
  SV_PutMarker("xyz3");

  SV_CloseWriteFile();

  // ------------------------------------------------------------ //

  if (! SV_OpenReadFile("savegame/prim.tst"))
    I_Error("SV_MainTestPrimitives: couldn't open input\n");
  
  if (! SV_VerifyHeader(&amp;version))
    I_Error("SV_MainTestPrimitives: couldn't open input\n");
  
  L_WriteDebug("TEST HEADER: version=0x%04x\n", version);

  for (i=0; i &lt; 4; i++)
  {
    unsigned int val = SV_GetByte();
    L_WriteDebug("TEST BYTE: 0x%02x %d\n", val, (char) val);
  }

  for (i=0; i &lt; 4; i++)
  {
    unsigned int val = SV_GetShort();
    L_WriteDebug("TEST SHORT: 0x%02x %d\n", val, (short) val);
  }
  
  for (i=0; i &lt; 4; i++)
  {
    unsigned int val = SV_GetInt();
    L_WriteDebug("TEST INT: 0x%02x %d\n", val, (int) val);
  }
  
  for (i=0; i &lt; 5; i++)
  {
    fixed_t val = SV_GetFixed();
    L_WriteDebug("TEST FIXED: 0x%08x = %1.6f\n", (unsigned int) val,
        M_FixedToFloat(val));
  }
  
  for (i=0; i &lt; 7; i++)
  {
    angle_t val = SV_GetAngle();
    L_WriteDebug("TEST ANGLE: 0x%08x = %1.6f\n", (unsigned int) val,
        ANG_2_FLOAT(val));
  }
  
  for (i=0; i &lt; 17; i++)
  {
    float_t val = SV_GetFloat();
    L_WriteDebug("TEST FLOAT: %1.6f\n", val);
  }
  
  for (i=0; i &lt; 5; i++)
  {
    const char *val = SV_GetString();
    L_WriteDebug("TEST STRING: [%s]\n", val ? val : "--NULL--");
    Z_Free((char *)val);
  }
  
  for (i=0; i &lt; 2; i++)
  {
    char val[6];
    SV_GetMarker(val);
    L_WriteDebug("TEST MARKER: [%s]\n", val);
  }
  
  SV_CloseReadFile();
}
</t>
<t tx="T491">@ignore
@language c

// New SaveGame Handling (Miscellaneous)

// This file handles
//    light_t         [LITE]
//    button_t        [BUTN]
//    rad_trigger_t   [TRIG]
//    drawtip_t       [DTIP]
//
//    plane_move_t    [PMOV]
//    slider_move_t   [SMOV]
//    elev_move_t     [EMOV]
//
// TODO HERE:
//   +  Fix donuts.
//   +  Implement slider_move array.
//   -  Implement elev_move array (when elevators are done).
//   -  Button off_sound field.

&lt;&lt; sv_misc #includes &gt;&gt;
&lt;&lt; sv_misc declarations &gt;&gt;
@others
</t>
<t tx="T492">#include "i_defs.h"

#include "dm_state.h"
#include "e_player.h"
#include "p_local.h"
#include "p_spec.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "r_state.h"
#include "rad_main.h"
#include "rad_trig.h"
#include "z_zone.h"
</t>
<t tx="T493">
#undef SF
#define SF  SVFIELD


// forward decls.
int SV_ButtonCountElems(void);
int SV_ButtonFindElem(button_t *elem);
void * SV_ButtonGetElem(int index);
void SV_ButtonCreateElems(int num_elems);
void SV_ButtonFinaliseElems(void);

int SV_LightCountElems(void);
int SV_LightFindElem(light_t *elem);
void * SV_LightGetElem(int index);
void SV_LightCreateElems(int num_elems);
void SV_LightFinaliseElems(void);

int SV_TriggerCountElems(void);
int SV_TriggerFindElem(rad_trigger_t *elem);
void * SV_TriggerGetElem(int index);
void SV_TriggerCreateElems(int num_elems);
void SV_TriggerFinaliseElems(void);

int SV_TipCountElems(void);
int SV_TipFindElem(drawtip_t *elem);
void * SV_TipGetElem(int index);
void SV_TipCreateElems(int num_elems);
void SV_TipFinaliseElems(void);

int SV_PlaneMoveCountElems(void);
int SV_PlaneMoveFindElem(plane_move_t *elem);
void * SV_PlaneMoveGetElem(int index);
void SV_PlaneMoveCreateElems(int num_elems);
void SV_PlaneMoveFinaliseElems(void);


boolean_t SR_LightGetType(void *storage, int index, void *extra);
void SR_LightPutType(void *storage, int index, void *extra);

boolean_t SR_TriggerGetScript(void *storage, int index, void *extra);
void SR_TriggerPutScript(void *storage, int index, void *extra);

boolean_t SR_TriggerGetState(void *storage, int index, void *extra);
void SR_TriggerPutState(void *storage, int index, void *extra);

boolean_t SR_TipGetString(void *storage, int index, void *extra);
void SR_TipPutString(void *storage, int index, void *extra);

boolean_t SR_PlaneMoveGetType(void *storage, int index, void *extra);
void SR_PlaneMovePutType(void *storage, int index, void *extra);


//----------------------------------------------------------------------------
//
//  BUTTON STRUCTURE
//
static button_t sv_dummy_button;

#define SV_F_BASE  sv_dummy_button

static savefield_t sv_fields_button[] =
{
  SF(line, "line", 1, SVT_INDEX("lines"), 
      SR_LineGetLine, SR_LinePutLine),
  SF(where, "where", 1, SVT_ENUM, SR_GetEnum, SR_PutEnum),
  SF(bimage, "bimage", 1, SVT_STRING, SR_LevelGetImage, SR_LevelPutImage),
  SF(btimer, "btimer", 1, SVT_INT, SR_GetInt, SR_PutInt),

  // FIXME: off_sound
 
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_button =
{
  NULL,              // link in list
  "button_t",        // structure name
  "butn",            // start marker
  sv_fields_button,  // field descriptions
  true,              // define_me
  NULL               // pointer to known struct
};

savearray_t sv_array_button =
{
  NULL,               // link in list
  "buttonlist",       // array name
  &amp;sv_struct_button,  // array type
  true,               // define_me

  SV_ButtonCountElems,     // count routine
  SV_ButtonGetElem,        // index routine
  SV_ButtonCreateElems,    // creation routine
  SV_ButtonFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  LIGHT STRUCTURE
//
static light_t sv_dummy_light;

#define SV_F_BASE  sv_dummy_light

static savefield_t sv_fields_light[] =
{
  SF(type, "type", 1, SVT_STRING, SR_LightGetType, SR_LightPutType),
  SF(sector, "sector", 1, SVT_INDEX("sectors"), 
      SR_SectorGetSector, SR_SectorPutSector),
  SF(count, "count", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(minlight, "minlight", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(maxlight, "maxlight", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(direction, "direction", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(fade_count, "fade_count", 1, SVT_INT, SR_GetInt, SR_PutInt),

  // NOT HERE:
  //   - prev &amp; next: automatically regenerated
 
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_light =
{
  NULL,              // link in list
  "light_t",         // structure name
  "lite",            // start marker
  sv_fields_light,   // field descriptions
  true,              // define_me
  NULL               // pointer to known struct
};

savearray_t sv_array_light =
{
  NULL,              // link in list
  "lights",          // array name
  &amp;sv_struct_light,  // array type
  true,              // define_me

  SV_LightCountElems,     // count routine
  SV_LightGetElem,        // index routine
  SV_LightCreateElems,    // creation routine
  SV_LightFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  TRIGGER STRUCTURE
//
static rad_trigger_t sv_dummy_trigger;

#define SV_F_BASE  sv_dummy_trigger

static savefield_t sv_fields_trigger[] =
{
  SF(info, "info", 1, SVT_STRING,
      SR_TriggerGetScript, SR_TriggerPutScript),

  SF(disabled, "disabled", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),
  SF(activated, "activated", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),
  SF(repeats_left, "repeats_left", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(repeat_delay, "repeat_delay", 1, SVT_INT, SR_GetInt, SR_PutInt),

  SF(state, "state", 1, SVT_INT,
      SR_TriggerGetState, SR_TriggerPutState),
  SF(wait_tics, "wait_tics", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(tip_slot, "tip_slot", 1, SVT_INT, SR_GetInt, SR_PutInt),

  // NOT HERE
  //   - next &amp; prev: can be regenerated.
  //   - tag_next &amp; tag_prev: ditto
  //   - soundorg: can be recomputed.
  
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_trigger =
{
  NULL,               // link in list
  "rad_trigger_t",    // structure name
  "trig",             // start marker
  sv_fields_trigger,  // field descriptions
  true,               // define_me
  NULL                // pointer to known struct
};

savearray_t sv_array_trigger =
{
  NULL,               // link in list
  "r_triggers",       // array name
  &amp;sv_struct_trigger, // array type
  true,               // define_me

  SV_TriggerCountElems,     // count routine
  SV_TriggerGetElem,        // index routine
  SV_TriggerCreateElems,    // creation routine
  SV_TriggerFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  DRAWTIP STRUCTURE
//
static drawtip_t sv_dummy_drawtip;

#define SV_F_BASE  sv_dummy_drawtip

static savefield_t sv_fields_drawtip[] =
{
  // treating the `p' sub-struct here as if the fields were directly
  // in drawtip_t.

  SF(p.x_pos, "x_pos", 1, SVT_PERCENT, SR_GetPercent, SR_PutPercent),
  SF(p.y_pos, "y_pos", 1, SVT_PERCENT, SR_GetPercent, SR_PutPercent),
  SF(p.left_just, "left_just", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(p.colourmap_name, "colourmap_name", 1, SVT_STRING,
      SR_TipGetString, SR_TipPutString),
  SF(p.translucency, "translucency", 1, SVT_PERCENT, 
      SR_GetPercent, SR_PutPercent),

  SF(delay, "delay", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(tip_text, "tip_text", 1, SVT_STRING,
      SR_TipGetString, SR_TipPutString),
  SF(tip_graphic, "tip_graphic", 1, SVT_STRING,
      SR_LevelGetImage, SR_LevelPutImage),
  SF(playsound, "playsound", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),
  SF(fade_time, "fade_time", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(fade_target, "fade_target", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
   
  // NOT HERE:
  //    p.slot_num, p.time: not used withing drawtip_t
  //    dirty: this is set in the finalizer
  //    colmap, hu_*: these are regenerated on next display

  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_drawtip =
{
  NULL,              // link in list
  "drawtip_t",       // structure name
  "dtip",            // start marker
  sv_fields_drawtip, // field descriptions
  true,              // define_me
  NULL               // pointer to known struct
};

savearray_t sv_array_drawtip =
{
  NULL,               // link in list
  "tip_slots",        // array name
  &amp;sv_struct_drawtip, // array type
  true,               // define_me

  SV_TipCountElems,     // count routine
  SV_TipGetElem,        // index routine
  SV_TipCreateElems,    // creation routine
  SV_TipFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  PLANEMOVE STRUCTURE
//
static plane_move_t sv_dummy_plane_move;

#define SV_F_BASE  sv_dummy_plane_move

static savefield_t sv_fields_plane_move[] =
{
  SF(type, "type", 1, SVT_STRING, SR_PlaneMoveGetType, SR_PlaneMovePutType),
  SF(sector, "sector", 1, SVT_INDEX("sectors"), 
      SR_SectorGetSector, SR_SectorPutSector),

  SF(is_ceiling, "is_ceiling", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),
  SF(startheight, "startheight", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(destheight, "destheight", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(speed, "speed", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(crush, "crush", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),
      
  SF(direction, "direction", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(olddirection, "olddirection", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(tag, "tag", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(waited, "waited", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(sfxstarted, "sfxstarted", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),

  SF(newspecial, "newspecial", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(new_image, "new_image", 1, SVT_STRING, 
      SR_LevelGetImage, SR_LevelPutImage),

  // NOT HERE:
  //   - whatiam: will always be MDT_PLANE
  //   - next, prev: regenerated automatically.
  
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_plane_move =
{
  NULL,                  // link in list
  "plane_move_t",        // structure name
  "pmov",                // start marker
  sv_fields_plane_move,  // field descriptions
  true,                  // define_me
  NULL                   // pointer to known struct
};

savearray_t sv_array_plane_move =
{
  NULL,                   // link in list
  "plane_movers",         // array name (virtual list)
  &amp;sv_struct_plane_move,  // array type
  true,                   // define_me

  SV_PlaneMoveCountElems,     // count routine
  SV_PlaneMoveGetElem,        // index routine
  SV_PlaneMoveCreateElems,    // creation routine
  SV_PlaneMoveFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};
</t>
<t tx="T494">@ ----------------------------------------------------------------------------

SV_ButtonCountElems
@c

int SV_ButtonCountElems(void)
{
  return maxbuttons;
}
</t>
<t tx="T495">@ SV_ButtonGetElem
@c

void *SV_ButtonGetElem(int index)
{
  if (index &lt; 0 || index &gt;= maxbuttons)
  {
    I_Warning("LOADGAME: Invalid Button: %d\n", index);
    index = 0;
  }
  
  return buttonlist + index;
}
</t>
<t tx="T496">@ SV_ButtonFindElem
@c

int SV_ButtonFindElem(button_t *elem)
{
  DEV_ASSERT2(buttonlist &lt;= elem &amp;&amp; elem &lt; (buttonlist + maxbuttons));

  return elem - buttonlist;
}
</t>
<t tx="T497">@ SV_ButtonCreateElems
@c

void SV_ButtonCreateElems(int num_elems)
{
  int i;
  
  maxbuttons = num_elems;
  Z_Resize(buttonlist, button_t, maxbuttons);

  // initialise defaults
  for (i=0; i &lt; maxbuttons; i++)
  {
    Z_Clear(buttonlist + i, button_t, 1);
  }
}
</t>
<t tx="T498">@ SV_ButtonFinaliseElems
@c

void SV_ButtonFinaliseElems(void)
{
  // nothing to do
}
</t>
<t tx="T499">@ ----------------------------------------------------------------------------

SV_LightCountElems
@c

int SV_LightCountElems(void)
{
  light_t *cur;
  int count;

  for (cur=lights, count=0; cur; cur=cur-&gt;next, count++)
  { /* nothing here */ }

  return count;
}
</t>
<t tx="T500">@ SV_LightGetElem
@c

void *SV_LightGetElem(int index)
{
  light_t *cur;

  for (cur=lights; cur &amp;&amp; index &gt; 0; cur=cur-&gt;next)
    index--;
  
  if (! cur)
    I_Error("LOADGAME: Invalid Light: %d\n", index);
  
  DEV_ASSERT2(index == 0);
  return cur;
}
</t>
<t tx="T501">@ SV_LightFindElem
@c

int SV_LightFindElem(light_t *elem)
{
  light_t *cur;
  int index;

  for (cur=lights, index=0; cur &amp;&amp; cur != elem; cur=cur-&gt;next)
    index++;
  
  if (! cur)
    I_Error("LOADGAME: No such LightPtr: %p\n", elem);
  
  return index;
}
</t>
<t tx="T502">@ SV_LightCreateElems
@c

void SV_LightCreateElems(int num_elems)
{
  P_DestroyAllLights();
  
  for (; num_elems &gt; 0; num_elems--)
  {
    light_t *cur = Z_ClearNew(light_t, 1);

    // link it in
    cur-&gt;next = lights;
    cur-&gt;prev = NULL;

    if (lights)
      lights-&gt;prev = cur;
    
    lights = cur;

    // initialise defaults
    cur-&gt;type = &amp;ddf_sectors[0]-&gt;l;
    cur-&gt;sector = sectors + 0;
  }
}
</t>
<t tx="T503">@ SV_LightFinaliseElems
@c

void SV_LightFinaliseElems(void)
{
  // nothing to do
}
</t>
<t tx="T504">@ ----------------------------------------------------------------------------

SV_TriggerCountElems
@c

int SV_TriggerCountElems(void)
{
  rad_trigger_t *cur;
  int count;

  for (cur=r_triggers, count=0; cur; cur=cur-&gt;next, count++)
  { /* nothing here */ }

  return count;
}
</t>
<t tx="T505">@ SV_TriggerGetElem
@c

void *SV_TriggerGetElem(int index)
{
  rad_trigger_t *cur;

  for (cur=r_triggers; cur &amp;&amp; index &gt; 0; cur=cur-&gt;next)
    index--;
  
  if (! cur)
    I_Error("LOADGAME: Invalid Trigger: %d\n", index);
  
  DEV_ASSERT2(index == 0);
  return cur;
}
</t>
<t tx="T506">@ SV_TriggerFindElem
@c

int SV_TriggerFindElem(rad_trigger_t *elem)
{
  rad_trigger_t *cur;
  int index;

  for (cur=r_triggers, index=0; cur &amp;&amp; cur != elem; cur=cur-&gt;next)
    index++;
  
  if (! cur)
    I_Error("LOADGAME: No such TriggerPtr: %p\n", elem);
  
  return index;
}
</t>
<t tx="T507">@ SV_TriggerCreateElems
@c

void SV_TriggerCreateElems(int num_elems)
{
  RAD_ClearTriggers();
  
  for (; num_elems &gt; 0; num_elems--)
  {
    rad_trigger_t *cur = Z_ClearNew(rad_trigger_t, 1);

    // link it in
    cur-&gt;next = r_triggers;
    cur-&gt;prev = NULL;

    if (r_triggers)
      r_triggers-&gt;prev = cur;
    
    r_triggers = cur;

    // initialise defaults
    cur-&gt;info = r_scripts;
    cur-&gt;state = r_scripts ? r_scripts-&gt;first_state : NULL;
    cur-&gt;disabled = true;
  }
}
</t>
<t tx="T508">@ SV_TriggerFinaliseElems
@c

void SV_TriggerFinaliseElems(void)
{
  rad_trigger_t *cur;

  for (cur=r_triggers; cur; cur=cur-&gt;next)
  {
    RAD_GroupTriggerTags(cur);
  }
}
</t>
<t tx="T509">@ ----------------------------------------------------------------------------

SV_TipCountElems
@c

int SV_TipCountElems(void)
{
  return MAXTIPSLOT;
}
</t>
<t tx="T510">@ SV_TipGetElem
@c

void *SV_TipGetElem(int index)
{
  if (index &lt; 0 || index &gt;= MAXTIPSLOT)
  {
    I_Warning("LOADGAME: Invalid Tip: %d\n", index);
    index = MAXTIPSLOT-1;
  }
  
  return tip_slots + index;
}
</t>
<t tx="T511">@ SV_TipFindElem
@c

int SV_TipFindElem(drawtip_t *elem)
{
  DEV_ASSERT2(tip_slots &lt;= elem &amp;&amp; elem &lt; (tip_slots + MAXTIPSLOT));

  return elem - tip_slots;
}
</t>
<t tx="T512">@ SV_TipCreateElems
@c

void SV_TipCreateElems(int num_elems)
{
  RAD_ResetTips();
}
</t>
<t tx="T513">@ SV_TipFinaliseElems
@c

void SV_TipFinaliseElems(void)
{
  int i;

  // mark all active tip slots as dirty
  for (i=0; i &lt; MAXTIPSLOT; i++)
  {
    if (tip_slots[i].delay &gt; 0)
      tip_slots[i].dirty = true;
  }
}
</t>
<t tx="T514">@ ----------------------------------------------------------------------------

SV_PlaneMoveCountElems
@c

int SV_PlaneMoveCountElems(void)
{
  gen_move_t *cur;
  int count;

  for (cur=active_movparts, count=0; cur; cur=cur-&gt;next)
  {
    if (cur-&gt;whatiam == MDT_PLANE)
      count++;
  }

  return count;
}
</t>
<t tx="T515">@ SV_PlaneMoveGetElem

The index value starts at 0.
@c

void *SV_PlaneMoveGetElem(int index)
{
  gen_move_t *cur;

  for (cur=active_movparts; cur; cur=cur-&gt;next)
  {
    if (cur-&gt;whatiam != MDT_PLANE)
      continue;

    if (index == 0)
      break;
    
    index--;
  }
 
  if (! cur)
    I_Error("LOADGAME: Invalid PlaneMove: %d\n", index);
  
  DEV_ASSERT2(index == 0);
  return cur;
}
</t>
<t tx="T516">@ SV_PlaneMoveFindElem

Returns the index value (starts at 0).
@c

int SV_PlaneMoveFindElem(plane_move_t *elem)
{
  gen_move_t *cur;
  int index;

  for (cur=active_movparts, index=0; cur; cur=cur-&gt;next)
  {
    if (cur-&gt;whatiam != MDT_PLANE)
      continue;
  
    if ((plane_move_t *)cur == elem)
      break;

    index++;
  }
  
  if (! cur)
    I_Error("LOADGAME: No such PlaneMovePtr: %p\n", elem);
  
  return index;
}
</t>
<t tx="T517">@ SV_PlaneMoveCreateElems
@c

void SV_PlaneMoveCreateElems(int num_elems)
{
  // NOTE: this removes all the other movers too.  Hence plane movers
  //       should be loaded before the other ones.
  //
  P_RemoveAllActiveParts();
 
  for (; num_elems &gt; 0; num_elems--)
  {
    plane_move_t *cur = Z_ClearNew(plane_move_t, 1);

    // initialise defaults
    cur-&gt;whatiam = MDT_PLANE;
    
    // link it in
    P_AddActivePart((gen_move_t *)cur);
  }
}
</t>
<t tx="T518">@ SV_PlaneMoveFinaliseElems
@c

void SV_PlaneMoveFinaliseElems(void)
{
  // nothing to do
}
</t>
<t tx="T519">@ ----------------------------------------------------------------------------

SR_LightGetType
@c

boolean_t SR_LightGetType(void *storage, int index, void *extra)
{
  const lighttype_t ** dest = (const lighttype_t **)storage + index;

  int number;
  const char *str;

  str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  if (str[1] != ':')
    I_Error("SR_LightGetType: invalid lighttype `%s'\n", str);

  number = strtol(str + 2, NULL, 0);

  if (str[0] == 'S')
  {
    const specialsector_t *special = DDF_SectorLookupNum(number);
    (*dest) = &amp;special-&gt;l;
  }
  else if (str[0] == 'L')
  {
    const linedeftype_t *special = DDF_LineLookupNum(number);
    (*dest) = &amp;special-&gt;l;
  }
  else
    I_Error("SR_LightGetType: invalid lighttype `%s'\n", str);

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T520">@ SR_LightPutType

Format of the string:

&lt;source char&gt; `:' &lt;source ref&gt;

The source char determines where the lighttype_t is found: `S' in a
sector type or `L' in a linedef type. The source ref is the
numeric ID of the sector/line type in DDF.
@c

void SR_LightPutType(void *storage, int index, void *extra)
{
  const lighttype_t *src = ((const lighttype_t **)storage)[index];

  int i;
  char buffer[64];

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  // look for it in the line types
  for (i=0; i &lt; num_ddf_linetypes; i++)
  {
    if (src == &amp;ddf_linetypes[i]-&gt;l)
    {
      sprintf(buffer, "L:%d", ddf_linetypes[i]-&gt;ddf.number);
      SV_PutString(buffer);
      return;
    }
  }

  // look for it in the sector types
  for (i=0; i &lt; num_ddf_sectors; i++)
  {
    if (src == &amp;ddf_sectors[i]-&gt;l)
    {
      sprintf(buffer, "S:%d", ddf_sectors[i]-&gt;ddf.number);
      SV_PutString(buffer);
      return;
    }
  }

  // not found !

  I_Warning("LOADGAME: could not find lighttype_t %p !\n", src);
  SV_PutString("S:1");
}
</t>
<t tx="T521">@ SR_TriggerGetState
@c

boolean_t SR_TriggerGetState(void *storage, int index, void *extra)
{
  const rts_state_t ** dest = (const rts_state_t **)storage + index;
  const rts_state_t *temp;

  int value;
  const rad_trigger_t *trig = (rad_trigger_t *) sv_current_elem;

  value = SV_GetInt();

  if (value == 0)
  {
    (*dest) = NULL;
    return true;
  }

  for (temp=trig-&gt;info-&gt;first_state; temp;
       temp=temp-&gt;next, value--)
  {
    if (value == 1)
      break;
  }

  if (! temp)
  {
    I_Warning("LOADGAME: invalid RTS state !\n");
    temp = trig-&gt;info-&gt;last_state;
  }

  (*dest) = temp;
  return true;
}
</t>
<t tx="T522">@ SR_TriggerPutState
@c

void SR_TriggerPutState(void *storage, int index, void *extra)
{
  const rts_state_t *src = ((const rts_state_t **)storage)[index];
  const rts_state_t *temp;

  int value;
  const rad_trigger_t *trig = (rad_trigger_t *) sv_current_elem;

  if (! src)
  {
    SV_PutInt(0);
    return;
  }

  // determine index value
  for (temp=trig-&gt;info-&gt;first_state, value=1; temp; 
       temp=temp-&gt;next, value++)
  {
    if (temp == src)
      break;
  }

  if (! temp)
    I_Error("INTERNAL ERROR: no such RTS state %p !\n", src);

  SV_PutInt(value);
}
</t>
<t tx="T523">@ SR_TriggerGetScript
@c

boolean_t SR_TriggerGetScript(void *storage, int index, void *extra)
{
  const rad_script_t ** dest = (const rad_script_t **)storage + index;
  const rad_script_t *temp;

  const char *swizzle;
  char buffer[256];
  char *base_p, *use_p;
  char *map_name;

  int idx_val;
  unsigned long crc;

  swizzle = SV_GetString();

  if (! swizzle)
  {
    (*dest) = NULL;
    return true;
  }

  Z_StrNCpy(buffer, swizzle, 256-1);
  Z_Free((char *)swizzle);

  if (buffer[0] != 'B' || buffer[1] != ':')
    I_Error("Corrupt savegame: bad script ref 1/4: `%s'\n", buffer);
  
  // get map name
  
  map_name = buffer + 2;
  base_p = strchr(map_name, ':');

  if (base_p == NULL || base_p == map_name || base_p[0] == 0)
    I_Error("Corrupt savegame: bad script ref 2/4: `%s'\n", map_name);

  // terminate the map name
  *base_p++ = 0;

  // get index value
  
  use_p = base_p;
  base_p = strchr(use_p, ':');
  
  if (base_p == NULL || base_p == use_p || base_p[0] == 0)
    I_Error("Corrupt savegame: bad script ref 3/4: `%s'\n", use_p);

  *base_p++ = 0;
  
  idx_val = strtol(use_p, NULL, 0);
  DEV_ASSERT2(idx_val &gt;= 1);
 
  // get CRC value
  
  crc = strtoul(base_p, NULL, 16);
 
  // now find the bugger !
  
  for (temp=r_scripts; temp; temp=temp-&gt;next)
  {
    if (DDF_CompareName(temp-&gt;mapid, map_name) != 0)
      continue;

    if (temp-&gt;crc != crc)
      continue;
    
    if (idx_val == 1)
      break;
    
    idx_val--;
  }

  if (! temp)
  {
    I_Warning("LOADGAME: No such RTS script !!\n");
    temp = r_scripts;
  }

  (*dest) = temp;
  return true;
}
</t>
<t tx="T524">@ SR_TriggerPutScript

Format of the string:

`B' `:' &lt;map&gt; `:' &lt;index&gt; `:' &lt;crc&gt;

The `B' is a format descriptor -- future changes should use other
letters. The CRC is used to find the radius script. There may be
several in the same map with the same CRC, and the `index' part is
used to differentiate them. Index values begin at 1. The CRC
value is in hexadecimal.
@c

void SR_TriggerPutScript(void *storage, int index, void *extra)
{
  const rad_script_t *src = ((const rad_script_t **)storage)[index];
  const rad_script_t *temp;

  int idx_val;
  char buffer[256];

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  // determine index idx_val
  for (temp=r_scripts, idx_val=1; temp; temp=temp-&gt;next)
  {
    if (DDF_CompareName(src-&gt;mapid, temp-&gt;mapid) != 0)
      continue;

    if (temp == src)
      break;

    if (temp-&gt;crc == src-&gt;crc)
      idx_val++;
  }

  if (! temp)
    I_Error("SR_TriggerPutScript: invalid ScriptPtr %p\n", src);

  sprintf(buffer, "B:%s:%d:%lX", src-&gt;mapid, idx_val, src-&gt;crc);

  SV_PutString(buffer);
}
</t>
<t tx="T525">@ ----------------------------------------------------------------------------

SR_TipGetString
@c

boolean_t SR_TipGetString(void *storage, int index, void *extra)
{
  const char ** dest = (const char **)storage + index;

  if (*dest)
    Z_Free((char *)(*dest));

  (*dest) = SV_GetString();
  return true;
}
</t>
<t tx="T526">@ SR_TipPutString
@c

void SR_TipPutString(void *storage, int index, void *extra)
{
  const char *src = ((const char **)storage)[index];

  SV_PutString(src);
}
</t>
<t tx="T527">@ SR_PlaneMoveGetType
@c

boolean_t SR_PlaneMoveGetType(void *storage, int index, void *extra)
{
  const moving_plane_t ** dest = (const moving_plane_t **)storage + index;

  int number;
  boolean_t is_ceil;
  const char *str;

  str = SV_GetString();

  if (! str)
  {
    (*dest) = NULL;
    return true;
  }

  if (str[1] != ':' || str[3] != ':')
    I_Error("SR_PlaneMoveGetType: invalid movestr `%s'\n", str);

  is_ceil = false;

  if (str[2] == 'F')
    ;
  else if (str[2] == 'C')
    is_ceil = true;
  else
    I_Error("SR_PlaneMoveGetType: invalid floortype `%s'\n", str);

  number = strtol(str + 4, NULL, 0);

  if (str[0] == 'S')
  {
    const specialsector_t *special = DDF_SectorLookupNum(number);
    (*dest) = is_ceil ? &amp;special-&gt;c : &amp;special-&gt;f;
  }
  else if (str[0] == 'L')
  {
    const linedeftype_t *special = DDF_LineLookupNum(number);
    (*dest) = is_ceil ? &amp;special-&gt;c : &amp;special-&gt;f;
  }
  else if (str[0] == 'D')
  {
    // FIXME: this ain't gonna work, freddy
    (*dest) = is_ceil ? &amp;donut[number].c : &amp;donut[number].f;
  }
  else
    I_Error("SR_PlaneMoveGetType: invalid srctype `%s'\n", str);

  Z_Free((char *)str);
  return true;
}
</t>
<t tx="T528">@ SR_PlaneMovePutType

Format of the string:

&lt;line/sec&gt; `:' &lt;floor/ceil&gt; `:' &lt;ddf num&gt;

The first field contains `L' if the moving_plane_t is within a
linedeftype, `S' for a sectortype, or `D' for the donut (which
prolly won't work yet). The second field is `F' for the floor
field in the line/sectortype, or `C' for the ceiling field. The
last value is the line/sector DDF number.
@c

void SR_PlaneMovePutType(void *storage, int index, void *extra)
{
  const moving_plane_t *src = ((const moving_plane_t **)storage)[index];

  int i;
  char buffer[64];

  if (! src)
  {
    SV_PutString(NULL);
    return;
  }

  // check for donut
  for (i=0; i &lt; 2; i++)
  {
    if (src == &amp;donut[i].f)
    {
      sprintf(buffer, "D:F:%d", i);
      SV_PutString(buffer);
      return;
    }
    else if (src == &amp;donut[i].c)
    {
      sprintf(buffer, "D:C:%d", i);
      SV_PutString(buffer);
      return;
    }
  }

  // check all the line types
  for (i=0; i &lt; num_ddf_linetypes; i++)
  {
    if (src == &amp;ddf_linetypes[i]-&gt;f)
    {
      sprintf(buffer, "L:F:%d", ddf_linetypes[i]-&gt;ddf.number);
      SV_PutString(buffer);
      return;
    }
    else if (src == &amp;ddf_linetypes[i]-&gt;c)
    {
      sprintf(buffer, "L:C:%d", ddf_linetypes[i]-&gt;ddf.number);
      SV_PutString(buffer);
      return;
    }
  }

  // check all the sector types
  for (i=0; i &lt; num_ddf_sectors; i++)
  {
    if (src == &amp;ddf_sectors[i]-&gt;f)
    {
      sprintf(buffer, "S:F:%d", ddf_sectors[i]-&gt;ddf.number);
      SV_PutString(buffer);
      return;
    }
    else if (src == &amp;ddf_sectors[i]-&gt;c)
    {
      sprintf(buffer, "S:C:%d", ddf_sectors[i]-&gt;ddf.number);
      SV_PutString(buffer);
      return;
    }
  }

  // not found !

  I_Warning("LOADGAME: could not find moving_plane %p !\n", src);
  SV_PutString("L:C:1");
}
</t>
<t tx="T529">@ignore
@language c

// New SaveGame Handling (Things)

// This file handles:
//    mobj_t        [MOBJ]
//    spawnspot_t   [SPWN]
//    iteminque_t   [ITMQ]
//

&lt;&lt; sv_mobj #includes &gt;&gt;
&lt;&lt; sv_mobj declarations &gt;&gt;
@others
</t>
<t tx="T530">#include "i_defs.h"

#include "ddf_locl.h"
#include "dm_state.h"
#include "e_player.h"
#include "p_local.h"
#include "p_setup.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "r_state.h"
#include "z_zone.h"
</t>
<t tx="T531">
#undef SF
#define SF  SVFIELD


// forward decls.
int SV_MobjCountElems(void);
int SV_MobjFindElem(mobj_t *elem);
void * SV_MobjGetElem(int index);
void SV_MobjCreateElems(int num_elems);
void SV_MobjFinaliseElems(void);

int SV_ItemqCountElems(void);
int SV_ItemqFindElem(iteminque_t *elem);
void * SV_ItemqGetElem(int index);
void SV_ItemqCreateElems(int num_elems);
void SV_ItemqFinaliseElems(void);

boolean_t SR_MobjGetPlayer(void *storage, int index, void *extra);
boolean_t SR_MobjGetMobj(void *storage, int index, void *extra);
boolean_t SR_MobjGetType(void *storage, int index, void *extra);
boolean_t SR_MobjGetState(void *storage, int index, void *extra);
boolean_t SR_MobjGetSpawnPoint(void *storage, int index, void *extra);
boolean_t SR_MobjGetAttack(void *storage, int index, void *extra);

void SR_MobjPutPlayer(void *storage, int index, void *extra);
void SR_MobjPutMobj(void *storage, int index, void *extra);
void SR_MobjPutType(void *storage, int index, void *extra);
void SR_MobjPutState(void *storage, int index, void *extra);
void SR_MobjPutSpawnPoint(void *storage, int index, void *extra);
void SR_MobjPutAttack(void *storage, int index, void *extra);


//----------------------------------------------------------------------------
//
//  MOBJ STRUCTURE AND ARRAY
//
static mobj_t sv_dummy_mobj;

#define SV_F_BASE  sv_dummy_mobj

static savefield_t sv_fields_mobj[] =
{
  SF(x, "x", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(y, "y", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(z, "z", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(angle, "angle", 1, SVT_ANGLE, SR_GetAngle, SR_PutAngle),
  SF(floorz, "floorz", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(ceilingz, "ceilingz", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(dropoffz, "dropoffz", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(radius, "radius", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(height, "height", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(mom, "mom", 1, SVT_VEC3, SR_GetVec3, SR_PutVec3),
  SF(health, "health", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(speed, "speed", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(fuse, "fuse", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(info, "info", 1, SVT_STRING, SR_MobjGetType, SR_MobjPutType),
  SF(state, "state", 1, SVT_STRING, SR_MobjGetState, SR_MobjPutState),
  SF(next_state, "next_state", 1, SVT_STRING, SR_MobjGetState, SR_MobjPutState),
  SF(tics, "tics", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(flags, "flags", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(extendedflags, "extendedflags", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(movedir, "movedir", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(movecount, "movecount", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(reactiontime, "reactiontime", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(threshold, "threshold", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(player, "player", 1, SVT_INDEX("players"), 
      SR_MobjGetPlayer, SR_MobjPutPlayer),
  SF(spawnpoint, "spawnpoint", 1, SVT_STRUCT("spawnpoint_t"), 
      SR_MobjGetSpawnPoint, SR_MobjPutSpawnPoint),
  SF(origheight, "origheight", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(visibility, "visibility", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(vis_target, "vis_target", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(vertangle, "vertangle", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(spreadcount, "spreadcount", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(side, "side", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(currentattack, "currentattack", 1, SVT_FLOAT, 
      SR_MobjGetAttack, SR_MobjPutAttack),
  SF(source, "source", 1, SVT_INDEX("mobjs"), SR_MobjGetMobj, SR_MobjPutMobj),
  SF(target, "target", 1, SVT_INDEX("mobjs"), SR_MobjGetMobj, SR_MobjPutMobj),
  SF(tracer, "tracer", 1, SVT_INDEX("mobjs"), SR_MobjGetMobj, SR_MobjPutMobj),
  SF(supportobj, "supportobj", 1, SVT_INDEX("mobjs"), SR_MobjGetMobj, SR_MobjPutMobj),
  SF(above_mo, "above_mo", 1, SVT_INDEX("mobjs"), SR_MobjGetMobj, SR_MobjPutMobj),
  SF(below_mo, "below_mo", 1, SVT_INDEX("mobjs"), SR_MobjGetMobj, SR_MobjPutMobj),
  SF(ride_dx, "ride_dx", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(ride_dy, "ride_dy", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(on_ladder, "on_ladder", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(path_trigger, "path_trigger", 1, SVT_STRING,
      SR_TriggerGetScript, SR_TriggerPutScript),
  SF(dlight_qty, "dlight_qty", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(dlight_target, "dlight_target", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),

  // NOT HERE:
  //   subsector &amp; region: these are regenerated.
  //   next,prev,snext,sprev,bnext,bprev: links are regenerated.
  //   sprite,frame,bright: regenerated from current state.
  //   tunnel_hash: would be meaningless, and not important.
  //   lastlookup: being reset to zero won't hurt.
  //   ...
  
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_mobj =
{
  NULL,            // link in list
  "mobj_t",        // structure name
  "mobj",          // start marker
  sv_fields_mobj,  // field descriptions
  true,            // define_me
  NULL             // pointer to known struct
};

savearray_t sv_array_mobj =
{
  NULL,             // link in list
  "mobjs",          // array name
  &amp;sv_struct_mobj,  // array type
  true,             // define_me

  SV_MobjCountElems,     // count routine
  SV_MobjGetElem,        // index routine
  SV_MobjCreateElems,    // creation routine
  SV_MobjFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  SPAWNPOINT STRUCTURE
//
static spawnpoint_t sv_dummy_spawnpoint;

#define SV_F_BASE  sv_dummy_spawnpoint

static savefield_t sv_fields_spawnpoint[] =
{
  SF(x, "x", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(y, "y", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(z, "z", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(angle, "angle", 1, SVT_ANGLE, SR_GetAngle, SR_PutAngle),
  SF(slope, "slope", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(info, "info", 1, SVT_STRING, SR_MobjGetType, SR_MobjPutType),
  SF(flags, "flags", 1, SVT_INT, SR_GetInt, SR_PutInt),
 
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_spawnpoint =
{
  NULL,                 // link in list
  "spawnpoint_t",       // structure name
  "spwn",               // start marker
  sv_fields_spawnpoint, // field descriptions
  true,                 // define_me
  NULL                  // pointer to known struct
};


//----------------------------------------------------------------------------
//
//  ITEMINQUE STRUCTURE AND ARRAY
//
static iteminque_t sv_dummy_iteminque;

#define SV_F_BASE  sv_dummy_iteminque

static savefield_t sv_fields_iteminque[] =
{
  SF(spawnpoint, "spawnpoint", 1, SVT_STRUCT("spawnpoint_t"), 
      SR_MobjGetSpawnPoint, SR_MobjPutSpawnPoint),
  SF(time, "time", 1, SVT_INT, SR_GetInt, SR_PutInt),

  // NOT HERE:
  //   next,prev: links are regenerated.
 
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_iteminque =
{
  NULL,                 // link in list
  "iteminque_t",        // structure name
  "itmq",               // start marker
  sv_fields_iteminque,  // field descriptions
  true,                 // define_me
  NULL                  // pointer to known struct
};

savearray_t sv_array_iteminque =
{
  NULL,                  // link in list
  "itemquehead",         // array name
  &amp;sv_struct_iteminque,  // array type
  true,                  // define_me

  SV_ItemqCountElems,     // count routine
  SV_ItemqGetElem,        // index routine
  SV_ItemqCreateElems,    // creation routine
  SV_ItemqFinaliseElems,  // finalisation routine

  NULL,  // pointer to known array
  0      // loaded size
};
</t>
<t tx="T532">@ ----------------------------------------------------------------------------

SV_MobjCountElems
@c

int SV_MobjCountElems(void)
{
  mobj_t *cur;
  int count=0;

  for (cur=mobjlisthead; cur; cur=cur-&gt;next)
    count++;
  
  return count;
}
</t>
<t tx="T533">@ SV_MobjGetElem

The index here starts at 0.
@c

void *SV_MobjGetElem(int index)
{
  mobj_t *cur;

  for (cur=mobjlisthead; cur &amp;&amp; index &gt; 0; cur=cur-&gt;next)
    index--;
  
  if (!cur)
    I_Error("LOADGAME: Invalid Mobj: %d\n", index);
  
  DEV_ASSERT2(index == 0);
  DEV_ASSERT2(cur-&gt;info);

  return cur;
}
</t>
<t tx="T534">@ SV_MobjFindElem

Returns the index number (starts at 0 here).
@c

int SV_MobjFindElem(mobj_t *elem)
{
  mobj_t *cur;
  int index;

  for (cur=mobjlisthead, index=0; cur &amp;&amp; cur != elem; cur=cur-&gt;next)
    index++;
  
  if (!cur)
    I_Error("LOADGAME: No such MobjPtr: %p\n", elem);
  
  return index;
}
</t>
<t tx="T535">@ SV_MobjCreateElems
@c

void SV_MobjCreateElems(int num_elems)
{
  // free existing mobjs
  if (mobjlisthead)
    P_RemoveMobjs();
  
  mobjlisthead = NULL;
  
  for (; num_elems &gt; 0; num_elems--)
  {
    mobj_t *cur = Z_ClearNew(mobj_t, 1);

    cur-&gt;next = mobjlisthead;
    cur-&gt;prev = NULL;

    if (mobjlisthead)
      mobjlisthead-&gt;prev = cur;
    
    mobjlisthead = cur;

    // initialise defaults
    cur-&gt;info = mobjinfo[0];
    cur-&gt;state = cur-&gt;next_state = states+1;
  }
}
</t>
<t tx="T536">@ SV_MobjFinaliseElems
@c

void SV_MobjFinaliseElems(void)
{
  mobj_t *mo;

  for (mo=mobjlisthead; mo; mo=mo-&gt;next)
  {
    if (mo-&gt;state)
    {
      mo-&gt;sprite = mo-&gt;state-&gt;sprite;
      mo-&gt;frame  = mo-&gt;state-&gt;frame;
      mo-&gt;bright = mo-&gt;state-&gt;bright;
    }

    P_SetThingPosition(mo);

    // handle reference counts

    #define REF_COUNT_FIELD(field)  \
        if (mo-&gt;field) mo-&gt;field-&gt;refcount++;
    
    REF_COUNT_FIELD(tracer);
    REF_COUNT_FIELD(source);
    REF_COUNT_FIELD(target);
    REF_COUNT_FIELD(supportobj);
    REF_COUNT_FIELD(above_mo);
    REF_COUNT_FIELD(below_mo);

    #undef REF_COUNT_FIELD

    // sanity checks
  }
}
</t>
<t tx="T537">@ ----------------------------------------------------------------------------

SV_ItemqCountElems
@c

int SV_ItemqCountElems(void)
{
  iteminque_t *cur;
  int count=0;

  for (cur=itemquehead; cur; cur=cur-&gt;next)
    count++;
  
  return count;
}
</t>
<t tx="T538">@ SV_ItemqGetElem

The index value starts at 0.
@c

void *SV_ItemqGetElem(int index)
{
  iteminque_t *cur;

  for (cur=itemquehead; cur &amp;&amp; index &gt; 0; cur=cur-&gt;next)
    index--;
  
  if (!cur)
    I_Error("LOADGAME: Invalid ItemInQue: %d\n", index);
  
  DEV_ASSERT2(index == 0);
  return cur;
}
</t>
<t tx="T539">@ SV_ItemqFindElem

Returns the index number (starts at 0 here).
@c

int SV_ItemqFindElem(iteminque_t *elem)
{
  iteminque_t *cur;
  int index;

  for (cur=itemquehead, index=0; cur &amp;&amp; cur != elem; cur=cur-&gt;next)
    index++;
  
  if (!cur)
    I_Error("LOADGAME: No such ItemInQue ptr: %p\n", elem);
  
  return index;
}
</t>
<t tx="T540">@ SV_ItemqCreateElems
@c

void SV_ItemqCreateElems(int num_elems)
{
  P_RemoveItemsInQue();
  
  itemquehead = NULL;
 
  for (; num_elems &gt; 0; num_elems--)
  {
    iteminque_t *cur = Z_ClearNew(iteminque_t, 1);

    cur-&gt;next = itemquehead;
    cur-&gt;prev = NULL;

    if (itemquehead)
      itemquehead-&gt;prev = cur;
    
    itemquehead = cur;

    // initialise defaults: leave blank
  }
}
</t>
<t tx="T541">@ SV_ItemqFinaliseElems
@c

void SV_ItemqFinaliseElems(void)
{
  iteminque_t *cur, *next;

  // remove any dead wood
  for (cur = itemquehead; cur; cur = next)
  {
    next = cur-&gt;next;

    if (cur-&gt;spawnpoint.info)
      continue;

    I_Warning("LOADGAME: discarding empty ItemInQue\n");

    if (next)
      next-&gt;prev = cur-&gt;prev;

    if (cur-&gt;prev)
      cur-&gt;prev-&gt;next = next;
    else
      itemquehead = next;

    Z_Free(cur);
  }
}
</t>
<t tx="T542">@ ----------------------------------------------------------------------------

SR_MobjGetPlayer
@c

boolean_t SR_MobjGetPlayer(void *storage, int index, void *extra)
{
  player_t ** dest = (player_t **)storage + index;

  int swizzle = SV_GetInt();

  *dest = (swizzle == 0) ? NULL : SV_PlayerGetElem(swizzle - 1);
  return true;
}
</t>
<t tx="T543">@ SR_MobjPutPlayer
@c

void SR_MobjPutPlayer(void *storage, int index, void *extra)
{
  player_t *elem = ((player_t **)storage)[index];

  int swizzle = (elem == NULL) ? 0 : SV_PlayerFindElem(elem) + 1;

  SV_PutInt(swizzle);
}
</t>
<t tx="T544">@ SR_MobjGetMobj
@c

boolean_t SR_MobjGetMobj(void *storage, int index, void *extra)
{
  mobj_t ** dest = (mobj_t **)storage + index;

  int swizzle = SV_GetInt();

  *dest = (swizzle == 0) ? NULL : SV_MobjGetElem(swizzle - 1);
  return true;
}
</t>
<t tx="T545">@ SR_MobjPutMobj
@c

void SR_MobjPutMobj(void *storage, int index, void *extra)
{
  mobj_t *elem = ((mobj_t **)storage)[index];

  int swizzle;

  // -AJA- HACK: temp fix for dummy targets.
  if (elem &amp;&amp; elem-&gt;extendedflags &amp; EF_DUMMYMOBJ)
  {
    SV_PutInt(0);
    return;
  }

  swizzle = (elem == NULL) ? 0 : SV_MobjFindElem(elem) + 1;
  SV_PutInt(swizzle);
}
</t>
<t tx="T546">@ SR_MobjGetType
@c

boolean_t SR_MobjGetType(void *storage, int index, void *extra)
{
  mobjinfo_t ** dest = (mobjinfo_t **)storage + index;

  const char *name = SV_GetString();

  // Intentional Const Override
  *dest = (name == NULL) ? NULL : (mobjinfo_t *)DDF_MobjLookup(name);

  Z_Free((char *)name);
  return true;
}
</t>
<t tx="T547">@ SR_MobjPutType
@c

void SR_MobjPutType(void *storage, int index, void *extra)
{
  mobjinfo_t *info = ((mobjinfo_t **)storage)[index];

  SV_PutString((info == NULL) ? NULL : info-&gt;ddf.name);
}
</t>
<t tx="T548">@ SR_MobjGetSpawnPoint
@c

boolean_t SR_MobjGetSpawnPoint(void *storage, int index, void *extra)
{
  spawnpoint_t *dest = (spawnpoint_t *)storage + index;

  if (sv_struct_spawnpoint.counterpart)
    return SV_LoadStruct(dest, sv_struct_spawnpoint.counterpart);
  
  return true;  // presumably
}
</t>
<t tx="T549">@ SR_MobjPutSpawnPoint
@c

void SR_MobjPutSpawnPoint(void *storage, int index, void *extra)
{
  spawnpoint_t *src = (spawnpoint_t *)storage + index;

  SV_SaveStruct(src, &amp;sv_struct_spawnpoint);
}
</t>
<t tx="T550">@ SR_MobjGetAttack
@c

boolean_t SR_MobjGetAttack(void *storage, int index, void *extra)
{
  attacktype_t ** dest = (attacktype_t **)storage + index;

  const char *name = SV_GetString();

  // Intentional Const Override
  *dest = (name == NULL) ? NULL : (attacktype_t *)DDF_AttackLookup(name);

  Z_Free((char *)name);
  return true;
}
</t>
<t tx="T551">@ SR_MobjPutAttack
@c

void SR_MobjPutAttack(void *storage, int index, void *extra)
{
  attacktype_t *info = ((attacktype_t **)storage)[index];

  SV_PutString((info == NULL) ? NULL : info-&gt;ddf.name);
}
</t>
<t tx="T552">@ ----------------------------------------------------------------------------

SR_MobjGetState
@c

boolean_t SR_MobjGetState(void *storage, int index, void *extra)
{
  state_t ** dest = (state_t **)storage + index;

  char buffer[256];
  char *base_p, *off_p;
  int i, base, offset;

  const char *swizzle;
  const mobj_t *mo = (mobj_t *) sv_current_elem;
  const mobjinfo_t *actual;

  DEV_ASSERT2(mo);
  DEV_ASSERT2(mo-&gt;info);

  swizzle = SV_GetString();

  if (! swizzle)
  {
    *dest = NULL;
    return true;
  }

  Z_StrNCpy(buffer, swizzle, 256-1);
  Z_Free((char *)swizzle);

  // separate string at `:' characters

  base_p = strchr(buffer, ':');

  if (base_p == NULL || base_p[0] == 0)
    I_Error("Corrupt savegame: bad state 1/2: `%s'\n", buffer);

  *base_p++ = 0;

  off_p = strchr(base_p, ':');

  if (off_p == NULL || off_p[0] == 0)
    I_Error("Corrupt savegame: bad state 2/2: `%s'\n", base_p);
  
  *off_p++ = 0;
  
  // find thing that contains the state
  actual = mo-&gt;info;
  
  if (buffer[0] != '*')
  {
    // traverse backwards in case #CLEARALL was used
    for (i=num_mobjinfo-1; i &gt;= 0; i--)
    {
      actual = mobjinfo[i];

      if (! actual-&gt;ddf.name)
        continue;

      if (DDF_CompareName(buffer, actual-&gt;ddf.name) == 0)
        break;
    }

    if (i &lt; 0)
      I_Error("LOADGAME: no such thing %s for state %s:%s\n",
          buffer, base_p, off_p);
  }

  // find base state
  offset = strtol(off_p, NULL, 0) - 1;
  
  for (base=actual-&gt;first_state; base &lt;= actual-&gt;last_state; base++)
  {
    if (! states[base].label)
      continue;
    
    if (DDF_CompareName(base_p, states[base].label) == 0)
      break;
  }

  if (base &gt; actual-&gt;last_state)
  {
    I_Warning("LOADGAME: no such label `%s' for state.\n", base_p);
    offset = 0;

    if (actual-&gt;idle_state)
      base = actual-&gt;idle_state;
    else if (actual-&gt;spawn_state)
      base = actual-&gt;spawn_state;
    else if (actual-&gt;meander_state)
      base = actual-&gt;meander_state;
    else
      base = actual-&gt;first_state;
  }

#if 0
  L_WriteDebug("Unswizzled state `%s:%s:%s' -&gt; %d\n", 
      buffer, base_p, off_p, base + offset);
#endif

  *dest = states + base + offset;
  
  return true;
}
</t>
<t tx="T553">@ SR_MobjPutState

The format of the string is:

THING `:' BASE `:' OFFSET

where THING is usually just "*" for the current thing, but can
refer to another ddf thing (e.g. "IMP"). BASE is the nearest
labelled state (e.g. "SPAWN"), or "*" as offset from the thing's
first state (unlikely to be needed). OFFSET is the integer offset
from the base state (e.g. "5"), which BTW starts at 1 (like the ddf
format).

Alternatively, the string can be NULL, which means the state
pointer should be NULL.

P.S: we go to all this trouble to try and get reasonable behaviour
when loading with different DDF files than what we saved with.
Typical example: a new item, monster or weapon gets added to our
DDF files causing all state numbers to be shifted upwards.
@c

void SR_MobjPutState(void *storage, int index, void *extra)
{
  state_t *S = ((state_t **)storage)[index];

  char swizzle[64];

  int i, s_num, base;

  const mobj_t *mo = (mobj_t *) sv_current_elem;
  const mobjinfo_t *actual;

  DEV_ASSERT2(mo);
  DEV_ASSERT2(mo-&gt;info);
  
  if (S == NULL)
  {
    SV_PutString(NULL);
    return;
  }

  // object has no states ?
  if (mo-&gt;info-&gt;last_state &lt;= 0 || 
      mo-&gt;info-&gt;last_state &lt; mo-&gt;info-&gt;first_state)
  {
    I_Warning("SAVEGAME: object [%s] has no states !!\n", mo-&gt;info-&gt;ddf.name);
    SV_PutString(NULL);
    return;
  }

  // get state number, check if valid
  s_num = S - states;

  if (s_num &lt; 0 || s_num &gt;= num_states)
  {
    I_Warning("SAVEGAME: object [%s] is in invalid state %d\n", 
        mo-&gt;info-&gt;ddf.name, s_num);

    if (mo-&gt;info-&gt;idle_state)
      s_num = mo-&gt;info-&gt;idle_state;
    else if (mo-&gt;info-&gt;spawn_state)
      s_num = mo-&gt;info-&gt;spawn_state;
    else if (mo-&gt;info-&gt;meander_state)
      s_num = mo-&gt;info-&gt;meander_state;
    else
    {
      SV_PutString("*:*:1");
      return;
    }
  }

  // state gone AWOL into another object ?
  actual = mo-&gt;info;

  if (s_num &lt; mo-&gt;info-&gt;first_state || s_num &gt; mo-&gt;info-&gt;last_state)
  {
    I_Warning("SAVEGAME: object [%s] is in AWOL state %d\n",
        mo-&gt;info-&gt;ddf.name, s_num);

    // look for real object
    for (i=0; i &lt; num_mobjinfo; i++)
    {
      actual = mobjinfo[i];

      if (actual-&gt;last_state &lt;= 0 ||
          actual-&gt;last_state &lt; actual-&gt;first_state)
        continue;

      if (actual-&gt;first_state &lt;= s_num &amp;&amp; s_num &lt;= actual-&gt;last_state)
        break;
    }

    if (i == num_mobjinfo)
    {
      I_Warning("-- ARGH: state %d cannot be found !!\n", s_num);
      SV_PutString("*:*:1");
      return;
    }

    if (! actual-&gt;ddf.name)
    {
      I_Warning("-- OOPS: state %d found in unnamed object !!\n", s_num);
      SV_PutString("*:*:1");
      return;
    }
  }
  
  // find the nearest base state
  
  for (base = s_num; 
       base &gt; mo-&gt;info-&gt;first_state &amp;&amp; states[base].label == NULL;
       base--)
  { /* nothing */ }

  sprintf(swizzle, "%s:%s:%d", 
      actual == mo-&gt;info ? "*" : actual-&gt;ddf.name, 
      states[base].label ? states[base].label : "*",
      1 + s_num - base);

#if 0
  L_WriteDebug("Swizzled state %d of [%s] -&gt; `%s'\n", 
      s_num, mo-&gt;info-&gt;ddf.name, swizzle);
#endif

  SV_PutString(swizzle);
}
</t>
<t tx="T554">@ignore
@language c

// New SaveGame Handling (Players)

// This file handles:
//   player_t        [PLAY]
//   playerweapon_t  [WEAP]
//   playerammo_t    [AMMO]
//   psprite_t       [PSPR]

&lt;&lt; sv_play #includes &gt;&gt;
&lt;&lt; sv_play declarations &gt;&gt;
@others
</t>
<t tx="T555">#include "i_defs.h"

#include "dm_state.h"
#include "e_player.h"
#include "p_local.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "r_state.h"
#include "z_zone.h"
</t>
<t tx="T556">
#undef SF
#define SF  SVFIELD


// forward decls.
int SV_PlayerCountElems(void);
int SV_PlayerFindElem(player_t *elem);
void * SV_PlayerGetElem(int index);
void SV_PlayerCreateElems(int num_elems);
void SV_PlayerFinaliseElems(void);

boolean_t SR_PlayerGetAmmo(void *storage, int index, void *extra);
boolean_t SR_PlayerGetWeapon(void *storage, int index, void *extra);
boolean_t SR_PlayerGetPSprite(void *storage, int index, void *extra);
boolean_t SR_PlayerGetName(void *storage, int index, void *extra);
boolean_t SR_PlayerGetState(void *storage, int index, void *extra);
boolean_t SR_WeaponGetInfo(void *storage, int index, void *extra);

void SR_PlayerPutAmmo(void *storage, int index, void *extra);
void SR_PlayerPutWeapon(void *storage, int index, void *extra);
void SR_PlayerPutPSprite(void *storage, int index, void *extra);
void SR_PlayerPutName(void *storage, int index, void *extra);
void SR_PlayerPutState(void *storage, int index, void *extra);
void SR_WeaponPutInfo(void *storage, int index, void *extra);


//----------------------------------------------------------------------------
//
//  PLAYER STRUCTURE AND ARRAY
//
static player_t sv_dummy_player;

#define SV_F_BASE  sv_dummy_player

static savefield_t sv_fields_player[] =
{
  SF(pnum, "pnum", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(playerstate, "playerstate", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(playername[0], "playername", 1, SVT_STRING, 
      SR_PlayerGetName, SR_PlayerPutName),
  SF(mo, "mo", 1, SVT_INDEX("mobjs"), SR_MobjGetMobj, SR_MobjPutMobj),
  SF(viewz, "viewz", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(viewheight, "viewheight", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(deltaviewheight, "deltaviewheight", 1, SVT_FLOAT, 
      SR_GetFloat, SR_PutFloat),
  SF(std_viewheight, "std_viewheight", 1, SVT_FLOAT, 
      SR_GetFloat, SR_PutFloat),
  SF(health, "health", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(armours[0], "armours", NUMARMOUR, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(powers[0],  "powers",  NUMPOWERS, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(cards, "cards_ke", 1, SVT_ENUM, SR_GetEnum, SR_PutEnum),
  SF(frags, "frags", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(totalfrags, "totalfrags", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(ready_wp, "ready_wp", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(pending_wp, "pending_wp", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(weapons[0], "weapons", MAXWEAPONS, SVT_STRUCT("playerweapon_t"), 
      SR_PlayerGetWeapon, SR_PlayerPutWeapon),
  SF(ammo[0], "ammo", NUMAMMO, SVT_STRUCT("playerammo_t"), 
      SR_PlayerGetAmmo, SR_PlayerPutAmmo),
  SF(cheats, "cheats", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(killcount, "killcount", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(itemcount, "itemcount", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(secretcount, "secretcount", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(jumpwait, "jumpwait", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(air_in_lungs, "air_in_lungs", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(underwater, "underwater", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),
  SF(flash, "flash_b", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),
  SF(psprites[0], "psprites", NUMPSPRITES, SVT_STRUCT("psprite_t"), 
      SR_PlayerGetPSprite, SR_PlayerPutPSprite),

  // NOT HERE:
  //   in_game: only in-game players are saved.
  //   key_choices: depends on DDF too much, and not important.
  //   remember_atk1/2: ditto.
  //   next,prev: links are regenerated.
  
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_player =
{
  NULL,          // link in list
  "player_t",    // structure name
  "play",        // start marker
  sv_fields_player,  // field descriptions
  true,          // define_me
  NULL           // pointer to known struct
};

savearray_t sv_array_player =
{
  NULL,               // link in list
  "players",          // array name
  &amp;sv_struct_player,  // array type
  true,               // define_me

  SV_PlayerCountElems,     // count routine
  SV_PlayerGetElem,        // index routine
  SV_PlayerCreateElems,    // creation routine
  SV_PlayerFinaliseElems,  // finalisation routine

  NULL,     // pointer to known array
  0         // loaded size
};


//----------------------------------------------------------------------------
//
//  WEAPON STRUCTURE
//
static playerweapon_t sv_dummy_playerweapon;

#define SV_F_BASE  sv_dummy_playerweapon

static savefield_t sv_fields_playerweapon[] =
{
  SF(info, "info", 1, SVT_STRING, SR_WeaponGetInfo, SR_WeaponPutInfo),
  SF(owned, "owned", 1, SVT_BOOLEAN, SR_GetBoolean, SR_PutBoolean),
  SF(clip_size, "clip_size", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(sa_clip_size, "sa_clip_size", 1, SVT_INT, SR_GetInt, SR_PutInt),
  
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_playerweapon =
{
  NULL,          // link in list
  "playerweapon_t",    // structure name
  "weap",        // start marker
  sv_fields_playerweapon,  // field descriptions
  true,          // define_me
  NULL           // pointer to known struct
};


//----------------------------------------------------------------------------
//
//  AMMO STRUCTURE
//
static playerammo_t sv_dummy_playerammo;

#define SV_F_BASE  sv_dummy_playerammo

static savefield_t sv_fields_playerammo[] =
{
  SF(num, "num", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(max, "max", 1, SVT_INT, SR_GetInt, SR_PutInt),
  
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_playerammo =
{
  NULL,          // link in list
  "playerammo_t",    // structure name
  "ammo",        // start marker
  sv_fields_playerammo,  // field descriptions
  true,          // define_me
  NULL           // pointer to known struct
};


//----------------------------------------------------------------------------
//
//  PSPRITE STRUCTURE
//
static pspdef_t sv_dummy_psprite;

#define SV_F_BASE  sv_dummy_psprite

static savefield_t sv_fields_psprite[] =
{
  SF(state, "state", 1, SVT_STRING, SR_PlayerGetState, SR_PlayerPutState),
  SF(next_state, "next_state", 1, SVT_STRING, 
      SR_PlayerGetState, SR_PlayerPutState),
  SF(tics, "tics", 1, SVT_INT, SR_GetInt, SR_PutInt),
  SF(visibility, "visibility", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  SF(vis_target, "vis_target", 1, SVT_FLOAT, SR_GetFloat, SR_PutFloat),
  
  // NOT HERE:
  //   sx, sy: they can be regenerated.
  
  SVFIELD_END
};

#undef SV_F_BASE

savestruct_t sv_struct_psprite =
{
  NULL,          // link in list
  "pspdef_t",    // structure name
  "pspr",        // start marker
  sv_fields_psprite,  // field descriptions
  true,          // define_me
  NULL           // pointer to known struct
};
</t>
<t tx="T557">@ ----------------------------------------------------------------------------

SV_PlayerCountElems
@c

int SV_PlayerCountElems(void)
{
  player_t *p;
  int count=0;

  for (p=players; p; p=p-&gt;next)
    count++;
  
  return count;
}
</t>
<t tx="T558">@ SV_PlayerGetElem
@c

void *SV_PlayerGetElem(int index)
{
  player_t *p;

  for (p=players; p &amp;&amp; index &gt; 0; p=p-&gt;next)
    index--;
  
  if (!p)
    I_Error("LOADGAME: Invalid Player: %d\n", index);
  
  DEV_ASSERT2(index == 0);

  return p;
}
</t>
<t tx="T559">@ SV_PlayerFindElem
@c

int SV_PlayerFindElem(player_t *elem)
{
  player_t *p;
  int index;

  for (p=players, index=0; p &amp;&amp; p != elem; p=p-&gt;next)
    index++;
  
  if (!p)
    I_Error("LOADGAME: No such PlayerPtr: %p\n", elem);
  
  return index;
}
</t>
<t tx="T560">@ SV_PlayerCreateElems
@c

void SV_PlayerCreateElems(int num_elems)
{
  int j;

  // free existing players
  P_RemoveAllPlayers();
  
  players = NULL;
  
  for (; num_elems &gt; 0; num_elems--)
  {
    player_t *p = Z_ClearNew(player_t, 1);

    p-&gt;pnum = num_elems-1;
    sprintf(p-&gt;playername, "Player%d", 1 + p-&gt;pnum);
    
    p-&gt;next = players;
    p-&gt;prev = NULL;

    if (players)
      players-&gt;prev = p;

    players = p;

    // initialise defaults
    p-&gt;in_game = true;
    p-&gt;remember_atk1 = p-&gt;remember_atk2 = -1;
    
    for (j=0; j &lt; NUMPSPRITES; j++)
    {
      p-&gt;psprites[j].sx = 1.0;
      p-&gt;psprites[j].sy = WEAPONTOP;
    }
  }
}
</t>
<t tx="T561">@ SV_PlayerFinaliseElems
@c

void SV_PlayerFinaliseElems(void)
{
  player_t *p;

  // create playerlookup[] array
  if (! playerlookup)
    playerlookup = Z_ClearNew(player_t *, MAXPLAYERS);

  for (p=players; p; p=p-&gt;next)
  {
    if (p-&gt;pnum &gt;= MAXPLAYERS)
    {
      // Ouch!!
      continue;
    }

    if (playerlookup[p-&gt;pnum])
      I_Error("LOADGAME: Two players with same number !\n");
     
    if (! p-&gt;mo)
      I_Error("LOADGAME: Player %d has no mobj !\n", p-&gt;pnum);
     
    playerlookup[p-&gt;pnum] = p;

    p-&gt;thinker = P_ConsolePlayerThinker;  //!!!!! FIXME

    P_UpdateAvailWeapons(p);
  }

  consoleplayer = displayplayer = players;  //!!!! FIXME
}
</t>
<t tx="T562">@ ----------------------------------------------------------------------------

SR_PlayerGetAmmo
@c

boolean_t SR_PlayerGetAmmo(void *storage, int index, void *extra)
{
  playerammo_t *dest = (playerammo_t *)storage + index;

  if (sv_struct_playerammo.counterpart)
    return SV_LoadStruct(dest, sv_struct_playerammo.counterpart);
  
  return true;  // presumably
}
</t>
<t tx="T563">@ SR_PlayerPutAmmo
@c

void SR_PlayerPutAmmo(void *storage, int index, void *extra)
{
  playerammo_t *src = (playerammo_t *)storage + index;

  SV_SaveStruct(src, &amp;sv_struct_playerammo);
}
</t>
<t tx="T564">@ SR_PlayerGetWeapon
@c

boolean_t SR_PlayerGetWeapon(void *storage, int index, void *extra)
{
  playerweapon_t *dest = (playerweapon_t *)storage + index;

  if (sv_struct_playerweapon.counterpart)
    return SV_LoadStruct(dest, sv_struct_playerweapon.counterpart);
  
  return true;  // presumably
}
</t>
<t tx="T565">@ SR_PlayerPutWeapon
@c

void SR_PlayerPutWeapon(void *storage, int index, void *extra)
{
  playerweapon_t *src = (playerweapon_t *)storage + index;

  SV_SaveStruct(src, &amp;sv_struct_playerweapon);
}
</t>
<t tx="T566">@ SR_PlayerGetPSprite
@c

boolean_t SR_PlayerGetPSprite(void *storage, int index, void *extra)
{
  pspdef_t *dest = (pspdef_t *)storage + index;

  //!!! FIXME: should skip if no counterpart
  if (sv_struct_psprite.counterpart)
    return SV_LoadStruct(dest, sv_struct_psprite.counterpart);
  
  return true;  // presumably
}
</t>
<t tx="T567">@ SR_PlayerPutPSprite
@c

void SR_PlayerPutPSprite(void *storage, int index, void *extra)
{
  pspdef_t *src = (pspdef_t *)storage + index;

  SV_SaveStruct(src, &amp;sv_struct_psprite);
}
</t>
<t tx="T568">@ SR_PlayerGetName
@c

boolean_t SR_PlayerGetName(void *storage, int index, void *extra)
{
  char *dest = (char *)storage;
  const char *str;

  DEV_ASSERT(index == 0, ("SR_PlayerGetName: index != 0"));

  str = SV_GetString();
  Z_StrNCpy(dest, str, MAX_PLAYNAME-1);
  Z_Free((char *)str);

  return true;
}
</t>
<t tx="T569">@ SR_PlayerPutName
@c

void SR_PlayerPutName(void *storage, int index, void *extra)
{
  char *src = (char *)storage;

  DEV_ASSERT(index == 0, ("SR_PlayerGetName: index != 0"));

  SV_PutString(src);
}
</t>
<t tx="T570">@ SR_WeaponGetInfo
@c

boolean_t SR_WeaponGetInfo(void *storage, int index, void *extra)
{
  weaponinfo_t ** dest = (weaponinfo_t **)storage + index;
  const char *name;
  int num;

  name = SV_GetString();

  num = name ? DDF_WeaponLookup(name) : -1;
  Z_Free((char *)name);
  
  *dest = (num &lt; 0) ? NULL : weaponinfo[num];
  return true;
}
</t>
<t tx="T571">@ SR_WeaponPutInfo
@c

void SR_WeaponPutInfo(void *storage, int index, void *extra)
{
  weaponinfo_t *info = ((weaponinfo_t **)storage)[index];

  SV_PutString(info ? info-&gt;ddf.name : NULL);
}
</t>
<t tx="T572">@ ----------------------------------------------------------------------------

SR_PlayerGetState
@c

boolean_t SR_PlayerGetState(void *storage, int index, void *extra)
{
  state_t ** dest = (state_t **)storage + index;

  char buffer[256];
  char *base_p, *off_p;
  int i, base, offset;

  const char *swizzle;
  const weaponinfo_t *actual;

  swizzle = SV_GetString();

  if (! swizzle)
  {
    *dest = NULL;
    return true;
  }

  Z_StrNCpy(buffer, swizzle, 256-1);
  Z_Free((char *)swizzle);

  // separate string at `:' characters

  base_p = strchr(buffer, ':');

  if (base_p == NULL || base_p[0] == 0)
    I_Error("Corrupt savegame: bad weapon state 1: `%s'\n", buffer);

  *base_p++ = 0;

  off_p = strchr(base_p, ':');

  if (off_p == NULL || off_p[0] == 0)
    I_Error("Corrupt savegame: bad weapon state 2: `%s'\n", base_p);
  
  *off_p++ = 0;
  
  // find weapon that contains the state
  // Traverses backwards in case #CLEARALL was used.
  actual = NULL;

  for (i=numweapons-1; i &gt;= 0; i--)
  {
    actual = weaponinfo[i];

    if (! actual-&gt;ddf.name)
      continue;

    if (DDF_CompareName(buffer, actual-&gt;ddf.name) == 0)
      break;
  }

  if (i &lt; 0)
    I_Error("LOADGAME: no such weapon %s for state %s:%s\n",
        buffer, base_p, off_p);

  // find base state
  offset = strtol(off_p, NULL, 0) - 1;
  
  for (base=actual-&gt;first_state; base &lt;= actual-&gt;last_state; base++)
  {
    if (! states[base].label)
      continue;
    
    if (DDF_CompareName(base_p, states[base].label) == 0)
      break;
  }

  if (base &gt; actual-&gt;last_state)
  {
    I_Warning("LOADGAME: no such label `%s' for weapon state.\n", base_p);

    offset = 0;
    base = actual-&gt;ready_state;
  }

#if 0
  L_WriteDebug("Unswizzled weapon state `%s:%s:%s' -&gt; %d\n", 
      buffer, base_p, off_p, base + offset);
#endif

  *dest = states + base + offset;
  
  return true;
}
</t>
<t tx="T573">@ SR_PlayerPutState

The format of the string is:

WEAPON:BASE:OFFSET

where WEAPON refers the ddf weapon containing the state. BASE is
the nearest labelled state (e.g. "SPAWN"), or "*" as offset from
the weapon's first state (unlikely to be needed). OFFSET is the
integer offset from the base state, which BTW starts at 1 (like in
ddf).

Alternatively, the string can be NULL, which means the state
pointer should be NULL.
@c

void SR_PlayerPutState(void *storage, int index, void *extra)
{
  state_t *S = ((state_t **)storage)[index];

  char swizzle[64];
  int i, s_num, base;

  const weaponinfo_t *actual;

  if (S == NULL)
  {
    SV_PutString(NULL);
    return;
  }

  // get state number, check if valid
  s_num = S - states;

  if (s_num &lt; 0 || s_num &gt;= num_states)
  {
    I_Warning("SAVEGAME: weapon is in invalid state %d\n", s_num);
    s_num = weaponinfo[0]-&gt;first_state;
  }

  // find the weapon that this state belongs to.
  // Traverses backwards in case #CLEARALL was used.
  actual = NULL;

  for (i=numweapons-1; i &gt;= 0; i--)
  {
    actual = weaponinfo[i];

    if (actual-&gt;last_state &lt;= 0 ||
        actual-&gt;last_state &lt; actual-&gt;first_state)
      continue;

    if (actual-&gt;first_state &lt;= s_num &amp;&amp; s_num &lt;= actual-&gt;last_state)
      break;
  }

  if (i &lt; 0)
  {
    I_Warning("SAVEGAME: weapon state %d cannot be found !!\n", s_num);
    actual = weaponinfo[0];
    s_num = actual-&gt;first_state;
  }
  
  // find the nearest base state
  
  for (base = s_num; 
       base &gt; actual-&gt;first_state &amp;&amp; states[base].label == NULL;
       base--)
  { /* nothing */ }

  sprintf(swizzle, "%s:%s:%d", actual-&gt;ddf.name,
      states[base].label ? states[base].label : "*",
      1 + s_num - base);

#if 0
  L_WriteDebug("Swizzled state of weapon %d -&gt; `%s'\n", s_num, swizzle);
#endif

  SV_PutString(swizzle);
}
</t>
<t tx="T574">@ignore
@language c

// New SaveGame Handling (Saving)

&lt;&lt; sv_save #includes &gt;&gt;
@others
</t>
<t tx="T575">#include "i_defs.h"
#include "sv_chunk.h"

#include "dm_state.h"
#include "e_main.h"
#include "g_game.h"
#include "m_math.h"
#include "m_misc.h"
#include "m_random.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_state.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"
</t>
<t tx="T576">@ SV_BeginSave
@c

void SV_BeginSave(void)
{
  L_WriteDebug("SV_BeginSave...\n");
}
</t>
<t tx="T577">@ SV_FinishSave
@c

void SV_FinishSave(void)
{
  L_WriteDebug("SV_FinishSave...\n");
}
</t>
<t tx="T578">@ SV_SaveStruct
@c

void SV_SaveStruct(void *base, savestruct_t *info)
{
  savefield_t *cur;
  char *storage;
  int i;
  
  SV_PushWriteChunk(info-&gt;marker);
  
  for (cur=info-&gt;fields; cur-&gt;type.kind != SFKIND_Invalid; cur++)
  {
    // ignore read-only (fudging) fields
    if (! cur-&gt;field_put)
      continue;
    
    storage = ((char *)base) + cur-&gt;offset;

    for (i=0; i &lt; cur-&gt;count; i++)
    {
      switch (cur-&gt;type.kind)
      {
        case SFKIND_Struct:
        case SFKIND_Index:
          (* cur-&gt;field_put)(storage, i, (char*)cur-&gt;type.name);
          break;
        
        default:
          (* cur-&gt;field_put)(storage, i, NULL);
          break;
      }
    }
  }

  SV_PopWriteChunk();
}
</t>
<t tx="T579">
static void SV_SaveSTRU(savestruct_t *S)
{
  int i, num;
  savefield_t *F;

  // count number of fields
  for (num=0; S-&gt;fields[num].type.kind != SFKIND_Invalid; num++)
  { /* nothing here */ }

  SV_PutInt(num);

  SV_PutString(S-&gt;struct_name);
  SV_PutString(S-&gt;marker);

  // write out the fields

  for (i=0, F=S-&gt;fields; i &lt; num; i++, F++)
  {
    SV_PutByte((unsigned char) F-&gt;type.kind);
    SV_PutByte((unsigned char) F-&gt;type.size);
    SV_PutShort((unsigned short) F-&gt;count);
    SV_PutString(F-&gt;field_name);

    if (F-&gt;type.kind == SFKIND_Struct ||
        F-&gt;type.kind == SFKIND_Index)
    {
      SV_PutString(F-&gt;type.name);
    }
  }
}
</t>
<t tx="T580">
static void SV_SaveARRY(savearray_t *A)
{
  int num_elem = (* A-&gt;count_elems)();

  SV_PutInt(num_elem);

  SV_PutString(A-&gt;array_name);
  SV_PutString(A-&gt;sdef-&gt;struct_name);
}
</t>
<t tx="T581">
static void SV_SaveDATA(savearray_t *A)
{
  int num_elem = (* A-&gt;count_elems)();
  int i;
  
  SV_PutString(A-&gt;array_name);

  for (i=0; i &lt; num_elem; i++)
  {
    sv_current_elem = (* A-&gt;get_elem)(i);

    DEV_ASSERT2(sv_current_elem);

    SV_SaveStruct(sv_current_elem, A-&gt;sdef);
  }
}
</t>
<t tx="T582">@ SV_SaveEverything
@c

void SV_SaveEverything(void)
{
  savestruct_t *stru;
  savearray_t  *arry;
  
  // Structure Area
  for (stru=sv_known_structs; stru; stru=stru-&gt;next)
  {
    if (! stru-&gt;define_me)
      continue;

    SV_PushWriteChunk("Stru");
    SV_SaveSTRU(stru);
    SV_PopWriteChunk();
  }

  // Array Area
  for (arry=sv_known_arrays; arry; arry=arry-&gt;next)
  {
    if (! arry-&gt;define_me)
      continue;

    SV_PushWriteChunk("Arry");
    SV_SaveARRY(arry);
    SV_PopWriteChunk();
  }

  // Data Area
  for (arry=sv_known_arrays; arry; arry=arry-&gt;next)
  {
    if (! arry-&gt;define_me)
      continue;

    SV_PushWriteChunk("Data");
    SV_SaveDATA(arry);
    SV_PopWriteChunk();
  }
}
</t>
<t tx="T583">@ignore
@language c

// Colour Code

&lt;&lt; v_colour #includes &gt;&gt;
&lt;&lt; v_colour declarations &gt;&gt;
@others
</t>
<t tx="T584">#include "i_defs.h"
#include "v_colour.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_argv.h"
#include "r_main.h"
#include "rgl_defs.h"
#include "st_stuff.h"
#include "v_res.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T585">
// -AJA- 1999/06/30: added this
byte playpal_data[14][256][3];
static byte playpal_greys[256];

// -AJA- 1999/09/18: fixes problem with black text etc.
static boolean_t loaded_playpal = false;

// -AJA- 1999/06/30: moved here from system-specific code.
byte rgb_32k[32][32][32];
unsigned long col2rgb16[65][256][2];
unsigned long col2rgb8[65][256];
unsigned long hicolourtransmask;

// -AJA- 1999/07/03: moved these here from st_stuff.c:
// Palette indices.
// For damage/bonus red-/gold-shifts
#define PAIN_PALS         1
#define BONUS_PALS        9
#define NUM_PAIN_PALS     8
#define NUM_BONUS_PALS    4
// Radiation suit, green shift.
#define RADIATION_PAL     13

// -AJA- 1999/07/03: moved these here from v_res.c:
int usegamma;
int current_gamma;

boolean_t interpolate_colmaps = true;

// general purpose colormaps
const colourmap_t *normal_map = NULL;
const colourmap_t *sky_map  = NULL;
const colourmap_t *shadow_map  = NULL;
const coltable_t *fuzz_coltable = NULL;
const coltable_t *dim_coltable = NULL;

// text translation tables
const byte *font_whitener = NULL;

const colourmap_t *text_red_map    = NULL;
const colourmap_t *text_white_map  = NULL;
const colourmap_t *text_grey_map   = NULL;
const colourmap_t *text_green_map  = NULL;
const colourmap_t *text_brown_map  = NULL;
const colourmap_t *text_blue_map   = NULL;
const colourmap_t *text_yellow_map = NULL;

// automap translation tables
const byte *am_normal_colmap  = NULL;
const byte *am_overlay_colmap = NULL;

byte null_tranmap[256];
byte halo_conv_table[256];

// -AJA- 1999/07/05: added `pixel_values' array.
long pixel_values[256];

// -AJA- whenever colourmaps have to be recomputed, we increase this.
static int colourmap_validcount = 7;

// colour indices from palette
int pal_black, pal_white, pal_gray239;
int pal_red, pal_green, pal_blue;
int pal_yellow, pal_green1, pal_brown1;

static int V_FindPureColour(int which);
</t>
<t tx="T586">@ V_InitPalette
@c

boolean_t V_InitPalette(void)
{
  int t, i;
  const byte *pal;
  int r, g, b;

  int max_file = W_GetNumFiles();
  wadtex_resource_t WT;
  int pal_lump = -1;

  // find "GLOBAL" palette (the one in the IWAD)
  
  for (t = 0; t &lt; max_file; t++)
  {
    W_GetTextureLumps(t, &amp;WT);
 
    if (WT.palette &gt;= 0)
    {
      pal_lump = WT.palette;
      break;
    }
  }

  if (pal_lump == -1)
    I_Error("Missing PLAYPAL palette lump !\n");
 
  pal = W_CacheLumpNum(pal_lump);

  // read in palette colours
  for (t = 0; t &lt; 14; t++)
  {
    for (i = 0; i &lt; 256; i++)
    {
      playpal_data[t][i][0] = pal[(t * 256 + i) * 3 + 0];
      playpal_data[t][i][1] = pal[(t * 256 + i) * 3 + 1];
      playpal_data[t][i][2] = pal[(t * 256 + i) * 3 + 2];
    }
  }

  for (i = 0; i &lt; 256; i++)
  {
    r = playpal_data[0][i][0];
    g = playpal_data[0][i][1];
    b = playpal_data[0][i][2];

    // NB: this test is rather lax
    playpal_greys[i] = (r == g) || (g == b);
  }

  W_DoneWithLump(pal);
  loaded_playpal = true;

  // lookup useful colours
  pal_black = V_FindColour(0, 0, 0);
  pal_white = V_FindColour(255, 255, 255);
  pal_gray239 = V_FindColour(239, 239, 239);

  pal_red   = V_FindPureColour(0);
  pal_green = V_FindPureColour(1);
  pal_blue  = V_FindPureColour(2);

  pal_yellow = V_FindColour(255, 255, 0);
  pal_green1 = V_FindColour(64, 128, 48);
  pal_brown1 = V_FindColour(192, 128, 74);

  I_Printf("Loaded global palette.\n");
      
  return true;
}
</t>
<t tx="T587">@ V_InitTranslationTables

Reads the translation tables for various things, especially text
colours. The text colourmaps to use are currently hardcoded, when
HUD.DDF (or MENU.DDF) comes along then the colours will be user
configurable.

-ACB- 1998/09/10 Replaced the old procedure with this.
-AJA- 2000/03/04: Moved here from r_draw1/2.c.
-AJA- 2000/03/05: Uses colmap.ddf instead of PALREMAP lump.
@c

static void InitTranslationTables(void)
{
  int i;

  if (normal_map)
    return;

  // look up the general colmaps &amp; coltables
  normal_map = DDF_ColmapLookup("NORMAL");
  sky_map  = DDF_ColmapLookup("SKY");
  shadow_map = DDF_ColmapLookup("SHADOW");
 
  fuzz_coltable = V_GetRawColtable(
      DDF_ColmapLookup("FUZZY"), 127);

  dim_coltable = V_GetRawColtable(
      DDF_ColmapLookup("DIMSCREEN"), 127);

  font_whitener = V_GetTranslationTable(
      DDF_ColmapLookup("FONTWHITEN"));

  am_normal_colmap = V_GetTranslationTable(
      DDF_ColmapLookup("AUTOMAP_NORMAL"));
 
  am_overlay_colmap = V_GetTranslationTable(
      DDF_ColmapLookup("AUTOMAP_OVERLAY"));

  // look up the text maps
  text_red_map = DDF_ColmapLookup("TEXT_RED");
  text_white_map  = DDF_ColmapLookup("TEXT_WHITE");
  text_grey_map   = DDF_ColmapLookup("TEXT_GREY");
  text_green_map  = DDF_ColmapLookup("TEXT_GREEN");
  text_brown_map  = DDF_ColmapLookup("TEXT_BROWN");
  text_blue_map   = DDF_ColmapLookup("TEXT_BLUE");
  text_yellow_map = DDF_ColmapLookup("TEXT_YELLOW");

  for (i=0; i &lt; 256; i++)
    null_tranmap[i] = i;

  // compute halo table (software mode)
  for (i=0; i &lt; 256; i++)
  {
    int j = font_whitener[i];

    if (GRAY &lt;= j &amp;&amp; j &lt; GRAY+GRAY_LEN)
      halo_conv_table[i] = 128 - ((j &amp; 0x1F) &lt;&lt; 2);
    else
      halo_conv_table[i] = 0;
  }
}
</t>
<t tx="T588">@ progress indicator for the translucency table calculations
@c

static void ColourCallbackFunc(int pos)
{
  static int cur_pos = 0;

  if (pos &lt;= cur_pos)
    return;

  while (pos &gt;= cur_pos + 16)
  {
    I_Printf(".");
    cur_pos += 16;
  }
}
</t>
<t tx="T589">@ CreateRGBTable:  * -ES- 1998/10/29: Added this.  * -AJA- 1999/06/30: Ditto :). *  * This is a modified version of Allegro's create_rgb_table, by Jan * Hubicka. The only difference is that this version will insert colour * 0 into the table, and Allegro's version won't (since that's Allegro's * transparent colour). * * Fills an RGB_MAP lookup table with conversion data for the specified * palette. This is the faster version by Jan Hubicka. * * Uses alg. similiar to foodfill - it adds one seed per every colour in  * palette to its best possition. Then areas around seed are filled by  * same colour because it is best aproximation for them, and then areas  * about them etc... * * It does just about 80000 tests for distances and this is about 100 * times better than normal 256*32000 tests so the caluclation time * is now less than one second at all computers I tested.
1.5k lookup table for colour matching
@c

static unsigned col_diff[3 * 128];

/* bestfit_init:
 *  Colour matching is done with weighted squares, which are much faster
 *  if we pregenerate a little lookup table...
 */
static void BestfitInit(void)
{
  int i;

  for (i = 1; i &lt; 64; i++)
  {
    int k = i * i;

    col_diff[0 + i] = col_diff[0 + 128 - i] = k * (59 * 59);
    col_diff[128 + i] = col_diff[128 + 128 - i] = k * (30 * 30);
    col_diff[256 + i] = col_diff[256 + 128 - i] = k * (11 * 11);
  }
}
</t>
<t tx="T590">
static void CreateRGBTable(byte table[32][32][32],
    byte pal[256][3],
    void (*callback) (int pos))
{
#define UNUSED 65535
#define LAST 65532

// macro ADD adds to single linked list
#define ADD(i)    (next[(i)] == UNUSED ? (next[(i)] = LAST, \
    (first != LAST ? (next[last] = (i)) : (first = (i))), \
    (last = (i))) : 0)

// same but w/o checking for first element
#define ADD1(i)   (next[(i)] == UNUSED ? (next[(i)] = LAST, \
    next[last] = (i), \
    (last = (i))) : 0)

// calculates distance between two colours
#define DIST(a1, a2, a3, b1, b2, b3) \
    (col_diff[ ((a2) - (b2)) &amp; 0x7F] + \
    (col_diff + 128)[((a1) - (b1)) &amp; 0x7F] + \
    (col_diff + 256)[((a3) - (b3)) &amp; 0x7F])

// converts r,g,b to position in array and back
#define POS(r, g, b) \
    (((r) / 2) * 32 * 32 + ((g) / 2) * 32 + ((b) / 2))

#define DEPOS(pal0, r, g, b) \
    ((b) = ((pal0)        &amp; 31) * 2, \
    (g) = (((pal0) &gt;&gt; 5)  &amp; 31) * 2, \
    (r) = (((pal0) &gt;&gt; 10) &amp; 31) * 2)

// is current colour better than pal1?
#define BETTER(r1, g1, b1, pal1) \
    (((int)DIST((r1), (g1), (b1), \
    (pal1)[0], (pal1)[1], (pal1)[2])) &gt; (int)dist2)

// checking of position
#define DOPOS(rp, gp, bp, ts) \
    if ((rp &gt; -1 || r &gt; 0) &amp;&amp; (rp &lt; 1 || r &lt; 61) &amp;&amp; \
        (gp &gt; -1 || g &gt; 0) &amp;&amp; (gp &lt; 1 || g &lt; 61) &amp;&amp; \
        (bp &gt; -1 || b &gt; 0) &amp;&amp; (bp &lt; 1 || b &lt; 61)) \
    { \
      i = first + rp * 32 * 32 + gp * 32 + bp; \
      if (ts ? data[i] != val : !data[i]) \
      { \
        dist2 = (rp ? (col_diff+128)[(r+2*rp-pal[val][0]) &amp; 0x7F] : r2) + \
            (gp ? (col_diff)[(g+2*gp-pal[val][1]) &amp; 0x7F] : g2) + \
            (bp ? (col_diff+256)[(b+2*bp-pal[val][2]) &amp; 0x7F] : b2); \
        if (BETTER((r+2*rp), (g+2*gp), (b+2*bp), pal[data[i]])) \
        { \
          data[i] = val; \
          ADD1 (i); \
        } \
      } \
    }

  int i, curr, r, g, b, val, r2, g2, b2, dist2;
  unsigned short next[32 * 32 * 32];
  unsigned char *data;
  int first = LAST;
  int last = LAST;
  int count = 0;
  int cbcount = 0;

#define AVERAGE_COUNT   18000

  BestfitInit();
  memset(next, 255, sizeof(next));
  memset(table, 0, sizeof(byte) * 32 * 32 * 32);

  data = (unsigned char *)table;

  // add starting seeds for foodfill
  for (i = 1; i &lt; 256; i++)
  {
    curr = POS(pal[i][0], pal[i][1], pal[i][2]);
    if (next[curr] == UNUSED)
    {
      data[curr] = i;
      ADD(curr);
    }
  }

  // main foodfill: two versions of loop for faster growing in blue axis
  while (first != LAST)
  {
    DEPOS(first, r, g, b);

    // calculate distance of current colour
    val = data[first];
    r2 = (col_diff + 128)[((pal[val][0]) - (r)) &amp; 0x7F];
    g2 = (col_diff)[((pal[val][1]) - (g)) &amp; 0x7F];
    b2 = (col_diff + 256)[((pal[val][2]) - (b)) &amp; 0x7F];

    // try to grow to all directions
    DOPOS(0, 0, 1, 1);
    DOPOS(0, 0, -1, 1);
    DOPOS(1, 0, 0, 1);
    DOPOS(-1, 0, 0, 1);
    DOPOS(0, 1, 0, 1);
    DOPOS(0, -1, 0, 1);

    // faster growing of blue direction
    if ((b &gt; 0) &amp;&amp; (data[first - 1] == val))
    {
      b -= 2;
      first--;
      b2 = (col_diff + 256)[((pal[val][2]) - (b)) &amp; 0x7F];

      DOPOS(-1, 0, 0, 0);
      DOPOS(1, 0, 0, 0);
      DOPOS(0, -1, 0, 0);
      DOPOS(0, 1, 0, 0);

      first++;
    }

    // get next from list
    i = first;
    first = next[first];
    next[i] = UNUSED;

    // second version of loop
    if (first != LAST)
    {
      DEPOS(first, r, g, b);

      val = data[first];
      r2 = (col_diff + 128)[((pal[val][0]) - (r)) &amp; 0x7F];
      g2 = (col_diff)[((pal[val][1]) - (g)) &amp; 0x7F];
      b2 = (col_diff + 256)[((pal[val][2]) - (b)) &amp; 0x7F];

      DOPOS(0, 0, 1, 1);
      DOPOS(0, 0, -1, 1);
      DOPOS(1, 0, 0, 1);
      DOPOS(-1, 0, 0, 1);
      DOPOS(0, 1, 0, 1);
      DOPOS(0, -1, 0, 1);

      if ((b &lt; 61) &amp;&amp; (data[first + 1] == val))
      {
        b += 2;
        first++;
        b2 = (col_diff + 256)[((pal[val][2]) - (b)) &amp; 0x7f];

        DOPOS(-1, 0, 0, 0);
        DOPOS(1, 0, 0, 0);
        DOPOS(0, -1, 0, 0);
        DOPOS(0, 1, 0, 0);

        first--;
      }

      i = first;
      first = next[first];
      next[i] = UNUSED;
    }

    count++;
    if (count == (cbcount + 1) * AVERAGE_COUNT / 256)
    {
      if (cbcount &lt; 256)
      {
        if (callback)
          callback(cbcount);
        cbcount++;
      }
    }
  }

  if (callback)
    while (cbcount &lt; 256)
      callback(cbcount++);
      
#undef AVERAGE_COUNT
#undef UNUSED
#undef LAST
#undef ADD
#undef ADD1
#undef DIST
#undef POS
#undef DEPOS
#undef DOPOS
#undef BETTER
}
</t>
<t tx="T591">
typedef struct
{
  int bits, mask, shift;
  int frac_bits, up_shift;

}
rgb16info_t;

static rgb16info_t rgb16info[3];

#define RI rgb16info

static void SwapEm(int a, int b)
{
  rgb16info_t tmp;
  tmp = RI[a];
  RI[a] = RI[b];
  RI[b] = tmp;
}
</t>
<t tx="T592">
static void V_ComputeRGBInfo(truecol_info_t * ti)
{
  if (BPP != 2)
    return;

  RI[0].bits = ti-&gt;red_bits;
  RI[1].bits = ti-&gt;green_bits;
  RI[2].bits = ti-&gt;blue_bits;

  RI[0].mask = ti-&gt;red_mask;
  RI[1].mask = ti-&gt;green_mask;
  RI[2].mask = ti-&gt;blue_mask;

  RI[0].shift = ti-&gt;red_shift;
  RI[1].shift = ti-&gt;green_shift;
  RI[2].shift = ti-&gt;blue_shift;

  // sort bitfields from right to left:

  if (RI[0].shift &gt; RI[1].shift)
    SwapEm(0, 1);
  if (RI[0].shift &gt; RI[2].shift)
    SwapEm(0, 2);
  if (RI[1].shift &gt; RI[2].shift)
    SwapEm(1, 2);

  if ((RI[0].shift != 0) || (RI[1].shift != RI[0].bits) ||
      (RI[2].shift != RI[0].bits + RI[1].bits))
  {
    I_Error("Non-contiguous 16 bit mode !");
  }

  RI[0].frac_bits = 16 - RI[1].bits - RI[0].bits;
  RI[1].frac_bits = RI[0].bits;
  RI[2].frac_bits = RI[1].bits;

  RI[0].up_shift = 16 - RI[0].frac_bits;
  RI[1].up_shift = 0;
  RI[2].up_shift = 16 + RI[0].bits;

#define MASK(n)  (((1L &lt;&lt; RI[n].frac_bits) - 1L) &lt;&lt; RI[n].up_shift)

  hicolourtransmask = MASK(0) | MASK(1) | MASK(2);

#undef MASK
}
</t>
<t tx="T593">
static unsigned long V_CalcRGB(int hicol, int level)
{
  unsigned long A = (hicol &amp; RI[0].mask) &gt;&gt; RI[0].shift;
  unsigned long B = (hicol &amp; RI[1].mask) &gt;&gt; RI[1].shift;
  unsigned long C = (hicol &amp; RI[2].mask) &gt;&gt; RI[2].shift;

  A = ((A * level) &gt;&gt; (6 - RI[0].frac_bits)) &lt;&lt; RI[0].up_shift;
  B = ((B * level) &gt;&gt; (6 - RI[1].frac_bits)) &lt;&lt; RI[1].up_shift;
  C = ((C * level) &gt;&gt; (6 - RI[2].frac_bits)) &lt;&lt; RI[2].up_shift;

  return A | B | C;
}
</t>
<t tx="T594">
#undef RI

static void CalcTranslucencyTable(void)
{
  int x, y, i;
  truecol_info_t ti;

  byte palette[256][3];  // Note: 6 bits per colour.

  I_Printf("Calculating translucency table");

  for (i = 0; i &lt; 256; i++)
  {
    palette[i][0] = playpal_data[0][i][0] &gt;&gt; 2;
    palette[i][1] = playpal_data[0][i][1] &gt;&gt; 2;
    palette[i][2] = playpal_data[0][i][2] &gt;&gt; 2;
  }

  CreateRGBTable(rgb_32k, palette, ColourCallbackFunc);

  // Convert to R/B/G
  for (x = 0; x &lt; 32; x++)
    for (y = 0; y &lt; 32; y++)
      for (i = 0; i &lt; y; i++)
      {
        byte temp;

        temp = rgb_32k[x][i][y];
        rgb_32k[x][i][y] = rgb_32k[x][y][i];
        rgb_32k[x][y][i] = temp;
      }

  // fixup some common colours
  rgb_32k[0][0][0] = pal_black;
  rgb_32k[31][31][31] = pal_white;

  I_GetTruecolInfo(&amp;ti);
  V_ComputeRGBInfo(&amp;ti);

  for (x = 0; x &lt; 65; x++)
  {
    for (y = 0; y &lt; 256; y++)
    {
      unsigned long rgb_lo;
      unsigned long rgb_hi;

      col2rgb8[x][y] = ((playpal_data[0][y][0] * x &gt;&gt; 4) &lt;&lt; 22) |
          ((playpal_data[0][y][1] * x &gt;&gt; 2) &lt;&lt; 10) |
          (playpal_data[0][y][2] * x &gt;&gt; 4);

      rgb_lo = V_CalcRGB(y, x);
      rgb_hi = V_CalcRGB(y &lt;&lt; 8, x);

      col2rgb16[x][y][0] = rgb_lo;
      col2rgb16[x][y][1] = rgb_hi;
    }
  }

  I_Printf("\n");
}
</t>
<t tx="T595">
static int cur_palette = -1;
static int cur_pal_bpp = -1;
static int new_palette = 0;

//
// V_InitColour
//
void V_InitColour(void)
{
  // check options
  M_CheckBooleanParm("nointerp", &amp;interpolate_colmaps, true);
 
  InitTranslationTables();
  CalcTranslucencyTable();

  // -AJA- 1999/11/07: fix for the "palette corrupt on res change"
  //       bug.  Allegro does not remember the palette when changing
  //       resolution, hence the problem.
  //
  cur_palette = -1;
  cur_pal_bpp = -1;
}
</t>
<t tx="T596">@ V_FindColour

Find the closest matching colour in the palette.
@c

int V_FindColour(int r, int g, int b)
{
  int i;

  int best = 0;
  int best_dist = 1 &lt;&lt; 30;
  
  for (i=0; i &lt; 256; i++)
  {
    int d_r = ABS(r - playpal_data[0][i][0]);
    int d_g = ABS(g - playpal_data[0][i][1]);
    int d_b = ABS(b - playpal_data[0][i][2]);

    int dist = d_r * d_r + d_g * d_g + d_b * d_b;

    if (dist == 0)
      return i;

    if (dist &lt; best_dist)
    {
      best = i;
      best_dist = dist;
    }
  }

  return best;
}
</t>
<t tx="T597">@ V_FindPureColour

Find the best match for the pure colour. `which' is 0 for red, 1
for green and 2 for blue.
@c

static int V_FindPureColour(int which)
{
  int i;

  int best = 0;
  int best_dist = 1 &lt;&lt; 30;
  
  for (i=0; i &lt; 256; i++)
  {
    int a = playpal_data[0][i][which];
    int b = playpal_data[0][i][(which+1)%3];
    int c = playpal_data[0][i][(which+2)%3];
    int d = MAX(b, c);

    int dist = 255 - (a - d);

    // the pure colour must shine through
    if (a &lt;= d)
      continue;

    if (dist &lt; best_dist)
    {
      best = i;
      best_dist = dist;
    }
  }

  return best;
}
</t>
<t tx="T598">@ V_SetPalette
@c

void V_SetPalette(int type, float_t amount)
{
  int i;
  int palette = 0;
  truecol_info_t ti;

  // -AJA- 1999/09/17: fixes problems with black text etc.
  if (!loaded_playpal)
    return;

  if (amount &gt;= 1.0)
    amount = 1.0;

  switch (type)
  {
    case PALETTE_PAIN:
      palette = (int)(PAIN_PALS + amount * (NUM_PAIN_PALS-1));
      break;

    case PALETTE_BONUS:
      palette = (int)(BONUS_PALS + amount * (NUM_BONUS_PALS-1));
      break;

    case PALETTE_SUIT:
      palette = RADIATION_PAL;
      break;
  }

  if (palette == cur_palette &amp;&amp; cur_pal_bpp == BPP)
    return;

  // mark the palette change
  new_palette++;

  cur_palette = palette;
  cur_pal_bpp = BPP;

  I_GetTruecolInfo(&amp;ti);
 
  for (i = 0; i &lt; 256; i++)
  {
    pixel_values[i] = I_Colour2Pixel(playpal_data[cur_palette], i);

    if (BPP != 1 &amp;&amp; playpal_greys[i])
      pixel_values[i] &amp;= ti.grey_mask;
  }

  stbar_update = true;
}
</t>
<t tx="T599">
static INLINE long MakeRGB(truecol_info_t *ti, long r, long g, long b)
{
  r = (r &gt;&gt; (8 - ti-&gt;red_bits))   &lt;&lt; ti-&gt;red_shift;
  g = (g &gt;&gt; (8 - ti-&gt;green_bits)) &lt;&lt; ti-&gt;green_shift;
  b = (b &gt;&gt; (8 - ti-&gt;blue_bits))  &lt;&lt; ti-&gt;blue_shift;

  return r | g | b;
}
</t>
<t tx="T600">@ MakeColourmapRange

Creates a colourmap table in `dest_colmaps' for use by the column &amp;
span drawers. Each colourmap is an array of `num' coltables. Each
coltable in the destination is a lookup table from indexed colour
(0-255) to framebuffer pixel. Each coltable in the source is a
lookup table from indexed colour to indexed colour. Only used for
non-8-bit modes. Note that the current gamma level must also be
applied in the conversion.
@c

static void MakeColourmapRange(void *dest_colmaps, byte palette[256][3],
    const byte *src_colmaps, int num)
{
  const byte *gtable = gammatable[usegamma];
  unsigned short *colmap16 = dest_colmaps;
  byte tempr[256], tempg[256], tempb[256];
  truecol_info_t ti;
  int i, j;

  DEV_ASSERT2(BPP == 2);

  I_GetTruecolInfo(&amp;ti);

  if (interpolate_colmaps &amp;&amp; num &gt;= 2)
  {
    for (j = 0; j &lt; 256; j++)
    {
      int c1 = src_colmaps[0 * 256 + j];
      int c2 = src_colmaps[(num - 1) * 256 + j];

      int r1 = palette[c1][0];
      int g1 = palette[c1][1];
      int b1 = palette[c1][2];

      int r2 = palette[c2][0];
      int g2 = palette[c2][1];
      int b2 = palette[c2][2];

      for (i = 0; i &lt; num; i++)
      {
        int r = gtable[r1 + (r2 - r1) * i / (num - 1)];
        int g = gtable[g1 + (g2 - g1) * i / (num - 1)];
        int b = gtable[b1 + (b2 - b1) * i / (num - 1)];

        colmap16[i * 256 + j] = MakeRGB(&amp;ti, r, g, b);

        if (playpal_greys[i])
          colmap16[i * 256 + j] &amp;= ti.grey_mask;
      }
    }

    return;
  }

  // use the old (but faster) method:

  for (i = 0; i &lt; 256; i++)
  {
    tempr[i] = gtable[palette[i][0]];
    tempg[i] = gtable[palette[i][1]];
    tempb[i] = gtable[palette[i][2]];
  }

  for (j = 0; j &lt; 256; j++)
  for (i = 0; i &lt; num; i++)
  {
    int c = src_colmaps[i * 256 + j];
    
    colmap16[i * 256 + j] = MakeRGB(&amp;ti, tempr[c], tempg[c], tempb[c]);

    if (playpal_greys[j])
      colmap16[i * 256 + j] &amp;= ti.grey_mask;
  }
}
</t>
<t tx="T601">@ LoadColourmap

Computes the right "colourmap" (more precisely, coltable) to put into
the dc_colourmap &amp; ds_colourmap variables for use by the column &amp;
span drawers.
@c

static void LoadColourmap(const colourmap_t * colm, int bpp)
{
  int lump;
  int size;
  const byte *data;
  const byte *data_in;

  // we are writing to const marked memory here. Here is the only place
  // the cache struct is touched.
  colmapcache_t *cache = 
      (colmapcache_t *)&amp;colm-&gt;cache; // Intentional Const Override

  cache-&gt;validcount = colourmap_validcount;
  cache-&gt;bpp = bpp;

  lump = W_GetNumForName(colm-&gt;lump_name);
  size = W_LumpLength(lump);
  data = W_CacheLumpNum(lump);

  if ((colm-&gt;start + colm-&gt;length) * 256 &gt; size)
    I_Error("Colourmap [%s] is too small ! (LENGTH too big)\n", 
      colm-&gt;ddf.name);

  data_in = data + (colm-&gt;start * 256);

  switch (bpp)
  {
    case 1:
      Z_Resize(cache-&gt;baseptr, char, colm-&gt;length * 256 + 255);
      cache-&gt;data = (void *)(((unsigned long)cache-&gt;baseptr + 255) &amp; ~255);
      Z_MoveData((byte *)cache-&gt;data, data_in, byte, colm-&gt;length * 256);
      break;

    case 2:
      Z_Resize(cache-&gt;baseptr, char, colm-&gt;length * 512 + 511);
      cache-&gt;data = (void *)(((unsigned long)cache-&gt;baseptr + 511) &amp; ~511);

      MakeColourmapRange(cache-&gt;data, playpal_data[cur_palette],
          data_in, colm-&gt;length);
      break;
  }

  W_DoneWithLump(data);
}
</t>
<t tx="T602">@ V_GetRawColtable
@c

const coltable_t *V_GetRawColtable(const colourmap_t * nominal, int level)
{
  coltable_t *result;
  int index;

  // Do we need to load or recompute this colourmap ?

  if (nominal-&gt;cache.data == NULL || 
      nominal-&gt;cache.validcount != colourmap_validcount ||
      nominal-&gt;cache.bpp != BPP)
  {
    LoadColourmap(nominal, BPP);
  }

  result = nominal-&gt;cache.data;
  index = (nominal-&gt;length * level) &gt;&gt; 8;

  return result + index * 256 * BPP;
}
</t>
<t tx="T603">@ V_GetTranslationTable
@c

const byte *V_GetTranslationTable(const colourmap_t * colmap)
{
  // Do we need to load or recompute this colourmap ?

  if (colmap-&gt;cache.data == NULL || 
      colmap-&gt;cache.validcount != colourmap_validcount ||
      colmap-&gt;cache.bpp != 1)
  {
    LoadColourmap(colmap, 1);
  }

  return colmap-&gt;cache.data;
}
</t>
<t tx="T604">@ V_GetColtable

Finds the right coltable for the dc_colourmap &amp; ds_colourmap
variables used by the column &amp; span drawers.
@c

const coltable_t *V_GetColtable(const colourmap_t * nominal, 
    int lightlevel, vcol_flags_e flags)
{
  DEV_ASSERT2(nominal);

  if (effect_colourmap)
  {
    if (effect_colourmap-&gt;length &gt; 1)
    {
      nominal = effect_colourmap;
      lightlevel = 255 * effect_strength;
    }
    else if (effect_strength &gt;= 1.0 || ((int)(effect_strength * 16) &amp; 2))
    {
      nominal = effect_colourmap;
      // doesn't matter
      lightlevel = 127;
    }
  }
  else if (flags &amp; VCOL_Sky)
  {
    nominal = sky_map;
    lightlevel = 255;
  }
  else
  { 
    if (effect_infrared)
      lightlevel += (int)(effect_strength * 255);

    if (! (nominal-&gt;special &amp; COLSP_NoFlash))
      lightlevel += extralight * 16;
  }

  lightlevel = MAX(0, MIN(255, lightlevel));

  return V_GetRawColtable(nominal, 255 - lightlevel);
}
</t>
<t tx="T605">
#ifdef USE_GL
//
// V_GetColmapRGB
//
void V_GetColmapRGB(const colourmap_t *colmap,
    float_t *r, float_t *g, float_t *b, boolean_t font)
{
  if (colmap-&gt;cache.data == NULL)
  {
    // Intention Const Override
    colmapcache_t *cache = (colmapcache_t *) &amp;colmap-&gt;cache;
    coltable_t *table;

    int r, g, b;

    LoadColourmap(colmap, 1);

    table = (coltable_t *) cache-&gt;data;

    if (font)
    {
      // for fonts, we only care about the GRAY colour
      r = playpal_data[0][table[pal_gray239]][0];
      g = playpal_data[0][table[pal_gray239]][1];
      b = playpal_data[0][table[pal_gray239]][2];
    }
    else
    {
      // use the RED,GREEN,BLUE colours, see how they change
      r = playpal_data[0][table[pal_red]][0];
      g = playpal_data[0][table[pal_green]][1];
      b = playpal_data[0][table[pal_blue]][2];
    }
    
    cache-&gt;gl_colour = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
  }

  (*r) = GAMMA_CONV((colmap-&gt;cache.gl_colour &gt;&gt; 16) &amp; 0xFF) / 255.0;
  (*g) = GAMMA_CONV((colmap-&gt;cache.gl_colour &gt;&gt;  8) &amp; 0xFF) / 255.0;
  (*b) = GAMMA_CONV((colmap-&gt;cache.gl_colour      ) &amp; 0xFF) / 255.0;
}
</t>
<t tx="T606">#endif

//
// V_GetTranslatedColtable
//
// Used for remapped sprites.  Will convert the input coltable into
// the output coltable (which is static) through the given translation
// array.
//
static byte translated_coltable[1024];

const coltable_t *V_GetTranslatedColtable(const coltable_t *src,
    const byte *trans)
{
  int i;

  switch (BPP)
  {
    case 1:
      for (i=0; i &lt; 256; i++)
      {
        translated_coltable[i] = ((byte *)src)[trans[i]];
      }
      break;

    case 2:
      for (i=0; i &lt; 256; i++)
      {
        ((unsigned short *)translated_coltable)[i] =
            ((unsigned short *)src)[trans[i]];
      }
      break;
  }
 
  return (const coltable_t *)translated_coltable;
}
</t>
<t tx="T607">@ V_ColourNewFrame

Call this at the start of each frame (before any rendering or
render-related work has been done). Will update the palette and/or
gamma settings if they have changed since the last call.
@c

void V_ColourNewFrame(void)
{
  if (current_gamma != usegamma)
  {
    W_ResetImages();
  }

  // -AJA- 1999/08/03: This fixes, once and for all, the now infamous
  //       "gamma too late on walls" bug.
  //
  if (new_palette &gt; 0 || current_gamma != usegamma)
  {
    new_palette = 0;
    usegamma = current_gamma;

    // -AJA- FIXME: GL doesn't need whole colourmaps recomputed
    
    if (BPP == 1)
      I_SetPalette(playpal_data[cur_palette]);
    else
      colourmap_validcount++;  // invalidate all colourmaps.
  }

  return;
}
</t>
<t tx="T608">@ V_IndexColourToRGB

Returns an RGB value from an index value - used the current
palette. The byte pointer is assumed to point a 3-byte array.
@c

void V_IndexColourToRGB(int indexcol, byte *returncol)
{
  returncol[0] = playpal_data[cur_palette][indexcol][0];
  returncol[1] = playpal_data[cur_palette][indexcol][1];
  returncol[2] = playpal_data[cur_palette][indexcol][2];
}
</t>
<t tx="T609">
void V_IndexNominalToRGB(int indexcol, byte *returncol)
{
  returncol[0] = playpal_data[0][indexcol][0];
  returncol[1] = playpal_data[0][indexcol][1];
  returncol[2] = playpal_data[0][indexcol][2];
}
</t>
<t tx="T610">@ignore
@language c

// Video Virtual Functions Code

// Original Author: Chi Hoang

// These are where the function pointers are actually delared (not extern)
// Two helper functions, that didn't belong anywhere else, are also here.

&lt;&lt; v_func #includes &gt;&gt;
&lt;&lt; v_func declarations &gt;&gt;
@others
</t>
<t tx="T611">#include "i_defs.h"

#include "dm_type.h"
#include "dm_defs.h"
#include "r_data.h"
#include "r_main.h"
#include "v_ctx.h"
#include "v_res.h"
#include "v_screen.h"
#include "w_image.h"
#include "w_wad.h"
</t>
<t tx="T612">
void (*V_CopyRect) (screen_t * dest, screen_t * src, int srcx, int srcy, int width, int height, int destx, int desty);

void (*V_CopyScreen) (screen_t * dest, screen_t * src);

// -AJA- 1999/07/04: added the following misc drawing functions:
void (*V_DrawPixel) (screen_t *scr, int x, int y, int c);
void (*V_DrawLine) (screen_t *scr, int x1, int y1, int x2, int y2, int c);
void (*V_DrawBox) (screen_t *scr, int x, int y, int w, int h, int c);
void (*V_DrawBoxAlpha) (screen_t *scr, int x, int y, int w, int h, int c, fixed_t alpha);

void (*resinit_r_draw_c) (void);

// The span blitting interface.
// Hook in assembler or system specific BLT here.
void (*R_DrawColumn) (void);
void (*R_DrawColumn_MIP) (void);

// The Spectre/Invisibility effect.
void (*R_DrawFuzzColumn) (void);

// -KM- 1998/11/25 All the 75%/50%/25% funcs have been removed.
void (*R_DrawTranslucentColumn) (void);
void (*R_DrawTranslucentColumn_MIP) (void);
void (*R_DrawTranslucentTranslatedColumn) (void);
void (*R_DrawTranslatedColumn) (void);

void (*R_VideoErase) (unsigned ofs, int count);

// Span blitting for rows, floor/ceiling.
// No Spectre effect needed.
void (*R_DrawSpan) (void);
void (*R_DrawSpan_MIP) (void);

// Translucent span blitting for floor/ceiling.
void (*R_DrawTranslucentSpan) (void);
void (*R_DrawTranslucentSpan_MIP) (void);
void (*R_DrawHoleySpan_MIP) (void);

// Initialise colour translation tables,
//  for player rendering etc.
void (*R_InitTranslationTables) (void);
</t>
<t tx="T613">
void R_DrawViewBorder(void)
{
  //!!!
}
</t>
<t tx="T614">
static const image_t *fill_image = NULL;
static char fill_name[10] = { 0, };

void R_FillBackScreen(void)
{
  int WW = SCREENWIDTH;
  int HH = (screenblocks == 11) ? SCREENHEIGHT :
      (SCREENHEIGHT - (32 * SCREENHEIGHT / 200));

  int left   = viewwindowx;
  int top    = viewwindowy;
  int right  = WW - viewwindowx - viewwindowwidth;
  int bottom = HH - viewwindowy - viewwindowheight;

  float_t t_r, t_b;

  DEV_ASSERT2(currentmap);

  if (!fill_image || strcmp(fill_name, currentmap-&gt;surround) != 0)
  {
    strcpy(fill_name, currentmap-&gt;surround);
    fill_image = W_ImageFromFlat(fill_name);
  }

  t_r = IM_RIGHT(fill_image)  * 5.0;
  t_b = IM_BOTTOM(fill_image) * 5.0;

  #define X_TO_TX(xx)  (t_r * (xx) / SCREENWIDTH)
  #define Y_TO_TY(yy)  (t_b * (yy) / SCREENHEIGHT)

  if (top &gt; 0)
  {
    vctx.DrawImage(0, 0, WW, top, fill_image, X_TO_TX(0), Y_TO_TY(0), 
        X_TO_TX(WW), Y_TO_TY(top), NULL, 1.0);
  }
  if (left &gt; 0)
  {
    vctx.DrawImage(0, top, left, viewwindowheight, fill_image,
        X_TO_TX(0), Y_TO_TY(top), X_TO_TX(left), 
        Y_TO_TY(top + viewwindowheight), NULL, 1.0);
  }
  if (right &gt; 0)
  {
    vctx.DrawImage(WW - right, top, right, viewwindowheight, fill_image,
        X_TO_TX(WW - right), Y_TO_TY(top), X_TO_TX(WW),
        Y_TO_TY(top + viewwindowheight), NULL, 1.0);
  }
  if (bottom &gt; 0)
  {
    vctx.DrawImage(0, HH - bottom, WW, bottom, fill_image,
        X_TO_TX(0), Y_TO_TY(HH - bottom), X_TO_TX(WW), Y_TO_TY(HH),
        NULL, 1.0);
  }

  #undef X_TO_TX
  #undef Y_TO_TY
}
</t>
<t tx="T615">@ignore
@language c

// Video Code  

&lt;&lt; v_res #includes &gt;&gt;
&lt;&lt; v_res declarations &gt;&gt;
@others
</t>
<t tx="T616">#include "i_defs.h"
#include "v_res.h"

#include "am_map.h"
#include "con_cvar.h"
#include "con_defs.h" // BCC Needs to know what funclist_s is.
#include "e_event.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "m_argv.h"
#include "m_fixed.h"
#include "r_draw1.h"
#include "r_draw2.h"
#include "r_plane.h"
#include "r_state.h"
#include "r_things.h"
#include "r_vbinit.h"
#include "st_stuff.h"
#include "v_screen.h"
#include "v_video1.h"
#include "v_video2.h"
#include "z_zone.h"
</t>
<t tx="T617">
//
//v_video.c stuff
//
screen_t *main_scr;
screen_t *back_scr;

int SCREENWIDTH;
int SCREENHEIGHT;
int SCREENPITCH;
int SCREENBITS;
boolean_t SCREENWINDOW;
boolean_t graphicsmode = false;

float_t DX, DY, DXI, DYI, DY2, DYI2;
int SCALEDWIDTH, SCALEDHEIGHT, X_OFFSET, Y_OFFSET;

float_t BASEYCENTER;
float_t BASEXCENTER;

//
//r_draw.c stuff
//

//
// For R_DrawColumn functions...
// Source is the top of the column to scale.
//
const coltable_t *dc_colourmap;
int dc_x;
int dc_yl;
int dc_yh;
int dc_width, dc_height;
fixed_t dc_yfrac;
fixed_t dc_ystep;

// -KM- 1998/11/25 Added translucency parameter.
fixed_t dc_translucency;

#ifndef NOSMOOTHING
// -ES- 1999/05/16 True if the drawing primitive uses smoothing.
boolean_t dc_usesmoothing;
boolean_t ds_usesmoothing;

#endif

// first pixel in a column
const byte *dc_source;

// translation table (remaps the 256 colours)
const byte *dc_translation;

// r_drawspan:
int ds_y;
int ds_x1;
int ds_x2;

const coltable_t *ds_colourmap;

fixed_t ds_xfrac, ds_yfrac;
fixed_t ds_xstep, ds_ystep;
int ds_width, ds_height;

// start of a 64*64 tile image 
const byte *ds_source;

// just for profiling
int dscount;

// -ES- 1998/08/20 Explicit initialisation to NULL
byte **ylookup = NULL;
int *columnofs = NULL;

// Screen Modes
screenmode_t *scrmode;
int numscrmodes;
</t>
<t tx="T618">
static void SetRes(void)
{
  // -ES- 1999/03/04 Removed weird aspect ratio warning - bad ratios don't look awful anymore :-)
  SCALEDWIDTH = (SCREENWIDTH - (SCREENWIDTH % 320));
  SCALEDHEIGHT = 200 * (SCALEDWIDTH / 320);

  // -KM- 1999/01/31 Add specific check for this: resolutions such as 640x350
  //  used to fail.
  if (SCALEDHEIGHT &gt; SCREENHEIGHT)
  {
    SCALEDHEIGHT = (SCREENHEIGHT - (SCREENHEIGHT % 200));
    SCALEDWIDTH = 320 * (SCALEDHEIGHT / 200);
  }

  // -ES- 1999/03/29 Allow very low resolutions
  if (SCALEDWIDTH &lt; 320 || SCALEDHEIGHT &lt; 200)
  {
    SCALEDWIDTH = SCREENWIDTH;
    SCALEDHEIGHT = SCREENHEIGHT;
    X_OFFSET = Y_OFFSET = 0;
  }
  else
  {
    X_OFFSET = (SCREENWIDTH - SCALEDWIDTH) / 2;
    Y_OFFSET = (SCREENHEIGHT - SCALEDHEIGHT) / 2;
  }

  //
  // Weapon Centering
  // Calculates the weapon height, relative to the aspect ratio.
  //
  // Moved here from a #define in r_things.c  -ACB- 1998/08/04
  //
  // -ES- 1999/03/04 Better psprite scaling
  BASEYCENTER = 100;
  BASEXCENTER = 160;

#if 0  // -AJA- This message meaningless at the moment
  // -KM- 1998/07/31 Cosmetic indenting
  I_Printf("  Scaled Resolution: %d x %d\n", SCALEDWIDTH, SCALEDHEIGHT);
#endif

  DX = SCALEDWIDTH / 320.0f;
  DXI = 320.0f / SCALEDWIDTH;
  DY = SCALEDHEIGHT / 200.0f;
  DYI = 200.0f / SCALEDHEIGHT;
  DY2 = DY / 2;
  DYI2 = DYI * 2;

  if (back_scr)
    V_DestroyScreen(back_scr);

  back_scr = V_CreateScreen(SCREENWIDTH, SCREENHEIGHT, BPP);

  ST_ReInit();

  AM_InitResolution();
}
</t>
<t tx="T619">
typedef struct video_func_s
{
  void (*V_CopyRect) (screen_t * dest, screen_t * src, int srcx, int srcy, int width, int height, int destx, int desty);
  void (*V_CopyScreen) (screen_t * dest, screen_t * src);

  void (*V_DrawPixel) (screen_t * scr, int x, int y, int col);
  void (*V_DrawLine) (screen_t * scr, int x1, int y1, int x2, int y2, int col);
  void (*V_DrawBox) (screen_t * scr, int x, int y, int w, int h, int col);
  void (*V_DrawBoxAlpha) (screen_t * scr, int x, int y, int w, int h, int col, fixed_t alpha);

  void (*resinit_r_draw_c) (void);
  void (*R_DrawColumn) (void);
  void (*R_DrawColumn_MIP) (void);
  void (*R_DrawFuzzColumn) (void);
  void (*R_DrawTranslatedColumn) (void);
  void (*R_DrawTranslucentTranslatedColumn) (void);
  void (*R_VideoErase) (unsigned ofs, int count);
  void (*R_DrawSpan) (void);
  void (*R_DrawSpan_MIP) (void);
  void (*R_DrawTranslucentSpan) (void);
  void (*R_DrawTranslucentSpan_MIP) (void);
  void (*R_DrawHoleySpan_MIP) (void);
  void (*R_FillBackScreen) (void);
  void (*R_DrawViewBorder) (void);
  void (*R_DrawTranslucentColumn) (void);
  void (*R_DrawTranslucentColumn_MIP) (void);

  funclist_t *colfuncs;
  funclist_t *spanfuncs;
  funclist_t *enlarge_2_2_funcs;
}
video_func_t;

video_func_t video_func[] =
{
    {
        V_CopyRect8,
        V_CopyScreen8,

    // -AJA- 1999/07/05: Added these three.
        V_DrawPixel8,
        V_DrawLine8,
        V_DrawBox8,
        V_DrawBoxAlpha8,

        resinit_r_draw_c8,
        R_DrawColumn8_CVersion,
        R_DrawColumn8_MIP,
        R_DrawFuzzColumn8,
        R_DrawTranslatedColumn8,
        R_DrawTranslucentTranslatedColumn8,
        R_VideoErase8,
        R_DrawSpan8_CVersion,
        R_DrawSpan8_MIP,
        R_DrawTranslucentSpan8,
        R_DrawTranslucentSpan8_MIP,
        R_DrawHoleySpan8_MIP,
        R_FillBackScreen8,
        R_DrawViewBorder8,
        R_DrawTranslucentColumn8,
        R_DrawTranslucentColumn8_MIP,

        &amp;drawcol8_funcs,
        &amp;drawspan8_funcs,
        &amp;enlarge8_2_2_funcs
    }
#ifndef NOHICOLOUR
    ,
    {
        V_CopyRect16,
        V_CopyScreen16,

    // -AJA- 1999/07/05: Added these three.
        V_DrawPixel16,
        V_DrawLine16,
        V_DrawBox16,
        V_DrawBoxAlpha16,

        resinit_r_draw_c16,
        R_DrawColumn16_CVersion,
        R_DrawColumn16_MIP,
        R_DrawFuzzColumn16,
        R_DrawTranslatedColumn16,
        R_DrawTranslucentTranslatedColumn16,
        R_VideoErase16,
        R_DrawSpan16_CVersion,
        R_DrawSpan16_MIP,
        R_DrawTranslucentSpan16,
        R_DrawTranslucentSpan16_MIP,
        R_DrawHoleySpan16_MIP,
        R_FillBackScreen16,
        R_DrawViewBorder16,
        R_DrawTranslucentColumn16,
        R_DrawTranslucentColumn16_MIP,

        &amp;drawcol16_funcs,
        &amp;drawspan16_funcs,
        &amp;enlarge16_2_2_funcs
    }
#endif // NOHICOLOUR
};

// Returns the video_func struct that uses the given BPP
static video_func_t *BPPToFuncTable(unsigned int bpp)
{
  if (bpp &gt; sizeof(video_func) / sizeof(video_func[0]) || bpp &lt; 1)
    I_Error("Invalid BPP: %d!", bpp);

  return &amp;video_func[bpp - 1];
}
</t>
<t tx="T620">
static void SetBPP(void)
{
  static video_func_t *functable = NULL;

  if (functable)
  {
    // functable is the previous resolution's table. Undo the
    // R_Draw* function dependencies that were set for that BPP.
    CON_SetFunclistDest(functable-&gt;colfuncs, NULL);
    CON_SetFunclistDest(functable-&gt;spanfuncs, NULL);
    CON_SetFunclistDest(functable-&gt;enlarge_2_2_funcs, NULL);
  }

  // -ES- 1998/08/20 Moved away BPP autodetect to V_MultiResInit
  functable = BPPToFuncTable(BPP);

  //okay, set all the function pointers

  V_CopyRect = functable-&gt;V_CopyRect;
  V_CopyScreen = functable-&gt;V_CopyScreen,

  V_DrawPixel = functable-&gt;V_DrawPixel;
  V_DrawLine = functable-&gt;V_DrawLine;
  V_DrawBox = functable-&gt;V_DrawBox;
  V_DrawBoxAlpha = functable-&gt;V_DrawBoxAlpha;

  resinit_r_draw_c = functable-&gt;resinit_r_draw_c;

  R_DrawFuzzColumn = functable-&gt;R_DrawFuzzColumn;
  R_DrawTranslatedColumn = functable-&gt;R_DrawTranslatedColumn;
  R_DrawTranslucentTranslatedColumn = functable-&gt;R_DrawTranslucentTranslatedColumn;
  R_VideoErase = functable-&gt;R_VideoErase;
  R_DrawSpan = functable-&gt;R_DrawSpan;
  R_DrawSpan_MIP = functable-&gt;R_DrawSpan_MIP;
  R_DrawTranslucentSpan = functable-&gt;R_DrawTranslucentSpan;
  R_DrawTranslucentSpan_MIP = functable-&gt;R_DrawTranslucentSpan_MIP;
  R_DrawHoleySpan_MIP = functable-&gt;R_DrawHoleySpan_MIP;
  R_DrawTranslucentColumn = functable-&gt;R_DrawTranslucentColumn;
  R_DrawTranslucentColumn_MIP = functable-&gt;R_DrawTranslucentColumn_MIP;
  R_DrawColumn_MIP = functable-&gt;R_DrawColumn_MIP;

  CON_SetFunclistDest(functable-&gt;colfuncs, &amp;R_DrawColumn);
  CON_SetFunclistDest(functable-&gt;spanfuncs, &amp;R_DrawSpan);
  CON_SetFunclistDest(functable-&gt;enlarge_2_2_funcs, &amp;R_DoEnlargeView_2_2);
}
</t>
<t tx="T621">@ V_InitResolution
Inits everything resolution-dependent to SCREENWIDTH x SCREENHEIGHT x BPP

-ES- 1998/08/20 Added this
@c

void V_InitResolution(void)
{
  SetBPP();
  SetRes();
}
</t>
<t tx="T622">@ V_MultiResInit

Called once at startup to initialise first V_InitResolution

-ACB- 1999/09/19 Removed forcevga reference
@c

boolean_t V_MultiResInit(void)
{
  I_Printf("Resolution: %d x %d x %dc\n", SCREENWIDTH, SCREENHEIGHT, 
      1 &lt;&lt; SCREENBITS);
  return true;
}
</t>
<t tx="T623">@ V_ClearPageBackground

-KM- 1998/07/21 This func clears around the edge of a scaled pic
@c

void V_ClearPageBackground(screen_t * scr)
{
  int y;
  int leftoffset = BPP * (SCREENWIDTH - SCALEDWIDTH) / 2;
  int topoffset = (SCREENHEIGHT - SCALEDHEIGHT) / 2;
  byte *dest;
  
  dest = scr-&gt;data;

  if (!V_ScreenHasCurrentRes(scr))
    I_Error("V_ClearPageBackground: Not supported by the given screen!");

  for (y = 0; y &lt; topoffset; y++, dest += SCREENPITCH)
  {
    Z_Clear(dest, byte, SCREENWIDTH * BPP);
  }

  if (SCALEDWIDTH &lt; SCREENWIDTH)
  {
    for (; y &lt; (SCREENHEIGHT - topoffset); y++, dest += SCREENPITCH)
    {
      Z_Clear(dest, byte, leftoffset);
      Z_Clear(dest + SCREENWIDTH * BPP - leftoffset, byte, leftoffset);
    }
  }

  for (; y &lt; SCREENHEIGHT; y++, dest += SCREENPITCH)
  {
    Z_Clear(dest, byte, SCREENWIDTH * BPP);
  }
}
</t>
<t tx="T624">@ V_AddAvailableResolution

Adds a resolution to the scrmodes list. This is used so we can
select it within the video options menu.

-ACB- 1999/10/03 Written
@c

void V_AddAvailableResolution(screenmode_t *mode)
{
  int i;

  // Unused depth: do not add.
  if (mode-&gt;depth != 8 &amp;&amp; mode-&gt;depth != 16 &amp;&amp; mode-&gt;depth != 24)
    return;

  L_WriteDebug("V_AddAvailableResolution: Res %d x %d - %dbpp\n", mode-&gt;width,
      mode-&gt;height, mode-&gt;depth);

  if (!scrmode)
  {
    scrmode = Z_New(screenmode_t, 1);
    scrmode[0] = mode[0];
    numscrmodes = 1;
    return;
  }

  // Go through existing list and check width and height do not already exist
  for(i = 0; i &lt; numscrmodes; i++)
  {
    if (scrmode[i].width == mode-&gt;width &amp;&amp; scrmode[i].height == mode-&gt;height &amp;&amp;
        scrmode[i].depth == mode-&gt;depth &amp;&amp; scrmode[i].windowed == mode-&gt;windowed)
      return;

    if ((scrmode[i].width &gt; mode-&gt;width || scrmode[i].height &gt; mode-&gt;height) &amp;&amp;
        scrmode[i].depth == mode-&gt;depth)
      break;
  }
  
  Z_Resize(scrmode, screenmode_t, numscrmodes+1);

  if (i != numscrmodes)
    Z_MoveData(&amp;scrmode[i+1], &amp;scrmode[i], screenmode_t, numscrmodes - i);

  scrmode[i] = mode[0];
  numscrmodes++;

  return;
}
</t>
<t tx="T625">@ V_FindClosestResolution

Finds the closest available resolution to the one specified.
Returns an index into scrmode[]. The samesize/samedepth will limit
the search, so -1 is returned if there were no matches. The search
only considers modes with the same `windowed' flag.
@c

#define DEPTH_MUL  25  // relative important of depth

int V_FindClosestResolution(screenmode_t *mode,
    boolean_t samesize, boolean_t samedepth)
{
  int i;

  int best_idx = -1;
  int best_dist = INT_MAX;

  for (i=0; i &lt; numscrmodes; i++)
  {
    int dw = ABS(scrmode[i].width  - mode-&gt;width);
    int dh = ABS(scrmode[i].height - mode-&gt;height);
    int dd = ABS(scrmode[i].depth  - mode-&gt;depth) * DEPTH_MUL;
    int dist;

    if (scrmode[i].windowed != mode-&gt;windowed)
      continue;

    // an exact match is always good...
    if (dw == 0 &amp;&amp; dh == 0 &amp;&amp; dd == 0)
      return i;

    if (samesize &amp;&amp; !(dw == 0 &amp;&amp; dh == 0))
      continue;

    if (samedepth &amp;&amp; dd != 0)
      continue;

    dist = dw * dw + dh * dh + dd * dd;

    if (dist &gt;= best_dist)
      continue;

    // found a better match
    best_idx = i;
    best_dist = dist;
  }

  return best_idx;
}
</t>
<t tx="T626">@ V_CompareModes

Returns -1 for less than, 0 if same, or +1 for greater than.
@c

int V_CompareModes(screenmode_t *A, screenmode_t *B)
{
  if (A-&gt;width &lt; B-&gt;width)
    return -1;
  else if (A-&gt;width &gt; B-&gt;width)
    return +1;

  if (A-&gt;height &lt; B-&gt;height)
    return -1;
  else if (A-&gt;height &gt; B-&gt;height)
    return +1;

  if (A-&gt;depth &lt; B-&gt;depth)
    return -1;
  else if (A-&gt;depth &gt; B-&gt;depth)
    return +1;

  if (A-&gt;windowed &lt; B-&gt;windowed)
    return -1;
  else if (A-&gt;windowed &gt; B-&gt;windowed)
    return +1;

  return 0;
}
</t>
<t tx="T627">@ignore
@language c

// Screen system

&lt;&lt; v_screen #includes &gt;&gt;
&lt;&lt; v_screen declarations &gt;&gt;
@others
</t>
<t tx="T628">#include "i_defs.h"
#include "v_screen.h"

#include "dm_state.h"
#include "z_zone.h"
</t>
<t tx="T629">
/*

   I have split up the creation/destruction routines, so that there is one
   routine that handles the content of the struct, and another one that also
   handles the memory managment of the struct itself.

   The Empty/Init routines should be used if you already have allocated memory
   for the screen_t struct (this is the case with viewbitmaps).
   The Create/Destroy routines should be used otherwise, they allocate the
   memory for the screen_ts before initialising.

 */

long screen_id_count = 1;
</t>
<t tx="T630">@ Destroys the contents of a screen.
@c

void V_EmptyScreen(screen_t * scr)
{
  if (scr-&gt;children)
    I_Error("V_EmptyScreen: Screen has %d subscreens!", scr-&gt;children);

  if (!scr-&gt;parent)
  {
    if (scr-&gt;data)
      Z_Free(scr-&gt;data);
  }
  else
    scr-&gt;parent-&gt;children--;
}
</t>
<t tx="T631">@ Destroys a screen &amp; frees it.
@c

void V_DestroyScreen(screen_t * scr)
{
  V_EmptyScreen(scr);
  Z_Free(scr);
}
</t>
<t tx="T632">@ Inits a screen for the given dimensions.
@c

void V_InitScreen(screen_t * s, int width, int height, int bytepp)
{
  s-&gt;width = width;
  s-&gt;height = height;
  s-&gt;bytepp = bytepp;
  
  // align
  s-&gt;pitch = V_GetPitch(width, bytepp);
  
  // allocate data
  s-&gt;data = Z_New(byte, s-&gt;pitch * height);
  s-&gt;parent = NULL;
  s-&gt;children = 0;
  s-&gt;x = s-&gt;y = 0;
  s-&gt;id = screen_id_count++;

  //L_WriteDebug("V_InitScreen: %d %d %d %d\n", s-&gt;width, s-&gt;height, s-&gt;bytepp, s-&gt;id);
}
</t>
<t tx="T633">@ Creates a new screen.
@c

screen_t *V_CreateScreen(int width, int height, int bytepp)
{
  screen_t *s;

  s = Z_New(screen_t, 1);

  V_InitScreen(s, width, height, bytepp);

  return s;
}
</t>
<t tx="T634">@ Allocates a screen. Must be initialised with V_InitScreen or V_InitSubScreen.
@c

screen_t *V_CreateEmptyScreen(void)
{
  screen_t *s;
  s = Z_ClearNew(screen_t, 1);
  return s;
}
</t>
<t tx="T635">@ Inits a sub-screen for the given dimensions.
@c

void V_InitSubScreen(screen_t * s, screen_t * p, int x, int y, int width, int height)
{
  s-&gt;width = width;
  s-&gt;height = height;
  s-&gt;parent = p;
  s-&gt;children = 0;
  p-&gt;children++;
  s-&gt;pitch = p-&gt;pitch;
  s-&gt;bytepp = p-&gt;bytepp;
  s-&gt;x = x;
  s-&gt;y = y;

  if (x &lt; 0 || y &lt; 0)
    I_Error("V_InitSubScreen: Negative upper-left coordinates!");
  
  if (x + width &gt; p-&gt;width)
    I_Error("V_InitSubScreen: Subscreen wider than parent!");

  if (y + height &gt; p-&gt;height)
    I_Error("V_InitSubScreen: Subscreen higher than parent!");

  s-&gt;data = p-&gt;data + p-&gt;pitch * y + p-&gt;bytepp * x;
  s-&gt;id = screen_id_count++;

}
</t>
<t tx="T636">@ Creates a new sub-screen.
@c

screen_t *V_CreateSubScreen(screen_t * p, int x, int y, int width, int height)
{
  screen_t *s;
  s = Z_New(screen_t, 1);

  V_InitSubScreen(s, p, x, y, width, height);
  return s;
}
</t>
<t tx="T637">
screen_t *V_ResizeScreen(screen_t * s, int newwidth, int newheight, int newbytepp)
{
  if (!s)
    return V_CreateScreen(newwidth, newheight, newbytepp);

  if (s-&gt;width == newwidth &amp;&amp; s-&gt;height == newheight &amp;&amp; s-&gt;bytepp == newbytepp)
    return s;

  if (s-&gt;parent)
  {
    if (newwidth + s-&gt;x &gt; s-&gt;parent-&gt;width)
      I_Error("V_ResizeScreen: Subscreen wider than parent!");
    s-&gt;width = newwidth;
    if (newheight + s-&gt;y &gt; s-&gt;parent-&gt;height)
      I_Error("V_ResizeScreen: Subscreen higher than parent!");
    s-&gt;height = newheight;
    if (newbytepp != s-&gt;parent-&gt;bytepp)
      I_Error("V_ResizeScreen: BPP differs from parent!");
  }
  else
  {
    if (s-&gt;children)
      // can't resize a screen which has subscreens.
      I_Error("V_ResizeScreen: Screen has %d subscreens!", s-&gt;children);

    s-&gt;pitch = V_GetPitch(newwidth, newbytepp);
    s-&gt;width = newwidth;
    s-&gt;height = newheight;
    s-&gt;bytepp = newbytepp;
    Z_Resize(s-&gt;data, byte, newheight * s-&gt;pitch);
  }
  s-&gt;id = screen_id_count++;

  return s;
}
</t>
<t tx="T638">@ Moves the sub-screen to the given coordinates relative to the parent
@c

void V_MoveSubScreen(screen_t * s, int x, int y)
{
  if (!s-&gt;parent)
    I_Error("V_MoveSubScreen: Screen is not a subscreen!");

  // can't move a screen which has subscreens.
  if (s-&gt;children)
    I_Error("V_MoveSubScreen: Screen has %d subscreens!", s-&gt;children);

  s-&gt;x = x;
  s-&gt;y = y;
  
  if (s-&gt;width + x &gt; s-&gt;parent-&gt;width || x &lt; 0 || s-&gt;height + y &gt; s-&gt;parent-&gt;height || y &lt; 0)
    I_Error("V_MoveSubScreen: Can't move screen outside parent's boundaries!");
  
  s-&gt;data = s-&gt;parent-&gt;data + y * s-&gt;pitch + x * s-&gt;bytepp;

  //L_WriteDebug("V_MoveSubScreen: old ID:%d\n", s-&gt;id);
  s-&gt;id = screen_id_count++;
  //L_WriteDebug("V_MoveSubScreen: new ID:%d\n", s-&gt;id);

}
</t>
<t tx="T639">@ V_GetPitch

Returns the pitch that should be used for the given width/bytepp combination
@c

int V_GetPitch(int width, int bytepp)
{
  // -ES- 1999/07/18 Of cache reasons, pitch is set to the next
  // 32-multiple after width*bytepp that not is divisible by 64.
  return ((width * bytepp + 31) &amp; ~63) + 32;
}
</t>
<t tx="T640">@ V_ScreenIsSubScreen

returns whether parts s1 and s2 share the same memory.
@c

boolean_t V_ScreensIntersect(screen_t * s1, screen_t * s2)
{
  int x1, y1, x2, y2;
  screen_t *s, *p;

  x1 = y1 = x2 = y2 = 0;
  for (s = s1; s-&gt;parent; s = s-&gt;parent)
  {
    x1 += s-&gt;x;
    y1 += s-&gt;y;
  }
  p = s;
  for (s = s2; s-&gt;parent; s = s-&gt;parent)
  {
    x2 += s-&gt;x;
    y2 += s-&gt;y;
  }
  if (s == p)
  {
    // s1 and s2 have the same origin screen, so they can intersect.
    // Just do a simple bounding box collision detection.
    if ((x1 + s1-&gt;width &lt; x2) || (x2 + s2-&gt;width &lt; x1) ||
        (y1 + s1-&gt;height &lt; y2) || (y2 + s2-&gt;height &lt; y1))
      return false;

    return true;
  }

  return false;
}
</t>
<t tx="T641">@ Checks whether scr has the same dimensions as the current resolution
(ie SCREENWIDTH*SCREENHEIGHT), and thereby can use routines like
DrawPatchInDirect.
@c

int V_ScreenHasCurrentRes(screen_t *scr)
{
  if (scr-&gt;width == SCREENWIDTH &amp;&amp;
      scr-&gt;height == SCREENHEIGHT &amp;&amp;
      scr-&gt;pitch == SCREENPITCH &amp;&amp;
      scr-&gt;bytepp == BPP)
  {
    return true;
  }
  else
  {
    return false;
  }
}
</t>
<t tx="T642">@ignore
@language c

// Top-level Video System

&lt;&lt; v_toplev #includes &gt;&gt;
&lt;&lt; v_toplev declarations &gt;&gt;
@others

#endif  // USE_LAYERS
</t>
<t tx="T643">#include "i_defs.h"
#include "v_toplev.h"

#include "e_search.h"
#include "dm_state.h"
#include "dm_defs.h"
#include "m_argv.h"
#include "m_bbox.h"
#include "m_swap.h"
#include "p_local.h"
#include "r_layers.h"
#include "r_local.h"
#include "r_sky.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T644">

#ifdef USE_LAYERS


static boolean_t begun_draw = false;

static int clipper_x1 = 0;
static int clipper_y1 = 0;
static int clipper_x2 = 0;
static int clipper_y2 = 0;
static int cur_solid_index;
</t>
<t tx="T645">@ VTOP_NewScreenSize
@c

void VTOP_NewScreenSize(int width, int height, int bpp)
{
  DEV_ASSERT2(! begun_draw);

  vctx.NewScreenSize(width, height, bpp);
}
</t>
<t tx="T646">@ VTOP_RenderScene
@c

void VTOP_RenderScene(int x1, int y1, int x2, int y2, vid_view_t *view)
{
  DEV_ASSERT2(! begun_draw);

  vctx.RenderScene(x1, y1, x2, y2, view);
}
</t>
<t tx="T647">@ VTOP_BeginDraw

Coordinates are the clipping rectangle. The extra parameter
`solid_index' is the index for this layer into the solid rectangle
list (needed for clipping).
@c

void VTOP_BeginDraw(int x1, int y1, int x2, int y2, int solid_index)
{
  DEV_ASSERT2(! begun_draw);
  
  DEV_ASSERT2(x2 &gt;= x1);
  DEV_ASSERT2(y2 &gt;= y1);
  DEV_ASSERT2(solid_index &gt;= 0);

  // keep a copy of clip rectangle for us to use...
  clipper_x1 = x1;
  clipper_y1 = y1;
  clipper_x2 = x2;
  clipper_y2 = y2;
  cur_solid_index = solid_index;

  vctx.BeginDraw(x1, y1, x2, y2);

  begun_draw = true;
}
</t>
<t tx="T648">@ VTOP_EndDraw
@c

void VTOP_EndDraw(void)
{
  DEV_ASSERT2(begun_draw);

  vctx.EndDraw();

  begun_draw = false;
}
</t>
<t tx="T649">@ VTOP_DrawImage

Draw an image. If `is_vol' is true, then it is assumed that this
image forms part of a volatile layer and thus doesn't need to be
clipped to the dirty matrix.
@c

void VTOP_DrawImage(int x1, int y1, int x2, int y2,
    float_t tx1, float_t ty1, float_t tx2, float_t ty2,
    const image_t *image, const colourmap_t *colmap, 
    int alpha, boolean_t is_vol)
{
  float_t tdx, tdy;
  
  DEV_ASSERT2(x2 &gt;= x1);
  DEV_ASSERT2(y2 &gt;= y1);

  if (alpha &lt;= 1)
    return;

  tdx = (tx2 - tx1) / (x2 - x1 + 1);
  tdy = (ty2 - ty1) / (y2 - y1 + 1);

  if (x1 &lt; clipper_x1)
  {
    tx1 += tdx * (clipper_x1 - x1);
    x1 = clipper_x1;
  }
  
  if (y1 &lt; clipper_y1)
  {
    ty1 += tdy * (clipper_y1 - y1);
    y1 = clipper_y1;
  }

  if (x2 &gt; clipper_x2)
  {
    tx2 += tdx * (clipper_x2 - x2);
    x2 = clipper_x2;
  }

  if (y2 &gt; clipper_y2)
  {
    ty2 += tdy * (clipper_y2 - y2);
    y2 = clipper_y2;
  }

  // nothing left to draw ?
  if (x1 &gt; x2 || y1 &gt; y2)
    return;

  if (is_vol || dirty_region_whole)
  {
    vctx.DrawImage(x1,y1,x2,y2, image, tx1,ty1,tx2,ty2, colmap, alpha);
    return;
  }

  // FIXME: implement dirty matrix &amp; solid rect clips
  I_Error("non-volatile VTOP_SolidBox not yet implemented !\n");
}
</t>
<t tx="T650">@ VTOP_SolidBox

Draw a solid box. If `is_vol' is true, then it is assumed that
this image forms part of a volatile layer and thus doesn't need to
be clipped to the dirty matrix.
@c

void VTOP_SolidBox(int x1, int y1, int x2, int y2,
    int colour, int alpha, boolean_t is_vol)
{
  DEV_ASSERT2(x2 &gt;= x1);
  DEV_ASSERT2(y2 &gt;= y1);

  if (alpha &lt;= 1)
    return;

  if (x1 &lt; clipper_x1)
    x1 = clipper_x1;

  if (y1 &lt; clipper_y1)
    y1 = clipper_y1;

  if (x2 &gt; clipper_x2)
    x2 = clipper_x2;

  if (y2 &gt; clipper_y2)
    y2 = clipper_y2;

  // nothing left to draw ?
  if (x1 &gt; x2 || y1 &gt; y2)
    return;

  if (is_vol || dirty_region_whole)
  {
    vctx.SolidBox(x1, y1, x2, y2, colour, alpha);
    return;
  }

  // FIXME: implement dirty matrix &amp; solid rect clips
  I_Error("non-volatile VTOP_SolidBox not yet implemented !\n");
}
</t>
<t tx="T651">@ VTOP_SolidLine

Note: assumed to be volatile.
@c

void VTOP_SolidLine(int x1, int y1, int x2, int y2,
    int colour, int alpha)
{
  if (alpha &lt;= 1)
    return;

  // we let the video context handle clipping...
  vctx.SolidLine(x1, y1, x2, y2, colour);
}
</t>
<t tx="T652">@ VTOP_ReadScreen

This one takes care to allocate the buffer. It must be freed using
Z_Free().
@c

byte *VTOP_ReadScreen(int x1, int y1, int x2, int y2)
{
  byte *rgb_buffer;
  
  DEV_ASSERT2(x2 &gt;= x1);
  DEV_ASSERT2(y2 &gt;= y1);

  rgb_buffer = Z_Malloc((x2 - x1 + 1) * (y2 - y1 + 1) * 3);

  vctx.ReadScreen(x1, y1, x2, y2, rgb_buffer);

  return rgb_buffer;
}
</t>
<t tx="T653">@ ANALYSIS UTILITY ROUTINES
@c

static byte analysis_region[DIRT_REG_H][DIRT_REG_W];
static boolean_t analysis_begun = false;

static int analysis_x1, analysis_y1;
static int analysis_x2, analysis_y2;
static int analysis_solid;

//
// VTOP_AnalyseBegin
//
// Begin analysis of the dirty matrix / solid rectangles for the layer
// with the given coordinates and solid index.  Coordinates are
// inclusive.  Note: Only one analysis can be in progress at any one
// time.
//
void VTOP_AnalyseBegin(int x1, int y1, int x2, int y2, int solid_index)
{
  int i, x, y;
  
  DEV_ASSERT2(! analysis_begun);

  DEV_ASSERT2(2048 &gt;= x2 &amp;&amp; x2 &gt;= x1 &amp;&amp; x1 &gt;= 0);
  DEV_ASSERT2(1536 &gt;= y2 &amp;&amp; y2 &gt;= y1 &amp;&amp; y1 &gt;= 0);
  
  analysis_x1 = x1;
  analysis_y1 = y1;
  analysis_x2 = x1;
  analysis_y2 = y1;

  // setup initial buffer, using solid rectangles

  x1 /= DIRT_X; y1 /= DIRT_Y;
  x2 /= DIRT_X; y2 /= DIRT_Y;

  for (y=y1; y &lt;= y2; y++)
  for (x=x1; x &lt;= x2; x++)
  {
    int px = x * DIRT_X;
    int py = y * DIRT_Y;

    // is this block clean ?
    if (! dirty_region_whole &amp;&amp; ! dirty_region[y][x])
    {
      analysis_region[y][x] = 0;
      continue;
    }

    // is this block totally under a solid rect ?
    for (i=solid_index; i &gt;= 0; i--)
    {
      int sx1 = solid_rects[i]-&gt;x1;
      int sy1 = solid_rects[i]-&gt;y1;
      int sx2 = solid_rects[i]-&gt;x2;
      int sy2 = solid_rects[i]-&gt;y2;

      if (sx1 &lt;= px &amp;&amp; px &lt;= sx2 &amp;&amp; sy1 &lt;= py &amp;&amp; py &lt;= sy2)
        break;
    }

    analysis_region[y][x] = (i &gt;= 0) ? 0 : 1;
  }

  analysis_begun = true;
}
</t>
<t tx="T654">@ VTOP_AnalyseEnd

Finish analysis, freeing any resources used.
@c

void VTOP_AnalyseEnd(void)
{
  DEV_ASSERT2(analysis_begun);

  analysis_begun = false;
}
</t>
<t tx="T655">
boolean_t VTOP_AnalyseNextRect(int *x1, int *y1, int *x2, int *y2)
{
  DEV_ASSERT2(analysis_begun);

  // FIXME: this could be optimised

  return false;
}
</t>
<t tx="T657">@ignore
@language c

// Player User Code

&lt;&lt; p_user #includes &gt;&gt;
@others
</t>
<t tx="T658">#include "i_defs.h"

#include "e_event.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "g_game.h"
#include "m_inline.h"
#include "p_local.h"
#include "p_mobj.h"
#include "rad_trig.h"
#include "s_sound.h"
#include "st_stuff.h"
#include "w_wad.h"
</t>
<t tx="T659">@ 16 pixels of bob
@c

#define MAXBOB        16.0f

//
// CalcHeight
//
// Calculate the walking / running height adjustment.
//
static void CalcHeight(player_t * player)
{
  float_t bob = 0;
  boolean_t onground = player-&gt;mo-&gt;z &lt;= player-&gt;mo-&gt;floorz;
  
  // Regular movement bobbing 
  // (needs to be calculated for gun swing even if not on ground).  
  // -AJA- Moved up here, to prevent weapon jumps when running down
  // stairs.
  
  player-&gt;bob = (player-&gt;mo-&gt;mom.x * player-&gt;mo-&gt;mom.x
      + player-&gt;mo-&gt;mom.y * player-&gt;mo-&gt;mom.y) / 8;

  if (player-&gt;bob &gt; MAXBOB)
    player-&gt;bob = MAXBOB;

  // ----CALCULATE BOB EFFECT----
  if (player-&gt;playerstate == PST_LIVE &amp;&amp; onground)
  {
    angle_t angle = ANG90 / 5 * leveltime;

    bob = player-&gt;bob * player-&gt;mo-&gt;info-&gt;bobbing * M_Sin(angle);
  }

  // ----CALCULATE VIEWHEIGHT----
  if (player-&gt;playerstate == PST_LIVE)
  {
    player-&gt;viewheight += player-&gt;deltaviewheight;

    if (player-&gt;viewheight &gt; player-&gt;std_viewheight)
    {
      player-&gt;viewheight = player-&gt;std_viewheight;
      player-&gt;deltaviewheight = 0;
    }
    else if (player-&gt;viewheight &lt; player-&gt;std_viewheight / 2)
    {
      player-&gt;viewheight = player-&gt;std_viewheight / 2;
      player-&gt;deltaviewheight = 0;
    }
    else if (player-&gt;viewheight &lt; 0.1)
    {
      player-&gt;viewheight = 0.1;
      player-&gt;deltaviewheight = 0;
    }
    else if (player-&gt;viewheight &lt; player-&gt;std_viewheight)
    {
       player-&gt;deltaviewheight += 0.2;
    }
  }

  player-&gt;viewz = player-&gt;mo-&gt;z + player-&gt;viewheight + bob;

  // No heads above the ceiling
  if (player-&gt;viewz &gt; player-&gt;mo-&gt;ceilingz - 2)
    player-&gt;viewz = player-&gt;mo-&gt;ceilingz - 2;

  // No heads below the floor, please
  if (player-&gt;viewz &lt; player-&gt;mo-&gt;floorz + 2)
    player-&gt;viewz = player-&gt;mo-&gt;floorz + 2;
}
</t>
<t tx="T660">@ MovePlayer
@c

static void MovePlayer(player_t * player)
{
  ticcmd_t *cmd;
  mobj_t *mo = player-&gt;mo;

  boolean_t onground = player-&gt;mo-&gt;z &lt;= player-&gt;mo-&gt;floorz;
  boolean_t onladder = player-&gt;mo-&gt;on_ladder &gt;= 0;
  boolean_t hasjetpack = player-&gt;powers[PW_Jetpack] &gt; 0;
  boolean_t canswim = player-&gt;swimming;

  float_t dx, dy;
  float_t eh, ev;

  float_t base_xy_speed;
  float_t base_z_speed;

  float_t F_vec[3], U_vec[3], S_vec[3];
  
  cmd = &amp;player-&gt;cmd;

  player-&gt;mo-&gt;angle += (angle_t)M_FloatToFixed(cmd-&gt;angleturn * player-&gt;mo-&gt;speed);

  // compute XY and Z speeds, taking swimming (etc) into account
  // (we try to swim in view direction -- assumes no gravity).
 
  base_xy_speed = player-&gt;mo-&gt;speed / 32.0;
  base_z_speed  = base_xy_speed;
  
  // Do not let the player control movement if not onground.
  // -MH- 1998/06/18  unless he has the JetPack!
  
  if (! (onground || onladder || canswim || hasjetpack))
    base_xy_speed /= 16;

  if (! (onladder || canswim || hasjetpack))
    base_z_speed /= 16;

  // move slower when crouching
  if (player-&gt;mo-&gt;extendedflags &amp; EF_CROUCHING)
    base_xy_speed *= CROUCH_SLOWDOWN;

  dx = M_Cos(player-&gt;mo-&gt;angle);
  dy = M_Sin(player-&gt;mo-&gt;angle);

  eh = 1;
  ev = 0;

  if (canswim)
  {
    float_t hyp = sqrt(1.0 + player-&gt;mo-&gt;vertangle * player-&gt;mo-&gt;vertangle);

    eh = 1.0 / hyp;
    ev = player-&gt;mo-&gt;vertangle / hyp;
  }
 
  // compute movement vectors
  
  F_vec[0] = eh * dx * base_xy_speed;
  F_vec[1] = eh * dy * base_xy_speed;
  F_vec[2] = ev * base_z_speed;
   
  S_vec[0] =  dy * base_xy_speed;
  S_vec[1] = -dx * base_xy_speed;
  S_vec[2] =  0;

  U_vec[0] = -ev * dx * base_xy_speed;
  U_vec[1] = -ev * dy * base_xy_speed;
  U_vec[2] =  eh * base_z_speed;
   
  player-&gt;mo-&gt;mom.x += F_vec[0] * cmd-&gt;forwardmove + S_vec[0] *
      cmd-&gt;sidemove + U_vec[0] * cmd-&gt;upwardmove;
  
  player-&gt;mo-&gt;mom.y += F_vec[1] * cmd-&gt;forwardmove + S_vec[1] *
      cmd-&gt;sidemove + U_vec[1] * cmd-&gt;upwardmove;
  
  player-&gt;mo-&gt;mom.z += F_vec[2] * cmd-&gt;forwardmove + S_vec[2] *
      cmd-&gt;sidemove + U_vec[2] * cmd-&gt;upwardmove;

  if (hasjetpack)
  {
    if (player-&gt;powers[PW_Jetpack] &lt;= (5 * TICRATE))
    {
      if (!(leveltime &amp; 10))
        S_StartSound(player-&gt;mo, sfx_jpflow);  // fuel low
    }
    else if (cmd-&gt;upwardmove &gt; 0)
      S_StartSound(player-&gt;mo, sfx_jprise);
    else if (cmd-&gt;upwardmove &lt; 0)
      S_StartSound(player-&gt;mo, sfx_jpdown);
    else if (cmd-&gt;forwardmove || cmd-&gt;sidemove)
      S_StartSound(player-&gt;mo, (onground ? sfx_jpidle : sfx_jpmove));
    else
      S_StartSound(player-&gt;mo, sfx_jpidle);
  }

  if ((cmd-&gt;forwardmove || cmd-&gt;sidemove)
      &amp;&amp; player-&gt;mo-&gt;state == &amp;states[player-&gt;mo-&gt;info-&gt;spawn_state])
  {
    if (player-&gt;mo-&gt;info-&gt;chase_state)
      P_SetMobjState(player-&gt;mo, player-&gt;mo-&gt;info-&gt;chase_state);
  }

  // EDGE Feature: Crouching

  if (level_flags.crouch &amp;&amp; mo-&gt;info-&gt;crouchheight &gt; 0)
  {
    if (player-&gt;cmd.upwardmove &lt; 0 &amp;&amp; mo-&gt;z == mo-&gt;floorz &amp;&amp;
        mo-&gt;height &gt; mo-&gt;info-&gt;crouchheight)
    {
      mo-&gt;height = MAX(mo-&gt;height - 2.0, mo-&gt;info-&gt;crouchheight);

      // update any things near the player
      P_ChangeThingSize(mo);
    }
    else if (player-&gt;cmd.upwardmove &gt;= 0 &amp;&amp; 
        mo-&gt;height &lt; mo-&gt;info-&gt;height)
    {
      // prevent standing up inside a solid area
      if ((mo-&gt;flags &amp; MF_NOCLIP) || mo-&gt;z+mo-&gt;height+2 &lt;= mo-&gt;ceilingz)
      {
        mo-&gt;height = MIN(mo-&gt;height + 2, mo-&gt;info-&gt;height);

        // update any things near the player
        P_ChangeThingSize(mo);
      }
    }

    if (mo-&gt;height &lt; (mo-&gt;info-&gt;height + mo-&gt;info-&gt;crouchheight) / 2.0)
      mo-&gt;extendedflags |= EF_CROUCHING;
    else
      mo-&gt;extendedflags &amp;= ~EF_CROUCHING;
    
    player-&gt;std_viewheight = mo-&gt;height * PERCENT_2_FLOAT(mo-&gt;info-&gt;viewheight);
  }

  // EDGE Feature: Jump Code
  //
  // -ACB- 1998/08/09 Check that jumping is allowed in the currentmap
  //                  Make player pause before jumping again
  
  if (cmd-&gt;extbuttons &amp; EBT_JUMP)
  {
    if (canswim)
    {
      player-&gt;mo-&gt;mom.z += base_z_speed * 10;
    }
    else if (level_flags.jump &amp;&amp; player-&gt;jumpwait &lt;= 0 &amp;&amp; onground)
    {
      player-&gt;mo-&gt;mom.z += player-&gt;mo-&gt;info-&gt;jumpheight / 
          (player-&gt;mo-&gt;extendedflags &amp; EF_CROUCHING ? 1.8 : 1.4);
      player-&gt;jumpwait = player-&gt;mo-&gt;info-&gt;jump_delay;

      // -AJA- 1999/09/11: New JUMP_SOUND for ddf.
      if (player-&gt;mo-&gt;info-&gt;jump_sound)
        S_StartSound(player-&gt;mo, player-&gt;mo-&gt;info-&gt;jump_sound);
    }
  }

  // EDGE Feature: Zooming
  //
  if (cmd-&gt;extbuttons &amp; EBT_ZOOM)
  {
    P_Zoom(player);
  }

  // EDGE Feature: Vertical Look (Mlook)
  //
  // -ACB- 1998/07/02 New Code used, rerouted via Ticcmd
  // -ACB- 1998/07/27 Used defines for look limits.
  //
  if (level_flags.mlook &amp;&amp; (cmd-&gt;extbuttons &amp; EBT_MLOOK))
  {
    player-&gt;mo-&gt;vertangle += cmd-&gt;vertangle / 254.0;

    if (player-&gt;mo-&gt;vertangle &gt; LOOKUPLIMIT)
      player-&gt;mo-&gt;vertangle = LOOKUPLIMIT;

    if (player-&gt;mo-&gt;vertangle &lt; LOOKDOWNLIMIT)
      player-&gt;mo-&gt;vertangle = LOOKDOWNLIMIT;
  }

  // EDGE Feature: Vertical Centering (Mlook)
  //
  // -ACB- 1998/07/02 Re-routed via Ticcmd
  //
  if (cmd-&gt;extbuttons &amp; EBT_CENTER)
    player-&gt;mo-&gt;vertangle = 0;
}
</t>
<t tx="T661">@ P_DeathThink

Fall on your face when dying.
Decrease POV height to floor height.
@c

#define ANG5   	(ANG90/18)

static void DeathThink(player_t * player)
{
  float_t dx, dy, dz;

  angle_t angle;
  angle_t delta;
  float_t slope, delta_s;

  // -AJA- 1999/12/07: don't die mid-air.
  player-&gt;powers[PW_Jetpack] = 0;

  P_MovePsprites(player);

  // fall to the ground
  if (player-&gt;viewheight &gt; player-&gt;std_viewheight)
    player-&gt;viewheight -= 1.0;
  else if (player-&gt;viewheight &lt; player-&gt;std_viewheight)
    player-&gt;viewheight = player-&gt;std_viewheight;
  
  player-&gt;deltaviewheight = 0;
  player-&gt;kick_offset = 0;

  CalcHeight(player);

  if (player-&gt;attacker &amp;&amp; player-&gt;attacker != player-&gt;mo)
  {
    dx = player-&gt;attacker-&gt;x - player-&gt;mo-&gt;x;
    dy = player-&gt;attacker-&gt;y - player-&gt;mo-&gt;y;
    dz = (player-&gt;attacker-&gt;z + player-&gt;attacker-&gt;height/2) - 
         (player-&gt;mo-&gt;z + player-&gt;viewheight);

    angle = R_PointToAngle(0, 0, dx, dy);
    delta = angle - player-&gt;mo-&gt;angle;

    slope = P_ApproxSlope(dx, dy, dz);
    slope = MIN(LOOKUPLIMIT, MAX(LOOKDOWNLIMIT, slope));
    delta_s = slope - player-&gt;mo-&gt;vertangle;

    if ((delta &lt;= ANG1 || delta &gt;= (angle_t)(0 - ANG1)) &amp;&amp;
        fabs(delta_s) &lt;= 0.01)
    {
      // Looking at killer,
      //  so fade damage flash down.
      player-&gt;mo-&gt;angle = angle;

      if (player-&gt;damagecount)
        player-&gt;damagecount--;
    }
    else 
    {
      if (delta &gt; ANG5 &amp;&amp; delta &lt; (angle_t)(0 - ANG5))
        delta = (delta &lt; ANG180) ? ANG5 : (angle_t)(0 - ANG5);

      if (delta_s &lt; -0.03 || delta_s &gt; 0.03)
        delta_s = (delta_s &lt; 0) ? -0.03 : 0.03;

      player-&gt;mo-&gt;angle += delta;
      player-&gt;mo-&gt;vertangle += delta_s;
    }
  }
  else if (player-&gt;damagecount)
    player-&gt;damagecount--;

  // -AJA- 1999/08/07: Fade out armor points too.
  if (player-&gt;bonuscount)
    player-&gt;bonuscount--;

  // lose the zoom when dead
  if (viewiszoomed)
  {
    R_SetFOV(normalfov);
    viewiszoomed = false;
  }

  if (deathmatch &gt;= 3 &amp;&amp; player-&gt;mo-&gt;movecount &gt; player-&gt;mo-&gt;info-&gt;respawntime)
    return;

  if (player-&gt;cmd.buttons &amp; BT_USE)
    player-&gt;playerstate = PST_REBORN;
}
</t>
<t tx="T662">@ P_ConsolePlayerThinker

Does the thinking of the console player, i.e. read from input
@c

void P_ConsolePlayerThinker(const player_t *p, void *data, ticcmd_t *dest)
{
  G_BuildTiccmd(dest);
}
</t>
<t tx="T663">@ P_PlayerThink
@c

void P_PlayerThink(player_t * player)
{
  mobj_t *mo = player-&gt;mo;
  ticcmd_t *cmd;
  int key;

  DEV_ASSERT2(mo);

#if 0  // DEBUG ONLY
{
  touch_node_t *tn;
  L_WriteDebug("Player %d Touch List:\n", player-&gt;pnum);
  for (tn = mo-&gt;touch_sectors; tn; tn=tn-&gt;mo_next)
  {
    L_WriteDebug("  SEC %d  Other = %s\n", tn-&gt;sec - sectors,
        tn-&gt;sec_next ? tn-&gt;sec_next-&gt;mo-&gt;info-&gt;ddf.name :
        tn-&gt;sec_prev ? tn-&gt;sec_prev-&gt;mo-&gt;info-&gt;ddf.name : "(None)");

    DEV_ASSERT2(tn-&gt;mo == mo);
    if (tn-&gt;mo_next)
    {
      DEV_ASSERT2(tn-&gt;mo_next-&gt;mo_prev == tn);
    }
  }
}
#endif

  // fixme: do this in the cheat code
  if (player-&gt;cheats &amp; CF_NOCLIP)
    player-&gt;mo-&gt;flags |= MF_NOCLIP;
  else
    player-&gt;mo-&gt;flags &amp;= ~MF_NOCLIP;

  // chain saw run forward
  cmd = &amp;player-&gt;cmd;
  if (player-&gt;mo-&gt;flags &amp; MF_JUSTATTACKED)
  {
    cmd-&gt;angleturn = 0;
    cmd-&gt;forwardmove = 64;
    cmd-&gt;sidemove = 0;
    player-&gt;mo-&gt;flags &amp;= ~MF_JUSTATTACKED;
  }

  if (player-&gt;playerstate == PST_DEAD)
  {
    DeathThink(player);
    return;
  }

  // Move/Look around.  Reactiontime is used to prevent movement for a
  // bit after a teleport.

  if (player-&gt;mo-&gt;reactiontime)
    player-&gt;mo-&gt;reactiontime--;
  else
    MovePlayer(player);

  CalcHeight(player);

  if (player-&gt;mo-&gt;props-&gt;special ||
      player-&gt;mo-&gt;subsector-&gt;sector-&gt;exfloor_used &gt; 0 ||
      player-&gt;underwater)
  {
    P_PlayerInSpecialSector(player, player-&gt;mo-&gt;subsector-&gt;sector);
  }

  // -AJA- FIXME: rework RTS execution as per docs/rts_rule.txt
  RAD_DoRadiTrigger(player);

  // Check for weapon change.

  // A special event has no other buttons.
  if (cmd-&gt;buttons &amp; BT_SPECIAL)
    cmd-&gt;buttons = 0;

  if (cmd-&gt;buttons &amp; BT_CHANGE)
  {
    int i, j;
    weaponkey_t *wk;

    // The actual changing of the weapon is done when the weapon
    // psprite can do it (read: not in the middle of an attack).

    key = (cmd-&gt;buttons &amp; BT_WEAPONMASK) &gt;&gt; BT_WEAPONSHIFT;
    wk = &amp;weaponkey[key];

    for (i=j=player-&gt;key_choices[key]; i &lt; (j + wk-&gt;numchoices); i++)
    {
      weaponinfo_t *choice = wk-&gt;choices[i % wk-&gt;numchoices];
      int pw_index;

      // see if player owns this kind of weapon
      for (pw_index=0; pw_index &lt; MAXWEAPONS; pw_index++)
      {
        if (! player-&gt;weapons[pw_index].owned)
          continue;
        
        if (player-&gt;weapons[pw_index].info == choice)
          break;
      }

      if (pw_index == MAXWEAPONS)
        continue;
      
      // ignore this choice if it the same as the current weapon
      if (player-&gt;ready_wp &gt;= 0 &amp;&amp; choice ==
          player-&gt;weapons[player-&gt;ready_wp].info)
      {
        continue;
      }
          
      if (! P_CheckWeaponSprite(choice))
        continue;
      
      player-&gt;pending_wp = pw_index;
      player-&gt;key_choices[key] = i % wk-&gt;numchoices;
      break;
    }
  }

  // check for use
  if (cmd-&gt;buttons &amp; BT_USE)
  {
    if (!player-&gt;usedown)
    {
      P_UseLines(player);
      player-&gt;usedown = true;
    }
  }
  else
  {
    player-&gt;usedown = false;
  }

  // decrement jumpwait counter
  if (player-&gt;jumpwait &gt; 0)
    player-&gt;jumpwait--;

  // cycle psprites
  P_MovePsprites(player);

  // Counters, time dependend power ups.

  if (player-&gt;powers[PW_Berserk] &gt; 0)
    player-&gt;powers[PW_Berserk]--;

  // -MH- 1998/06/18  jetpack "fuel" counter
  if (player-&gt;powers[PW_Jetpack] &gt; 0)
    player-&gt;powers[PW_Jetpack]--;

  // -ACB- 1998/07/16  nightvision counter decrementation
  if (player-&gt;powers[PW_NightVision] &gt; 0)
    player-&gt;powers[PW_NightVision]--;

  if (player-&gt;powers[PW_Invulnerable] &gt; 0)
    player-&gt;powers[PW_Invulnerable]--;

  if (player-&gt;powers[PW_PartInvis] &gt; 0)
    player-&gt;powers[PW_PartInvis]--;

  if (player-&gt;powers[PW_PartInvis] &gt;= 128 ||
      fmod(player-&gt;powers[PW_PartInvis], 16) &gt;= 8)
    player-&gt;mo-&gt;flags |=  MF_FUZZY;
  else
    player-&gt;mo-&gt;flags &amp;= ~MF_FUZZY;

  if (player-&gt;powers[PW_Infrared] &gt; 0)
    player-&gt;powers[PW_Infrared]--;

  if (player-&gt;powers[PW_AcidSuit] &gt; 0)
    player-&gt;powers[PW_AcidSuit]--;

  if (player-&gt;powers[PW_Scuba] &gt; 0)
    player-&gt;powers[PW_Scuba]--;

  if (player-&gt;damagecount)
    player-&gt;damagecount--;

  if (player-&gt;bonuscount)
    player-&gt;bonuscount--;

  if (player-&gt;grin_count)
    player-&gt;grin_count--;

  if (player-&gt;attackdown || player-&gt;secondatk_down)
    player-&gt;attackdown_count++;
  else
    player-&gt;attackdown_count = 0;
   
  player-&gt;kick_offset /= 1.6;

  // Handling colourmaps.
  //
  // -AJA- 1999/07/10: Updated for colmap.ddf. Ideally, the exact
  // colourmap &amp; palette effects to use would be specifiable somewhere
  // in DDF -- for now it is hardcoded.

  player-&gt;effect_colourmap = NULL;
  player-&gt;effect_infrared = false;

  if (player-&gt;powers[PW_Invulnerable] &gt; 0)
  {
    int s = player-&gt;powers[PW_Invulnerable];

    player-&gt;effect_colourmap = DDF_ColmapLookup("ALLWHITE");
    player-&gt;effect_strength = (float_t)((s &gt;= 128) ? 1.0 : s / 128.0);
  }
  else if (player-&gt;powers[PW_Infrared] &gt; 0)
  {
    int s = player-&gt;powers[PW_Infrared];

    player-&gt;effect_infrared = true;
    player-&gt;effect_strength = (float_t)((s &gt;= 128) ? 1.0 : s / 128.0);
  }
  // -ACB- 1998/07/15 NightVision Code
  else if (player-&gt;powers[PW_NightVision] &gt; 0)
  {
    int s = player-&gt;powers[PW_NightVision];

    player-&gt;effect_colourmap = DDF_ColmapLookup("ALLGREEN");
    player-&gt;effect_strength = (float_t)((s &gt;= 128) ? 1.0 : s / 128.0);
  }
}
</t>
<t tx="T664">@ P_AddPlayer

Creates a new player.
@c

void P_AddPlayer(int pnum)
{
  player_t *p;
  char namebuf[32];

  DEV_ASSERT2(0 &lt;= pnum &amp;&amp; pnum &lt; MAXPLAYERS);

  if (playerlookup == NULL)
    playerlookup = Z_ClearNew(player_t *, MAXPLAYERS);

  DEV_ASSERT(! playerlookup[pnum], 
      ("P_AddPlayer: %d already there", pnum));
   
  p = playerlookup[pnum] = Z_ClearNew(player_t, 1);

  p-&gt;in_game = false;
  p-&gt;pnum = pnum;

  // determine name
  sprintf(namebuf, "Player%dName", pnum + 1);

  if (DDF_LanguageValidRef(namebuf))
  {
    Z_StrNCpy(p-&gt;playername, DDF_LanguageLookup(namebuf), MAX_PLAYNAME-1);
  }
  else
  {
    // -ES- Default to player##
    sprintf(p-&gt;playername, "Player%d", pnum + 1);
  }
}
</t>
<t tx="T665">@ P_RemoveAllPlayers
@c

void P_RemoveAllPlayers(void)
{
  int i;
  
  players = NULL;

  for (i=0; i &lt; MAXPLAYERS; i++)
  {
    if (!playerlookup[i])
      continue;

    Z_Free(playerlookup[i]);
    playerlookup[i] = NULL;
  }
}
</t>
<t tx="T666">@ P_AddPlayerToGame
@c

void P_AddPlayerToGame(player_t *p)
{
  int i;

  DEV_ASSERT2(0 &lt;= p-&gt;pnum &amp;&amp; p-&gt;pnum &lt; MAXPLAYERS);

  if (p-&gt;in_game)
    return;

  p-&gt;in_game = true;

  // Link it in.  The list is sorted by pnum.
  if (players == NULL)
  {
    p-&gt;next = p-&gt;prev = NULL;
    players = p;
    return;
  }

  // find player directly before this one, if any
  for (i = p-&gt;pnum - 1; i &gt;= 0; i--)
    if (playerlookup[i] &amp;&amp; playerlookup[i]-&gt;in_game)
      break;

  if (i &lt; 0)
  {
    p-&gt;next = players;
    p-&gt;prev = NULL;

    if (p-&gt;next)
      p-&gt;next-&gt;prev = p;

    players = p;
  }
  else
  {
    p-&gt;next = playerlookup[i]-&gt;next;
    p-&gt;prev = playerlookup[i];

    if (p-&gt;next)
      p-&gt;next-&gt;prev = p;
    
    playerlookup[i]-&gt;next = p;
  }

  L_WriteDebug("  List:\n");
  for (p=players; p; p=p-&gt;next)
  {
    L_WriteDebug("    %p %d\n", p, p-&gt;pnum+1);
  }
  L_WriteDebug("  EndList\n");
}
</t>
<t tx="T667">@ P_RemovePlayerFromGame
@c

void P_RemovePlayerFromGame(player_t *p)
{
  DEV_ASSERT2(0 &lt;= p-&gt;pnum &amp;&amp; p-&gt;pnum &lt; MAXPLAYERS);

  if (!p-&gt;in_game)
    return;

  if (p-&gt;next)
    p-&gt;next-&gt;prev = p-&gt;prev;

  if (p-&gt;prev)
    p-&gt;prev-&gt;next = p-&gt;next;
  else
    players = p-&gt;next;
  
  p-&gt;in_game = false;
}
</t>
<t tx="T668">@ P_UpdateAvailWeapons

Must be called as soon as the player has received or lost a weapon.
Updates the status bar icons.
@c

void P_UpdateAvailWeapons(player_t *p)
{
  int i, key;

  for (i=0; i &lt; 10; i++)
    p-&gt;avail_weapons[i] = false;

  for (i=0; i &lt; MAXWEAPONS; i++)
  {
    if (! p-&gt;weapons[i].owned)
      continue;
    
    DEV_ASSERT2(p-&gt;weapons[i].info);

    key = p-&gt;weapons[i].info-&gt;bind_key;

    // update the status bar icons
    if (0 &lt;= key &amp;&amp; key &lt;= 9)
      p-&gt;avail_weapons[key] = true;
  }
  stbar_update = true;
}
</t>
<t tx="T669">@ P_AddWeapon

Returns true if player didn't already have the weapon. If
successful and `index' is non-NULL, it is set to the new index.
@c

boolean_t P_AddWeapon(player_t *player, weaponinfo_t *info, int *index)
{
  int i;
  int slot = -1;
  int rep_slot = -1;

  for (i=0; i &lt; MAXWEAPONS; i++)
  {
    weaponinfo_t *cur_info = player-&gt;weapons[i].info;
    
    // find free slot
    if (! player-&gt;weapons[i].owned)
    {
      if (slot &lt; 0)
        slot = i;
      
      continue;
    }

    // check if already own this weapon
    if (cur_info == info)
    {
      return false;
    }

    // don't downgrade any UPGRADED weapons
    // NOTE: this cannot detect upgrades of upgrades
    //
    if (cur_info-&gt;upgraded_weap &gt;= 0 &amp;&amp;
        weaponinfo[cur_info-&gt;upgraded_weap] == info)
    {
      return false;
    }

    // check for weapon upgrades
    if (info-&gt;upgraded_weap &gt;= 0 &amp;&amp;
        cur_info == weaponinfo[info-&gt;upgraded_weap])
    {
      rep_slot = i;
      continue;
    }
  }

  if (rep_slot &gt;= 0)
    slot = rep_slot;

  if (slot &lt; 0)
    return false;

  L_WriteDebug("P_AddWeapon: [%s] @ %d\n", info-&gt;ddf.name, slot);

  player-&gt;weapons[slot].owned = true;
  player-&gt;weapons[slot].info  = info;
  player-&gt;weapons[slot].clip_size    = info-&gt;clip;
  player-&gt;weapons[slot].sa_clip_size = info-&gt;sa_clip;

  P_UpdateAvailWeapons(player);

  if (index)
    (*index) = slot;

  // handle the icky case of holding the weapon which is being
  // replaced by the new one.  This won't look great, the weapon
  // should lower rather than just disappear.  Oh well.

  if (rep_slot &gt;= 0 &amp;&amp; player-&gt;ready_wp == rep_slot)
  {
    player-&gt;ready_wp = WPSEL_None;
    player-&gt;pending_wp = rep_slot;

    P_SetPsprite(player, ps_weapon, S_NULL);
  }

  return true;
}
</t>
<t tx="T670">@ P_RemoveWeapon

Returns true if player had the weapon.
@c

boolean_t P_RemoveWeapon(player_t *player, weaponinfo_t *info)
{
  int i;

  for (i=0; i &lt; MAXWEAPONS; i++)
  {
    if (! player-&gt;weapons[i].owned)
      continue;
    
    if (player-&gt;weapons[i].info == info)
      break;
  }

  if (i &gt;= MAXWEAPONS)
    return false;

  L_WriteDebug("P_RemoveWeapon: [%s] @ %d\n", info-&gt;ddf.name, i);

  player-&gt;weapons[i].owned = false;
  player-&gt;weapons[i].info  = NULL;

  P_UpdateAvailWeapons(player);

  // handle the icky case of already holding the weapon.  This won't
  // look great, the weapon should lower rather than just disappear.
  // Oh well.

  if (player-&gt;ready_wp == i)
  {
    player-&gt;ready_wp = WPSEL_None;
    P_SetPsprite(player, ps_weapon, S_NULL);
    P_SelectNewWeapon(player, -100, AM_DontCare);
  }
  else if (player-&gt;pending_wp == i)
  {
    P_SelectNewWeapon(player, -100, AM_DontCare);
  }
  
  return true;
}
</t>
<t tx="T671">@ P_GiveInitialBenefits

Give the player the initial benefits when they start a game (or
restart after dying). Sets up: ammo, ammo-limits, health, armour,
keys and weapons.

-AJA- 2000/03/02: written.
@c

void P_GiveInitialBenefits(player_t *p, const mobjinfo_t *info)
{
  int priority = -100;
  int pw_index;
  int i;
  
  p-&gt;ready_wp   = WPSEL_None;
  p-&gt;pending_wp = WPSEL_NoChange;

  for (i=num_disabled_weapons; i &lt; numweapons; i++)
  {
    if (! weaponinfo[i]-&gt;autogive)
      continue;

    if (! P_AddWeapon(p, weaponinfo[i], &amp;pw_index))
      continue;

    // choose highest priority FREE weapon as the default
    if (weaponinfo[i]-&gt;priority &gt; priority)
    {
      priority = weaponinfo[i]-&gt;priority;
      p-&gt;pending_wp = p-&gt;ready_wp = pw_index;
    }
  }

  for (i=0; i &lt; 10; i++)
    p-&gt;key_choices[i] = 0;

  // clear out ammo &amp; ammo-limits
  for (i=0; i &lt; NUMAMMO; i++)
  {
    p-&gt;ammo[i].num = p-&gt;ammo[i].max = 0;
  }

  // set health and armour
  p-&gt;health = info-&gt;spawnhealth;
  p-&gt;air_in_lungs = info-&gt;lung_capacity;
  p-&gt;underwater = false;

  for (i = 0; i &lt; NUMARMOUR; i++)
    p-&gt;armours[i] = 0;

  p-&gt;cards = KF_NONE;

  // give all initial benefits
  P_GiveBenefitList(p, NULL, info-&gt;initial_benefits, false);

  // refresh to remove all stuff from status bar
  P_UpdateAvailWeapons(p);
  stbar_update = true;
}
</t>
<t tx="T672">@ignore
@language c

// Weapon (player sprites) Action Code

// -KM- 1998/11/25 Added/Changed stuff for weapons.ddf

&lt;&lt; p_weapon #includes &gt;&gt;
@others
</t>
<t tx="T673">#include "i_defs.h"
#include "p_weapon.h"

#include "e_event.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "m_misc.h"
#include "m_random.h"
#include "p_action.h"
#include "p_local.h"
#include "rad_trig.h"
#include "s_sound.h"
#include "w_wad.h"
</t>
<t tx="T674">@ P_SetPsprite
@c

void P_SetPsprite(player_t * p, int position, int stnum)
{
  pspdef_t *psp;
  state_t *st;

  psp = &amp;p-&gt;psprites[position];

  if (stnum == S_NULL)
  {
    // object removed itself
    psp-&gt;state = psp-&gt;next_state = NULL;
    return;
  }

  st = &amp;states[stnum];

  psp-&gt;tics = st-&gt;tics;
  psp-&gt;state = st;
  psp-&gt;next_state = (st-&gt;nextstate == S_NULL) ? NULL : 
       (states + st-&gt;nextstate);

  // Call action routine.
  // Modified handling.

  p-&gt;action_psp = position;

  if (st-&gt;action)
    (* st-&gt;action)(p-&gt;mo);
}
</t>
<t tx="T675">@ P_CheckWeaponSprite

returns true if the sprite(s) for the weapon exist. Prevents being
able to e.g. select the super shotgun when playing with a DOOM 1
IWAD (and cheating).

-KM- 1998/12/16 Added check to make sure sprites exist.
-AJA- 2000: Made into a separate routine.
@c

boolean_t P_CheckWeaponSprite(weaponinfo_t *info)
{
  if (!info-&gt;up_state)
    return false;

  if (sprites[states[info-&gt;up_state].sprite].frames == 0)
    return false;

  return true;
}
</t>
<t tx="T676">@ P_RefillClips
@c

void P_RefillClips(player_t * p)
{
  playerweapon_t *pw;
  weaponinfo_t *info;
  
  if (p-&gt;ready_wp == WPSEL_None)
    return;
  
  pw = &amp;p-&gt;weapons[p-&gt;ready_wp];
  info = pw-&gt;info;
  
  if (pw-&gt;clip_size &lt;= 0)
    pw-&gt;clip_size = info-&gt;clip;

  if (pw-&gt;sa_clip_size &lt;= 0)
    pw-&gt;sa_clip_size = info-&gt;sa_clip;

  // make sure clips don't surpass total ammo

  if (info-&gt;ammo != AM_NoAmmo &amp;&amp; 
      pw-&gt;clip_size &gt; p-&gt;ammo[info-&gt;ammo].num)
  {
    pw-&gt;clip_size = p-&gt;ammo[info-&gt;ammo].num;
  }

  if (info-&gt;sa_ammo != AM_NoAmmo &amp;&amp; 
      pw-&gt;sa_clip_size &gt; p-&gt;ammo[info-&gt;sa_ammo].num)
  {
    pw-&gt;sa_clip_size = p-&gt;ammo[info-&gt;sa_ammo].num;
  }
}
</t>
<t tx="T677">@ P_BringUpWeapon

Starts bringing the pending weapon up
from the bottom of the screen.
@c

void P_BringUpWeapon(player_t * p)
{
  weaponinfo_t *info;
  weapon_selection_e sel;

  DEV_ASSERT2(p-&gt;pending_wp != WPSEL_NoChange);

  sel = p-&gt;ready_wp = p-&gt;pending_wp;

  p-&gt;pending_wp = WPSEL_NoChange;
  p-&gt;psprites[ps_weapon].sy = WEAPONBOTTOM;

  p-&gt;remember_atk1 = -1;
  p-&gt;remember_atk2 = -1;

  if (sel == WPSEL_None)
  {
    p-&gt;attackdown = false;
    p-&gt;secondatk_down = false;

    P_SetPsprite(p, ps_weapon, S_NULL);
    return;
  }

  info = p-&gt;weapons[sel].info;

  if (info-&gt;start)
    S_StartSound(p-&gt;mo, info-&gt;start);

  P_SetPsprite(p, ps_weapon, info-&gt;up_state);

  p-&gt;refire = info-&gt;refire_inacc ? 0 : 1;

  // refill clips if necessary
  P_RefillClips(p);
}
</t>
<t tx="T678">@ P_SelectNewWeapon

Out of ammo, pick a weapon to change to.
Preferences are set here.

The `ammo' parameter is normally AM_DontCare, meaning that the user
ran out of ammo while firing. Otherwise it is some ammo just
picked up by the player.
@c

void P_SelectNewWeapon(player_t * p, int priority, ammotype_t ammo)
{
  int i;
  int key = -1;
  weaponinfo_t *info;
 
  for (i=0; i &lt; MAXWEAPONS; i++)
  {
    info = p-&gt;weapons[i].info;

    if (! p-&gt;weapons[i].owned)
      continue;

    if (info-&gt;dangerous || info-&gt;priority &lt; priority)
      continue;

    if (ammo != AM_DontCare &amp;&amp; info-&gt;ammo != ammo)
      continue;
    
    if (ammo == AM_DontCare &amp;&amp; !(info-&gt;ammo == AM_NoAmmo || 
        p-&gt;ammo[info-&gt;ammo].num &gt;= info-&gt;ammopershot))
      continue;
    
    if (! P_CheckWeaponSprite(info))
      continue;

    p-&gt;pending_wp = i;
    priority = info-&gt;priority;
    key = info-&gt;bind_key;
  }

  // all out of choices ?
  if (priority &lt; 0)
  {
    p-&gt;pending_wp = (ammo == AM_DontCare) ? WPSEL_None : WPSEL_NoChange;
    return;
  }

  if (p-&gt;pending_wp == p-&gt;ready_wp)
  {
    p-&gt;pending_wp = WPSEL_NoChange;
    return;
  }
  
  // update current key choice
  if (key &gt;= 0)
  {
    DEV_ASSERT2(p-&gt;pending_wp &gt;= 0);
    info = p-&gt;weapons[p-&gt;pending_wp].info;

    for (i=0; i &lt; weaponkey[key].numchoices; i++)
    {
      if (weaponkey[key].choices[i] == info)
      {
        p-&gt;key_choices[key] = i;
        break;
      }
    }
  }
}
</t>
<t tx="T679">@ CheckAmmo

Returns true if there is enough ammo to shoot.
If not, selects the next weapon to use.
@c

static boolean_t CheckAmmo(player_t * p)
{
  weaponinfo_t *info;

  if (p-&gt;ready_wp == WPSEL_None)
    return false;

  info = p-&gt;weapons[p-&gt;ready_wp].info;

  // Some do not need ammunition anyway.
  // Return if current ammunition sufficient.
  if (info-&gt;ammo == AM_NoAmmo || p-&gt;ammo[info-&gt;ammo].num &gt;=
      info-&gt;ammopershot)
    return true;

  P_SelectNewWeapon(p, -100, AM_DontCare);

  return false;
}
</t>
<t tx="T680">@ CheckAmmoSA
@c

static boolean_t CheckAmmoSA(player_t * p)
{
  weaponinfo_t *info;

  if (p-&gt;ready_wp == WPSEL_None)
    return false;

  info = p-&gt;weapons[p-&gt;ready_wp].info;

  // Some do not need ammunition anyway.
  // Return if current ammunition sufficient.
  if (info-&gt;sa_ammo == AM_NoAmmo ||
      p-&gt;ammo[info-&gt;sa_ammo].num &gt;= info-&gt;sa_ammopershot)
    return true;

  // Note Well: we don't bother selecting a new weapon

  return false;
}
</t>
<t tx="T681">@ P_FireWeapon.

-AJA- 1999/08/10: Reworked for multiple attacks.
@c

static void P_FireWeapon(player_t * p)
{
  statenum_t newstate;

  if (!CheckAmmo(p))
    return;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  p-&gt;flash = false;

  if (p-&gt;remember_atk1 &gt;= 0)
  {
    newstate = p-&gt;remember_atk1;
    p-&gt;remember_atk1 = -1;
  }
  else
  {
    newstate = p-&gt;weapons[p-&gt;ready_wp].info-&gt;attack_state;
  }

  P_SetPsprite(p, ps_weapon, newstate);

  if (! (p-&gt;weapons[p-&gt;ready_wp].info-&gt;special_flags &amp;
      WPSP_SilentToMonsters))
  {
    P_NoiseAlert(p);
  }
}
</t>
<t tx="T682">@ P_FireSecondAttack

-AJA- 2000/02/08: written (hastily).
@c

static void P_FireSecondAttack(player_t * p)
{
  statenum_t newstate;

  if (!CheckAmmoSA(p))
    return;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  p-&gt;flash = false;

  if (p-&gt;remember_atk2 &gt;= 0)
  {
    newstate = p-&gt;remember_atk2;
    p-&gt;remember_atk2 = -1;
  }
  else
  {
    newstate = p-&gt;weapons[p-&gt;ready_wp].info-&gt;sa_attack_state;
  }

  if (!newstate)
     return;

  P_SetPsprite(p, ps_weapon, newstate);

  if (! (p-&gt;weapons[p-&gt;ready_wp].info-&gt;special_flags &amp;
      WPSP_SilentToMonsters))
  {
    P_NoiseAlert(p);
  }
}
</t>
<t tx="T683">@ P_DropWeapon

Player died, so put the weapon away.
@c

void P_DropWeapon(player_t * p)
{
  p-&gt;remember_atk1 = -1;
  p-&gt;remember_atk2 = -1;

  if (p-&gt;ready_wp != WPSEL_None)
    P_SetPsprite(p, ps_weapon, 
        p-&gt;weapons[p-&gt;ready_wp].info-&gt;down_state);
}
</t>
<t tx="T684">@ A_WeaponReady

The player can fire the weapon
or change to another weapon at this time.
Follows after getting weapon up,
or after previous attack/fire sequence.
@c

void A_WeaponReady(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  boolean_t hasjetpack = p-&gt;powers[PW_Jetpack] &gt; 0;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  statenum_t newstate;
  angle_t angle;
  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;

  int fire_1 = (p-&gt;cmd.buttons &amp; BT_ATTACK);
  int fire_2 = (p-&gt;cmd.extbuttons &amp; EBT_SECONDATK);

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (w-&gt;idle &amp;&amp; psp-&gt;state == &amp;states[w-&gt;ready_state])
    S_StartSound(mo, w-&gt;idle);

  // check for change if player is dead, put the weapon away
  if (p-&gt;pending_wp != WPSEL_NoChange || !p-&gt;health)
  {
    // change weapon (pending weapon should already be validated)
    newstate = p-&gt;weapons[p-&gt;ready_wp].info-&gt;down_state;
    P_SetPsprite(p, ps_weapon, newstate);
    P_SetPsprite(p, ps_crosshair, S_NULL);
    return;
  }

  // check for fire: the missile launcher and bfg do not auto fire
  if (fire_1 &amp;&amp; !fire_2)
  {
    if (!p-&gt;attackdown || w-&gt;autofire)
    {
      p-&gt;attackdown = true;
      P_FireWeapon(p);
      return;
    }
  }
  else
    p-&gt;attackdown = false;

  if (fire_2 &amp;&amp; !fire_1)
  {
    if (!p-&gt;secondatk_down || w-&gt;sa_autofire)
    {
      p-&gt;secondatk_down = true;
      P_FireSecondAttack(p);
      return;
    }
  }
  else
    p-&gt;secondatk_down = false;

  // bob the weapon based on movement speed
  if (hasjetpack)
  {
    psp-&gt;sx = 1.0;
    psp-&gt;sy = WEAPONTOP;
  }
  else
  {
    angle = (128 * leveltime) &lt;&lt; ANGLETOFINESHIFT;
    psp-&gt;sx = 1.0 + p-&gt;bob * PERCENT_2_FLOAT(w-&gt;swaying) * M_Cos(angle);

    angle &amp;= (ANG180 - 1);
    psp-&gt;sy = WEAPONTOP + p-&gt;bob * PERCENT_2_FLOAT(w-&gt;bobbing) * M_Sin(angle);
  }
}
</t>
<t tx="T685">@ A_ReFire

The player can re-fire the weapon
without lowering it entirely.

-AJA- 1999/08/10: Reworked for multiple attacks.
@c

void A_ReFire(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  p-&gt;remember_atk1 = -1;

  // check for fire
  // (if a weaponchange is pending, let it go through instead)

  if (p-&gt;cmd.buttons &amp; BT_ATTACK)
  {
    // -KM- 1999/01/31 Check for semiautomatic weapons.
    if (p-&gt;pending_wp &lt; 0 &amp;&amp; p-&gt;health &amp;&amp; 
        (!p-&gt;attackdown || w-&gt;autofire))
    {
      p-&gt;refire++;
      P_FireWeapon(p);
      return;
    }
  }
  
  p-&gt;refire = w-&gt;refire_inacc ? 0 : 1;
  CheckAmmo(p);
}
</t>
<t tx="T686">@ A_ReFireSA
@c

void A_ReFireSA(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  p-&gt;remember_atk2 = -1;

  // check for fire
  // (if a weaponchange is pending, let it go through instead)

  if (p-&gt;cmd.extbuttons &amp; EBT_SECONDATK)
  {
    if (p-&gt;pending_wp &lt; 0 &amp;&amp; p-&gt;health &amp;&amp; 
        (!p-&gt;secondatk_down || w-&gt;sa_autofire))
    {
      p-&gt;refire++;
      P_FireSecondAttack(p);
      return;
    }
  }

  p-&gt;refire = w-&gt;refire_inacc ? 0 : 1;
  CheckAmmoSA(p);
}
</t>
<t tx="T687">@ A_NoFire

If the player is still holding the fire button, continue, otherwise
return to the weapon ready states.

-AJA- 1999/08/18: written.
@c

void A_NoFire(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  // check for fire
  //  (if a weaponchange is pending, let it go through instead)

  if (p-&gt;cmd.buttons &amp; BT_ATTACK)
  {
    // -KM- 1999/01/31 Check for semiautomatic weapons.
    if (p-&gt;pending_wp &lt; 0 &amp;&amp; p-&gt;health &amp;&amp; 
        (!p-&gt;attackdown || w-&gt;autofire))
    {
      p-&gt;remember_atk1 = psp-&gt;state-&gt;nextstate;
      p-&gt;refire++;

      P_FireWeapon(p);
      return;
    }
  }

  p-&gt;refire = w-&gt;refire_inacc ? 0 : 1;
  p-&gt;remember_atk1 = -1;

  if (CheckAmmo(p))
  {
    // Player not firing, and no need to change weapon.
    // Therefore return weapon to ready state.

    int newstate = p-&gt;weapons[p-&gt;ready_wp].info-&gt;ready_state;

    P_SetPsprite(p, ps_weapon, newstate);
    P_SetPsprite(p, ps_crosshair, p-&gt;weapons[p-&gt;ready_wp].info-&gt;crosshair);

    // -AJA- FIXME: probably need to take the _player_ thing out of its
    // attack state.
  }
}
</t>
<t tx="T688">@ A_NoFireSA
@c

void A_NoFireSA(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  // check for fire
  // (if a weaponchange is pending, let it go through instead)

  if (p-&gt;cmd.extbuttons &amp; EBT_SECONDATK)
  {
    if (p-&gt;pending_wp &lt; 0 &amp;&amp; p-&gt;health &amp;&amp; 
        (!p-&gt;secondatk_down || w-&gt;sa_autofire))
    {
      p-&gt;remember_atk2 = psp-&gt;state-&gt;nextstate;
      p-&gt;refire++;

      P_FireSecondAttack(p);
      return;
    }
  }

  p-&gt;refire = w-&gt;refire_inacc ? 0 : 1;
  p-&gt;remember_atk2 = -1;

  if (CheckAmmoSA(p))
  {
    // Player not firing, and no need to change weapon.
    // Therefore return weapon to ready state.

    int newstate = p-&gt;weapons[p-&gt;ready_wp].info-&gt;ready_state;

    P_SetPsprite(p, ps_weapon, newstate);
    P_SetPsprite(p, ps_crosshair, p-&gt;weapons[p-&gt;ready_wp].info-&gt;crosshair);

    // -AJA- FIXME: probably need to take the _player_ thing out of its
    // attack state.
  }
}
</t>
<t tx="T689">@ A_NoFireReturn

Like A_NoFire, but used for multiple attacks. It remembers the
position in the attack states when the player stops firing, and
returns to this position when the player starts firing again.

-AJA- 1999/08/11: written.
@c

void A_NoFireReturn(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  p-&gt;remember_atk1 = psp-&gt;state-&gt;nextstate;

  // check for fire
  //  (if a weaponchange is pending, let it go through instead)

  if (p-&gt;cmd.buttons &amp; BT_ATTACK)
  {
    // -KM- 1999/01/31 Check for semiautomatic weapons.
    if (p-&gt;pending_wp &lt; 0 &amp;&amp; p-&gt;health &amp;&amp; 
        (!p-&gt;attackdown || w-&gt;autofire))
    {
      p-&gt;refire++;
      P_FireWeapon(p);
      return;
    }
  }

  p-&gt;refire = w-&gt;refire_inacc ? 0 : 1;

  if (CheckAmmo(p))
  {
    // Player not firing, and no need to change weapon.
    // Therefore return weapon to ready state.

    int newstate = p-&gt;weapons[p-&gt;ready_wp].info-&gt;ready_state;

    P_SetPsprite(p, ps_weapon, newstate);
    P_SetPsprite(p, ps_crosshair, p-&gt;weapons[p-&gt;ready_wp].info-&gt;crosshair);

    // -AJA- FIXME: probably need to take the _player_ thing out of its
    // attack state.
  }
}
</t>
<t tx="T690">@ A_NoFireReturnSA

-AJA- 2001/05/14: written.
@c

void A_NoFireReturnSA(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  p-&gt;remember_atk2 = psp-&gt;state-&gt;nextstate;

  // check for fire
  //  (if a weaponchange is pending, let it go through instead)

  if (p-&gt;cmd.extbuttons &amp; EBT_SECONDATK)
  {
    // -KM- 1999/01/31 Check for semiautomatic weapons.
    if (p-&gt;pending_wp &lt; 0 &amp;&amp; p-&gt;health &amp;&amp; 
        (!p-&gt;secondatk_down || w-&gt;sa_autofire))
    {
      p-&gt;refire++;
      P_FireSecondAttack(p);
      return;
    }
  }

  p-&gt;refire = w-&gt;refire_inacc ? 0 : 1;

  if (CheckAmmoSA(p))
  {
    // Player not firing, and no need to change weapon.
    // Therefore return weapon to ready state.

    int newstate = p-&gt;weapons[p-&gt;ready_wp].info-&gt;ready_state;

    P_SetPsprite(p, ps_weapon, newstate);
    P_SetPsprite(p, ps_crosshair, p-&gt;weapons[p-&gt;ready_wp].info-&gt;crosshair);

    // -AJA- FIXME: probably need to take the _player_ thing out of its
    // attack state.
  }
}
</t>
<t tx="T691">@ A_WeaponKick

-AJA- 2000/02/08: written.
@c

void A_WeaponKick(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  float kick = 0.05;
  
  if (! level_flags.kicking)
    return;
  
  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
    kick = ((float_t *) psp-&gt;state-&gt;action_par)[0];
    
  p-&gt;deltaviewheight -= kick;
  p-&gt;kick_offset = kick;
}
</t>
<t tx="T692">@ A_CheckReload

Check whether the player has used up
the clip quantity of ammo. If so, must reload.

-KM- 1999/01/31 Check clip size.
-AJA- 1999/08/11: Reworked for new playerweapon_t field.
@c

void A_CheckReload(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  weaponinfo_t *info;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  CheckAmmo(p);

  if (p-&gt;ready_wp == WPSEL_None || p-&gt;pending_wp &gt;= 0)
    return;

  info = p-&gt;weapons[p-&gt;ready_wp].info;

  if (!info-&gt;reload_state)
    return;

  if (p-&gt;weapons[p-&gt;ready_wp].clip_size &lt;= 0)
  {
    P_RefillClips(p);
    P_SetPsprite(p, ps_weapon, info-&gt;reload_state);
  }
}
</t>
<t tx="T693">@ A_CheckReloadSA
@c

void A_CheckReloadSA(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  weaponinfo_t *info;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  CheckAmmoSA(p);

  if (p-&gt;ready_wp == WPSEL_None || p-&gt;pending_wp &gt;= 0)
    return;

  info = p-&gt;weapons[p-&gt;ready_wp].info;

  if (!info-&gt;sa_reload_state)
    return;

  if (p-&gt;weapons[p-&gt;ready_wp].sa_clip_size &lt;= 0)
  {
    P_RefillClips(p);
    P_SetPsprite(p, ps_weapon, info-&gt;sa_reload_state);
  }
}
</t>
<t tx="T694">@ A_Lower

Lowers current weapon, and changes weapon at bottom.
@c

void A_Lower(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  psp-&gt;sy += LOWERSPEED;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  // In `LimitZoom' mode, disable any current zoom
  if (level_flags.limit_zoom &amp;&amp; viewiszoomed)
  {
    R_SetFOV(normalfov);
    viewiszoomed = false;
  }

  // Is already down.
  if (psp-&gt;sy &lt; WEAPONBOTTOM)
    return;

  // Player is dead.
  if (p-&gt;playerstate == PST_DEAD)
  {
    psp-&gt;sy = WEAPONBOTTOM;

    // don't bring weapon back up
    return;
  }

  // The old weapon has been lowered off the screen,
  // so change the weapon and start raising it
  if (!p-&gt;health)
  {
    // Player is dead, so keep the weapon off screen.
    P_SetPsprite(p, ps_weapon, S_NULL);
    return;
  }

  if (p-&gt;pending_wp == WPSEL_NoChange)
  {
    p-&gt;ready_wp = WPSEL_None;
    P_SelectNewWeapon(p, -100, AM_DontCare);
  }

  P_BringUpWeapon(p);
}
</t>
<t tx="T695">@ A_Raise
@c

void A_Raise(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  statenum_t newstate;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  psp-&gt;sy -= RAISESPEED;

  if (psp-&gt;sy &gt; WEAPONTOP)
    return;

  psp-&gt;sy = WEAPONTOP;

  p-&gt;remember_atk1 = -1;
  p-&gt;remember_atk2 = -1;

  // The weapon has been raised all the way,
  //  so change to the ready state.
  newstate = p-&gt;weapons[p-&gt;ready_wp].info-&gt;ready_state;

  P_SetPsprite(p, ps_weapon, newstate);
  P_SetPsprite(p, ps_crosshair, p-&gt;weapons[p-&gt;ready_wp].info-&gt;crosshair);
}
</t>
<t tx="T696">@ A_SetCrosshair
@c

void A_SetCrosshair(mobj_t * mo)
{
#if 0  // !! FIXME
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  P_SetPsprite(p, ps_crosshair,
    p-&gt;weapons[p-&gt;ready_wp].info-&gt;crosshair + psp-&gt;state-&gt;misc1);
#endif
}
</t>
<t tx="T697">
void A_GotTarget(mobj_t * mo)
{
#if 0  // !! FIXME
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  attacktype_t *attack = p-&gt;weapons[p-&gt;ready_wp].info-&gt;attack;
  mobj_t *obj;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  obj = P_MapTargetAutoAim(mo, mo-&gt;angle, attack-&gt;range,
      attack-&gt;flags &amp; AF_ForceAim);

  if (obj-&gt;extendedflags &amp; EF_DUMMYMOBJ)
    obj = P_MapTargetAutoAim(mo, mo-&gt;angle + (1 &lt;&lt; 26),
        attack-&gt;range, attack-&gt;flags &amp; AF_ForceAim);

  if (obj-&gt;extendedflags &amp; EF_DUMMYMOBJ)
    obj = P_MapTargetAutoAim(mo, mo-&gt;angle - (1 &lt;&lt; 26),
        attack-&gt;range, attack-&gt;flags &amp; AF_ForceAim);

  if (obj-&gt;extendedflags &amp; EF_DUMMYMOBJ)
    P_SetPsprite(p, ps_crosshair,
      p-&gt;weapons[p-&gt;ready_wp].info-&gt;crosshair + psp-&gt;state-&gt;misc1);
  else
    P_SetPsprite(p, ps_crosshair,
      p-&gt;weapons[p-&gt;ready_wp].info-&gt;crosshair + psp-&gt;state-&gt;misc2);
#endif
}
</t>
<t tx="T698">@ A_GunFlash
@c

void A_GunFlash(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (!p-&gt;flash)
  {
    if (mo-&gt;info-&gt;missile_state)
      P_SetMobjState(mo, mo-&gt;info-&gt;missile_state);

    P_SetPsprite(p, ps_flash, p-&gt;weapons[p-&gt;ready_wp].
        info-&gt;flash_state);
    p-&gt;flash = true;
  }
}
</t>
<t tx="T699">@ A_GunFlashSA
@c

void A_GunFlashSA(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (!p-&gt;flash)
  {
    if (mo-&gt;info-&gt;missile_state)
      P_SetMobjState(mo, mo-&gt;info-&gt;missile_state);

    P_SetPsprite(p, ps_flash, p-&gt;weapons[p-&gt;ready_wp].
        info-&gt;sa_flash_state);
    p-&gt;flash = true;
  }
}
</t>
<t tx="T700">@ WEAPON ATTACKS
@c

void A_WeaponShoot(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;
  attacktype_t *attack = w-&gt;attack;
  ammotype_t ammo;
  int count;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  // -AJA- 1999/08/10: Multiple attack support.
  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
    attack = (attacktype_t *) psp-&gt;state-&gt;action_par;

  ammo = w-&gt;ammo;

  // Minimal amount for one shot varies.
  count = w-&gt;ammopershot;

  // Some do not need ammunition anyway.
  // Return if current ammunition sufficient.
  if (!(ammo == AM_NoAmmo || p-&gt;ammo[ammo].num &gt;= count))
    return;

  // -AJA- 1999/08/11: Increase fire count.
  p-&gt;weapons[p-&gt;ready_wp].clip_size--;

  P_ActPlayerAttack(mo, attack);

  if (level_flags.kicking)
  {
    p-&gt;deltaviewheight -= w-&gt;kick;
    p-&gt;kick_offset = w-&gt;kick;
  }

  if (mo-&gt;target &amp;&amp; !(mo-&gt;target-&gt;extendedflags &amp; EF_DUMMYMOBJ))
  {
    if (w-&gt;hit)
      S_StartSound(mo, w-&gt;hit);

    if (w-&gt;feedback)
      mo-&gt;flags |= MF_JUSTATTACKED;
  }
  else
  {
    if (w-&gt;engaged)
      S_StartSound(mo, w-&gt;engaged);
  }

  // show the player making the shot/attack...

  if (attack &amp;&amp; attack-&gt;attackstyle == ATK_CLOSECOMBAT &amp;&amp;
      mo-&gt;info-&gt;melee_state)
  {
    P_SetMobjState(mo, mo-&gt;info-&gt;melee_state);
  }
  else if (mo-&gt;info-&gt;missile_state)
  {
    P_SetMobjState(mo, mo-&gt;info-&gt;missile_state);
  }

  if (ammo != AM_NoAmmo)
    p-&gt;ammo[ammo].num -= count;

  if (w-&gt;flash_state &amp;&amp; !p-&gt;flash)
  {
    P_SetPsprite(p, ps_flash, w-&gt;flash_state);
    p-&gt;flash = true;
  }
}
</t>
<t tx="T701">
void A_WeaponShootSA(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;
  attacktype_t *attack = w-&gt;sa_attack;
  ammotype_t ammo;
  int count;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  // -AJA- 1999/08/10: Multible attack support.
  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
    attack = (attacktype_t *) psp-&gt;state-&gt;action_par;

  ammo = w-&gt;sa_ammo;

  // Minimal amount for one shot varies.
  count = w-&gt;sa_ammopershot;

  // Some do not need ammunition anyway.
  // Return if current ammunition sufficient.
  if (!(ammo == AM_NoAmmo || p-&gt;ammo[ammo].num &gt;= count))
    return;

  // -AJA- 1999/08/11: Increase fire count.
  p-&gt;weapons[p-&gt;ready_wp].sa_clip_size--;

  P_ActPlayerAttack(mo, attack);

  if (mo-&gt;target &amp;&amp; !(mo-&gt;target-&gt;extendedflags &amp; EF_DUMMYMOBJ))
  {
    if (w-&gt;hit)
      S_StartSound(mo, w-&gt;hit);

    if (w-&gt;feedback)
      mo-&gt;flags |= MF_JUSTATTACKED;
  }
  else
  {
    if (w-&gt;engaged)
      S_StartSound(mo, w-&gt;engaged);
  }

  // show the player making the shot/attack...

  if (attack &amp;&amp; attack-&gt;attackstyle == ATK_CLOSECOMBAT &amp;&amp;
      mo-&gt;info-&gt;melee_state)
  {
    P_SetMobjState(mo, mo-&gt;info-&gt;melee_state);
  }
  else if (mo-&gt;info-&gt;missile_state)
  {
    P_SetMobjState(mo, mo-&gt;info-&gt;missile_state);
  }

  if (ammo != AM_NoAmmo)
    p-&gt;ammo[ammo].num -= count;

  if (w-&gt;sa_flash_state &amp;&amp; !p-&gt;flash)
  {
    P_SetPsprite(p, ps_flash, w-&gt;sa_flash_state);
    p-&gt;flash = true;
  }
}
</t>
<t tx="T702">@ A_WeaponEject

Used for ejecting shells (or other effects).

-AJA- 1999/09/10: written.
@c

void A_WeaponEject(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;
  attacktype_t *attack = w-&gt;eject_attack;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
    attack = (attacktype_t *) psp-&gt;state-&gt;action_par;

  P_ActPlayerAttack(mo, attack);
}
</t>
<t tx="T703">@ A_WeaponPlaySound

Generate an arbitrary sound from this weapon.
@c

void A_WeaponPlaySound(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];
  
  sfx_t *sound = NULL;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
    sound = (sfx_t *) psp-&gt;state-&gt;action_par;

  if (! sound)
  {
    M_WarnError("A_WeaponPlaySound: missing sound name !\n");
    return;
  }

  S_StartSound(mo, sound);
}
</t>
<t tx="T704">@ A_WeaponKillSound

Kill any current sound from this weapon.
@c

void A_WeaponKillSound(mobj_t * mo)
{
  S_StopSound(mo);
}
</t>
<t tx="T705">@ A_SFXWeapon1/2/3
@c

void A_SFXWeapon1(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);
  S_StartSound(mo, p-&gt;weapons[p-&gt;ready_wp].info-&gt;sound1);
}
</t>
<t tx="T706">
void A_SFXWeapon2(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);
  S_StartSound(mo, p-&gt;weapons[p-&gt;ready_wp].info-&gt;sound2);
}
</t>
<t tx="T707">
void A_SFXWeapon3(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);
  S_StartSound(mo, p-&gt;weapons[p-&gt;ready_wp].info-&gt;sound3);
}
</t>
<t tx="T708">@ These three routines make a flash of light when a weapon fires.
@c

void A_Light0(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);
  p-&gt;extralight = 0;
}
</t>
<t tx="T709">
void A_Light1(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);
  p-&gt;extralight = 1;
}
</t>
<t tx="T710">
void A_Light2(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);
  p-&gt;extralight = 2;
}
</t>
<t tx="T711">@ A_WeaponJump
@c

void A_WeaponJump(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];
  weaponinfo_t *w = p-&gt;weapons[p-&gt;ready_wp].info;

  act_jump_info_t *jump;
  
  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (!psp-&gt;state || !psp-&gt;state-&gt;action_par)
  {
    M_WarnError("JUMP used in weapon [%s] without a label !\n",
        w-&gt;ddf.name);
    return;
  }

  jump = (act_jump_info_t *) psp-&gt;state-&gt;action_par;

  DEV_ASSERT2(jump-&gt;chance &gt;= 0);
  DEV_ASSERT2(jump-&gt;chance &lt;= 1);

  if (P_RandomTest(jump-&gt;chance))
  {
    psp-&gt;next_state = (psp-&gt;state-&gt;jumpstate == S_NULL) ? NULL :
        (states + psp-&gt;state-&gt;jumpstate);
  }
}
</t>
<t tx="T712">@ A_WeaponTransSet
@c

void A_WeaponTransSet(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];
  float_t value = VISIBLE;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
  {
    value = ((percent_t *) psp-&gt;state-&gt;action_par)[0];
    value = MAX(0.0, MIN(1.0, value));
  }

  psp-&gt;visibility = psp-&gt;vis_target = value;
}
</t>
<t tx="T713">@ A_WeaponTransFade
@c

void A_WeaponTransFade(mobj_t * mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];
  float_t value = INVISIBLE;

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
  {
    value = ((percent_t *) psp-&gt;state-&gt;action_par)[0];
    value = MAX(0.0, MIN(1.0, value));
  }

  psp-&gt;vis_target = value;
}
</t>
<t tx="T714">@ P_SetupPsprites

Called at start of level for each player.
@c

void P_SetupPsprites(player_t * p)
{
  int i;

  // remove all psprites
  for (i = 0; i &lt; NUMPSPRITES; i++)
  {
    pspdef_t *psp = &amp;p-&gt;psprites[i];

    psp-&gt;state = NULL;
    psp-&gt;next_state = NULL;
    psp-&gt;sx = psp-&gt;sy = 0;
    psp-&gt;visibility = psp-&gt;vis_target = VISIBLE;
  }

  // spawn the gun
  p-&gt;pending_wp = p-&gt;ready_wp;

  P_BringUpWeapon(p);
}
</t>
<t tx="T715">@ P_MovePsprites

Called every tic by player thinking routine.
@c

#define MAX_PSP_LOOP  10

void P_MovePsprites(player_t * p)
{
  int i;
  pspdef_t *psp;
  int loop_count;

  // check if player has NO weapon but wants to change
  if (! p-&gt;psprites[ps_weapon].state &amp;&amp;
      p-&gt;pending_wp != WPSEL_NoChange)
  {
    P_BringUpWeapon(p);
  }
  
  psp = &amp;p-&gt;psprites[0];

  for (i = 0; i &lt; NUMPSPRITES; i++, psp++)
  {
    // a null state means not active
    if (! psp-&gt;state)
      continue;

    for (loop_count=0; loop_count &lt; MAX_PSP_LOOP; loop_count++)
    {
      // drop tic count and possibly change state
      // Note: a -1 tic count never changes.
      if (psp-&gt;tics &lt; 0)
        break;
      
      psp-&gt;tics--;

      if (psp-&gt;tics &gt;= 1)
        break;

      P_SetPsprite(p, i, psp-&gt;next_state ?
          (psp-&gt;next_state - states) : S_NULL);

      if (psp-&gt;tics != 0)
        break;
    }

    // handle translucency fades
    psp-&gt;visibility = (34 * psp-&gt;visibility + psp-&gt;vis_target) / 35;
  }

  p-&gt;psprites[ps_flash].sx = p-&gt;psprites[ps_weapon].sx;
  p-&gt;psprites[ps_flash].sy = p-&gt;psprites[ps_weapon].sy;
}
</t>
<t tx="T716">@ P_ActCheckMoving

-KM- 1999/01/31 Returns a player to spawnstate when not moving.
@c

void P_ActCheckMoving(mobj_t * mo)
{
  player_t *p = mo-&gt;player;

  if (fabs(mo-&gt;mom.x) &lt; STOPSPEED &amp;&amp; fabs(mo-&gt;mom.y) &lt; STOPSPEED)
  {
    if (p)
    {
      if (p-&gt;cmd.forwardmove || p-&gt;cmd.sidemove)
        return;
    }
    mo-&gt;mom.x = mo-&gt;mom.y = 0;

    P_SetMobjStateDeferred(mo, mo-&gt;info-&gt;idle_state, 0);
  }
}
</t>
<t tx="T717">@ A_WeaponEnableRadTrig
A_WeaponDisableRadTrig
@c

void A_WeaponEnableRadTrig(mobj_t *mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
  {
    int tag = *(int *)psp-&gt;state-&gt;action_par;
    RAD_EnableByTag(mo, tag, false);
  }
}
</t>
<t tx="T718">
void A_WeaponDisableRadTrig(mobj_t *mo)
{
  player_t *p = mo-&gt;player;
  pspdef_t *psp = &amp;p-&gt;psprites[p-&gt;action_psp];

  DEV_ASSERT2(p-&gt;ready_wp &gt;= 0);

  if (psp-&gt;state &amp;&amp; psp-&gt;state-&gt;action_par)
  {
    int tag = *(int *)psp-&gt;state-&gt;action_par;
    RAD_EnableByTag(mo, tag, true);
  }
}
</t>
<t tx="T719">@ P_Zoom
@c

void P_Zoom(player_t *p)
{
  if (viewiszoomed)
  {
    R_SetFOV(normalfov);
    viewiszoomed = false;
    return;
  }
  
  // In `LimitZoom' mode, only allow zooming if weapon supports it
  if (level_flags.limit_zoom)
  {
    if (p-&gt;ready_wp &lt; 0 || p-&gt;pending_wp &gt;= 0)
      return;
    
    if (p-&gt;weapons[p-&gt;ready_wp].info-&gt;zoom_fov &gt; 0)
    {
      R_SetFOV(p-&gt;weapons[p-&gt;ready_wp].info-&gt;zoom_fov);
      viewiszoomed = true;
    }
    return;
  }

  // -ES- 1999/04/03 Oops
  R_SetFOV(zoomedfov);
  viewiszoomed = true;
}
</t>
<t tx="T720">@ignore
@language c

// True BSP Rendering (BSP Traversal)

// -AJA- 1999/08/31: Wrote this file.
//
// TODO HERE:
//   + optimise first subsector: ignore floors out of view.
//   + fix the single-pixel-gap sprite clipping bug.
//   + draw halos.
//   + split up: r2_seg.c and r2_mobj.c.

&lt;&lt; r2_bsp #includes &gt;&gt;
&lt;&lt; r2_bsp declarations &gt;&gt;
@others
</t>
<t tx="T721">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_bbox.h"
#include "p_local.h"
#include "p_mobj.h"
#include "p_spec.h"
#include "r_defs.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_sky.h"
#include "r_state.h"
#include "r_things.h"
#include "r2_defs.h"
#include "v_colour.h"
#include "v_res.h"
#include "z_zone.h"
</t>
<t tx="T722">

#define DEBUG  0
#define DEBUG_OVERDRAW  0


// common stuff

extern sector_t *frontsector;
extern sector_t *backsector;

static subsector_t *cur_sub;
static seg_t *cur_seg;

static int cur_x_min, cur_x_max;

static boolean_t cur_upper_sky;
static boolean_t cur_lower_sky;
static boolean_t cur_upper_invis;
static boolean_t cur_lower_invis;

static subsector_t *drawsubs;


int detail_level = 1;
boolean_t use_dlights = false;
int sprite_kludge = 0;
</t>
<t tx="T723">#define APPROX_DIST2(dx,dy)  \
((dx) + (dy) - 0.5 * MIN((dx),(dy)))

#define APPROX_DIST3(dx,dy,dz)  \
APPROX_DIST2(APPROX_DIST2(dx,dy),dz)


// The minimum distance between player and a visible sprite.
#define MINZ  2.0


#define PART_TEX_W(part)  (part-&gt;image ? IM_WIDTH( part-&gt;image) : 0)
#define PART_TEX_H(part)  (part-&gt;image ? IM_HEIGHT(part-&gt;image) : 0)

// R2_AddDLights
//
// Increases the array of light level at the points (x,y,z).
//
void R2_AddDLights(int num, int *level, 
float_t *x, float_t *y, float_t *z, mobj_t *mo)
{
int qty = (int)ceil(mo-&gt;dlight_qty);

float_t mo_z = mo-&gt;z + mo-&gt;height * PERCENT_2_FLOAT(mo-&gt;info-&gt;dlight.height);
float_t dist;

DEV_ASSERT2(num &gt; 0);
DEV_ASSERT2(qty &gt; 0);

switch (mo-&gt;info-&gt;dlight.type)
{
case DLITE_None:
  I_Error("R2_AddDLights: bad dynamic light\n");

case DLITE_Constant:
  for (; num &gt; 0; num--, level++, x++, y++, z++)
    (*level) += qty;
  break;

case DLITE_Linear:
  for (; num &gt; 0; num--, level++, x++, y++, z++)
  {
    dist = APPROX_DIST3(fabs((*x) - mo-&gt;x), fabs((*y) - mo-&gt;y), 
        fabs((*z) - mo_z));

    (*level) += qty * 32.0 / MAX(1.0, dist);
  }
  break;

case DLITE_Quadratic:
  for (; num &gt; 0; num--, level++, x++, y++, z++)
  {
    dist = APPROX_DIST3(fabs((*x) - mo-&gt;x), fabs((*y) - mo-&gt;y), 
        fabs((*z) - mo_z));
    
    (*level) += qty * 1024.0 / MAX(1, dist * dist);
  }
  break;
}
}
</t>
<t tx="T724">@ R2_AddColourDLights

Increases the arrays of colour levels at the points (x,y,z).
@c

void R2_AddColourDLights(int num, int *r, int *g, int *b, 
    float_t *x, float_t *y, float_t *z, mobj_t *mo)
{
  int base_qty = (int)ceil(mo-&gt;dlight_qty);
  int qty;

  float_t mo_z = mo-&gt;z + mo-&gt;height * PERCENT_2_FLOAT(mo-&gt;info-&gt;dlight.height);
  float_t dist;
    
  int R = (mo-&gt;info-&gt;dlight.colour &gt;&gt; 16) &amp; 0xFF;
  int G = (mo-&gt;info-&gt;dlight.colour &gt;&gt;  8) &amp; 0xFF;
  int B = (mo-&gt;info-&gt;dlight.colour      ) &amp; 0xFF;

  DEV_ASSERT2(num &gt; 0);
  DEV_ASSERT2(base_qty &gt; 0);

  switch (mo-&gt;info-&gt;dlight.type)
  {
    case DLITE_None:
      I_Error("R2_AddColourDLights: bad dynamic light\n");

    case DLITE_Constant:
      for (; num &gt; 0; num--, r++, g++, b++, x++, y++, z++)
      {
        (*r) += base_qty * R / 255;
        (*g) += base_qty * G / 255;
        (*b) += base_qty * B / 255;
      }
      break;
  
    case DLITE_Linear:
      for (; num &gt; 0; num--, r++, g++, b++, x++, y++, z++)
      {
        dist = APPROX_DIST3(fabs((*x) - mo-&gt;x), fabs((*y) - mo-&gt;y), 
            fabs((*z) - mo_z));

        qty = base_qty * 32.0 / MAX(1.0, dist);

        (*r) += qty * R / 255;
        (*g) += qty * G / 255;
        (*b) += qty * B / 255;
      }
      break;

    case DLITE_Quadratic:
      for (; num &gt; 0; num--, r++, g++, b++, x++, y++, z++)
      {
        dist = APPROX_DIST3(fabs((*x) - mo-&gt;x), fabs((*y) - mo-&gt;y), 
            fabs((*z) - mo_z));
        
        qty = base_qty * 1024.0 / MAX(1, dist * dist);

        (*r) += qty * R / 255;
        (*g) += qty * G / 255;
        (*b) += qty * B / 255;
      }
      break;
  }
}
</t>
<t tx="T725">@ R2_WallEvent

Handle a single section of wall.
@c

static void R2_WallEvent(drawfloor_t *dfloor, int x1, int x2,
    float_t top, float_t bottom, float_t tex_top_h, 
    surface_t *part, boolean_t is_masked, float_t x_offset)
{
  drawwall_t *wall;
  screenline_t *area;

  float_t yt, yt2, yt_step;
  float_t yb, yb2, yb_step;

  int x;
  float_t scale1, scale2, scale_step;

  boolean_t maybe_slider = is_masked;
  boolean_t solid, connect_low, connect_high;

#if (DEBUG &gt;= 3)
    L_WriteDebug("WALL X:%d..%d (%d,%d,%d) -&gt; (%d,%d,%d)\n", x1, x2,
        (int)cur_seg-&gt;v1-&gt;x, (int)cur_seg-&gt;v1-&gt;y, (int)top,
        (int)cur_seg-&gt;v2-&gt;x, (int)cur_seg-&gt;v2-&gt;y, (int)bottom);
#endif
  
  scale1 = cur_seg-&gt;scale1;
  scale2 = cur_seg-&gt;scale2;

  scale_step = (x1==x2) ? 0 : (scale2 - scale1) / (x2 - x1);
  
  wall = R2_GetDrawWall();
  area = &amp;wall-&gt;area;

  wall-&gt;next = NULL;
  wall-&gt;seg  = cur_seg;

  wall-&gt;part  = part;
  wall-&gt;props = part-&gt;override_p ? part-&gt;override_p : dfloor-&gt;props;
  wall-&gt;is_masked = is_masked;

  wall-&gt;scale1 = scale1 + scale_step * (x1 - cur_seg-&gt;x1);
  wall-&gt;scale_step = scale_step;

  wall-&gt;distance = cur_seg-&gt;rw_distance;
  wall-&gt;x_offset = cur_seg-&gt;rw_offset + x_offset;
  wall-&gt;angle = cur_seg-&gt;angle;
  wall-&gt;slide_type = SLIDE_None;
  
  // horizontal slider hack
  if (maybe_slider &amp;&amp; cur_seg-&gt;linedef-&gt;special &amp;&amp; 
      cur_seg-&gt;linedef-&gt;special-&gt;s.type != SLIDE_None)
  {
    slider_move_t *smov = cur_seg-&gt;linedef-&gt;slider_move;

    if (smov)
    {
      wall-&gt;slide_type = smov-&gt;info-&gt;type;
      wall-&gt;opening = smov-&gt;opening;
      wall-&gt;line_len = smov-&gt;line_len;
    }

    wall-&gt;side = 0;

    // seg is on left side of linedef ?
    if ((cur_seg-&gt;v2-&gt;x - cur_seg-&gt;v1-&gt;x) * cur_seg-&gt;linedef-&gt;dx &lt; 0 ||
        (cur_seg-&gt;v2-&gt;y - cur_seg-&gt;v1-&gt;y) * cur_seg-&gt;linedef-&gt;dy &lt; 0)
    {
      wall-&gt;side = 1;
#if 0
      if (wall-&gt;slide_type == SLIDE_Left)
        wall-&gt;slide_type = SLIDE_Right;
      else if (wall-&gt;slide_type == SLIDE_Right)
        wall-&gt;slide_type = SLIDE_Left;
#endif
    }
  }

  DEV_ASSERT2(x2 &gt;= x1);

  solid = !is_masked &amp;&amp; (part-&gt;translucency &gt; 0.99);

  connect_high = solid &amp;&amp; !dfloor-&gt;higher &amp;&amp; 
      (top &gt;= cur_sub-&gt;sector-&gt;c_h);

  connect_low = solid &amp;&amp; !dfloor-&gt;lower &amp;&amp;
      (bottom &lt;= cur_sub-&gt;sector-&gt;f_h);

  // calculate area
  area-&gt;x1 = x1;
  area-&gt;x2 = x2;

  area-&gt;ranges = R2_GetOpenings(x2 - x1 + 1);

  area-&gt;y_offset = tex_top_h - top;

  top    -= viewz;
  bottom -= viewz;

  yt  = focusyfrac - top * scale1;
  yt2 = focusyfrac - top * scale2;

  yb  = focusyfrac - bottom * scale1;
  yb2 = focusyfrac - bottom * scale2;

  yt_step = (x1==x2) ? 0 : (yt2 - yt) / (x2 - x1);
  yb_step = (x1==x2) ? 0 : (yb2 - yb) / (x2 - x1);

  area-&gt;y = yt;
  area-&gt;step = yt_step;

  // quit early if totally off-screen
  if ((yb &lt; 0 &amp;&amp; yb2 &lt; 0) || (yt &gt;= viewheight &amp;&amp; yt2 &gt;= viewheight))
  {
    R2_CommitOpenings(0);
    R2_CommitDrawWall(0);
    return;
  }
  
  for (x=x1; x &lt;= x2; x++, yt += yt_step, yb += yb_step)
  {
    int y1 = MAX((int)floor(yt), 0);
    int y2 = MIN((int)floor(yb), viewheight-1);

    if (y1 &gt; y2)
    {
      y1 = 1;
      y2 = 0;
    }

    area-&gt;ranges[x - x1].y1 = y1;
    area-&gt;ranges[x - x1].y2 = y2;
  }

  R2_1DOcclusionClose(x1, x2, area-&gt;ranges);
  R2_2DOcclusionClose(x1, x2, area-&gt;ranges, connect_low, connect_high, solid);
 
  //
  // Dynamic lighting
  //
  wall-&gt;extra_light[0] = 0;
  wall-&gt;extra_light[1] = 0;

  if (use_dlights)
  {
    drawthing_t *dl;
    divline_t div;
    float_t wx[2], wy[2], wz[2];

    wx[0] = cur_seg-&gt;v1-&gt;x;
    wy[0] = cur_seg-&gt;v1-&gt;y;

    wx[1] = cur_seg-&gt;v2-&gt;x;
    wy[1] = cur_seg-&gt;v2-&gt;y;
    
    wz[0] = wz[1] = (top+bottom) / 2.0;

    div.x  = cur_seg-&gt;v1-&gt;x;
    div.y  = cur_seg-&gt;v1-&gt;y;
    div.dx = cur_seg-&gt;v2-&gt;x - div.x;
    div.dy = cur_seg-&gt;v2-&gt;y - div.y;

    for (dl=dfloor-&gt;dlights; dl; dl=dl-&gt;next)
    {
      // light behind seg ?    
      if (P_PointOnDivlineSide(dl-&gt;mo-&gt;x, dl-&gt;mo-&gt;y, &amp;div) != 0)
        continue;
       
      R2_AddDLights(2, wall-&gt;extra_light, wx, wy, wz, dl-&gt;mo);
    }
  }

  // link it in
  DEV_ASSERT2(!cur_seg-&gt;miniseg);
  if (!cur_seg-&gt;backsector || connect_low || connect_high)
  {
    R2_DrawWall(cur_sub, wall);
    R2_CommitOpenings(0);
    R2_CommitDrawWall(0);
  }
  else
  {
    wall-&gt;next = dfloor-&gt;walls;
    dfloor-&gt;walls = wall;

    R2_CommitOpenings(x2 - x1 + 1);
    R2_CommitDrawWall(1);
  }
}
</t>
<t tx="T726">@ Analyses floor/ceiling heights, and add corresponding walls/floors
to the drawfloor. Returns true if the whole region was "solid".
@c

static boolean_t R2_BuildWalls(drawfloor_t *floor)
{
  side_t *sd = cur_seg-&gt;sidedef;
   
  float_t f1 = floor-&gt;f_h;
  float_t c1 = floor-&gt;c_h;

  float_t f, c, tex_top_h;
  float_t x_offset;

  int j;
  wall_tile_t *wt;

#if (DEBUG &gt;= 3)
    L_WriteDebug("   BUILD WALLS %1.1f .. %1.1f\n", f1, c1);
#endif

  // handle TRANSLUCENT + THICK floors (a bit of a hack)
  if (floor-&gt;ef &amp;&amp; floor-&gt;higher &amp;&amp;
      (floor-&gt;ef-&gt;ef_info-&gt;type &amp; EXFL_Thick) &amp;&amp;
      (floor-&gt;ef-&gt;top-&gt;translucency &lt;= 0.99))
  {
    c1 = floor-&gt;ef-&gt;top_h;
  }

  for (j=0; j &lt; sd-&gt;tile_used; j++)
  {
    wt = sd-&gt;tiles + j;

    c = MIN(c1, wt-&gt;z2);
    f = MAX(f1, wt-&gt;z1);

    // not visible ?
    if (f &gt;= c)
      continue;

    DEV_ASSERT2(wt-&gt;surface-&gt;image);
 
    tex_top_h = wt-&gt;tex_z + wt-&gt;surface-&gt;offset.y;

    if (wt-&gt;flags &amp; WTILF_Extra)
      x_offset = cur_seg-&gt;sidedef-&gt;middle.offset.x;
    else
      x_offset = wt-&gt;surface-&gt;offset.x;
    
    R2_WallEvent(floor, cur_seg-&gt;x1, cur_seg-&gt;x2, c, f, tex_top_h,
        wt-&gt;surface, (wt-&gt;flags &amp; WTILF_MidMask), x_offset);
  }

  if (cur_seg-&gt;sidedef-&gt;middle.image == NULL)
  {
    // -AJA- hack for transparent doors (this test would normally be
    // above this block, not inside it).
    //
    if (f1 &gt;= c1)
      return true;

    return false;
  }

  // handle sliders that are totally solid and closed
  if (cur_seg-&gt;linedef-&gt;special &amp;&amp;
      cur_seg-&gt;linedef-&gt;special-&gt;s.type != SLIDE_None &amp;&amp;
      ! cur_seg-&gt;linedef-&gt;special-&gt;s.see_through &amp;&amp;
      ! cur_seg-&gt;linedef-&gt;slider_move)
  {
    return true;
  }
   
  return false;
}
</t>
<t tx="T727">static void R2_WalkWall(seg_t *seg)
{
  drawfloor_t *dfloor;

  cur_seg = seg;

  frontsector = seg-&gt;front_sub-&gt;sector;
  backsector  = NULL;

  if (seg-&gt;back_sub)
    backsector = seg-&gt;back_sub-&gt;sector;

  cur_upper_sky = (backsector &amp;&amp; IS_SKY(frontsector-&gt;ceil) &amp;&amp;
      IS_SKY(backsector-&gt;ceil));

  cur_lower_sky = (backsector &amp;&amp; IS_SKY(frontsector-&gt;floor) &amp;&amp;
      IS_SKY(backsector-&gt;floor));

  cur_upper_invis = cur_lower_invis = false;

  DEV_ASSERT2(!seg-&gt;miniseg);

  // -AJA- hack to allow transparent doors
  if (backsector)
  {
    cur_lower_invis = (backsector-&gt;f_h &gt; frontsector-&gt;f_h) &amp;&amp;
        (seg-&gt;sidedef-&gt;bottom.image == NULL);

    cur_upper_invis = (backsector-&gt;c_h &lt; frontsector-&gt;c_h) &amp;&amp;
        (seg-&gt;sidedef-&gt;top.image == NULL);
  }

  // --- handle each floor ---
  
  for (dfloor=cur_sub-&gt;floors; dfloor; dfloor=dfloor-&gt;next)
  {
    R2_BuildWalls(dfloor);
  }

  // cookie-cut the seg from the 1D occlusion buffer
  if (seg-&gt;linedef-&gt;blocked)
    R2_1DOcclusionSet(seg-&gt;x1, seg-&gt;x2);
}
</t>
<t tx="T728">@ R2_WalkSeg

Visit a single seg (aka. line) that forms part of the current
subsector.

seg-&gt;back will be true if the seg faces away from the camera.

seg-&gt;visible will be true if the seg (front or back) is visible.
Examples of non-visible: totally off left/right screen edge,
totally occluded by 1D buffer.

Visible segs (front or back) have valid info (x1, x2, angle1/2,
scale1/2, etc). All segs have value translated coords (for sprite
clipping).
@c

static void R2_WalkSeg(seg_t *seg)
{
  angle_t angle1, angle2, temp;
  angle_t span, tspan1, tspan2, distangle;
  float_t hyp;

  int x1, x2;

  seg-&gt;visible = false;
  seg-&gt;back = false;

  // translate coordinates
  {
    float_t tx1 = seg-&gt;v1-&gt;x - viewx;
    float_t ty1 = seg-&gt;v1-&gt;y - viewy;
    float_t tx2 = seg-&gt;v2-&gt;x - viewx;
    float_t ty2 = seg-&gt;v2-&gt;y - viewy;

    seg-&gt;tx1 = tx1 * viewsin - ty1 * viewcos;
    seg-&gt;tz1 = tx1 * viewcos + ty1 * viewsin;

    seg-&gt;tx2 = tx2 * viewsin - ty2 * viewcos;
    seg-&gt;tz2 = tx2 * viewcos + ty2 * viewsin;
  }

  // compute sprite clipping info
  seg-&gt;orientation = 0;

  if (seg-&gt;back_sub &amp;&amp; sprite_kludge &lt;= 1 &amp;&amp;
      (seg-&gt;miniseg || !seg-&gt;linedef-&gt;blocked) &amp;&amp;
      (seg-&gt;tz1 &gt; MINZ || seg-&gt;tz2 &gt; MINZ) &amp;&amp;
      fabs(seg-&gt;tz1 - seg-&gt;tz2) &gt; 0.2)
  {
    seg-&gt;orientation = ((seg-&gt;angle - (viewangle + ANG90)) &lt;= 
        ANG180) ? -1 : +1;
  }

#if (DEBUG &gt;= 3)
    L_WriteDebug("TRANS %p: (%1.1f,%1.1f) -&gt; (%1.1f,%1.1f) "
        "orien=%d\n", seg, seg-&gt;tx1, seg-&gt;tz1, seg-&gt;tx2, 
        seg-&gt;tz2, seg-&gt;orientation);
#endif

  angle1 = R_PointToAngle(viewx, viewy, seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y);
  angle2 = R_PointToAngle(viewx, viewy, seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y);

  // Clip to view edges.
  // -ES- 1999/03/20 Replaced clipangle with clipscope/leftclipangle/rightclipangle

  span = angle1 - angle2;

  // back side ?
  if (span &gt;= ANG180)
  {
    temp   = angle1; 
    angle1 = angle2; 
    angle2 = temp;
    
    seg-&gt;back = true;
    span = 0 - span;
  }

  // Global angle needed by segcalc.
  rw_angle1 = angle1;

  angle1 -= viewangle;
  angle2 -= viewangle;

#if (DEBUG &gt;= 3)
    L_WriteDebug("ANGLE1 = %1.2f  ANGLE2 = %1.2f\n", 
        ANG_2_FLOAT(angle1), ANG_2_FLOAT(angle2));
#endif

  tspan1 = angle1 - rightclipangle;
  tspan2 = leftclipangle - angle2;

  if (tspan1 &gt; clipscope)
  {
    // Totally off the left edge?
    if (tspan2 &gt;= ANG180)
      return;

    angle1 = leftclipangle;
  }

  if (tspan2 &gt; clipscope)
  {
    // Totally off the left edge?
    if (tspan1 &gt;= ANG180)
      return;

    angle2 = rightclipangle;
  }

#if (DEBUG &gt;= 3)
    L_WriteDebug("ANGLE1 = %1.2f  ANGLE2 = %1.2f\n", 
        ANG_2_FLOAT(angle1), ANG_2_FLOAT(angle2));
#endif

  seg-&gt;angle1 = angle1;
  seg-&gt;angle2 = angle2;

  // The seg is in the view range,
  // but not necessarily visible.

  angle1 = (angle1 + ANG90) &gt;&gt; ANGLETOFINESHIFT;
  angle2 = (angle2 + ANG90) &gt;&gt; ANGLETOFINESHIFT;

  // clip to screen
  x1 = MAX(viewangletox[angle1], 0);
  x2 = MIN(viewangletox[angle2], viewwidth) - 1;

  if (x1 &lt;= x2)
  {
    seg-&gt;visible = ! R2_1DOcclusionTestShrink(&amp;x1, &amp;x2);
  }

  seg-&gt;x1 = x1;
  seg-&gt;x2 = x2;

#if (DEBUG &gt;= 2)
    L_WriteDebug("  %sSEG %p (%1.1f, %1.1f) -&gt; (%1.1f, %1.1f) %s %s\n",
        seg-&gt;miniseg ? "MINI" : "", seg, seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y, 
        seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y, seg-&gt;back ? "back" : "front", 
        seg-&gt;visible ?  "visible" : "non-vis");
#endif

  if (!seg-&gt;visible)
    return;

  // update screen bounds of subsector
  {
    cur_x_min = MIN(cur_x_min, x1);
    cur_x_max = MAX(cur_x_max, x2);
  }

  // mark the segment as visible for auto map
  if (seg-&gt;visible &amp;&amp; !seg-&gt;miniseg)
    seg-&gt;linedef-&gt;flags |= ML_Mapped;

  // determine angle that is normal to the seg line
  rw_normalangle = seg-&gt;angle + (seg-&gt;back ? ANG270 : ANG90);

  // distangle is the angle that lies between the seg line and the
  // line from the camera to the seg's first point.

  distangle = rw_normalangle - rw_angle1;

  if (distangle &gt; ANG180)
    distangle = 0 - distangle;
    
  distangle = (distangle &gt;= ANG90) ? 0 : ANG90 - distangle;

  // rw_distance is the distance from the camera to the seg line along
  // a line which is normal to the seg line.

  hyp = R_PointToDist(viewx, viewy, (seg-&gt;back ? seg-&gt;v2 : seg-&gt;v1)-&gt;x, 
      (seg-&gt;back ? seg-&gt;v2 : seg-&gt;v1)-&gt;y);

  seg-&gt;rw_distance = hyp * M_Sin(distangle);
  seg-&gt;rw_offset   = hyp * M_Cos(distangle);

  if (rw_normalangle - rw_angle1 &lt; ANG180)
    seg-&gt;rw_offset = 0 - seg-&gt;rw_offset;

  seg-&gt;rw_offset += seg-&gt;offset;

  // calculate scale at both ends and step
  rw_distance = seg-&gt;rw_distance;

  seg-&gt;scale1 = R_ScaleFromGlobalAngle(viewangle + xtoviewangle[x1]);
  seg-&gt;scale2 = R_ScaleFromGlobalAngle(viewangle + xtoviewangle[x2]);

#if (DEBUG &gt;= 2)
    L_WriteDebug("    %d..%d  scale1=%1.8f  scale2=%1.8f  "
        "rw_dist=%1.2f  rw_off=%1.2f\n", seg-&gt;x1, seg-&gt;x2, 
        seg-&gt;scale1, seg-&gt;scale2, seg-&gt;rw_distance, seg-&gt;rw_offset);
#endif

#if 0
  // -AJA- this code is no longer needed, but I want to keep it in
  //       case later on we decide to implement slopes.  It computes
  //       the world coords of the start and end of the wall part.
  {
    angle_t angle1 = viewangle - seg-&gt;angle + xtoviewangle[x1] - ANG90;
    angle_t angle2 = viewangle - seg-&gt;angle + xtoviewangle[x2] - ANG90;

    float_t x_dist1 = rw_offset2 - seg-&gt;offset;
    float_t x_dist2 = rw_offset2 - seg-&gt;offset;

    float_t x1 = seg-&gt;v1-&gt;x;
    float_t y1 = seg-&gt;v1-&gt;y;
    angle_t angle = seg-&gt;angle;

    if (! (ANG90-ANG1  &lt;= angle1 &amp;&amp; angle1 &lt;= ANG90+ANG1) &amp;&amp;
        ! (ANG270-ANG1 &lt;= angle1 &amp;&amp; angle1 &lt;= ANG270+ANG1))
      x_dist1 -= M_Tan(angle1) * rw_distance;
    
    if (! (ANG90-ANG1  &lt;= angle2 &amp;&amp; angle2 &lt;= ANG90+ANG1) &amp;&amp;
        ! (ANG270-ANG1 &lt;= angle2 &amp;&amp; angle2 &lt;= ANG270+ANG1))
      x_dist2 -= M_Tan(angle2) * rw_distance;

    if (cur_is_back)
    {
      x1 = seg-&gt;x2;
      y1 = seg-&gt;y2;

      angle += ANG180;
    }
    
    cur_world_x1 = x1 + M_Cos(angle) * x_dist1;
    cur_world_y1 = y1 + M_Sin(angle) * x_dist1;
    cur_world_x2 = x1 + M_Cos(angle) * x_dist2;
    cur_world_y2 = y1 + M_Sin(angle) * x_dist2;
  }
#endif
}
</t>
<t tx="T729">@ Checks BSP node/subtree bounding box.
Returns true if some part of the bbox might be visible.

Placed here to be close to R2_WalkSeg(), which contains similiar
logic with respect to the angle clipping stuff.
@c

extern int checkcoord[12][4];

boolean_t R2_CheckBBox(float_t *bspcoord)
{
  int boxx;
  int boxy;
  int boxpos;

  float_t x1, y1, x2, y2;

  angle_t angle1, angle2;
  angle_t span, tspan1, tspan2;

  int sx1, sx2;

  // Find the corners of the box
  // that define the edges from current viewpoint.
  if (viewx &lt;= bspcoord[BOXLEFT])
    boxx = 0;
  else if (viewx &lt; bspcoord[BOXRIGHT])
    boxx = 1;
  else
    boxx = 2;

  if (viewy &gt;= bspcoord[BOXTOP])
    boxy = 0;
  else if (viewy &gt; bspcoord[BOXBOTTOM])
    boxy = 1;
  else
    boxy = 2;

  boxpos = (boxy &lt;&lt; 2) + boxx;
  if (boxpos == 5)
    return true;

  x1 = bspcoord[checkcoord[boxpos][0]];
  y1 = bspcoord[checkcoord[boxpos][1]];
  x2 = bspcoord[checkcoord[boxpos][2]];
  y2 = bspcoord[checkcoord[boxpos][3]];

  // check clip list for an open space
  angle1 = R_PointToAngle(viewx, viewy, x1, y1) - viewangle;
  angle2 = R_PointToAngle(viewx, viewy, x2, y2) - viewangle;

  span = angle1 - angle2;

  // Sitting on a line?
  if (span &gt;= ANG180)
    return true;

  // -ES- 1999/03/20 Replaced clipangle with clipscope/leftclipangle/rightclipangle

  tspan1 = angle1 - rightclipangle;
  tspan2 = leftclipangle - angle2;

  if (tspan1 &gt; clipscope)
  {
    // Totally off the left edge?
    if (tspan2 &gt;= ANG180)
      return false;

    angle1 = leftclipangle;
  }

  if (tspan2 &gt; clipscope)
  {
    // Totally off the right edge?
    if (tspan1 &gt;= ANG180)
      return false;

    angle2 = rightclipangle;
  }

  // Find the first clippost
  //  that touches the source post
  //  (adjacent pixels are touching).
  angle1 = (angle1 + ANG90) &gt;&gt; ANGLETOFINESHIFT;
  angle2 = (angle2 + ANG90) &gt;&gt; ANGLETOFINESHIFT;
  sx1 = viewangletox[angle1];
  sx2 = viewangletox[angle2] - 1;

  // Does not cross a pixel.
  if (sx1 &gt; sx2)
    return false;

  return ! R2_1DOcclusionTest(sx1, sx2);
}
</t>
<t tx="T730">@ face_dir is +1 for upwards (floors), -1 for downwards (ceilings).
@c

static void R2_PlaneEvent(drawfloor_t *dfloor, int x1, int x2,
    float_t h, surface_t *info, int face_dir)
{
  drawplane_t *plane;
  screenline_t *area;
  seg_t *seg;
  int vis_count;

  int x, sx, ex;
  float_t y1, y2, step, h2;

  boolean_t sky, solid, connect_low, connect_high;

  connect_low  = (face_dir &gt; 0) &amp;&amp; (!dfloor-&gt;lower);
  connect_high = (face_dir &lt; 0) &amp;&amp; (!dfloor-&gt;higher);
  
  sky = connect_high &amp;&amp; IS_SKY(*info);

  // ignore non-facing planes
  if (!sky &amp;&amp; (viewz &gt; h) != (face_dir &gt; 0))
    return;

  // ignore dud regions (dfloor &gt; ceiling)
  if (dfloor-&gt;f_h &gt; dfloor-&gt;c_h)
    return;

  // ignore invisible planes
  if (info-&gt;translucency &lt; 0.02)
    return;

  // ignore missing texture (maybe causing HOM)
  if (info-&gt;image == NULL)
    return;

  if (hom_detect)
    connect_low = connect_high = false;

  plane = R2_GetDrawPlane();
  area = &amp;plane-&gt;area;

  // setup prototype plane
  plane-&gt;next  = NULL;
  plane-&gt;h     = h;
  plane-&gt;info  = info;
  plane-&gt;props = info-&gt;override_p ? info-&gt;override_p : dfloor-&gt;props;
  plane-&gt;face_dir = face_dir;

  h -= viewz;

  // setup area
  area-&gt;x1 = x1;
  area-&gt;x2 = x2;

  area-&gt;ranges = R2_GetOpenings(x2 - x1 + 1);
  
  solid = (info-&gt;translucency &gt; 0.99) &amp;&amp; info-&gt;image-&gt;solid;

  // setup initial shape.  The connect_xxx stuff in here is for
  // flat-flooding (an old Doom trick used e.g. for deep water).

  if (face_dir &lt; 0)
  {
    for (x=x1; x &lt;= x2; x++)
    {
      area-&gt;ranges[x - x1].y1 = connect_high ? Screen_clip[x].y1 : 0;
      area-&gt;ranges[x - x1].y2 = -1;
    }
  }
  else
  {
    for (x=x1; x &lt;= x2; x++)
    {
      area-&gt;ranges[x - x1].y1 = viewheight;
      area-&gt;ranges[x - x1].y2 = connect_low ? Screen_clip[x].y2 : viewheight-1;
    }
  }
 
  vis_count=0;

  // handle sky specially (for compatibility)
  if (sky)
  {
    boolean_t double_sky;

    for (seg=cur_sub-&gt;segs; seg; seg=seg-&gt;sub_next)
    {
      if (!seg-&gt;visible || seg-&gt;back || seg-&gt;miniseg)
        continue;

      sx = MAX(x1, seg-&gt;x1);
      ex = MIN(x2, seg-&gt;x2);

      if (sx &gt; ex)
        continue;

      double_sky = (seg-&gt;backsector &amp;&amp; IS_SKY(seg-&gt;backsector-&gt;ceil));

      h2 = h;
      if (double_sky)
      {
        h2 = MIN(h2, seg-&gt;backsector-&gt;c_h - viewz);  // MAX ???
      }
      y1 = focusyfrac - h2 * seg-&gt;scale1;
      y2 = focusyfrac - h2 * seg-&gt;scale2;

      if (y1 &lt; 0 &amp;&amp; y2 &lt; 0)
        continue;

      step = (seg-&gt;x1==seg-&gt;x2) ? 0 : (y2 - y1) / (seg-&gt;x2 - seg-&gt;x1);

      vis_count++;

      y1 += step * (sx - seg-&gt;x1);

      for (x=sx; x &lt;= ex; x++, y1 += step)
      {
        int y = MIN((int)floor(y1), viewheight-1);

        if (y &lt; 0)
          continue;

        area-&gt;ranges[x - x1].y2 = y;
      }

      R2_1DOcclusionClose(sx, ex, area-&gt;ranges + (sx-x1));
      R2_2DOcclusionClose(sx, ex, area-&gt;ranges + (sx-x1), 
          false, !double_sky, false);
    }

    if (vis_count &gt; 0)
      R2_DrawPlane(cur_sub, plane);

    R2_CommitOpenings(0);
    R2_CommitDrawPlane(0);
    
    return;
  }
 
  // traverse the segs, computing the on-screen columns
  for (seg=cur_sub-&gt;segs; seg; seg=seg-&gt;sub_next)
  {
    if (!seg-&gt;visible)
      continue;
    
#if 0
    // allow vertical flooding when back equivalent to front
    if ((connect_low || connect_high) &amp;&amp; seg-&gt;miniseg)
      continue;
#endif

    sx = MAX(x1, seg-&gt;x1);
    ex = MIN(x2, seg-&gt;x2);

    if (sx &gt; ex)
      continue;

    y1 = focusyfrac - h * seg-&gt;scale1;
    y2 = focusyfrac - h * seg-&gt;scale2;

    step = (seg-&gt;x1==seg-&gt;x2) ? 0 : (y2 - y1) / (seg-&gt;x2 - seg-&gt;x1);

    // ignore parts of segs that are totally off-screen
    if (((face_dir &lt; 0) &amp;&amp; y1 &lt; 0 &amp;&amp; y2 &lt; 0) ||
        ((face_dir &gt; 0) &amp;&amp; y1 &gt;= viewheight &amp;&amp; y2 &gt;= viewheight))
    {
      continue;
    }

    vis_count++;

    y1 += step * (sx - seg-&gt;x1);

    if (face_dir &lt; 0)
    {
      if (seg-&gt;back &amp;&amp; connect_high)
        continue;

      for (x=sx; x &lt;= ex; x++, y1 += step)
      {
        int y = MIN((int)floor(y1), viewheight-1);

        if (y &lt; 0)
          continue;

        if (!seg-&gt;back)
          area-&gt;ranges[x - x1].y2 = y;
        else
          area-&gt;ranges[x - x1].y1 = y + 1;
      }
    }
    else
    {
      if (seg-&gt;back &amp;&amp; connect_low)
        continue;

      for (x=sx; x &lt;= ex; x++, y1 += step)
      {
        int y = MAX((int)floor(y1), 0);

        if (y &gt;= viewheight)
          continue;

        if (!seg-&gt;back)
          area-&gt;ranges[x - x1].y1 = y;
        else
          area-&gt;ranges[x - x1].y2 = y - 1;
      }
    }
  }
  
  // quit early if totally off-screen
  if (vis_count == 0)
  {
    R2_CommitOpenings(0);
    R2_CommitDrawPlane(0);
    return;
  }

  R2_1DOcclusionClose(x1, x2, area-&gt;ranges);
  R2_2DOcclusionClose(x1, x2, area-&gt;ranges, connect_low, connect_high, solid);

#if 0  // TEMPORARY DISABLED
  //
  // Dynamic lighting
  //
  plane-&gt;min_y = plane-&gt;max_y = -1;

  plane-&gt;extra_light[0] = 0;
  plane-&gt;extra_light[1] = 0;

  if (use_dlights &amp;&amp; ! IS_SKY(*info))
  {
    drawthing_t *dl;

    int mid_x = (x1 + x2) / 2;
    float_t dist1, dist2;
    angle_t angle;

    float_t wx[2], wy[2], wz[2];
    
    plane-&gt;min_y = SCREENHEIGHT-1;
    plane-&gt;max_y = 0;

    for (x=x1; x &lt;= x2; x++)
    {
      if (area-&gt;ranges[x - x1].y1 &gt; area-&gt;ranges[x - x1].y2)
        continue;
      
      plane-&gt;min_y = MIN(plane-&gt;min_y, area-&gt;ranges[x - x1].y1);
      plane-&gt;max_y = MAX(plane-&gt;max_y, area-&gt;ranges[x - x1].y2);
    }

    if (plane-&gt;min_y &lt;= plane-&gt;max_y)
    {
      DEV_ASSERT2(0 &lt;= plane-&gt;min_y &lt; SCREENHEIGHT);
      DEV_ASSERT2(0 &lt;= plane-&gt;max_y &lt; SCREENHEIGHT);

      // compute map coordinates for top &amp; bottom of plane

      dist1 = fabs(info-&gt;h - viewz) * yslope[plane-&gt;min_y];
      dist2 = fabs(info-&gt;h - viewz) * yslope[plane-&gt;max_y];
      angle = viewangle + xtoviewangle[mid_x];

      dist1 *= distscale[mid_x];
      dist2 *= distscale[mid_x];

      wx[0] = viewx + M_Cos(angle) * dist1;
      wy[0] = viewy + M_Sin(angle) * dist1;

      wx[1] = viewx + M_Cos(angle) * dist2;
      wy[1] = viewy + M_Sin(angle) * dist2;

      wz[0] = wz[1] = info-&gt;h;

      for (dl=dfloor-&gt;dlights; dl; dl=dl-&gt;next)
      {
        // light behind the plane ?    
        if ((dl-&gt;tz &gt; info-&gt;h) != (face_dir &gt; 0))
          continue;
       
        R2_AddDLights(2, plane-&gt;extra_light, wx, wy, wz, dl-&gt;mo);
      }
    }
  }
#endif

  // link it in
  if (connect_low || connect_high)
  {
    R2_DrawPlane(cur_sub, plane);
    R2_CommitOpenings(0);
    R2_CommitDrawPlane(0);
  }
  else
  {
    plane-&gt;next = dfloor-&gt;planes;
    dfloor-&gt;planes = plane;

    R2_CommitOpenings(x2 - x1 + 1);
    R2_CommitDrawPlane(1);
  }
}
</t>
<t tx="T731">@ R2_GetThingSprite

Can return NULL, for no image.
@c

const image_t * R2_GetThingSprite(mobj_t *mo, boolean_t *flip)
{
  spritedef_t *sprite;
  spriteframe_t *frame;

  angle_t ang;
  int rot;

  // decide which patch to use for sprite relative to player

#ifdef DEVELOPERS
  // this shouldn't happen
  if ((unsigned int)mo-&gt;sprite &gt;= (unsigned int)numsprites)
    I_Error("R2_GetThingSprite: invalid sprite number %i.\n", mo-&gt;sprite);
#endif

  sprite = sprites + mo-&gt;sprite;

  if (mo-&gt;frame &gt;= sprite-&gt;numframes ||
      !sprite-&gt;frames[mo-&gt;frame].finished)
  {
#if 1
    // -AJA- 2001/08/04: allow the patch to be missing
    (*flip) = false;
    return W_ImageForDummySprite();
#else
    // -ACB- 1998/06/29 More Informative Error Message
    I_Error("R2_GetThingSprite: Invalid sprite frame %s:%c",
        sprite-&gt;name, 'A' + mo-&gt;frame);
#endif
  }

  frame = sprite-&gt;frames + mo-&gt;frame;

  if (frame-&gt;rotated)
  {
    // choose a different rotation based on player view
    ang = R_PointToAngle(viewx, viewy, mo-&gt;x, mo-&gt;y) -
        mo-&gt;angle + ANG180 + (ANG45 / (frame-&gt;extended ? 4 : 2));
    rot = ANG_2_ROT(ang);
  }
  else
  {
    // use single rotation for all views
    rot = 0;
  }

  DEV_ASSERT2(0 &lt;= rot &amp;&amp; rot &lt; 16);

  (*flip) = frame-&gt;flip[rot] ? true : false;

  return frame-&gt;images[rot];
}
</t>
<t tx="T732">@ R2_GetOtherSprite

Used for non-object stuff, like weapons and finale.
@c

const image_t * R2_GetOtherSprite(int spritenum, int framenum, boolean_t *flip)
{
  spritedef_t *sprite;
  spriteframe_t *frame;

#ifdef DEVELOPERS
  // this shouldn't happen
  if ((unsigned int)spritenum &gt;= (unsigned int)numsprites)
    I_Error("R2_GetThingSprite: invalid sprite number %i.\n", spritenum);
#endif

  sprite = sprites + spritenum;

  if (framenum &gt;= sprite-&gt;numframes ||
      !sprite-&gt;frames[framenum].finished)
  {
#if 1
    return NULL;
#else
    // -ACB- 1998/06/29 More Informative Error Message
    I_Error("R2_GetOtherSprite: Invalid sprite frame %s:%c",
        sprite-&gt;name, 'A' + framenum);
#endif
  }

  frame = sprite-&gt;frames + framenum;

  *flip = frame-&gt;flip[0] ? true : false;

  return frame-&gt;images[0];
}
</t>
<t tx="T733">@ R2_WalkThing

Visit a single thing that exists in the current subsector.
@c

static void R2_WalkThing(mobj_t *mo)
{
  drawthing_t *dthing;
  screenline_t *area;
  
  float_t tr_x;
  float_t tr_y;

  float_t tx, tx1, tx2;
  float_t tz;

  float_t gzb, gzt;

  float_t xscale;
  float_t yscale;
  float_t dist_scale;

  int x1, x2;
  int offset = 0;

  const image_t *image;
  int sprite_height;
  int top_offset;

  boolean_t spr_flip;
  int clip_vert = 0;

  // ignore invisible things
  if (mo-&gt;visibility == INVISIBLE)
      return;

  // transform the origin point
  tr_x = mo-&gt;x - viewx;
  tr_y = mo-&gt;y - viewy;

  tz = tr_x * viewcos + tr_y * viewsin;

  // thing is behind view plane?
  if (tz &lt; MINZ)
    return;

  // -ES- 1999/03/14 Use distunit for y and x scale.
  xscale = x_distunit / tz;
  yscale = y_distunit / tz;
  dist_scale = yscale;

  tx = tr_x * viewsin - tr_y * viewcos;

  // too far off the side?
  // -ES- 1999/03/13 Fixed clipping to work with large FOVs (up to 176 deg)
  // rejects all sprites where angle&gt;176 deg (arctan 32), since those
  // sprites would result in overflow in future calculations
  if (fabs(tx) / 32 &gt; tz)
    return;
  
  image = R2_GetThingSprite(mo, &amp;spr_flip);

  if (!image)
    return;

  // calculate edges of the shape
  tx1 = tx - IM_OFFSETX(image) * mo-&gt;info-&gt;xscale;

  x1 = floor(focusxfrac + tx1 * xscale);

  // off the right side ?
  if (x1 &gt;= viewwidth)
  {
    return;
  }
  else if (x1 &lt; 0)
  {
    offset = 0 - x1;
    x1 = 0;
  }

  tx2 = tx1 + IM_WIDTH(image) * mo-&gt;info-&gt;xscale;

  x2 = floor(focusxfrac + tx2 * xscale) - 1;

  // off the left side ?
  if (x2 &lt; 0)
    return;

  x2 = MIN(x2, viewwidth-1);

  // too narrow to be seen
  if (x1 &gt; x2)
    return;

  xscale *= mo-&gt;info-&gt;xscale;
  yscale *= mo-&gt;info-&gt;yscale;

  sprite_height = IM_HEIGHT(image);
  top_offset = IM_OFFSETY(image);

  gzt = mo-&gt;z + top_offset * mo-&gt;info-&gt;yscale;
  gzb = gzt - sprite_height * mo-&gt;info-&gt;yscale;

  // fix for sprites that sit wrongly into the floor/ceiling

  if (sprite_kludge==0 &amp;&amp; gzb &lt; mo-&gt;floorz)
  {
    // explosion ?
    if (mo-&gt;info-&gt;flags &amp; MF_MISSILE)
    {
      clip_vert = +1;
    }
    else
    {
      gzt += mo-&gt;floorz - gzb;
      gzb = mo-&gt;floorz;
    }
  }
  else if (sprite_kludge==0 &amp;&amp; gzt &gt; mo-&gt;ceilingz)
  {
    // explosion ?
    if (mo-&gt;info-&gt;flags &amp; MF_MISSILE)
    {
      clip_vert = +1;
    }
    else
    {
      gzb -= gzt - mo-&gt;ceilingz;
      gzt = mo-&gt;ceilingz;
    }
  }

  if (gzb &gt;= gzt)
    return;

  // create new draw thing

  dthing = R2_GetDrawThing();
  R2_CommitDrawThing(1);

  area = &amp;dthing-&gt;area;

  dthing-&gt;mo = mo;
  dthing-&gt;clipped_left = dthing-&gt;clipped_right = false;
  dthing-&gt;props = cur_sub-&gt;floors-&gt;props;

  dthing-&gt;image  = image;
  dthing-&gt;flip   = spr_flip;
  dthing-&gt;bright = mo-&gt;bright ? true : false;
  dthing-&gt;clip_vert = clip_vert;
  dthing-&gt;is_halo = false;
  dthing-&gt;is_shadow = false;
  
  dthing-&gt;xscale = xscale;
  dthing-&gt;yscale = yscale;
  dthing-&gt;ixscale = 1.0f / xscale;
  dthing-&gt;iyscale = 1.0f / yscale;
  dthing-&gt;dist_scale = dist_scale;
  dthing-&gt;xfrac = offset * dthing-&gt;ixscale;

  dthing-&gt;tx = tx;
  dthing-&gt;tz = tz;
  dthing-&gt;tx1 = tx1;
  dthing-&gt;tx2 = tx2;

  dthing-&gt;top = gzt;
  dthing-&gt;bottom = gzb;

  // setup area.  NOTE: ranges are created later.
  area-&gt;x1 = x1;
  area-&gt;x2 = x2;
  area-&gt;ranges = NULL;  // note used for drawthings

  area-&gt;y = 0;
  area-&gt;step = 0;
  area-&gt;y_offset = 0;

  // translation support
  if (mo-&gt;info-&gt;palremap)
    dthing-&gt;trans_table = V_GetTranslationTable(mo-&gt;info-&gt;palremap);
  else
    dthing-&gt;trans_table = NULL;

  // link it in
  dthing-&gt;next = cur_sub-&gt;raw_things;
  dthing-&gt;prev = NULL;

  if (cur_sub-&gt;raw_things)
    cur_sub-&gt;raw_things-&gt;prev = dthing;

  cur_sub-&gt;raw_things = dthing;

  // create shadow
  if (level_flags.shadows &amp;&amp; mo-&gt;info-&gt;shadow_trans &gt; 0 &amp;&amp;
      mo-&gt;floorz &lt; viewz &amp;&amp; ! IS_SKY(mo-&gt;subsector-&gt;sector-&gt;floor))
  {
    drawthing_t *dshadow = R2_GetDrawThing();
    R2_CommitDrawThing(1);

    dshadow[0] = dthing[0];

    dshadow-&gt;is_shadow = true;
    dshadow-&gt;clip_vert = -1;
    dshadow-&gt;trans_table = NULL;

    // shadows are 1/4 the height
    dshadow-&gt;yscale /= 4.0;
    dshadow-&gt;iyscale *= 4.0;

    gzb = mo-&gt;floorz;
    gzt = gzb + sprite_height / 4.0 * mo-&gt;info-&gt;yscale;

    dshadow-&gt;top = gzt;
    dshadow-&gt;bottom = gzb;

    // link it in
    dshadow-&gt;next = cur_sub-&gt;raw_things;
    dshadow-&gt;prev = NULL;

    if (cur_sub-&gt;raw_things)
      cur_sub-&gt;raw_things-&gt;prev = dshadow;

    cur_sub-&gt;raw_things = dshadow;
  }
}
</t>
<t tx="T734">@ R2_ClipSpriteHorizontally

Checks to see if the sprite crosses the given clipseg. If it does,
then the current drawthing is split, and a new drawthing for the
other half is added to the corresponding drawsub. If the _whole_
drawthing was moved to the other drawsub, then `true' is returned,
otherwise returns false. Note: `dthing' must be unlinked from any
list.
@c

#define SX_FUDGE  1

static boolean_t R2_ClipSpriteHorizontally(subsector_t *dsub, 
  drawthing_t *dthing, seg_t *clipper)
{
  float_t x, dx, dz;
  int new_x;

  drawthing_t *dnew;
  subsector_t *border;

  // quick distance check
  if (MIN(clipper-&gt;tz1, clipper-&gt;tz2) &gt; dthing-&gt;tz ||
      MAX(clipper-&gt;tz1, clipper-&gt;tz2) &lt; dthing-&gt;tz)
  {
    return false;
  }

  // compute intersection point
  dx = clipper-&gt;tx2 - clipper-&gt;tx1;
  dz = clipper-&gt;tz2 - clipper-&gt;tz1;

  // dz guaranteed to be != 0 (since orientation != 0)
  DEV_ASSERT2(clipper-&gt;orientation != 0);
  CHECKVAL(dz);

  x = clipper-&gt;tx1 + (dthing-&gt;tz - clipper-&gt;tz1) * dx / dz;

  new_x = floor(focusxfrac + x * dthing-&gt;xscale / 
      dthing-&gt;mo-&gt;info-&gt;xscale);  // OPTIMISE

  // check if visible part of sprite is totally in this subsector, or
  // totally in the other subsector.  These checks also guarantee that
  // any split point is not too close to the edge.

  if ((clipper-&gt;orientation &gt; 0 &amp;&amp; new_x-SX_FUDGE &lt;= dthing-&gt;area.x1) ||
      (clipper-&gt;orientation &lt; 0 &amp;&amp; new_x+SX_FUDGE &gt;= dthing-&gt;area.x2))
  {
    return false;
  }

  border = clipper-&gt;back_sub;

  DEV_ASSERT2(border);
  DEV_ASSERT2(subsectors_seen[border - subsectors]);

  // just moving the whole sprite (no clipping) ?
  if ((clipper-&gt;orientation &gt; 0 &amp;&amp; new_x+SX_FUDGE &gt;= dthing-&gt;area.x2) ||
      (clipper-&gt;orientation &lt; 0 &amp;&amp; new_x-SX_FUDGE &lt;= dthing-&gt;area.x1))
  {
    // prevent cycling
    if (clipper-&gt;orientation &gt; 0 &amp;&amp; dthing-&gt;area.x2 &gt; new_x-SX_FUDGE)
      dthing-&gt;clipped_right = true;

    if (clipper-&gt;orientation &lt; 0 &amp;&amp; dthing-&gt;area.x1 &lt; new_x+SX_FUDGE)
      dthing-&gt;clipped_left = true;

    dthing-&gt;next = border-&gt;raw_things;
    dthing-&gt;prev = NULL;

    if (border-&gt;raw_things)
      border-&gt;raw_things-&gt;prev = dthing;

    border-&gt;raw_things = dthing;
    return true;
  }

  // OK, we need to split the sprite at the seg boundary, and put the
  // new half into the correct drawsub.  The current drawthing is
  // shortened.
  
  dnew = R2_GetDrawThing();
  R2_CommitDrawThing(1);

  dnew[0] = dthing[0];

  if (clipper-&gt;orientation &gt; 0)
  {
    // new piece is on the left side
    dthing-&gt;xfrac += (new_x - dthing-&gt;area.x1) * dthing-&gt;ixscale;
    dthing-&gt;area.x1 = new_x;
    dthing-&gt;clipped_left = true;

    dnew-&gt;area.x2 = new_x - 1;
    dnew-&gt;clipped_right = true;
  }
  else
  {
    // new piece is on the right side
    dnew-&gt;xfrac += (new_x - dnew-&gt;area.x1) * dnew-&gt;ixscale;
    dnew-&gt;area.x1 = new_x;
    dnew-&gt;clipped_left = true;

    dthing-&gt;area.x2 = new_x - 1;
    dthing-&gt;clipped_right = true;
  }

  // put new piece where it belongs

  dnew-&gt;next = border-&gt;raw_things;
  dnew-&gt;prev = NULL;

  if (border-&gt;raw_things)
    border-&gt;raw_things-&gt;prev = dnew;

  border-&gt;raw_things = dnew;
  return false;
}
</t>
<t tx="T735">
static INLINE void LinkDrawthingIntoDrawfloor(drawthing_t *dthing,
    drawfloor_t *dfloor)
{
#ifndef USE_GL
  mobj_t *mo = dthing-&gt;mo;
#endif

  dthing-&gt;props = dfloor-&gt;props;
  dthing-&gt;next  = dfloor-&gt;things;
  dthing-&gt;prev  = NULL;

  if (dfloor-&gt;things)
    dfloor-&gt;things-&gt;prev = dthing;

  dfloor-&gt;things = dthing;

  //
  // Dynamic Lighting
  //
  dthing-&gt;extra_light = 0;

#ifndef USE_GL  // GL renderer uses its own method
  if (!(mo-&gt;flags &amp; MF_FUZZY) &amp;&amp; !(dthing-&gt;is_shadow | dthing-&gt;is_halo))
  {
    drawthing_t *dl;

    float_t mid_z = MO_MIDZ(mo);

    for (dl=dfloor-&gt;dlights; dl; dl=dl-&gt;next)
    {
      if (mo == dl-&gt;mo)
        continue;

      R2_AddDLights(1, &amp;dthing-&gt;extra_light, &amp;mo-&gt;x, &amp;mo-&gt;y, &amp;mid_z, dl-&gt;mo);
    }
  }
#endif
}
</t>
<t tx="T736">@ R2_ClipSpriteVertically
@c

#define SY_FUDGE  2

void R2_ClipSpriteVertically(subsector_t *dsub, drawthing_t *dthing)
{
  drawfloor_t *dfloor, *df_orig;
  drawthing_t *dnew, *dt_orig;

  float_t z;
  float_t f1, c1;
  float_t f1_orig, c1_orig;
  
  // find the thing's nominal region.  This section is equivalent to
  // the R_PointInVertRegion() code (but using drawfloors).

  if (dthing-&gt;is_shadow)
    z = dthing-&gt;bottom + 0.5;
  else
    z = (dthing-&gt;top + dthing-&gt;bottom) / 2.0;

  for (dfloor = dsub-&gt;z_floors; dfloor-&gt;higher; dfloor = dfloor-&gt;higher)
  {
    if (z &lt;= dfloor-&gt;top_h)
      break;
  }

  DEV_ASSERT2(dfloor);

  // link in sprite.  We'll shrink it if it gets clipped.
  LinkDrawthingIntoDrawfloor(dthing, dfloor);

  // handle never-clip things 
  if (dthing-&gt;clip_vert &lt; 0)
    return;
    
  // Note that sprites are not clipped by the lowest floor or
  // highest ceiling, OR by *solid* extrafloors (even translucent
  // ones) -- UNLESS clip_vert is &gt; 0.

  f1 = dfloor-&gt;f_h;
  c1 = dfloor-&gt;c_h;

  // handle TRANSLUCENT + THICK floors (a bit of a hack)
  if (dfloor-&gt;ef &amp;&amp; dfloor-&gt;ef-&gt;ef_info &amp;&amp; dfloor-&gt;higher &amp;&amp;
      (dfloor-&gt;ef-&gt;ef_info-&gt;type &amp; EXFL_Thick) &amp;&amp;
      (dfloor-&gt;ef-&gt;top-&gt;translucency &lt;= 0.99))
  {
    c1 = dfloor-&gt;top_h;
  }

  df_orig = dfloor;
  dt_orig = dthing;
  f1_orig = f1;
  c1_orig = c1;

  // Two sections here: Downward clipping (for sprite's bottom) and
  // Upward clipping (for sprite's top).  Both use the exact same
  // algorithm:
  //     
  //    WHILE (current must be clipped)
  //    {
  //       new := COPY OF current
  //       clip both current and new to the clip height
  //       current := new
  //       floor := NEXT floor
  //       link current into floor
  //    }
 
  // ---- downward section ----

  for (;;)
  {
    if (!dfloor-&gt;lower)
      break;

    if ((dthing-&gt;bottom &gt;= f1 - SY_FUDGE) ||
        (dthing-&gt;top    &lt;  f1 + SY_FUDGE))
      break;

    DEV_ASSERT2(dfloor-&gt;lower-&gt;ef &amp;&amp; dfloor-&gt;lower-&gt;ef-&gt;ef_info);

    if (! (dfloor-&gt;lower-&gt;ef-&gt;ef_info-&gt;type &amp; EXFL_Liquid))
      break;
    
    // sprite's bottom must be clipped.  Make a copy.

    dnew = R2_GetDrawThing();
    R2_CommitDrawThing(1);

    dnew[0] = dthing[0];

    // shorten current sprite
    
    dthing-&gt;bottom = f1;
    
    DEV_ASSERT2(dthing-&gt;bottom &lt; dthing-&gt;top);

    // shorten new sprite
    
    dnew-&gt;area.y_offset += (dnew-&gt;top - f1);
    dnew-&gt;top = f1;

    DEV_ASSERT2(dnew-&gt;bottom &lt; dnew-&gt;top);

    // time to move on...

    dthing = dnew;
    dfloor = dfloor-&gt;lower;

    f1 = dfloor-&gt;f_h;
    c1 = dfloor-&gt;c_h;

    // handle TRANSLUCENT + THICK floors (a bit of a hack)
    if (dfloor-&gt;ef &amp;&amp; dfloor-&gt;ef-&gt;ef_info &amp;&amp; dfloor-&gt;higher &amp;&amp;
        (dfloor-&gt;ef-&gt;ef_info-&gt;type &amp; EXFL_Thick) &amp;&amp;
        (dfloor-&gt;ef-&gt;top-&gt;translucency &lt;= 0.99))
    {
      c1 = dfloor-&gt;top_h;
    }

    // link new piece in
    LinkDrawthingIntoDrawfloor(dthing, dfloor);
  }

  // when clip_vert is &gt; 0, we must clip to solids
  if (dthing-&gt;clip_vert &gt; 0 &amp;&amp;
      dthing-&gt;bottom &lt;  f1 - SY_FUDGE &amp;&amp;
      dthing-&gt;top    &gt;= f1 + SY_FUDGE)
  {
    // shorten current sprite
    
    dthing-&gt;bottom = f1;
    
    DEV_ASSERT2(dthing-&gt;bottom &lt; dthing-&gt;top);
  }

  dfloor = df_orig;
  dthing = dt_orig;
  f1 = f1_orig;
  c1 = c1_orig;
  
  // ---- upward section ----
  
  for (;;)
  {
    if (!dfloor-&gt;higher)
      break;

    if ((dthing-&gt;bottom &gt;= c1 - SY_FUDGE) ||
        (dthing-&gt;top    &lt;  c1 + SY_FUDGE))
      break;

    DEV_ASSERT2(dfloor-&gt;ef &amp;&amp; dfloor-&gt;ef-&gt;ef_info);

    if (! (dfloor-&gt;ef-&gt;ef_info-&gt;type &amp; EXFL_Liquid))
      break;
 
    // sprite's top must be clipped.  Make a copy.

    dnew = R2_GetDrawThing();
    R2_CommitDrawThing(1);

    dnew[0] = dthing[0];

    // shorten current sprite
    
    dthing-&gt;area.y_offset += (dthing-&gt;top - c1);
    dthing-&gt;top = c1;
    
    DEV_ASSERT2(dthing-&gt;bottom &lt; dthing-&gt;top);

    // shorten new sprite
    
    dnew-&gt;bottom = c1;

    DEV_ASSERT2(dnew-&gt;bottom &lt; dnew-&gt;top);

    // time to move on...

    dthing = dnew;
    dfloor = dfloor-&gt;higher;

    f1 = dfloor-&gt;f_h;
    c1 = dfloor-&gt;c_h;

    // handle TRANSLUCENT + THICK floors (a bit of a hack)
    if (dfloor-&gt;ef &amp;&amp; dfloor-&gt;ef-&gt;ef_info &amp;&amp; dfloor-&gt;higher &amp;&amp;
        (dfloor-&gt;ef-&gt;ef_info-&gt;type &amp; EXFL_Thick) &amp;&amp;
        (dfloor-&gt;ef-&gt;top-&gt;translucency &lt;= 0.99))
    {
      c1 = dfloor-&gt;top_h;
    }

    // link new piece in
    LinkDrawthingIntoDrawfloor(dthing, dfloor);
  }

  // when clip_vert is &gt; 0, we must clip to solids
  if (dthing-&gt;clip_vert &gt; 0 &amp;&amp;
      dthing-&gt;bottom &lt;  c1 - SY_FUDGE &amp;&amp;
      dthing-&gt;top    &gt;= c1 + SY_FUDGE)
  {
    // shorten current sprite
 
    dthing-&gt;area.y_offset += dthing-&gt;top - c1;
    dthing-&gt;top = c1;

    DEV_ASSERT2(dthing-&gt;bottom &lt; dthing-&gt;top);
  }
}
</t>
<t tx="T737">@ R2_ClipOneSprite

Checks if drawthing needs to be clipped against any clipsegs in the
drawsub, clipping the remaining part (if any) onto the appropriate
drawfloors. Note: `dthing' must be unlinked from any list.
@c

static void R2_ClipOneSprite(subsector_t *dsub, drawthing_t *dthing)
{
  seg_t *clipper;
 
  for (clipper=dsub-&gt;segs; clipper; clipper=clipper-&gt;sub_next)
  {
    // don't clip against 1-sided lines (or invisible back subs)
    if (!clipper-&gt;back_sub || 
        !subsectors_seen[clipper-&gt;back_sub - subsectors])
    {
      continue;
    }
    
    // ignore clipsegs that wouldn't be used
    if (clipper-&gt;orientation == 0 ||
       (clipper-&gt;orientation &gt; 0 &amp;&amp; dthing-&gt;clipped_left) ||
       (clipper-&gt;orientation &lt; 0 &amp;&amp; dthing-&gt;clipped_right))
    {
      continue;
    }

    if (R2_ClipSpriteHorizontally(dsub, dthing, clipper))
      return;
 
    // all clipped out ? :)
    if (dthing-&gt;clipped_left &amp;&amp; dthing-&gt;clipped_right)
      break;
  }

  // the remaining piece has now been clipped against all the
  // clipsegs.  Now clip it vertically, which stores the sprite in the
  // appropriate drawfloor(s).

  R2_ClipSpriteVertically(dsub, dthing);
}
</t>
<t tx="T738">@ R2_ClipSprites
@c

static void R2_ClipSprites(void)
{
  subsector_t *cur;
  drawthing_t *dthing;

  for (;;)
  {
    int count = 0;

    for (cur=drawsubs; cur; cur=cur-&gt;rend_next)
    {
      if (! cur-&gt;raw_things)
        continue;
      
      count++;

      while (cur-&gt;raw_things)
      {
        dthing = cur-&gt;raw_things;
        cur-&gt;raw_things = dthing-&gt;next;

        if (cur-&gt;raw_things)
          cur-&gt;raw_things-&gt;prev = NULL;

        R2_ClipOneSprite(cur, dthing);
      }
    }

    if (count == 0)
      break;
  }
}
</t>
<t tx="T739">@ R2_FindDLights
@c

void R2_FindDLights(subsector_t *sub, drawfloor_t *dfloor)
{
  int xl, xh, yl, yh;
  int bx, by;

  xl = (sub-&gt;bbox[BOXLEFT]  -bmaporgx-MAXDLIGHTRADIUS) / MAPBLOCKUNITS;
  xh = (sub-&gt;bbox[BOXRIGHT] -bmaporgx+MAXDLIGHTRADIUS) / MAPBLOCKUNITS;
  yl = (sub-&gt;bbox[BOXBOTTOM]-bmaporgy-MAXDLIGHTRADIUS) / MAPBLOCKUNITS;
  yh = (sub-&gt;bbox[BOXTOP]   -bmaporgy+MAXDLIGHTRADIUS) / MAPBLOCKUNITS;

  for (bx = xl; bx &lt;= xh; bx++)
  for (by = yl; by &lt;= yh; by++)
  {
    mobj_t *mo;
    drawthing_t *dl;

    if (bx &lt; 0 || by &lt; 0 || bx &gt;= bmapwidth || by &gt;= bmapheight)
      continue;

    for (mo=blocklights[by * bmapwidth + bx]; mo; mo = mo-&gt;dlnext)
    {
      if (! mo-&gt;bright || mo-&gt;dlight_qty &lt;= 0)
        continue;

      if (mo-&gt;ceilingz &lt;= dfloor-&gt;f_h || mo-&gt;floorz &gt;= dfloor-&gt;top_h)
      {
        continue;
      }

      dl = R2_GetDrawThing();
      R2_CommitDrawThing(1);

      dl-&gt;mo = mo;
      dl-&gt;tz = mo-&gt;z + mo-&gt;height * PERCENT_2_FLOAT(mo-&gt;info-&gt;dlight.height);
      
      dl-&gt;next = dfloor-&gt;dlights;
      dl-&gt;prev = NULL;  // NOTE: not used (singly linked)

      dfloor-&gt;dlights = dl;
    }
  }
}
</t>
<t tx="T740">
static void LightUpPlayerWeapon(player_t *p, drawfloor_t *dfloor)
{
  drawthing_t *dl;
  float_t mid_z;

  mid_z = p-&gt;mo-&gt;z + p-&gt;mo-&gt;height *
      PERCENT_2_FLOAT(p-&gt;mo-&gt;info-&gt;shotheight);

  for (dl=dfloor-&gt;dlights; dl; dl=dl-&gt;next)
  {
    R2_AddDLights(1, &amp;extra_psp_light, &amp;p-&gt;mo-&gt;x, &amp;p-&gt;mo-&gt;y,
        &amp;mid_z, dl-&gt;mo);
  }
}
</t>
<t tx="T741">

static INLINE void AddNewDrawFloor(extrafloor_t *ef,
    float_t f_h, float_t c_h, float_t top_h,
    surface_t *floor, surface_t *ceil,
    region_properties_t *props)
{
  drawfloor_t *dfloor;
  drawfloor_t *tail;

  dfloor = R2_GetDrawFloor();
  R2_CommitDrawFloor(1);

  Z_Clear(dfloor, drawfloor_t, 1);

  dfloor-&gt;f_h   = f_h;
  dfloor-&gt;c_h   = c_h;
  dfloor-&gt;top_h = top_h;
  dfloor-&gt;floor = floor;
  dfloor-&gt;ceil  = ceil;
  dfloor-&gt;ef    = ef;
  dfloor-&gt;props = props;
  
  // link it in
  // (order is very important)

  if (cur_sub-&gt;floors == NULL || f_h &gt; viewz)
  {
    // add to head
    dfloor-&gt;next = cur_sub-&gt;floors;
    dfloor-&gt;prev = NULL;

    if (cur_sub-&gt;floors)
      cur_sub-&gt;floors-&gt;prev = dfloor;

    cur_sub-&gt;floors = dfloor;
  }
  else
  {
    // add to tail
    for (tail=cur_sub-&gt;floors; tail-&gt;next; tail=tail-&gt;next)
    { /* nothing here */ }

    dfloor-&gt;next = NULL;
    dfloor-&gt;prev = tail;

    tail-&gt;next = dfloor;
  }

  // add to tail of height order list (for sprite clipping)
  for (tail=cur_sub-&gt;z_floors; tail &amp;&amp; tail-&gt;higher; tail=tail-&gt;higher)
  { /* nothing here */ }

  dfloor-&gt;higher = NULL;
  dfloor-&gt;lower = tail;

  if (tail)
    tail-&gt;higher = dfloor;
  else
    cur_sub-&gt;z_floors = dfloor;

  if (use_dlights &amp;&amp; blocklights)
  {
    R2_FindDLights(cur_sub, dfloor);

    if (cur_sub == viewsubsector &amp;&amp; f_h &lt;= viewz &amp;&amp; viewz &lt;= c_h)
      LightUpPlayerWeapon(consoleplayer, dfloor);
  }
}
</t>
<t tx="T742">@ R2_WalkSubsector

Visit a subsector, and collect information, such as where the
walls, planes (ceilings &amp; floors) and things need to be drawn.
@c

static void R2_WalkSubsector(int num)
{
  mobj_t *mo;
  seg_t *seg;
  sector_t *sector;
  surface_t *floor_s;
  float_t floor_h;

  extrafloor_t *S, *L, *C;

  drawfloor_t *dfloor;

#if (DEBUG &gt;= 1)
    L_WriteDebug("\nVISITING SUBSEC %d\n\n", num);
#endif

  subsectors_seen[num] = 1;

  cur_sub = subsectors + num;
  sector = cur_sub-&gt;sector;

  cur_sub-&gt;ranges = NULL;
  cur_sub-&gt;floors = cur_sub-&gt;z_floors = NULL;
  cur_sub-&gt;raw_things = NULL;

  // add in each extrafloor, traversing strictly upwards

  floor_s = &amp;sector-&gt;floor;
  floor_h = sector-&gt;f_h;

  S = sector-&gt;bottom_ef;
  L = sector-&gt;bottom_liq;

  while (S || L)
  {
    if (!L || (S &amp;&amp; S-&gt;bottom_h &lt; L-&gt;bottom_h))
    {
      C = S;  S = S-&gt;higher;
    }
    else
    {
      C = L;  L = L-&gt;higher;
    }

    DEV_ASSERT2(C);

    // ignore liquids in the middle of THICK solids, or below real
    // floor or above real ceiling
    //
    if (C-&gt;bottom_h &lt; floor_h || C-&gt;bottom_h &gt; sector-&gt;c_h)
      continue;
    
    AddNewDrawFloor(C, floor_h, C-&gt;bottom_h, C-&gt;top_h, floor_s, C-&gt;bottom, C-&gt;p);

    floor_s = C-&gt;top;
    floor_h = C-&gt;top_h;
  }

  AddNewDrawFloor(NULL, floor_h, sector-&gt;c_h, sector-&gt;c_h, 
      floor_s, &amp;sector-&gt;ceil, sector-&gt;p);
 
#if (DEBUG &gt;= 1)
  L_WriteDebug("\nANALYSING SUBSEC %d\n\n", num);
#endif

  cur_x_min = viewwidth-1;
  cur_x_max = 0;

  // first pass over segs.  Used to determine all back-facing segs
  // (for planes) and other non-visible segs.  Also computes the width
  // of the subsector (cur_x_min..cur_x_max), as well as clipping info
  // for sprites.  Does NOT do any drawing or update the 1D/2D
  // buffers.
 
  for (seg=cur_sub-&gt;segs; seg; seg=seg-&gt;sub_next)
  {
    R2_WalkSeg(seg);
  }

  if (cur_x_min &gt; cur_x_max)
    return;

  // remember the occlusion buffer, so we can clip sprites later
  
  cur_sub-&gt;x_min = cur_x_min;
  cur_sub-&gt;x_max = cur_x_max;
  cur_sub-&gt;ranges = R2_GetOpenings(cur_x_max - cur_x_min + 1);

  R2_CommitOpenings(cur_x_max - cur_x_min + 1);
  R2_2DOcclusionCopy(cur_x_min, cur_x_max, cur_sub-&gt;ranges);

  cur_sub-&gt;clip_left = (cur_x_min &lt;= 0 ||
      R2_1DOcclusionTest(cur_x_min-1, cur_x_min-1));
  cur_sub-&gt;clip_right = (cur_x_max &gt;= viewwidth-1 ||
      R2_1DOcclusionTest(cur_x_max+1, cur_x_max+1));

  // handle each sprite in the subsector.
  // This must be done before segs, since the wall/plane code will
  // update the 1D/2D occlusion buffers.
  
  for (mo=cur_sub-&gt;thinglist; mo; mo=mo-&gt;snext)
  {
    R2_WalkThing(mo);
  }

  // now handle the planes in each floor.  Extrafloor planes use the
  // back-facing seg information, whereas the lowest floor / highest
  // ceiling can rely on the floor/ceiling clip values (i.e. just like
  // in the old Doom renderer -- and as an added bonus :) the old
  // flat-flooding trick should work again).  E.F planes are stored,
  // but the lowest F / highest C can be drawn immediately (updating
  // the 1D/2D buffers as they go).
  //
  // NOTE: traversal must go from closest plane to furthest plane
  // (from the viewheight) for correct updating of the 1D/2D buffers.
 
  if (cur_sub-&gt;floors)
  {
    for (dfloor=cur_sub-&gt;floors; dfloor-&gt;next; dfloor=dfloor-&gt;next)
    { /* nothing */ }

    for (; dfloor; dfloor=dfloor-&gt;prev)
    {
      R2_PlaneEvent(dfloor, cur_x_min, cur_x_max, dfloor-&gt;c_h, dfloor-&gt;ceil,  -1);
      R2_PlaneEvent(dfloor, cur_x_min, cur_x_max, dfloor-&gt;f_h, dfloor-&gt;floor, +1);
    }
  }

  // second pass over segs.  Draw certain solid stuff (e.g. one-sided
  // walls), updating the 1D and 2D occlusion buffers.  Add the rest
  // (like midmasked textures) to the drawing lists to draw later.
 
  for (seg=cur_sub-&gt;segs; seg; seg=seg-&gt;sub_next)
  {
    if (!seg-&gt;miniseg &amp;&amp; seg-&gt;visible &amp;&amp; !seg-&gt;back)
      R2_WalkWall(seg);
  }

  // update 1D buffer wherever the 2D buffer closed up
  R2_2DUpdate1D(cur_x_min, cur_x_max);
 
  // add drawsub to list
  // (add to head, thus the eventual order is furthest -&gt; closest)
  
  cur_sub-&gt;rend_next = drawsubs;
  drawsubs = cur_sub;
}
</t>
<t tx="T743">@ R2_WalkBSPNode

Walks all subsectors below a given node, traversing subtree
recursively, collecting information. Just call with BSP root.
@c

static void R2_WalkBSPNode(int bspnum)
{
  node_t *node;
  int side;

  // Found a subsector?
  if (bspnum &amp; NF_SUBSECTOR)
  {
    R2_WalkSubsector(bspnum &amp; (~NF_SUBSECTOR));
    return;
  }

  node = &amp;nodes[bspnum];

  // Decide which side the view point is on.
  side = P_PointOnDivlineSide(viewx, viewy, &amp;node-&gt;div);

#if (DEBUG &gt;= 2)
    L_WriteDebug("NODE %d (%1.1f, %1.1f) -&gt; (%1.1f, %1.1f)  SIDE %d\n",
        bspnum, node-&gt;div.x, node-&gt;div.y, node-&gt;div.x +
        node-&gt;div.dx, node-&gt;div.y + node-&gt;div.dy, side);
#endif

  // Recursively divide front space.
  if (R2_CheckBBox(node-&gt;bbox[side]))
    R2_WalkBSPNode(node-&gt;children[side]);

  // Recursively divide back space.
  if (R2_CheckBBox(node-&gt;bbox[side ^ 1]))
    R2_WalkBSPNode(node-&gt;children[side ^ 1]);
}
</t>
<t tx="T744">@ R2_RenderTrueBSP

True BSP rendering. Initialises all structures, then walks the BSP
tree collecting information and drawing solid walls and outermost
planes, then renders the remaining stuff in each subsector (sprites
and extrafloors) from back to front.
@c

void R2_RenderTrueBSP(void)
{
  subsector_t *cur;
  
  // initialise
  R2_ClearBSP();
  R2_1DOcclusionClear(0, viewwidth-1);
  R2_2DOcclusionClear(0, viewwidth-1);
  R_InitSkyMap();
  
  extra_psp_light = 0;

  drawsubs = NULL;

  if (hom_detect)
  {
    V_DrawBox(main_scr, viewwindowx, viewwindowy, 
        viewwindowwidth, viewwindowheight, pal_green);
  }

  // walk the bsp tree
  R2_WalkBSPNode(root_node);

  R2_ClipSprites();

  // draw all the stored stuff
  for (cur=drawsubs; cur; cur=cur-&gt;rend_next)
  {
    R2_DrawSubsector(cur);
  }

#if (DEBUG &gt; 0)
    L_WriteDebug("\n--------------------------------\n\n");
#endif
}
</t>
<t tx="T745">@ignore
@language c

// True BSP Rendering (Drawing code)

// -AJA- 1999/08/31: Wrote this file.
//
// TODO HERE:
//   + R2_DrawPSprite: clean up.
//   - implement Fuzzy_MIP column and HoleyTrans span drawers.
//   - WALL SKEW is wrong when image_t is scaled.
//   - FLOOR ALIGNMENT is wrong when image_t is scaled.

&lt;&lt; r2_draw #includes &gt;&gt;
&lt;&lt; r2_draw declarations &gt;&gt;
@others



</t>
<t tx="T746">#include "i_defs.h"

#include "dm_state.h"
#include "m_inline.h"
#include "m_swap.h"
#include "e_search.h"
#include "r_data.h"
#include "r_defs.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_sky.h"
#include "r_state.h"
#include "r_things.h"
#include "v_colour.h"
#include "v_res.h"
#include "v_ctx.h"
#include "w_image.h"
#include "w_wad.h"
#include "w_textur.h"
#include "z_zone.h"

#include "r2_defs.h"
#include "r_draw1.h"
</t>
<t tx="T747">#define SHOW_WALLS   2
#define SHOW_PLANES  2
#define SHOW_THINGS  2
#define SHOW_SKY     2
#define SHOW_WEAPON  2

#define SHOW_OVERDRAW  0
#define SHOW_FIRST_IN  0

static void R2_DrawSkyPlane(drawplane_t *plane);

// FIXME:
extern float_t basexscale;
extern float_t baseyscale;
</t>
<t tx="T748">#if (SHOW_WALLS&lt;2 || SHOW_PLANES&lt;2 || SHOW_THINGS&lt;2 || SHOW_SKY&lt;2 || SHOW_WEAPON&lt;2)

// Temporary routine
static void BOGUS_Column16(screen_t * scr, int x, int y, int h, int col)
{
  short *dest;

  x += viewwindowx;
  y += viewwindowy;

  dest = (short *)(scr-&gt;data + y * scr-&gt;pitch) + x;

  for (; h &gt; 0; h--)
  {
      dest[0] = col;
      dest += scr-&gt;pitch / 2;
  }
}
</t>
<t tx="T749">@ Temporary routine
@c

static void BOGUS_Column(screen_t * scr, int x, int y, int h, int col)
{
  byte *dest;

  if (BPP == 2)
  {
    BOGUS_Column16(scr, x, y, h, pixel_values[col &amp; 0xFF]);
    return;
  }
  else if (BPP != 1)
    return;

  x += viewwindowx;
  y += viewwindowy;

  dest = scr-&gt;data + y * scr-&gt;pitch + x;

  for (; h &gt; 0; h--, dest += scr-&gt;pitch)
  {
#if SHOW_OVERDRAW
    if (col &gt; 5 &amp;&amp; *dest != 1) 
    {
      if (SHOW_FIRST_IN)
        *dest = col;
      else if (*dest &gt;= 192)
        *dest += 2;
      else
        *dest = 192;
    }
    else 
#endif
      *dest = col;
  }
}
</t>
<t tx="T750">static void BOGUS_DrawArea(screenline_t *area, int col)
{
  int x, y1, y2;

  for (x=area-&gt;x1; x &lt;= area-&gt;x2; x++)
  {
    if (x &lt; 0 || x &gt;= viewwidth)
      continue;

    y1 = area-&gt;ranges[x - area-&gt;x1].y1;
    y2 = area-&gt;ranges[x - area-&gt;x1].y2;

    y1 = MAX(y1, 0);
    y2 = MIN(y2, viewheight-1);

    if (y1 &gt; y2)
      continue;

    BOGUS_Column(main_scr, x, y1, y2-y1+1, col);
  }
}
</t>
<t tx="T751">#endif

//
// R2_DrawMaskedWPost
//
// Render a single column of a texture with transparent parts.  Used
// for both sprites and mid-masked textures on 2S lines.
//
static float_t mask_top;
static float_t mask_scale;
static float_t mask_yl;
static float_t mask_yh;
static float_t mask_translucency;

static void R2_DrawMaskedWPost(const w_post_t * column)
{
  int yp;

  float_t raw_yl;
  float_t raw_yh;
  float_t raw_top;

  CHECKVAL(mask_scale);
  dc_ystep = M_FloatToFixed(1.0 / mask_scale) - 1;
  dc_translucency = M_FloatToFixed(mask_translucency);

  // handle each post in turn
  for (yp=0; WPOST_SKIP(column) != P_SENTINEL; column=WPOST_NEXT(column))
  {
    // calculate unclipped screen coordinates for post
    yp += WPOST_SKIP(column);
    raw_yl = mask_top + yp * mask_scale;
    raw_top = raw_yl;

    yp += WPOST_LEN(column);
    raw_yh = mask_top + yp * mask_scale;

    // clip post to given area (which must lie within the screen)
    if (raw_yl &lt; mask_yl)
      raw_yl = mask_yl;

    if (raw_yh &gt; mask_yh+1)
      raw_yh = mask_yh+1;

    dc_yl = floor(raw_yl);
    dc_yh = floor(raw_yh) - 1;

    if (dc_yh &gt;= dc_yl)
    {
      dc_source = WPOST_DATA(column);
      dc_yfrac = FLOAT_2_FIX((dc_yl + 1 - raw_top) / mask_scale);

      (* colfunc)();
    }
  }
}
</t>
<t tx="T752">
static float_t wall_scale_x;
static float_t wall_scale_y;
static int wall_base_lite;
static int wall_curlightlev;

static struct
{
  int mip;
  const cached_image_t *cim;
}
wall_image_cache;

static void R2_MapWallColumn(drawwall_t *wall, int x, int offset,
    fixed_t texcol, fixed_t texcol_next, int y1, int y2)
{
  float_t yt, yp, scale;

  int lightlev, lightdist;
  int column;

  const cached_image_t *cim;
  const byte *cim_block = NULL;
  int mip;

  mip = 0;

  if (use_mipmapping &amp;&amp; ! wall-&gt;is_masked)
  {
    fixed_t tmp_ystep, tmp_zstep, tmp_step;

    tmp_zstep = ABS(texcol_next - texcol);

    scale = wall-&gt;scale1 + (x - wall-&gt;area.x1) * wall-&gt;scale_step;
    scale *= wall_scale_y * wall-&gt;part-&gt;y_mat.y;

    CHECKVAL(scale);

    tmp_ystep = FLOAT_2_FIX(1.0 / ABS(scale));
    tmp_step = MAX(tmp_ystep, tmp_zstep);

    for (; tmp_step &gt; FRACSQRT2; tmp_step &gt;&gt;= 1)
      mip++;

    // make sure that mip values don't *decrease* as we go along the
    // wall.  The column drawing order should guarantee increases.
    mip = MAX(mip, wall_image_cache.mip);
  }

  dc_width  = MIP_SIZE(wall-&gt;part-&gt;image-&gt;total_w, mip);
  dc_height = MIP_SIZE(wall-&gt;part-&gt;image-&gt;total_h, mip);

  // see if this image (at this mip) is in the cache
  if (wall_image_cache.cim &amp;&amp; mip == wall_image_cache.mip)
  {
    cim = wall_image_cache.cim;
  }
  else
  {
    if (wall_image_cache.cim)
      W_ImageDone(wall_image_cache.cim);

    cim = W_ImageCache(wall-&gt;part-&gt;image, 
        wall-&gt;is_masked ? IMG_Post : IMG_Block, mip, true);

    wall_image_cache.cim = cim;
    wall_image_cache.mip = mip;
  }

  if (! wall-&gt;is_masked)
    cim_block = W_ImageGetBlock(cim);
  
  // ------ //
  
  dc_x  = x;
  dc_yl = y1;
  dc_yh = y2;

  if (dc_yh &lt; dc_yl || dc_yh &lt; 0 || dc_yl &gt;= viewheight)
    return;

  if (dc_yl &lt; 0)
    dc_yl = 0;

  if (dc_yh &gt;= viewheight) 
    dc_yh = viewheight-1;

  yt = wall-&gt;area.y + offset * wall-&gt;area.step;
  yp = wall-&gt;area.y_offset;
  
  scale = wall-&gt;scale1 + offset * wall-&gt;scale_step;
  CHECKVAL(scale);
  CHECKVAL(y_distunit);

  lightdist = (int) (scale * 160.0 * 16.0 / y_distunit);
  lightdist = MIN(MAXLIGHTSCALE-1, lightdist);

  // skew support
  yp += (FIX_2_FLOAT(texcol) - wall-&gt;part-&gt;offset.x) * wall-&gt;part-&gt;y_mat.x;
  
  // scale support
  scale *= wall_scale_y * wall-&gt;part-&gt;y_mat.y;
  yp    /= wall_scale_y * wall-&gt;part-&gt;y_mat.y;

  column = texcol &gt;&gt; FRACBITS;

  // determine colourmap

  lightlev = wall_base_lite;

  DEV_ASSERT2(currentmap);
  if (currentmap-&gt;lighting &lt;= LMODEL_Doomish)
  {
    lightlev = scalelight[lightlev &gt;&gt; LIGHTSEGSHIFT][lightdist];
  }
  
#if 0  // DLIGHT stuff
  lightlev += e_lite_0 + e_lite_diff * offset / width;
#endif
  lightlev = MIN(255, MAX(0, lightlev));

  if (lightlev != wall_curlightlev)
  {
    wall_curlightlev = lightlev;
    dc_colourmap = V_GetColtable(wall-&gt;props-&gt;colourmap, lightlev, 0);
  }

  if (! wall-&gt;is_masked)
  {
    CHECKVAL(scale);

    dc_ystep = FLOAT_2_FIX(1.0 / scale);
    dc_yfrac = FLOAT_2_FIX((dc_yl + 1 - yt) / scale + yp);

    dc_yfrac /= (wall-&gt;part-&gt;image-&gt;total_h / dc_height);
    dc_ystep /= (wall-&gt;part-&gt;image-&gt;total_h / dc_height);

    column &amp;= (wall-&gt;part-&gt;image-&gt;total_w - 1);
    column /= (wall-&gt;part-&gt;image-&gt;total_w / dc_width);
    
    dc_source = cim_block + dc_height * column;

    // -AJA- screen coords are now absolute
    dc_x  += viewwindowx;
    dc_yl += viewwindowy;
    dc_yh += viewwindowy;

    (* colfunc)();
  }
  else
  {
    const w_post_t *cim_col;

    if (wall-&gt;slide_type != SLIDE_None || (wall-&gt;seg &amp;&amp; 
        wall-&gt;seg-&gt;linedef &amp;&amp; wall-&gt;seg-&gt;linedef-&gt;special &amp;&amp; 
        wall-&gt;seg-&gt;linedef-&gt;special-&gt;s.type != SLIDE_None))
    {
      if (wall-&gt;side == 1)
        column = wall-&gt;line_len - column;
    }

    if (wall-&gt;slide_type == SLIDE_Right)
    {
      column -= floor(wall-&gt;opening);
      if (column &lt; 0)
        return;
    }
    else if (wall-&gt;slide_type == SLIDE_Left)
    {
      column += floor(wall-&gt;opening);
      if (column &gt; wall-&gt;line_len)
        return;
    }
    else if (wall-&gt;slide_type == SLIDE_Center)
    {
      float_t pos1 = (wall-&gt;line_len - wall-&gt;opening) / 2;
      float_t pos2 = (wall-&gt;line_len + wall-&gt;opening) / 2;

      if (pos1 &lt;= column &amp;&amp; column &lt;= pos2)
        return;
      
      if (column &lt; pos1)
        column += wall-&gt;opening/2;
      else
        column -= wall-&gt;opening/2;
    }

    // -AJA- screen coords are now absolute
    dc_x  += viewwindowx;
    dc_yl += viewwindowy;
    dc_yh += viewwindowy;

    mask_yl = (float_t) dc_yl;
    mask_yh = (float_t) dc_yh;
    mask_scale = scale;
    mask_top = yt + viewwindowy - yp * mask_scale;

    cim_col = W_ImageGetPost(cim, column);

    if (cim_col)
      R2_DrawMaskedWPost(cim_col);
  }
}
</t>
<t tx="T753">@ Render a single wall of a subsector.
@c

void R2_DrawWall(subsector_t *dsub, drawwall_t *wall)
{
#if (SHOW_WALLS == 2)
  int x;
  int x_start, x_end, x_step;
  int offset;
  int width;

  float_t xp;
  int e_lite_0, e_lite_diff;
  fixed_t texcol1, texcol2;

  angle_t angle;

  wall_base_lite = wall-&gt;props-&gt;lightlevel;

  DEV_ASSERT2(currentmap);
  if (currentmap-&gt;lighting == LMODEL_Doom)
  {
    if (wall-&gt;seg-&gt;v1-&gt;y == wall-&gt;seg-&gt;v2-&gt;y)
      wall_base_lite += 8;
    else if (wall-&gt;seg-&gt;v1-&gt;x == wall-&gt;seg-&gt;v2-&gt;x)
      wall_base_lite -= 8;
    
    wall_base_lite = MAX(0, MIN(255, wall_base_lite));
  }
  
  mask_translucency = 1.0;
  colfunc = R_DrawColumn_MIP;

  if (wall-&gt;part-&gt;translucency &lt;= 0.99 &amp;&amp; level_flags.trans)
  {
    colfunc = R_DrawTranslucentColumn_MIP;
    mask_translucency = wall-&gt;part-&gt;translucency;
    dc_translucency = FLOAT_2_FIX(mask_translucency);
  }

  DEV_ASSERT2(wall-&gt;area.x1 &lt;= wall-&gt;area.x2);

  // draw columns Left-&gt;Right to ensure increasing distance
  if (wall-&gt;seg-&gt;scale1 &lt; wall-&gt;seg-&gt;scale2)
  {
    x_start = wall-&gt;area.x2;
    x_end   = wall-&gt;area.x1 - 1;
    x_step  = -1;
  }
  else
  {
    x_start = wall-&gt;area.x1;
    x_end   = wall-&gt;area.x2 + 1;
    x_step  = +1;
  }

  // calculate initial texture column
  xp = wall-&gt;x_offset;
  angle = viewangle - wall-&gt;angle + xtoviewangle[x_start] - ANG90;

  if (! (ANG90-ANG1  &lt;= angle &amp;&amp; angle &lt;= ANG90+ANG1) &amp;&amp;
      ! (ANG270-ANG1 &lt;= angle &amp;&amp; angle &lt;= ANG270+ANG1))
  {
    xp -= M_Tan(angle) * wall-&gt;distance;
  }

  wall_scale_x = (float_t)0x0100 / wall-&gt;part-&gt;image-&gt;scale_x;
  wall_scale_y = (float_t)0x0100 / wall-&gt;part-&gt;image-&gt;scale_y;

  CHECKVAL(wall-&gt;part-&gt;x_mat.x);
  texcol1 = M_FloatToFixed(xp / wall_scale_x / wall-&gt;part-&gt;x_mat.x);

  wall_curlightlev = -999;
  e_lite_0    = wall-&gt;extra_light[0];
  e_lite_diff = wall-&gt;extra_light[1] - e_lite_0;
  width = wall-&gt;area.x2 - wall-&gt;area.x1 + 1;

  wall_image_cache.cim = NULL;
  wall_image_cache.mip = 0;

  // --- draw the columns ---
  
  for (x = x_start; x != x_end; x += x_step, texcol1=texcol2)
  {
    offset = x - wall-&gt;area.x1;

    // calculate _next_ texture column
    // NOTE: assumes xtoviewangle[] array is 1 bigger than screen
    xp = wall-&gt;x_offset;
    angle = viewangle - wall-&gt;angle + xtoviewangle[x+x_step] - ANG90;

    if (! (ANG90-ANG1  &lt;= angle &amp;&amp; angle &lt;= ANG90+ANG1) &amp;&amp;
        ! (ANG270-ANG1 &lt;= angle &amp;&amp; angle &lt;= ANG270+ANG1))
    {
      xp -= M_Tan(angle) * wall-&gt;distance;
    }

    texcol2 = M_FloatToFixed(xp / wall_scale_x / wall-&gt;part-&gt;x_mat.x);

    R2_MapWallColumn(wall, x, offset, texcol1, texcol2,
        wall-&gt;area.ranges[offset].y1, wall-&gt;area.ranges[offset].y2);
  }

  if (wall_image_cache.cim)
    W_ImageDone(wall_image_cache.cim);

#elif (SHOW_WALLS == 1)
  BOGUS_DrawArea(&amp;wall-&gt;area, 
      BROWN + BROWN_LEN * (255 - wall-&gt;props-&gt;lightlevel) / 256);
#endif /* SHOW_WALLS */
}
</t>
<t tx="T754">static const colourmap_t *plane_colourmap;
static surface_t *plane_data;
static float_t plane_h;
static float_t plane_translucency;
static int plane_base_light;
static int plane_cur_light;

static struct
{
  int mip;
  const cached_image_t *cim;
  const byte *block;
}
plane_image_cache[2];

static void R2_MapPlaneRow(drawplane_t *p, int cach_num, 
    int y, int x1, int x2)
{
  angle_t angle;
  float_t distance;
  float_t length;
  float_t SCL = 1.0;  //!!!! FIXME: 64.0 / plane_data-&gt;scale;
  float_t dx, dy;
  float_t scale_x, scale_y;
  int lightlev, lightdist;
  int index;
#if 0  // DLIGHT stuff
  int e_lite_0, e_lite_diff;
#endif

  const cached_image_t *cim;
  int mip;

#ifdef DEVELOPERS
  if (x2 &lt; x1 || x1 &lt; 0 || x2 &gt;= viewwidth || y &lt; 0 || y &gt;= viewheight)
    I_Error("R2_MapPlaneRow: y=%d x=%d..%d", y, x1, x2);
#endif

  scale_x = (float_t)0x0100 / plane_data-&gt;image-&gt;scale_x;
  scale_y = (float_t)0x0100 / plane_data-&gt;image-&gt;scale_y;

  distance = fabs(plane_h - viewz) * yslope[y];
  length = distance * distscale[x1];
  angle = viewangle + xtoviewangle[x1];

  mip = 0;

  if (use_mipmapping)
  {
    int y2;
    float_t dist_next;
    fixed_t tmp_xstep, tmp_zstep, tmp_step;

    DEV_ASSERT2(0 &lt;= y &amp;&amp; y &lt; SCREENHEIGHT);

    // compute tmp_zstep, which is the maximum distance in texture
    // space that we stepping from this span to the next one.
    if (plane_h &lt; viewz)
      y2 = MIN(y+1, SCREENHEIGHT-1);
    else
      y2 = MAX(y-1, 0);

    dist_next = fabs(plane_h - viewz) * yslope[y2];

    tmp_xstep = M_FloatToFixed(ABS(distance * SCL / x_distunit));
    tmp_zstep = M_FloatToFixed(ABS(distance - dist_next) * SCL);
    tmp_step = MAX(tmp_xstep, tmp_zstep);

    for (; tmp_step &gt; FRACSQRT2; tmp_step &gt;&gt;= 1)
      mip++;
  }

  ds_width  = MIP_SIZE(plane_data-&gt;image-&gt;total_w, mip);
  ds_height = MIP_SIZE(plane_data-&gt;image-&gt;total_h, mip);

  // see if this image (at this mip) is in the cache
  if (plane_image_cache[cach_num].cim &amp;&amp; mip ==
      plane_image_cache[cach_num].mip)
  {
    cim = plane_image_cache[cach_num].cim;
    ds_source = plane_image_cache[cach_num].block;
  }
  else if (plane_image_cache[cach_num ^ 1].cim &amp;&amp; mip ==
      plane_image_cache[cach_num ^ 1].mip)
  {
    cim = plane_image_cache[cach_num ^ 1].cim;
    ds_source = plane_image_cache[cach_num ^ 1].block;
  }
  else
  {
    if (plane_image_cache[cach_num].cim)
      W_ImageDone(plane_image_cache[cach_num].cim);

    cim = W_ImageCache(plane_data-&gt;image, IMG_Block, mip, true);
    ds_source = W_ImageGetBlock(cim);

    plane_image_cache[cach_num].cim = cim;
    plane_image_cache[cach_num].mip = mip;
    plane_image_cache[cach_num].block = ds_source;
  }

  ds_y  = y;
  ds_x1 = x1;
  ds_x2 = x2;

  ds_xstep = M_FloatToFixed(distance * SCL / scale_x * basexscale);
  ds_ystep = M_FloatToFixed(distance * SCL / scale_y * baseyscale);

  // -AJA- 1999/07/16: Add offsets (thanks Lee).
  // -AJA- NB: Using M_Cos/M_Sin here really slows things down.

  dx = FIX_2_FLOAT(finecosine[angle &gt;&gt; ANGLETOFINESHIFT]) * length;
  dy = FIX_2_FLOAT(finesine  [angle &gt;&gt; ANGLETOFINESHIFT]) * length;
 
  // FIXME: clean up !!!
  { 
    float_t tx = viewx + plane_data-&gt;offset.x + dx;
    float_t ty = viewy + plane_data-&gt;offset.y + dy;

    dx = tx ; //!!!! * M_Cos(plane_data-&gt;angle) + ty * M_Sin(plane_data-&gt;angle);
    dy = ty ; //!!!! * M_Cos(plane_data-&gt;angle) - tx * M_Sin(plane_data-&gt;angle);
  }
  
  // Doom flats are inverted W.R.T. the Y coordinate
  ds_xfrac =  M_FloatToFixed(dx * SCL / scale_x);
  ds_yfrac = -M_FloatToFixed(dy * SCL / scale_y);

  lightlev = plane_base_light;
  
  DEV_ASSERT2(currentmap);
  if (currentmap-&gt;lighting &lt;= LMODEL_Doomish)
  {
    index = 1 &lt;&lt; (LIGHTZSHIFT - FRACBITS);
    CHECKVAL(index);

    lightdist = distance / index;
    lightdist = MAX(0, MIN(MAXLIGHTZ-1, lightdist));
    
    lightlev = zlight[lightlev &gt;&gt; LIGHTSEGSHIFT][lightdist];
  }

#if 0  // DLIGHT stuff, disabled for now
  if (use_dlights &amp;&amp; p-&gt;min_y &gt;= 0)
  {
    int offset = y - p-&gt;min_y;
    int height = p-&gt;max_y - p-&gt;min_y + 1;

    DEV_ASSERT2(0 &lt;= offset &amp;&amp; offset &lt; height);

    e_lite_0    = p-&gt;extra_light[0];
    e_lite_diff = p-&gt;extra_light[1] - e_lite_0;

    lightlev += (e_lite_0 + e_lite_diff * offset / height);
    lightlev = MAX(0, MIN(255, lightlev));
  }
#endif

  if (lightlev != plane_cur_light)
  {
    plane_cur_light = lightlev;
    ds_colourmap = V_GetColtable(plane_colourmap, lightlev, 0);
  }

  ds_xfrac /= (plane_data-&gt;image-&gt;total_w / ds_width);
  ds_xstep /= (plane_data-&gt;image-&gt;total_w / ds_width);

  ds_yfrac /= (plane_data-&gt;image-&gt;total_h / ds_height);
  ds_ystep /= (plane_data-&gt;image-&gt;total_h / ds_height);

  // -AJA- screen coords are now absolute
  ds_y  += viewwindowy;
  ds_x1 += viewwindowx;
  ds_x2 += viewwindowx;

  (* spanfunc)();
}

</t>
<t tx="T755">static INLINE void R2_MakeSpans(drawplane_t *p, 
    int x, int t1, int b1, int t2, int b2)
{
  for (; t1 &lt; t2 &amp;&amp; t1 &lt;= b1; t1++)
    R2_MapPlaneRow(p, 0, t1, spanstart[t1], x-1);

  for (; b1 &gt; b2 &amp;&amp; t1 &lt;= b1; b1--)
    R2_MapPlaneRow(p, 1, b1, spanstart[b1], x-1);

  for (; t2 &lt; t1 &amp;&amp; t2 &lt;= b2; t2++)
    spanstart[t2] = x;

  for (; b2 &gt; b1 &amp;&amp; t2 &lt;= b2; b2--)
    spanstart[b2] = x;
}
</t>
<t tx="T756">@ Render a single plane of a subsector.
@c

void R2_DrawPlane(subsector_t *dsub, drawplane_t *plane)
{
#if (SHOW_PLANES == 2)
  int x;
  int L_yt = 9999, L_yb = 0;
  int R_yt, R_yb;

  if (IS_SKY(plane-&gt;info[0]))
  {
    R2_DrawSkyPlane(plane);
    return;
  }

  plane_h = plane-&gt;h;
  plane_data = plane-&gt;info;
  plane_translucency = plane_data-&gt;translucency;

  if (plane_translucency &lt; 0.02)
    // transparent
    return;

  dc_translucency = FLOAT_2_FIX(plane_translucency);

  plane_cur_light = -999;
  plane_base_light = plane-&gt;props-&gt;lightlevel;
  plane_colourmap = plane-&gt;props-&gt;colourmap;
  
  plane_image_cache[0].cim = NULL;
  plane_image_cache[1].cim = NULL;
 
  // choose the appropriate span function
  if (! plane_data-&gt;image-&gt;solid)
    spanfunc = R_DrawHoleySpan_MIP;
  else if (plane_translucency &lt;= 0.99 &amp;&amp; level_flags.trans)
    spanfunc = R_DrawTranslucentSpan_MIP;
  else
    spanfunc = R_DrawSpan_MIP;

  basexscale =  M_Cos(viewangle - ANG90 /* !!!! - plane_data-&gt;angle */) / x_distunit;
  baseyscale = -M_Sin(viewangle - ANG90 /* !!!! - plane_data-&gt;angle */) / x_distunit;

  // draw the spans
  for (x = plane-&gt;area.x1; x &lt;= plane-&gt;area.x2; x++)
  {
    int offset = x - plane-&gt;area.x1;

    R_yt = plane-&gt;area.ranges[offset].y1;
    R_yb = plane-&gt;area.ranges[offset].y2;

    if (R_yt &lt; 0)
      R_yt = 0;

    if (R_yb &gt;= viewheight)
      R_yb = viewheight-1;

    if (R_yt &gt; R_yb)
    {
      R_yt = 9999;
      R_yb = 0;
    }
    
    R2_MakeSpans(plane, x, L_yt, L_yb, R_yt, R_yb);

    L_yt = R_yt;
    L_yb = R_yb;
  }

  R2_MakeSpans(plane, x, L_yt, L_yb, 9999, 0);

  if (plane_image_cache[0].cim)
    W_ImageDone(plane_image_cache[0].cim);

  if (plane_image_cache[1].cim)
    W_ImageDone(plane_image_cache[1].cim);

#elif (SHOW_PLANES == 1)
  BOGUS_DrawArea(&amp;plane-&gt;area,
      GREEN + GREEN_LEN * (255 - plane-&gt;props-&gt;lightlevel) / 256);
#endif /* SHOW_PLANES */
}
</t>
<t tx="T757">@ Render a single thing of a subsector.
@c

extern lighttable_t *spritezlights;

#define SX_FUDGE  2

void R2_DrawThing(subsector_t *dsub, drawthing_t *dthing)
{
#if (SHOW_THINGS == 2)
  int x, px;
  int yt, yb;

  int index;
  int offset;
  int column;
  int patch_width;

  const cached_image_t *cim;
  const w_post_t *cim_col;

  patch_width = dthing-&gt;image-&gt;actual_w;
  
  // calculate lighting
  if (dthing-&gt;is_shadow)
  {
    dc_colourmap = V_GetColtable(shadow_map, 0, 0);
  }
  else if (dthing-&gt;is_halo)
  {
    dc_colourmap = NULL;
  }
  else if (dthing-&gt;bright)
  {
    dc_colourmap = V_GetColtable(dthing-&gt;props-&gt;colourmap, 255, 0);
  }
  else if (dthing-&gt;mo-&gt;flags &amp; MF_FUZZY)
  {
    dc_colourmap = fuzz_coltable;
  }
  else
  {
    index = MIN(255, dthing-&gt;props-&gt;lightlevel + dthing-&gt;extra_light);

    DEV_ASSERT2(currentmap);
    if (currentmap-&gt;lighting &lt;= LMODEL_Doomish)
    {
      index &gt;&gt;= LIGHTSEGSHIFT;

      if (index &lt; 0)
        spritezlights = zlight[0];
      else if (index &gt;= LIGHTLEVELS)
        spritezlights = zlight[LIGHTLEVELS - 1];
      else
        spritezlights = zlight[index];

      index = dthing-&gt;tz / (1 &lt;&lt; (LIGHTZSHIFT - FRACBITS));

      if (index &gt;= MAXLIGHTZ)
        index = MAXLIGHTZ - 1;
      
      index = spritezlights[index];
    }

    dc_colourmap = V_GetColtable(dthing-&gt;props-&gt;colourmap, index, 0);
  }

  // handle translucency, translation &amp; shadow effect

  index = 0;
  mask_translucency = 1.0;

  if (dthing-&gt;is_shadow &amp;&amp; level_flags.trans)
  {
    index |= 1;
    mask_translucency = dthing-&gt;mo-&gt;visibility *
        PERCENT_2_FLOAT(dthing-&gt;mo-&gt;info-&gt;shadow_trans);
  }
  else if (dthing-&gt;mo-&gt;visibility &lt; VISIBLE &amp;&amp; level_flags.trans)
  {
    index |= 1;
    mask_translucency = dthing-&gt;mo-&gt;visibility;
  }

  if (dthing-&gt;trans_table)
  {
    index |= 2;
    dc_translation = dthing-&gt;trans_table;
  }
  
  if (dthing-&gt;is_halo)
  {
    colfunc = R_DrawHaloColumn8_MIP;  //!!!
  }
  else if ((dthing-&gt;mo-&gt;flags &amp; MF_FUZZY) &amp;&amp; !dthing-&gt;is_shadow)
  {
    colfunc = R_DrawFuzzColumn;
  } 
  else
  {
    DEV_ASSERT2(index &lt;= 3);
    
    switch (index)
    {
      case 0: colfunc = R_DrawColumn; break;
      case 1: colfunc = R_DrawTranslucentColumn; break;
      case 2: colfunc = R_DrawTranslatedColumn; break;
      case 3: colfunc = R_DrawTranslucentTranslatedColumn; break;
    }
  }

  yt = floor(focusyfrac - (dthing-&gt;top    - viewz) * dthing-&gt;dist_scale);
  yb = floor(focusyfrac - (dthing-&gt;bottom - viewz) * dthing-&gt;dist_scale);

  cim = W_ImageCache(dthing-&gt;image, IMG_Post, 0, true);

  // draw the columns
  for (x = dthing-&gt;area.x1; x &lt;= dthing-&gt;area.x2; x++)
  {
    if (x &lt; dsub-&gt;x_min-SX_FUDGE || x &gt; dsub-&gt;x_max+SX_FUDGE ||
        (x &lt; dsub-&gt;x_min &amp;&amp; dsub-&gt;clip_left) ||
        (x &gt; dsub-&gt;x_max &amp;&amp; dsub-&gt;clip_right))
    {
      continue;
    }
    
    px = MAX(dsub-&gt;x_min, MIN(dsub-&gt;x_max, x));

    dc_x  = x;
    dc_yl = MAX(yt,   dsub-&gt;ranges[px - dsub-&gt;x_min].y1);
    dc_yh = MIN(yb-1, dsub-&gt;ranges[px - dsub-&gt;x_min].y2);

    if (dc_yl &gt;= dc_yh)
      continue;
    
    DEV_ASSERT2(dc_yh &gt;= 0 &amp;&amp; dc_yl &lt; viewheight);

    if (dc_yl &lt; 0)
      dc_yl = 0;

    if (dc_yh &gt;= viewheight) 
      dc_yh = viewheight-1;

    offset = x - dthing-&gt;area.x1;

    column = floor(dthing-&gt;xfrac + offset * dthing-&gt;ixscale);

    if (dthing-&gt;flip)
      column = patch_width - 1 - column;

    if (column &lt; 0 || column &gt;= patch_width)
      continue;

    // -AJA- screen coords are now absolute
    dc_x  += viewwindowx;
    dc_yl += viewwindowy;
    dc_yh += viewwindowy;

    mask_yl = (float_t) dc_yl;
    mask_yh = (float_t) dc_yh;
    mask_scale = dthing-&gt;yscale;
    mask_top = yt + viewwindowy - (dthing-&gt;area.y_offset * mask_scale
        / dthing-&gt;mo-&gt;info-&gt;yscale);  // OPTIMISE

    cim_col = W_ImageGetPost(cim, column);

    if (cim_col)
      R2_DrawMaskedWPost(cim_col);
  }

  W_ImageDone(cim);

#elif (SHOW_THINGS == 1)
  int x, px, y1, y2;
  int yt, yb;
  int col = RED + RED_LEN * (255 - dthing-&gt;props-&gt;lightlevel) / 256;

  yt = floor(focusyfrac - (dthing-&gt;top    - viewz) * dthing-&gt;dist_scale);
  yb = floor(focusyfrac - (dthing-&gt;bottom - viewz) * dthing-&gt;dist_scale);

  for (x=dthing-&gt;area.x1; x &lt;= dthing-&gt;area.x2; x++)
  {
    if (x &lt; dsub-&gt;x_min-SX_FUDGE || x &gt; dsub-&gt;x_max+SX_FUDGE ||
        (x &lt; dsub-&gt;x_min &amp;&amp; dsub-&gt;clip_left) ||
        (x &gt; dsub-&gt;x_max &amp;&amp; dsub-&gt;clip_right))
    {
      continue;
    }
    
    px = MAX(dsub-&gt;x_min, MIN(dsub-&gt;x_max, x));

    y1 = MAX(yt, dsub-&gt;ranges[px - dsub-&gt;x_min].y1);
    y2 = MIN(yb, dsub-&gt;ranges[px - dsub-&gt;x_min].y2);

    if (y1 &gt; y2)
      continue;
    
    BOGUS_Column(main_scr, x, y1, y2-y1+1, col);
  }
#endif /* SHOW_THINGS */
}
</t>
<t tx="T758">static drawthing_t **mapdrawthings = NULL;
static int mapdrawthing_num = 0;

static void R2_DrawSortThings(subsector_t *dsub, drawfloor_t *dfloor)
{
  drawthing_t *thing;

  int i, count=0;

  for (thing=dfloor-&gt;things; thing; thing=thing-&gt;next)
    count++;

  if (count == 0)
    return;

  // maybe reallocate array
  if (count &gt; mapdrawthing_num)
  {
    Z_Resize(mapdrawthings, drawthing_t *, count);
    mapdrawthing_num = count;
  }

  // fill array
  count=0;

  for (thing=dfloor-&gt;things; thing; thing=thing-&gt;next)
    mapdrawthings[count++] = thing;

  // sort array.  Shadows are drawn first, Halos last
  //
  #define CMP(a,b)  ((a)-&gt;is_shadow &gt; (b)-&gt;is_shadow ||  \
       ((a)-&gt;is_shadow == (b)-&gt;is_shadow &amp;&amp;  \
        ((a)-&gt;is_halo &lt; (b)-&gt;is_halo ||                  \
         ((a)-&gt;is_halo == (b)-&gt;is_halo &amp;&amp;  \
          (a)-&gt;tz &gt; (b)-&gt;tz))))
  QSORT(drawthing_t *, mapdrawthings, count, CUTOFF);
  #undef CMP

  // draw array
  for (i=0; i &lt; count; i++)
    R2_DrawThing(dsub, mapdrawthings[i]);
}
</t>
<t tx="T759">@ Draw a single floor of a subsector.
@c

void R2_DrawFloor(subsector_t *dsub, drawfloor_t *dfloor)
{
  drawwall_t  *wall;
  drawplane_t *plane;

  for (plane=dfloor-&gt;planes; plane; plane=plane-&gt;next)
  {
    R2_DrawPlane(dsub, plane);
  }

  for (wall=dfloor-&gt;walls; wall; wall=wall-&gt;next)
  {
    R2_DrawWall(dsub, wall);
  }

  R2_DrawSortThings(dsub, dfloor);
}
</t>
<t tx="T760">@ Draw a subsector based on all the information collected when
traversing the BSP tree.
@c

void R2_DrawSubsector(subsector_t *dsub)
{
  drawfloor_t *dfloor;

  for (dfloor=dsub-&gt;floors; dfloor; dfloor=dfloor-&gt;next)
  {
    R2_DrawFloor(dsub, dfloor);
  }
}
</t>
<t tx="T761">@ R2_DrawSkyPlane
@c

static void R2_DrawSkyPlane(drawplane_t *plane)
{
#if (SHOW_SKY == 2)
  int x;
  int column;

  float_t scale_x = (float_t)0x0100 / sky_image-&gt;scale_x;
  float_t scale_y = (float_t)0x0100 / sky_image-&gt;scale_y;

  const cached_image_t *cim;

  cim = W_ImageCache(sky_image, IMG_Block, 0, true);

  dc_width  = sky_image-&gt;total_w;
  dc_height = sky_image-&gt;total_h;

  dc_ystep = M_FloatToFixed(skytexturescale / scale_y);
  dc_colourmap = V_GetColtable(normal_map, 255, VCOL_Sky);

  if ((sky_image-&gt;total_w * scale_x) &lt; 300)
    scale_x *= 2.0;
  
  for (x=plane-&gt;area.x1; x &lt;= plane-&gt;area.x2; x++)
  {
    dc_x = x;

    dc_yl = plane-&gt;area.ranges[x - plane-&gt;area.x1].y1;
    dc_yh = plane-&gt;area.ranges[x - plane-&gt;area.x1].y2;

    if (dc_yl &gt; dc_yh)
      continue;
    
    column = ((viewangle + xtoviewangle[x]) &gt;&gt; (ANGLETOSKYSHIFT)) / scale_x;
    column &amp;= (sky_image-&gt;total_w - 1);

    dc_yfrac = M_FloatToFixed(skytexturemid / scale_y) + dc_yl * dc_ystep;

    dc_source = W_ImageGetBlock(cim) + dc_height * column;

    // -AJA- screen coords are now absolute
    dc_x  += viewwindowx;
    dc_yl += viewwindowy;
    dc_yh += viewwindowy;

    R_DrawColumn_MIP();
  }
  W_ImageDone(cim);

#elif (SHOW_SKY == 1)
  BOGUS_DrawArea(&amp;plane-&gt;area, CYAN+CYAN_LEN/2);
#endif /* SHOW_SKY */
}
</t>
<t tx="T762">@ R2_DrawPSprite

-ACB- 1998/09/02 Fixed Error Messages to display correct procedure.
@c

static void R2_DrawPSprite(pspdef_t * psp, int which,
    player_t * player, region_properties_t *props, const state_t *state)
{
#if (SHOW_WEAPON &gt;= 1)
  int texcol;
  int trans = 0;
  fixed_t frac;
  fixed_t dfrac;

  const image_t *image;
  const cached_image_t *cim;
  const w_post_t *cim_col;

  int x, x1, x2;
  int sx1, sx2;
  int sy1, sy2;
  boolean_t flip;
  const colourmap_t *nominal;

  float_t tx, ty1, ty2;
  float_t visibility;
  float_t xiscale, yscale;
  float_t startfrac, dist_scale;

  // decide which image to use

#ifdef DEVELOPERS
  if ((unsigned int)state-&gt;sprite &gt;= (unsigned int)numsprites)
    I_Error("DrawPSprite: invalid sprite number %i ", state-&gt;sprite);
#endif

  image = R2_GetOtherSprite(state-&gt;sprite, state-&gt;frame, &amp;flip);

  if (!image)
    return;

  // calculate edges of the shape
  tx = psp-&gt;sx - BASEXCENTER;

  tx -= image-&gt;offset_x;
  x1 = focusxfrac + tx * pspritescale;

  // off the right side
  if (x1 &gt;= viewwidth)
    return;

  tx += IM_WIDTH(image);
  x2 = focusxfrac + tx * pspritescale - 1;

  // off the left side
  if (x2 &lt;= 0)
    return;

  ty1 = psp-&gt;sy - IM_OFFSETY(image);
  ty2 = ty1 + IM_HEIGHT(image);

  sx1 = MAX(x1, 0);
  sx2 = MIN(x2, viewwindowwidth - 1);

  if (sx1 &gt;= sx2)
    return;

  yscale = pspritescale2;
  dist_scale = pspritescale2;

  if (flip)
  {
    xiscale = -pspriteiscale;
    // -ES- Fixme
    startfrac = IM_WIDTH(image) - 0.0001;
  }
  else
  {
    xiscale = pspriteiscale;
    startfrac = 0;
  }

  if (sx1 &gt; x1)
    startfrac += xiscale * (sx1 - x1);

  visibility = player-&gt;mo-&gt;visibility * psp-&gt;visibility;

  // calculate lighting
  // -AJA- 1999/07/10: Updated for colmap.ddf.
  nominal = props-&gt;colourmap;

  DEV_ASSERT2(currentmap);

  if (player-&gt;powers[PW_PartInvis] &gt; 4 * 32 ||
      fmod(player-&gt;powers[PW_PartInvis], 16) &gt;= 8)
  {
////    mobjflags |= MF_FUZZY;
    dc_colourmap = fuzz_coltable;
  }
  else if (state-&gt;bright)
  {
    // full bright
    dc_colourmap = V_GetColtable(nominal, 255, 0);
  }
  else if (currentmap-&gt;lighting &lt;= LMODEL_Doomish)
  {
    // local light
    dc_colourmap = V_GetColtable(nominal, extra_psp_light +
        spritezlights[FLAT_LIGHTZ], 0);
  }
  else
  {
    // FLAT lighting
    dc_colourmap = V_GetColtable(nominal, extra_psp_light +
        props-&gt;lightlevel, 0);
  }

  if (player-&gt;mo-&gt;flags &amp; MF_FUZZY)
  {
    trans |= 1;
  }

  if (visibility &lt; VISIBLE &amp;&amp; level_flags.trans)
  {
    trans |= 2;
    dc_translucency = M_FloatToFixed(visibility);
  }

//!!!  if (trans_table)
//!!!  {
//!!!    dc_translation = trans_table;
//!!!    trans |= 4;
//!!!  }

  colfunc = R_DrawColumn_MIP;

  if (trans &amp; 1)
    colfunc = R_DrawFuzzColumn;  //!!! FIXME
  else
    switch (trans)
    {
      default:
        break;
      case 2:
        colfunc = R_DrawTranslucentColumn_MIP;
        break;

        //!!!! FIXME: use V_GetTranslatedColtable for these
      case 4:
        colfunc = R_DrawTranslatedColumn;
        break;
      case 6:
        colfunc = R_DrawTranslucentTranslatedColumn;
        break;
    }

  // -ES- 1999/03/04 Fixed aspect ratio
  masked_translucency = 1.0;  // -AJA- 1999/06/30

  frac = M_FloatToFixed(startfrac);
  dfrac = M_FloatToFixed(xiscale);
  
  sy1 = (int) (viewwindowheight * ty1 / 200.0);
  sy2 = (int) (viewwindowheight * ty2 / 200.0);

  cim = W_ImageCache(image, IMG_Post, 0, true);
  dc_height = image-&gt;total_h;

  if (sy1 &lt; 0)
    sy1 = 0;

  if (sy2 &gt;= viewwindowheight)
    sy2 = viewwindowheight-1;

  if (sy1 &gt;= sy2)
    return;

#if (SHOW_WEAPON == 1)
  V_DrawBox(main_scr, viewwindowx + sx1, viewwindowy + dc_yl, sx2-sx1, dc_yh-dc_yl, which ? YELLOW : DBLUE);
  return;
#endif  /* SHOW_WEAPON */

  for (x = sx1; x &lt;= sx2; x++, frac += dfrac)
  {
    texcol = frac &gt;&gt; FRACBITS;

    // allow a single pixel error at either side of sprite
    if (texcol == -1 || texcol == image-&gt;actual_w)
      continue;

#ifdef DEVELOPERS
    if (texcol &lt; -1 || texcol &gt; image-&gt;actual_w)
      I_Error("R_DrawVisSprite: bad texcol %d (image %dx%d)", texcol, image-&gt;actual_w, image-&gt;actual_h);
#endif

    // -AJA- screen coords are now absolute
    dc_x = x + viewwindowx;
    dc_yl = sy1 + viewwindowy;
    dc_yh = sy2 + viewwindowy;

    mask_yl = (float_t) dc_yl;
    mask_yh = (float_t) dc_yh;
    mask_scale = yscale;
    mask_top = mask_yl;

    cim_col = W_ImageGetPost(cim, texcol);

    if (cim_col)
      R2_DrawMaskedWPost(cim_col);
  }

  W_ImageDone(cim);
#endif  /* SHOW_WEAPON */
}
</t>
<t tx="T763">@ R2_DrawPlayerSprites
@c

void R2_DrawPlayerSprites(player_t * p)
{
  int i;
  int lightnum;

  DEV_ASSERT2(p-&gt;in_game);

  // get light level
  lightnum = view_props-&gt;lightlevel &gt;&gt; LIGHTSEGSHIFT;

  // -AJA- 1999/07/10: Now uses zlight[] instead of scalelight[].
  if (lightnum &lt; 0)
    spritezlights = zlight[0];
  else if (lightnum &gt;= LIGHTLEVELS)
    spritezlights = zlight[LIGHTLEVELS - 1];
  else
    spritezlights = zlight[lightnum];

  // special handling for zoom: show viewfinder
  if (viewiszoomed)
  {
    weaponinfo_t *w;
    pspdef_t *psp = &amp;p-&gt;psprites[ps_weapon];

    if ((p-&gt;ready_wp &lt; 0) || (psp-&gt;state == S_NULL))
      return;

    w = p-&gt;weapons[p-&gt;ready_wp].info;

    if (w-&gt;zoom_state &lt;= 0)
      return;

    R2_DrawPSprite(psp, ps_weapon, p, view_props,
        states + w-&gt;zoom_state);

    return;
  }
  
  // add all active psprites
  // Note: order is significant
  for (i = 0; i &lt; NUMPSPRITES; i++)
  {
    pspdef_t *psp = &amp;p-&gt;psprites[i];

    if (psp-&gt;state == S_NULL)
      continue;

    R2_DrawPSprite(psp, i, p, view_props, psp-&gt;state);
  }
}
</t>
<t tx="T764">@ Automap clipping of lines.

Based on Cohen-Sutherland clipping algorithm but with a slightly
faster reject and precalculated slopes. If the speed is needed,
use a hash algorithm to handle the common cases.
@c

boolean_t R2_ClipLine(int *x1, int *y1, int *x2, int *y2,
    int cl_x1, int cl_y1, int cl_x2, int cl_y2)
{
  enum
  {
    LEFT = 1,
    RIGHT = 2,
    BOTTOM = 4,
    TOP = 8
  };

  int outcode1 = 0;
  int outcode2 = 0;
  int outside;

  int dx, dy;
  int tmp_x, tmp_y;

#define DO_OUTCODE(oc, xx, yy)  \
    do {                                       \
      (oc) = 0;                                \
      if ((yy) &lt; cl_y1) (oc) |= TOP;           \
      else if ((yy) &gt;= cl_y2) (oc) |= BOTTOM;  \
      if ((xx) &lt; cl_x1) (oc) |= LEFT;          \
      else if ((xx) &gt;= cl_x2) (oc) |= RIGHT;   \
    } while (0)

  // do trivial rejects and outcodes
  DO_OUTCODE(outcode1, (*x1), (*y1));
  DO_OUTCODE(outcode2, (*x2), (*y2));

  if (outcode1 &amp; outcode2)
    return false;  // trivially outside

  while (outcode1 | outcode2)
  {
    // may be partially inside box
    // find an outside point
    if (outcode1)
      outside = outcode1;
    else
      outside = outcode2;

    DEV_ASSERT2(outside != 0);

    // clip to each side
    if (outside &amp; TOP)
    {
      dy = (*y1) - (*y2);
      dx = (*x2) - (*x1);
      tmp_x = (*x1) + ((*y1) - cl_y1) * dx / dy;
      tmp_y = cl_y1;
    }
    else if (outside &amp; BOTTOM)
    {
      dy = (*y1) - (*y2);
      dx = (*x2) - (*x1);
      tmp_x = (*x1) + ((*y1) - cl_y2) * dx / dy;
      tmp_y = cl_y2 - 1;
    }
    else if (outside &amp; LEFT)
    {
      dy = (*y2) - (*y1);
      dx = (*x2) - (*x1);
      tmp_y = (*y1) + (cl_x1 - (*x1)) * dy / dx;
      tmp_x = cl_x1;
    }
    else
    {
      DEV_ASSERT2(outside &amp; RIGHT);

      dy = (*y2) - (*y1);
      dx = (*x2) - (*x1);
      tmp_y = (*y1) + (cl_x2 - 1 - (*x1)) * dy / dx;
      tmp_x = cl_x2 - 1;
    }

    if (outside == outcode1)
    {
      (*x1) = tmp_x;
      (*y1) = tmp_y;

      DO_OUTCODE(outcode1, (*x1), (*y1));
    }
    else
    {
      (*x2) = tmp_x;
      (*y2) = tmp_y;

      DO_OUTCODE(outcode2, (*x2), (*y2));
    }

    if (outcode1 &amp; outcode2)
      return false;  // trivially outside
  }

#undef DO_OUTCODE

  return true;
}
</t>
<t tx="T765">@ The video context structure. There can only be one, either for
software rendering (here) or for GL rendering.
@c

#ifndef USE_GL
video_context_t vctx;
#endif

// static int clipper_x1;  ...

//
// R2_NewScreenSize
//
void R2_NewScreenSize(int width, int height, int bpp)
{
  //...
}
</t>
<t tx="T766">void R2_RenderScene(int x, int y, int w, int h, vid_view_t *view)
{
  //!!!
  R2_RenderTrueBSP();
}
</t>
<t tx="T767">void R2_BeginDraw(int x1, int y1, int x2, int y2)
{
  //...
}
</t>
<t tx="T768">void R2_EndDraw(void)
{
  //...
}
</t>
<t tx="T769">static void DrawImagePost(int x, int y, int w, int h, const image_t *image, 
    float_t tx1, float_t ty1, float_t tx2, float_t ty2,
    const colourmap_t *colmap, float_t alpha)
{
  const cached_image_t *cim;
  const w_post_t *cim_col;

  int column;

  cim = W_ImageCache(image, IMG_Post, 0, false);

  dc_colourmap = V_GetColtable(colmap, 255, 0);
  dc_height = image-&gt;total_h;
  dc_translucency = M_FloatToFixed(alpha);

  if (alpha &lt; 0.99)
    colfunc = R_DrawTranslucentColumn_MIP;
  else
    colfunc = R_DrawColumn_MIP;

  for (dc_x=x; dc_x &lt; x+w; dc_x++)
  {
    float_t tx = tx1 + (tx2 - tx1) * (dc_x - x) / w;
    
    if (dc_x &lt; 0 || dc_x &gt;= SCREENWIDTH)
      continue;

    column = (int)(tx * image-&gt;total_w);
    
    dc_yl = y;
    dc_yh = y + h - 1;

    if (dc_yl &lt; 0)
      dc_yl = 0;

    if (dc_yh &gt;= SCREENHEIGHT) 
      dc_yh = SCREENHEIGHT-1;

    if (dc_yh &lt; dc_yl || dc_yh &lt; 0 || dc_yl &gt;= SCREENHEIGHT)
      return;

    mask_yl = (float_t) dc_yl;
    mask_yh = (float_t) dc_yh;

    CHECKVAL(ty2 - ty1);
    mask_scale = (float_t)h / (ty2 - ty1) / image-&gt;total_h;
    mask_top = mask_yl - ty1 * mask_scale;

    cim_col = W_ImageGetPost(cim, column);

    if (cim_col)
      R2_DrawMaskedWPost(cim_col);
  }

  W_ImageDone(cim);
}

</t>
<t tx="T770">static void DrawImageBlock(int x, int y, int w, int h, const image_t *image, 
    float_t tx1, float_t ty1, float_t tx2, float_t ty2,
    const colourmap_t *colmap, float_t alpha)
{
  const cached_image_t *cim;

  float_t scale_x, scale_y;

  cim = W_ImageCache(image, IMG_Block, 0, false);
  ds_source = W_ImageGetBlock(cim);

  ds_colourmap = V_GetColtable(colmap, 255, 0);
  ds_width  = image-&gt;total_w;
  ds_height = image-&gt;total_h;
  dc_translucency = M_FloatToFixed(alpha);

  if (alpha &lt; 0.99)
    spanfunc = R_DrawTranslucentSpan_MIP;
  else
    spanfunc = R_DrawSpan_MIP;

  scale_x = image-&gt;scale_x / (float_t)0x0100;
  scale_y = image-&gt;scale_y / (float_t)0x0100;
  
  for (ds_y=y; ds_y &lt; y+h; ds_y++)
  {
    float_t ty = ty1 + (ty2 - ty1) * (ds_y - y) / h;

    if (ds_y &lt; 0 || ds_y &gt;= SCREENHEIGHT)
      continue;

    ds_x1 = x;
    ds_x2 = x + w - 1;

    if (ds_x1 &lt; 0)
      ds_x1 = 0;

    if (ds_x2 &gt;= SCREENWIDTH) 
      ds_x2 = SCREENWIDTH-1;

    if (ds_x2 &lt; ds_x1 || ds_x2 &lt; 0 || ds_x1 &gt;= SCREENWIDTH)
      return;

    ds_yfrac = M_FloatToFixed(ty  * ds_height);
    ds_xfrac = M_FloatToFixed(tx1 * ds_width);

    CHECKVAL(w);
    ds_ystep = 0;
    ds_xstep = M_FloatToFixed(ds_width * (tx2 - tx1) / w);

    (* spanfunc)();
  }

  W_ImageDone(cim);
}
</t>
<t tx="T771">void R2_DrawImage(int x, int y, int w, int h, const image_t *image, 
    float_t tx1, float_t ty1, float_t tx2, float_t ty2,
    const colourmap_t *colmap, float_t alpha)
{
  if (x+w &lt;= 0 || x &gt;= SCREENWIDTH)
    return;

  if (y+h &lt;= 0 || y &gt; SCREENHEIGHT)
    return;

  if (! colmap)
    colmap = normal_map;

  if (image-&gt;solid)
    DrawImageBlock(x, y, w, h, image, tx1, ty1, tx2, ty2, colmap, alpha);
  else
    DrawImagePost(x, y, w, h, image, tx1, ty1, tx2, ty2, colmap, alpha);
}
</t>
<t tx="T772">void R2_SolidBox(int x, int y, int w, int h, int colour, float_t alpha)
{
  // FIXME: implement translucent box drawing
  
  if (alpha &lt; 0.02)
    return;

  if (alpha &gt;= 0.98)
  {
    V_DrawBox(main_scr, x, y, w, h, colour);
  }
  else
  {
    V_DrawBoxAlpha(main_scr, x, y, w, h, colour, M_FloatToFixed(alpha));
  }
}
</t>
<t tx="T773">void R2_SolidLine(int x1, int y1, int x2, int y2, int colour)
{
  if (R2_ClipLine(&amp;x1, &amp;y1, &amp;x2, &amp;y2, 0, 0, SCREENWIDTH, SCREENHEIGHT))
  {
    V_DrawLine(main_scr, x1, y1, x2, y2, colour);
  }
}
</t>
<t tx="T774">void R2_ReadScreen(int x, int y, int w, int h, byte *rgb_buffer)
{
  //...
}
</t>
<t tx="T775">@ -ACB- 2000/07/22 Do we not like this with OpenGL
@c

#ifndef USE_GL
//
// R2_Init
//
void R2_Init(void)
{
  I_Printf("TrueBSP: Initialising...\n");

  // setup video context

#ifndef USE_GL
  vctx.double_buffered = false;

  vctx.NewScreenSize = R2_NewScreenSize;
  vctx.RenderScene = R2_RenderScene;
  vctx.BeginDraw = R2_BeginDraw;
  vctx.EndDraw = R2_EndDraw;
  vctx.DrawImage = R2_DrawImage;
  vctx.SolidBox = R2_SolidBox;
  vctx.SolidLine = R2_SolidLine;
  vctx.ReadScreen = R2_ReadScreen;

  R2_InitUtil();
#endif
}

#endif /* !USE_GL */
</t>
<t tx="T776">@ignore
@language c

// True BSP Rendering (Utility routines)

// -AJA- 1999/08/31: Wrote this file.
//
// TODO HERE:
//   + Implement better 1D buffer code.

&lt;&lt; r2_util #includes &gt;&gt;
&lt;&lt; r2_util declarations &gt;&gt;
@others
</t>
<t tx="T777">#include "i_defs.h"

#include "dm_state.h"
#include "m_bbox.h"
#include "m_fixed.h"

#include "r_data.h"
#include "r_defs.h"
#include "r_state.h"
#include "r_main.h"
#include "v_res.h"
#include "z_zone.h"

#include "r2_defs.h"
</t>
<t tx="T778">

// arrays of stuff

typedef struct commit_array_s
{
  stack_array_t a;

  // position of current free entry.
  int pos;

  // whether an item has been gotten, but not yet committed.
  boolean_t active;
}
commit_array_t;

static drawwall_t  ** arr_walls  = NULL;
static drawplane_t ** arr_planes = NULL;
static drawthing_t ** arr_things = NULL;
static drawfloor_t ** arr_floors = NULL;

static commit_array_t cmt_walls;
static commit_array_t cmt_planes;
static commit_array_t cmt_things;
static commit_array_t cmt_floors;


byte *subsectors_seen = NULL;
static int subsectors_seen_size = -1;

void R2_InitOpenings(void);
void R2_StartOpenings(void);
</t>
<t tx="T779">@ R2_InitUtil

One-time initialisation routine.
@c

void R2_InitUtil(void)
{
  Z_InitStackArray(&amp;cmt_walls.a, (void ***)&amp;arr_walls, 
      sizeof(drawwall_t),  64);
  cmt_walls.pos = 0;
  cmt_walls.active = false;

  Z_InitStackArray(&amp;cmt_planes.a, (void ***)&amp;arr_planes, 
      sizeof(drawplane_t), 64);
  cmt_planes.pos = 0;
  cmt_planes.active = false;
      
  Z_InitStackArray(&amp;cmt_things.a, (void ***)&amp;arr_things, 
      sizeof(drawthing_t), 64);
  cmt_things.pos = 0;
  cmt_things.active = false;

  Z_InitStackArray(&amp;cmt_floors.a, (void ***)&amp;arr_floors, 
      sizeof(drawfloor_t), 64);
  cmt_floors.pos = 0;
  cmt_floors.active = false;

  R2_InitOpenings();
}
</t>
<t tx="T780">@ bsp clear function
@c

void R2_ClearBSP(void)
{
  Z_SetArraySize(&amp;cmt_walls.a,  0);
  Z_SetArraySize(&amp;cmt_planes.a, 0);
  Z_SetArraySize(&amp;cmt_things.a, 0);
  Z_SetArraySize(&amp;cmt_floors.a, 0);

  cmt_walls.pos  = 0;
  cmt_planes.pos = 0;
  cmt_things.pos = 0;
  cmt_floors.pos = 0;

  if (subsectors_seen_size != numsubsectors)
  {
    subsectors_seen_size = numsubsectors;

    Z_Resize(subsectors_seen, byte, subsectors_seen_size);
  }

  Z_Clear(subsectors_seen, byte, subsectors_seen_size);

  R2_StartOpenings();
}
</t>
<t tx="T781">@ allocate functions
@c

drawwall_t *R2_GetDrawWall(void)
{
  DEV_ASSERT(!cmt_walls.active, ("R2_GetDrawWall: called twice"));
  
  if (cmt_walls.pos &gt;= cmt_walls.a.num)
    Z_SetArraySize(&amp;cmt_walls.a, cmt_walls.pos + 1);
  
  cmt_walls.active = true;
  return arr_walls[cmt_walls.pos];
}
</t>
<t tx="T782">
drawplane_t *R2_GetDrawPlane(void)
{
  DEV_ASSERT(!cmt_planes.active, ("R2_GetDrawPlane: called twice"));
  
  if (cmt_planes.pos &gt;= cmt_planes.a.num)
    Z_SetArraySize(&amp;cmt_planes.a, cmt_planes.pos + 1);
  
  cmt_planes.active = true;
  return arr_planes[cmt_planes.pos];
}
</t>
<t tx="T783">
drawthing_t *R2_GetDrawThing(void)
{
  DEV_ASSERT(!cmt_things.active, ("R2_GetDrawThing: called twice"));
  
  if (cmt_things.pos &gt;= cmt_things.a.num)
    Z_SetArraySize(&amp;cmt_things.a, cmt_things.pos + 1);
    
  cmt_things.active = true;
  return arr_things[cmt_things.pos];
}
</t>
<t tx="T784">
drawfloor_t *R2_GetDrawFloor(void)
{
  DEV_ASSERT(!cmt_floors.active, ("R2_GetDrawFloor: called twice"));

  if (cmt_floors.pos &gt;= cmt_floors.a.num)
    Z_SetArraySize(&amp;cmt_floors.a, cmt_floors.pos + 1);
  
  cmt_floors.active = true;
  return arr_floors[cmt_floors.pos];
}
</t>
<t tx="T785">
void R2_CommitDrawWall(int used)
{
  DEV_ASSERT(cmt_walls.active, ("R2_CommitDrawWall: not active"));
  DEV_ASSERT2(0 &lt;= used &amp;&amp; used &lt;= 1);
  
  cmt_walls.pos += used;
  cmt_walls.active = false;
}
</t>
<t tx="T786">
void R2_CommitDrawPlane(int used)
{
  DEV_ASSERT(cmt_planes.active, ("R2_CommitDrawPlane: not active"));
  DEV_ASSERT2(0 &lt;= used &amp;&amp; used &lt;= 1);
  
  cmt_planes.pos += used;
  cmt_planes.active = false;
}
</t>
<t tx="T787">
void R2_CommitDrawThing(int used)
{
  DEV_ASSERT(cmt_things.active, ("R2_CommitDrawThing: not active"));
  DEV_ASSERT2(0 &lt;= used &amp;&amp; used &lt;= 1);
  
  cmt_things.pos += used;
  cmt_things.active = false;
}
</t>
<t tx="T788">
void R2_CommitDrawFloor(int used)
{
  DEV_ASSERT(cmt_floors.active, ("R2_CommitDrawFloor: not active"));
  DEV_ASSERT2(0 &lt;= used &amp;&amp; used &lt;= 1);
  
  cmt_floors.pos += used;
  cmt_floors.active = false;
}
</t>
<t tx="T789">

void R2_FreeupBSP(void)
{
  Z_SetArraySize(&amp;cmt_walls.a,  0);
  Z_SetArraySize(&amp;cmt_planes.a, 0);
  Z_SetArraySize(&amp;cmt_things.a, 0);
  Z_SetArraySize(&amp;cmt_floors.a, 0);
}
</t>
<t tx="T790">@ ----------------------------------------------------------------------------

OPENING CODE


The openings are kept in blocks of 64K, allocated when needed (and
by using "Stack Arrays" they get freed when no longer needed).
@c

#define OPENING_CHUNK  16384

typedef struct range_array_s
{
  Y_range_t ranges[OPENING_CHUNK];
}
range_array_t;


static stack_array_t range_arrays_a;
static range_array_t ** range_arrays;
static int num_range_arrays;

static range_array_t *free_R_array;
static int free_RA_pos;

static boolean_t RA_active;

//
// R2_InitOpenings
//
// Once-only call to initialise opening system.
//
void R2_InitOpenings(void)
{
  Z_InitStackArray(&amp;range_arrays_a, (void ***)&amp;range_arrays, 
      sizeof(range_array_t), 0);
}
</t>
<t tx="T791">@ R2_StartOpenings

Called once per frame, before rendering begins.
@c

void R2_StartOpenings(void)
{
  num_range_arrays = 1;
  Z_SetArraySize(&amp;range_arrays_a, num_range_arrays);

  // setup the free pointer
  free_R_array = range_arrays[0];
  free_RA_pos  = 0;

  RA_active = false;
}
</t>
<t tx="T792">@ R2_GetOpenings

Get an array of openings for a new wall/plane/thing or whatever,
with at most `width' elements. The returned array is provisional,
you must call R2_CommitOpenings() sometime later to ensure that
nothing else uses it. This routine cannot be called again until
R2_CommitOpenings is called. R2_CommitOpenings can be called with
a lower width (including 0, if no openings were needed).
@c

Y_range_t *R2_GetOpenings(int width)
{
  DEV_ASSERT(!RA_active, ("R2_GetOpenings: called twice"));
  DEV_ASSERT2(free_R_array);
  DEV_ASSERT2(0 &lt; width &amp;&amp; width &lt;= OPENING_CHUNK);

  // no more room in current chunk ?
  if (width &gt; (OPENING_CHUNK - free_RA_pos))
  {
    num_range_arrays++;
    Z_SetArraySize(&amp;range_arrays_a, num_range_arrays);

    free_R_array = range_arrays[num_range_arrays-1];
    free_RA_pos  = 0;
  }

  RA_active = true;

  return free_R_array-&gt;ranges + free_RA_pos;
}
</t>
<t tx="T793">@ R2_CommitOpenings

(see the comment above).
@c

void R2_CommitOpenings(int width)
{
  DEV_ASSERT(RA_active, ("R2_CommitOpenings: not active"));
  DEV_ASSERT2(free_R_array);
  DEV_ASSERT2(0 &lt;= width &amp;&amp; width &lt;= OPENING_CHUNK);
  DEV_ASSERT2(width &lt;= (OPENING_CHUNK - free_RA_pos));

  free_RA_pos += width;

  RA_active = false;
}
</t>
<t tx="T794">@ ----------------------------------------------------------------------------

1D OCCLUSION BUFFER CODE

NOTE! temporary code to test new 1D buffer concept
@c

static byte cruddy_1D_buf[2048];

//
// R2_1DOcclusionClear
//
void R2_1DOcclusionClear(int x1, int x2)
{
  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; x1 &lt;= x2);

  for (; x1 &lt;= x2; x1++)
    cruddy_1D_buf[x1] = 1;
}
</t>
<t tx="T795">@ R2_1DOcclusionSet
@c

void R2_1DOcclusionSet(int x1, int x2)
{
  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; x1 &lt;= x2);

  for (; x1 &lt;= x2; x1++)
    cruddy_1D_buf[x1] = 0;
}
</t>
<t tx="T796">@ R2_1DOcclusionTest

Test if the range from x1..x2 is completely blocked, returning true
if it is, otherwise false.
@c

boolean_t R2_1DOcclusionTest(int x1, int x2)
{
  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; x1 &lt;= x2);

  for (; x1 &lt;= x2; x1++)
    if (cruddy_1D_buf[x1])
      return false;
  
  return true;
}
</t>
<t tx="T797">@ R2_1DOcclusionTestShrink

Similiar to the above routine, but shrinks the given range as much
as possible. Returns true if totally occluded.
@c

boolean_t R2_1DOcclusionTestShrink(int *x1, int *x2)
{
  DEV_ASSERT2(0 &lt;= (*x1) &amp;&amp; (*x1) &lt;= (*x2));

  for (; (*x1) &lt;= (*x2); (*x1)++)
    if (cruddy_1D_buf[*x1])
      break;

  for (; (*x1) &lt;= (*x2); (*x2)--)
    if (cruddy_1D_buf[*x2])
      break;
  
  return (*x1) &gt; (*x2) ? true : false;
}
</t>
<t tx="T798">@ R2_1DOcclusionClose
@c

void R2_1DOcclusionClose(int x1, int x2, Y_range_t *ranges)
{
  int i;

  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; x1 &lt;= x2);

  for (i=x1; i &lt;= x2; i++)
  {
    if (cruddy_1D_buf[i] == 0)
    {
      ranges[i - x1].y1 = 1;
      ranges[i - x1].y2 = 0;
    }
  }
}
</t>
<t tx="T799">@ ----------------------------------------------------------------------------

2D OCCLUSION BUFFER CODE
@c

Y_range_t Screen_clip[2048];

//
// R2_2DOcclusionClear
//
void R2_2DOcclusionClear(int x1, int x2)
{
  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; x1 &lt;= x2);

  for (; x1 &lt;= x2; x1++)
  {
    Screen_clip[x1].y1 = 0;
    Screen_clip[x1].y2 = viewheight-1;
  }
}
</t>
<t tx="T800">@ R2_2DOcclusionClose
@c

void R2_2DOcclusionClose(int x1, int x2, Y_range_t *ranges,
    boolean_t connect_low, boolean_t connect_high, boolean_t solid)
{
  int i;

  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; x1 &lt;= x2);

  for (i=x1; i &lt;= x2; i++)
  {
    short y1 = ranges[i - x1].y1;
    short y2 = ranges[i - x1].y2;

    if (y1 &gt; y2)
      continue;

    ranges[i - x1].y1 = MAX(y1, Screen_clip[i].y1);
    ranges[i - x1].y2 = MIN(y2, Screen_clip[i].y2);
  
    if (connect_low || (solid &amp;&amp; y2 &gt;= Screen_clip[i].y2))
      Screen_clip[i].y2 = MIN(Screen_clip[i].y2, y1-1);

    if (connect_high || (solid &amp;&amp; y1 &lt;= Screen_clip[i].y1))
      Screen_clip[i].y1 = MAX(Screen_clip[i].y1, y2+1);
  }
}
</t>
<t tx="T801">@ R2_2DOcclusionCopy

Copy the 1D/2D occlusion buffer.
@c

void R2_2DOcclusionCopy(int x1, int x2, Y_range_t *ranges)
{
  int i;

  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; x1 &lt;= x2);

  for (i=x1; i &lt;= x2; i++)
  {
    if (cruddy_1D_buf[i] == 0)
    {
      ranges[i - x1].y1 = 1;
      ranges[i - x1].y2 = 0;
    }
    else
    {
      ranges[i - x1].y1 = Screen_clip[i].y1;
      ranges[i - x1].y2 = Screen_clip[i].y2;
    }
  }
}
</t>
<t tx="T802">@ R2_2DUpdate1D

Check the 2D occlusion buffer for complete closure, updating the 1D
occlusion buffer where necessary.
@c

void R2_2DUpdate1D(int x1, int x2)
{
  int i;

  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; x1 &lt;= x2);

  for (i=x1; i &lt;= x2; i++)
  {
    if (Screen_clip[i].y1 &gt; Screen_clip[i].y2)
      cruddy_1D_buf[i] = 0;
  }
}
</t>
<t tx="T803">@ ----------------------------------------------------------------------------

TILE SKY UTILITIES
@c

tilesky_t sky_tiles[4];
int sky_tiles_active = 0;

void R2_TileSkyClear(void)
{
  memset(sky_tiles, 0, sizeof(sky_tiles));
  sky_tiles_active = 0;
}
</t>
<t tx="T804">
void R2_TileSkyAdd(const tilesky_info_t *info, struct line_s *line)
{
  int layer = info-&gt;layer - 1;

  if (layer &lt; 0 || layer &gt;= MAX_TILESKY)
    return;

  // update count of active sky tiles
  if (! sky_tiles[layer].active)
    sky_tiles_active++;

  sky_tiles[layer].info = info;
  sky_tiles[layer].line = line;
  sky_tiles[layer].active = true;

  L_WriteDebug("SKY TILE %d ACTIVE (total active %d)\n",
      layer, sky_tiles_active);
}
</t>
<t tx="T805">@ ----------------------------------------------------------------------------

LEVEL-OF-DETAIL STUFF

These functions return a "LOD" number. 1 means the maximum
detail, 2 is half the detail, 4 is a quarter, etc...
@c

int lod_base_cube = 256;


//
// R2_GetPointLOD
//
int R2_GetPointLOD(float_t x, float_t y, float_t z)
{
  x = fabs(x - viewx);
  y = fabs(y - viewy);
  z = fabs(z - viewz);

  x = MAX(x, MAX(y, z));

  return 1 + (int)floor(x / lod_base_cube);
}
</t>
<t tx="T806">@ R2_GetBBoxLOD
@c

int R2_GetBBoxLOD(float_t x1, float_t y1, float_t z1,
    float_t x2, float_t y2, float_t z2)
{
  x1 -= viewx;  x2 -= viewx;
  y1 -= viewy;  y2 -= viewy;
  z1 -= viewz;  z2 -= viewz;

  // check signs to handle BBOX crossing the axis
  x1 = ((x1&lt;0) != (x2&lt;0)) ? 0 : MIN(fabs(x1), fabs(x2));
  y1 = ((y1&lt;0) != (y2&lt;0)) ? 0 : MIN(fabs(y1), fabs(y2));
  z1 = ((z1&lt;0) != (z2&lt;0)) ? 0 : MIN(fabs(z1), fabs(z2));
  
  x1 = MAX(x1, MAX(y1, z1));

  return 1 + (int)floor(x1 / lod_base_cube);
}
</t>
<t tx="T807">@ R2_GetWallLOD

Note: code is currently the same as in R2_GetBBoxLOD above, though
this could be improved to handle diagonal lines better (at the
moment we just use the line's bbox).
@c

int R2_GetWallLOD(float_t x1, float_t y1, float_t z1,
    float_t x2, float_t y2, float_t z2)
{
  x1 -= viewx;  x2 -= viewx;
  y1 -= viewy;  y2 -= viewy;
  z1 -= viewz;  z2 -= viewz;

  // check signs to handle BBOX crossing the axis
  x1 = ((x1&lt;0) != (x2&lt;0)) ? 0 : MIN(fabs(x1), fabs(x2));
  y1 = ((y1&lt;0) != (y2&lt;0)) ? 0 : MIN(fabs(y1), fabs(y2));
  z1 = ((z1&lt;0) != (z2&lt;0)) ? 0 : MIN(fabs(z1), fabs(z2));
  
  x1 = MAX(x1, MAX(y1, z1));

  return 1 + (int)floor(x1 / lod_base_cube);
}
</t>
<t tx="T808">@ R2_GetPlaneLOD
@c

int R2_GetPlaneLOD(subsector_t *sub, float_t h)
{
  // get BBOX of plane
  float_t x1 = sub-&gt;bbox[BOXLEFT]   - viewx;
  float_t x2 = sub-&gt;bbox[BOXRIGHT]  - viewx;
  float_t y1 = sub-&gt;bbox[BOXBOTTOM] - viewy;
  float_t y2 = sub-&gt;bbox[BOXTOP]    - viewy;

  x1 = ((x1&lt;0) != (x2&lt;0)) ? 0 : MIN(fabs(x1), fabs(x2));
  y1 = ((y1&lt;0) != (y2&lt;0)) ? 0 : MIN(fabs(y1), fabs(y2));

  h = MAX(fabs(h - viewz), MAX(x1, y1));

  return 1 + (int)floor(h / lod_base_cube);
}
</t>
<t tx="T809">@ignore
@language c

// BSP Handling Code

// -KM- 1998/09/27 Special sector colourmap changing

&lt;&lt; r_bsp #includes &gt;&gt;

side_t *sidedef;
line_t *linedef;
sector_t *frontsector;
sector_t *backsector;
int root_node;

// R_CheckBBox
//
// Checks BSP node/subtree bounding box.
// Returns true if some part of the bbox might be visible.

int checkcoord[12][4] =
{
  {BOXRIGHT, BOXTOP, BOXLEFT, BOXBOTTOM},
  {BOXRIGHT, BOXTOP, BOXLEFT, BOXTOP},
  {BOXRIGHT, BOXBOTTOM, BOXLEFT, BOXTOP},
  {0},
  {BOXLEFT, BOXTOP, BOXLEFT, BOXBOTTOM},
  {0},
  {BOXRIGHT, BOXBOTTOM, BOXRIGHT, BOXTOP},
  {0},
  {BOXLEFT, BOXTOP, BOXRIGHT, BOXBOTTOM},
  {BOXLEFT, BOXBOTTOM, BOXRIGHT, BOXBOTTOM},
  {BOXLEFT, BOXBOTTOM, BOXRIGHT, BOXTOP}
};
</t>
<t tx="T810">#include "i_defs.h"
#include "r_bsp.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_bbox.h"
#include "p_local.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_segs.h"
#include "r_state.h"
#include "r_things.h"
#include "z_zone.h"
</t>
<t tx="T811">@ignore
@language c

// Rendering Data Handling Code

// -ACB- 1998/09/09 Reformatted File Layout.
// -KM- 1998/09/27 Colourmaps can be dynamically changed.
// -ES- 2000/02/12 Moved most of this module to w_texture.c.

&lt;&lt; r_data #includes &gt;&gt;
@others
</t>
<t tx="T812">#include "i_defs.h"
#include "r_data.h"

#include "e_search.h"
#include "dm_state.h"
#include "dm_defs.h"
#include "m_argv.h"
#include "m_misc.h"
#include "m_swap.h"
#include "p_local.h"
#include "r_sky.h"
#include "w_wad.h"
#include "w_textur.h"
#include "z_zone.h"
</t>
<t tx="T813">@ R_AddFlatAnim

Here are the rules for flats, they get a bit hairy, but are the
simplest thing which achieves expected behaviour:

1. When two flats in different wads have the same name, the flat
in the _later_ wad overrides the flat in the earlier wad. This
allows pwads to replace iwad flats -- as is usual. For general
use of flats (e.g. in levels) their order is not an issue.

2. The flat animation sequence is determined by the _earliest_ wad
which contains _both_ the start and the end flat. The sequence
contained in that wad becomes the animation sequence (the list
of flat names). These names are then looked up normally, so
flats in newer wads will get used if their name matches one in
the sequence.

Note that via rule 2, the _earliest_ wad sets the animation
sequence. HMMMMM !!

-AJA- 2001/01/28: reworked flat animations.
@c

void R_AddFlatAnim(animdef_t *anim)
{
  int start = W_CheckNumForName(anim-&gt;startname);
  int end   = W_CheckNumForName(anim-&gt;endname);

  int file;
  int s_offset, e_offset;
  const int *lumps;
  int total;

  int i;
  const image_t **flats;
  
  if (start == -1 || end == -1)
  {
    // sequence not valid.  Maybe it is the DOOM 1 IWAD.
    return;
  }

  file = W_FindFlatSequence(anim-&gt;startname, anim-&gt;endname, 
      &amp;s_offset, &amp;e_offset);

  if (file &lt; 0)
  {
    I_Warning("Missing flat animation: %s-%s not in any wad.\n",
        anim-&gt;startname, anim-&gt;endname);
    return;
  }

  DEV_ASSERT2(s_offset &lt;= e_offset);

  lumps = W_GetListLumps(file, LMPLST_Flats, &amp;total);

  // determine animation sequence
  lumps += s_offset;
  total = e_offset - s_offset + 1;

  flats = Z_New(const image_t *, total);

  // lookup each flat
  for (i=0; i &lt; total; i++)
  {
    const char *name = W_GetLumpName(lumps[i]);

    // Note we use W_ImageFromFlat() here.  It might seem like a good
    // optimisation to use the lump number directly, but we can't do
    // that -- the lump list does NOT take overriding flats (in newer
    // pwads) into account.
    
    flats[i] = W_ImageFromFlat(name);
  }

  W_AnimateImageSet(flats, total, anim-&gt;speed);
  Z_Free(flats);
}
</t>
<t tx="T814">@ R_AddTextureAnim

Here are the rules for textures:

1. The TEXTURE1/2 lumps require a PNAMES lump to complete their
meaning. Some wads have the TEXTURE1/2 lump(s) but lack a
PNAMES lump -- in this case the next oldest PNAMES lump is used
(e.g. the one in the IWAD).

2. When two textures in different wads have the same name, the
texture in the _later_ wad overrides the one in the earlier wad,
as is usual. For general use of textures (e.g. in levels),
their ordering is not an issue.

3. The texture animation sequence is determined by the _latest_ wad
whose TEXTURE1/2 lump contains _both_ the start and the end
texture. The sequence within that lump becomes the animation
sequence (the list of texture names). These names are then
looked up normally, so textures in newer wads can get used if
their name matches one in the sequence.

-AJA- 2001/06/17: reworked texture animations.
@c

void R_AddTextureAnim(animdef_t *anim)
{
  int set, s_offset, e_offset;
  
  int i, total;
  const image_t **texs;
 
  set = W_FindTextureSequence(anim-&gt;startname, anim-&gt;endname,
      &amp;s_offset, &amp;e_offset);

  if (set &lt; 0)
  {
    // sequence not valid.  Maybe it is the DOOM 1 IWAD.
    return;
  }

  DEV_ASSERT2(s_offset &lt;= e_offset);

  total = e_offset - s_offset + 1;
  
  texs = Z_New(const image_t *, total);

  // lookup each texture
  for (i=0; i &lt; total; i++)
  {
    const char *name = W_TextureNameInSet(set, s_offset + i);
    texs[i] = W_ImageFromFlat(name);
  }

  W_AnimateImageSet(texs, total, anim-&gt;speed);
  Z_Free(texs);
}
</t>
<t tx="T815">@ R_InitFlats
@c

boolean_t R_InitFlats(void)
{
  int max_file = W_GetNumFiles();
  int j, file;
  
  int *F_lumps = NULL;
  int numflats = 0;
   
  I_Printf("R_InitFlats...\n");

  // iterate over each file, creating our big array of flats

  for (file=0; file &lt; max_file; file++)
  {
    const int *lumps;
    int lumpnum;

    lumps = W_GetListLumps(file, LMPLST_Flats, &amp;lumpnum);

    if (lumpnum == 0)
      continue;

    Z_Resize(F_lumps, int, numflats + lumpnum);

    for (j=0; j &lt; lumpnum; j++, numflats++)
      F_lumps[numflats] = lumps[j];
  }

  if (numflats == 0)
    I_Error("No flats found !  Make sure the chosen IWAD is valid.\n");

  // now sort the flats, primarily by increasing name, secondarily by
  // increasing lump number (a measure of newness).

#define CMP(a, b)  \
    (strcmp(W_GetLumpName(a), W_GetLumpName(b)) &lt; 0 || \
     (strcmp(W_GetLumpName(a), W_GetLumpName(b)) == 0 &amp;&amp; a &lt; b))
  QSORT(int, F_lumps, numflats, CUTOFF);
#undef CMP

  // remove duplicate names.  We rely on the fact that newer lumps
  // have greater lump values than older ones.  Because the QSORT took
  // newness into account, only the last entry in a run of identically
  // named flats needs to be kept.

  for (j=1; j &lt; numflats; j++)
  {
    int a = F_lumps[j - 1];
    int b = F_lumps[j];

    if (strcmp(W_GetLumpName(a), W_GetLumpName(b)) == 0)
      F_lumps[j - 1] = -1;
  }

#if 0  // DEBUGGING
  for (j=0; j &lt; numflats; j++)
  {
    L_WriteDebug("FLAT #%d:  lump=%d  name=[%s]\n", j,
        F_lumps[j], W_GetLumpName(F_lumps[j]));
  }
#endif
  
  W_ImageCreateFlats(F_lumps, numflats); 
  Z_Free(F_lumps);

  return true;
}
</t>
<t tx="T816">@ -ACB- 1999/09/25 modified for new boolean_t type
@c

boolean_t R_InitPicAnims(void)
{
  int i;

  // loop through animdefs, and add relevant anims.
  // Note: reverse order, give priority to newer anims.
  for (i = numanimdefs-1; i &gt;= 0; i--)
  {
    animdef_t *A = animdefs[i];

    if (A-&gt;istexture == true)
      R_AddTextureAnim(A);
    else
      R_AddFlatAnim(A);
  }

  return true;
}
</t>
<t tx="T817">static void R_PrecacheSprites(void)
{
  int i;
  byte *sprite_present;
  mobj_t *mo;
    
  DEV_ASSERT2(numsprites &gt; 0);

  sprite_present = Z_ClearNew(byte, numsprites);

  for (mo = mobjlisthead; mo; mo = mo-&gt;next)
  {
    if (mo-&gt;sprite &lt; 0 || mo-&gt;sprite &gt;= numsprites)
      continue;

    sprite_present[mo-&gt;sprite] = 1;
  }

  for (i=0; i &lt; numsprites; i++)
  {
    spritedef_t *sp = sprites + i;
    int fr, rot;

    const image_t *cur_image;
    const image_t *last_image = NULL;  // an optimisation

    if (! sprite_present[i] || sp-&gt;numframes == 0)
      continue;

    DEV_ASSERT2(sp-&gt;frames);

    for (fr=0; fr &lt; sp-&gt;numframes; fr++)
    {
      if (! sp-&gt;frames[fr].finished)
        continue;

      for (rot=0; rot &lt; 16; rot++)
      {
        cur_image = sp-&gt;frames[fr].images[rot];

        if (cur_image == NULL || cur_image == last_image)
          continue;

        W_ImagePreCache(cur_image);

        last_image = cur_image;
      }
    }
  }
 
  Z_Free(sprite_present);
}
</t>
<t tx="T818">@ Preloads all relevant graphics for the level.

-AJA- 2001/06/18: Reworked for image system.
@c

void R_PrecacheLevel(void)
{
  const image_t ** images;

  int max_image;
  int count = 0;
  int i;

  if (demoplayback)
    return;

  // do sprites first -- when memory is tight, they'll be the first
  // images to be removed from the cache(s).
 
  if (M_CheckParm("-fastsprite") || M_CheckParm("-fastsprites"))
  {
    R_PrecacheSprites();
  }
 
  // maximum possible images
  max_image = 1 + 3 * numsides + 2 * numsectors;
   
  images = Z_New(const image_t *, max_image);

  // Sky texture is always present.
  images[count++] = sky_image;

  // add in sidedefs
  for (i=0; i &lt; numsides; i++)
  {
    if (sides[i].top.image)
      images[count++] = sides[i].top.image;
    
    if (sides[i].middle.image)
      images[count++] = sides[i].middle.image;

    if (sides[i].middle.image)
      images[count++] = sides[i].middle.image;
  }

  DEV_ASSERT2(count &lt;= max_image);

  // add in planes
  for (i=0; i &lt; numsectors; i++)
  {
    if (sectors[i].floor.image)
      images[count++] = sectors[i].floor.image;

    if (sectors[i].ceil.image)
      images[count++] = sectors[i].ceil.image;
  }

  DEV_ASSERT2(count &lt;= max_image);

  // Sort the images, so we can ignore the duplicates
  
#define CMP(a, b)  (a &lt; b)
  QSORT(const image_t *, images, count, CUTOFF);
#undef CMP

  for (i=0; i &lt; count; i++)
  {
    DEV_ASSERT2(images[i]);
    
    if (i+1 &lt; count &amp;&amp; images[i] == images[i + 1])
      continue;

    if (images[i] == skyflatimage)
      continue;

    W_ImagePreCache(images[i]);
  }

  Z_Free(images);
}
</t>
<t tx="T819">@ignore
@language c

// Column/Span Drawing for 8-bit Colour Code

// -ACB- 1998/09/10 Cleaned up.

&lt;&lt; r_draw1 #includes &gt;&gt;
&lt;&lt; r_draw1 declarations &gt;&gt;

@ All drawing to the view buffer is accomplished in this file.

The other refresh files only know about ccordinates, not the
architecture of the frame buffer.

Conveniently, the frame buffer is a linear one, and we need
only the base address, and the total size == width*height*depth/8.

-ES- 1999/02/12 Converted BLF stuff to 8-bit
Detail level. High detail levels look better, but
consume more memory. For each detail increase by one,
the BLF table needs approx. four times as much memory.
@c

@others
</t>
<t tx="T820">#include "i_defs.h"
#include "r_draw1.h"

#include "con_cvar.h"
#include "con_defs.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "m_random.h"
#include "r_local.h"
#include "v_res.h"
#include "v_screen.h"
#include "v_colour.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T821">
funclist_t drawcol8_funcs;
funclist_t drawspan8_funcs;
</t>
<t tx="T822">#define BLFshift 2
#define BLFsz (1&lt;&lt;BLFshift)
#define BLFmax (BLFsz-1)

static void ColSmoothingOn(funclist_t * fl GCCATTR(unused))
{
  dc_usesmoothing = true;
}
</t>
<t tx="T823">static void ColSmoothingOff(funclist_t * fl GCCATTR(unused))
{
  dc_usesmoothing = false;
}
</t>
<t tx="T824">static void SpanSmoothingOn(funclist_t * fl GCCATTR(unused))
{
  ds_usesmoothing = true;
}
</t>
<t tx="T825">static void SpanSmoothingOff(funclist_t * fl GCCATTR(unused))
{
  ds_usesmoothing = false;
}
</t>
<t tx="T826">@ Table with 256 longs containing translucency table-style fix-point RGBs.
@c

typedef unsigned long BLF8LUT;

// Totally 8*8*256 BLF16LUTs
static BLF8LUT *BLFTab[BLFsz][BLFsz];

static void BLF_Init8(funclist_t * fl)
{
  static boolean_t firsttime = true;
  unsigned int i;

  unsigned long r, g, b, x, y, xy;

  const unsigned char *thepalette;

  // Array of all the used BLF16LUTs
  BLF8LUT *BLFBuf;

  // Stores which index to BLFBuf a certain x*y should use (x and y are 31.1 fix point)
  int BLFCheck[4 * BLFsz * BLFsz];

  int count = 0;

  if (fl-&gt;dest == &amp;R_DrawColumn)
    ColSmoothingOn(fl);
  else if (fl-&gt;dest == &amp;R_DrawSpan)
    SpanSmoothingOn(fl);
  if (!firsttime)
    return;
  firsttime = false;

  I_Printf("BLF_Init: Init Bilinear Filtering");

  // Init BLFCheck
  for (x = 0; x &lt; 4 * BLFsz * BLFsz; x++)
    BLFCheck[x] = -1;
  for (x = 1; x &lt; 2 * BLFsz; x += 2)
    for (y = 1; y &lt; 2 * BLFsz; y += 2)
      if (BLFCheck[x * y] == -1)
      {
        BLFCheck[x * y] = count;
        count++;
      }

  // Allocate the memory if it isn't already allocated. Use 32-byte alignment.
  BLFBuf = BLFTab[0][0];
  if (!BLFBuf)
  {
    // allocate memory
    BLFBuf = (BLF8LUT *) Z_Malloc(count * 256 * sizeof(BLF8LUT) + 31);

    // align by 32
    BLFBuf = (BLF8LUT *) (((long)BLFBuf + 31) &amp; ~31);
  }

  for (x = 0; x &lt; BLFsz; x++)
    for (y = 0; y &lt; BLFsz; y++)
      BLFTab[x][y] = &amp;BLFBuf[256 * BLFCheck[(2 * x + 1) * (2 * y + 1)]];

  thepalette = W_CacheLumpName("PLAYPAL");
  for (xy = 0; xy &lt; 4 * BLFsz * BLFsz; xy++)
    if (BLFCheck[xy] != -1)
    {
      for (i = 0; i &lt; 256; i++)
      {
        r = thepalette[i * 3 + 0];
        g = thepalette[i * 3 + 1];
        b = thepalette[i * 3 + 2];
        r = ((r * xy) &lt;&lt;
			 2) &gt;&gt; (2 + 2 * BLFshift);
        g = ((g * xy) &lt;&lt;
			 4) &gt;&gt; (2 + 2 * BLFshift);
        b = ((b * xy) &lt;&lt;
			 2) &gt;&gt; (2 + 2 * BLFshift);
        (&amp;BLFBuf[256 * BLFCheck[xy]])[i] = (r &lt;&lt; 22) + (g &lt;&lt; 10) + b;
      }
    }
  W_DoneWithLump(thepalette);
  I_Printf("\n");
}
</t>
<t tx="T827">void resinit_r_draw_c8(void)
{
}
</t>
<t tx="T828">@ A column is a vertical slice/span from a wall texture that,
given the DOOM style restrictions on the view orientation,
will always have constant z depth.

Thus a special case loop for very fast rendering can
be used. It has also been used with Wolfenstein 3D.

-ES- 1999/04/19 Optimised slightly
@c

void R_DrawColumn8_CVersion(void)
{
  int count;
  byte *dest;
  unsigned long frac;
  unsigned long fracstep;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  fracstep = dc_ystep &lt;&lt; (FRACBITS - 7);
  frac = dc_yfrac &lt;&lt; (FRACBITS - 7);

  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  do
  {
    // Re-map colour indices from wall texture column
    // using a lighting/special effects LUT.
    *dest = dc_colourmap[dc_source[frac &gt;&gt; (32 - 7)]];

    dest += vb_pitch;
    frac += fracstep;

  }
  while (--count);
}
</t>
<t tx="T829">void R_DrawColumn8_MIP(void)
{
  int count;
  byte *dest;

  fixed_t yfrac;
  fixed_t ystep;
  fixed_t ymask;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  //
  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  yfrac = dc_yfrac;
  ystep = dc_ystep;
  ymask = (dc_height - 1) &lt;&lt; FRACBITS;

  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  do
  {
    // Re-map colour indices from wall texture column
    // using a lighting/special effects LUT.
    *dest = dc_colourmap[dc_source[(yfrac &amp; ymask) &gt;&gt; FRACBITS]];

    dest += vb_pitch;
    yfrac += ystep;
  }
  while (--count);
}
</t>
<t tx="T830">void R_DrawTranslucentColumn8_MIP(void)
{
  int count;
  byte *dest;

  fixed_t yfrac;
  fixed_t ystep;
  fixed_t ymask;

  fixed_t fglevel, bglevel;
  unsigned long *fg2rgb, *bg2rgb;
  unsigned long fg;  // current colours

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  fglevel = dc_translucency;
  fglevel = fglevel &amp; ~0x3ff;
  bglevel = FRACUNIT - fglevel;

  fg2rgb = col2rgb8[fglevel &gt;&gt; 10];
  bg2rgb = col2rgb8[bglevel &gt;&gt; 10];

  //
  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  yfrac = dc_yfrac;
  ystep = dc_ystep;
  ymask = (dc_height - 1) &lt;&lt; FRACBITS;

  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  do
  {
    // Re-map colour indices from wall texture column
    // using a lighting/special effects LUT.
    fg = (fg2rgb[dc_colourmap[dc_source[(yfrac &amp; ymask) &gt;&gt; FRACBITS]]] +
        bg2rgb[*dest]) | 0x07c1fc1f;

    *dest = rgb_32k[0][0][fg &amp; (fg &gt;&gt; 17)];

    dest += vb_pitch;
    yfrac += ystep;
  }
  while (--count);
}
</t>
<t tx="T831">void R_DrawHaloColumn8_MIP(void)
{
  int count;
  byte *dest;

  fixed_t yfrac;
  fixed_t ystep;
  fixed_t ymask;

  fixed_t fglevel, bglevel;
  unsigned long fg;  // current colours

  int A = 1, B = 2;
  byte halo_col = 0x50;
    
  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  fglevel = dc_translucency;
  fglevel = fglevel &amp; ~0x3ff;
  bglevel = FRACUNIT - fglevel;

  //
  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  yfrac = dc_yfrac;
  ystep = dc_ystep;
  ymask = (dc_height - 1) &lt;&lt; FRACBITS;

  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  do
  {
    byte val = dc_source[(yfrac &amp; ymask) &gt;&gt; FRACBITS];

    fg = (col2rgb8[val * A / B][halo_col] +
          col2rgb8[64 - val * A / B][*dest]) | 0x07c1fc1f;

    *dest = rgb_32k[0][0][fg &amp; (fg &gt;&gt; 17)];

    dest += vb_pitch;
    yfrac += ystep;
  }
  while (--count);
}
</t>
<t tx="T832">@ These two just return without drawing anything. Used for profiling.
@c

void R_DrawColumn8_dontdraw(void)
{
  return;
}
</t>
<t tx="T833">void R_DrawSpan8_dontdraw(void)
{
  return;
}
</t>
<t tx="T834">#if 0
// -ES- 1999-04-07 Mipmapping test
void R_DrawColumn8_MIP(void)
{
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;
  unsigned long mask;
  fixed_t i;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  //
  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  // create mask, so that scale is at least 1.
  mask = 0xffff0000;
  for (i = abs(fracstep); i &gt; FRACUNIT; i &gt;&gt;= 1)
  {
    mask &lt;&lt;= 1;
  }
  // the masking truncates the frac, so it's a good idea to add this value
  // so that it's rounded instead.
  frac += (0xFFFFFFFF - mask + 1 - FRACUNIT) / 2;
  mask &amp;= 127 * FRACUNIT;
  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  do
  {
    // Re-map colour indices from wall texture column
    // using a lighting/special effects LUT.
    *dest = dc_colourmap[dc_source[((unsigned long)(frac &amp; mask)) &gt;&gt; FRACBITS]];

    dest += vb_pitch;
    frac += fracstep;

  }
  while (--count);
}
#endif</t>
<t tx="T835">@ Original algorithm invented by David Finch (mef@wave.net)
DrawColumn fixed by KM
Added by -ES- 1999/04/19
4-19-00: rewritten by David Finch to look like Unreal
@c
void R_DrawColumn8_vfi(void)
{
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;

#ifdef NOSMOOTHING
  R_DrawColumn8_CVersion();
#else

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 ||
      dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  if (fracstep &gt; 50000)
  {
    do
    {
      // Re-map colour indices from wall texture column
      // using a lighting/special effects LUT.
      *dest = dc_colourmap[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]];

      dest += vb_pitch;
      frac += fracstep;

    }
    while (--count);
  }
  else
  {
    // This routine by David Finch &lt;mef@wave.net&gt;.
 // 4-19-00: rewritten to look like Unreal
    const byte *dcsrc1,*dcsrc2;
    int xa1,ya1,xa2,ya2;

    dc_xfrac &amp;= 0xffff;

// () left out for a reason
#define _a1 10922+32768
#define _a2 32767+32768


 if(dc_x&amp;1) {
  if(dc_yl&amp;1) {
   xa1=-_a2;
   ya1=-_a1;
   xa2=+_a2;
   ya2=+_a1;
  } else {
   xa2=-_a2;
   ya2=-_a1;
   xa1=+_a2;
   ya1=+_a1;
  }
 } else {
  if(dc_yl&amp;1) {
   xa1=_a1;
   ya1=-_a2;
   xa2=-_a1;
   ya2=_a2;
  } else {
   xa2=_a1;
   ya2=-_a2;
   xa1=-_a1;
   ya1=_a2;
  }
 }
 if(xa1+dc_xfrac&gt;65535) dcsrc1=dc_source2; else dcsrc1=dc_source;
 if(xa2+dc_xfrac&gt;65535) dcsrc2=dc_source2; else dcsrc2=dc_source;

 if(count&amp;1) {
  *dest = dc_colourmap[dcsrc1[((frac + ya1) &gt;&gt; 16) &amp; 127]];
  dest += vb_pitch;
  frac += fracstep;
  if(--count) {
   do
   {
    *dest = dc_colourmap[dcsrc2[((frac + ya2) &gt;&gt; 16) &amp; 127]];

    dest += vb_pitch;
    frac += fracstep;

    *dest = dc_colourmap[dcsrc1[((frac + ya1) &gt;&gt; 16) &amp; 127]];
    dest += vb_pitch;
    frac += fracstep;
   }
   while (count-=2);
  }
 } else {
  do
  {
   *dest = dc_colourmap[dcsrc1[((frac + ya1) &gt;&gt; 16) &amp; 127]];
   dest += vb_pitch;
   frac += fracstep;

   *dest = dc_colourmap[dcsrc2[((frac + ya2) &gt;&gt; 16) &amp; 127]];

   dest += vb_pitch;
   frac += fracstep;
  }
  while (count-=2);
 }
  }
#endif
}
</t>
<t tx="T836">@ Original algorithm invented by David Finch (mef@wave.net)
Converted to span routine by KM
Added and improved by -ES- 1999/04/19
4-19-00: rewritten by David Finch to look like Unreal
@c

#define TXTP(x,y) ((y)&amp;(63&lt;&lt;6)) | ((x)&amp;63)
void R_DrawSpan8_vfi(void)
{
  fixed_t xfrac;
  fixed_t yfrac;
  byte *dest;
  int count;
  int spot;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH ||
      (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac;
  yfrac = ds_yfrac;

  dest = ylookup[ds_y] + columnofs[ds_x1];

  count = ds_x2 - ds_x1;

  if (abs(ds_xstep) + abs(ds_ystep) &gt; 65535)
    do
    {
      spot = ((yfrac &gt;&gt; (16 - 6)) &amp; (63 * 64)) + ((xfrac &gt;&gt; 16) &amp; 63);

      *dest++ = ds_colourmap[ds_source[spot]];

      xfrac += ds_xstep;
      yfrac += ds_ystep;
    }
    while (count--);
  else
  {
    int xa1,ya1,xa2,ya2;

    // This routine by David Finch &lt;mef@wave.net&gt;.
 // 4-19-00: rewritten to look like Unreal

    xfrac -= FRACUNIT / 2;
    yfrac -= FRACUNIT / 2;

 if(ds_y&amp;1) {
  if(ds_x1&amp;1) {
   xa1=-_a2;
   ya1=-_a1;
   xa2=+_a2;
   ya2=+_a1;
  } else {
   xa2=-_a2;
   ya2=-_a1;
   xa1=+_a2;
   ya1=+_a1;
  }
 } else {
  if(ds_x1&amp;1) {
   xa1=_a1;
   ya1=-_a2;
   xa2=-_a1;
   ya2=_a2;
  } else {
   xa2=_a1;
   ya2=-_a2;
   xa1=-_a1;
   ya1=_a2;
  }
 }
    do
    {
      *dest++ = ds_colourmap[ds_source[(((xfrac + xa1) &gt;&gt; 16) &amp; 63) |
(((yfrac + ya1) &gt;&gt; 10) &amp; (63 * 64))]];
   xfrac += ds_xstep;
      yfrac += ds_ystep;

   if(!count--) break;

      *dest++ = ds_colourmap[ds_source[(((xfrac + xa2) &gt;&gt; 16) &amp; 63) |
(((yfrac + ya2) &gt;&gt; 10) &amp; (63 * 64))]];
   xfrac += ds_xstep;
      yfrac += ds_ystep;

    }
    while (count--);
  }
}
</t>
<t tx="T837">@ -ES- 1998/12/18 Converted this to 8-bit
@c

void R_DrawColumn8_KM()
{
#ifdef NOSMOOTHING
  R_DrawColumn8_CVersion();
#else
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  // Inner loop that does the actual texture mapping, e.g. a DDA-lile scaling.
  if (fracstep &gt; 0x12000)
  {
    do
    {
      // Re-map colour indices from wall texture column
      // using a lighting/special effects LUT.
      *dest = dc_colourmap[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]];

      dest += vb_pitch;
      frac += fracstep;

    }
    while (--count);
  }
  else
  {
    unsigned long spot[4];
    unsigned long level[4];
    unsigned long c;
    int i;

    dc_xfrac &amp;= 0xffff;
    do
    {
      level[3] = (frac &amp; 0xffff) * dc_xfrac;
      level[2] = (FRACUNIT - (frac &amp; 0xffff)) * dc_xfrac;
      level[1] = (frac &amp; 0xffff) * (FRACUNIT - dc_xfrac - 1);
      level[0] = (FRACUNIT - (frac &amp; 0xffff)) * (FRACUNIT - dc_xfrac - 1);
      spot[0] = dc_source[(frac &gt;&gt; FRACBITS) &amp; 127];
      spot[1] = dc_source[((frac &gt;&gt; FRACBITS) + 1) &amp; 127];
      spot[2] = dc_source2[(frac &gt;&gt; FRACBITS) &amp; 127];
      spot[3] = dc_source2[((frac &gt;&gt; FRACBITS) + 1) &amp; 127];

      for (i = 0, c = 0; i &lt; 4; i++)
      {
        c += col2rgb8[level[i] &gt;&gt; 26][spot[i]];
      }

      // -ES- 1999/03/13 Fixed the RGB conversion
      c |= 0x07c1fc1f;
      *dest = dc_colourmap[rgb_32k[0][0][c &amp; (c &gt;&gt; 17)]];

      dest += vb_pitch;
      frac += fracstep;
    }
    while (--count);
  }
#endif
}
</t>
<t tx="T838">@ -ES- 1999/03/29 Added this
@c

void R_DrawColumn8_BLF()
{
#ifdef NOSMOOTHING
  R_DrawColumn8_CVersion();
#else
  int count;
  byte *dest;
  fixed_t yfrac;
  fixed_t ystep;
  unsigned long col1, col2, col3, col4;
  unsigned long x1, x2, y1, y2;

  if (dc_ystep &gt; 0x20000)
    R_DrawColumn8_CVersion();

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  ystep = dc_ystep;
  yfrac = dc_yfrac - FRACUNIT / 2;

  dc_xfrac &amp;= 0xffff;

  // x position is constant
  x1 = (dc_xfrac &gt;&gt; (16 - BLFshift));
  x2 = BLFmax - x1;

  // Inner loop that does the actual texture mapping, e.g. a DDA-lile scaling.
  do
  {
    col1 = dc_source[(yfrac &gt;&gt; FRACBITS) &amp; 127];
    col2 = dc_source2[(yfrac &gt;&gt; FRACBITS) &amp; 127];
    col3 = dc_source[((yfrac &gt;&gt; FRACBITS) + 1) &amp; 127];
    col4 = dc_source2[((yfrac &gt;&gt; FRACBITS) + 1) &amp; 127];

    // Get the texture sub-coordinates
    y1 = (yfrac &gt;&gt; (16 - BLFshift)) &amp; BLFmax;
    y2 = BLFmax - y1;

    col1 = BLFTab[x2][y2][col1]
        + BLFTab[x1][y2][col2]
        + BLFTab[x2][y1][col3]
        + BLFTab[x1][y1][col4];

    // Convert to usable RGB
    col1 |= 0x07c1fc1f;

    // Store pixel
    *dest = dc_colourmap[rgb_32k[0][0][col1 &amp; (col1 &gt;&gt; 17)]];

    dest += vb_pitch;
    yfrac += ystep;
  }
  while (--count);
#endif
}
</t>
<t tx="T839">@ Spectre/Invisibility.

Creates a fuzzy image by opying pixels from above/below.

Used with an all black colourmap, this creates the FUZZY effect,
i.e. spectres and invisible players.
@c

void R_DrawFuzzColumn8(void)
{
  int count;
  byte *dest;
  int fuzzpos = framecount;

  // Adjust borders. Low...
  if (dc_yl &lt; 6)
    dc_yl = 6;

  count = dc_yh - dc_yl;

  // Zero length.
  if (count &lt; 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  // Does not work with blocky mode.
  dest = ylookup[dc_yl] + columnofs[dc_x];

  do
  {
    fuzzpos = (fuzzpos+1) &amp; 7;

    // Lookup framebuffer, and retrieve a pixel that is zero to seven
    // pixels above the current one.

    *dest = dc_colourmap[dest[-fuzzpos * vb_pitch]];

    dest += vb_pitch;
  }
  while (count--);
}
</t>
<t tx="T840">@ -ES- 1998/10/29 New translucency

-KM- 1998/11/25 Modified rest of EDGE to work with this.

-ES- 1998/02/12 New col2rgb format
@c

void R_DrawTranslucentColumn8()
{
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;

  fixed_t fglevel, bglevel;
  unsigned long *fg2rgb, *bg2rgb;
  unsigned long fg;  // current colours

  fglevel = dc_translucency;
  fglevel = fglevel &amp; ~0x3ff;
  bglevel = FRACUNIT - fglevel;

  fg2rgb = col2rgb8[fglevel &gt;&gt; 10];
  bg2rgb = col2rgb8[bglevel &gt;&gt; 10];

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  dest = ylookup[dc_yl] + columnofs[dc_x];

  fracstep = dc_ystep;
  frac = dc_yfrac;

  do
  {
    /*

       New translucency algorithm, by Erik Sandberg:

       Basically, we compute the red, green and blue values for each pixel, and
       then use a RGB table to check which one of the palette colours that best
       represents those RGB values. The RGB table is 8k big, with 4 R-bits,
       5 G-bits and 4 B-bits. A 4k table gives a bit too bad precision, and a 32k
       table takes up more memory and results in more cache misses, so an 8k
       table seemed to be quite ultimate.

       The computation of the RGB for each pixel is accelerated by using two
       1k tables for each translucency level.
       The xth element of one of these tables contains the r, g and b values for
       the colour x, weighted for the current translucency level (for example,
       the weighted rgb values for background colour at 75% translucency are 1/4
       of the original rgb values). The rgb values are stored as three
       low-precision fixed point values, packed into one long per colour:
       Bit 0-4:   Frac part of blue  (5 bits)
       Bit 5-8:   Int  part of blue  (4 bits)
       Bit 9-13:  Frac part of red   (5 bits)
       Bit 14-17: Int  part of red   (4 bits)
       Bit 18-22: Frac part of green (5 bits)
       Bit 23-27: Int  part of green (5 bits)

       The point of this format is that the two colours now can be added, and
       then be converted to a RGB table index very easily: First, we just set
       all the frac bits and the four upper zero bits to 1. It's now possible
       to get the RGB table index by ORing the current value &gt;&gt; 7 with the
       current value &gt;&gt; 23, and then mask away some high bits by anding it
       with 0x1FFF.

     */

    fg = (fg2rgb[dc_colourmap[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]]] +
        bg2rgb[*dest]) | 0x07c1fc1f;

    *dest = rgb_32k[0][0][fg &amp; (fg &gt;&gt; 17)];

    dest += vb_pitch;
    frac += fracstep;
  }
  while (--count);
}
</t>
<t tx="T841">@ R_DrawTranslatedColumn8

Uses the translation tables to remap one set of palette colours to
another. One prime example is the player greens to the other player
colours.

Could be used with different translation tables, e.g. the lighter coloured
version of the BaronOfHell, the HellKnight, uses identical sprites,
kinda brightened up.

8-Bit Colour Version.
@c

void R_DrawTranslatedColumn8(void)
{
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;

  count = dc_yh - dc_yl;

  if (count &lt; 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Looks familiar.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  // Here we do an additional index re-mapping.
  do
  {
    // Translation tables are used to map certain colourramps to other ones,
    // used with PLAY sprites. Thus the "green" ramp of the player 0 sprite
    // is mapped to gray, red, black/indigo.
    *dest = dc_colourmap[dc_translation[dc_source[frac &gt;&gt; FRACBITS]]];
    dest += vb_pitch;

    frac += fracstep;
  }
  while (count--);
}
</t>
<t tx="T842">@ -ES- 1999/02/12 New col2rgb format
@c

void R_DrawTranslucentTranslatedColumn8()
{
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;

  fixed_t fglevel, bglevel;
  unsigned long *fg2rgb, *bg2rgb;
  unsigned long fg;  // current colours

  fglevel = dc_translucency;
  fglevel = fglevel &amp; ~0x3ff;
  bglevel = FRACUNIT - fglevel;

  fg2rgb = col2rgb8[fglevel &gt;&gt; 10];
  bg2rgb = col2rgb8[bglevel &gt;&gt; 10];

  count = dc_yh - dc_yl + 1;

  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  dest = ylookup[dc_yl] + columnofs[dc_x];

  fracstep = dc_ystep;
  frac = dc_yfrac;

  do
  {
    //
    // This is R_DrawTranslucentColumn with an extra translation table lookup
    //
    fg = (fg2rgb[dc_colourmap[dc_translation[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]]]] +
        bg2rgb[*dest]) | 0x07c1fc1f;

    *dest = rgb_32k[0][0][fg &amp; (fg &gt;&gt; 17)];

    dest += vb_pitch;
    frac += fracstep;
  }
  while (--count);
}
</t>
<t tx="T843">@ With DOOM style restrictions on view orientation, the floors and ceilings
consist of horizontal slices or spans with constant z depth.

However, rotation around the world z axis is possible, thus this mapping,
while simpler and faster than perspective correct texture mapping, has to
traverse the texture at an angle in all but a few cases.

In consequence, flats are not stored by column (like walls), and the inner
loop has to step in texture space u and v.

Draws the actual span.

-ES- 1999/04/19 Optimised slightly
@c

void R_DrawSpan8_CVersion(void)
{
  unsigned long xfrac;
  unsigned long yfrac;
  byte *dest;
  int count;
  int spot;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac &lt;&lt; 10;
  ds_xstep &lt;&lt;= 10;
  yfrac = ds_yfrac;

  dest = ylookup[ds_y] + columnofs[ds_x1];

  count = ds_x2 - ds_x1 + 1;

  do
  {
    // Current texture index in u,v.
    spot = ((yfrac &gt;&gt; (16 - 6)) &amp; (63 * 64)) + (xfrac &gt;&gt; 26);

    // Lookup pixel from flat texture tile,
    // re-index using light/colourmap.
    *dest++ = ds_colourmap[ds_source[spot]];

    // Next step in u,v.
    xfrac += ds_xstep;
    yfrac += ds_ystep;
  }
  while (--count);
}
</t>
<t tx="T844">void R_DrawSpan8_MIP(void)
{
  fixed_t xfrac, yfrac;
  fixed_t xmask, ymask;
  fixed_t xstep, ystep;

  byte *dest;
  int count;
  int spot;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan8_MIP: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac;
  yfrac = ds_yfrac * ds_width;

  xmask = (ds_width-1) &lt;&lt; FRACBITS;
  ymask = ((ds_height-1) * ds_width) &lt;&lt; FRACBITS;

  xstep = ds_xstep;
  ystep = ds_ystep * ds_width;

  dest = ylookup[ds_y] + columnofs[ds_x1];

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  do
  {
    // Current texture index in u,v.  Maximum texture size is 128x128.
    spot = ((yfrac &amp; ymask) + (xfrac &amp; xmask)) &gt;&gt; FRACBITS;

    // Lookup pixel from flat texture tile, re-index using light/colourmap.
    *dest++ = ds_colourmap[ds_source[spot]];

    // Next step in u,v.
    xfrac += xstep;
    yfrac += ystep;
  }
  while (count--);
}
</t>
<t tx="T845">void R_DrawTranslucentSpan8_MIP(void)
{
  fixed_t xfrac, yfrac;
  fixed_t xmask, ymask;
  fixed_t xstep, ystep;

  byte *dest;
  int count;
  int spot;

  fixed_t fglevel, bglevel;
  unsigned long *fg2rgb, *bg2rgb;
  unsigned long fg;  // current colours

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan8_MIP: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  fglevel = dc_translucency;
  fglevel = fglevel &amp; ~0x3ff;
  bglevel = FRACUNIT - fglevel;

  fg2rgb = col2rgb8[fglevel &gt;&gt; 10];
  bg2rgb = col2rgb8[bglevel &gt;&gt; 10];

  xfrac = ds_xfrac;
  yfrac = ds_yfrac * ds_width;

  xmask = (ds_width-1) &lt;&lt; FRACBITS;
  ymask = ((ds_height-1) * ds_width) &lt;&lt; FRACBITS;

  xstep = ds_xstep;
  ystep = ds_ystep * ds_width;

  dest = ylookup[ds_y] + columnofs[ds_x1];

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  do
  {
    // Current texture index in u,v.  Maximum texture size is 128x128.
    spot = ((yfrac &amp; ymask) + (xfrac &amp; xmask)) &gt;&gt; FRACBITS;

    // Lookup pixel from flat texture tile, re-index using light/colourmap.
    fg = (fg2rgb[ds_colourmap[ds_source[spot]]] +
        bg2rgb[*dest]) | 0x07c1fc1f;

    *dest++ = rgb_32k[0][0][fg &amp; (fg &gt;&gt; 17)];

    // Next step in u,v.
    xfrac += xstep;
    yfrac += ystep;
  }
  while (count--);
}
</t>
<t tx="T846">void R_DrawHoleySpan8_MIP(void)
{
  fixed_t xfrac, yfrac;
  fixed_t xmask, ymask;
  fixed_t xstep, ystep;

  byte *dest;
  int count;
  int spot;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan8_MIP: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac;
  yfrac = ds_yfrac * ds_width;

  xmask = (ds_width-1) &lt;&lt; FRACBITS;
  ymask = ((ds_height-1) * ds_width) &lt;&lt; FRACBITS;

  xstep = ds_xstep;
  ystep = ds_ystep * ds_width;

  dest = ylookup[ds_y] + columnofs[ds_x1];

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  do
  {
    // Current texture index in u,v.  Maximum texture size is 128x128.
    spot = ((yfrac &amp; ymask) + (xfrac &amp; xmask)) &gt;&gt; FRACBITS;

    // Lookup pixel from flat texture tile, re-index using light/colourmap.
    if (ds_source[spot] != TRANS_PIXEL)
      *dest++ = ds_colourmap[ds_source[spot]];

    // Next step in u,v.
    dest++;
    xfrac += xstep;
    yfrac += ystep;
  }
  while (count--);
}
</t>
<t tx="T847">@ -AJA- 1999/08/16: Added this.
@c

void R_DrawTranslucentSpan8(void)
{
  unsigned long xfrac;
  unsigned long yfrac;
  byte *dest;
  int count;
  int spot;

  fixed_t fglevel, bglevel;
  unsigned long *fg2rgb, *bg2rgb;
  unsigned long fg;  // current colours

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawTranslucentSpan8: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  fglevel = dc_translucency;
  fglevel = fglevel &amp; ~0x3ff;
  bglevel = FRACUNIT - fglevel;

  fg2rgb = col2rgb8[fglevel &gt;&gt; 10];
  bg2rgb = col2rgb8[bglevel &gt;&gt; 10];

  xfrac = ds_xfrac &lt;&lt; 10;
  ds_xstep &lt;&lt;= 10;
  yfrac = ds_yfrac;

  dest = ylookup[ds_y] + columnofs[ds_x1];

  count = ds_x2 - ds_x1 + 1;

  do
  {
    spot = ((yfrac &gt;&gt; (16 - 6)) &amp; (63 * 64)) + (xfrac &gt;&gt; 26);

    // Lookup pixel from flat texture tile,
    // re-index using light/colourmap, and apply translucency.
    fg = (fg2rgb[ds_colourmap[ds_source[spot]]] +
        bg2rgb[*dest]) | 0x07c1fc1f;

    *dest++ = rgb_32k[0][0][fg &amp; (fg &gt;&gt; 17)];

    xfrac += ds_xstep;
    yfrac += ds_ystep;
  }
  while (--count);
}
</t>
<t tx="T848">#if 0
// -ES- 1999-04-07 Mipmapping test
void R_DrawSpan8_MIP(void)
{
  fixed_t xfrac;
  fixed_t yfrac;
  byte *dest;
  int count;
  int spot;

  unsigned long xmask, ymask;
  unsigned long i;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac;
  yfrac = ds_yfrac;

  dest = ylookup[ds_y] + columnofs[ds_x1];

  count = ds_x2 - ds_x1;

  xmask = 0xffff0000;
  for (i = abs(ds_xstep); i &gt; FRACUNIT; i &gt;&gt;= 1)
    xmask &lt;&lt;= 1;
  xmask &amp;= 63 * FRACUNIT;
  ymask = 0xffff0000;
  for (i = abs(ds_ystep); i &gt; FRACUNIT; i &gt;&gt;= 1)
    ymask &lt;&lt;= 1;
  ymask &amp;= 63 * FRACUNIT;
  do
  {
    spot = ((yfrac &amp; ymask) &gt;&gt; (16 - 6)) + ((xfrac &amp; xmask) &gt;&gt; 16);

    *dest++ = ds_colourmap[ds_source[spot]];

    // Next step in u,v.
    xfrac += ds_xstep;
    yfrac += ds_ystep;
  }
  while (count--);
}
#endif

</t>
<t tx="T849">// -ES- 1998/12/18 Added this one
void R_DrawSpan8_KM(void)
{
  unsigned long xfrac;
  unsigned long yfrac;
  unsigned char *dest;
  int count;
  int spot;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac;
  yfrac = ds_yfrac;

  dest = ylookup[ds_y] + columnofs[ds_x1];

  count = ds_x2 - ds_x1;

  if (((ds_xstep &amp; 0xffff) &gt; FRACUNIT) &amp;&amp; ((ds_ystep &amp; 0xffff) &gt; FRACUNIT))
  {
    do
    {
      spot = ((yfrac &gt;&gt; (FRACBITS - 6)) &amp; (63 * 64)) + ((xfrac &gt;&gt; FRACBITS) &amp; 63);

      *dest++ = dc_colourmap[ds_source[spot]];

      xfrac += ds_xstep;
      yfrac += ds_ystep;

    }
    while (count--);
  }
  else
  {
    unsigned long spot[4];
    unsigned long level[4];

    // current colour
    unsigned long c;
    int i;

    xfrac -= FRACUNIT / 2;
    yfrac -= FRACUNIT / 2;

    do
    {
      spot[0] = ((yfrac &gt;&gt; 16) &amp; 63) * 64 + ((xfrac &gt;&gt; 16) &amp; 63);
      spot[1] = ((yfrac &gt;&gt; 16) &amp; 63) * 64 + (((xfrac &gt;&gt; 16) + 1) &amp; 63);
      spot[2] = (((yfrac &gt;&gt; 16) + 1) &amp; 63) * 64 + ((xfrac &gt;&gt; 16) &amp; 63);
      spot[3] = (((yfrac &gt;&gt; 16) + 1) &amp; 63) * 64 + (((xfrac &gt;&gt; 16) + 1) &amp; 63);

      level[3] = ((yfrac &amp; 0xffff) * (xfrac &amp; 0xffff));
      level[1] = (FRACUNIT - (yfrac &amp; 0xffff) - 1) * (xfrac &amp; 0xffff);
      level[2] = (yfrac &amp; 0xffff) * (FRACUNIT - (xfrac &amp; 0xffff) - 1);
      level[0] = (FRACUNIT - (yfrac &amp; 0xffff) - 1) * (FRACUNIT - (xfrac &amp; 0xffff) - 1);

      for (i = 0, c = 0; i &lt; 4; i++)
      {
        spot[i] = (unsigned long)(ds_source[spot[i]]);
        c += col2rgb8[level[i] &gt;&gt; 26][spot[i]];
      }

      // -ES- 1999/03/13 Fixed the RGB conversion
      c |= 0x07c1fc1f;
      *dest++ = ds_colourmap[rgb_32k[0][0][c &amp; (c &gt;&gt; 17)]];

      xfrac += ds_xstep;
      yfrac += ds_ystep;
    }
    while (count--);
  }
}
</t>
<t tx="T850">@ ------------------------------------------------------------
Bilinear Filtering
16-bit version originally written by Vitek Kavan vit.kavan@usa.net
Improved &amp; converted to 8-bit colour by -ES- 1999/02/12
@c

void R_DrawSpan8_BLF(void)
{
  int count;
  unsigned long col1, col2, col3, col4;
  unsigned long x1, x2, y1, y2;
  unsigned char *dest = (ylookup[ds_y] + columnofs[ds_x1]);
  unsigned long xfrac = ds_xfrac - FRACUNIT / 2;
  unsigned long yfrac = ds_yfrac - FRACUNIT / 2;

  count = ds_x2 - ds_x1;

  do
  {
    // Get the texture coordinates
    y1 = ((yfrac &gt;&gt; 10) &amp; (63 * 64));
    x1 = ((xfrac &gt;&gt; 16) &amp; 63);
    y2 = (y1 + 64) &amp; (63 * 64);
    x2 = (x1 + 1) &amp; 63;

    // Get the colours of the four corners
    col1 = ds_source[y1 + x1];
    col2 = ds_source[y1 + x2];
    col3 = ds_source[y2 + x1];
    col4 = ds_source[y2 + x2];

    // Get the texture sub-coordinates
    x1 = (xfrac &gt;&gt; (16 - BLFshift)) &amp; BLFmax;
    y1 = (yfrac &gt;&gt; (16 - BLFshift)) &amp; BLFmax;
    x2 = BLFmax - x1;
    y2 = BLFmax - y1;

    // Get the fixed-point RGB value
    col1 = BLFTab[x2][y2][col1]
        + BLFTab[x1][y2][col2]
        + BLFTab[x2][y1][col3]
        + BLFTab[x1][y1][col4];

    // Convert to usable RGB
    col1 |= 0x07c1fc1f;

    // Store pixel
    *dest++ = ds_colourmap[rgb_32k[0][0][col1 &amp; (col1 &gt;&gt; 17)]];

    // Next step
    xfrac += ds_xstep;
    yfrac += ds_ystep;
  }
  while (count--);
}
</t>
<t tx="T851">@ R_InitFunctions_Draw1
@c

void R_InitFunctions_Draw1(void)
{
  CON_InitFunctionList(&amp;drawcol8_funcs, "col8", R_DrawColumn8_CVersion, ColSmoothingOff);
  CON_InitFunctionList(&amp;drawspan8_funcs, "span8", R_DrawSpan8_CVersion, SpanSmoothingOff);

  CON_AddFunctionToList(&amp;drawcol8_funcs, "BLF", "Bilinear Filtering", R_DrawColumn8_BLF, BLF_Init8);
  CON_AddFunctionToList(&amp;drawcol8_funcs, "VFI", "Very fast Interpolation", R_DrawColumn8_vfi, ColSmoothingOn);
  CON_AddFunctionToList(&amp;drawcol8_funcs, "KM", "Kester's Smoothing", R_DrawColumn8_KM, ColSmoothingOn);
  CON_AddFunctionToList(&amp;drawcol8_funcs, "None", "Dummy routine, doesn't draw anything", R_DrawColumn8_dontdraw, ColSmoothingOff);

  CON_AddFunctionToList(&amp;drawspan8_funcs, "BLF", "Bilinear Filtering", R_DrawSpan8_BLF, BLF_Init8);
  CON_AddFunctionToList(&amp;drawspan8_funcs, "VFI", "Very fast Interpolation", R_DrawSpan8_vfi, SpanSmoothingOn);
  CON_AddFunctionToList(&amp;drawspan8_funcs, "KM", "Kester's Smoothing", R_DrawSpan8_KM, SpanSmoothingOn);
  CON_AddFunctionToList(&amp;drawspan8_funcs, "None", "Dummy routine, doesn't draw anything", R_DrawSpan8_dontdraw, SpanSmoothingOff);
}
</t>
<t tx="T852">@ Fills the back screen with a pattern for variable screen sizes
Also draws a beveled edge.
@c

void R_FillBackScreen8(void)
{
#if 0  // OLD CODE
  const byte *src;
  byte *dest;
  int x;
  int y;
  const patch_t *patch;

  if ((viewwindowwidth == SCREENWIDTH) &amp;&amp; (viewwindowheight == SCREENHEIGHT))
    return;

  src = W_CacheLumpName(currentmap-&gt;surround);

  for (y = 0; y &lt; back_scr-&gt;height; y++)
  {
    dest = back_scr-&gt;data + back_scr-&gt;pitch * y;
    for (x = 0; x &lt; back_scr-&gt;width / 64; x++)
    {
      Z_MoveData(dest, src + ((y &amp; 63) &lt;&lt; 6), byte, 64);
      dest += 64;
    }

    if (back_scr-&gt;width &amp; 63)
    {
      Z_MoveData(dest, src + ((y &amp; 63) &lt;&lt; 6), byte, back_scr-&gt;width &amp; 63);
    }
  }

  W_DoneWithLump(src);

  if (SCREENWIDTH == viewwindowwidth)
    return;

  if ((viewwindowy - 8) &gt;= 0)
  {
    patch = W_CacheLumpName("brdr_t");
    for (x = 0; x &lt; viewwindowwidth; x += 8)
      V_DrawPatch(back_scr, viewwindowx + x, viewwindowy - 8, patch);
    W_DoneWithLump(patch);
  }

  if ((viewwindowy + viewwindowheight + 8) &lt; (SCREENHEIGHT - SBARHEIGHT))
  {
    patch = W_CacheLumpName("brdr_b");
    for (x = 0; x &lt; viewwindowwidth; x += 8)
      V_DrawPatch(back_scr, viewwindowx + x, viewwindowy + viewwindowheight, patch);
    W_DoneWithLump(patch);
  }

  if ((viewwindowx - 8) &gt;= 0)
  {
    patch = W_CacheLumpName("brdr_l");
    for (y = 0; y &lt; viewwindowheight; y += 8)
      V_DrawPatch(back_scr, viewwindowx - 8, viewwindowy + y, patch);
    W_DoneWithLump(patch);
  }

  if ((viewwindowx + viewwindowwidth + 8) &lt; SCREENWIDTH)
  {
    patch = W_CacheLumpName("brdr_r");
    for (y = 0; y &lt; viewwindowheight; y += 8)
      V_DrawPatch(back_scr, viewwindowx + viewwindowwidth, viewwindowy + y, patch);
    W_DoneWithLump(patch);
  }

  // Draw beveled edge.
  if (((viewwindowx - 8) &gt;= 0) &amp;&amp; ((viewwindowy - 8) &gt;= 0))
  {
    V_DrawPatchName(back_scr, viewwindowx - 8, viewwindowy - 8, "brdr_tl");
  }

  if (((viewwindowx + viewwindowwidth + 8) &lt; SCREENWIDTH) &amp;&amp; ((viewwindowy - 8) &gt;= 0))
  {
    V_DrawPatchName(back_scr, viewwindowx + viewwindowwidth, viewwindowy - 8, "brdr_tr");
  }

  if (((viewwindowx - 8) &gt;= 0) &amp;&amp; ((viewwindowy + viewwindowheight + 8) &lt; (SCREENHEIGHT - SBARHEIGHT)))
  {
    V_DrawPatchName(back_scr, viewwindowx - 8, viewwindowy + viewwindowheight, "brdr_bl");
  }

  if (((viewwindowx + viewwindowwidth + 8) &lt; SCREENWIDTH) &amp;&amp;
      ((viewwindowy + viewwindowheight + 8) &lt; (SCREENHEIGHT - SBARHEIGHT)))
  {
    V_DrawPatchName(back_scr, viewwindowx + viewwindowwidth, viewwindowy + viewwindowheight, "brdr_br");
  }
#endif
}
</t>
<t tx="T853">@ Linear Frame Buffer copy.
@c

void R_VideoErase8(unsigned ofs, int count)
{
#if 0  // OLD CODE
  Z_MoveData(main_scr-&gt;data + ofs, back_scr-&gt;data + ofs, byte, count);
#endif
}
</t>
<t tx="T854">@ Draws the border around the view for different size windows?

-ES- 1999/07/18 Fixed stuff regarding SCREENPITCH
@c

void R_DrawViewBorder8(void)
{
#if 0  // OLD CODE
  int side;
  int ofs;
  int i;

  // if screenwidth&gt;320, draw stuff around status bar, even if
  // viewwindowwidth==SCREENWIDTH
  //
  if ((SCREENWIDTH &gt; 320) &amp;&amp; (SCREENHEIGHT != viewwindowheight))
  {
    ofs = (SCREENHEIGHT - SBARHEIGHT) * SCREENPITCH;
    side = (SCREENWIDTH - 320) / 2;
    for (i = 0; i &lt; SBARHEIGHT; i++)
    {
      R_VideoErase8(ofs, side);
      R_VideoErase8(ofs + SCREENWIDTH - side, side);
      ofs += SCREENPITCH;
    }
  }

  // don't draw stuff over and under viewwindow if there is no space to draw it
  if ((viewwindowy == 0) &amp;&amp; ((viewwindowy + viewwindowheight) &gt;= (SCREENHEIGHT - SBARHEIGHT)))
    return;

  // copy top
  for (i = 0; i &lt; viewwindowy; i++)
    R_VideoErase8(i * SCREENPITCH, SCREENWIDTH);

  // copy left and right side
  for (i = viewwindowy; i &lt; viewwindowy + viewwindowheight; i++)
  {
    // left
    R_VideoErase8(i * SCREENPITCH, viewwindowx);
    // right
    R_VideoErase8(i * SCREENPITCH + viewwindowx + viewwindowwidth,
        SCREENWIDTH - (viewwindowx + viewwindowwidth));
  }

  // copy bottom
  for (i = viewwindowy + viewwindowheight; i &lt; SCREENHEIGHT - SBARHEIGHT; i++)
    R_VideoErase8(i * SCREENPITCH, SCREENWIDTH);

  V_MarkRect(0, 0, SCREENWIDTH, SCREENHEIGHT - SBARHEIGHT);
#endif
}
</t>
<t tx="T855">@ignore
@language c

// Column/Span Drawing for 16-bit Colour Code

// Note: The best place for optimisation!

// -ACB- 1998/09/10 Cleaned up.

&lt;&lt; r_draw2 #includes &gt;&gt;
&lt;&lt; r_draw2 declarations &gt;&gt;
@others

#endif // NOHICOLOUR
</t>
<t tx="T856">#include "i_defs.h"
</t>
<t tx="T857">
#ifndef NOHICOLOUR

#include "r_draw2.h"

#include "con_defs.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "r_local.h"
#include "v_res.h"
#include "v_colour.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"

funclist_t drawcol16_funcs;
funclist_t drawspan16_funcs;

#define FUZZ_SHADE  10  // out of 64

//
// All drawing to the view buffer is accomplished in this file.
//
// The other refresh files only know about ccordinates, not the
// architecture of the frame buffer.
//
// Conveniently, the frame buffer is a linear one, and we need
// only the base address, and the total size.
//

/*
   Here are the necessary changes, written for 0.60 (not 0.64 as I told before).
   If you find my code ugly, than it's not miracle coz I'm Delphi/Pascal/Asm
   programmer and this routine was my first and last experiment with AT&amp;T syntax,
   thanx god for FPC and NASM, I don't have to use it anymore, even in the Linux
   world. The routine is based on look-up table ;-), The BLF_Init routine must
   be called during the start-up. If you think it is not a complete nonsense,
   check it w/ your column routine, it should look great. The precision
   of the filtration can be raised by enlarging the table, but it really slows 
   things down, I plan to check it's behavior using 3Dnow PREFETCH instruction,
   it should help. - Vitek Kavan
 */

// -ES- 1999/01/10 Improved the algorithm a bit: Improved the accuracy
// and decreased the table size from 4 M to 52 K.

#define BLFshift 2  // Detail level. High detail levels look better, but
                   // consume more memory. For each detail increase by one,
                   // the BLF table needs approx. four times as much memory.
#define BLFsz (1&lt;&lt;BLFshift)
#define BLFmax (BLFsz-1)

typedef unsigned long BLF16LUT[256];  // Table with 256 longs containing translucency table-style fix-point RGBs.

static BLF16LUT *BLFTab[BLFsz][BLFsz]; </t>
<t tx="T858">@ Totally 8*8*2 BLF16LUTs
@c

static void ColSmoothingOn(funclist_t *fl GCCATTR(unused))
{
  dc_usesmoothing = true;
}
</t>
<t tx="T859">static void ColSmoothingOff(funclist_t *fl GCCATTR(unused))
{
  dc_usesmoothing = false;
}
</t>
<t tx="T860">static void SpanSmoothingOn(funclist_t *fl GCCATTR(unused))
{
  ds_usesmoothing = true;
}
</t>
<t tx="T861">static void SpanSmoothingOff(funclist_t *fl GCCATTR(unused))
{
  ds_usesmoothing = false;
}
</t>
<t tx="T862">static void BLF_Init16(funclist_t *fl)
{
  static boolean_t firsttime = true;

  unsigned int i;
  unsigned int r, g, b, x, y, xy;
  BLF16LUT *BLFBuf;  // Array of all the used BLF16LUTs

  int BLFCheck[4 * BLFsz * BLFsz];  // Stores which index to BLFBuf a certain x*y should use (x and y are 31.1 fix point)

  int count = 0;

  if (fl-&gt;dest == &amp;R_DrawColumn)
    ColSmoothingOn(fl);
  else if (fl-&gt;dest == &amp;R_DrawSpan)
    SpanSmoothingOn(fl);
  if (!firsttime)
    return;
  firsttime = false;

  I_Printf("BLF_Init: Init Bilinear Filtering");

  // Init BLFCheck
  for (x = 0; x &lt; 4 * BLFsz * BLFsz; x++)
    BLFCheck[x] = -1;
  for (x = 1; x &lt; 2 * BLFsz; x += 2)
    for (y = 1; y &lt; 2 * BLFsz; y += 2)
      if (BLFCheck[x * y] == -1)
      {
        BLFCheck[x * y] = count;
        count++;
      }

  // Allocate the memory if it isn't already allocated. Use 32-byte alignment.
  BLFBuf = BLFTab[0][0];
  if (!BLFBuf)
  {
    // allocate memory
    BLFBuf = (BLF16LUT *) Z_Malloc(count * 2 * sizeof(BLF16LUT) + 31);
    // align
    BLFBuf = (BLF16LUT *) (((long)BLFBuf + 31) &amp; ~31);
  }

  for (x = 0; x &lt; BLFsz; x++)
    for (y = 0; y &lt; BLFsz; y++)
      BLFTab[x][y] = &amp;BLFBuf[2 * BLFCheck[(2 * x + 1) * (2 * y + 1)]];

  for (xy = 0; xy &lt; 4 * BLFsz * BLFsz; xy++)
    if (BLFCheck[xy] != -1)
    {
      for (i = 0; i &lt; 256; i++)
      {
        // Low byte of RGB triplet
        g = (i &amp; 0xE0) &gt;&gt; 5;
        b = i &amp; 0x1F;

        g = ((g * xy) &lt;&lt;
			 5) &gt;&gt; (2 + 2 * BLFshift);
        b = ((b * xy) &lt;&lt;
			 5) &gt;&gt; (2 + 2 * BLFshift);
        (&amp;BLFBuf[2 * BLFCheck[xy]])[0][i] = g | (b &lt;&lt; 11);

        // High byte of RGB triplet
        r = ((i &lt;&lt;
			 8) &amp; 0xF800) &gt;&gt; 11;
        g = ((i &lt;&lt;
			 8) &amp; 0x0700) &gt;&gt; 5;

        r = ((r * xy) &lt;&lt;
			 6) &gt;&gt; (2 + 2 * BLFshift);
        g = ((g * xy) &lt;&lt;
			 5) &gt;&gt; (2 + 2 * BLFshift);
        (&amp;BLFBuf[2 * BLFCheck[xy]])[1][i] = g | (r &lt;&lt; 21);
      }
    }
  I_Printf("\n");
}
</t>
<t tx="T863">@ -----------------------------------------------------------
@c

void resinit_r_draw_c16(void)
{
}
</t>
<t tx="T864">@ A column is a vertical slice/span from a wall texture that, given the
DOOM style restrictions on the view orientation, will always have
constant z depth.

Thus a special case loop for very fast rendering can
be used. It has also been used with Wolfenstein 3D.
@c

void R_DrawColumn16_CVersion(void)
{
  int count;
  byte *dest;
  short *tempcolourmap;
  fixed_t frac;
  fixed_t fracstep;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn16_CVersion: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  // Inner loop that does the actual texture mapping, e.g. a DDA-lile scaling.
  tempcolourmap = (short *)(dc_colourmap);

  do
  {
    // Re-map colour indices from wall texture column
    // using a lighting/special effects LUT.
    *(short *)dest = tempcolourmap[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]];

    dest += vb_pitch;
    frac += fracstep;
  }
  while (--count);
}
</t>
<t tx="T865">@ R_DrawColumn16_MIP
@c

void R_DrawColumn16_MIP(void)
{
  int count;
  byte *dest;
  short *tempcolourmap;

  fixed_t yfrac;
  fixed_t ystep;
  fixed_t ymask;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  //
  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  yfrac = dc_yfrac;
  ystep = dc_ystep;
  ymask = (dc_height - 1) &lt;&lt; FRACBITS;

  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  
  tempcolourmap = (short *)(dc_colourmap);
  
  do
  {
    // Re-map colour indices from wall texture column
    // using a lighting/special effects LUT.
    *(short *)dest = tempcolourmap[dc_source[(yfrac &amp; ymask) &gt;&gt; FRACBITS]];

    dest += vb_pitch;
    yfrac += ystep;
  }
  while (--count);
}
</t>
<t tx="T866">void R_DrawTranslucentColumn16_MIP(void)
{
  int count;
  byte *dest;
  unsigned short *tempcolourmap;

  fixed_t fglevel, bglevel;
  unsigned long c;  // current colour

  fixed_t yfrac;
  fixed_t ystep;
  fixed_t ymask;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  fglevel = (dc_translucency + 1023) / 1040;
  bglevel = 64 - fglevel;

  //
  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  yfrac = dc_yfrac;
  ystep = dc_ystep;
  ymask = (dc_height - 1) &lt;&lt; FRACBITS;

  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  
  tempcolourmap = (unsigned short *)(dc_colourmap);
  
  do
  {
    // Re-map colour indices from wall texture column
    // using a lighting/special effects LUT.
    c = tempcolourmap[dc_source[(yfrac &amp; ymask) &gt;&gt; FRACBITS]];

    c = col2rgb16[fglevel][(unsigned char)c][0] +
        col2rgb16[fglevel][c &gt;&gt; 8][1] +
        col2rgb16[bglevel][((byte *)dest)[0]][0] +
        col2rgb16[bglevel][((byte *)dest)[1]][1];
    c |= hicolourtransmask;

    *(short *)dest = (short)(c &amp; (c &gt;&gt; 16));

    dest += vb_pitch;
    yfrac += ystep;
  }
  while (--count);
}
</t>
<t tx="T867">void R_DrawColumn16_KM(void)
{
#ifdef NOSMOOTHING
  R_DrawColumn16_CVersion();
#else
  int count;
  byte *dest;
  unsigned short *tempcolourmap;
  unsigned long frac;
  unsigned long fracstep;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn16_CVersion: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  // Inner loop that does the actual texture mapping, e.g. a DDA-lile scaling.
  tempcolourmap = (unsigned short *)(dc_colourmap);
  if (fracstep &gt; 0x20000)
  {
    do
    {
      // Re-map colour indices from wall texture column
      // using a lighting/special effects LUT.
      *(short *)dest = tempcolourmap[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]];

      dest += vb_pitch;
      frac += fracstep;

    }
    while (--count);
  }
  else
  {
    unsigned long spot[4];
    unsigned long level[4];
    unsigned long c;
    int i;

    frac -= FRACUNIT / 2;
    dc_xfrac &amp;= 0xffff;
    do
    {
      level[3] = (frac &amp; 0xffff) * dc_xfrac;
      level[2] = (FRACUNIT - (frac &amp; 0xffff) - 1) * dc_xfrac;
      level[1] = (frac &amp; 0xffff) * (FRACUNIT - dc_xfrac - 1);
      level[0] = (FRACUNIT - (frac &amp; 0xffff) - 1) * (FRACUNIT - dc_xfrac - 1);

      spot[0] = tempcolourmap[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]];
      spot[1] = tempcolourmap[dc_source[((frac &gt;&gt; FRACBITS) + 1) &amp; 127]];
      spot[2] = tempcolourmap[dc_source2[(frac &gt;&gt; FRACBITS) &amp; 127]];
      spot[3] = tempcolourmap[dc_source2[((frac &gt;&gt; FRACBITS) + 1) &amp; 127]];

      for (i = 0, c = 0; i &lt; 4; i++)
      {
        level[i] &gt;&gt;= 26;
        c += col2rgb16[level[i]][spot[i] &amp; 0xff][0] + col2rgb16[level[i]][(spot[i] &gt;&gt; 8) &amp; 0xff][1];
      }
      c |= hicolourtransmask;
      c &amp;= c &gt;&gt; 16;
      *(short *)dest = (short)c;

      dest += vb_pitch;
      frac += fracstep;
    }
    while (--count);
  }
#endif
}
</t>
<t tx="T868">@ -ES- 1999/03/29 Added This
@c

void R_DrawColumn16_BLF(void)
{
#ifdef NOSMOOTHING
  R_DrawColumn16_CVersion();
#else
  int count;
  byte *dest;
  unsigned short *tempcolourmap;
  fixed_t yfrac;
  fixed_t ystep;
  unsigned long col1, col2, col3, col4;
  unsigned long x1, x2, y1, y2;

  if (dc_ystep &gt; 0x20000)
    R_DrawColumn16_CVersion();

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn16_CVersion: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  ystep = dc_ystep;
  yfrac = dc_yfrac - FRACUNIT / 2;

  tempcolourmap = (unsigned short *)(dc_colourmap);

  dc_xfrac &amp;= 0xffff;
  x1 = (dc_xfrac &gt;&gt; (16 - BLFshift));
  x2 = BLFmax - x1;

  // Inner loop that does the actual texture mapping, e.g. a DDA-lile scaling.
  do
  {
    col1 = tempcolourmap[dc_source[(yfrac &gt;&gt; FRACBITS) &amp; 127]];
    col2 = tempcolourmap[dc_source2[(yfrac &gt;&gt; FRACBITS) &amp; 127]];
    col3 = tempcolourmap[dc_source[((yfrac &gt;&gt; FRACBITS) + 1) &amp; 127]];
    col4 = tempcolourmap[dc_source2[((yfrac &gt;&gt; FRACBITS) + 1) &amp; 127]];

    // Get the texture sub-coordinates
    y1 = (yfrac &gt;&gt; (16 - BLFshift)) &amp; BLFmax;
    y2 = BLFmax - y1;

    col1 = BLFTab[x2][y2][0][col1 &amp; 0xff]
        + BLFTab[x2][y2][1][col1 &gt;&gt; 8]
        + BLFTab[x1][y2][0][col2 &amp; 0xff]
        + BLFTab[x1][y2][1][col2 &gt;&gt; 8]
        + BLFTab[x2][y1][0][col3 &amp; 0xff]
        + BLFTab[x2][y1][1][col3 &gt;&gt; 8]
        + BLFTab[x1][y1][0][col4 &amp; 0xff]
        + BLFTab[x1][y1][1][col4 &gt;&gt; 8];

    // Convert to usable RGB
    col1 |= 0x07E0F81F;
    col1 &amp;= col1 &gt;&gt; 16;

    // Store pixel
    *(short *)dest = (short)col1;

    // Next step
    dest += vb_pitch;
    yfrac += ystep;
  }
  while (--count);

#endif
}
</t>
<t tx="T869">@ Creates a fuzzy image by copying pixels from above/below.

Used with an all black colourmap, this could create the FUZZY effect,
i.e. spectres and invisible players.
@c

void R_DrawFuzzColumn16(void)
{
  int count;
  byte *dest;
  unsigned long c;
  unsigned short fuzzcol = ((short *)dc_colourmap)[0];
  int fuzzpos = framecount;

  // Adjust borders. Low...
  if (dc_yl &lt; 6)
    dc_yl = 6;

  count = dc_yh - dc_yl;

  // Zero length.
  if (count &lt; 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawFuzzColumn16: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  dest = ylookup[dc_yl] + columnofs[dc_x];

  do
  {
    fuzzpos = (fuzzpos + 1) &amp; 7;

    // Lookup framebuffer, and retrieve a pixel that is zero to seven
    // pixels above the current one.

    c = col2rgb16[64-FUZZ_SHADE][dest[-fuzzpos*vb_pitch+0]][0] +
        col2rgb16[64-FUZZ_SHADE][dest[-fuzzpos*vb_pitch+1]][1] +
        col2rgb16[FUZZ_SHADE][fuzzcol &amp; 0xFF][0] +
        col2rgb16[FUZZ_SHADE][fuzzcol &gt;&gt; 8][1];
    c |= hicolourtransmask;
    *(short *)dest = (short)(c &amp; (c &gt;&gt; 16));

    dest += vb_pitch;
  }
  while (count--);
}
</t>
<t tx="T870">@ -ES- 1998/11/08 New tranlsucency. It's slow, but it works.
-KM- 1998/11/25 Modified for use with new trans system. (dc_translucency)
-ES- 1998/11/29 Improved the translucency algorithm.
@c

void R_DrawTranslucentColumn16()
{
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;

  fixed_t fglevel, bglevel;
  unsigned long c;  // current colour

#if FADER
  if (dc_translucency == 0x8000)
    fglevel = abs(256 - (leveltime &amp; 0x1ff)) &lt;&lt; 8;
#endif

/*  fglevel = fglevel&amp;~0x3ff;
   bglevel = FRACUNIT-fglevel;
   fglevel &gt;&gt;= 10;
   bglevel &gt;&gt;= 10;
 */
  fglevel = (dc_translucency + 1023) / 1040;
  bglevel = 64 - fglevel;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  //
  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  //
  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  //
  do
  {
    c = ((unsigned short *)dc_colourmap)[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]];
    c = col2rgb16[fglevel][(unsigned char)c][0] +
        col2rgb16[fglevel][c &gt;&gt; 8][1] +
        col2rgb16[bglevel][dest[0]][0] +
        col2rgb16[bglevel][dest[1]][1];
    c |= hicolourtransmask;
    *(short *)dest = (short)(c &amp; (c &gt;&gt; 16));
    dest += vb_pitch;
    frac += fracstep;
  }
  while (--count);
}
</t>
<t tx="T871">@ Uses the translation tables to remap one set of palette colours to
another. One prime example is the player greens to the other player
colours.

Could be used with different translation tables, e.g. the lighter coloured
version of the BaronOfHell, the HellKnight, uses identical sprites,
kinda brightened up.

16-Bit Version.

-ES- 1998/11/29 Improved the translucency algorithm.
@c

void R_DrawTranslatedColumn16(void)
{
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;
  short *tempcolourmap;

  count = dc_yh - dc_yl;

  if (count &lt; 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawTranslatedColumn16: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Looks familiar.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  // Here we do an additional index re-mapping.
  tempcolourmap = (short *)dc_colourmap;

  do
  {
    *(short *)dest = tempcolourmap[dc_translation[dc_source[frac &gt;&gt; FRACBITS]]];
    dest += vb_pitch;

    frac += fracstep;
  }
  while (count--);
}
</t>
<t tx="T872">void R_DrawTranslucentTranslatedColumn16()
{
  int count;
  byte *dest;
  fixed_t frac;
  fixed_t fracstep;

  fixed_t fglevel, bglevel;
  unsigned long c;  // current colour

  fglevel = dc_translucency;
#if FADER
  if (dc_translucency == 0x8000)
    fglevel = abs(256 - (leveltime &amp; 0x1ff)) &lt;&lt; 8;
#endif
  fglevel = fglevel &amp; ~0x3ff;
  bglevel = FRACUNIT - fglevel;
  fglevel &gt;&gt;= 10;
  bglevel &gt;&gt;= 10;

  count = dc_yh - dc_yl + 1;

  // Zero length, column does not exceed a pixel.
  if (count &lt;= 0)
    return;

#ifdef DEVELOPERS
  if ((unsigned int)dc_x &gt;= (unsigned int)SCREENWIDTH || dc_yl &lt; 0 || dc_yh &gt;= SCREENHEIGHT)
    I_Error("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);
#endif

  //
  // Framebuffer destination address.
  // Use ylookup LUT to avoid multiply with ScreenWidth.
  //
  dest = ylookup[dc_yl] + columnofs[dc_x];

  // Determine scaling, which is the only mapping to be done.
  fracstep = dc_ystep;
  frac = dc_yfrac;

  //
  // Inner loop that does the actual texture mapping,
  // e.g. a DDA-lile scaling. This is as fast as it gets.
  //
  do
  {
    c = ((unsigned short *)dc_colourmap)[dc_translation[dc_source[(frac &gt;&gt; FRACBITS) &amp; 127]]];
    c = col2rgb16[fglevel][(unsigned char)c][0] +
        col2rgb16[fglevel][c &gt;&gt; 8][1] +
        col2rgb16[bglevel][dest[0]][0] +
        col2rgb16[bglevel][dest[1]][1];
    c |= hicolourtransmask;
    *(short *)dest = (short)(c &amp; (c &gt;&gt; 16));
    dest += vb_pitch;
    frac += fracstep;
  }
  while (--count);
}
</t>
<t tx="T873">@ With DOOM style restrictions on view orientation,
the floors and ceilings consist of horizontal slices
or spans with constant z depth.

However, rotation around the world z axis is possible,
thus this mapping, while simpler and faster than
perspective correct texture mapping, has to traverse
the texture at an angle in all but a few cases.

In consequence, flats are not stored by column (like walls),
and the inner loop has to step in texture space u and v.
@c

void R_DrawSpan16_CVersion(void)
{
  fixed_t xfrac;
  fixed_t yfrac;
  short *dest;
  int count;
  int spot;
  short *tempcolourmap;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan16_CVersion: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac;
  yfrac = ds_yfrac;

  dest = (short *)(ylookup[ds_y] + columnofs[ds_x1]);

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  tempcolourmap = (short *)ds_colourmap;

  do
  {
    // Current texture index in u,v.
    spot = ((yfrac &gt;&gt; (FRACBITS - 6)) &amp; (63 * 64)) + ((xfrac &gt;&gt; FRACBITS) &amp; 63);

    // Lookup pixel from flat texture tile, re-index using light/colourmap.
    *dest++ = tempcolourmap[ds_source[spot]];

    // Next step in u,v.
    xfrac += ds_xstep;
    yfrac += ds_ystep;
  }
  while (count--);
}
</t>
<t tx="T874">void R_DrawSpan16_MIP(void)
{
  fixed_t xfrac, yfrac;
  fixed_t xmask, ymask;
  fixed_t xstep, ystep;

  short *dest;
  int count;
  int spot;
  short *tempcolourmap;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan16_MIP: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac * ds_height;
  xstep = ds_xstep * ds_height;
  xmask = ((ds_width-1) &lt;&lt; FRACBITS) * ds_height;

  yfrac = ds_yfrac;
  ystep = ds_ystep;
  ymask = (ds_height-1) &lt;&lt; FRACBITS;

  dest = (short *)(ylookup[ds_y] + columnofs[ds_x1]);

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  tempcolourmap = (short *)ds_colourmap;

  do
  {
    // Current texture index in u,v.  Maximum texture size is 128x128.
    spot = ((yfrac &amp; ymask) + (xfrac &amp; xmask)) &gt;&gt; FRACBITS;

    // Lookup pixel from flat texture tile, re-index using light/colourmap.
    *dest++ = tempcolourmap[ds_source[spot]];

    // Next step in u,v.
    xfrac += xstep;
    yfrac += ystep;
  }
  while (count--);
}
</t>
<t tx="T875">void R_DrawTranslucentSpan16_MIP(void)
{
  fixed_t xfrac, yfrac;
  fixed_t xmask, ymask;
  fixed_t xstep, ystep;

  short *dest;
  int count;
  int spot;
  unsigned short *tempcolourmap;

  fixed_t fglevel, bglevel;
  unsigned long c;  // current colour

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan16_MIP: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  fglevel = (dc_translucency + 1023) / 1040;
  bglevel = 64 - fglevel;

  xfrac = ds_xfrac;
  yfrac = ds_yfrac * ds_width;

  xmask = (ds_width-1) &lt;&lt; FRACBITS;
  ymask = ((ds_height-1) * ds_width) &lt;&lt; FRACBITS;

  xstep = ds_xstep;
  ystep = ds_ystep * ds_width;

  dest = (short *)(ylookup[ds_y] + columnofs[ds_x1]);

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  tempcolourmap = (unsigned short *)ds_colourmap;

  do
  {
    // Current texture index in u,v.  Maximum texture size is 128x128.
    spot = ((yfrac &amp; ymask) + (xfrac &amp; xmask)) &gt;&gt; FRACBITS;

    c = tempcolourmap[ds_source[spot]];

    c = col2rgb16[fglevel][(unsigned char)c][0] +
        col2rgb16[fglevel][c &gt;&gt; 8][1] +
        col2rgb16[bglevel][((byte *)dest)[0]][0] +
        col2rgb16[bglevel][((byte *)dest)[1]][1];
    c |= hicolourtransmask;

    *dest++ = (short)(c &amp; (c &gt;&gt; 16));

    // Next step in u,v.
    xfrac += xstep;
    yfrac += ystep;
  }
  while (count--);
}
</t>
<t tx="T876">void R_DrawHoleySpan16_MIP(void)
{
  fixed_t xfrac, yfrac;
  fixed_t xmask, ymask;
  fixed_t xstep, ystep;

  short *dest;
  int count;
  int spot;
  short *tempcolourmap;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawHoleySpan16_MIP: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac;
  yfrac = ds_yfrac * ds_width;

  xmask = (ds_width-1) &lt;&lt; FRACBITS;
  ymask = ((ds_height-1) * ds_width) &lt;&lt; FRACBITS;

  xstep = ds_xstep;
  ystep = ds_ystep * ds_width;

  dest = (short *)(ylookup[ds_y] + columnofs[ds_x1]);

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  tempcolourmap = (short *)ds_colourmap;

  do
  {
    // Current texture index in u,v.  Maximum texture size is 128x128.
    spot = ((yfrac &amp; ymask) + (xfrac &amp; xmask)) &gt;&gt; FRACBITS;

    // Lookup pixel from flat texture tile, re-index using light/colourmap.
    if (ds_source[spot] != TRANS_PIXEL)
      *dest = tempcolourmap[ds_source[spot]];

    // Next step in u,v.
    dest++;
    xfrac += xstep;
    yfrac += ystep;
  }
  while (count--);
}
</t>
<t tx="T877">void R_DrawTranslucentSpan16(void)
{
  fixed_t xfrac;
  fixed_t yfrac;
  short *dest;
  int count;
  int spot;
  unsigned short *tempcolourmap;

  fixed_t fglevel, bglevel;
  unsigned long c;  // current colour

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan16_CVersion: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  fglevel = (dc_translucency + 1023) / 1040;
  bglevel = 64 - fglevel;

  xfrac = ds_xfrac;
  yfrac = ds_yfrac;

  dest = (short *)(ylookup[ds_y] + columnofs[ds_x1]);

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  tempcolourmap = (unsigned short *)ds_colourmap;

  do
  {
    // Current texture index in u,v.
    spot = ((yfrac &gt;&gt; (FRACBITS - 6)) &amp; (63 * 64)) + ((xfrac &gt;&gt; FRACBITS) &amp; 63);

    c = tempcolourmap[ds_source[spot]];

    c = col2rgb16[fglevel][(unsigned char)c][0] +
        col2rgb16[fglevel][c &gt;&gt; 8][1] +
        col2rgb16[bglevel][((byte *)dest)[0]][0] +
        col2rgb16[bglevel][((byte *)dest)[1]][1];
    c |= hicolourtransmask;

    *dest++ = (short)(c &amp; (c &gt;&gt; 16));

    // Next step in u,v.
    xfrac += ds_xstep;
    yfrac += ds_ystep;

  }
  while (count--);
}
</t>
<t tx="T878">@ -KM- 1998/11/25 Finished this. It is *REAL* slow. Make sure you have the hardware.
@c

void R_DrawSpan16_KM(void)
{
  unsigned long xfrac;
  unsigned long yfrac;
  short *dest;
  int count;
  int spot;
  short *tempcolourmap;

#ifdef DEVELOPERS
  if (ds_x2 &lt; ds_x1 || ds_x1 &lt; 0 || ds_x2 &gt;= SCREENWIDTH || (unsigned int)ds_y &gt; (unsigned int)SCREENHEIGHT)
    I_Error("R_DrawSpan16_CVersion: %i to %i at %i", ds_x1, ds_x2, ds_y);
#endif

  xfrac = ds_xfrac;
  yfrac = ds_yfrac;

  dest = (short *)(ylookup[ds_y] + columnofs[ds_x1]);

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  if (((ds_xstep &amp; 0xffff) &gt; FRACUNIT) &amp;&amp; ((ds_ystep &amp; 0xffff) &gt; FRACUNIT))
  {
    tempcolourmap = (short *)ds_colourmap;
    do
    {
      // Current texture index in u,v.
      spot = ((yfrac &gt;&gt; (FRACBITS - 6)) &amp; (63 * 64)) + ((xfrac &gt;&gt; FRACBITS) &amp; 63);

      // Lookup pixel from flat texture tile, re-index using light/colourmap.
      *dest++ = tempcolourmap[ds_source[spot]];

      // Next step in u,v.
      xfrac += ds_xstep;
      yfrac += ds_ystep;

    }
    while (count--);
  }
  else
  {
    unsigned long spot[4];
    unsigned long level[4];
    unsigned long c;  // current colour

    int i;

    xfrac -= FRACUNIT / 2;
    yfrac -= FRACUNIT / 2;
    do
    {
      spot[0] = ((yfrac &gt;&gt; 16) &amp; 63) * 64 + ((xfrac &gt;&gt; 16) &amp; 63);
      spot[1] = ((yfrac &gt;&gt; 16) &amp; 63) * 64 + (((xfrac &gt;&gt; 16) + 1) &amp; 63);
      spot[2] = (((yfrac &gt;&gt; 16) + 1) &amp; 63) * 64 + ((xfrac &gt;&gt; 16) &amp; 63);
      spot[3] = (((yfrac &gt;&gt; 16) + 1) &amp; 63) * 64 + (((xfrac &gt;&gt; 16) + 1) &amp; 63);

      level[3] = (yfrac &amp; 0xffff) * (xfrac &amp; 0xffff);
      level[1] = (FRACUNIT - (yfrac &amp; 0xffff) - 1) * (xfrac &amp; 0xffff);
      level[2] = (yfrac &amp; 0xffff) * (FRACUNIT - (xfrac &amp; 0xffff) - 1);
      level[0] = (FRACUNIT - (yfrac &amp; 0xffff)) * (FRACUNIT - (xfrac &amp; 0xffff) - 1);

      for (i = 0, c = 0; i &lt; 4; i++)
      {
        level[i] &gt;&gt;= 26;
        spot[i] = (unsigned long)(((unsigned short *)ds_colourmap)[ds_source[spot[i]]]);
        c += col2rgb16[level[i]][spot[i] &amp; 0xff][0] + col2rgb16[level[i]][(spot[i] &gt;&gt; 8) &amp; 0xff][1];
      }
      c |= hicolourtransmask;
      c &amp;= c &gt;&gt; 16;

      *dest++ = (short)c;

      // Next step in u,v.
      xfrac += ds_xstep;
      yfrac += ds_ystep;
    }
    while (count--);
  }
}
</t>
<t tx="T879">@ ------------------------------------------------------------
Bilinear Filtering by Vitek Kavan vit.kavan@usa.net
-ES- 1999/01/10 Improved the algorithm
@c

void R_DrawSpan16_BLF(void)
{
  int count;
  unsigned long col1, col2, col3, col4;
  unsigned long x1, x2, y1, y2;
  short *dest = (short *)(ylookup[ds_y] + columnofs[ds_x1]);
  unsigned short *tempcolourmap = (unsigned short *)ds_colourmap;
  unsigned long xfrac = ds_xfrac - FRACUNIT / 2;
  unsigned long yfrac = ds_yfrac - FRACUNIT / 2;

  // We do not check for zero spans here?
  count = ds_x2 - ds_x1;

  do
  {
    // Get the texture coordinates
    y1 = ((yfrac &gt;&gt; 10) &amp; (63 * 64));
    x1 = ((xfrac &gt;&gt; 16) &amp; 63);
    y2 = (y1 + 64) &amp; (63 * 64);
    x2 = (x1 + 1) &amp; 63;

    // Get the colours of the four corners
    col1 = tempcolourmap[ds_source[y1 + x1]];
    col2 = tempcolourmap[ds_source[y1 + x2]];
    col3 = tempcolourmap[ds_source[y2 + x1]];
    col4 = tempcolourmap[ds_source[y2 + x2]];

    // Get the texture sub-coordinates
    x1 = (xfrac &gt;&gt; (16 - BLFshift)) &amp; BLFmax;
    y1 = (yfrac &gt;&gt; (16 - BLFshift)) &amp; BLFmax;
    x2 = BLFmax - x1;
    y2 = BLFmax - y1;

    // Get the fixed-point RGB value
    col1 = BLFTab[x2][y2][0][col1 &amp; 0xff]
        + BLFTab[x2][y2][1][col1 &gt;&gt; 8]
        + BLFTab[x1][y2][0][col2 &amp; 0xff]
        + BLFTab[x1][y2][1][col2 &gt;&gt; 8]
        + BLFTab[x2][y1][0][col3 &amp; 0xff]
        + BLFTab[x2][y1][1][col3 &gt;&gt; 8]
        + BLFTab[x1][y1][0][col4 &amp; 0xff]
        + BLFTab[x1][y1][1][col4 &gt;&gt; 8];

    // Convert to usable RGB
    col1 |= 0x07E0F81F;
    col1 &amp;= col1 &gt;&gt; 16;

    // Store pixel
    *dest++ = (short)col1;

    // Next step
    xfrac += ds_xstep;
    yfrac += ds_ystep;
  }
  while (count--);
}
</t>
<t tx="T880">@ Adds all hicolour rendering functions
@c

void R_InitFunctions_Draw2(void)
{
  CON_InitFunctionList(&amp;drawcol16_funcs, "col16", R_DrawColumn16_CVersion, ColSmoothingOff);
  CON_InitFunctionList(&amp;drawspan16_funcs, "span16", R_DrawSpan16_CVersion, SpanSmoothingOff);

  CON_AddFunctionToList(&amp;drawcol16_funcs, "BLF", "Bilinear Filtering", R_DrawColumn16_BLF, BLF_Init16);
  CON_AddFunctionToList(&amp;drawcol16_funcs, "KM", "Kester's Smoothing", R_DrawColumn16_KM, ColSmoothingOn);

  CON_AddFunctionToList(&amp;drawspan16_funcs, "BLF", "Bilinear Filtering", R_DrawSpan16_BLF, BLF_Init16);
  CON_AddFunctionToList(&amp;drawspan16_funcs, "KM", "Kester's Smoothing", R_DrawSpan16_KM, SpanSmoothingOn);
}
</t>
<t tx="T881">@ Fills the back screen with a pattern for variable screen sizes
Also draws a beveled edge.
@c

void R_FillBackScreen16(void)
{
#if 0  // OLD CODE
  const byte *src;
  const byte *tempsrc;
  short *dest;
  int x;
  int y;
  const patch_t *patch;

  if ((viewwindowwidth == SCREENWIDTH) &amp;&amp; (viewwindowheight == SCREENHEIGHT))
    return;

  src = W_CacheLumpName(currentmap-&gt;surround);

  for (y = 0; y &lt; SCREENHEIGHT; y++)
  {
    tempsrc = src + ((y &amp; 63) &lt;&lt; 6);
    dest = (short *)(back_scr-&gt;data + back_scr-&gt;pitch * y);

    for (x = 0; x &lt; back_scr-&gt;width; x++)
    {
      *dest = (short)pixel_values[tempsrc[x &amp; 63]];
      dest++;
    }
  }

  W_DoneWithLump(src);

  if (SCREENWIDTH == viewwindowwidth)
    return;

  if ((viewwindowy - 8) &gt;= 0)
  {
    patch = W_CacheLumpName("brdr_t");
    for (x = 0; x &lt; viewwindowwidth; x += 8)
      V_DrawPatch(back_scr, viewwindowx + x, viewwindowy - 8, patch);
    W_DoneWithLump(patch);
  }

  if ((viewwindowy + viewwindowheight + 8) &lt; (SCREENHEIGHT - SBARHEIGHT))
  {
    patch = W_CacheLumpName("brdr_b");
    for (x = 0; x &lt; viewwindowwidth; x += 8)
      V_DrawPatch(back_scr, viewwindowx + x, viewwindowy + viewwindowheight, patch);
    W_DoneWithLump(patch);
  }

  if ((viewwindowx - 8) &gt;= 0)
  {
    patch = W_CacheLumpName("brdr_l");
    for (y = 0; y &lt; viewwindowheight; y += 8)
      V_DrawPatch(back_scr, viewwindowx - 8, viewwindowy + y, patch);
    W_DoneWithLump(patch);
  }

  if ((viewwindowx + viewwindowwidth + 8) &lt; SCREENWIDTH)
  {
    patch = W_CacheLumpName("brdr_r");
    for (y = 0; y &lt; viewwindowheight; y += 8)
      V_DrawPatch(back_scr, viewwindowx + viewwindowwidth, viewwindowy + y, patch);
    W_DoneWithLump(patch);
  }

  // Draw beveled edge.
  if (((viewwindowx - 8) &gt;= 0) &amp;&amp; ((viewwindowy - 8) &gt;= 0))
  {
    V_DrawPatchName(back_scr, viewwindowx - 8, viewwindowy - 8, "brdr_tl");
  }

  if (((viewwindowx + viewwindowwidth + 8) &lt; SCREENWIDTH) &amp;&amp; ((viewwindowy - 8) &gt;= 0))
  {
    V_DrawPatchName(back_scr, viewwindowx + viewwindowwidth, viewwindowy - 8, "brdr_tr");
  }

  if (((viewwindowx - 8) &gt;= 0) &amp;&amp; ((viewwindowy + viewwindowheight + 8) &lt; (SCREENHEIGHT - SBARHEIGHT)))
  {
    V_DrawPatchName(back_scr, viewwindowx - 8, viewwindowy + viewwindowheight, "brdr_bl");
  }

  if (((viewwindowx + viewwindowwidth + 8) &lt; SCREENWIDTH) &amp;&amp;
      ((viewwindowy + viewwindowheight + 8) &lt; (SCREENHEIGHT - SBARHEIGHT)))
  {
    V_DrawPatchName(back_scr, viewwindowx + viewwindowwidth, viewwindowy + viewwindowheight, "brdr_br");
  }
#endif
}
</t>
<t tx="T882">@ Copy a screen buffer.

ofs shows the number of bytes to skip before drawing, count shows the
number of pixels to copy.
@c

void R_VideoErase16(unsigned ofs, int count)
{
#if 0  // OLD CODE
  Z_MoveData(main_scr-&gt;data + ofs, back_scr-&gt;data + ofs, byte, sizeof(short) * count);
#endif
}
</t>
<t tx="T883">@ R_DrawViewBorder
Draws the border around the view
for different size windows?

-ES- 1999/07/18 Fixed stuff regarding SCREENPITCH
@c

void R_DrawViewBorder16(void)
{
#if 0  // OLD CODE
  int side;
  int ofs;
  int i;

  // if screenwidth&gt;320, draw stuff around status bar, even if
  // viewwindowwidth==SCREENWIDTH
  if ((SCREENWIDTH &gt; 320) &amp;&amp; (SCREENHEIGHT != viewwindowheight))
  {
    ofs = (SCREENHEIGHT - SBARHEIGHT) * SCREENPITCH;
    side = (SCREENWIDTH - 320) / 2;

    for (i = 0; i &lt; SBARHEIGHT; i++)
    {
      R_VideoErase16(ofs, side);
      R_VideoErase16(ofs + 2 * (SCREENWIDTH - side), side);
      ofs += SCREENPITCH;
    }
  }

  // don't draw stuff over and under viewwindow if there is no space to draw it
  if ((viewwindowy == 0) &amp;&amp; ((viewwindowy + viewwindowheight) &gt;= (SCREENHEIGHT - SBARHEIGHT)))
    return;

  // copy top
  for (i = 0; i &lt; viewwindowy; i++)
    R_VideoErase16(i * SCREENPITCH, SCREENWIDTH);

  // copy left and right side
  for (i = viewwindowy; i &lt; viewwindowy + viewwindowheight; i++)
  {
    // left
    R_VideoErase16(i * SCREENPITCH, viewwindowx);
    // right
    R_VideoErase16(i * SCREENPITCH + 2 * (viewwindowx + viewwindowwidth),
        SCREENWIDTH - (viewwindowx + viewwindowwidth));
  }

  // copy bottom
  for (i = viewwindowy + viewwindowheight; i &lt; SCREENHEIGHT - SBARHEIGHT; i++)
    R_VideoErase16(i * SCREENPITCH, SCREENWIDTH);

/*
   //    if (viewwindowwidth == SCREENWIDTH)
   if (viewwindowheight&gt;=(SCREENHEIGHT-SBARHEIGHT))
   return;

   top = ((SCREENHEIGHT-SBARHEIGHT)-viewwindowheight)/2; 
   side = (SCREENWIDTH-viewwindowwidth)/2; 

   // copy top and one line of left side 
   R_VideoErase16 (0, top*SCREENWIDTH+side);

   // copy one line of right side and bottom 
   ofs = (viewwindowheight+top)*SCREENWIDTH-side; 
   R_VideoErase16 (ofs, top*SCREENWIDTH+side);

   // copy sides using wraparound 
   ofs = top*SCREENWIDTH + SCREENWIDTH-side; 
   side &lt;&lt;= 1;

   for (i=1 ; i&lt;viewwindowheight ; i++) 
   { 
   R_VideoErase16 (ofs, side);
   ofs += SCREENWIDTH; 
   }
 */
  V_MarkRect(0, 0, SCREENWIDTH, SCREENHEIGHT - SBARHEIGHT);
#endif
}
</t>
<t tx="T884">@ignore
@language c

// Layer Rendering System

//  See the file "docs/layersys.txt" for a complete description of the layer system.

//  -AJA- 2000/06/13: Started work on this file.

&lt;&lt; r_layers #includes &gt;&gt;
&lt;&lt; r_layers declarations &gt;&gt;
@others

#endif // USE_LAYERS
</t>
<t tx="T885">#include "i_defs.h"
#include "r_layers.h"

#include "dm_state.h"
#include "m_bbox.h"
#include "m_fixed.h"
#include "r_data.h"
#include "r_main.h"
#include "z_zone.h"
</t>
<t tx="T886">

#ifdef USE_LAYERS


layer_t *layer_list = NULL;


layer_t ** solid_rects = NULL;
int num_solid_rects = 0;
int max_solid_rects = 0;


static void ResizeLayerList(layer_t *list, int x1, int y1, int x2, int y2);
</t>
<t tx="T887">@ R_LayerInit

Initialise the layer system.
@c

boolean_t R_LayerInit(void)
{
  // nothing to do
  return true;
}
</t>
<t tx="T888">@ R_LayerNew

Create a new layer.
@c

layer_t *R_LayerNew(int depth, int x1, int y1, int x2, int y2,
    layerflags_e flags, void *private)
{
  layer_t *layer;

  DEV_ASSERT2(x1 &gt;= 0);
  DEV_ASSERT2(y1 &gt;= 0);
  DEV_ASSERT2(x2 &gt;= x1);
  DEV_ASSERT2(y2 &gt;= y1);
  DEV_ASSERT2(depth &gt;= 0);

  layer = Z_ClearNew(layer_t, 1);

  layer-&gt;x1 = x1;
  layer-&gt;y1 = y1;
  layer-&gt;x2 = x2;
  layer-&gt;y2 = y2;

  layer-&gt;depth = depth;
  layer-&gt;flags = flags;
  layer-&gt;private = private;

  return layer;
}
</t>
<t tx="T889">@ R_LayerDestroy

Destroy a layer. The layer *must* not be in a list somewhere. Any
child layers are also destroyed (by recursively calling this
routine). If the `private' field is not NULL, Z_Free() will be
called on it.
@c

void R_LayerDestroy(layer_t *layer)
{
  if (layer-&gt;private)
    Z_Free(layer-&gt;private);
  
  while (layer-&gt;children)
  {
    layer_t *cur = layer-&gt;children;
    layer-&gt;children = cur-&gt;next;

    R_LayerDestroy(cur);
  }

  Z_Free(layer);
}
</t>
<t tx="T890">@ R_LayerAdd

Add a layer to the parent layer, which can be NULL for the top
level layer list. The layers in the list are depth sorted, higher
values occur later in the list.
@c

void R_LayerAdd(layer_t *parent, layer_t *layer)
{
  layer_t ** parent_list = &amp;layer_list;

  if (layer-&gt;parent)
    parent_list = &amp;layer-&gt;parent-&gt;children;

  if (!(*parent_list) || (*parent_list)-&gt;depth &gt;= layer-&gt;depth)
  {
    // add to head

    layer-&gt;next = (*parent_list);
    layer-&gt;prev = NULL;

    if (*parent_list)
      (*parent_list)-&gt;prev = layer;
    
    (*parent_list) = layer;
  }
  else
  {
    // link in after some other node

    layer_t *cur = (*parent_list);

    DEV_ASSERT2(cur);

    while (cur &amp;&amp; cur-&gt;next &amp;&amp; cur-&gt;next-&gt;depth &lt; layer-&gt;depth)
      cur = cur-&gt;next;
    
    layer-&gt;next = cur-&gt;next;
    layer-&gt;prev = cur;

    if (cur-&gt;next)
      cur-&gt;next-&gt;prev = layer;
    
    cur-&gt;next = layer;
  }

  M_DirtyRegion(layer-&gt;x1, layer-&gt;y1, layer-&gt;x2, layer-&gt;y2);
}
</t>
<t tx="T891">@ R_LayerRemove

Remove the layer from it's parent list.
@c

void R_LayerRemove(layer_t *layer)
{
  layer_t ** parent_list = &amp;layer_list;

  if (layer-&gt;parent)
    parent_list = &amp;layer-&gt;parent-&gt;children;

  if (layer-&gt;next)
    layer-&gt;next-&gt;prev = layer-&gt;prev;
  
  if (layer-&gt;prev)
    layer-&gt;prev-&gt;next = layer-&gt;next;
  else
    (*parent_list) = layer-&gt;next;
  
  layer-&gt;next = NULL;
  layer-&gt;prev = NULL;

  M_DirtyRegion(layer-&gt;x1, layer-&gt;y1, layer-&gt;x2, layer-&gt;y2);
}
</t>
<t tx="T892">@ R_LayerEnable

Enable the layer, making it active and thus will be drawn and can
receive events. Updates the dirty matrix appropriately.
@c

void R_LayerEnable(layer_t *layer)
{
  layer-&gt;flags |= LAYF_Active;

  M_DirtyRegion(layer-&gt;x1, layer-&gt;y1, layer-&gt;x2, layer-&gt;y2);
}
</t>
<t tx="T893">@ R_LayerDisable

Disable the layer, making it non-active. It won't be drawn after
this nor receive any more events. Updates the dirty matrix
appropriately.
@c

void R_LayerDisable(layer_t *layer)
{
  layer-&gt;flags &amp;= ~LAYF_Active;

  M_DirtyRegion(layer-&gt;x1, layer-&gt;y1, layer-&gt;x2, layer-&gt;y2);
}
</t>
<t tx="T894">@ R_LayerChangeBounds

Change the position and/or size of the layer on the screen.
Updates the dirty matrix appropriately. Causes all children layers
to be resized.
@c

void R_LayerChangeBounds(layer_t *layer, int x1, int y1, int x2, int y2)
{
  if (layer-&gt;flags &amp; LAYF_Active)
    M_DirtyRegion(layer-&gt;x1, layer-&gt;y1, layer-&gt;x2, layer-&gt;y2);

  layer-&gt;x1 = x1;
  layer-&gt;y1 = y1;
  layer-&gt;x2 = x2;
  layer-&gt;y2 = y2;

  if (layer-&gt;flags &amp; LAYF_Active)
    M_DirtyRegion(layer-&gt;x1, layer-&gt;y1, layer-&gt;x2, layer-&gt;y2);

  // resize children, recursivly

  ResizeLayerList(layer-&gt;children, x1, y1, x2, y2);
}
</t>
<t tx="T895">@ R_LayerChangeFlags

Change the layer's flags, especially the Solid one, updating the
the dirty matrix appropriately. Cannot be used to set the Active
flag, use the Enable/Disable functions for that.
@c

void R_LayerChangeFlags(layer_t *layer, layerflags_e flags)
{
  if (layer-&gt;flags &amp; LAYF_Active)
  {
    if ((layer-&gt;flags ^ flags) &amp; LAYF_Solid)
    {
      M_DirtyRegion(layer-&gt;x1, layer-&gt;y1, layer-&gt;x2, layer-&gt;y2);
    }
  }

  layer-&gt;flags = (layer-&gt;flags &amp; LAYF_Active) | (flags &amp; ~LAYF_Active);
}
</t>
<t tx="T896">@ R_LayerChangeContents

Signals that the contents of the layer has changed. Updates the
dirty matrix appropriately.
@c

void R_LayerChangeContents(layer_t *layer)
{
  if (layer-&gt;flags &amp; LAYF_Active)
    M_DirtyRegion(layer-&gt;x1, layer-&gt;y1, layer-&gt;x2, layer-&gt;y2);
}
</t>
<t tx="T897">@ R_LayerClipRectToSolids

Tests the given rectangle (in x1/y1/x2/y2) against all the solid
rectangles _before_ the index, shrinking the given rectangle where
possible. Returns true if it was totally occluded. Can only be
called by "Drawer" functions or by DL_Query().
@c

boolean_t R_LayerClipRectToSolids(int solid_index, 
    int *x1, int *y1, int *x2, int *y2)
{
  DEV_ASSERT2(solid_index &gt;= 0);

  for (solid_index--; solid_index &gt;= 0; solid_index--)
  {
    int sx1 = solid_rects[solid_index]-&gt;x1;
    int sy1 = solid_rects[solid_index]-&gt;y1;
    int sx2 = solid_rects[solid_index]-&gt;x2;
    int sy2 = solid_rects[solid_index]-&gt;y2;
    
    int ocode = 0;

    // no overlap ?
    if ((*x2) &lt; sx1 || (*x1) &gt; sx2 || (*y2) &lt; sy1 || (*y1) &gt; sy2)
      continue;
    
    if ((*x1) &lt;= sx1 &amp;&amp; (*x2) &gt;= sx2)
      ocode |= 1;

    if ((*y1) &lt;= sy1 &amp;&amp; (*y2) &gt;= sy2)
      ocode |= 2;

    switch (ocode)
    {
      case 0:
        // only partially covered in X or Y
        break;
      
      case 3:
        // totally covered
        return true;
      
      case 1:
        // convered in X, only partially in Y
        if ((*y1) &lt;= sy1)
        {
          (*y1) = sy2 + 1;
        }
        else if ((*y2) &gt;= sy2)
        {
          (*y2) = sy1 - 1;
        }

        DEV_ASSERT2((*y2) &gt;= (*y1));
        break;
    
      case 2:
        // convered in Y, only partially in X
        if ((*x1) &lt;= sx1)
        {
          (*x1) = sx2 + 1;
        }
        else if ((*x2) &gt;= sx2)
        {
          (*x2) = sx1 - 1;
        }

        DEV_ASSERT2((*x2) &gt;= (*x1));
        break;

#ifdef DEVELOPERS
      default:
        I_Error("Bad ocode (%d) in R_LayerClipRectToSolids\n", ocode);
#endif 
    }
  }

  return false;
}
</t>
<t tx="T898">@ ------------------------------------------------------------------------
@c

static boolean_t ListenLayersRecursive(layer_t *list, event_t *ev)
{
  // move to end
  while (list &amp;&amp; list-&gt;next)
    list = list-&gt;next;
  
  for (; list; list = list-&gt;prev)
  {
    if (! (list-&gt;flags &amp; LAYF_Active))
      continue;

    if (list-&gt;children)
    {
      if (ListenLayersRecursive(list-&gt;children, ev))
        return true;
    }
    
    // do this layer _after_ children (since conceptually this layer
    // is underneath all of the children layers).
 
    if (list-&gt;Listener)
    {
      if ((*list-&gt;Listener)(list, ev))
        return true;
    }
  }

  return false;
}
</t>
<t tx="T899">@ R_ListenLayers

Traverses the layer tree from highest to lowest and passes the
event to each active layer, exiting early if one of the layers
"eats" the event. Returns true if a layer ate the event, otherwise
false.
@c

boolean_t R_ListenLayers(event_t *ev)
{
  return ListenLayersRecursive(layer_list, ev);
}
</t>
<t tx="T900">

static void ResizeLayerList(layer_t *list, int x1, int y1, int x2, int y2)
{
  for (; list; list = list-&gt;next)
  {
    DEV_ASSERT2(list-&gt;Resizer);

    (* list-&gt;Resizer)(list, x1, y1, x2, y2);
  }
}
</t>
<t tx="T901">@ R_ResizeLayers

Called whenever the video mode changes, allowing each layer to
move/resize itself.
@c

void R_ResizeLayers(void)
{
  // mark whole screen as dirty
  M_DirtyMatrix();

  ResizeLayerList(layer_list, 0, 0, SCREENWIDTH-1, SCREENHEIGHT-1);
}
</t>
<t tx="T902">@ ------------------------------------------------------------------------

NOTE: `DL' is short for DrawLayers...
@c

static void DL_Init(void)
{
  num_solid_rects = 0;
}
</t>
<t tx="T903">

static void DL_CleanUp(void)
{
  // nothing to do
}
</t>
<t tx="T904">@ DL_Query

Returns true if a 100% blocking layer was reached. Coordinates are
the parent clipping rectangle.
@c

static boolean_t DL_Query(layer_t *list, int x1, int y1, int x2, int y2)
{
  // move to end
  while (list &amp;&amp; list-&gt;next)
    list = list-&gt;next;
  
  // move backward (i.e. downward) through list

  for (; list; list = list-&gt;prev)
  {
    list-&gt;solid_index = -1;

    if (! (list-&gt;flags &amp; LAYF_Active))
      continue;
    
    // check if this layer totally outside of parent
    if (list-&gt;x2 &lt; x1 || list-&gt;x1 &gt; x2 ||
        list-&gt;y2 &lt; y1 || list-&gt;y1 &gt; y2)
    {
      list-&gt;invisible = true;
      continue;
    }

    // determine intersection between this layer &amp; parent clip
    list-&gt;clip_x1 = MAX(list-&gt;x1, x1);
    list-&gt;clip_y1 = MAX(list-&gt;y1, y1);
    list-&gt;clip_x2 = MIN(list-&gt;x2, x2);
    list-&gt;clip_y2 = MIN(list-&gt;y2, y2);

    DEV_ASSERT2(list-&gt;clip_x2 &gt;= list-&gt;clip_x1);
    DEV_ASSERT2(list-&gt;clip_y2 &gt;= list-&gt;clip_y1);

    list-&gt;vis_x1 = list-&gt;clip_x1;
    list-&gt;vis_y1 = list-&gt;clip_y1;
    list-&gt;vis_x2 = list-&gt;clip_x2;
    list-&gt;vis_y2 = list-&gt;clip_y2;

    list-&gt;invisible = R_LayerClipRectToSolids(num_solid_rects, 
        &amp;list-&gt;vis_x1, &amp;list-&gt;vis_y1, &amp;list-&gt;vis_x2, &amp;list-&gt;vis_y2);

    if (list-&gt;invisible)
      continue;

    // query children layers, recursively

    if (DL_Query(list-&gt;children, list-&gt;clip_x1, list-&gt;clip_y1,
                 list-&gt;clip_x2, list-&gt;clip_y2))
    {
      // early out, mark all lower layers (including this one !) as
      // invisible.

      for (; list; list=list-&gt;prev)
        list-&gt;invisible = true;
      
      return true;
    }

    if (list-&gt;flags &amp; LAYF_Volatile)
      M_DirtyRegion(list-&gt;x1, list-&gt;y1, list-&gt;x2, list-&gt;y2);

    // solid rectangle stuff

    list-&gt;solid_index = num_solid_rects;

    if (list-&gt;flags &amp; LAYF_Solid)
    {
      // check if layer covers whole screen

      if (list-&gt;x1 &lt;= 0 &amp;&amp; list-&gt;y1 &lt;= 0 &amp;&amp;
          list-&gt;x2 &gt;= SCREENWIDTH-1 &amp;&amp; 
          list-&gt;y2 &gt;= SCREENHEIGHT-1)
      {
        // early out, mark all lower layers (but not this one !) as
        // invisible.

        for (list=list-&gt;prev; list; list=list-&gt;prev)
          list-&gt;invisible = true;
        
        return true;
      }

      // add this layer into array of solid rectangles

      num_solid_rects++;

      if (num_solid_rects &gt; max_solid_rects)
      {
        Z_Resize(solid_rects, layer_t *, num_solid_rects);

        while (max_solid_rects &lt; num_solid_rects)
          solid_rects[max_solid_rects++] = NULL;
      }

      solid_rects[num_solid_rects-1] = list;
    }
  }

  return false;
}
</t>
<t tx="T905">

static void DL_Draw(layer_t *list)
{
  // move forward (i.e. upward) through list

  for (; list; list=list-&gt;next)
  {
    if (! (list-&gt;flags &amp; LAYF_Active))
      continue;

    if (list-&gt;invisible)
      continue;
    
    DEV_ASSERT2(list-&gt;solid_index &gt;= 0);

    if (list-&gt;Drawer)
    {
      (* list-&gt;Drawer)(list);
    }

    // draw children layers, recursively.  Called here since
    // conceptually the children layers are above their parent.

    DL_Draw(list-&gt;children);
  }
}
</t>
<t tx="T906">@ R_DrawLayers

Traverse the layer tree and draws everything that needs to be
drawn. When the Drawer() functions in each layer are called, the
dirty matrix must be used to clip any drawing to the clean areas
(unless flagged with LAYF_Volatile). Drawing must also be clipped
to the layer's current clip rectangle. Drawing can be optionally
clipped to the solid areas too, for improved performance.
@c

void R_DrawLayers(void)
{
  DL_Init();
  DL_Query(layer_list, 0, 0, SCREENWIDTH-1, SCREENHEIGHT-1);
  DL_Draw(layer_list);
  DL_CleanUp();
}
</t>
<t tx="T907">@ignore
@language c

// Main Rendering Organisation Code

// -KM- 1998/09/27 Dynamic Colourmaps

&lt;&lt; r_main #includes &gt;&gt;
&lt;&lt; r_main declarations &gt;&gt;
@others
</t>
<t tx="T908">#include "i_defs.h"
#include "r_main.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "e_net.h"
#include "gui_main.h"
#include "m_argv.h"
#include "m_bbox.h"
#include "m_fixed.h"
#include "m_misc.h"
#include "m_menu.h"
#include "p_local.h"
#include "r_local.h"
#include "r_sky.h"
#include "r_vbinit.h"
#include "r_view.h"
#include "r2_defs.h"
#include "rgl_defs.h"

#include "st_stuff.h"
#include "v_colour.h"
#include "w_wad.h"
#include "wp_main.h"
#include "z_zone.h"
</t>
<t tx="T909">
viewbitmap_t *rightvb;

// the view and viewbitmap that the rendering system currently is set up for
view_t *curview = NULL;
viewbitmap_t *curviewbmp = NULL;

// -ES- 1999/03/14 Dynamic Field Of View
// Fineangles in the viewwidth wide window.
angle_t FIELDOFVIEW = 2048;

// The used aspect ratio. A normal texel will look aspect_ratio*4/3
// times wider than high on the monitor
static const float_t aspect_ratio = 200.0 / 320.0;

// the extreme angles of the view
// -AJA- FIXME: these aren't angle_t (32 bit angles).
angle_t topangle;
angle_t bottomangle;
angle_t rightangle;
angle_t leftangle;

float_t leftslope;
float_t rightslope;
float_t topslope;
float_t bottomslope;

int viewwidth;
int viewheight;
int viewwindowx;
int viewwindowy;
int viewwindowwidth;
int viewwindowheight;

int vb_w;
int vb_h;
int vb_pitch;

angle_t viewangle = 0;
float_t viewvertangle;

angle_t normalfov, zoomedfov;
boolean_t viewiszoomed = false;

// increment every time a check is made
int validcount = 1;

// -KM- 1998/09/27 Dynamic colourmaps
// -AJA- 1999/07/10: Updated for colmap.ddf.
const colourmap_t *effect_colourmap;
float_t effect_strength;
boolean_t effect_infrared;

// -ES- 1999/03/19 rename from center to focus
float_t focusxfrac;
float_t focusyfrac;

// -ES- 1999/03/14 Added these. Unit Scale is used for things one distunit away.
float_t x_distunit;
float_t y_distunit;

// just for profiling purposes
int framecount;
int linecount;

subsector_t *viewsubsector;
region_properties_t *view_props;

float_t viewx;
float_t viewy;
float_t viewz;

float_t viewcos;
float_t viewsin;

player_t *viewplayer;

camera_t *camera = NULL;

camera_t *background_camera = NULL;
mobj_t *background_camera_mo = NULL;

viewbitmap_t *screenvb;

//
// precalculated math tables
//

// -ES- 1999/03/20 Different right &amp; left side clip angles, for asymmetric FOVs.
angle_t leftclipangle, rightclipangle;
angle_t clipscope;

// The viewangletox[viewangle + FINEANGLES/4] lookup
// maps the visible view angles to screen X coordinates,
// flattening the arc to a flat projection plane.
// There will be many angles mapped to the same X. 
// -ES- 1999/05/22 Made Dynamic
int *viewangletox;

// The xtoviewangleangle[] table maps a screen pixel
// to the lowest viewangle that maps back to x ranges
// from leftangle to rightangle.
// -ES- 1998/08/20 Explicit init to NULL
angle_t *xtoviewangle = NULL;

// -KM- 1998/09/27 Dynamic colourmaps
// -ES- 1999/06/13 BPP-specific colourmaps
// -AJA- 1999/07/10: Un-BPP-ised the lighting tables, for colmap.ddf.

lighttable_t zlight[LIGHTLEVELS][MAXLIGHTZ];
lighttable_t scalelight[LIGHTLEVELS][MAXLIGHTSCALE];

// bumped light from gun blasts
int extralight;

angle_t viewanglebaseoffset;
angle_t viewangleoffset;

void (*colfunc) (void);
void (*basecolfunc) (void);
void (*fuzzcolfunc) (void);
void (*transcolfunc) (void);
void (*spanfunc) (void);
void (*trans_spanfunc) (void);

wipeinfo_t *telept_wipeinfo = NULL;
int telept_starttic;
int telept_active = 0;
</t>
<t tx="T910">static void R_Render_Standard(void)
{
  R_RenderViewBitmap(screenvb);
  if (telept_active)
    telept_active = !WIPE_DoWipe(&amp;screenvb-&gt;screen, &amp;screenvb-&gt;screen,
        &amp;screenvb-&gt;screen, leveltime - telept_starttic, telept_wipeinfo);
}
</t>
<t tx="T911">@ R_PointToAngle

To get a global angle from cartesian coordinates,
the coordinates are flipped until they are in
the first octant of the coordinate system, then
the y (&lt;=x) is scaled and divided by x to get a
tangent (slope) value which is looked up in the
tantoangle[] table.
@c

angle_t R_PointToAngle(float_t x1, float_t y1, float_t x, float_t y)
{
  x -= x1;
  y -= y1;

  if ((x == 0) &amp;&amp; (y == 0))
    return 0;

  if (x &gt;= 0)
  {
    // x &gt;=0
    if (y &gt;= 0)
    {
      // y&gt;= 0

      if (x &gt; y)
      {
        // octant 0
        return M_ATan(y / x);
      }
      else
      {
        // octant 1
        return ANG90 - 1 - M_ATan(x / y);
      }
    }
    else
    {
      // y&lt;0
      y = -y;

      if (x &gt; y)
      {
        // octant 8
        // -ACB- 1999/09/27 Fixed MSVC Compiler warning
        return 0 - M_ATan(y / x);
      }
      else
      {
        // octant 7
        return ANG270 + M_ATan(x / y);
      }
    }
  }
  else
  {
    // x&lt;0
    x = -x;

    if (y &gt;= 0)
    {
      // y&gt;= 0
      if (x &gt; y)
      {
        // octant 3
        return ANG180 - 1 - M_ATan(y / x);
      }
      else
      {
        // octant 2
        return ANG90 + M_ATan(x / y);
      }
    }
    else
    {
      // y&lt;0
      y = -y;

      if (x &gt; y)
      {
        // octant 4
        return ANG180 + M_ATan(y / x);
      }
      else
      {
        // octant 5
        return ANG270 - 1 - M_ATan(x / y);
      }
    }
  }
}
</t>
<t tx="T912">@ R_PointToDist
@c

float_t R_PointToDist(float_t x1, float_t y1, float_t x2, float_t y2)
{
  angle_t angle;
  float_t dx;
  float_t dy;
  float_t temp;
  float_t dist;

  dx = fabs(x2 - x1);
  dy = fabs(y2 - y1);

  if (dx == 0)
    return dy;
  else if (dy == 0)
    return dx;

  if (dy &gt; dx)
  {
    temp = dx;
    dx = dy;
    dy = temp;
  }

  angle = M_ATan(dy / dx) + ANG90;

  // use as cosine
  dist = dx / M_Sin(angle);

  return dist;
}
</t>
<t tx="T913">@ R_ScaleFromGlobalAngle

Returns the texture mapping scale
for the current line (horizontal span)
at the given angle.

rw_distance &amp; rw_normalangle must be calculated first.
@c

float_t R_ScaleFromGlobalAngle(angle_t visangle)
{
  float_t scale;
  angle_t anglea;
  angle_t angleb;
  float_t cosa;
  float_t cosb;
  float_t num;
  float_t den;

  // Note: anglea is the difference between the given angle `visangle'
  // and the view angle.  We calculate the distance from the camera to
  // the seg line (below), and by triangulating we can determine the
  // distance from the view plane to the point on the seg (along a line
  // parallel to the view angle).
  //
  // Namely: z = hyp * cos(anglea).
  //
  // Thus: scale = 1.0 / z.
  //
  // Since the angle lies in the view's cliprange (clipping has
  // already occurred), the cosine will always be positive.

  anglea = visangle - viewangle;
  cosa = M_Cos(anglea);

  // Note: angleb is the difference between the given angle `visangle'
  // and the seg line's normal.  We know the distance along the normal
  // (rw_distance), thus by triangulating we can calculate the
  // distance from the camera to the seg line at the given angle,
  //
  // Namely: hyp = rw_distance / cos(angleb).
  //
  // Since the seg line faces the camera (back faces have already been
  // culled), the cosine will always be positive.

  angleb = visangle - rw_normalangle;
  cosb = M_Cos(angleb);

  num = y_distunit * cosb;
  den = rw_distance * cosa;

  if (den &gt; 0)
  {
    scale = num / den;

    if (scale &gt; 64)
      scale = 64;
    else if (scale &lt; 1/256.0)
      scale = 1/256.0;
  }
  else
    scale = 64;

  return scale;
}
</t>
<t tx="T914">@ InitTextureMapping
@c

static void InitTextureMapping(void)
{
  // this should be called between each view change (or it could be removed)
  leftclipangle = xtoviewangle[0];
  rightclipangle = xtoviewangle[viewwidth];
  clipscope = leftclipangle - rightclipangle;
}
</t>
<t tx="T915">@ InitLightTables

Inits the zlight and scalelight tables. Only done once, at startup.
-ES- 1999/06/13 Made separate 8- and 16-bit versions of tables
-AJA- 1999/07/10: Unseparated them, for colmap.ddf.
@c

static void InitLightTables(void)
{
  int i;
  int j;
  int level;
  float_t startmap;
  float_t scale;

  // Calculate the light levels to use
  //  for each level / distance combination &amp;
  //  for each level / scale combination.
  // -AJA- 1999/07/10: Reworked for colmap.ddf.

  for (i = 0; i &lt; LIGHTLEVELS; i++)
  {
    startmap = ((LIGHTLEVELS - 1 - i) * 2) * 256.0 / LIGHTLEVELS;

    for (j = 0; j &lt; MAXLIGHTZ; j++)
    {
      scale = 16 * 160.0 / (j + 1);
      level = startmap - scale;

      if (level &lt; 0)
        level = 0;
      if (level &gt; 255)
        level = 255;

      zlight[i][j] = 255 - level;
    }

    for (j = 0; j &lt; MAXLIGHTSCALE; j++)
    {
      level = startmap - j * 192.0 / MAXLIGHTSCALE;

      if (level &lt; 0)
        level = 0;
      if (level &gt; 255)
        level = 255;

      scalelight[i][j] = 255 - level;
    }
  }
}
</t>
<t tx="T916">@ Can currently only be R_Render_Standard.
@c

void (*R_Render) (void) = R_Render_Standard;

//
// R_SetViewSize
//
// Do not really change anything here,
// because it might be in the middle of a refresh.
//
// The change will take effect next refresh.

boolean_t setsizeneeded;
int setblocks;
boolean_t setresfailed = false;
int use_3d_mode;

void R_SetViewSize(int blocks)
{
  setsizeneeded = true;

  setblocks = blocks;
}
</t>
<t tx="T917">
static void InitViews(viewbitmap_t * vb, float_t xoffset)
{
  const char *s;
  aspect_t *a;

  // -ES- 1999/03/19 Use focusx &amp; focusy, for asymmetric fovs.
  focusxfrac = leftslope * viewwidth / (leftslope - rightslope) + xoffset;

  // Unit scale at distance distunit.
  x_distunit = viewwidth / (leftslope - rightslope);

  a = R_CreateAspect(vb,
      x_distunit, y_distunit,
      focusxfrac,
      topslope, bottomslope,
      viewwidth, viewheight);

  // first of all, create the psprite view, but only if viewanglebaseoffset == 0
  if (viewanglebaseoffset == 0)
    R_CreateView(vb, a, 0, 0, camera, VRF_PSPR, 100);

  s = M_GetParm("-screencomp");
  if (s)
  {
    screencomposition = atoi(s);
  }

  // now create the "real" views...
  screencomplist[screencomposition].routine(vb);
}
</t>
<t tx="T918">@ R_ExecuteSetViewSize
@c

void R_ExecuteSetViewSize(void)
{
  float_t slopeoffset;
  int sbar_height;

  setsizeneeded = false;
  redrawsbar = true;

  sbar_height = FROM_200(ST_HEIGHT);
  
  if (setblocks == 11 || background_camera_mo)
  {
    viewwidth  = SCREENWIDTH;
    viewheight = SCREENHEIGHT;
  }
  else
  {
    viewwidth  = (setblocks * SCREENWIDTH / 10) &amp; ~7;

    // Fixes 400x300 etc.
    if (setblocks == 10)
      viewheight = SCREENHEIGHT - sbar_height;
    else
      viewheight = (setblocks * (SCREENHEIGHT - sbar_height) / 10) &amp; ~7;
  }

  viewwindowwidth  = viewwidth;
  viewwindowheight = viewheight;
  viewwindowx = (SCREENWIDTH - viewwindowwidth) / 2;

  if (viewwidth == SCREENWIDTH)
    viewwindowy = 0;
  else
    viewwindowy = (SCREENHEIGHT - sbar_height - viewheight) / 2;

  leftslope = M_Tan(leftangle &lt;&lt; ANGLETOFINESHIFT);
  rightslope = M_Tan(rightangle &lt;&lt; ANGLETOFINESHIFT);

  slopeoffset = M_Tan((FIELDOFVIEW / 2) &lt;&lt; ANGLETOFINESHIFT) * aspect_ratio;
  slopeoffset = slopeoffset * viewwindowheight / viewwindowwidth;
  slopeoffset = slopeoffset * SCREENWIDTH / SCREENHEIGHT;

  topslope = slopeoffset;
  bottomslope = -slopeoffset;

  y_distunit = viewwindowheight / (topslope - bottomslope);
  focusyfrac = viewwindowheight * topslope / (topslope - bottomslope);

  if (use_3d_mode &amp;&amp; SCREENBITS == 16)
  {
    static camera_t *leftc, *rightc;

    if (screenvb)
      R_DestroyViewBitmap(screenvb);

    if (rightvb)
      R_DestroyViewBitmap(rightvb);

    rightvb = R_CreateViewBitmap(viewwindowwidth, viewwindowheight, BPP, NULL, 0, 0);
    screenvb = R_CreateViewBitmap(viewwindowwidth, viewwindowheight, BPP, main_scr, viewwindowx, viewwindowy);

    R_InitVB_3D_Right(rightvb, screenvb);

    if (!leftc)
    {
      leftc = R_CreateCamera();
      R_InitCamera_3D_Left(leftc);
      rightc = R_CreateCamera();
      R_InitCamera_3D_Right(rightc);
    }

    camera = leftc;
    InitViews(screenvb, 4.0);
    camera = rightc;
    InitViews(rightvb, -4.0);

    R_InitVB_3D_Left(rightvb, screenvb);
  }
  else
  {
    // -AJA- FIXME: cameras should be renewed when starting a new
    //       level (since there will be new mobjs).

    // -AJA- 1999/10/22: background cameras.  This code really sucks
    //       arse, needs improving.
    if (background_camera_mo &amp;&amp; !background_camera)
    {
      background_camera = R_CreateCamera();
      R_InitCamera_StdObject(background_camera, background_camera_mo);
      camera = background_camera;
    }

    if (!camera || (background_camera &amp;&amp; !background_camera_mo))
    {
      camera = R_CreateCamera();
      R_InitCamera_StdPlayer(camera);
      background_camera = NULL;
    }

    if (screenvb)
      R_DestroyViewBitmap(screenvb);

    screenvb = R_CreateViewBitmap(viewwindowwidth, viewwindowheight, BPP, 
        main_scr, 0, 0); //!!!! viewwindowx, viewwindowy);

    InitViews(screenvb, 0);
  }

  R_SetActiveViewBitmap(screenvb);

  pspritescale = (float_t)(viewwindowwidth / 320.0);
  pspriteiscale = (float_t)(320.0 / viewwindowwidth);
  pspritescale2 = ((float_t)SCREENHEIGHT / SCREENWIDTH) * viewwindowwidth / 200;
  pspriteiscale2 = ((float_t)SCREENWIDTH / SCREENHEIGHT) * 200 / viewwindowwidth;

}
</t>
<t tx="T919">@ R_SetFOV

Sets the specified field of view
-ES- 1999/03/28 Added This
@c

void R_SetFOV(angle_t fov)
{
  // can't change fov to angle below 5 or above 175 deg (approx). Round so
  // that 5 and 175 are allowed for sure.
  if (fov &lt; ANG90 / 18)
    fov = ANG90 / 18;
  if (fov &gt; ((ANG90 + 17) / 18) * 35)
    fov = ANG90 / 18 * 35;

  setsizeneeded = true;

  fov = fov &gt;&gt; ANGLETOFINESHIFT;  // convert to fineangle format

  leftangle = fov / 2;
  rightangle = (fov/2)*-1; // -ACB- 1999/09/27 Fixed MSVC Compiler Problem
  FIELDOFVIEW = leftangle - rightangle;
}
</t>
<t tx="T920">
void R_SetNormalFOV(angle_t newfov)
{
  menunormalfov = (newfov - ANG45 / 18) / (ANG45 / 9);
  cfgnormalfov = (newfov + ANG45 / 90) / (ANG180 / 180);
  normalfov = newfov;
  if (!viewiszoomed)
    R_SetFOV(normalfov);
}
</t>
<t tx="T921">void R_SetZoomedFOV(angle_t newfov)
{
  menuzoomedfov = (newfov - ANG45 / 18) / (ANG45 / 9);
  cfgzoomedfov = (newfov + ANG45 / 90) / (ANG180 / 180);
  zoomedfov = newfov;
  if (viewiszoomed)
    R_SetFOV(zoomedfov);
}
</t>
<t tx="T922">@ R_ChangeResolution

Makes R_ExecuteChangeResolution execute at start of next refresh.

-ES- 1998/08/20 Added this
@c

boolean_t changeresneeded = false;
static screenmode_t setMode;

void R_ChangeResolution(int width, int height, int depth, boolean_t windowed)
{
  changeresneeded = true;
  setsizeneeded = true;  // need to re-init some stuff

  setMode.width    = width;
  setMode.height   = height;
  setMode.depth    = depth;
  setMode.windowed = windowed;
}
</t>
<t tx="T923">@ R_ExecuteChangeResolution

Do the resolution change

-ES- 1998/08/20 Added this

-ES- 1999/04/05 Changed this to work with the viewbitmap system
@c

static boolean_t DoExecuteChangeResolution(void)
{
  static boolean_t init_rend = false;
  changeresneeded = false;

  SCREENWIDTH  = setMode.width;
  SCREENHEIGHT = setMode.height;
  SCREENBITS   = setMode.depth;
  SCREENWINDOW = setMode.windowed;

  // -ACB- 1999/09/20
  // parameters needed for I_SetScreenMode - returns false on failure
  if (! I_SetScreenSize(&amp;setMode))
  {
    // wait one second before changing res again, gfx card doesn't like to
    // switch mode too rapidly
    int tics = I_GetTime() + TICRATE;
    while (tics &gt;= I_GetTime())
    { /* nothing */ }

    // something was wrong, check if memory is corrupt
    Z_CheckHeap();

    return false;
  }

  // -ES- 2000-08-14 The resolution is obviously available.
  // In some situations, it might however not yet be available in the
  // screenmode list.
  V_AddAvailableResolution(&amp;setMode);

  V_InitResolution();

  // -AJA- 1999/07/01: Setup colour tables.
  V_InitColour();

  if (! init_rend)
  {
#ifdef USE_GL
    RGL_Init();
#else
    R2_Init();
#endif
    
    init_rend = true;
  }

///!!!! -AJA- FIXME: clean up (move into R2_NewScreenSize)
  {
    int i;

    Z_Resize(columnofs, int, SCREENWIDTH);
    Z_Resize(ylookup, byte *, SCREENHEIGHT);

    for (i=0; i &lt; SCREENWIDTH; i++)
      columnofs[i] = i * BPP;

    for (i=0; i &lt; SCREENHEIGHT; i++)
      ylookup[i] = main_scr-&gt;data + i * main_scr-&gt;pitch;
  }

  vctx.NewScreenSize(SCREENWIDTH, SCREENHEIGHT, BPP);

  // -ES- 1999/08/29 Fixes the garbage palettes, and the blank 16-bit console
  V_SetPalette(PALETTE_NORMAL, 0);
  V_ColourNewFrame();

  // -ES- 1999/08/20 Update GUI (resize stuff etc)
  GUI_InitResolution();

  // re-initialise various bits of GL state
#ifdef USE_GL
  RGL_SoftInit();
  W_ResetImages();
#endif

  graphicsmode = true;

  // -AJA- 1999/07/03: removed PLAYPAL reference.
  return true;
}
</t>
<t tx="T924">
void R_ExecuteChangeResolution(void)
{
  int i, j, idx;
  screenmode_t wantedMode;
  screenmode_t oldMode;
  screenmode_t mode320 = { 320, 200, 8, false };

  wantedMode = setMode;
  
  oldMode.width    = SCREENWIDTH;
  oldMode.height   = SCREENHEIGHT;
  oldMode.depth    = SCREENBITS;
  oldMode.windowed = SCREENWINDOW;

  // -ACB- 1999/09/21 false on failure - logical.
  if (DoExecuteChangeResolution())
  {
    setresfailed = false;
    return;
  }

  setresfailed = true;

  setMode = oldMode;
  setsizeneeded = true;

  if (DoExecuteChangeResolution())
    return;

  // couldn't even reset to old resolution. Perhaps they were the same.
  // Try 320x200 as second last resort.  Do a major loop over
  // windowing flag, e.g. so if all fullscreen modes fail we switch to
  // trying the windowing ones.

  for (j=0; j &lt; 2; j++, SCREENWINDOW = !SCREENWINDOW)
  {
    mode320.windowed = SCREENWINDOW;
    idx = V_FindClosestResolution(&amp;mode320, false, false);

    if (idx == -1)
      continue;

    setMode = scrmode[idx];
    setsizeneeded = true;

    I_Warning("Requested mode not available.  Trying %dx%dx%dc %s...\n",
        setMode.width, setMode.height, 1 &lt;&lt; setMode.depth,
        setMode.windowed ? "(Windowed)" : "(Fullscreen)");
     
    if (DoExecuteChangeResolution())
      return;

    // Should not happen, that mode was in the avail list. 
    // Last ditch effort: try all other modes in avail list.

    for (i=0; i &lt; numscrmodes; i++)
    {
      if (scrmode[i].windowed != SCREENWINDOW)
        continue;

      setMode = scrmode[i];
      setsizeneeded = true;

      // ignore ones we've already tried
      if (i == idx)
        continue;
      
      if (V_CompareModes(&amp;setMode, &amp;wantedMode) == 0)
        continue;

      if (V_CompareModes(&amp;setMode, &amp;oldMode) == 0)
        continue;

      I_Warning("Requested mode not available.  Trying %dx%dx%dc %s...\n",
          setMode.width, setMode.height, 1 &lt;&lt; setMode.depth,
          setMode.windowed ? "(Windowed)" : "(Fullscreen)");
     
      if (DoExecuteChangeResolution())
        return;
    }
  }

  // Ouch. Nothing worked! Quit.

  I_Error(DDF_LanguageLookup("ModeSelErrT"), SCREENWIDTH, SCREENHEIGHT, 
        1 &lt;&lt; SCREENBITS);
}
</t>
<t tx="T925">@ R_Init

Called once at startup, to initialise some rendering stuff.
@c

boolean_t R_Init(void)
{
  R_SetViewSize(screenblocks);
  I_Printf(".");
  InitLightTables();
  I_Printf(".");
  I_Printf(".");
  R_SetNormalFOV((angle_t)(cfgnormalfov * (angle_t)((float_t)ANG45 / 45.0)));
  I_Printf(".");
  R_SetZoomedFOV((angle_t)(cfgzoomedfov * (angle_t)((float_t)ANG45 / 45.0)));
  I_Printf(".");
  R_SetFOV(normalfov);
  I_Printf(".");
  framecount = 0;

  return true;
}
</t>
<t tx="T926">@ R_PointInSubsector
@c

subsector_t *R_PointInSubsector(float_t x, float_t y)
{
  node_t *node;
  int side;
  int nodenum;

  nodenum = root_node;

  while (!(nodenum &amp; NF_SUBSECTOR))
  {
    node = &amp;nodes[nodenum];
    side = P_PointOnDivlineSide(x, y, &amp;node-&gt;div);
    nodenum = node-&gt;children[side];
  }

  return &amp;subsectors[nodenum &amp; ~NF_SUBSECTOR];
}
</t>
<t tx="T927">@ R_PointGetProps
@c

region_properties_t *R_PointGetProps(subsector_t *sub, float_t z)
{
  extrafloor_t *S, *L, *C;
  float_t floor_h;

  // traverse extrafloors upwards
 
  floor_h = sub-&gt;sector-&gt;f_h;

  S = sub-&gt;sector-&gt;bottom_ef;
  L = sub-&gt;sector-&gt;bottom_liq;

  while (S || L)
  {
    if (!L || (S &amp;&amp; S-&gt;bottom_h &lt; L-&gt;bottom_h))
    {
      C = S;  S = S-&gt;higher;
    }
    else
    {
      C = L;  L = L-&gt;higher;
    }

    DEV_ASSERT2(C);

    // ignore liquids in the middle of THICK solids, or below real
    // floor or above real ceiling
    //
    if (C-&gt;bottom_h &lt; floor_h || C-&gt;bottom_h &gt; sub-&gt;sector-&gt;c_h)
      continue;
    
    if (z &lt; C-&gt;top_h)
      return C-&gt;p;

    floor_h = C-&gt;top_h;
  }

  // extrafloors were exhausted, must be top area
  return sub-&gt;sector-&gt;p;
}
</t>
<t tx="T928">
int telept_effect = 0;
int telept_flash = 1;
int telept_reverse = 0;

void R_StartFading(int start, int range)
{
  telept_wipeinfo = WIPE_InitWipe(&amp;screenvb-&gt;screen, 0, 0,
      &amp;screenvb-&gt;screen, 0, 0, true,
      &amp;screenvb-&gt;screen, 0, 0, false,
      viewwindowwidth, viewwindowheight, telept_wipeinfo,
      range, telept_reverse, telept_effect);

  telept_active = true;
  telept_starttic = start + leveltime;
}
</t>
<t tx="T929">@ R_SetupFrame

-ES- 1999/07/21 Exported most of this one to the camera section of
r_vbinit.c
@c

static void SetupFrame(camera_t * camera, view_t * v)
{
  // init all the globals
  R_CallCallbackList(camera-&gt;frame_start);

  // do some more stuff
  viewsin = M_Sin(viewangle);
  viewcos = M_Cos(viewangle);

  framecount++;
  validcount++;
}
</t>
<t tx="T930">@ R_RenderView
@c

void R_RenderViewBitmap(viewbitmap_t * vb)
{
  view_t *v;
  aspect_t *a;

  colfunc = basecolfunc = R_DrawColumn;
  fuzzcolfunc = R_DrawFuzzColumn;
  transcolfunc = R_DrawTranslatedColumn;
  spanfunc = R_DrawSpan;
  trans_spanfunc = R_DrawTranslucentSpan;

  R_CallCallbackList(vb-&gt;frame_start);

  R_SetActiveViewBitmap(vb);

  for (v = vb-&gt;views; v; v = v-&gt;vbnext)
  {
    a = v-&gt;aspect;

    SetupFrame(v-&gt;camera, v);

    R_AspectChangeY(a, a-&gt;y_distunit, viewvertangle);

    R_CallCallbackList(v-&gt;frame_start);

    R_SetActiveView(v);

    // we don't need to do anything if the view is invisible
    // we still have to call frame_end though, in case it would be used for
    // some sort of cleanup after frame_start, or if it would change something
    // in the view.
    if (v-&gt;screen.width &gt; 0 &amp;&amp; v-&gt;screen.height &gt; 0)
    {
      if (v-&gt;renderflags &amp; VRF_VIEW)
      {
        // -ES- FIXME: Clean up renderflags stuff.
        // Each view should have its own renderer, which can be truebsp,
        // non-truebsp or psprite. Needs cleanup of code.

        // check for new console commands.
        E_NetUpdate();
  
#ifdef USE_GL
        RGL_RenderTrueBSP();
#else
        R2_RenderTrueBSP();
#endif
        // Check for new console commands.
        E_NetUpdate();
      }
#ifndef USE_GL
      if (v-&gt;renderflags &amp; VRF_PSPR &amp;&amp; v-&gt;camera-&gt;view_obj-&gt;player)
      {
        // Draw the player sprites.
        // -ES- 1999/05/27 Moved psprite code here.
        focusyfrac = (float_t)viewheight / 2;

        R2_DrawPlayerSprites(v-&gt;camera-&gt;view_obj-&gt;player);
      }
#endif
    }
    R_CallCallbackList(v-&gt;frame_end);
    R_CallCallbackList(v-&gt;camera-&gt;frame_end);
  }

  R_CallCallbackList(vb-&gt;frame_end);
}
</t>
<t tx="T931">@ R_SetActiveViewBitmap

Changes the view bitmap to draw to.
Currently supports:
identically sized viewbmps
@c

void R_SetActiveViewBitmap(viewbitmap_t * vb)
{
  if (curviewbmp == vb)
    return;

  curviewbmp = vb;

  vb_h = vb-&gt;screen.height;
  vb_w = vb-&gt;screen.width;

  // only need to re-init if pitch has changed.
  if (vb-&gt;screen.pitch != vb_pitch)
  {
    vb_pitch = vb-&gt;screen.pitch;
    I_PrepareAssembler();
  }
}
</t>
<t tx="T932">@ R_SetActiveView

Changes the view to draw.
@c

void R_SetActiveView(view_t * v)
{
  aspect_t *a;

  curview = v;

  a = v-&gt;aspect;

  // error if not the appropriate vb is used. Could call
  // R_SetActiveViewBitmap instead, but you should always do that manually
  // before calling this one.
  if (v-&gt;parent != curviewbmp)
    I_Error("R_SetActiveView: The wrong viewbitmap is used!");

///!!!!  columnofs = v-&gt;columnofs;
///!!!!  ylookup = v-&gt;ylookup;

  viewwidth = v-&gt;screen.width;
  viewheight = v-&gt;screen.height;

  focusxfrac = a-&gt;focusxfrac - (float_t)v-&gt;aspect_x;
  focusyfrac = a-&gt;focusyfrac - (float_t)v-&gt;aspect_y;

  viewangletox = v-&gt;viewangletox;
  xtoviewangle = v-&gt;xtoviewangle;

  distscale = v-&gt;distscale;

  yslope = v-&gt;yslope;

  topslope = a-&gt;topslope - (a-&gt;topslope - a-&gt;bottomslope) * v-&gt;aspect_y / a-&gt;maxheight;
  bottomslope = a-&gt;topslope - (a-&gt;topslope - a-&gt;bottomslope) * (v-&gt;aspect_y + viewheight) / a-&gt;maxheight;

#ifndef USE_GL
  topslope += a-&gt;fakefocusslope;
  bottomslope += a-&gt;fakefocusslope;
#endif

  x_distunit = a-&gt;x_distunit;
  y_distunit = a-&gt;y_distunit;

  // This is no more time-critical, so it can be called every frame...
  InitTextureMapping();
}
</t>
<t tx="T933">@ignore
@language c

// Floor and Ceiling Rendering Code

// -ACB- 1998/07/13 - Changed RANGECHECK for DEVELOPERS
// -KM- 1998/09/27 Dynamic colourmaps.
// -AJA- 1999/07/12: Updated for colmap.ddf.
// -AJA- 1999/07/16: Added xoffset &amp; yoffset (for scrolling flats).
// -AJA- 1999/08/16: Support for rendering extra floors.

&lt;&lt; r_plane #includes &gt;&gt;

//
// spanstart holds the start of a plane span
// initialised to 0 at start
//
int *spanstart = NULL;

// 1999/03/20 Removed the origyslope hack
float_t *yslope = NULL;

float_t *distscale = NULL;
float_t basexscale;
float_t baseyscale;

// -ES- 1999/03/23 Changed to cache struct
typedef struct planecache_s
{
  float_t height;
  float_t distance;
  fixed_t xstep;
  fixed_t ystep;
} planecache_t;

planecache_t *planecache = NULL;

</t>
<t tx="T934">#include "i_defs.h"
#include "r_plane.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_inline.h"
#include "r_local.h"
#include "r_sky.h"
#include "r_state.h"
#include "v_colour.h"
#include "w_textur.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T935">@ignore
@language c

// Segs Code

// -KM- 1998/09/27 Dynamic colourmaps.
// -AJA- 1999/08/16: Support for rendering extra floors.

&lt;&lt; r_segs #includes &gt;&gt;

// True if any of the segs textures might be visible.
boolean_t segtextured;

// False if the back side is the same plane.
boolean_t markfloor;
boolean_t markceiling;

angle_t rw_normalangle;

// angle to line origin
int rw_angle1;

boolean_t maskedtexture;

//
// regular wall
//
int rw_x;
int rw_stopx;
angle_t rw_centerangle;
fixed_t rw_offset;
float_t rw_distance;
float_t rw_scale;
float_t rw_scalestep;

fixed_t rw_midtexturemid;
fixed_t rw_toptexturemid;
fixed_t rw_bottomtexturemid;

// -ES- 1999/03/24 Added These. They show the light level.
float_t rw_light;
float_t rw_lightstep;

fixed_t topfrac;
fixed_t topstep;

fixed_t bottomfrac;
fixed_t bottomstep;

// -AJA- 1999/07/10: Updated for colmap.ddf.
const lighttable_t *walllights;
const colourmap_t *wallnominal;

const byte *dc_source2;
fixed_t dc_xfrac;

</t>
<t tx="T936">#include "i_defs.h"
#include "r_segs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_inline.h"
#include "r_local.h"
#include "r_sky.h"
#include "v_colour.h"
#include "w_textur.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T937">@ignore
@language c

// Sky Handling Code

&lt;&lt; r_sky #includes &gt;&gt;
&lt;&lt; r_sky declarations &gt;&gt;
@others
</t>
<t tx="T938">#include "i_defs.h"
#include "r_sky.h"

#include "dm_state.h"
#include "m_fixed.h"
#include "r_data.h"
#include "r_main.h"
#include "z_zone.h"
</t>
<t tx="T939">
//
// sky mapping
//
float_t skytexturemid;

const struct image_s *sky_image;

// -ES- 1999-04-11 Added This
float_t skytexturescale;

typedef struct sec_sky_ring_s
{
  // which group of connected skies (0 if none)
  int group;
 
  // link of sector in RING
  struct sec_sky_ring_s *next;
  struct sec_sky_ring_s *prev;

  // maximal sky height of group
  float_t max_h;
}
sec_sky_ring_t;
</t>
<t tx="T940">@ R_InitSkyMap

Called every frame to calculate the sky texture's scale.

When stretchsky is off, the sky looks just like original DOOM's sky.
It will tile if you look up or down, or increase the FOV to more than 90.
When stretchsky is on, the sky is stretched to 9/5 of the original size.
9/5 is 360/200, where 200 is original screen height and 360 is the number
of texels between the lowest and the highest texel you can see
when looking maximally up or down in fullscreen and FOV 90.
In FOVs bigger than 90, the sky will tile.
@c

void R_InitSkyMap(void)
{
  if (level_flags.stretchsky)
  {
    skytexturemid = 100 - 160 * topslope * 5 / 9;
    skytexturescale = 160 * (topslope - bottomslope) * 5 / (viewheight * 9);
  }
  else
  {
    skytexturemid = 100 - 160 * topslope;
    skytexturescale = 160 * (topslope - bottomslope) / viewheight;
  }
}
</t>
<t tx="T941">@ R_ComputeSkyHeights

This routine computes the sky height field in sector_t, which is
the maximal sky height over all sky sectors (ceiling only) which
are joined by 2S linedefs.

Algorithm: Initially all sky sectors are in individual groups. Now
we scan the linedef list. For each 2-sectored line with sky on
both sides, merge the two groups into one. Simple :). We can
compute the maximal height of the group as we go.
@c

void R_ComputeSkyHeights(void)
{
  int i;
  line_t *ld;
  sector_t *sec;
  sec_sky_ring_t *rings;

  // --- initialise ---

  rings = Z_ClearNew(sec_sky_ring_t, numsectors);

  for (i=0, sec=sectors; i &lt; numsectors; i++, sec++)
  {
    if (! IS_SKY(sec-&gt;ceil))
      continue;

    rings[i].group = (i + 1);
    rings[i].next = rings[i].prev = rings + i;
    rings[i].max_h = sec-&gt;c_h;
  }

  // --- make the pass over linedefs ---
  
  for (i=0, ld=lines; i &lt; numlines; i++, ld++)
  {
    sector_t *sec1, *sec2;
    sec_sky_ring_t *ring1, *ring2, *tmp_R;

    if (! ld-&gt;side[0] || ! ld-&gt;side[1])
      continue;
    
    sec1 = ld-&gt;frontsector;
    sec2 = ld-&gt;backsector;
    
    DEV_ASSERT2(sec1 &amp;&amp; sec2);

    if (sec1 == sec2)
      continue;

    ring1 = rings + (sec1 - sectors);
    ring2 = rings + (sec2 - sectors);

    // we require sky on both sides
    if (ring1-&gt;group == 0 || ring2-&gt;group == 0)
      continue;

    // already in the same group ?
    if (ring1-&gt;group == ring2-&gt;group)
      continue;

    // swap sectors to ensure the lower group is added to the higher
    // group, since we don't need to update the `max_h' fields of the
    // highest group.

    if (ring1-&gt;max_h &lt; ring2-&gt;max_h)
    {
      tmp_R = ring1;  ring1 = ring2;  ring2 = tmp_R;
    }
    
    // update the group numbers in the second group
    
    ring2-&gt;group = ring1-&gt;group;
    ring2-&gt;max_h = ring1-&gt;max_h;

    for (tmp_R=ring2-&gt;next; tmp_R != ring2; tmp_R=tmp_R-&gt;next)
    {
      tmp_R-&gt;group = ring1-&gt;group;
      tmp_R-&gt;max_h = ring1-&gt;max_h;
    }
    
    // merge 'em baby...

    ring1-&gt;next-&gt;prev = ring2;
    ring2-&gt;next-&gt;prev = ring1;

    tmp_R = ring1-&gt;next; 
    ring1-&gt;next = ring2-&gt;next;
    ring2-&gt;next = tmp_R;
  }

  // --- now store the results, and free up ---
  
  for (i=0, sec=sectors; i &lt; numsectors; i++, sec++)
  {
    if (rings[i].group &gt; 0)
      sec-&gt;sky_h = rings[i].max_h;

#if 0   // DEBUG CODE
    L_WriteDebug("SKY: sec %d  group %d  max_h %1.1f\n", i,
        rings[i].group, rings[i].max_h);
#endif
  }

  Z_Free(rings);
}
</t>
<t tx="T942">@ignore
@language c

// Rendering things (objects as sprites) Code

// -KM- 1998/07/26 Replaced #ifdef RANGECHECK with #ifdef DEVELOPERS
// -KM- 1998/09/27 Dynamic colourmaps
// -AJA- 1999/07/12: Now uses colmap.ddf.

&lt;&lt; r_things #includes &gt;&gt;
&lt;&lt; r_things declarations &gt;&gt;
@others
</t>
<t tx="T943">#include "i_defs.h"
#include "r_things.h"

#include "e_search.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_swap.h"
#include "p_local.h"
#include "r_local.h"
#include "v_colour.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T944">
// The minimum distance between player and a visible sprite.
// FIXME: Decrease value, lower values are valid when float_t is used.
#define MINZ        (4.0)

//
// Sprite rotation 0 is facing the viewer,
//  rotation 1 is one angle turn CLOCKWISE around the axis.
// This is not the same as the angle,
//  which increases counter clockwise (protractor).
// There was a lot of stuff grabbed wrong, so I changed it...
//
float_t pspritescale;
float_t pspriteiscale;
float_t pspritescale2;
float_t pspriteiscale2;
float_t masked_translucency;

lighttable_t *spritezlights;

int extra_psp_light;

// constant arrays
//  used for psprite clipping and initializing clipping
// -ES- 1998/08/20 init to 0
int negonearray = 0;

// Sprite defs.  allocated in blocks of 16
spritedef_t *sprites = NULL;
int numsprites = 0;

// Sorted map of sprite defs.  Only used during initialisation.
static spritedef_t ** sprite_map = NULL;
static int sprite_map_len;


//
// INITIALISATION FUNCTIONS
//

typedef struct add_spr_cache_s
{
  char name[6];
  int index;
}
add_spr_cache_t;

static int add_spr_cache_num = 0;
static add_spr_cache_t add_spr_cache[2] = 
  {{ "", 0 }, { "", 0 }};
</t>
<t tx="T945">@ R_AddSpriteName

Looks up the sprite name, returning the index if found. When not
found, a new sprite is created, and that index is returned. The
given sprite name should be upper case.
@c

int R_AddSpriteName(const char *name, int frame)
{
  int index;

  DEV_ASSERT2(strlen(name) == 4);
  frame += 1;

  // look in cache
  if (strcmp(name, add_spr_cache[0].name) == 0)
    index = add_spr_cache[0].index;
  else if (strcmp(name, add_spr_cache[1].name) == 0)
    index = add_spr_cache[1].index;
  else
  {
    // look backwards, assuming a recent sprite is more likely
    for (index=numsprites-1; index &gt;= 0; index--)
    {
      if (strcmp(sprites[index].name, name) == 0)
        break;
    }

    if (index &lt; 0)
    {
      index = numsprites;

      if ((numsprites % 16) == 0)
        Z_Resize(sprites, spritedef_t, numsprites + 16);
      
      numsprites++;

      Z_Clear(sprites + index, spritedef_t, 1);
      strcpy(sprites[index].name, name);
    }

    // update cache
    strcpy(add_spr_cache[add_spr_cache_num].name, name);
    add_spr_cache[add_spr_cache_num].index = index;
    
    add_spr_cache_num ^= 1;
  }

  // update maximal frame count
  // NOTE: frames are allocated during R_InitSprites
  if (frame &gt; sprites[index].numframes)
    sprites[index].numframes = frame;

  return index;
}
</t>
<t tx="T946">@ SPRITE LOADING FUNCTIONS
@c

static void InstallSpriteLump(spritedef_t *def, int lump,
    const char *lumpname, int pos, byte flip)
{
  int frame, rot;
  
  char frame_ch = lumpname[pos];
  char rot_ch   = lumpname[pos+1];

  // convert frame &amp; rotation characters
  // NOTE: rotations 9 and A-G are EDGE specific.
  
  if ('A' &lt;= frame_ch &amp;&amp; frame_ch &lt;= 'Z')
    frame = (frame_ch - 'A');
  else switch (frame_ch)
  {
    case '[':  frame = 26; break;
    case '\\': frame = 27; break;
    case ']':  frame = 28; break;
    case '^':  frame = 29; break;
    case '_':  frame = 30; break;

    default:
      I_Warning("Sprite lump %s has illegal frame.\n", lumpname);
      return;
  }

  // ignore frames larger than what is used in DDF
  if (frame &gt;= def-&gt;numframes)
    return;

  if ('0' == rot_ch)
    rot = 0;
  else if ('1' &lt;= rot_ch &amp;&amp; rot_ch &lt;= '8')
    rot = (rot_ch - '1') * 2;
  else if ('9' == rot_ch)
    rot = 1;
  else if ('A' &lt;= rot_ch &amp;&amp; rot_ch &lt;= 'G')
    rot = (rot_ch - 'A') * 2 + 3;
  else
  {
    I_Warning("Sprite lump %s has illegal rotation.\n", lumpname);
    return;
  }

  DEV_ASSERT2(0 &lt;= frame &amp;&amp; frame &lt; def-&gt;numframes);

  // don't disturb any already-loaded frames
  if (def-&gt;frames[frame].finished)
    return;
   
  def-&gt;frames[frame].rotated = (rot_ch == '0') ? 0 : 1;

  if (rot &amp; 1)
    def-&gt;frames[frame].extended = 1;
 
  DEV_ASSERT2(0 &lt;= rot &amp;&amp; rot &lt; 16);

  if (def-&gt;frames[frame].images[rot])
  {
    I_Warning("Sprite %s:%c has two lumps mapped to it.\n", 
        lumpname, frame_ch);
    return;
  }

  def-&gt;frames[frame].images[rot] = W_ImageCreateSprite(lump);
  def-&gt;frames[frame].flip[rot] = flip;
}
</t>
<t tx="T947">@ FillSpriteFrames
@c

static void FillSpriteFrames(int file)
{
  const int *lumps;
  int lumpnum;

  int S, L;

  lumps = W_GetListLumps(file, LMPLST_Sprites, &amp;lumpnum);

  if (lumpnum == 0)
    return;

  // check all lumps for prefixes matching the ones in the sprite
  // list.  Both lists have already been sorted to make this as fast
  // as possible.

  S = L = 0; 

  while (S &lt; sprite_map_len &amp;&amp; L &lt; lumpnum)
  {
    const char *sprname  = sprite_map[S]-&gt;name;
    const char *lumpname = W_GetLumpName(lumps[L]);

    int comp;

    if (strlen(lumpname) != 6 &amp;&amp; strlen(lumpname) != 8)
    {
      I_Warning("Sprite name %s has illegal length.\n", lumpname);
      L++; continue;
    }
    
    comp = strncmp(sprname, lumpname, 4);

    if (comp &lt; 0)  // S &lt; L
    {
      S++; continue;
    }
    else if (comp &gt; 0)  // S &gt; L
    {
      L++; continue;
    }

    // we have a match

    InstallSpriteLump(sprite_map[S], lumps[L], lumpname, 4, 0);

    if (lumpname[6])
      InstallSpriteLump(sprite_map[S], lumps[L], lumpname, 6, 1);

    L++;
  }
}
</t>
<t tx="T948">
static void MarkCompletedFrames(void)
{
  int src, dst;

  for (src = dst = 0; src &lt; sprite_map_len; src++)
  {
    spritedef_t *def = sprite_map[src];

    int f, i;
    int count;
    int finish_num = 0;

    for (f=0; f &lt; def-&gt;numframes; f++)
    {
      char frame_ch = 'A' + f;
      spriteframe_t *frame = def-&gt;frames + f;

      if (frame-&gt;finished)
      {
        finish_num++;
        continue;
      }

      // check if all image pointers are NULL
      for (i=count=0; i &lt; 16; i++)
        count += frame-&gt;images[i] ? 1 : 0;

      if (count == 0)
        continue;

      frame-&gt;finished = 1;
      finish_num++;

      // fill in any gaps.  This is especially needed because of the
      // extra 8 rotations, but it also handles missing sprites well.

      if (! frame-&gt;rotated)
      {
        if (count != 1)
          I_Warning("Sprite %s:%c has extra rotations.\n", def-&gt;name,
              frame_ch);

        DEV_ASSERT2(frame-&gt;images[0] != NULL);

        for (i=1; i &lt; 16; i++)
        {
          frame-&gt;images[i] = frame-&gt;images[0];
          frame-&gt;flip[i]   = frame-&gt;flip[0];
        }

        continue;
      }

      if (count != 8 &amp;&amp; count != 16)
        I_Warning("Sprite %s:%c is missing rotations.\n", def-&gt;name, 
            frame_ch);

      // Note two passes are needed
      for (i=0; i &lt; (16 * 2); i++)
      {
        if (frame-&gt;images[i % 16] &amp;&amp; !frame-&gt;images[(i+1) % 16])
        {
          frame-&gt;images[(i+1) % 16] = frame-&gt;images[i % 16];
          frame-&gt;flip  [(i+1) % 16] = frame-&gt;flip  [i % 16];
        }
      }
    }

    // remove complete sprites from sprite_map
    if (finish_num == def-&gt;numframes)
      continue;

    sprite_map[dst++] = def;
  }

  sprite_map_len = dst;
}
</t>
<t tx="T949">@ show warnings for missing patches
@c

static void CheckSpriteFrames(spritedef_t *def)
{
  int i;
  int missing;
  
  for (i = missing = 0; i &lt; def-&gt;numframes; i++)
  {
    if (! def-&gt;frames[i].finished)
      missing++;
  }

  if (missing &gt; 0)
    I_Warning("Missing %d frames in sprite: %s\n", missing, def-&gt;name);

  // free some memory for completely missing sprites
  if (missing == def-&gt;numframes)
  {
    Z_Free(def-&gt;frames);
    
    def-&gt;numframes = 0;
    def-&gt;frames = NULL;
  }
}
</t>
<t tx="T950">@ R_InitSprites

Use the sprite lists in the WAD (S_START..S_END) to flesh out the
known sprite definitions (global `sprites' array) with images.

Checking for missing frames still done at run time.

-AJA- 2001/02/01: rewrote this stuff.
@c

boolean_t R_InitSprites(void)
{
  int i, file;

  if (numsprites == 0)
    I_Error("Missing sprite definitions !!\n");
  
  I_Printf("R_InitSprites: Finding sprite patches\n");
  
  // allocate frames
  for (i=0; i &lt; numsprites; i++)
  {
    DEV_ASSERT2(strlen(sprites[i].name) == 4);
    DEV_ASSERT2(sprites[i].numframes &gt; 0);
  
    sprites[i].frames = Z_ClearNew(spriteframe_t, sprites[i].numframes);
    
    // names in the sprite list should be unique
    if (i &gt; 0)
    {
      DEV_ASSERT2(strncmp(sprites[i-1].name, sprites[i].name, 4) != 0);
    }
  }
   
  // create a sorted list
  sprite_map_len = numsprites;
  sprite_map = Z_New(spritedef_t *, sprite_map_len);

  for (i=0; i &lt; sprite_map_len; i++)
    sprite_map[i] = sprites + i;

#define CMP(a, b)  (strcmp(a-&gt;name, b-&gt;name) &lt; 0)
  QSORT(spritedef_t *, sprite_map, sprite_map_len, CUTOFF);
#undef CMP
  
  // iterate over each file.  Order is important, we must go from
  // newest wad to oldest, so that new sprites override the old ones.
  // Completely finished sprites get removed from the sorted list as
  // we go.  
  //
  // NOTE WELL: override granularity is single frames.
 
  for (file=W_GetNumFiles() - 1; file &gt;= 0; file--)
  {
    FillSpriteFrames(file);
    MarkCompletedFrames();
  }
 
  // perform checks and free stuff
  for (i=0; i &lt; numsprites; i++)
    CheckSpriteFrames(sprites + i);
 
  Z_Free(sprite_map);
  sprite_map = NULL;

  return true;
}
</t>
<t tx="T951">@ignore
@language c

// View Bitmap Initialisation code

// Here are all the composition mode dependent initialisation routines and
// callbacks for viewbitmaps and its substructs (ie views and cameras).

&lt;&lt; r_vbinit #includes &gt;&gt;
&lt;&lt; r_vbinit declarations &gt;&gt;
@others
</t>
<t tx="T952">#include "i_defs.h"
#include "r_vbinit.h"

#include "con_defs.h"
#include "dm_state.h"
#include "r_main.h"
#include "r_segs.h"
#include "r_state.h"
#include "r_view.h"
#include "v_colour.h"
#include "v_res.h"
#include "z_zone.h"
</t>
<t tx="T953">
byte **dv_ylookup;
int *dv_columnofs;
int dv_viewwidth;
int dv_viewheight;

funclist_t enlarge8_2_2_funcs;
funclist_t enlarge16_2_2_funcs;
</t>
<t tx="T954">
static void R_EnlargeView8_2_2_CVersion(void)
{
  int x, y;
  int w, h;
  byte *dest1, *dest2, *src;

  w = dv_viewwidth;
  h = dv_viewheight;

  for (y = 0; y &lt; h; y++)
  {
    dest1 = dv_ylookup[y * 2 - h] + dv_columnofs[-w];
    dest1 += 2 * w;
    dest2 = dest1 + vb_pitch;
    src = dv_ylookup[y] + dv_columnofs[0];
    src += w;
    for (x = -w; x; x++)
    {
      dest1[2 * x + 0] = dest1[2 * x + 1] = dest2[2 * x + 0] = dest2[2 * x + 1] = src[x];
    }
  }
}
</t>
<t tx="T955">
static void R_EnlargeView16_2_2_CVersion(void)
{
  int x, y;
  int w, h;
  unsigned long *dest1, *dest2;
  unsigned short *src;
  unsigned long pixel;

  w = dv_viewwidth;
  h = dv_viewheight;

  for (y = 0; y &lt; h; y++)
  {
    dest1 = (unsigned long *)(dv_ylookup[y * 2 - h] + dv_columnofs[-w]);
    dest1 += w;
    dest2 = (unsigned long *)((char *)dest1 + vb_pitch);
    src = (unsigned short *)(dv_ylookup[y] + dv_columnofs[0]);
    src += w;
    for (x = -w; x; x++)
    {
      pixel = src[x];
      pixel |= pixel &lt;&lt; 16;
      dest1[x] = dest2[x] = pixel;
    }
  }
}
</t>
<t tx="T956">@ Anti-aliased scaling. The 'quick blur' setting.
@c

static void R_EnlargeView8_2_2_Blur(void)
{
  int x, y;
  int w, h;
  byte *dest, *src;
  unsigned long c, c1;

  w = dv_viewwidth;
  h = dv_viewheight;

  for (y = 0; y &lt; h; y++)
  {
    dest = dv_ylookup[y * 2 - h] + dv_columnofs[-w];
    src = dv_ylookup[y] + dv_columnofs[0];
    for (x = 0; x &lt; w; x++)
    {
      c1 = col2rgb8[32][src[0]];
      c = (c1 + c1) | 0x07c1fc1f;
      dest[0] = rgb_32k[0][0][c &amp; (c &gt;&gt; 17)];

      c = (c1 + col2rgb8[32][src[1]]) | 0x07c1fc1f;
      dest[1] = rgb_32k[0][0][c &amp; (c &gt;&gt; 17)];

      c = (c1 + col2rgb8[32][src[vb_pitch]]) | 0x07c1fc1f;
      dest[vb_pitch] = rgb_32k[0][0][c &amp; (c &gt;&gt; 17)];

      c = (col2rgb8[16][src[0]] + col2rgb8[16][src[1]] +
          col2rgb8[16][src[vb_pitch]] + col2rgb8[16][src[vb_pitch + 1]]) | 0x07c1fc1f;

      dest[vb_pitch + 1] = rgb_32k[0][0][c &amp; (c &gt;&gt; 17)];

      dest += 2;
      src++;
    }
    dest[-1] = dest[-2];
    dest[vb_pitch - 1] = dest[vb_pitch - 2];
  }
  dest = dv_ylookup[h - 1] + dv_columnofs[-w];
  Z_MoveData(dest, dest - vb_pitch, byte, vb_pitch);
}
</t>
<t tx="T957">
void (*R_DoEnlargeView_2_2) (void);

static void R_EnlargeView_2_2(void *data)
{
  view_t *v = data;

  dv_viewwidth = v-&gt;screen.width;
  dv_viewheight = v-&gt;screen.height;
  dv_ylookup = v-&gt;ylookup;
  dv_columnofs = v-&gt;columnofs;

  R_DoEnlargeView_2_2();
}
</t>
<t tx="T958">
static void BlurViewStrong8(void *data)
{
// DRAW_PIXEL: Draws one pixel
#define DRAW_PIXEL(x1,x2,x3) \
  (c = (line1[x1] + 2 * line1[x2] + line1[x3] + \
        2 * line2[x1] + 4 * line2[x2] + 2 * line2[x3] + \
        line3[x1] + 2 * line3[x2] + line3[x3]) | 0x07c1fc1f, \
  dest[x2] = rgb_32k[0][0][c &amp; (c &gt;&gt; 17)])

  view_t *v = data;
  unsigned int i;
  unsigned int x, y;
  unsigned int w, h;
  byte *dest, *src;
  unsigned long c;
  unsigned long *tmp;
  unsigned long *col2rgb;

  // We store the RGB values of three lines in memory.
  // This way, we never need to look up each pixel more than once,
  // and the special cases for top/bottom lines is quite easy to handle.
  // the line above the current one
  static unsigned long *line1 = NULL;
  // the current line
  static unsigned long *line2 = NULL;
  // the line below the current one
  static unsigned long *line3 = NULL;
  // width of the screen
  static unsigned long linew = 0;

  col2rgb = col2rgb8[4];

  w = v-&gt;screen.width;
  h = v-&gt;screen.height;

  if (w &gt; linew)
  {
    line1 = realloc(line1, w * sizeof(unsigned long));
    line2 = realloc(line2, w * sizeof(unsigned long));
    line3 = realloc(line3, w * sizeof(unsigned long));

    linew = w;
  }

  src = v-&gt;ylookup[0] + v-&gt;columnofs[0];

  for (i = 0; i &lt; linew; i++)
  {
    line2[i] = line1[i] = col2rgb[src[i]];
  }

  for (y = 0; y &lt; h; y++)
  {
    src = v-&gt;ylookup[y &gt; h - 2 ? h - 1 : y + 1] + columnofs[0];

    for (i = 0; i &lt; linew; i++)
    {
      line3[i] = col2rgb[src[i]];
    }

    dest = v-&gt;ylookup[y] + v-&gt;columnofs[0];

    // first draw the leftmost pixel
    DRAW_PIXEL(0, 0, 1);

    // now draw all the other pixels
    for (x = 1; x &lt; w - 1; x++)
    {
      DRAW_PIXEL(x - 1, x, x + 1);
    }

    // finally, draw the rightmost pixel
    DRAW_PIXEL(w - 2, w - 1, w - 1);

    tmp = line1;
    line1 = line2;
    line2 = line3;
    line3 = tmp;
  }
#undef DRAW_PIXEL
}
</t>
<t tx="T959">
static void BlurViewLight8(void *data)
{
// DRAW_PIXEL: Draws one pixel
#define DRAW_PIXEL(x1,x2,x3) \
  (c = (line1[x2] + line2[x1] + 4*line2[x2] + line2[x3] + line3[x2]) | 0x07c1fc1f, \
  dest[x2] = rgb_32k[0][0][c &amp; (c &gt;&gt; 17)])

  view_t *v = data;
  unsigned int i;
  unsigned int x, y;
  unsigned int w, h;
  byte *dest, *src;
  unsigned long c;
  unsigned long *tmp;
  unsigned long *col2rgb;

  // We store the RGB values of three lines in memory.
  // This way, we never need to look up each pixel more than once,
  // and the special cases for top/bottom lines is quite easy to handle.
  // the line above the current one
  static unsigned long *line1 = NULL;
  // the current line
  static unsigned long *line2 = NULL;
  // the line below the current one
  static unsigned long *line3 = NULL;
  // width of the screen
  static unsigned long linew = 0;

  col2rgb = col2rgb8[8];

  w = v-&gt;screen.width;
  h = v-&gt;screen.height;

  if (w &gt; linew)
  {
    line1 = realloc(line1, w * sizeof(unsigned long));
    line2 = realloc(line2, w * sizeof(unsigned long));
    line3 = realloc(line3, w * sizeof(unsigned long));

    linew = w;
  }

  src = v-&gt;ylookup[0] + v-&gt;columnofs[0];

  for (i = 0; i &lt; linew; i++)
  {
    line2[i] = line1[i] = col2rgb[src[i]];
  }

  for (y = 0; y &lt; h; y++)
  {
    src = v-&gt;ylookup[y &gt; h - 2 ? h - 1 : y + 1] + columnofs[0];

    for (i = 0; i &lt; linew; i++)
    {
      line3[i] = col2rgb[src[i]];
    }

    dest = v-&gt;ylookup[y] + v-&gt;columnofs[0];

    // first draw the leftmost pixel
    DRAW_PIXEL(0, 0, 1);

    // now draw all the other pixels
    for (x = 1; x &lt; w - 1; x++)
    {
      DRAW_PIXEL(x - 1, x, x + 1);
    }

    // finally, draw the rightmost pixel
    DRAW_PIXEL(w - 2, w - 1, w - 1);

    tmp = line1;
    line1 = line2;
    line2 = line3;
    line3 = tmp;
  }
#undef DRAW_PIXEL
}
</t>
<t tx="T960">
typedef struct
{
  int curdet;
  int mindet;
  int maxdet;
  unsigned long time0,time1;
  unsigned long tic0,tic1;
  unsigned long tic;
}
auto_vbdata_t;

//
// Checks what we should swith the detail level to.
//
// We aim to allow an error of about 10%
#define ALLOWED_ERROR (0.1)
// this is the minimal time we can allow between two time measurements
// to keep the measurement error within ALLOWED_ERROR.
#define MIN_TIME_INTERVAL (1000000/ALLOWED_ERROR/2/microtimer_granularity)
// returns the time interval between time1 and time2
#define TIME_INTERVAL(time1,time2) ((time2) - (time1) + 0.5 / microtimer_granularity)
static void CheckDetailChange(void *data)
{
  auto_vbdata_t *d = data;
  float_t fps;
  unsigned long curtime;
  int detail;

  d-&gt;tic++;

  curtime = I_ReadMicroSeconds();
  L_WriteDebug("\ntime %ld/%ld", curtime, d-&gt;time0);

  // first-time stuff
  if (d-&gt;time0 == 0)
    d-&gt;time0 = curtime;

  // Always try to keep two timers going simultaneously, to get more frequent
  // FPS updates on systems with poor timers.
  if (curtime &gt; d-&gt;time0 + MIN_TIME_INTERVAL / 2 &amp;&amp; d-&gt;time0 &gt;= d-&gt;time1)
  {
    d-&gt;time1 = curtime;
    d-&gt;tic1 = d-&gt;tic;
  }

  // stop now if not enough time has elapsed to get a decent frame rate value.
  if (curtime &lt;= d-&gt;time0 + MIN_TIME_INTERVAL)
    return;

  fps = (d-&gt;tic - d-&gt;tic0) * 1000000.0 / TIME_INTERVAL(d-&gt;time0, curtime);
  d-&gt;time0 = d-&gt;time1;
  d-&gt;tic0 = d-&gt;tic1;

  detail = d-&gt;curdet;
  if (fps &gt; 35.0)
  {
    detail++;
  }
  if (fps &lt; 30.0)
  {
    detail--;
  }

  // clip to max/min values
  if (detail &gt; d-&gt;maxdet)
    detail = d-&gt;maxdet;
  if (detail &lt; d-&gt;mindet)
    detail = d-&gt;mindet;
  d-&gt;curdet = detail;

  L_WriteDebug("\nFPS %f, detail %d\n", fps, detail);
}
</t>
<t tx="T961">
typedef struct
{
  view_t *v;
  int lowx;
  int lowy;
  int loww;
  int lowh;
  int hix;
  int hiy;
  int hiw;
  int hih;
  int lowdet;
  int hidet;
  int xscale;
  int yscale;
  int last_det;
  int *detail;
}
auto_viewdata_t;

//
// Callback that is used for all the views that resize in auto detail
//
static void AutoDetailViewFunc(void *data)
{
  auto_viewdata_t *a = data;
  int x, y, w, h;
  int deltadet;
  int detail;

  detail = *(a-&gt;detail);
  if (detail &lt; a-&gt;lowdet)
    detail = a-&gt;lowdet;
  if (detail &gt; a-&gt;hidet)
    detail = a-&gt;hidet;
  if (detail == a-&gt;last_det &amp;&amp; detail != -1)
    return;

  a-&gt;last_det = detail;

  detail = detail - a-&gt;lowdet;

  deltadet = a-&gt;hidet - a-&gt;lowdet;
  x = a-&gt;lowx + detail * (a-&gt;hix - a-&gt;lowx) / deltadet;
  y = a-&gt;lowy + detail * (a-&gt;hiy - a-&gt;lowy) / deltadet;
  w = a-&gt;loww + detail * (a-&gt;hiw - a-&gt;loww) / deltadet;
  h = a-&gt;lowh + detail * (a-&gt;hih - a-&gt;lowh) / deltadet;

  if (x &lt; 0)
    x = 0;
  if (y &lt; 0)
    y = 0;
  if (x &gt; a-&gt;v-&gt;aspect-&gt;maxwidth - w)
    x = a-&gt;v-&gt;aspect-&gt;maxwidth - w;
  if (y &gt; a-&gt;v-&gt;aspect-&gt;maxheight - h)
    y = a-&gt;v-&gt;aspect-&gt;maxheight - h;

  R_ViewSetXPosition(a-&gt;v, a-&gt;xscale * x + w * (a-&gt;xscale - 1), x, w);
  R_ViewSetYPosition(a-&gt;v, a-&gt;yscale * y + h * (a-&gt;yscale - 1), y, h);
}
</t>
<t tx="T962">@ MakeViewAutoDetail

Makes a view use the automatic detail level feature.
When the detail level is &lt;= lowdet, the view will have the low* dimensions,
when it's &gt;= hidet the view will have the hi* dimensions. When detail level
is between lowdet and hidet, the view dimensions will be somewhere between
of low* and hi*, depending on how close it is to lowdet/hidet.

*** All the dimensions refer to aspect position ***
xscale and yscale tell how many times bigger the view will get on the screen.
detail is the value returned by make_vb_auto_detail.
@c

static void MakeViewAutoDetail(view_t * v, int lowx, int lowy, int loww, int lowh,
    int hix, int hiy, int hiw, int hih, int lowdet, int hidet,
    int xscale, int yscale, int *detail)
{
  auto_viewdata_t *a;

  a = Z_ClearNew(auto_viewdata_t, 1);

  a-&gt;v = v;
  a-&gt;lowx = lowx;
  a-&gt;lowy = lowy;
  a-&gt;loww = loww;
  a-&gt;lowh = lowh;
  a-&gt;hix = hix;
  a-&gt;hiy = hiy;
  a-&gt;hiw = hiw;
  a-&gt;hih = hih;
  a-&gt;lowdet = lowdet;
  a-&gt;hidet = hidet;
  a-&gt;xscale = xscale;
  a-&gt;yscale = yscale;
  a-&gt;last_det = -1;  // current detail level. We don't need to resize view if detail hasn't changed since last frame.

  a-&gt;detail = detail;

  R_AddStartCallback(&amp;v-&gt;frame_start, AutoDetailViewFunc, a, Z_Free);
}
</t>
<t tx="T963">@ MakeVBAutoDetail

Makes a viewbitmap use the automatic detail level feature.
This must be called *before* any of its affected views is created, and
the returned pointer should be passed as the 'detail' parameter to all the
childrens' make_view_auto_detail calls.
mindet and maxdet show the minimal and maximal detail levels that will
be used by this viewbitmap.
@c

static int *MakeVBAutoDetail(viewbitmap_t * vb, int mindet, int maxdet)
{
  auto_vbdata_t *a;

  a = Z_ClearNew(auto_vbdata_t, 1);

  a-&gt;mindet = mindet;
  a-&gt;maxdet = maxdet;
  // current detail level: start right between min and max
  a-&gt;curdet = (mindet + maxdet) / 2;

  R_AddStartCallback(&amp;vb-&gt;frame_start, CheckDetailChange, a, Z_Free);

  return &amp;a-&gt;curdet;
}
</t>
<t tx="T964">@ init_vb_*
Helper functions that compose the vb in different ways.
All of them assume that vb already is created and that it has
one aspect and one view: those that normally are used for psprite.
Also, viewwidth and viewheight are set to viewwindowwidth and
viewwindowheight.
If you want to replace any of those, you can destroy them and create new
ones.

the normal one, with only one view, at full detail
@c

static void InitVB_Classic(viewbitmap_t * vb)
{
  aspect_t *a = vb-&gt;aspects;

  R_CreateView(vb, a, 0, 0, camera, VRF_VIEW, 0);
}
</t>
<t tx="T965">@ looks like the normal one, but is split up in two views. This can increase
the frame rate very much in some situations, especially when you're close
to a wall and a high resolution is chosen.
@c

static void InitVB_Classic_2y(viewbitmap_t * vb)
{
  aspect_t *a = vb-&gt;aspects;
  view_t *v;

  v = R_CreateView(vb, a, 0, 0, camera, VRF_VIEW, 0);
  R_ViewSetYPosition(v, 0, 0, viewheight / 2);
  v = R_CreateView(vb, a, 0, 0, camera, VRF_VIEW, 0);
  R_ViewSetYPosition(v, viewheight / 2, viewheight / 2, viewheight / 2);
}
</t>
<t tx="T966">@ The old low detail mode. The pixels are doubled y- and x-wise.
@c

static void InitVB_LowDetail(viewbitmap_t * vb)
{
  aspect_t *a;
  view_t *v;

  a = R_CreateAspect( vb, x_distunit / 2, y_distunit / 2,
                      ((focusxfrac-0.5)/2), topslope, bottomslope,
                      viewwidth / 2, viewheight / 2);

  v = R_CreateView(vb, a, 0, 0, camera, VRF_VIEW, 0);
  R_ViewSetYPosition(v, viewheight / 2, 0, viewheight / 2);
  R_ViewSetXPosition(v, viewwidth / 2, 0, viewwidth / 2);
  R_AddEndCallback(&amp;v-&gt;frame_end, R_EnlargeView_2_2, v, NULL);
}
</t>
<t tx="T967">@ low detail at the edges of the viewbitmap.
@c

static void InitVB_LDE(viewbitmap_t * vb)
{
  aspect_t *a1 = vb-&gt;aspects;
  aspect_t *a2;
  view_t *v;

  a2 = R_CreateAspect(vb, x_distunit / 2, y_distunit / 2,
      ((focusxfrac - 0.5)/2),
      topslope, bottomslope,
      viewwidth / 2, viewheight / 2);

  // left view
  v = R_CreateView(vb, a2, 0, 0, camera, VRF_VIEW, 0);
  R_ViewSetXPosition(v, viewwidth / 8, 0, viewwidth / 8);
  R_ViewSetYPosition(v, viewheight / 2, 0, viewheight / 2);
  R_AddEndCallback(&amp;v-&gt;frame_end, R_EnlargeView_2_2, v, NULL);

  // right view
  v = R_CreateView(vb, a2, 0, 0, camera, VRF_VIEW, 0);
  R_ViewSetXPosition(v, 7 * viewwidth / 8, 3 * viewwidth / 8, viewwidth / 8);
  R_ViewSetYPosition(v, viewheight / 2, 0, viewheight / 2);
  R_AddEndCallback(&amp;v-&gt;frame_end, R_EnlargeView_2_2, v, NULL);

  // middle view
  v = R_CreateView(vb, a1, 0, 0, camera, VRF_VIEW, 0);
  R_ViewSetXPosition(v, viewwidth / 4, viewwidth / 4, viewwidth / 2);
  R_ViewSetYPosition(v, 0, 0, viewheight * 3 / 4);

  // bottom view
  v = R_CreateView(vb, a2, 0, 0, camera, VRF_VIEW, 1);
  R_ViewSetXPosition(v, viewwidth / 2, viewwidth / 8, viewwidth / 4);
  R_ViewSetYPosition(v, viewheight * 7 / 8, viewheight * 3 / 8, viewheight / 8);
  R_AddEndCallback(&amp;v-&gt;frame_end, R_EnlargeView_2_2, v, NULL);
}
</t>
<t tx="T968">@ Automatic detail level. Dynamically changes the detail level, so that
the frame rate always is 30-35 FPS.
@c

static void InitVB_AutoDetail(viewbitmap_t * vb) // naming conventions?
{
#if 0
  InitVB_LDE(vb);
#else
  aspect_t *a1 = vb-&gt;aspects;
  aspect_t *a2;
  view_t *v;
  int *detail;

  a2 = R_CreateAspect(vb, x_distunit / 2, y_distunit / 2,
      (focusxfrac - 0.5) / 2,
      topslope, bottomslope,
      viewwidth / 2, viewheight / 2);

/*
   Viewbitmap will look like this (approximately) in different detail levels:

   Lowest:  Low:     Medium:  High:    Highest:
   LLLLRRRR LLLMMRRR LLMMMMRR LMMMMMMR MMMMMMMM
   LLLLRRRR LLLMMRRR LLMMMMRR LMMMMMMR MMMMMMMM
   LLLLRRRR LLLMMRRR LLMMMMRR LMMMMMMR MMMMMMMM
   LLLLRRRR LLLMMRRR LLMMMMRR LMMMMMMR MMMMMMMM
   LLLLRRRR LLLMMRRR LLMMMMRR LMMMMMMR MMMMMMMM
   LLLLRRRR LLLBBRRR LLMMMMRR LMMMMMMR MMMMMMMM
   LLLLRRRR LLLBBRRR LLBBBBRR LMMMMMMR MMMMMMMM
   LLLLRRRR LLLBBRRR LLBBBBRR LBBBBBBR MMMMMMMM

   where L (left), R (right) and B (bottom) are low detail views, and M (middle)
   is a high detail view.
 */

  detail = MakeVBAutoDetail(vb, 0, viewwidth / 8);

  // left view (low detail)
  v = R_CreateView(vb, a2, 0, 0, camera, VRF_VIEW, 0);
  MakeViewAutoDetail(v, 0, 0, viewwidth / 4, viewheight / 2, 0, 0, 0, viewheight / 2, 0, viewwidth / 8, 2, 2, detail);
  R_AddEndCallback(&amp;v-&gt;frame_end, R_EnlargeView_2_2, v, NULL);

  // right view (low detail)
  v = R_CreateView(vb, a2, 0, 0, camera, VRF_VIEW, 2);
  MakeViewAutoDetail(v, viewwidth / 2, 0, viewwidth / 4, viewheight / 2, viewwidth / 2, 0, 0, viewheight / 2, 0, viewwidth / 8, 2, 2, detail);
  R_AddEndCallback(&amp;v-&gt;frame_end, R_EnlargeView_2_2, v, NULL);

  // bottom view (low detail)
  v = R_CreateView(vb, a2, 0, 0, camera, VRF_VIEW, 3);
  MakeViewAutoDetail(v, viewwidth / 4, viewheight / 2, 0, viewheight / 4, 0, viewheight / 2, viewwidth / 2, 0, 0, viewwidth / 8, 2, 2, detail);
  R_AddEndCallback(&amp;v-&gt;frame_end, R_EnlargeView_2_2, v, NULL);

  // middle view (high detail)
  v = R_CreateView(vb, a1, 0, 0, camera, VRF_VIEW, 1);
  MakeViewAutoDetail(v, viewwidth / 2, 0, 0, viewheight / 2, 0, 0, viewwidth, viewheight, 0, viewwidth / 8, 1, 1, detail);
#endif
}
</t>
<t tx="T969">@ Use light blur filter.
@c

static void InitVB_BlurLight(viewbitmap_t * vb)
{
  aspect_t *a = vb-&gt;aspects;
  view_t *v;

  v = R_CreateView(vb, a, 0, 0, camera, VRF_VIEW, 0);

  if (BPP == 1)
    R_AddEndCallback(&amp;v-&gt;frame_end, BlurViewLight8, v, NULL);
}
</t>
<t tx="T970">@ Use strong blur filter.
@c

static void InitVB_BlurStrong(viewbitmap_t * vb)
{
  aspect_t *a = vb-&gt;aspects;
  view_t *v;

  v = R_CreateView(vb, a, 0, 0, camera, VRF_VIEW, 0);

  if (BPP == 1)
    R_AddEndCallback(&amp;v-&gt;frame_end, BlurViewStrong8, v, NULL);
}
</t>
<t tx="T971">@ Multiplies FOV by nviews by creating nviews views.
@c

static void InitVB_NViews(viewbitmap_t * vb, int nviews)
{
  int w;
  int i;
  aspect_t *a;
  view_t *v;
  static camera_t *cameras[20];

  w = (viewwidth + nviews - 1) / nviews;
  a = R_CreateAspect(vb,
      x_distunit * w / viewwidth,
      y_distunit * w / viewwidth,
      focusxfrac * w / viewwidth,
      topslope * viewwidth / w,
      bottomslope * viewwidth / w,
      w, viewheight);

  for (i = 0; i &lt; nviews; i++)
  {
    if (cameras[i])
      R_DestroyCamera(cameras[i]);

    cameras[i] = R_CreateCamera();
    
    R_InitCamera_ViewOffs(cameras[i], (float_t)(viewanglebaseoffset+(((nviews - 1 - i * 2) * FIELDOFVIEW / 2) &lt;&lt; ANGLETOFINESHIFT)) );
    
    v = R_CreateView(vb, a, 0, 0, cameras[i], VRF_VIEW, 0);
    
    R_ViewSetXPosition(v, viewwidth * i / nviews, 0,
        viewwidth * (i + 1) / nviews - viewwidth * i / nviews);
  }
}
</t>
<t tx="T972">
static void InitVB_3Views(viewbitmap_t * vb)
{
  InitVB_NViews(vb, 3);
}
</t>
<t tx="T973">
static void InitVB_10Views(viewbitmap_t * vb)
{
  InitVB_NViews(vb, 10);
}
</t>
<t tx="T974">@ the screen drawing mode. Index in the screencomplist.
@c

int screencomposition = 0;
vbinit_t screencomplist[] =
{
  {"Classic", InitVB_Classic, "The original screen setting"},
  {"DoubleY", InitVB_Classic_2y, "Looks like the original, but might be faster"},
  {"LowDetail", InitVB_LowDetail, "Low detail mode"},
  {"LightBlur", InitVB_BlurLight, "Use Light Blur Filter"},
  {"StrongBlur", InitVB_BlurStrong, "Use Strong Blur Filter"},
  {"LDE", InitVB_LDE, "Low Detail at the Edges of the screen"},
  {"AutoDetail", InitVB_AutoDetail, "Automatic Detail Level"},
  {"3XFOV", InitVB_3Views, "Gives you three times as big FOV"},
  {"10XFOV", InitVB_10Views, "Gives you ten times as big FOV"},
  {NULL,NULL,NULL}
};


/***** Camera routines *****/
typedef struct
{
  camera_t *c;
  mobj_t *mo;
}
camera_start_stdobj_t;

static void CameraFrameInit_StdObject(void *data)
{
  camera_start_stdobj_t *o = data;
  camera_t *c;
  mobj_t *mo;

  mo = o-&gt;mo;
  c = o-&gt;c;

  c-&gt;view_obj = mo;

  viewx = mo-&gt;x;
  viewy = mo-&gt;y;
  viewangle = mo-&gt;angle;
  viewvertangle = mo-&gt;vertangle;
  viewsubsector = mo-&gt;subsector;

  if (mo-&gt;player)
  {
    // -AJA- NOTE: CameraFrameInit_StdPlayer is used instead !!
    
    viewz = mo-&gt;player-&gt;viewz;

    extralight = mo-&gt;player-&gt;extralight;
    effect_colourmap = mo-&gt;player-&gt;effect_colourmap;
    effect_strength = mo-&gt;player-&gt;effect_strength;
    effect_infrared = mo-&gt;player-&gt;effect_infrared;
  }
  else
  {
    viewz = mo-&gt;z + mo-&gt;height * 9 / 10;

    extralight = 0;
    effect_colourmap = NULL;
    effect_strength = 0;
    effect_infrared = false;
  }

  view_props = R_PointGetProps(viewsubsector, viewz);
}
</t>
<t tx="T975">
void R_InitCamera_StdObject(camera_t * c, mobj_t * mo)
{
  camera_start_stdobj_t *o;

  o = Z_New(camera_start_stdobj_t, 1);
  o-&gt;c = c;
  o-&gt;mo = mo;
  R_AddStartCallback(&amp;c-&gt;frame_start, CameraFrameInit_StdObject, o, Z_Free);
}
</t>
<t tx="T976">
static void CameraFrameInit_StdPlayer(void *data)
{
  camera_t *c = data;
  player_t *player;

  player = displayplayer;
  c-&gt;view_obj = player-&gt;mo;

  viewx = player-&gt;mo-&gt;x;
  viewy = player-&gt;mo-&gt;y;
  viewangle = player-&gt;mo-&gt;angle;
  viewz = player-&gt;viewz;
  extralight = player-&gt;extralight;

  viewsubsector = player-&gt;mo-&gt;subsector;
  viewvertangle = player-&gt;mo-&gt;vertangle + player-&gt;kick_offset;
  view_props = R_PointGetProps(viewsubsector, viewz);

  effect_colourmap = player-&gt;effect_colourmap;
  effect_strength = player-&gt;effect_strength;
  effect_infrared = player-&gt;effect_infrared;
}
</t>
<t tx="T977">  

void R_InitCamera_StdPlayer(camera_t * c)
{
  R_AddStartCallback(&amp;c-&gt;frame_start, CameraFrameInit_StdPlayer, c, NULL);
}
</t>
<t tx="T978">
typedef struct
{
  angle_t offs;
}
camera_start_viewoffs_t;

static void CameraFrameInit_ViewOffs(void *data)
{
  camera_start_viewoffs_t *o = data;

  viewangle += o-&gt;offs;
}
</t>
<t tx="T979">
void R_InitCamera_ViewOffs(camera_t * c, angle_t offs)
{
  camera_start_viewoffs_t *data;

  R_InitCamera_StdPlayer(c);

  data = Z_New(camera_start_viewoffs_t, 1);
  data-&gt;offs = offs;

  R_AddStartCallback(&amp;c-&gt;frame_start, CameraFrameInit_ViewOffs, data, Z_Free);
}
</t>
<t tx="T980">
float_t camera_3d_offset = 4.0;

static void CameraFrameInit_3D_Left(void *data)
{
  viewx += M_Sin(viewangle) * camera_3d_offset;
  viewy -= M_Cos(viewangle) * camera_3d_offset;
}
</t>
<t tx="T981">
static void CameraFrameInit_3D_Right(void *data)
{
  viewx -= M_Sin(viewangle) * camera_3d_offset;
  viewy += M_Cos(viewangle) * camera_3d_offset;
}
</t>
<t tx="T982">
void R_InitCamera_3D_Left(camera_t * c)
{
  CON_CreateCVarReal("3doffset", cf_normal, &amp;camera_3d_offset);
  // use std as a base
  R_InitCamera_StdPlayer(c);
  // add callback that moves view to the left
  R_AddStartCallback(&amp;c-&gt;frame_start, CameraFrameInit_3D_Left, NULL, NULL);
}
</t>
<t tx="T983">void R_InitCamera_3D_Right(camera_t * c)
{
  CON_CreateCVarReal("3doffset", cf_normal, &amp;camera_3d_offset);
  // use std as a base
  R_InitCamera_StdPlayer(c);
  // add callback that moves view to the right
  R_AddStartCallback(&amp;c-&gt;frame_start, CameraFrameInit_3D_Right, NULL, NULL);
}
</t>
<t tx="T984">
typedef struct
{
  viewbitmap_t *right;
  viewbitmap_t *left;
}
vb_3d_right_t;

static void FinishVB_3D_Left(void *data)
{
  viewbitmap_t *vb = data;

  R_RenderViewBitmap(vb);
}
</t>
<t tx="T985">@ LUTs for conversion to red/cyan format
@c

static unsigned short cyan_3d[2][256];
static unsigned short red_3d[2][256];

// -ES- 2000/01/24 Changed 3d glasses effect to 16 bit. It is much cleaner
// that way.
static void FinishVB_3D_Right(void *data)
{
  vb_3d_right_t *vb = data;
  int x;
  int y;
  viewbitmap_t *left;
  viewbitmap_t *right;
  unsigned char *dest;
  unsigned char *src;

  left = vb-&gt;left;
  right = vb-&gt;right;
  for (y = 0; y &lt; right-&gt;screen.height; y++)
  {
    src = right-&gt;screen.data + right-&gt;screen.pitch * y;
    dest = left-&gt;screen.data + left-&gt;screen.pitch * y;
    for (x = 0; x &lt; right-&gt;screen.width; x ++)
    {
      *(short *)dest = cyan_3d[0][dest[0]] + cyan_3d[1][dest[1]] +
          red_3d[0][src[0]] + red_3d[1][src[1]];
      dest += 2;
      src += 2;
    }
  }
}
</t>
<t tx="T986">
void R_InitVB_3D_Left(viewbitmap_t * r, viewbitmap_t * l)
{
  R_AddEndCallback(&amp;l-&gt;frame_end, FinishVB_3D_Left, r, NULL);
}
</t>
<t tx="T987">
void R_InitVB_3D_Right(viewbitmap_t * r, viewbitmap_t * l)
{
  vb_3d_right_t *data;
  int i;
  truecol_info_t ti;

  data = Z_New(vb_3d_right_t, 1);
  data-&gt;left = l;
  data-&gt;right = r;
  R_AddEndCallback(&amp;r-&gt;frame_end, FinishVB_3D_Right, data, Z_Free);
  // -ES- These are the weights for red/green/blue
  // in the colour conversion.
  // Theoretically, the weights should be 30*30, 59*59 and 11*11, but
  // that made all blue objects too dark. Using 1:1:1 looks much better IMO
#define RW 1
#define GW 1
#define BW 1
  I_GetTruecolInfo(&amp;ti);
  for (i = 0; i &lt; 256; i++)
  {
    int r, g, b, c;
    int n;

    c = i;
    for (n = 0; n &lt; 2; n++)
    {
      r = ((c &amp; ti.red_mask) &gt;&gt; ti.red_shift) &lt;&lt; (6 - ti.red_bits);
      g = ((c &amp; ti.green_mask) &gt;&gt; ti.green_shift) &lt;&lt; (6 - ti.green_bits);
      b = ((c &amp; ti.blue_mask) &gt;&gt; ti.blue_shift) &lt;&lt; (6 - ti.blue_bits);
      c = (g * GW + b * BW + r * RW) / (RW + GW + BW);
      r = (c &gt;&gt; (6 - ti.red_bits)) &lt;&lt; ti.red_shift;
      g = (c &gt;&gt; (6 - ti.green_bits)) &lt;&lt; ti.green_shift;
      b = (c &gt;&gt; (6 - ti.blue_bits)) &lt;&lt; ti.blue_shift;
      cyan_3d[n][i] = g | b;
      red_3d[n][i] = r;
      c = i &lt;&lt; 8;
    }
  }
#undef RW
#undef GW
#undef BW
}
</t>
<t tx="T988">@ R_InitVBFunctions

Initialises Function Lists
@c

void R_InitVBFunctions(void)
{
  CON_InitFunctionList(&amp;enlarge8_2_2_funcs, "Enlarge8", R_EnlargeView8_2_2_CVersion, NULL);
  CON_AddFunctionToList(&amp;enlarge8_2_2_funcs, "blur", "Interpolate between pixels", R_EnlargeView8_2_2_Blur, NULL);
#ifndef NOHICOLOUR
  CON_InitFunctionList(&amp;enlarge16_2_2_funcs, "Enlarge16", R_EnlargeView16_2_2_CVersion, NULL);
#endif
}
</t>
<t tx="T989">@ignore
@language c

// View Bitmap systems

&lt;&lt; r_view #includes &gt;&gt;
&lt;&lt; r_view declarations &gt;&gt;
@others
</t>
<t tx="T990">#include "i_defs.h"
#include "r_view.h"

#include "dm_state.h"
#include "m_math.h"
#include "r_data.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_things.h"
#include "z_zone.h"
</t>
<t tx="T991">
// internal variables showing the biggest dimensions so far, just to keep some
// common temp arrays big enough for all the viewbitmaps.
int max_vb_h = 0;
int max_vb_w = 0;
</t>
<t tx="T992">@ Destroys a list of callbacks
@c

void R_DestroyCallbackList(callback_t ** list)
{
  callback_t *c, *tmp;

  for (c = *list; c; c = tmp)
  {
    if (c-&gt;kill_data)
      c-&gt;kill_data(c-&gt;data);
    tmp = c-&gt;next;
    Z_Free(c);
  }
  *list = NULL;
}
</t>
<t tx="T993">@ Executes all the callbacks in the list.
@c

void R_CallCallbackList(callback_t * list)
{
  for (; list; list = list-&gt;next)
    if (list-&gt;f)
      list-&gt;f(list-&gt;data);
}
</t>
<t tx="T994">@ Adds a callback to the end of *list. Use this for start_frame lists.
@c

void R_AddStartCallback(callback_t ** list, void (*f) (void *), void *data, void (*kill_data) (void *))
{
  callback_t *c;
  callback_t dummy;

  dummy.next = *list;
  dummy.prev = NULL;

  // find the last item in the list
  for (c = &amp;dummy; c-&gt;next; c = c-&gt;next)
    ;

  // link in the new element after the last one (i.e. after c)
  c-&gt;next = Z_New(callback_t, 1);
  if (c == &amp;dummy)
  {
    c-&gt;next-&gt;prev = NULL;
    *list = c-&gt;next;
  }
  else
    c-&gt;next-&gt;prev = c;
  c = c-&gt;next;
  c-&gt;next = NULL;

  // init the new item
  c-&gt;f = f;
  c-&gt;data = data;
  c-&gt;kill_data = kill_data;
}
</t>
<t tx="T995">@ Adds a callback to the start of *list. Use this for end_frame lists.
@c

void R_AddEndCallback(callback_t ** list, void (*f) (void *), void *data, void (*kill_data) (void *))
{
  callback_t *c;

  c = Z_New(callback_t, 1);
  c-&gt;f = f;
  c-&gt;data = data;
  c-&gt;kill_data = kill_data;
  c-&gt;prev = NULL;
  c-&gt;next = *list;
  if (*list)
    (*list)-&gt;prev = c;
  *list = c;
}
</t>
<t tx="T996">@ R_DestroyViewBitmap

Destroys the view bitmap and all its components (including views and aspects)
@c

void R_DestroyViewBitmap(viewbitmap_t * vb)
{
  while (vb-&gt;views)
    R_DestroyView(vb-&gt;views);
  while (vb-&gt;aspects)
    R_DestroyAspect(vb-&gt;aspects);

  V_EmptyScreen(&amp;vb-&gt;screen);

  Z_Free(vb-&gt;baseylookup);
  Z_Free(vb-&gt;basecolumnofs);

  R_DestroyCallbackList(&amp;vb-&gt;frame_start);
  R_DestroyCallbackList(&amp;vb-&gt;frame_end);

  // just to avoid strange bugs...
  if (vb == curviewbmp)
    curviewbmp = NULL;

  Z_Free(vb);
}
</t>
<t tx="T997">@ R_CreateViewBitmap

Creates a viewbitmap with the given dimensions. If p is NULL, a standalone
screen will be created and used as destination. Otherwise a subscreen to
p, starting at (x,y), will be created and used.
@c

viewbitmap_t *R_CreateViewBitmap(int width, int height, int bytepp, screen_t * p, int x, int y)
{
  viewbitmap_t *vb;
  int i;

  vb = Z_ClearNew(viewbitmap_t, 1);

  if (p)
  {
    if (bytepp != p-&gt;bytepp)
      I_Error("R_CreateViewBitmap: bytepp different in vb and parent");
    V_InitSubScreen(&amp;vb-&gt;screen, p, x, y, width, height);
  }
  else
    V_InitScreen(&amp;vb-&gt;screen, width, height, bytepp);

  vb-&gt;views = NULL;
  vb-&gt;aspects = NULL;
  vb-&gt;baseylookup = Z_New(byte *, SCREENHEIGHT);  //!!! -AJA- hack !
  vb-&gt;basecolumnofs = Z_New(int, SCREENWIDTH);

  for (i = 0; i &lt; SCREENHEIGHT; i++)
  {
    vb-&gt;baseylookup[i] = vb-&gt;screen.data + i * vb-&gt;screen.pitch;
  }
  for (i = 0; i &lt; SCREENWIDTH; i++)
  {
    vb-&gt;basecolumnofs[i] = i * bytepp;
  }

  // some global arrays have to be as big as the largest viewbitmap.
  if (width &gt; max_vb_w)
  {
    max_vb_w = width;
  }

  if (height &gt; max_vb_h)
  {
    max_vb_h = height;

    Z_Resize(spanstart, int, height);
    Z_Clear(spanstart, int, height);
  }

  return vb;
}
</t>
<t tx="T998">@ R_DestroyAspect

Destroys the aspect and removes all references to it.
Does not destroy any views, but all child views get their aspect info
cleared.
@c

void R_DestroyAspect(aspect_t * a)
{
  aspect_t *a2;

  // no view should be related to this aspect
  while (a-&gt;views)
    R_ViewClearAspect(a-&gt;views);

  // Unlink the aspect from its parent's aspect list
  if (a == a-&gt;parent-&gt;aspects)
    a-&gt;parent-&gt;aspects = a-&gt;next;
  else
  {
    for (a2 = a-&gt;parent-&gt;aspects; a2-&gt;next; a2 = a2-&gt;next)
      if (a2-&gt;next == a)
      {
        a2-&gt;next = a-&gt;next;
        break;
      }
    if (!a2-&gt;next)
    {  // didn't find v in its parent's list

      I_Error("R_DestroyAspect: Aspect doesn't exist in parent's aspect list");
    }
  }

  Z_Free(a-&gt;basextoviewangle);
  Z_Free(a-&gt;baseviewangletox);
  Z_Free(a-&gt;basedistscale);
  Z_Free(a-&gt;baseyslope);
  Z_Free(a);
}
</t>
<t tx="T999">@ R_AspectChangeY

Changes y_distunit and y angle of an aspect.
fakefocusslope is the slope of the angle which would be focus if true 3D
would be used.
@c

void R_AspectChangeY(aspect_t * a, float_t y_distunit, float_t fakefocusslope)
{
  float_t dy;
  int i;

  if (a-&gt;y_distunit != y_distunit || a-&gt;fakefocusslope != fakefocusslope)
  {
    a-&gt;fakefocusslope = fakefocusslope;

    a-&gt;focusyfrac = ((float_t)a-&gt;maxheight * (fakefocusslope + a-&gt;topslope)) /
                     (float_t)((a-&gt;topslope-a-&gt;bottomslope))-(float_t)0.5;

    a-&gt;y_distunit = y_distunit;

    for (i = 0; i &lt; a-&gt;maxheight; i++)
    {
      dy = fabs((float_t)i - (a-&gt;focusyfrac + 0.5));
      // -ES- 1999/10/17 Prevent from crash by using dist*4 as slope instead
      // of Inf if dy is very small
      // (gives an angle of 89.9 instead of 90 in normal 320x200).
      if (dy &lt;= 0.25)
        a-&gt;baseyslope[i] = y_distunit * 4;
      else
        a-&gt;baseyslope[i] = y_distunit / dy;
    }
  }
}
</t>
<t tx="T1000">
void R_AspectChangeX(aspect_t * a, float_t x_distunit, float_t focusxfrac)
{
  int i;
  int x;
  int t;
  angle_t ang;
  float_t maxleftslope, minrightslope;
  float_t cosadj;

  a-&gt;x_distunit = x_distunit;
  a-&gt;focusxfrac = focusxfrac;

  maxleftslope = focusxfrac / x_distunit;
  minrightslope = (focusxfrac - (float_t)a-&gt;maxwidth) / x_distunit;

  // Use tangent table to generate viewangletox:
  //  viewangletox will give the next greatest x
  //  after the view angle.
  for (i = 0; i &lt; FINEANGLES / 2; i++)
  {
    ang = (i &lt;&lt; ANGLETOFINESHIFT) - ANG90;

    if (i == 0 || M_Tan(ang) &lt; minrightslope)
      t = a-&gt;maxwidth + 1;
    else if (M_Tan(ang) &gt; maxleftslope)
      t = -1;
    else
    {
      t = (int)(focusxfrac - M_Tan(ang) * x_distunit + 1.0);

      if (t &lt; -1)
        t = -1;
      else if (t &gt; a-&gt;maxwidth + 1)
        t = a-&gt;maxwidth + 1;
    }
    a-&gt;baseviewangletox[i] = t;
  }

  // Scan viewangletox[] to generate xtoviewangle[]:
  //  xtoviewangle will give the smallest view angle
  //  that maps to x. 
  for (x = 0; x &lt;= a-&gt;maxwidth; x++)
  {
    i = 0;
    while (a-&gt;baseviewangletox[i] &gt; x)
      i++;
    a-&gt;basextoviewangle[x] = (i &lt;&lt; ANGLETOFINESHIFT) - ANG90;
  }

  for (i = 0; i &lt; a-&gt;maxwidth; i++)
  {
    cosadj = (float_t)fabs(M_Cos(a-&gt;basextoviewangle[i]));
    a-&gt;basedistscale[i] =  (float_t)(1.0 / cosadj);
  }
}
</t>
<t tx="T1001">@ R_CreateAspect

Creates an aspect_t with the given dimensions, and links it into the
parent's list.
@c

aspect_t *R_CreateAspect(viewbitmap_t * parent, float_t x_distunit,
    float_t y_distunit,float_t focusxfrac,
    float_t topslope,float_t bottomslope, int maxwidth, int maxheight)
{
  aspect_t *a;

  a = Z_New(aspect_t, 1);

  a-&gt;maxwidth = maxwidth;
  a-&gt;maxheight = maxheight;

  if (maxwidth &gt; parent-&gt;screen.width || maxheight &gt; parent-&gt;screen.height)
    I_Error("R_CreateAspect: aspect's max size larger than parent!");

  // X STUFF
  a-&gt;baseviewangletox = Z_New(int, FINEANGLES / 2);
  a-&gt;basextoviewangle = Z_New(angle_t, maxwidth + 1);
  a-&gt;basedistscale = Z_New(float_t, maxwidth);

  R_AspectChangeX(a, x_distunit, focusxfrac);

  // Y STUFF
  a-&gt;topslope = topslope;
  a-&gt;bottomslope = bottomslope;
  a-&gt;fakefocusslope = (float_t)M_PI;  // ChangeY is called w slope==0, so it has to be different.

  a-&gt;baseyslope = Z_New(float_t, a-&gt;maxheight);

  R_AspectChangeY(a, y_distunit, 0);

  a-&gt;views = NULL;

  a-&gt;next = parent-&gt;aspects;
  parent-&gt;aspects = a;
  a-&gt;parent = parent;

  return a;
}
</t>
<t tx="T1002">@ ViewRemoveFromVBList

Removes the view from its parent viewbitmap_t's list.
@c

static void ViewRemoveFromVBList(view_t * v)
{
  view_t *v2;

  if (v == v-&gt;parent-&gt;views)
    v-&gt;parent-&gt;views = v-&gt;vbnext;
  else
  {
    boolean_t error = true;

    for (v2 = v-&gt;parent-&gt;views; v2-&gt;vbnext; v2 = v2-&gt;vbnext)
      if (v2-&gt;vbnext == v)
      {
        v2-&gt;vbnext = v-&gt;vbnext;
        error = false;
        break;
      }
    if (error)
    {  // didn't find v in its parent's list

      I_Error("ViewRemoveFromVBList: View doesn't exist in parent's view list");
    }
  }
}
</t>
<t tx="T1003">@ R_ViewClearAspect

Removes all aspect info from a view, and removes it from the aspect's list.
The view can't be used again until you give it a new aspect
(through R_ViewSetAspect)
@c

void R_ViewClearAspect(view_t * v)
{
  view_t *v2;

  if (v-&gt;aspect == NULL)
    I_Error("R_ViewClearAspect: No aspect to clear!");

  if (v == v-&gt;aspect-&gt;views)
    v-&gt;aspect-&gt;views = v-&gt;anext;
  else
  {
    boolean_t error = true;

    for (v2 = v-&gt;aspect-&gt;views; v2-&gt;anext; v2 = v2-&gt;anext)
      if (v2-&gt;anext == v)
      {
        v2-&gt;anext = v-&gt;anext;
        error = false;
        break;
      }
    if (error)
    {  // didn't find v in the aspect's list

      I_Error("R_ViewClearAspect: View doesn't exist in aspect's view list");
    }
  }

  // destroy all aspect related stuff
  v-&gt;xtoviewangle = NULL;
  Z_Free(v-&gt;viewangletox);
  v-&gt;viewangletox = NULL;
  v-&gt;yslope = NULL;

  v-&gt;aspect = NULL;
}
</t>
<t tx="T1004">@ R_DestroyView

Destroys the view and removes it from any lists that refer to it.
@c

void R_DestroyView(view_t * v)
{
  // First unlink v from all the view lists
  ViewRemoveFromVBList(v);
  if (v-&gt;aspect)
    R_ViewClearAspect(v);

  V_EmptyScreen(&amp;v-&gt;screen);

  R_DestroyCallbackList(&amp;v-&gt;frame_start);
  R_DestroyCallbackList(&amp;v-&gt;frame_start);

  // just to avoid strange bugs...
  if (v == curview)
    curview = NULL;

  Z_Free(v);
}
</t>
<t tx="T1005">@ SetVBPos

Selects where within the viewbitmap the view should be drawn.
@c

static void ViewSetVBXPos(view_t * v, int vbx)
{
  V_MoveSubScreen(&amp;v-&gt;screen, 0, 0); //!!!! vbx, v-&gt;screen.y);
  v-&gt;columnofs = v-&gt;parent-&gt;basecolumnofs + 0; //!!!! vbx;
}
</t>
<t tx="T1006">@ ViewSetVBYPos

Selects where within the viewbitmap the view should be drawn.
@c

static void ViewSetVBYPos(view_t * v, int vby)
{
  V_MoveSubScreen(&amp;v-&gt;screen, 0, 0); //!!!! v-&gt;screen.x, vby);
  v-&gt;ylookup = v-&gt;parent-&gt;baseylookup + 0; //!!!! vby;
}
</t>
<t tx="T1007">@ R_ViewSetAspectPos

Selects which part of the aspect the view should render, and the width of
the rendering.
@c

void R_ViewSetAspectXPos(view_t * v, int ax, int width)
{
  aspect_t *a = v-&gt;aspect;
  int i;

  if (ax + width &gt; a-&gt;maxwidth)
    I_Error("R_ViewSetAspectXPos: aspect width/height overflow!");

  V_ResizeScreen(&amp;v-&gt;screen, width, v-&gt;screen.height, v-&gt;screen.bytepp);

  v-&gt;aspect_x = ax;

  // Create viewangletox, based on aspect's baseviewangletox
  i = 0;
  while (a-&gt;baseviewangletox[i] - ax &gt; width)
  {
    v-&gt;viewangletox[i] = width;
    i++;
  }
  while (a-&gt;baseviewangletox[i] - ax &gt; 0)
  {
    v-&gt;viewangletox[i] = a-&gt;baseviewangletox[i] - ax;
    i++;
  }
  while (i &lt; FINEANGLES / 2)
  {
    v-&gt;viewangletox[i] = 0;
    i++;
  }
  // xtoviewangle is just a part of aspect's basextoviewangle
  v-&gt;xtoviewangle = a-&gt;basextoviewangle + ax;
  // same with distscale
  v-&gt;distscale = a-&gt;basedistscale + ax;
}
</t>
<t tx="T1008">@ ViewSetAspectPos

Selects which part of the aspect the view should render, and the height of
the rendering.
@c

static void ViewSetAspectYPos(view_t * v, int ay, int height)
{
  if (ay + height &gt; v-&gt;aspect-&gt;maxheight)
    I_Error("R_ViewSetYPos: aspect width/height overflow!");

  v-&gt;aspect_y = ay;

  // don't update if height hasn't changed
  if (height != v-&gt;screen.height)
  {
    V_ResizeScreen(&amp;v-&gt;screen, v-&gt;screen.width, height, v-&gt;screen.bytepp);
  }

  v-&gt;yslope = v-&gt;aspect-&gt;baseyslope + ay;
}
</t>
<t tx="T1009">@ R_ViewSetYPosition

Sets the position of the view within both the viewbitmap and aspect
@c

void R_ViewSetYPosition(view_t * v, int vby, int ay, int height)
{
  // just calls the two helper functions. Do them in an order that suits the
  // range checking
  if (vby + v-&gt;screen.height &gt; v-&gt;parent-&gt;screen.height)
  {
    ViewSetAspectYPos(v, ay, height);
    ViewSetVBYPos(v, vby);
  }
  else
  {
    ViewSetVBYPos(v, vby);
    ViewSetAspectYPos(v, ay, height);
  }
}
</t>
<t tx="T1010">@ R_ViewSetXPosition

Sets the position of the view within both the viewbitmap and aspect
@c

void R_ViewSetXPosition(view_t * v, int vbx, int ax, int width)
{
  // just calls the two helper functions. Do them in an order that suits the
  // range checking
  if (vbx + v-&gt;screen.width &gt; v-&gt;parent-&gt;screen.width)
  {
    R_ViewSetAspectXPos(v, ax, width);
    ViewSetVBXPos(v, vbx);
  }
  else
  {
    ViewSetVBXPos(v, vbx);
    R_ViewSetAspectXPos(v, ax, width);
  }
}
</t>
<t tx="T1011">@ ViewSetPosition

Sets the position of the view within both the viewbitmap and aspect
@c

static void ViewSetPosition(view_t * v, int vbx, int vby, int ax, int ay, int width, int height)
{
  R_ViewSetXPosition(v, vbx, ax, width);
  R_ViewSetYPosition(v, vby, ay, height);
}
</t>
<t tx="T1012">@ R_ViewSetAspect

Sets the view's aspect to a, and initialises the view for the aspect's
maximum size.
@c

void R_ViewSetAspect(view_t * v, aspect_t * a)
{
  if (v-&gt;aspect)
    R_ViewClearAspect(v);

  v-&gt;viewangletox = Z_New(int, FINEANGLES / 2);

  v-&gt;anext = a-&gt;views;
  a-&gt;views = v;
  v-&gt;aspect = a;

  // view dimensions are initially set to the maximal possible
  ViewSetPosition(v, v-&gt;screen.x, v-&gt;screen.y, 0, 0, a-&gt;maxwidth, a-&gt;maxheight);
}
</t>
<t tx="T1013">@ R_CreateView

Creates a view. x and y show the smallest possible coords for the
upper-left corner (they can grow later). The view will be initialised for
the aspect's maximal dimensions.
@c

view_t *R_CreateView(viewbitmap_t * parent, aspect_t * aspect, int x, int y, camera_t * camera, unsigned char flags, int priority)
{
  view_t *v, *v1;

  if (x &lt; 0 || y &lt; 0)
    I_Error("R_CreateView: x or y is below zero!");

  v = Z_ClearNew(view_t, 1);

  // init width and height to 0, and let R_ViewAspectChange set them properly.
  V_InitSubScreen(&amp;v-&gt;screen, &amp;parent-&gt;screen, x, y, 0, 0);

  v-&gt;priority = priority;
  v-&gt;parent = parent;

  // High priority views are drawn last to overwrite the others, and
  // are therefore in the tail of the view list.
  if (parent-&gt;views == NULL || parent-&gt;views-&gt;priority &gt;= priority)
  {
    v-&gt;vbnext = parent-&gt;views;
    parent-&gt;views = v;
  }
  else
  {
    // Seach through the list for the first view whose priority is greater or
    // equal to the new view's
    for (v1 = parent-&gt;views; v1-&gt;vbnext &amp;&amp; v1-&gt;vbnext-&gt;priority &lt; priority; v1 = v1-&gt;vbnext) ;
    // Link it in there
    v-&gt;vbnext = v1-&gt;vbnext;
    v1-&gt;vbnext = v;
  }

  v-&gt;camera = camera;
  v-&gt;renderflags = flags;

  R_ViewSetAspect(v, aspect);

  return v;
}
</t>
<t tx="T1014">@ R_DestroyCamera
@c

void R_DestroyCamera(camera_t * c)
{
  R_DestroyCallbackList(&amp;c-&gt;frame_start);
  R_DestroyCallbackList(&amp;c-&gt;frame_end);

  Z_Free(c);
}
</t>
<t tx="T1015">@ R_CreateCamera

Just creates an empty camera. You must add a start_frame routine manually.
@c

camera_t *R_CreateCamera(void)
{
  camera_t *c;

  c = Z_ClearNew(camera_t, 1);

  return c;
}
</t>
<t tx="T1016">@ignore
@language c

// Radius Trigger Actions

// -AJA- 1999/10/24: Split these off from the rad_trig.c file.

&lt;&lt; rad_act #includes &gt;&gt;
&lt;&lt; rad_act declarations &gt;&gt;
@others
</t>
<t tx="T1017">#include "i_defs.h"
#include "rad_trig.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "hu_lib.h"
#include "hu_stuff.h"
#include "g_game.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_menu.h"
#include "m_random.h"
#include "m_swap.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_defs.h"
#include "r_sky.h"
#include "s_sound.h"
#include "v_ctx.h"
#include "v_colour.h"
#include "v_res.h"
#include "w_image.h"
#include "w_wad.h"
#include "w_textur.h"
#include "z_zone.h"
</t>
<t tx="T1018">
// current tip slots
drawtip_t tip_slots[MAXTIPSLOT];

// properties for fixed slots
static s_tip_prop_t fixed_props[FIXEDSLOTS] =
{
  { 1, 0.50, 0.50, 0, "TEXT_WHITE",  1.0 }, 
  { 2, 0.20, 0.25, 1, "TEXT_WHITE",  1.0 },
  { 3, 0.20, 0.75, 1, "TEXT_WHITE",  1.0 },
  { 4, 0.50, 0.50, 0, "TEXT_BLUE",   1.0 },
  { 5, 0.20, 0.25, 1, "TEXT_BLUE",   1.0 },
  { 6, 0.20, 0.75, 1, "TEXT_BLUE",   1.0 },
  { 7, 0.50, 0.50, 0, "TEXT_YELLOW", 1.0 },
  { 8, 0.20, 0.25, 1, "TEXT_YELLOW", 1.0 },
  { 9, 0.20, 0.75, 1, "TEXT_YELLOW", 1.0 } 
};
</t>
<t tx="T1019">@ Once-only initialisation.
@c

void RAD_InitTips(void)
{
  int i;

  for (i=0; i &lt; MAXTIPSLOT; i++)
  {
    drawtip_t *current = tip_slots + i;
    s_tip_prop_t *src = fixed_props + ((i &gt;= FIXEDSLOTS) ? 0 : i);

    // initial properties
    Z_Clear(current, drawtip_t, 1);
    Z_MoveData(&amp;current-&gt;p, src, s_tip_prop_t, 1);

    current-&gt;delay = -1;
    current-&gt;p.slot_num  = i;
    current-&gt;p.colourmap_name = Z_StrDup(current-&gt;p.colourmap_name);
  }
}
</t>
<t tx="T1020">@ Used when changing levels to clear any tips.
@c

void RAD_ResetTips(void)
{
  int i;

  // free any strings
  for (i=0; i &lt; MAXTIPSLOT; i++)
  {
    drawtip_t *current = tip_slots + i;

    if (current-&gt;p.colourmap_name)
      Z_Free((char *)current-&gt;p.colourmap_name);

    if (current-&gt;tip_text)
      Z_Free((char *)current-&gt;tip_text);
  }

  RAD_InitTips();
}
</t>
<t tx="T1021">static void SetupTip(drawtip_t *cur)
{
  int i;
  int font_height = hu_font.height + 2;
  int base_x, base_y;

  const char *ch_ptr;
  boolean_t need_newbie;

  hu_textline_t *HU;

  if (cur-&gt;tip_graphic)
    return;

  // lookup translation table
  if (! cur-&gt;p.colourmap_name)
    cur-&gt;colmap = text_white_map;
  else
    cur-&gt;colmap = DDF_ColmapLookup(cur-&gt;p.colourmap_name);

  // build HULIB information

  base_x = (int)(320 * PERCENT_2_FLOAT(cur-&gt;p.x_pos));
  base_y = (int)(200 * PERCENT_2_FLOAT(cur-&gt;p.y_pos));

  HU = NULL;
  need_newbie = true;
  cur-&gt;hu_linenum = 0;

  for (ch_ptr=cur-&gt;tip_text; *ch_ptr; ch_ptr++)
  {
    if (need_newbie)
    {
      HU = cur-&gt;hu_lines + cur-&gt;hu_linenum;
      cur-&gt;hu_linenum++;

      HL_InitTextLine(HU, base_x, base_y, &amp;hu_font);
      HU-&gt;centre = cur-&gt;p.left_just ? false : true;

      need_newbie = false;
    }

    if (*ch_ptr == '\n')
    {
      if (cur-&gt;hu_linenum == TIP_LINE_MAX)
      {
        /// M_WarnError("RTS Tip is too tall !\n");
        break;
      }

      need_newbie = true;
      continue;
    }

    DEV_ASSERT2(HU);

    HL_AddCharToTextLine(HU, *ch_ptr);
  }

  // adjust vertical positions
  for (i=0; i &lt; cur-&gt;hu_linenum; i++)
  {
    cur-&gt;hu_lines[i].y += (i * 2 - cur-&gt;hu_linenum) * font_height / 2;
  }
}
</t>
<t tx="T1022">static void FinishTip(drawtip_t *current)
{
  int i;

  if (current-&gt;tip_graphic)
    return;

  for (i=0; i &lt; current-&gt;hu_linenum; i++)
  {
    HL_EraseTextLine(current-&gt;hu_lines + i);
  }
}
</t>
<t tx="T1023">static void SendTip(s_tip_t * tip, int slot)
{
  drawtip_t *current;
  
  DEV_ASSERT2(0 &lt;= slot &amp;&amp; slot &lt; MAXTIPSLOT);

  current = tip_slots + slot;

  // if already in use, boot out the squatter
  if (current-&gt;delay &amp;&amp; !current-&gt;dirty)
    FinishTip(current);

  current-&gt;delay = tip-&gt;display_time;

  if (current-&gt;tip_text)
    Z_Free((char *)current-&gt;tip_text);

  if (tip-&gt;tip_ldf)
    current-&gt;tip_text = Z_StrDup(DDF_LanguageLookup(tip-&gt;tip_ldf));
  else if (tip-&gt;tip_text)
    current-&gt;tip_text = Z_StrDup(tip-&gt;tip_text);
  else
    current-&gt;tip_text = NULL;

  current-&gt;tip_graphic = tip-&gt;tip_graphic ?
      W_ImageFromPatch(tip-&gt;tip_graphic) : NULL;
  current-&gt;playsound   = tip-&gt;playsound ? true : false;
  current-&gt;fade_time   = 0;

  // mark it as "set me up please"
  current-&gt;dirty = true;
}
</t>
<t tx="T1024">@ -AJA- 1999/09/07: Reworked to handle tips with multiple lines.
@c

void RAD_DisplayTips(void)
{
  int i, slot;
  float_t alpha;

  for (slot=0; slot &lt; MAXTIPSLOT; slot++)
  {
    drawtip_t *current = tip_slots + slot;

    // Is there actually a tip to display ?
    if (current-&gt;delay &lt; 0)
      continue;

    if (current-&gt;dirty)
    {
      SetupTip(current);
      current-&gt;dirty = false;
    }
    
    // If the display time is up reset the tip and erase it.
    if (current-&gt;delay == 0)
    {
      FinishTip(current);

      current-&gt;delay = -1;
      continue;
    }

    // Make a noise when the tip is first displayed.
    // Note: This happens only once.

    if (current-&gt;playsound)
    {
      S_StartSound(NULL, DDF_SfxLookupSound("TINK"));
      current-&gt;playsound = false;
    }

    alpha = current-&gt;p.translucency;

    if (alpha &lt; 0.02)
      continue;
    
    if (current-&gt;tip_graphic)
    {
      const image_t *image = current-&gt;tip_graphic;

      int x = SCREENWIDTH  * PERCENT_2_FLOAT(current-&gt;p.x_pos);
      int y = SCREENHEIGHT * PERCENT_2_FLOAT(current-&gt;p.y_pos);

      vctx.DrawImage(x, y, IM_WIDTH(image), IM_HEIGHT(image), image,
          0, 0, IM_RIGHT(image), IM_BOTTOM(image), NULL, alpha);

      continue;
    }

    // Dump it to the screen

    for (i=0; i &lt; current-&gt;hu_linenum; i++)
    {
      HL_DrawTextLineAlpha(current-&gt;hu_lines + i, false,
          current-&gt;colmap, M_FloatToFixed(alpha));
    }
  }
}
</t>
<t tx="T1025">@ Does any tic-related RTS stuff. For now, just update the tips.

-AJA- 1999/09/07: written.
@c

void RAD_Ticker(void)
{
  int i;

  // update the tips.

  for (i=0; i &lt; MAXTIPSLOT; i++)
  {
    drawtip_t *current = tip_slots + i;

    if (current-&gt;delay &lt; 0)
      continue;

    if (current-&gt;delay &gt; 0)
      current-&gt;delay--;

    // handle fading
    if (current-&gt;fade_time &gt; 0)
    {
      float_t diff = current-&gt;fade_target - current-&gt;p.translucency;
      
      current-&gt;fade_time--;

      if (current-&gt;fade_time == 0)
        current-&gt;p.translucency = current-&gt;fade_target;
      else
        current-&gt;p.translucency += diff / (current-&gt;fade_time+1);
    }
  }
}
</t>
<t tx="T1026">void RAD_ActNOP(rad_trigger_t *R, mobj_t *actor, void *param)
{
  // No Operation
}
</t>
<t tx="T1027">void RAD_ActTip(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_tip_t *tip = (s_tip_t *) param;

  // Only display the tip to the player that stepped into the radius
  // trigger.

  if (actor-&gt;player != consoleplayer)
    return;

  SendTip(tip, R-&gt;tip_slot);
}
</t>
<t tx="T1028">void RAD_ActTipProps(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_tip_prop_t *tp = (s_tip_prop_t *) param;
  drawtip_t *current;

  if (actor-&gt;player != consoleplayer)
    return;

  if (tp-&gt;slot_num &gt;= 0)
    R-&gt;tip_slot = tp-&gt;slot_num;

  DEV_ASSERT2(0 &lt;= R-&gt;tip_slot &amp;&amp; R-&gt;tip_slot &lt; MAXTIPSLOT);

  // the first few tip slots have fixed properties
  if (R-&gt;tip_slot &lt; FIXEDSLOTS)
    return;

  current = tip_slots + R-&gt;tip_slot;

  if (tp-&gt;x_pos &gt;= 0)
    current-&gt;p.x_pos = tp-&gt;x_pos;
 
  if (tp-&gt;y_pos &gt;= 0)
    current-&gt;p.y_pos = tp-&gt;y_pos;
 
  if (tp-&gt;left_just &gt;= 0)
    current-&gt;p.left_just = tp-&gt;left_just;
 
  if (tp-&gt;colourmap_name)
  {
    if (current-&gt;p.colourmap_name)
      Z_Free((char *)current-&gt;p.colourmap_name);

    current-&gt;p.colourmap_name = Z_StrDup(tp-&gt;colourmap_name);
  }
 
  if (tp-&gt;translucency &gt;= 0)
  {
    if (tp-&gt;time == 0)
      current-&gt;p.translucency = tp-&gt;translucency;
    else
    {
      current-&gt;fade_target = tp-&gt;translucency;
      current-&gt;fade_time = tp-&gt;time;
    }
  }
  
  // make tip system recompute some stuff
  current-&gt;dirty = true;
}
</t>
<t tx="T1029">void RAD_ActSpawnThing(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_thing_t *t = (s_thing_t *) param;

  mobj_t *mo;
  const mobjinfo_t *minfo;

  // These *MUST* happen to everyone to keep netgames consistent.
  // Spawn a new map object.

  if (t-&gt;thing_name)
    minfo = DDF_MobjLookup(t-&gt;thing_name);
  else
    minfo = DDF_MobjLookupNum(t-&gt;thing_type);

  if (minfo == NULL)
  {
    if (t-&gt;thing_name)
      I_Error("Thing type: %s in RTS trigger not found.\n", t-&gt;thing_name);
    else
      I_Error("Thing type: %d in RTS trigger not found.\n", t-&gt;thing_type);
    return;
  }

  // -AJA- 1999/10/02: -nomonsters check.
  if (level_flags.nomonsters &amp;&amp; (minfo-&gt;extendedflags &amp; EF_MONSTER))
    return;

  // -AJA- 1999/10/07: -noextra check.
  if (!level_flags.have_extra &amp;&amp; (minfo-&gt;extendedflags &amp; EF_EXTRA))
    return;

  // -AJA- 1999/09/11: Support for supplying Z value.

  if (t-&gt;spawn_effect)
  {
    mo = P_MobjCreateObject(t-&gt;x, t-&gt;y, t-&gt;z, minfo-&gt;respawneffect);
  }

  mo = P_MobjCreateObject(t-&gt;x, t-&gt;y, t-&gt;z, minfo);

  // -ACB- 1998/07/10 New Check, so that spawned mobj's don't
  //                  spawn somewhere where they should not.
  if (!P_CheckAbsPosition(mo, mo-&gt;x, mo-&gt;y, mo-&gt;z))
  {
    P_RemoveMobj(mo);
    return;
  }

  P_SetMobjDirAndSpeed(mo, t-&gt;angle, t-&gt;slope, 0);

  mo-&gt;spawnpoint.x = t-&gt;x;
  mo-&gt;spawnpoint.y = t-&gt;y;
  mo-&gt;spawnpoint.z = t-&gt;z;
  mo-&gt;spawnpoint.angle = t-&gt;angle;
  mo-&gt;spawnpoint.slope = t-&gt;slope;
  mo-&gt;spawnpoint.info = minfo;
  mo-&gt;spawnpoint.flags = t-&gt;ambush ? MF_AMBUSH : 0;

  if (t-&gt;ambush)
    mo-&gt;flags |= MF_AMBUSH;

  // -AJA- 1999/09/25: If radius trigger is a path node, then
  //       setup the thing to follow the path.

  if (R-&gt;info-&gt;next_in_path)
    mo-&gt;path_trigger = R-&gt;info;
}
</t>
<t tx="T1030">void RAD_ActDamagePlayers(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_damagep_t *damage = (s_damagep_t *) param;
  player_t *p;
  
  // Make sure these can happen to everyone within the radius.
  // Damage the player(s)
  for (p = players; p; p = p-&gt;next)
  {
    if (!RAD_WithinRadius(p-&gt;mo, R-&gt;info))
      continue;

    P_DamageMobj(p-&gt;mo, NULL, NULL, damage-&gt;damage_amount, NULL);
  }
}
</t>
<t tx="T1031">void RAD_ActHealPlayers(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_healp_t *heal = (s_healp_t *) param;
  player_t *p;

  // Heal the player(s)
  for (p = players; p; p = p-&gt;next)
  {
    if (!RAD_WithinRadius(p-&gt;mo, R-&gt;info))
      continue;

    if (p-&gt;health &gt;= heal-&gt;limit)
      continue;

    if (p-&gt;health + heal-&gt;heal_amount &gt;= heal-&gt;limit)
      p-&gt;health = heal-&gt;limit;
    else
      p-&gt;health += heal-&gt;heal_amount;

    p-&gt;mo-&gt;health = p-&gt;health;
  }
}
</t>
<t tx="T1032">void RAD_ActArmourPlayers(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_armour_t *armour = (s_armour_t *) param;
  player_t *p;

  // Armour for player(s)
  for (p = players; p; p = p-&gt;next)
  {
    if (!RAD_WithinRadius(p-&gt;mo, R-&gt;info))
      continue;

    if (p-&gt;armours[armour-&gt;type] &gt;= armour-&gt;limit)
      continue;

    if (p-&gt;armours[armour-&gt;type] + armour-&gt;armour_amount &gt; armour-&gt;limit)
      p-&gt;armours[armour-&gt;type] = armour-&gt;limit;
    else
      p-&gt;armours[armour-&gt;type] += armour-&gt;armour_amount;
  }
}
</t>
<t tx="T1033">void RAD_ActBenefitPlayers(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_benefit_t *be = (s_benefit_t *) param;
  player_t *p;

  for (p = players; p; p = p-&gt;next)
  {
    if (!RAD_WithinRadius(p-&gt;mo, R-&gt;info))
      continue;

    P_GiveBenefitList(p, NULL, be-&gt;benefit, be-&gt;lose_it);
  }
}
</t>
<t tx="T1034">void RAD_ActDamageMonsters(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_damage_monsters_t *mon = (s_damage_monsters_t *) param;
 
  // -AJA- FIXME: this is _so_ non-optimal...

  mobj_t *mo;
  const mobjinfo_t *info = NULL;

  if (mon-&gt;thing_name)
  {
    info = DDF_MobjLookup(mon-&gt;thing_name);
  }
  else if (mon-&gt;thing_type &gt;= 0)
  {
    info = DDF_MobjLookupNum(mon-&gt;thing_type);

    if (info == NULL)
      I_Error("RTS DAMAGE_MONSTERS: Unknown thing type %d.\n",
          mon-&gt;thing_type);
  }
  
  // scan the mobj list
  for (mo=mobjlisthead; mo != NULL; mo=mo-&gt;next)
  {
    if (info &amp;&amp; mo-&gt;info != info)
      continue;

    if (! (mo-&gt;extendedflags &amp; EF_MONSTER) || mo-&gt;health &lt;= 0)
      continue;
    
    if (! RAD_WithinRadius(mo, R-&gt;info))
      continue;
    
    P_DamageMobj(mo, NULL, actor, mon-&gt;damage_amount, NULL);
  }
}
</t>
<t tx="T1035">void RAD_ActThingEvent(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_thing_event_t *tev = (s_thing_event_t *) param;
 
  // -AJA- FIXME: this is very sub-optimal...

  mobj_t *mo;
  const mobjinfo_t *info = NULL;
  statenum_t state;

  if (tev-&gt;thing_name)
  {
    info = DDF_MobjLookup(tev-&gt;thing_name);
  }
  else
  {
    info = DDF_MobjLookupNum(tev-&gt;thing_type);

    if (info == NULL)
      I_Error("RTS THING_EVENT: Unknown thing type %d.\n",
          tev-&gt;thing_type);
  }
  
  // scan the mobj list
  for (mo=mobjlisthead; mo != NULL; mo=mo-&gt;next)
  {
    if (mo-&gt;info != info)
      continue;

    // ignore certain things (e.g. corpses)
    if (mo-&gt;health &lt;= 0)
      continue;

    if (! RAD_WithinRadius(mo, R-&gt;info))
      continue;
    
    state = P_MobjFindLabel(mo, tev-&gt;label);

    if (state)
      P_SetMobjStateDeferred(mo, state + tev-&gt;offset, 0);
  }
}
</t>
<t tx="T1036">void RAD_ActGotoMap(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_gotomap_t *go = (s_gotomap_t *) param;

  // Warp to level n
  G_ExitToLevel(go-&gt;map_name, 5);
}
</t>
<t tx="T1037">void RAD_ActExitLevel(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_exit_t *exit = (s_exit_t *) param;

  G_ExitLevel(exit-&gt;exittime);
}
</t>
<t tx="T1038">void RAD_ActPlaySound(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_sound_t *ambient = (s_sound_t *) param;

  if (ambient-&gt;kind == PSOUND_BossMan)
  {
    S_StartSound(NULL, ambient-&gt;soundid);
    return;
  }

  // Ambient sound
  R-&gt;soundorg.x = ambient-&gt;x;
  R-&gt;soundorg.y = ambient-&gt;y;

  if (ambient-&gt;z == ONFLOORZ)
    R-&gt;soundorg.z = R_PointInSubsector(ambient-&gt;x, ambient-&gt;y)-&gt;
        sector-&gt;f_h;
  else
    R-&gt;soundorg.z = ambient-&gt;z;

  S_StartSound((mobj_t *) &amp;R-&gt;soundorg, ambient-&gt;soundid);
}
</t>
<t tx="T1039">void RAD_ActKillSound(rad_trigger_t *R, mobj_t *actor, void *param)
{
  S_StopSound((mobj_t *) &amp;R-&gt;soundorg);
}
</t>
<t tx="T1040">void RAD_ActChangeMusic(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_music_t *music = (s_music_t *) param;

  S_ChangeMusic(music-&gt;playnum, music-&gt;looping);
}
</t>
<t tx="T1041">void RAD_ActChangeTex(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_changetex_t *ctex = (s_changetex_t *) param;

  int i;

  const image_t *image;

  DEV_ASSERT2(param);

  // find texture or flat
  if (ctex-&gt;what &gt;= CHTEX_Floor)
    image = W_ImageFromFlat(ctex-&gt;texname);
  else
    image = W_ImageFromTexture(ctex-&gt;texname);

  if (ctex-&gt;what == CHTEX_Sky)
  {
    sky_image = image;
    return;
  }

  // handle the floor/ceiling case
  if (ctex-&gt;what &gt;= CHTEX_Floor)
  {
    sector_t *tsec;
    
    for (tsec = P_FindSectorFromTag(ctex-&gt;tag); tsec; 
         tsec = tsec-&gt;tag_next)
    {
      if (ctex-&gt;subtag)
      {
        boolean_t valid = false;

        for (i=0; i &lt; tsec-&gt;linecount; i++)
        {
          if (tsec-&gt;lines[i]-&gt;tag == ctex-&gt;subtag)
          {
            valid = true;
            break;
          }
        }

        if (! valid)
          continue;
      }
      
      if (ctex-&gt;what == CHTEX_Floor)
        tsec-&gt;floor.image = image;
      else
        tsec-&gt;ceil.image = image;
    }
    return;
  }

  // handle the line changers
  DEV_ASSERT2(ctex-&gt;what &lt; CHTEX_Sky);

  for (i=0; i &lt; numlines; i++)
  {
    side_t *side = (ctex-&gt;what &lt;= CHTEX_RightLower) ?
        lines[i].side[0] : lines[i].side[1];

    if (lines[i].tag != ctex-&gt;tag || !side)
      continue;
    
    if (ctex-&gt;subtag &amp;&amp; side-&gt;sector-&gt;tag != ctex-&gt;subtag)
      continue;
    
    switch (ctex-&gt;what)
    {
      case CHTEX_RightUpper:
      case CHTEX_LeftUpper:
        side-&gt;top.image = image;
        break;
        
      case CHTEX_RightMiddle:
      case CHTEX_LeftMiddle:
        side-&gt;middle.image = image;
        break;

      case CHTEX_RightLower:
      case CHTEX_LeftLower:
        side-&gt;bottom.image = image;

      default:
        break;
    }

    P_ComputeWallTiles(lines + i, 0);
    P_ComputeWallTiles(lines + i, 1);
  }
}
</t>
<t tx="T1042">void RAD_ActSkill(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_skill_t *skill = (s_skill_t *) param;

  // Skill selection trigger function
  // -ACB- 1998/07/30 replaced respawnmonsters with respawnsetting.
  // -ACB- 1998/08/27 removed fastparm temporaryly.
  
  gameskill = skill-&gt;skill;

  level_flags.fastparm = skill-&gt;FastMonsters;
  level_flags.respawn = skill-&gt;Respawn;
}
</t>
<t tx="T1043">static void MoveOneSector(sector_t *sec, s_movesector_t *t)
{
  float_t dh;

  if (t-&gt;relative)
    dh = t-&gt;value;
  else if (t-&gt;is_ceiling)
    dh = t-&gt;value - sec-&gt;c_h;
  else
    dh = t-&gt;value - sec-&gt;f_h;
      
  if (! P_CheckSolidSectorMove(sec, t-&gt;is_ceiling, dh))
    return;

  P_SolidSectorMove(sec, t-&gt;is_ceiling, dh, true, false);
}
</t>
<t tx="T1044">void RAD_ActMoveSector(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_movesector_t *t = (s_movesector_t *) param;
  int i;

  // SectorV compatibility
  if (t-&gt;tag == 0)
  {
    if (t-&gt;secnum &lt; 0 || t-&gt;secnum &gt;= numsectors)
      I_Error("RTS SECTORV: no such sector %d.\n", t-&gt;secnum);

    MoveOneSector(sectors + t-&gt;secnum, t);
    return;
  }

  // OPTIMISE !
  for (i=0; i &lt; numsectors; i++)
  {
    if (sectors[i].tag == t-&gt;tag)
      MoveOneSector(sectors + i, t);
  }
}
</t>
<t tx="T1045">static void LightOneSector(sector_t *sec, s_lightsector_t *t)
{
  if (t-&gt;relative)
    sec-&gt;props.lightlevel += t-&gt;value;
  else
    sec-&gt;props.lightlevel = t-&gt;value;
}
</t>
<t tx="T1046">void RAD_ActLightSector(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_lightsector_t *t = (s_lightsector_t *) param;
  int i;

  // SectorL compatibility
  if (t-&gt;tag == 0)
  {
    if (t-&gt;secnum &lt; 0 || t-&gt;secnum &gt;= numsectors)
      I_Error("RTS SECTORL: no such sector %d.\n", t-&gt;secnum);

    LightOneSector(sectors + t-&gt;secnum, t);
    return;
  }

  // OPTIMISE !
  for (i=0; i &lt; numsectors; i++)
  {
    if (sectors[i].tag == t-&gt;tag)
      LightOneSector(sectors + i, t);
  }
}
</t>
<t tx="T1047">void RAD_ActEnableScript(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_enabler_t *t = (s_enabler_t *) param;
  rad_trigger_t *other;

  // Enable/Disable Scripts
  if (t-&gt;script_name)
  {
    other = RAD_FindTriggerByName(t-&gt;script_name);

    if (! other)
      return;
    
    other-&gt;disabled = t-&gt;new_disabled;
  }
  else
  {
    RAD_EnableByTag(actor, t-&gt;tag, t-&gt;new_disabled);
  }
}
</t>
<t tx="T1048">void RAD_ActActivateLinetype(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_lineactivator_t *t = (s_lineactivator_t *) param;

  P_RemoteActivation(actor, t-&gt;typenum, t-&gt;tag, 0, line_Any);
}
</t>
<t tx="T1049">void RAD_ActUnblockLines(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_lineunblocker_t *ub = (s_lineunblocker_t *) param;

  int i;

  for (i=0; i &lt; numlines; i++)
  {
    line_t *ld = lines + i;

    if (ld-&gt;tag != ub-&gt;tag)
      continue;

    if (! ld-&gt;side[0] || ! ld-&gt;side[1])
      continue;

    // clear standard flags
    ld-&gt;flags &amp;= ~(ML_Blocking | ML_BlockMonsters);

    // clear EDGE's extended lineflags too
    ld-&gt;flags &amp;= ~(ML_SightBlock | ML_ShootBlock);
  }
}
</t>
<t tx="T1050">void RAD_ActJump(rad_trigger_t *R, mobj_t *actor, void *param)
{
  s_jump_t *t = (s_jump_t *) param;

  if (! P_RandomTest(t-&gt;random_chance))
    return;

  if (! t-&gt;cache_state)
  {
    t-&gt;cache_state = RAD_FindStateByLabel(R-&gt;info, t-&gt;label);

    if (! t-&gt;cache_state)
      I_Error("RTS: No such label `%s' for JUMP primitive.\n", t-&gt;label);
  }

  R-&gt;state = t-&gt;cache_state;

  // Jumps have a one tic surcharge, to prevent accidental infinite
  // loops within radius scripts.
  R-&gt;wait_tics += 1;
}
</t>
<t tx="T1051">void RAD_ActSleep(rad_trigger_t *R, mobj_t *actor, void *param)
{
  R-&gt;disabled = true;
}
</t>
<t tx="T1052">void RAD_ActRetrigger(rad_trigger_t *R, mobj_t *actor, void *param)
{
  R-&gt;activated = false;
}
</t>
<t tx="T1053">@ignore
@language c

// Radius Trigger Parsing

&lt;&lt; rad_pars #includes &gt;&gt;
&lt;&lt; rad_pars declarations &gt;&gt;
@others
</t>
<t tx="T1054">#include "i_defs.h"
#include "rad_trig.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "hu_lib.h"
#include "hu_stuff.h"
#include "g_game.h"
#include "m_argv.h"
#include "m_swap.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_defs.h"
#include "s_sound.h"
#include "v_res.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1055">

typedef struct define_s
{
  // next in list
  struct define_s *next;

  char *name;
  char *value;
}
define_t;

typedef struct rts_parser_s
{
  // needed level:
  //   -1 : don't care
  //    0 : outside any block
  //    1 : within START_MAP block
  //    2 : within RADIUSTRIGGER block
  int level;

  // name
  char *name;

  // number of parameters
  int min_pars, max_pars;

  // parser function
  void (* parser)(int pnum, const char ** pars);
}
rts_parser_t;


int rad_cur_linenum;
char *rad_cur_filename;
static char *rad_cur_linedata = NULL;

static char tokenbuf[4096];

// -AJA- 1999/09/12: Made all these static.  The variable `defines'
//       was clashing with the one in ddf_main.c.  ARGH !

// Define List
static define_t *defines;

// Determine whether the code blocks are started and terminated.
static int rad_cur_level = 0;

static const char *rad_level_names[3] =
{ "outer area", "map area", "trigger area" };

// Location of current script
static rad_script_t *this_rad;
static char *this_map = NULL;

// Pending state info for current script
static int pending_wait_tics = 0;
static char *pending_label = NULL;

// Default tip properties (position, colour, etc)
static s_tip_prop_t default_tip_props =
    { -1, -1, -1, -1, NULL, -1.0, 0 };
</t>
<t tx="T1056">

int RAD_StringHashFunc(const char *s)
{
  int r = 0;
  int c;

  while (*s)
  {
    r *= 36;
    if (*s &gt;= 'a' &amp;&amp; *s &lt;= 'z')
      c = *s - 'a';
    else if (*s &gt;= 'A' &amp;&amp; *s &lt;= 'Z')
      c = *s - 'A';
    else if (*s &gt;= '0' &amp;&amp; *s &lt;= '9')
      c = *s - '0' + 'Z' - 'A' + 1;
    else
      c = *s;
    r += c % 36;
    s++;
  }

  return r;
}
</t>
<t tx="T1057">@ RAD_Error

-AJA- 2000/01/04: written.
@c

void RAD_Error(const char *err, ...)
{
  va_list argptr;
  char buffer[2048];
  char *pos;

  buffer[2047] = 0;

  // put actual message on first line
  va_start(argptr, err);
  vsprintf(buffer, err, argptr);
  va_end(argptr);
  
  pos = buffer + strlen(buffer);

  sprintf(pos, "Error occurred near line %d of %s\n", rad_cur_linenum, 
        rad_cur_filename);
  pos += strlen(pos);
  
  if (rad_cur_linedata)
  {
    sprintf(pos, "Line contents: %s\n", rad_cur_linedata);
    pos += strlen(pos);
  }
   
  // check for buffer overflow
  DEV_ASSERT(buffer[2047] == 0, ("Buffer overflow in DDF_Error"));
  
  // add a blank line for readability under DOS/Linux.  Two linefeeds
  // because the cursor may be at the end of a line with dots.
  I_Printf("\n\n");
 
  I_Error("%s", buffer);
}
</t>
<t tx="T1058">
void RAD_Warning(const char *err, ...)
{
  va_list argptr;
  char buffer[1024];

  if (no_warnings)
    return;

  va_start(argptr, err);
  vsprintf(buffer, err, argptr);
  va_end(argptr);
  
  I_Warning("\n");
  I_Warning("Found problem near line %d of %s\n", rad_cur_linenum, 
        rad_cur_filename);
  
  if (rad_cur_linedata)
    I_Warning("with line contents: %s\n", rad_cur_linedata);
   
  I_Warning("%s", buffer);
}
</t>
<t tx="T1059">
void RAD_WarnError(const char *err, ...)
{
  va_list argptr;
  char buffer[1024];

  va_start(argptr, err);
  vsprintf(buffer, err, argptr);
  va_end(argptr);

  if (strict_errors)
    RAD_Error("%s", buffer);
  else
    RAD_Warning("%s", buffer);
}
</t>
<t tx="T1060">
static void RAD_ErrorSetLineData(const char *data)
{
  if (rad_cur_linedata)
    Z_Free(rad_cur_linedata);
  
  rad_cur_linedata = Z_StrDup(data);
}
</t>
<t tx="T1061">
static void RAD_ErrorClearLineData(void)
{
  if (rad_cur_linedata)
  {
    Z_Free(rad_cur_linedata);
    rad_cur_linedata = NULL;
  }
}
</t>
<t tx="T1062">@ Searches through the #defines namespace for a match and returns
its value if it exists.
@c

static boolean_t CheckForDefine(const char *s, char ** val)
{
  define_t *tempnode = defines;

  for (; tempnode; tempnode = tempnode-&gt;next)
  {
    if (strcmp(s, tempnode-&gt;name) == 0)
    {
      *val = Z_StrDup(tempnode-&gt;value);
      return true;
    }
  }
  return false;
}
</t>
<t tx="T1063">
static void RAD_CheckForInt(const char *value, int *retvalue)
{
  const char *pos = value;
  int count = 0;
  int length = strlen(value);

  // Accomodate for "-" as you could have -5 or something like that.
  if (*pos == '-')
  {
    count++;
    pos++;
  }
  while (isdigit(*pos++))
    count++;

  // Is the value an integer?
  if (length != count)
    RAD_Error("Parameter is not of numeric type: %s\n", value);

  *retvalue = atoi(value);
}
</t>
<t tx="T1064">static void RAD_CheckForFloat(const char *value, float_t *retvalue)
{
  if (sscanf(value, "%f", retvalue) != 1)
    RAD_Error("Parameter is not of numeric type: %s\n", value);
}
</t>
<t tx="T1065">@ RAD_CheckForPercent

Reads percentages (0%..100%).
@c

static void RAD_CheckForPercent(const char *info, void *storage)
{
  char s[101];
  char *p;
  float_t f;

  // just check that the string is valid
  Z_StrNCpy(s, info, 100);
  for (p = s; isdigit(*p) || *p == '.'; p++)
  { /* nothing here */ }

  // the number must be followed by %
  if (*p != '%')
    RAD_Error("Parameter is not of percent type: %s\n", info);
  *p = 0;

  RAD_CheckForFloat(s, &amp;f);
  if (f &lt; 0.0 || f &gt; 100.0)
    RAD_Error("Percentage out of range: %s\n", info);

  *(percent_t *)storage = f / 100.0;
}
</t>
<t tx="T1066">@ RAD_CheckForPercentAny

Like the above routine, but don't limit to 0..100%.
@c

static void RAD_CheckForPercentAny(const char *info, void *storage)
{
  char s[101];
  char *p;
  float_t f;

  // just check that the string is valid
  Z_StrNCpy(s, info, 100);
  for (p = s; isdigit(*p) || *p == '.'; p++)
  { /* nothing here */ }

  // the number must be followed by %
  if (*p != '%')
    RAD_Error("Parameter is not of percent type: %s\n", info);
  *p = 0;

  RAD_CheckForFloat(s, &amp;f);

  *(percent_t *)storage = f / 100.0;
}
</t>
<t tx="T1067">@ -ES- Copied from DDF_MainGetTime.
FIXME: Collect all functions that are common to DDF and RTS,
and move them to a new module for RTS+DDF common code.
@c

static void RAD_CheckForTime(const char *info, void *storage)
{
  float val;
  int *dest = (int *)storage;
  int i;
  char *s;

  DEV_ASSERT2(info &amp;&amp; storage);

  // -ES- 1999/09/14 MAXT means that time should be maximal.
  if (!stricmp(info, "maxt"))
  {
    *dest = INT_MAX; // -ACB- 1999/09/22 Standards, Please.
    return;
  }

  s = strchr(info, 'T');
  if (!s)
    s = strchr(info, 't');
    
  if (s)
  {
    i = s-info;
    s = I_TmpMalloc(i + 1);
    Z_StrNCpy(s, info, i);
    RAD_CheckForInt(s, storage);
    I_TmpFree(s);
    return;
  }

  if (sscanf(info, "%f", &amp;val) != 1)
  {
    I_Warning("Bad time value `%s'.\n", info);
    return;
  }

  *dest = (int)(val * (float_t)TICRATE);
}
</t>
<t tx="T1068">
static armour_type_e RAD_CheckForArmourType(const char *info)
{
  if (DDF_CompareName(info, "GREEN") == 0)
    return ARMOUR_Green;
  else if (DDF_CompareName(info, "BLUE") == 0)
    return ARMOUR_Blue;
  else if (DDF_CompareName(info, "YELLOW") == 0)
    return ARMOUR_Yellow;
  else if (DDF_CompareName(info, "RED") == 0)
    return ARMOUR_Red;
  
  RAD_Error("Unknown armour type: %s\n", info);
  return 0;
}
</t>
<t tx="T1069">
static changetex_type_e RAD_CheckForChangetexType(const char *info)
{
  if (DDF_CompareName(info, "LEFT_UPPER") == 0)
    return CHTEX_LeftUpper;
  else if (DDF_CompareName(info, "LEFT_MIDDLE") == 0)
    return CHTEX_LeftMiddle;
  else if (DDF_CompareName(info, "LEFT_LOWER") == 0)
    return CHTEX_LeftLower;
  if (DDF_CompareName(info, "RIGHT_UPPER") == 0)
    return CHTEX_RightUpper;
  else if (DDF_CompareName(info, "RIGHT_MIDDLE") == 0)
    return CHTEX_RightMiddle;
  else if (DDF_CompareName(info, "RIGHT_LOWER") == 0)
    return CHTEX_RightLower;
  else if (DDF_CompareName(info, "FLOOR") == 0)
    return CHTEX_Floor;
  else if (DDF_CompareName(info, "CEILING") == 0)
    return CHTEX_Ceiling;
  else if (DDF_CompareName(info, "SKY") == 0)
    return CHTEX_Sky;

  RAD_Error("Unknown ChangeTex type `%s'\n", info);
  return 0;
}
</t>
<t tx="T1070">@ RAD_UnquoteString

Remove the quotes from the given string, returning a newly
allocated string.
@c

static char *RAD_UnquoteString(const char *s)
{
  int tokenlen = 0;

  // skip initial quote
  s++;

  while (*s != '"')
  {
#ifdef DEVELOPERS
    if (*s == 0)
      I_Error("INTERNAL ERROR: bad string.\n");
#endif
    
    // -AJA- 1999/09/07: check for \n. Only temporary, awaiting bison...
    if (s[0] == '\\' &amp;&amp; toupper(s[1]) == 'N')
    {
      tokenbuf[tokenlen++] = '\n';
      s += 2;
      continue;
    }
    
    tokenbuf[tokenlen++] = *s++;
  }

  tokenbuf[tokenlen] = 0;
  return Z_StrDup(tokenbuf);
}
</t>
<t tx="T1071">
static boolean_t CheckForBoolean(const char *s)
{
  if (strcmp(s, "TRUE") == 0 || strcmp(s, "1") == 0)
    return true;

  if (strcmp(s, "FALSE") == 0 || strcmp(s, "0") == 0)
    return false;

  // Nope, it's an error.
  RAD_Error("Bad boolean value (should be TRUE or FALSE): %s\n", s);
  return false;
}
</t>
<t tx="T1072">@ DoParseWhenAppear

-AJA- 1999/09/25: written (rather quickly).
-AJA- FIXME: duplicated code, use DDF_MainGetWhenAppear someday.
@c

static void DoParseWhenAppear(rad_script_t *scr, const char *skill)
{
  scr-&gt;appear = 0;
  
  if (strstr(skill, "1")) scr-&gt;appear |= 1 &lt;&lt; 0;
  if (strstr(skill, "2")) scr-&gt;appear |= 1 &lt;&lt; 1;
  if (strstr(skill, "3")) scr-&gt;appear |= 1 &lt;&lt; 2;
  if (strstr(skill, "4")) scr-&gt;appear |= 1 &lt;&lt; 3;
  if (strstr(skill, "5")) scr-&gt;appear |= 1 &lt;&lt; 4;

  if (strstr(skill, "SP") || strstr(skill, "sp"))
    scr-&gt;appear |= WNAP_Single;
  if (strstr(skill, "COOP") || strstr(skill, "coop"))
    scr-&gt;appear |= WNAP_Coop;
  if (strstr(skill, "DM") || strstr(skill, "dm"))
    scr-&gt;appear |= WNAP_DeathMatch;
}
</t>
<t tx="T1073">
static void DoParsePlayerSet(const char *info, unsigned long *set)
{
  const char *p = info;
  const char *next;
  int num;

  *set = 0;

  if (DDF_CompareName(info, "ALL") == 0)
  {
    *set = ~0;
    return;
  }

  for (;;)
  {
    if (! isdigit(p[0]))
      RAD_Error("Bad number in set of players: %s\n", info);

    num = strtol(p, (char **) &amp;next, 10);

    *set |= (1 &lt;&lt; (num-1));

    p = next;

    if (p[0] == 0)
      break;

    if (p[0] != ':')
      RAD_Error("Missing `:' in set of players: %s\n", info);

    p++;
  }
}
</t>
<t tx="T1074">@ AddStateToScript

Adds a new action state to the tail of the current set of states
for the given radius trigger.

-AJA- 1999/10/23: written.
@c

static void AddStateToScript(rad_script_t *R, int tics,
    void (* action)(struct rad_trigger_s *R, mobj_t *actor, void *param), 
    void *param)
{
  rts_state_t *state;

  state = Z_ClearNew(rts_state_t, 1);

  state-&gt;tics = tics;
  state-&gt;action = action;
  state-&gt;param = param;

  state-&gt;tics += pending_wait_tics;
  state-&gt;label = pending_label;

  pending_wait_tics = 0;
  pending_label = NULL;

  // link it in
  state-&gt;next = NULL;
  state-&gt;prev = R-&gt;last_state;

  if (R-&gt;last_state)
    R-&gt;last_state-&gt;next = state;
  else
    R-&gt;first_state = state;

  R-&gt;last_state = state;
}
</t>
<t tx="T1075">@ ClearOneScripts
@c

static void ClearOneScript(rad_script_t *scr)
{
  Z_Free(scr-&gt;mapid);

  while (scr-&gt;boss_trig)
  {
    s_ondeath_t *cur = scr-&gt;boss_trig;
    scr-&gt;boss_trig = cur-&gt;next;

    Z_Free(cur);
  }
  
  while (scr-&gt;height_trig)
  {
    s_onheight_t *cur = scr-&gt;height_trig;
    scr-&gt;height_trig = cur-&gt;next;

    Z_Free(cur);
  }

  // free all states
  while (scr-&gt;first_state)
  {
    rts_state_t *cur = scr-&gt;first_state;
    scr-&gt;first_state = cur-&gt;next;

    if (cur-&gt;param)
      Z_Free(cur-&gt;param);
    
    Z_Free(cur);
  }
}
</t>
<t tx="T1076">@ ClearPreviousScripts

Removes any radius triggers for a given map when start_map is used.
Thus triggers in later RTS files/lumps replace those in earlier RTS
files/lumps in the specified level.

-AJA- 1999/10/05: written.
@c

static void ClearPreviousScripts(const char *mapid)
{
  rad_script_t *scr, *next;

  for (scr=r_scripts; scr; scr=next)
  {
    next = scr-&gt;next;

    if (strcmp(scr-&gt;mapid, mapid) == 0)
    {
      // unlink and free it
      if (scr-&gt;next)
        scr-&gt;next-&gt;prev = scr-&gt;prev;

      if (scr-&gt;prev)
        scr-&gt;prev-&gt;next = scr-&gt;next;
      else
        r_scripts = scr-&gt;next;
      
      ClearOneScript(scr);

      Z_Free(scr);
    }
  }
}
</t>
<t tx="T1077">@ ClearAllScripts

Removes all radius triggers from all maps.

-AJA- 1999/10/05: written.
@c

static void ClearAllScripts(void)
{
  while (r_scripts)
  {
    rad_script_t *scr = r_scripts;
    r_scripts = scr-&gt;next;

    ClearOneScript(scr);

    Z_Free(scr);
  }
}
</t>
<t tx="T1078">@ RAD_ComputeScriptCRC
@c

static void RAD_ComputeScriptCRC(rad_script_t *scr)
{
  int flags;

  CRC32_Init(&amp;scr-&gt;crc);

  // Note: the mapid doesn't belong in the CRC

  if (scr-&gt;script_name)
    CRC32_ProcessStr(&amp;scr-&gt;crc, scr-&gt;script_name);

  CRC32_ProcessInt(&amp;scr-&gt;crc, scr-&gt;tag);
  CRC32_ProcessInt(&amp;scr-&gt;crc, scr-&gt;appear);
  CRC32_ProcessInt(&amp;scr-&gt;crc, scr-&gt;min_players);
  CRC32_ProcessInt(&amp;scr-&gt;crc, scr-&gt;max_players);
  CRC32_ProcessInt(&amp;scr-&gt;crc, scr-&gt;repeat_count);

  CRC32_ProcessInt(&amp;scr-&gt;crc, (int)scr-&gt;x);
  CRC32_ProcessInt(&amp;scr-&gt;crc, (int)scr-&gt;y);
  CRC32_ProcessInt(&amp;scr-&gt;crc, (int)scr-&gt;z);
  CRC32_ProcessInt(&amp;scr-&gt;crc, (int)scr-&gt;rad_x);
  CRC32_ProcessInt(&amp;scr-&gt;crc, (int)scr-&gt;rad_y);
  CRC32_ProcessInt(&amp;scr-&gt;crc, (int)scr-&gt;rad_z);

  // lastly handle miscellaneous parts

  #undef M_FLAG
  #define M_FLAG(bit, cond)  \
      if cond { flags |= (1 &lt;&lt; (bit)); }

  flags = 0;
  
  M_FLAG(0, (scr-&gt;tagged_disabled));
  M_FLAG(1, (scr-&gt;tagged_use));
  M_FLAG(2, (scr-&gt;tagged_independent));
  M_FLAG(3, (scr-&gt;tagged_immediate));

  M_FLAG(4, (scr-&gt;boss_trig != NULL));
  M_FLAG(5, (scr-&gt;height_trig != NULL));
  M_FLAG(6, (scr-&gt;cond_trig != NULL));
  M_FLAG(7, (scr-&gt;next_in_path != NULL));

  CRC32_ProcessInt(&amp;scr-&gt;crc, flags);

  // Q/ add in states ?  
  // A/ Nah.
  
  CRC32_Done(&amp;scr-&gt;crc);
}
</t>
<t tx="T1079">
#undef M_FLAG

// RAD_CollectParameters
//
// Collect the parameters from the line into an array of strings
// `pars', which can hold at most `max' string pointers.
// 
// -AJA- 1999/10/23: written.
// -AJA- 2000/01/02: Moved #define handling to here.
//
static void RAD_CollectParameters(const char *line, int *pnum, 
    char ** pars, int max)
{
  int tokenlen = -1;
  boolean_t in_string = false;

  *pnum = 0;

  for (;;)
  {
    int ch = *line;

    if (in_string)
    {
      if (ch == 0)
        RAD_Error("Nonterminated string found.\n");

      if (ch == '"')
        in_string = false;

      tokenbuf[tokenlen++] = ch;
      line++;
      continue;
    }

    if (tokenlen &gt;= 0)
    {
      // end of token ?
      if (ch == 0 || isspace(ch) ||
          ch == ';' || (line[0] == '/' &amp;&amp; line[1] == '/'))
      {
        tokenbuf[tokenlen] = 0;
        tokenlen = -1;

        if (*pnum &gt;= max)
          RAD_Error("Too many tokens on line\n");
          
        // check for defines 
        if (! CheckForDefine(tokenbuf, &amp;pars[*pnum]))
          pars[*pnum] = Z_StrDup(tokenbuf);

        *pnum += 1;

        // end of line ?
        if (ch == 0 || ch == ';' || (line[0] == '/' &amp;&amp; line[1] == '/'))
          break;

        line++;
        continue;
      }

      tokenbuf[tokenlen++] = ch;
      line++;
      continue;
    }
    
    // end of line ?
    if (ch == 0 || ch == ';' || (line[0] == '/' &amp;&amp; line[1] == '/'))
      break;

    if (isspace(ch))
    {
      line++;
      continue;
    }

    // string ?
    if (ch == '"')
      in_string = true;

    // must be token
    tokenbuf[0] = ch;
    tokenlen = 1;
    line++;
    continue;
  }
}
</t>
<t tx="T1080">@ RAD_FreeParameters

Free previously collected parameters.

-AJA- 1999/10/23: written.
@c

static void RAD_FreeParameters(int pnum, char **pars)
{
  while (pnum &gt; 0)
  {
    Z_Free(pars[--pnum]);
  }
}
</t>
<t tx="T1081">@ ---- Primitive Parsers ----------------------------------------------
@c

static void RAD_ParseVersion(int pnum, const char **pars)
{
  // #Version &lt;vers&gt;

  float vers;

  RAD_CheckForFloat(pars[1], &amp;vers);
  
  if (vers &gt; (float_t) PARSERV / (float_t) PARSERVFIX)
    RAD_Error("This version of EDGE cannot handle this script\n");
}
</t>
<t tx="T1082">
static void RAD_ParseClearAll(int pnum, const char **pars)
{
  // #ClearAll

  ClearAllScripts();
}
</t>
<t tx="T1083">
static void RAD_ParseDefine(int pnum, const char **pars)
{
  // #Define &lt;identifier&gt; &lt;num&gt;

  define_t *newdef;

  newdef = Z_ClearNew(define_t, 1);

  newdef-&gt;name  = Z_StrDup(pars[1]);
  newdef-&gt;value = Z_StrDup(pars[2]);

  // link it in
  newdef-&gt;next = defines;
  defines = newdef;
}
</t>
<t tx="T1084">
static void RAD_ParseStartMap(int pnum, const char **pars)
{
  // Start_Map &lt;map&gt;

  if (rad_cur_level != 0)
    RAD_Error("%s found, but previous END_MAP missing !\n", pars[0]);

  // -AJA- 1999/08/02: New scripts replace old ones.
  ClearPreviousScripts(pars[1]);

  this_map = Z_StrDup(pars[1]);
  strupr(this_map);

  rad_cur_level++;
}
</t>
<t tx="T1085">
static void RAD_ParseRadiusTrigger(int pnum, const char **pars)
{
  // RadiusTrigger &lt;x&gt; &lt;y&gt; &lt;radius&gt;
  // RadiusTrigger &lt;x&gt; &lt;y&gt; &lt;radius&gt; &lt;low z&gt; &lt;high z&gt;
  //
  // RectTrigger &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;
  // RectTrigger &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; &lt;z1&gt; &lt;z2&gt;

  // -AJA- 1999/09/12: Reworked for having Z-restricted triggers.

  if (rad_cur_level == 2)
    RAD_Error("%s found, but previous END_RADIUSTRIGGER missing !\n",
      pars[0]);

  if (rad_cur_level == 0)
    RAD_Error("%s found, but without any START_MAP !\n", pars[0]);
  
  // Set the node up, from now on we can use rscript as it points
  // to the new node.

  this_rad = Z_ClearNew(rad_script_t, 1);

  // set defaults
  this_rad-&gt;z = 0;
  this_rad-&gt;rad_z = -1;
  this_rad-&gt;appear = DEFAULT_APPEAR;
  this_rad-&gt;min_players = 0;
  this_rad-&gt;max_players = INT_MAX;
  this_rad-&gt;netmode = RNET_Separate;
  this_rad-&gt;what_players = ~0;  // "ALL"
  this_rad-&gt;absolute_req_players = 1;
  this_rad-&gt;repeat_count = -1;
  this_rad-&gt;repeat_delay = 0;

  pending_wait_tics = 0;
  pending_label = NULL;

  if (DDF_CompareName("RECT_TRIGGER", pars[0]) == 0)
  {
    float_t x1, y1, x2, y2, z1, z2;

    if (pnum == 6)
      RAD_Error("%s: Wrong number of parameters.\n", pars[0]);

    RAD_CheckForFloat(pars[1], &amp;x1);
    RAD_CheckForFloat(pars[2], &amp;y1);
    RAD_CheckForFloat(pars[3], &amp;x2);
    RAD_CheckForFloat(pars[4], &amp;y2);

    if (x1 &gt; x2)
      RAD_WarnError("%s: bad X range %1.1f to %1.1f\n", pars[0], x1, x2);
    if (y1 &gt; y2)
      RAD_WarnError("%s: bad Y range %1.1f to %1.1f\n", pars[0], y1, y2);
       
    this_rad-&gt;x = (x1 + x2) / 2;
    this_rad-&gt;y = (y1 + y2) / 2;
    this_rad-&gt;rad_x = fabs(x1 - x2) / 2;
    this_rad-&gt;rad_y = fabs(y1 - y2) / 2;

    if (pnum &gt;= 7)
    {
      RAD_CheckForFloat(pars[5], &amp;z1);
      RAD_CheckForFloat(pars[6], &amp;z2);

      if (z1 &gt; z2 + 1)
        RAD_WarnError("%s: bad height range %1.1f to %1.1f\n",
          pars[0], z1, z2);
       
      this_rad-&gt;z = (z1 + z2) / 2;
      this_rad-&gt;rad_z = fabs(z1 - z2) / 2;
    }
  }
  else
  {
    if (pnum == 5)
      RAD_Error("%s: Wrong number of parameters.\n", pars[0]);

    RAD_CheckForFloat(pars[1], &amp;this_rad-&gt;x);
    RAD_CheckForFloat(pars[2], &amp;this_rad-&gt;y);
    RAD_CheckForFloat(pars[3], &amp;this_rad-&gt;rad_x);

    this_rad-&gt;rad_y = this_rad-&gt;rad_x;

    if (pnum &gt;= 6)
    {
      float_t z1, z2;

      RAD_CheckForFloat(pars[4], &amp;z1);
      RAD_CheckForFloat(pars[5], &amp;z2);

      if (z1 &gt; z2)
        RAD_WarnError("%s: bad height range %1.1f to %1.1f\n",
          pars[0], z1, z2);
       
      this_rad-&gt;z = (z1 + z2) / 2;
      this_rad-&gt;rad_z = fabs(z1 - z2) / 2;
    }
  }

  // link it in
  this_rad-&gt;next = r_scripts;
  this_rad-&gt;prev = NULL;

  if (r_scripts)
    r_scripts-&gt;prev = this_rad;

  r_scripts = this_rad;

  rad_cur_level++;
}
</t>
<t tx="T1086">
static void RAD_ParseEndRadiusTrigger(int pnum, const char **pars)
{
  // End_RadiusTrigger

  if (rad_cur_level != 2)
    RAD_Error("%s found, but without any RADIUSTRIGGER !\n", pars[0]);

  // --- check stuff ---
 
  // handle any pending WAIT or LABEL values
  if (pending_wait_tics &gt; 0 || pending_label)
  {
    AddStateToScript(this_rad, 0, RAD_ActNOP, NULL);
  }
  
  this_rad-&gt;mapid = Z_StrDup(this_map);
  RAD_ComputeScriptCRC(this_rad);
  this_rad = NULL;

  rad_itemsread++;
  rad_cur_level--;
}
</t>
<t tx="T1087">
static void RAD_ParseEndMap(int pnum, const char **pars)
{
  // End_Map

  if (rad_cur_level == 2)
    RAD_Error("%s found, but previous END_RADIUSTRIGGER missing !\n",
      pars[0]);

  if (rad_cur_level == 0)
    RAD_Error("%s found, but without any START_MAP !\n", pars[0]);
  
  this_map = NULL;

  rad_cur_level--;
}
</t>
<t tx="T1088">
static void RAD_ParseName(int pnum, const char **pars)
{
  // Name &lt;name&gt;
  //
  // -AJA- 1999/09/25: added this primitive.

  if (this_rad-&gt;script_name)
    RAD_Error("Script already has a name: `%s'\n", this_rad-&gt;script_name);
    
  this_rad-&gt;script_name = Z_StrDup(pars[1]);
}
</t>
<t tx="T1089">
static void RAD_ParseTag(int pnum, const char **pars)
{
  // Tag &lt;number&gt;
  //
  // -AJA- 2000/01/09: added this primitive.

  if (this_rad-&gt;tag != 0)
    RAD_Error("Script already has a tag: `%d'\n", this_rad-&gt;tag);
   
  RAD_CheckForInt(pars[1], &amp;this_rad-&gt;tag);
}
</t>
<t tx="T1090">
static void RAD_ParseWhenAppear(int pnum, const char **pars)
{
  // When_Appear 1:2:3:4:5:sp:coop:dm:extra

  DoParseWhenAppear(this_rad, pars[1]);
}
</t>
<t tx="T1091">
static void RAD_ParseWhenPlayerNum(int pnum, const char **pars)
{
  // When_Player_Num &lt;num&gt;
  // When_Player_Num &lt;min&gt; &lt;max&gt;

  RAD_CheckForInt(pars[1], &amp;this_rad-&gt;min_players);
  this_rad-&gt;max_players = this_rad-&gt;min_players;

  if (pnum &gt;= 3)
    RAD_CheckForInt(pars[2], &amp;this_rad-&gt;max_players);

  if (this_rad-&gt;min_players &lt; 0 || 
      this_rad-&gt;min_players &gt; this_rad-&gt;max_players)
  {
    RAD_Error("Illegal playernum range: %d..%d\n",
        this_rad-&gt;min_players, this_rad-&gt;max_players);
  }
}
</t>
<t tx="T1092">
static void RAD_ParseNetMode(int pnum, const char **pars)
{
  // Net_Mode SEPARATE
  // Net_Mode SEPARATE &lt;player set&gt;
  //
  // Net_Mode ABSOLUTE
  // Net_Mode ABSOLUTE &lt;min players&gt;

  if (DDF_CompareName(pars[1], "SEPARATE") == 0)
  {
    this_rad-&gt;netmode = RNET_Separate;

    if (pnum &gt;= 3)
      DoParsePlayerSet(pars[2], &amp;this_rad-&gt;what_players);

    return;
  }

  if (DDF_CompareName(pars[1], "ABSOLUTE") == 0)
  {
    this_rad-&gt;netmode = RNET_Absolute;

    if (pnum &gt;= 3)
    {
      if (DDF_CompareName(pars[2], "ALL") == 0)
        this_rad-&gt;absolute_req_players = -1;
      else
         RAD_CheckForInt(pars[2], &amp;this_rad-&gt;absolute_req_players);
    }

    return;
  }

  RAD_Error("%s: unknown mode `%s'\n", pars[0], pars[1]);
}
</t>
<t tx="T1093">
static void RAD_ParseTaggedRepeatable(int pnum, const char **pars)
{
  // Tagged_Repeatable
  // Tagged_Repeatable &lt;num repetitions&gt;
  // Tagged_Repeatable &lt;num repetitions&gt; &lt;delay&gt;

  if (this_rad-&gt;repeat_count &gt;= 0)
    RAD_Error("%s: can only be used once.\n", pars[0]);

  if (pnum &gt;= 2)
     RAD_CheckForInt(pars[1], &amp;this_rad-&gt;repeat_count);
  else
     this_rad-&gt;repeat_count = 0;

  // -ES- 2000/03/03 Changed to RAD_CheckForTime.
  if (pnum &gt;= 3)
    RAD_CheckForTime(pars[2], &amp;this_rad-&gt;repeat_delay);
  else
    this_rad-&gt;repeat_delay = 1;
}
</t>
<t tx="T1094">
static void RAD_ParseTaggedUse(int pnum, const char **pars)
{
  // Tagged_Use

  this_rad-&gt;tagged_use = true;
}
</t>
<t tx="T1095">
static void RAD_ParseTaggedIndependent(int pnum, const char **pars)
{
  // Tagged_Independent

  this_rad-&gt;tagged_independent = true;
}
</t>
<t tx="T1096">
static void RAD_ParseTaggedImmediate(int pnum, const char **pars)
{
  // Tagged_Immediate

  this_rad-&gt;tagged_immediate = true;
}
</t>
<t tx="T1097">
static void RAD_ParseTaggedPlayerSpecific(int pnum, const char **pars)
{
  // Tagged_Player_Specific

  if (this_rad-&gt;netmode != RNET_Separate)
    RAD_Error("%s can only be used with NET_MODE SEPARATE\n", pars[0]);

  this_rad-&gt;tagged_player_specific = true;
}
</t>
<t tx="T1098">
static void RAD_ParseTaggedDisabled(int pnum, const char **pars)
{
  // Tagged_Disabled

  this_rad-&gt;tagged_disabled = true;
}
</t>
<t tx="T1099">
static void RAD_ParseTaggedPath(int pnum, const char **pars)
{
  // Tagged_Path  &lt;next node&gt;
  //
  // -AJA- 1999/09/25: added this primitive.

  rts_path_t *path = Z_ClearNew(rts_path_t, 1);

  path-&gt;next = this_rad-&gt;next_in_path;
  path-&gt;name = Z_StrDup(pars[1]);

  this_rad-&gt;next_in_path = path;
  this_rad-&gt;next_path_total += 1;
}
</t>
<t tx="T1100">
static void RAD_ParsePathEvent(int pnum, const char **pars)
{
  // Path_Event  &lt;label&gt;

  const char *div;
  int i;

  if (this_rad-&gt;path_event_label)
    RAD_Error("%s: Can only be used once per trigger.\n", pars[0]);
   
  // parse the label name
  div = strchr(pars[1], ':');

  i = div ? (div - pars[1]) : strlen(pars[1]);

  if (i &lt;= 0)
    RAD_Error("%s: Bad label `%s'.\n", pars[0], pars[2]);

  this_rad-&gt;path_event_label = Z_New(const char, i + 1);
  Z_StrNCpy((char *)this_rad-&gt;path_event_label, pars[1], i);

  this_rad-&gt;path_event_offset = div ? MAX(0, atoi(div+1) - 1) : 0;
}
</t>
<t tx="T1101">
static void RAD_ParseOnDeath(int pnum, const char **pars)
{
  // OnDeath &lt;thing type&gt;
  // OnDeath &lt;thing type&gt; &lt;threshhold&gt;

  s_ondeath_t *cond;

  cond = Z_ClearNew(s_ondeath_t, 1);
  cond-&gt;threshhold = 0;

  // get map thing
  if (pars[1][0] == '-' || pars[1][0] == '+' || isdigit(pars[1][0]))
  {
    RAD_CheckForInt(pars[1], &amp;cond-&gt;thing_type);
  }
  else
    cond-&gt;thing_name = Z_StrDup(pars[1]);

  if (pnum &gt;= 3)
  {
    RAD_CheckForInt(pars[2], &amp;cond-&gt;threshhold);
  }

  // link it into list of ONDEATH conditions
  cond-&gt;next = this_rad-&gt;boss_trig;
  this_rad-&gt;boss_trig = cond;
}
</t>
<t tx="T1102">
static void RAD_ParseOnHeight(int pnum, const char **pars)
{
  // OnHeight &lt;low Z&gt; &lt;high Z&gt;
  // OnHeight &lt;low Z&gt; &lt;high Z&gt; &lt;sector num&gt;

  s_onheight_t *cond;

  cond = Z_ClearNew(s_onheight_t, 1);

  cond-&gt;sec_num = -1;

  RAD_CheckForFloat(pars[1], &amp;cond-&gt;z1);
  RAD_CheckForFloat(pars[2], &amp;cond-&gt;z2);
  
  if (cond-&gt;z1 &gt; cond-&gt;z2)
    RAD_Error("%s: bad height range %1.1f..%1.1f\n", pars[0],
      cond-&gt;z1, cond-&gt;z2);

  // get sector reference
  if (pnum &gt;= 4)
  {
    RAD_CheckForInt(pars[3], &amp;cond-&gt;sec_num);
  }

  // link it into list of ONHEIGHT conditions
  cond-&gt;next = this_rad-&gt;height_trig;
  this_rad-&gt;height_trig = cond;
}
</t>
<t tx="T1103">
static void RAD_ParseOnCondition(int pnum, const char **pars)
{
  // OnCondition  &lt;condition&gt;

  condition_check_t *cond;

  cond = Z_ClearNew(condition_check_t, 1);

  if (! DDF_MainParseCondition(pars[1], cond))
  {
    Z_Free(cond);
    return;
  }

  // link it into list of ONCONDITION list
  cond-&gt;next = this_rad-&gt;cond_trig;
  this_rad-&gt;cond_trig = cond;
}
</t>
<t tx="T1104">
static void RAD_ParseLabel(int pnum, const char **pars)
{
  // Label &lt;label&gt;

  if (pending_label)
    RAD_Error("State already has a label: `%s'\n",
        pending_label);

  pending_label = Z_StrDup(pars[1]);
}
</t>
<t tx="T1105">
static void RAD_ParseEnableScript(int pnum, const char **pars)
{
  // Enable_Script  &lt;script name&gt;
  // Disable_Script &lt;script name&gt;
  
  s_enabler_t *t;

  t = Z_ClearNew(s_enabler_t, 1);

  t-&gt;script_name = Z_StrDup(pars[1]);
  t-&gt;new_disabled = DDF_CompareName("DISABLE_SCRIPT", pars[0]) == 0;

  AddStateToScript(this_rad, 0, RAD_ActEnableScript, t);
}
</t>
<t tx="T1106">
static void RAD_ParseEnableTagged(int pnum, const char **pars)
{
  // Enable_Tagged  &lt;tag num&gt;
  // Disable_Tagged &lt;tag num&gt;
  
  s_enabler_t *t;

  t = Z_ClearNew(s_enabler_t, 1);

  RAD_CheckForInt(pars[1], &amp;t-&gt;tag);

  if (t-&gt;tag &lt;= 0)
    RAD_Error("Bad tag value: %s\n", pars[1]);

  t-&gt;new_disabled = DDF_CompareName("DISABLE_TAGGED", pars[0]) == 0;

  AddStateToScript(this_rad, 0, RAD_ActEnableScript, t);
}
</t>
<t tx="T1107">
static void RAD_ParseExitLevel(int pnum, const char **pars)
{
  // ExitLevel
  // ExitLevel &lt;wait tics&gt;

  s_exit_t *exit;
  
  exit = Z_ClearNew(s_exit_t, 1);
  exit-&gt;exittime = 10;

  if (pnum &gt;= 2)
  {
    RAD_CheckForTime(pars[1], &amp;exit-&gt;exittime);
  }

  AddStateToScript(this_rad, 0, RAD_ActExitLevel, exit);
}
</t>
<t tx="T1108">
static void RAD_ParseTip(int pnum, const char **pars)
{
  // Tip "&lt;text&gt;"
  // Tip "&lt;text&gt;" &lt;time&gt;
  // Tip "&lt;text&gt;" &lt;time&gt; &lt;has sound&gt;
  //
  // (likewise for Tip_LDF)
  // (likewise for Tip_Graphic)

  s_tip_t *tip;

  tip = Z_ClearNew(s_tip_t, 1);

  tip-&gt;display_time = 3 * TICRATE;
  tip-&gt;playsound = false;

  if (DDF_CompareName(pars[0], "TIP_GRAPHIC") == 0)
    tip-&gt;tip_graphic = Z_StrDup(pars[1]);
  else if (DDF_CompareName(pars[0], "TIP_LDF") == 0)
    tip-&gt;tip_ldf = Z_StrDup(pars[1]);
  else if (pars[1][0] == '"')
    tip-&gt;tip_text = RAD_UnquoteString(pars[1]);
  else
    RAD_Error("Needed string for TIP command.\n");

  if (pnum &gt;= 3)
    RAD_CheckForTime(pars[2], &amp;tip-&gt;display_time);

  if (pnum &gt;= 4)
    tip-&gt;playsound = CheckForBoolean(pars[3]);

  AddStateToScript(this_rad, 0, RAD_ActTip, tip);
}
</t>
<t tx="T1109">
static void RAD_ParseTipSlot(int pnum, const char ** pars)
{
  // Tip_Slot &lt;slotnum&gt;
  //
  // -AJA- 2000/10/21: added this primitive.

  s_tip_prop_t *tp;

  tp = Z_New(s_tip_prop_t, 1);
  tp[0] = default_tip_props;

  RAD_CheckForInt(pars[1], &amp;tp-&gt;slot_num);

  if (tp-&gt;slot_num &lt; 1 || tp-&gt;slot_num &gt; MAXTIPSLOT)
    RAD_Error("Bad tip slot `%d' -- must be between 1-%d\n",
        tp-&gt;slot_num, MAXTIPSLOT);
 
  tp-&gt;slot_num--;

  AddStateToScript(this_rad, 0, RAD_ActTipProps, tp);
}
</t>
<t tx="T1110">
static void RAD_ParseTipPos(int pnum, const char ** pars)
{
  // Tip_Set_Pos &lt;x&gt; &lt;y&gt;
  // Tip_Set_Pos &lt;x&gt; &lt;y&gt; &lt;time&gt;
  //
  // -AJA- 2000/10/21: added this primitive.

  s_tip_prop_t *tp;

  tp = Z_New(s_tip_prop_t, 1);
  tp[0] = default_tip_props;

  RAD_CheckForPercentAny(pars[1], &amp;tp-&gt;x_pos);
  RAD_CheckForPercentAny(pars[2], &amp;tp-&gt;y_pos);

  if (pnum &gt;= 4)
    RAD_CheckForTime(pars[3], &amp;tp-&gt;time);

  AddStateToScript(this_rad, 0, RAD_ActTipProps, tp);
}
</t>
<t tx="T1111">
static void RAD_ParseTipColour(int pnum, const char ** pars)
{
  // Tip_Set_Colour &lt;colmap ref&gt;
  // Tip_Set_Colour &lt;colmap ref&gt; &lt;time&gt;
  //
  // -AJA- 2000/10/21: added this primitive.

  s_tip_prop_t *tp;

  tp = Z_New(s_tip_prop_t, 1);
  tp[0] = default_tip_props;

  tp-&gt;colourmap_name = Z_StrDup(pars[1]);
  
  if (pnum &gt;= 3)
    RAD_CheckForTime(pars[2], &amp;tp-&gt;time);

  AddStateToScript(this_rad, 0, RAD_ActTipProps, tp);
}
</t>
<t tx="T1112">
static void RAD_ParseTipTrans(int pnum, const char ** pars)
{
  // Tip_Set_Trans &lt;translucency&gt;
  // Tip_Set_Trans &lt;translucency&gt; &lt;time&gt;

  s_tip_prop_t *tp;

  tp = Z_New(s_tip_prop_t, 1);
  tp[0] = default_tip_props;

  RAD_CheckForPercent(pars[1], &amp;tp-&gt;translucency);

  if (pnum &gt;= 3)
    RAD_CheckForTime(pars[2], &amp;tp-&gt;time);

  AddStateToScript(this_rad, 0, RAD_ActTipProps, tp);
}
</t>
<t tx="T1113">
static void RAD_ParseTipAlign(int pnum, const char ** pars)
{
  // Tip_Set_Align  CENTER/LEFT

  s_tip_prop_t *tp;

  tp = Z_New(s_tip_prop_t, 1);
  tp[0] = default_tip_props;

  if (DDF_CompareName(pars[1], "CENTER") == 0 ||
      DDF_CompareName(pars[1], "CENTRE") == 0)
  {
    tp-&gt;left_just = 0;
  }
  else if (DDF_CompareName(pars[1], "LEFT") == 0)
  {
    tp-&gt;left_just = 1;
  }
  else
  {
    RAD_WarnError("TIP_POS: unknown justify method `%s'\n", pars[1]);
  }

  AddStateToScript(this_rad, 0, RAD_ActTipProps, tp);
}
</t>
<t tx="T1114">
static void RAD_ParseSpawnThing(int pnum, const char **pars)
{
  // SpawnThing &lt;thingid&gt;
  // SpawnThing &lt;thingid&gt; &lt;angle&gt;
  // SpawnThing &lt;thingid&gt; &lt;x&gt; &lt;y&gt;
  // SpawnThing &lt;thingid&gt; &lt;x&gt; &lt;y&gt; &lt;angle&gt;
  // SpawnThing &lt;thingid&gt; &lt;x&gt; &lt;y&gt; &lt;angle&gt; &lt;z&gt;
  // SpawnThing &lt;thingid&gt; &lt;x&gt; &lt;y&gt; &lt;angle&gt; &lt;z&gt; &lt;slope&gt;
  //
  // (likewise for SpawnThing_Ambush)
  // (likewise for SpawnThing_Flash)
  //
  // -ACB- 1998/08/06 Use mobjinfo_t linked list
  // -AJA- 1999/09/11: Extra fields for Z and slope.

  // -AJA- 1999/09/11: Reworked for spawning things at Z.

  s_thing_t *t;
  const char *angle_str;
  int val;

  t = Z_ClearNew(s_thing_t, 1);

  // set defaults
  t-&gt;x = this_rad-&gt;x;
  t-&gt;y = this_rad-&gt;y;

  if (this_rad-&gt;rad_z &lt; 0)
    t-&gt;z = ONFLOORZ;
  else
    t-&gt;z = this_rad-&gt;z - this_rad-&gt;rad_z;

  t-&gt;ambush = DDF_CompareName("SPAWNTHING_AMBUSH", pars[0]) == 0;
  t-&gt;spawn_effect = DDF_CompareName("SPAWNTHING_FLASH", pars[0]) == 0;

  // get map thing
  if (pars[1][0] == '-' || pars[1][0] == '+' || isdigit(pars[1][0]))
  {
    RAD_CheckForInt(pars[1], &amp;t-&gt;thing_type);
  }
  else
    t-&gt;thing_name = Z_StrDup(pars[1]);

  // get angle
  angle_str = (pnum == 3) ? pars[2] : 
              (pnum &gt;= 5) ? pars[4] : NULL;

  if (angle_str) 
  {
    RAD_CheckForInt(angle_str, &amp;val);

    if (ABS(val) &lt;= 360)
      t-&gt;angle = FLOAT_2_ANG((float_t) val);
    else
      t-&gt;angle = val &lt;&lt; 16;
  }

  // check for x &amp; y, z, slope

  if (pnum &gt;= 4)
  {
    RAD_CheckForFloat(pars[2], &amp;t-&gt;x);
    RAD_CheckForFloat(pars[3], &amp;t-&gt;y);
  }
  if (pnum &gt;= 6)
  {
    RAD_CheckForFloat(pars[5], &amp;t-&gt;z);
  }
  if (pnum &gt;= 7)
  {
    RAD_CheckForFloat(pars[6], &amp;t-&gt;slope);

    // FIXME: Merge with DDF_MainGetSlope someday.
    t-&gt;slope /= 45.0;
  }

  AddStateToScript(this_rad, 0, RAD_ActSpawnThing, t);
}
</t>
<t tx="T1115">
static void RAD_ParsePlaySound(int pnum, const char **pars)
{
  // PlaySound &lt;soundid&gt;
  // PlaySound &lt;soundid&gt; &lt;x&gt; &lt;y&gt;
  // PlaySound &lt;soundid&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;
  //
  // PlaySound_BossMan &lt;soundid&gt;
  // PlaySound_BossMan &lt;soundid&gt; &lt;x&gt; &lt;y&gt;
  // PlaySound_BossMan &lt;soundid&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;
  //
  // -AJA- 1999/09/12: Reworked for playing sound at specific Z.

  s_sound_t *t;

  if (pnum == 3)
    RAD_Error("%s: Wrong number of parameters.\n", pars[0]);

  t = Z_ClearNew(s_sound_t, 1);

  if (DDF_CompareName(pars[0], "PLAYSOUND_BOSSMAN") == 0)
    t-&gt;kind = PSOUND_BossMan;
  else
    t-&gt;kind = PSOUND_Normal;

  t-&gt;soundid = DDF_SfxLookupSound(pars[1]);

  t-&gt;x = this_rad-&gt;x;
  t-&gt;y = this_rad-&gt;y;
  t-&gt;z = (this_rad-&gt;rad_z &lt; 0) ? ONFLOORZ : this_rad-&gt;z;

  if (pnum &gt;= 4)
  {
    RAD_CheckForFloat(pars[2], &amp;t-&gt;x);
    RAD_CheckForFloat(pars[3], &amp;t-&gt;y);
  }

  if (pnum &gt;= 5)
  {
    RAD_CheckForFloat(pars[4], &amp;t-&gt;z);
  }

  AddStateToScript(this_rad, 0, RAD_ActPlaySound, t);
}
</t>
<t tx="T1116">
static void RAD_ParseKillSound(int pnum, const char **pars)
{
  // KillSound

  AddStateToScript(this_rad, 0, RAD_ActKillSound, NULL);
}
</t>
<t tx="T1117">
static void RAD_ParseChangeMusic(int pnum, const char **pars)
{
  // ChangeMusic &lt;playlist num&gt;

  s_music_t *music;

  music = Z_ClearNew(s_music_t, 1);

  RAD_CheckForInt(pars[1], &amp;music-&gt;playnum);

  music-&gt;looping = true;

  AddStateToScript(this_rad, 0, RAD_ActChangeMusic, music);
}
</t>
<t tx="T1118">
static void RAD_ParseDamagePlayer(int pnum, const char **pars)
{
  // DamagePlayer &lt;amount&gt;

  s_damagep_t *t;

  t = Z_ClearNew(s_damagep_t, 1);

  RAD_CheckForFloat(pars[1], &amp;t-&gt;damage_amount);

  AddStateToScript(this_rad, 0, RAD_ActDamagePlayers, t);
}
</t>
<t tx="T1119">@ FIXME: use the benefit system
@c

static void RAD_ParseHealPlayer(int pnum, const char **pars)
{
  // HealPlayer &lt;amount&gt;
  // HealPlayer &lt;amount&gt; &lt;limit&gt;

  s_healp_t *heal;

  heal = Z_ClearNew(s_healp_t, 1);

  RAD_CheckForFloat(pars[1], &amp;heal-&gt;heal_amount);

  if (pnum &lt; 3)
    heal-&gt;limit = MAXHEALTH;
  else
    RAD_CheckForFloat(pars[2], &amp;heal-&gt;limit);

  if (heal-&gt;limit &lt; 0 || heal-&gt;limit &gt; MAXHEALTH)
    RAD_Error("Health limit out of range: %1.1f\n", heal-&gt;limit);

  if (heal-&gt;heal_amount &lt; 0 || heal-&gt;heal_amount &gt; heal-&gt;limit)
    RAD_Error("Health value out of range: %1.1f\n", heal-&gt;heal_amount);

  AddStateToScript(this_rad, 0, RAD_ActHealPlayers, heal);
}
</t>
<t tx="T1120">@ FIXME: use the benefit system
@c

static void RAD_ParseGiveArmour(int pnum, const char **pars)
{
  // GiveArmour &lt;type&gt; &lt;amount&gt;
  // GiveArmour &lt;type&gt; &lt;amount&gt; &lt;limit&gt;
  
  s_armour_t *armour;

  armour = Z_ClearNew(s_armour_t, 1);

  armour-&gt;type = RAD_CheckForArmourType(pars[1]);

  RAD_CheckForFloat(pars[2], &amp;armour-&gt;armour_amount);

  if (pnum &lt; 4)
    armour-&gt;limit = MAXARMOUR;
  else
    RAD_CheckForFloat(pars[3], &amp;armour-&gt;limit);

  if (armour-&gt;limit &lt; 0 || armour-&gt;limit &gt; MAXARMOUR)
    RAD_Error("Armour limit out of range: %1.1f\n", armour-&gt;limit);

  if (armour-&gt;armour_amount &lt; 0 || armour-&gt;armour_amount &gt; armour-&gt;limit)
    RAD_Error("Armour value out of range: %1.1f\n", armour-&gt;armour_amount);

  AddStateToScript(this_rad, 0, RAD_ActArmourPlayers, armour);
}
</t>
<t tx="T1121">
static void RAD_ParseGiveLoseBenefit(int pnum, const char **pars)
{
  // Give_Benefit  &lt;benefit&gt;
  //   or
  // Lose_Benefit  &lt;benefit&gt;
 
  s_benefit_t *sb;

  sb = Z_ClearNew(s_benefit_t, 1);

  if (DDF_CompareName(pars[0], "LOSE_BENEFIT") == 0)
    sb-&gt;lose_it = true;

  DDF_MobjGetBenefit(pars[1], &amp;sb-&gt;benefit);
      
  AddStateToScript(this_rad, 0, RAD_ActBenefitPlayers, sb);
}
</t>
<t tx="T1122">
static void RAD_ParseDamageMonsters(int pnum, const char **pars)
{
  // Damage_Monsters &lt;monster&gt; &lt;amount&gt;

  s_damage_monsters_t *mon;

  mon = Z_ClearNew(s_damage_monsters_t, 1);

  // get monster type
  if (pars[1][0] == '-' || pars[1][0] == '+' || isdigit(pars[1][0]))
  {
    RAD_CheckForInt(pars[1], &amp;mon-&gt;thing_type);
  }
  else if (DDF_CompareName(pars[1], "ANY") == 0)
    mon-&gt;thing_type = -1;
  else
    mon-&gt;thing_name = Z_StrDup(pars[1]);

  RAD_CheckForFloat(pars[2], &amp;mon-&gt;damage_amount);
  
  AddStateToScript(this_rad, 0, RAD_ActDamageMonsters, mon);
}
</t>
<t tx="T1123">
static void RAD_ParseThingEvent(int pnum, const char **pars)
{
  // Thing_Event &lt;thing&gt; &lt;label&gt;

  s_thing_event_t *tev;
  const char *div;
  int i;

  tev = Z_ClearNew(s_thing_event_t, 1);

  // parse the object type
  if (pars[1][0] == '-' || pars[1][0] == '+' || isdigit(pars[1][0]))
    RAD_CheckForInt(pars[1], &amp;tev-&gt;thing_type);
  else
    tev-&gt;thing_name = Z_StrDup(pars[1]);

  // parse the label name
  div = strchr(pars[2], ':');

  i = div ? (div - pars[2]) : strlen(pars[2]);

  if (i &lt;= 0)
    RAD_Error("%s: Bad label `%s'.\n", pars[0], pars[2]);

  tev-&gt;label = Z_New(const char, i + 1);
  Z_StrNCpy((char *)tev-&gt;label, pars[2], i);

  tev-&gt;offset = div ? MAX(0, atoi(div+1) - 1) : 0;

  AddStateToScript(this_rad, 0, RAD_ActThingEvent, tev);
}
</t>
<t tx="T1124">
static void RAD_ParseSkill(int pnum, const char **pars)
{
  // Skill &lt;skill&gt; &lt;respawn&gt; &lt;fastmonsters&gt;

  s_skill_t *skill;
  int val;

  skill = Z_ClearNew(s_skill_t, 1);

  RAD_CheckForInt(pars[1], &amp;val);

  skill-&gt;skill = (skill_t) (val - 1);
  skill-&gt;Respawn = CheckForBoolean(pars[2]);
  skill-&gt;FastMonsters = CheckForBoolean(pars[3]);

  AddStateToScript(this_rad, 0, RAD_ActSkill, skill);
}
</t>
<t tx="T1125">
static void RAD_ParseGotoMap(int pnum, const char **pars)
{
  // GotoMap &lt;map name&gt;

  s_gotomap_t *go;

  go = Z_ClearNew(s_gotomap_t, 1);

  go-&gt;map_name = Z_StrDup(pars[1]);

  AddStateToScript(this_rad, 0, RAD_ActGotoMap, go);
}
</t>
<t tx="T1126">
static void RAD_ParseMoveSector(int pnum, const char **pars)
{
  // MoveSector &lt;tag&gt; &lt;amount&gt; &lt;ceil or floor&gt;
  // MoveSector &lt;tag&gt; &lt;amount&gt; &lt;ceil or floor&gt; ABSOLUTE
  // 
  // backwards compatibility:
  //   SectorV &lt;sector&gt; &lt;amount&gt; &lt;ceil or floor&gt;

  s_movesector_t *secv;

  secv = Z_ClearNew(s_movesector_t, 1);
  secv-&gt;relative = true;

  RAD_CheckForInt(pars[1], &amp;secv-&gt;tag);
  RAD_CheckForFloat(pars[2], &amp;secv-&gt;value);

  if (DDF_CompareName(pars[3], "FLOOR") == 0)
    secv-&gt;is_ceiling = 0;
  else if (DDF_CompareName(pars[3], "CEILING") == 0)
    secv-&gt;is_ceiling = 1;
  else
    secv-&gt;is_ceiling = !CheckForBoolean(pars[3]);

  if (DDF_CompareName(pars[0], "SECTORV") == 0)
  {
    secv-&gt;secnum = secv-&gt;tag;
    secv-&gt;tag = 0;
  }
  else  // MOVE_SECTOR
  {
    if (secv-&gt;tag == 0)
      RAD_Error("%s: Invalid tag number: %d\n", pars[0], secv-&gt;tag);

    if (pnum &gt;= 5)
    {
      if (DDF_CompareName(pars[4], "ABSOLUTE") == 0)
        secv-&gt;relative = false;
      else
        RAD_WarnError("%s: expected `ABSOLUTE' but got `%s'.\n",
            pars[0], pars[4]);
    }
  }

  AddStateToScript(this_rad, 0, RAD_ActMoveSector, secv);
}
</t>
<t tx="T1127">
static void RAD_ParseLightSector(int pnum, const char **pars)
{
  // LightSector &lt;tag&gt; &lt;amount&gt;
  // LightSector &lt;tag&gt; &lt;amount&gt; ABSOLUTE
  // 
  // backwards compatibility:
  //   SectorL &lt;sector&gt; &lt;amount&gt;

  s_lightsector_t *secl;

  secl = Z_ClearNew(s_lightsector_t, 1);
  secl-&gt;relative = true;

  RAD_CheckForInt(pars[1], &amp;secl-&gt;tag);
  RAD_CheckForFloat(pars[2], &amp;secl-&gt;value);

  if (DDF_CompareName(pars[0], "SECTORL") == 0)
  {
    secl-&gt;secnum = secl-&gt;tag;
    secl-&gt;tag = 0;
  }
  else  // LIGHT_SECTOR
  {
    if (secl-&gt;tag == 0)
      RAD_Error("%s: Invalid tag number: %d\n", pars[0], secl-&gt;tag);

    if (pnum &gt;= 4)
    {
      if (DDF_CompareName(pars[3], "ABSOLUTE") == 0)
        secl-&gt;relative = false;
      else
        RAD_WarnError("%s: expected `ABSOLUTE' but got `%s'.\n",
            pars[0], pars[3]);
    }
  }

  AddStateToScript(this_rad, 0, RAD_ActLightSector, secl);
}
</t>
<t tx="T1128">
static void RAD_ParseActivateLinetype(int pnum, const char **pars)
{
  // Activate_LineType &lt;linetype&gt; &lt;tag&gt;
  //
  // -AJA- 1999/10/21: added this primitive.

  s_lineactivator_t *lineact;

  lineact = Z_ClearNew(s_lineactivator_t, 1);

  RAD_CheckForInt(pars[1], &amp;lineact-&gt;typenum);
  RAD_CheckForInt(pars[2], &amp;lineact-&gt;tag);

  AddStateToScript(this_rad, 0, RAD_ActActivateLinetype, lineact);
}
</t>
<t tx="T1129">
static void RAD_ParseUnblockLines(int pnum, const char **pars)
{
  // Unblock_Lines &lt;tag&gt;
  //
  // -AJA- 2001/10/21: added this primitive.
  // (Woah! Compare date to the one above in Activate_LineType)

  s_lineunblocker_t *lineact;

  lineact = Z_ClearNew(s_lineunblocker_t, 1);

  RAD_CheckForInt(pars[1], &amp;lineact-&gt;tag);

  AddStateToScript(this_rad, 0, RAD_ActUnblockLines, lineact);
}
</t>
<t tx="T1130">
static void RAD_ParseWait(int pnum, const char **pars)
{
  // Wait &lt;time&gt;
  //
  // -AJA- 2000/01/05: added this primitive.

  int tics;

  RAD_CheckForTime(pars[1], &amp;tics);

  if (tics &lt;= 0)
    RAD_Error("%s: Invalid time: %d\n", pars[0], tics);
    
  pending_wait_tics += tics;
}
</t>
<t tx="T1131">
static void RAD_ParseJump(int pnum, const char **pars)
{
  // Jump &lt;label&gt;
  // Jump &lt;label&gt; &lt;random chance&gt;
  //
  // -AJA- 2000/01/05: added this primitive.

  s_jump_t *jump;

  jump = Z_ClearNew(s_jump_t, 1);

  jump-&gt;label = Z_StrDup(pars[1]);

  if (pnum &gt;= 3)
    RAD_CheckForPercent(pars[2], &amp;jump-&gt;random_chance);

  AddStateToScript(this_rad, 0, RAD_ActJump, jump);
}
</t>
<t tx="T1132">
static void RAD_ParseSleep(int pnum, const char **pars)
{
  // Sleep
  //
  // -AJA- 2000/01/09: added this primitive.

  AddStateToScript(this_rad, 0, RAD_ActSleep, NULL);
}
</t>
<t tx="T1133">
static void RAD_ParseRetrigger(int pnum, const char **pars)
{
  // Retrigger
  //
  // -AJA- 2001/07/06: added this primitive.

  if (! this_rad-&gt;tagged_independent)
    RAD_Error("%s can only be used with TAGGED_INDEPENDENT.\n", pars[0]);
      
  AddStateToScript(this_rad, 0, RAD_ActRetrigger, NULL);
}
</t>
<t tx="T1134">
static void RAD_ParseChangeTex(int pnum, const char **pars)
{
  // Change_Tex &lt;where&gt; &lt;texname&gt;
  // Change_Tex &lt;where&gt; &lt;texname&gt; &lt;tag&gt;
  // Change_Tex &lt;where&gt; &lt;texname&gt; &lt;tag&gt; &lt;subtag&gt;

  s_changetex_t *ctex;

  if (strlen(pars[2]) &gt; 8)
    RAD_Error("%s: Texture name too long: %s\n", pars[0], pars[2]);
   
  ctex = Z_ClearNew(s_changetex_t, 1);

  ctex-&gt;what = RAD_CheckForChangetexType(pars[1]);
  ctex-&gt;tag = ctex-&gt;subtag = 0;

  strcpy(ctex-&gt;texname, pars[2]);

  if (pnum &gt;= 4)
    RAD_CheckForInt(pars[3], &amp;ctex-&gt;tag);
 
  if (pnum &gt;= 5)
    RAD_CheckForInt(pars[4], &amp;ctex-&gt;subtag);
 
  AddStateToScript(this_rad, 0, RAD_ActChangeTex, ctex);
}
</t>
<t tx="T1135">@ PARSER TABLE
@c

static rts_parser_t radtrig_parsers[] =
{
  // directives...
  {-1, "#DEFINE",  3,3, RAD_ParseDefine},
  {0, "#VERSION",  2,2, RAD_ParseVersion},
  {0, "#CLEARALL", 1,1, RAD_ParseClearAll},

  // basics...
  {-1, "START_MAP", 2,2, RAD_ParseStartMap},
  {-1, "RADIUS_TRIGGER", 4,6, RAD_ParseRadiusTrigger},
  {-1, "RECT_TRIGGER", 5,7, RAD_ParseRadiusTrigger},
  {-1, "END_RADIUSTRIGGER", 1,1, RAD_ParseEndRadiusTrigger},
  {-1, "END_MAP",  1,1, RAD_ParseEndMap},
  
  // properties...
  {2, "NAME", 2,2, RAD_ParseName},
  {2, "TAG",  2,2, RAD_ParseTag},
  {2, "WHEN_APPEAR", 2,2, RAD_ParseWhenAppear},
  {2, "WHEN_PLAYER_NUM",   2,3, RAD_ParseWhenPlayerNum},
  {2, "NET_MODE", 2,3, RAD_ParseNetMode},
  {2, "TAGGED_REPEATABLE", 1,3, RAD_ParseTaggedRepeatable},
  {2, "TAGGED_USE", 1,1, RAD_ParseTaggedUse},
  {2, "TAGGED_INDEPENDENT", 1,1, RAD_ParseTaggedIndependent},
  {2, "TAGGED_IMMEDIATE",   1,1, RAD_ParseTaggedImmediate},
  {2, "TAGGED_PLAYER_SPECIFIC", 1,1, RAD_ParseTaggedPlayerSpecific},
  {2, "TAGGED_DISABLED", 1,1, RAD_ParseTaggedDisabled},
  {2, "TAGGED_PATH", 2,2, RAD_ParseTaggedPath},
  {2, "PATH_EVENT", 2,2, RAD_ParsePathEvent},
  {2, "ONDEATH",  2,3, RAD_ParseOnDeath},
  {2, "ONHEIGHT", 3,4, RAD_ParseOnHeight},
  {2, "ONCONDITION",  2,2, RAD_ParseOnCondition},
  {2, "LABEL", 2,2, RAD_ParseLabel},

  // actions...
  {2, "TIP",     2,4, RAD_ParseTip},
  {2, "TIP_LDF", 2,4, RAD_ParseTip},
  {2, "TIP_GRAPHIC", 2,4, RAD_ParseTip},
  {2, "TIP_SLOT",    2,2, RAD_ParseTipSlot},
  {2, "TIP_SET_POS",    3,4, RAD_ParseTipPos},
  {2, "TIP_SET_COLOUR", 2,3, RAD_ParseTipColour},
  {2, "TIP_SET_TRANS",  2,3, RAD_ParseTipTrans},
  {2, "TIP_SET_ALIGN",  2,2, RAD_ParseTipAlign},
  {2, "EXITLEVEL", 1,2, RAD_ParseExitLevel},
  {2, "SPAWNTHING", 2,7, RAD_ParseSpawnThing},
  {2, "SPAWNTHING_AMBUSH", 2,7, RAD_ParseSpawnThing},
  {2, "SPAWNTHING_FLASH",  2,7, RAD_ParseSpawnThing},
  {2, "PLAYSOUND", 2,5, RAD_ParsePlaySound},
  {2, "PLAYSOUND_BOSSMAN", 2,5, RAD_ParsePlaySound},
  {2, "KILLSOUND", 1,1, RAD_ParseKillSound},
  {2, "HEALPLAYER",   2,3, RAD_ParseHealPlayer},
  {2, "GIVEARMOUR",   3,4, RAD_ParseGiveArmour},
  {2, "DAMAGEPLAYER", 2,2, RAD_ParseDamagePlayer},
  {2, "GIVE_BENEFIT", 2,2, RAD_ParseGiveLoseBenefit},
  {2, "LOSE_BENEFIT", 2,2, RAD_ParseGiveLoseBenefit},
  {2, "DAMAGE_MONSTERS", 3,3, RAD_ParseDamageMonsters},
  {2, "THING_EVENT", 3,3, RAD_ParseThingEvent},
  {2, "SKILL",   4,4, RAD_ParseSkill},
  {2, "GOTOMAP", 2,2, RAD_ParseGotoMap},
  {2, "MOVE_SECTOR", 4,5, RAD_ParseMoveSector},
  {2, "LIGHT_SECTOR", 3,4, RAD_ParseLightSector},
  {2, "ENABLE_SCRIPT",  2,2, RAD_ParseEnableScript},
  {2, "DISABLE_SCRIPT", 2,2, RAD_ParseEnableScript},
  {2, "ENABLE_TAGGED",  2,2, RAD_ParseEnableTagged},
  {2, "DISABLE_TAGGED", 2,2, RAD_ParseEnableTagged},
  {2, "ACTIVATE_LINETYPE", 3,3, RAD_ParseActivateLinetype},
  {2, "UNBLOCK_LINES", 2,2, RAD_ParseUnblockLines},
  {2, "WAIT",  2,2, RAD_ParseWait},
  {2, "JUMP",  2,3, RAD_ParseJump},
  {2, "SLEEP", 1,1, RAD_ParseSleep},
  {2, "RETRIGGER", 1,1, RAD_ParseRetrigger},
  {2, "CHANGE_TEX", 3,5, RAD_ParseChangeTex},
  {2, "CHANGE_MUSIC", 2,2, RAD_ParseChangeMusic},

  // somewhat-deprecated primitives
  {2, "SECTORV", 4,4, RAD_ParseMoveSector},
  {2, "SECTORL", 3,3, RAD_ParseLightSector},
  
  // that's all, folks.
  {0, NULL, 0,0, NULL}
};

//
// Primitive Parser
//
void RAD_ParseLine(char *s)
{
  int pnum;
  char *pars[16];
  rts_parser_t *cur;

  RAD_ErrorSetLineData(s);

  RAD_CollectParameters(s, &amp;pnum, pars, 16);

  if (pnum == 0)
  {
    RAD_ErrorClearLineData();
    return;
  }

  for (cur = radtrig_parsers; cur-&gt;name != NULL; cur++)
  {
    const char *cur_name = cur-&gt;name;
    boolean_t obsolete = false;

    if (cur_name[0] == '!')
    {
      obsolete = true;
      cur_name++;
    }

    if (DDF_CompareName(pars[0], cur_name) != 0)
      continue;

    if (obsolete &amp;&amp; !no_obsoletes)
    {
      RAD_Warning("The rts %s command is obsolete !\n", cur_name);
    }

    // check level
    if (cur-&gt;level &gt;= 0)
    {
      if (cur-&gt;level != rad_cur_level)
      {
        RAD_Error("RTS command `%s' used in wrong place "
          "(found in %s, should be in %s).\n", pars[0],
          rad_level_names[rad_cur_level],
          rad_level_names[cur-&gt;level]);
      
        RAD_FreeParameters(pnum, pars);
        RAD_ErrorClearLineData();

        return;
      }
    }

    // check number of parameters.  Too many is live-with-able, but
    // not enough is fatal.

    if (pnum &lt; cur-&gt;min_pars)
      RAD_Error("%s: Not enough parameters.\n", cur-&gt;name);

    if (pnum &gt; cur-&gt;max_pars)
      RAD_WarnError("%s: Too many parameters.\n", cur-&gt;name);
    
    // found it, invoke the parser function
    (* cur-&gt;parser)(pnum, (const char **) pars);

    RAD_FreeParameters(pnum, pars);
    RAD_ErrorClearLineData();

    return;
  }

  RAD_WarnError("Unknown primitive: %s\n", pars[0]);

  RAD_FreeParameters(pnum, pars);
  RAD_ErrorClearLineData();
}
</t>
<t tx="T1136">
void RAD_ParserBegin(void)
{
  rad_cur_level = 0;
}
</t>
<t tx="T1137">
void RAD_ParserDone(void)
{
  if (rad_cur_level &gt;= 2)
    RAD_Error("RADIUSTRIGGER: block not terminated !\n");

  if (rad_cur_level == 1)
    RAD_Error("START_MAP: block not terminated !\n");
}
</t>
<t tx="T1138">@ignore
@language c

// Radius Trigger / Tip Code

// -KM- 1998/11/25 Fixed problems created by DDF.
//   Radius Triggers can be added to wad files.  RSCRIPT is the lump.
//   Tip function can handle graphics.
//   New functions: ondeath, #version
//   Radius Triggers with radius &lt; 0 affect entire map.
//   Radius triggers used to save compatibility with hacks in Doom/Doom2 
//       (eg MAP07, E2M8, E3M8, MAP32 etc..)
//
// -AJA- 1999/10/23: Began work on a state model for RTS actions.
//
// -AJA- 1999/10/24: Split off actions into rad_act.c, and structures
//       into the rad_main.h file.
//
// -AJA- 2000/01/04: Split off parsing code into rad_pars.c.

&lt;&lt; rad_trig #includes &gt;&gt;
&lt;&lt; rad_trig declarations &gt;&gt;
@others
</t>
<t tx="T1139">#include "i_defs.h"
#include "rad_trig.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "e_main.h"
#include "hu_lib.h"
#include "hu_stuff.h"
#include "g_game.h"
#include "m_argv.h"
#include "m_misc.h"
#include "m_random.h"
#include "m_swap.h"
#include "p_local.h"
#include "p_spec.h"
#include "r_defs.h"
#include "s_sound.h"
#include "v_res.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1140">// Static Scripts.  Never change once all scripts have been read in.
rad_script_t *r_scripts = NULL;

// Dynamic Triggers.  These only exist for the current level.
rad_trigger_t *r_triggers = NULL;

// # Triggers
int rad_itemsread = 0;

// Current RTS file or lump being parsed.
static byte *rad_memfile;
static byte *rad_memfile_end;
static byte *rad_memptr;
static int rad_memfile_size;

</t>
<t tx="T1141">@ -AJA- 1999/09/25: written.
@c

rad_script_t * RAD_FindScriptByName(const char *map_name, const char *name)
{
  rad_script_t *scr;

  for (scr=r_scripts; scr; scr=scr-&gt;next)
  {
    if (scr-&gt;script_name == NULL)
      continue;

    if (strcmp(scr-&gt;mapid, map_name) != 0)
      continue;

    if (DDF_CompareName(scr-&gt;script_name, name) == 0)
      return scr;
  }

  I_Error("RTS: No such script `%s' on map %s.\n", name, map_name);
  return NULL;
}
</t>
<t tx="T1142">rad_trigger_t * RAD_FindTriggerByName(const char *name)
{
  rad_trigger_t *trig;

  for (trig=r_triggers; trig; trig=trig-&gt;next)
  {
    if (trig-&gt;info-&gt;script_name == NULL)
      continue;

    if (DDF_CompareName(trig-&gt;info-&gt;script_name, name) == 0)
      return trig;
  }

  I_Warning("RTS: No such trigger `%s'.\n", name);
  return NULL;
}
</t>
<t tx="T1143">rts_state_t * RAD_FindStateByLabel(rad_script_t *scr, char *label)
{
  rts_state_t *st;

  for (st=scr-&gt;first_state; st; st=st-&gt;next)
  {
    if (st-&gt;label == NULL)
      continue;

    if (DDF_CompareName(st-&gt;label, label) == 0)
      return st;
  }

  // NOTE: no error message, unlike the other Find funcs
  return NULL;
}
</t>
<t tx="T1144">@ Looks for all current triggers with the given tag number, and
either enables them or disables them (based on `disable').
Actor can be NULL.
@c

void RAD_EnableByTag(mobj_t *actor, int tag, boolean_t disable)
{
  rad_trigger_t *trig;

  if (tag &lt;= 0)
    I_Error("INTERNAL ERROR: RAD_EnableByTag: bad tag %d\n", tag);

  for (trig=r_triggers; trig; trig=trig-&gt;next)
  {
    if (trig-&gt;info-&gt;tag == tag)
      break;
  }

  // were there any ?
  if (! trig)
    return;
  
  for (; trig; trig=trig-&gt;tag_next)
  {
    if (disable)
      trig-&gt;disabled = true;
    else
      trig-&gt;disabled = false;
  }
}
</t>
<t tx="T1145">boolean_t RAD_WithinRadius(mobj_t * mo, rad_script_t * r)
{
  if (r-&gt;rad_x &gt;= 0 &amp;&amp; fabs(r-&gt;x - mo-&gt;x) &gt; r-&gt;rad_x + mo-&gt;radius)
    return false;

  if (r-&gt;rad_y &gt;= 0 &amp;&amp; fabs(r-&gt;y - mo-&gt;y) &gt; r-&gt;rad_y + mo-&gt;radius)
    return false;

  if (r-&gt;rad_z &gt;= 0 &amp;&amp; fabs(r-&gt;z - MO_MIDZ(mo)) &gt; r-&gt;rad_z + mo-&gt;height/2)
  {
    return false;
  }

  return true;
}
</t>
<t tx="T1146">@ -AJA- 1999/12/08: written.
@c

static boolean_t RAD_CheckBossTrig(rad_trigger_t *trig, s_ondeath_t *cond)
{
  mobj_t *mo;

  int count = 0;

  // lookup thing type if we haven't already done so
  if (! cond-&gt;cached_info)
  {
    if (cond-&gt;thing_name)
      cond-&gt;cached_info = DDF_MobjLookup(cond-&gt;thing_name);
    else
    {
      cond-&gt;cached_info = DDF_MobjLookupNum(cond-&gt;thing_type);
      
      if (cond-&gt;cached_info == NULL)
        I_Error("RTS ONDEATH: Unknown thing type %d.\n",
          cond-&gt;thing_type);
    }
  }
  
  // scan the remaining mobjs to see if all bosses are dead
  for (mo=mobjlisthead; mo != NULL; mo=mo-&gt;next)
  {
    if (mo-&gt;info == cond-&gt;cached_info &amp;&amp; mo-&gt;health &gt; 0)
    {
      count++;
    
      if (count &gt; cond-&gt;threshhold)
        return false;
    }
  }

  return true;
}
</t>
<t tx="T1147">@ -AJA- 1999/12/08: written.
@c

static boolean_t RAD_CheckHeightTrig(rad_trigger_t *trig, 
    s_onheight_t *cond)
{
  float_t h;

  // lookup sector if we haven't already done so
  if (! cond-&gt;cached_sector)
  {
    if (cond-&gt;sec_num &gt;= 0)
    {
      if (cond-&gt;sec_num &gt;= numsectors)
        I_Error("RTS ONHEIGHT: no such sector %d.\n", cond-&gt;sec_num);
      
      cond-&gt;cached_sector = &amp; sectors[cond-&gt;sec_num];
    }
    else
    {
      cond-&gt;cached_sector = R_PointInSubsector(trig-&gt;info-&gt;x, 
          trig-&gt;info-&gt;y)-&gt;sector;
    }
  }

  h = cond-&gt;cached_sector-&gt;f_h;

  return (cond-&gt;z1 &lt;= h &amp;&amp; h &lt;= cond-&gt;z2);
}
</t>
<t tx="T1148">boolean_t RAD_CheckReachedTrigger(mobj_t * thing)
{
  rad_script_t * scr = (rad_script_t *) thing-&gt;path_trigger;

  rts_path_t *path;
  int choice;
  
  if (! RAD_WithinRadius(thing, scr))
    return false;

  // Thing has reached this path node. Update so it starts following
  // the next node.  Handle any PATH_EVENT too.

  if (scr-&gt;path_event_label)
  {
    statenum_t state = P_MobjFindLabel(thing, scr-&gt;path_event_label);

    if (state)
      P_SetMobjStateDeferred(thing, state + scr-&gt;path_event_offset, 0);
  }
 
  if (scr-&gt;next_path_total == 0)
  {
    thing-&gt;path_trigger = NULL;
    return true;
  }
  else if (scr-&gt;next_path_total == 1)
    choice = 0;
  else
    choice = P_Random() % scr-&gt;next_path_total;

  path = scr-&gt;next_in_path;
  DEV_ASSERT2(path);

  for (; choice &gt; 0; choice--)
  {
    path = path-&gt;next;
    DEV_ASSERT2(path);
  }

  if (! path-&gt;cached_scr)
    path-&gt;cached_scr = RAD_FindScriptByName(scr-&gt;mapid, path-&gt;name);
 
  DEV_ASSERT2(path-&gt;cached_scr);

  thing-&gt;path_trigger = path-&gt;cached_scr;
  return true;
}
</t>
<t tx="T1149">static void DoRemoveTrigger(rad_trigger_t *trig)
{
  // handle tag linkage
  if (trig-&gt;tag_next)
    trig-&gt;tag_next-&gt;tag_prev = trig-&gt;tag_prev;

  if (trig-&gt;tag_prev)
    trig-&gt;tag_prev-&gt;tag_next = trig-&gt;tag_next;

  // unlink and free it
  if (trig-&gt;next)
    trig-&gt;next-&gt;prev = trig-&gt;prev;

  if (trig-&gt;prev)
    trig-&gt;prev-&gt;next = trig-&gt;next;
  else
    r_triggers = trig-&gt;next;

  S_AddToFreeQueue((mobj_t *)&amp;trig-&gt;soundorg, (void *)trig);
}
</t>
<t tx="T1150">@ Called by P_PlayerThink
Radius Trigger Event handler.
@c

void RAD_DoRadiTrigger(player_t * p)
{
  rad_trigger_t *trig, *next;

  // Start looking through the trigger list.
  for (trig=r_triggers; trig; trig=next)
  {
    next = trig-&gt;next;
	&lt;&lt; handle trigger trig &gt;&gt;
    DoRemoveTrigger(trig);
  }
}</t>
<t tx="T1151">@ RAD_GroupTriggerTags

Called from RAD_SpawnTriggers to set the tag_next &amp; tag_prev fields
of each rad_trigger_t, keeping all triggers with the same tag in a
linked list for faster handling.

Also sets up `soundorg'.
@c

void RAD_GroupTriggerTags(rad_trigger_t *trig)
{
  rad_trigger_t *cur;

  trig-&gt;soundorg.x = trig-&gt;info-&gt;x;
  trig-&gt;soundorg.y = trig-&gt;info-&gt;y;
  trig-&gt;soundorg.z = 0.0;
     
  trig-&gt;tag_next = trig-&gt;tag_prev = NULL;

  // find first trigger with the same tag #
  for (cur=r_triggers; cur; cur=cur-&gt;next)
  {
    if (cur == trig)
      continue;

    if (cur-&gt;info-&gt;tag == trig-&gt;info-&gt;tag)
      break;
  }

  if (! cur)
    return;

  // link it in

  trig-&gt;tag_next = cur;
  trig-&gt;tag_prev = cur-&gt;tag_prev;

  if (cur-&gt;tag_prev)
    cur-&gt;tag_prev-&gt;tag_next = trig;
  
  cur-&gt;tag_prev = trig;
}
</t>
<t tx="T1152">void RAD_SpawnTriggers(char *map_name)
{
  rad_script_t *scr;
  rad_trigger_t *trig;

#ifdef DEVELOPERS
  if (r_triggers)
    I_Error("RAD_SpawnTriggers without RAD_ClearTriggers\n");
#endif

  for (scr=r_scripts; scr; scr=scr-&gt;next)
  {
    &lt;&lt; handle script scr &gt;&gt;;
  }
}</t>
<t tx="T1153">static void RAD_ClearCachedInfo(void)
{
  rad_script_t *scr;
  s_ondeath_t *d_cur;
  s_onheight_t *h_cur;

  for (scr=r_scripts; scr; scr=scr-&gt;next)
  {
    // clear ONDEATH cached info
    for (d_cur=scr-&gt;boss_trig; d_cur; d_cur=d_cur-&gt;next)
    {
      d_cur-&gt;cached_info = NULL;
    }

    // clear ONHEIGHT cached info
    for (h_cur=scr-&gt;height_trig; h_cur; h_cur=h_cur-&gt;next)
    {
      h_cur-&gt;cached_sector = NULL;
    }
  }
}
</t>
<t tx="T1154">void RAD_ClearTriggers(void)
{
  // remove all dynamic triggers
  while (r_triggers)
  {
    rad_trigger_t *trig = r_triggers;
    r_triggers = trig-&gt;next;

    Z_Free(trig);
  }

  RAD_ClearCachedInfo();
  RAD_ResetTips();
}
</t>
<t tx="T1155">@ Loads the script file into memory for parsing.

-AJA- 2000/01/04: written, based on DDF_MainCacheFile
-AJA- FIXME: merge them both into a single utility routine.
(BETTER: a single utility parsing module).
@c

static void RAD_MainCacheFile(const char *filename)
{
  FILE *file;

  // open the file
  file = fopen(filename, "rb");

  if (file == NULL)
    I_Error("\nRAD_MainReadFile: Unable to open: '%s'", filename);

  // get to the end of the file
  fseek(file, 0, SEEK_END);

  // get the size
  rad_memfile_size = ftell(file);

  // reset to beginning
  fseek(file, 0, SEEK_SET);

  // malloc the size
  rad_memfile = Z_New(byte, rad_memfile_size + 1);
  rad_memfile_end = &amp;rad_memfile[rad_memfile_size];

  // read the goodies
  fread(rad_memfile, 1, rad_memfile_size, file);

  // null Terminated string.
  rad_memfile[rad_memfile_size] = 0;

  // close the file
  fclose(file);
}
</t>
<t tx="T1156">@ -ACB- 1998/07/10 Renamed function and used I_Print for functions,
Version displayed at all times.
@c

static void RAD_ParseScript(boolean_t dots)
{
  char str[MAXSTRLEN];
  int n = 0;

  RAD_ParserBegin();
  
  rad_cur_linenum = 1;
  rad_memptr = rad_memfile;

  while (rad_memptr &lt; rad_memfile_end)
  {
    int sp;

    for (sp=0; rad_memptr &lt; rad_memfile_end &amp;&amp; rad_memptr[0] != '\n'; 
         rad_memptr++)
    {
      // ignore carriage returns
      if (rad_memptr[0] == '\r')
        continue;

      if (sp &lt; MAXSTRLEN-1)
        str[sp++] = rad_memptr[0];
    }

    // skip trailing EOLN
    rad_memptr++;

    str[sp] = 0;

#if (DEBUG_RTS)
    L_WriteDebug("RTS LINE: `%s'\n", str);
#endif

    if (sp &gt; 0)
    {
      // turn it into upper case
      strupr(str);

      RAD_ParseLine(str);

      if (dots &amp;&amp; n != rad_itemsread)
        I_Printf(".");

      n = rad_itemsread;
    }

    rad_cur_linenum++;
  }

  RAD_ParserDone();
}
</t>
<t tx="T1157">void RAD_LoadLump(void *data, int size)
{
  L_WriteDebug("RTS: Loading LUMP (size=%d)\n", size);

  rad_cur_filename = "RSCRIPT LUMP";
  
  rad_memfile_size = size;
  rad_memfile = Z_New(byte, size + 1);
  rad_memfile_end = &amp;rad_memfile[size];

  Z_MoveData(rad_memfile, (byte *)data, byte, size);

  // Null Terminated string.
  rad_memfile[size] = 0;

  // OK we have the file in memory.  Parse it to death :-)
  RAD_ParseScript(false);

  Z_Free(rad_memfile);
}
</t>
<t tx="T1158">static void RAD_LoadFile(const char *name, boolean_t dots)
{
  DEV_ASSERT2(name);
  
  L_WriteDebug("RTS: Loading File %s\n", name);

  rad_cur_filename = (char *) name;

  RAD_MainCacheFile(name);

  // OK we have the file in memory.  Parse it to death :-)
  RAD_ParseScript(dots);

  Z_Free(rad_memfile);
}
</t>
<t tx="T1159">boolean_t RAD_Init(void)
{
  char *filename;

  RAD_InitTips();

  I_Printf("Radius Triggers v%i.%i", PARSERV / PARSERVFIX, 
      PARSERV % PARSERVFIX);

  if (external_ddf)
  {
    filename = M_ComposeFileName(ddfdir, "edge.scr");
    RAD_LoadFile(filename, true);
    Z_Free(filename);
  }

  I_Printf("\n");

  return true;
}
</t>
<t tx="T1160">boolean_t RAD_LoadParam(void)
{
  const char *par;
  char *filename;

  // -KM- 1998/11/25 Check for command line script loading
  par = M_GetParm("-script");

  if (par)
  {
    filename = M_ComposeFileName(gamedir, par);
    RAD_LoadFile(filename, false);
    Z_Free(filename);
  }

  return true;
}
</t>
<t tx="T1161">@ignore
@language c

// OpenGL Rendering (BSP Traversal)

// -AJA- 2000/01/03: Wrote this file (by cleaning up r2_bsp.c).

// TODO HERE:
//   * use IM_WIDTH(),IM_BOTTOM(),etc where needed.
//   + optimise first subsector: ignore floors out of view.
//   + split up: rgl_seg.c and rgl_mobj.c.
//   + handle scaling better.
//   - implement halos.

// this conditional applies to the whole file
#ifdef USE_GL

&lt;&lt; rgl_bsp #includes &gt;&gt;
&lt;&lt; rgl_bsp declarations &gt;&gt;
@others


#endif  // USE_GL
</t>
<t tx="T1162">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "e_search.h"
#include "m_bbox.h"
#include "m_random.h"
#include "p_local.h"
#include "p_mobj.h"
#include "r_defs.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_sky.h"
#include "r_state.h"
#include "r_things.h"
#include "r2_defs.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "v_res.h"
#include "w_textur.h"
#include "w_wad.h"
#include "v_ctx.h"
#include "z_zone.h"
</t>
<t tx="T1163">

#define DEBUG  0

#define HALOS    0


// colour of the player's weapon
int rgl_weapon_r;
int rgl_weapon_g;
int rgl_weapon_b;

//!!!
extern int glpar_invuln;


// common stuff

extern sector_t *frontsector;
extern sector_t *backsector;

static subsector_t *cur_sub;
static seg_t *cur_seg;

static boolean_t cur_upper_sky;
static boolean_t cur_lower_sky;
static boolean_t cur_upper_invis;
static boolean_t cur_lower_invis;

static boolean_t solid_mode;

//!!! HACK FIXME
extern boolean_t ren_allbright;
extern float_t ren_red_mul;
extern float_t ren_grn_mul;
extern float_t ren_blu_mul;

static subsector_t *drawsubs_head;
static subsector_t *drawsubs_tail;

int rgl_currtimeval; </t>
<t tx="T1164">@ hack..
The minimum distance between player and a visible sprite.
@c

#define MINZ        (4.0)

// LIGHTING RULES:
//
//   1. N/S/E/W changes and infrared are applied before darkening.
//   2. extralight and dlights are applied after darkening.
//   3. for gamma, we rely on the gamma function g() having the
//      property: g(X * Y) = g(X) * g(Y).
//

static INLINE int RGL_Light(int nominal)
{
  if (ren_allbright)
    return 255;
  
  if (effect_infrared)
    nominal += (int)(effect_strength * 255);

  DEV_ASSERT2(currentmap);
  if (currentmap-&gt;lighting &lt;= LMODEL_Doomish)
  {
    nominal = rgl_light_map[MIN(255, nominal)];
  }
  
  nominal += extralight * 16;
  
  return GAMMA_CONV(MIN(255, nominal));
}
</t>
<t tx="T1165">#define LT_RED(light)  (MIN(255,light) * ren_red_mul / 255.0)
#define LT_GRN(light)  (MIN(255,light) * ren_grn_mul / 255.0)
#define LT_BLU(light)  (MIN(255,light) * ren_blu_mul / 255.0)

typedef struct wall_plane_data_s
{
  vec3_t normal;
  divline_t div;

  int col[3];
  float_t trans;

  drawthing_t *dlights;

  float_t tx, tdx;
  float_t ty, ty_top, ty_mul, ty_skew;

  vec2_t x_mat, y_mat;
}
wall_plane_data_t;


void WallCoordFunc(vec3_t *src, local_gl_vert_t *vert, void *d)
{
  wall_plane_data_t *data = (wall_plane_data_t *)d;

  int R = data-&gt;col[0];
  int G = data-&gt;col[1];
  int B = data-&gt;col[2];

  float_t x = src-&gt;x;
  float_t y = src-&gt;y;
  float_t z = src-&gt;z;

  float_t tx, ty;
  float_t along;

  // compute texture coord
  if (fabs(data-&gt;div.dx) &gt; fabs(data-&gt;div.dy))
  {
    CHECKVAL(data-&gt;div.dx);
    along = (x - data-&gt;div.x) / data-&gt;div.dx;
  }
  else
  {
    CHECKVAL(data-&gt;div.dy);
    along = (y - data-&gt;div.y) / data-&gt;div.dy;
  }

  tx = data-&gt;tx + along * data-&gt;tdx;
  ty = data-&gt;ty + (data-&gt;ty_top - z) * data-&gt;ty_mul +
       along * data-&gt;ty_skew;
   
  // dynamic lighting
  if (use_dlights)
  {
    drawthing_t *dl;

    for (dl=data-&gt;dlights; dl; dl=dl-&gt;next)
    {
      // light behind seg ?    
      if (P_PointOnDivlineSide(dl-&gt;mo-&gt;x, dl-&gt;mo-&gt;y, &amp;data-&gt;div) != 0)
        continue;
       
      R2_AddColourDLights(1, &amp;R, &amp;G, &amp;B, &amp;x, &amp;y, &amp;z, dl-&gt;mo);
    }
  }

  SET_COLOR(LT_RED(R), LT_GRN(G), LT_BLU(B), data-&gt;trans);
  SET_TEXCOORD(tx, ty);
  SET_NORMAL(data-&gt;normal.x, data-&gt;normal.y, data-&gt;normal.z);
  SET_EDGE_FLAG(GL_TRUE);
  SET_VERTEX(x, y, z);
}
</t>
<t tx="T1166">void PlaneCoordFunc(vec3_t *src, local_gl_vert_t *vert, void *d)
{
  wall_plane_data_t *data = (wall_plane_data_t *)d;

  float_t x = src-&gt;x;
  float_t y = src-&gt;y;
  float_t z = src-&gt;z;

  float_t rx = (x + data-&gt;tx) / 64;
  float_t ry = (y + data-&gt;ty) / 64;

  float_t tx = rx * data-&gt;x_mat.x + ry * data-&gt;x_mat.y;
  float_t ty = rx * data-&gt;y_mat.x + ry * data-&gt;y_mat.y;

  int R = data-&gt;col[0];
  int G = data-&gt;col[1];
  int B = data-&gt;col[2];

  // dynamic lighting
  if (use_dlights)
  {
    drawthing_t *dl;

    for (dl=data-&gt;dlights; dl; dl=dl-&gt;next)
    {
      // light behind the plane ?    
      if ((dl-&gt;tz &gt; z) != (data-&gt;normal.z &gt; 0))
        continue;
 
      R2_AddColourDLights(1, &amp;R, &amp;G, &amp;B, &amp;x, &amp;y, &amp;z, dl-&gt;mo);
    }
  }

  SET_COLOR(LT_RED(R), LT_GRN(G), LT_BLU(B), data-&gt;trans);
  SET_TEXCOORD(tx, ty);
  SET_NORMAL(data-&gt;normal.x, data-&gt;normal.y, data-&gt;normal.z);
  SET_EDGE_FLAG(GL_TRUE);
  SET_VERTEX(x, y, z);
}
</t>
<t tx="T1167">@ Note: mid_masked is 2 &amp; 3 for horiz. sliding door.
@c

static void RGL_DrawWall(drawfloor_t *dfloor, float_t top,
    float_t bottom, float_t tex_top_h, surface_t *part,
    int mid_masked, boolean_t opaque, float_t x_offset)
{
  float_t x1 = cur_seg-&gt;v1-&gt;x;
  float_t y1 = cur_seg-&gt;v1-&gt;y;
  float_t x2 = cur_seg-&gt;v2-&gt;x;
  float_t y2 = cur_seg-&gt;v2-&gt;y;

  float_t xy_ofs = cur_seg-&gt;offset;
  float_t xy_len = cur_seg-&gt;length;

  float_t tex_x1 = 0, tex_y1 = 0;
  float_t tex_x2 = 0, tex_y2 = 0, tex_dy = 0;

  int w, h;
  float_t t_right, t_bottom;
  float_t trans = part-&gt;translucency;

  boolean_t blended;

  GLuint tex_id;
  const cached_image_t *cim;

  raw_polyquad_t *poly;
  wall_plane_data_t data;

  region_properties_t *props = part-&gt;override_p ? part-&gt;override_p : 
      dfloor-&gt;props;
  int lit_Nom = props-&gt;lightlevel;
  const colourmap_t *colmap = props-&gt;colourmap;
  float_t c_r, c_g, c_b;

  // ignore non-solid walls in solid mode (&amp; vice versa)
  blended = (part-&gt;translucency &lt;= 0.99) ? true : false;
  if ((blended || mid_masked) == solid_mode)
    return;
  
  DEV_ASSERT2(currentmap);
  
  // do the N/S/W/E bizzo...
  if (currentmap-&gt;lighting == LMODEL_Doom)
  {
    if (cur_seg-&gt;v1-&gt;y == cur_seg-&gt;v2-&gt;y)
      lit_Nom -= 8;
    else if (cur_seg-&gt;v1-&gt;x == cur_seg-&gt;v2-&gt;x)
      lit_Nom += 8;

    // limit to 0..255 range
    lit_Nom = MAX(0, MIN(255, lit_Nom));
  }

  V_GetColmapRGB(colmap, &amp;c_r, &amp;c_g, &amp;c_b, false);

  lit_Nom = RGL_Light(lit_Nom);

  data.col[0] = lit_Nom * c_r;
  data.col[1] = lit_Nom * c_g;
  data.col[2] = lit_Nom * c_b;

  data.trans = trans;

  data.dlights = dfloor-&gt;dlights;

  DEV_ASSERT2(part-&gt;image);
  cim = W_ImageCache(part-&gt;image, IMG_OGL, 0, true);
  tex_id = W_ImageGetOGL(cim);

  // Note: normally this would be wrong, since we're using the GL
  // texture ID later on (after W_ImageDone).  The W_LockImagesOGL
  // call saves us though.
  W_ImageDone(cim);

  w = part-&gt;image-&gt;actual_w;
  h = part-&gt;image-&gt;actual_h;
  t_right  = w / (float_t)part-&gt;image-&gt;total_w;
  t_bottom = h / (float_t)part-&gt;image-&gt;total_h;

  x_offset += xy_ofs;

  tex_x1 = x_offset;
  tex_x2 = tex_x1 + xy_len;
  
  tex_y1 = tex_top_h - top;
  tex_y2 = tex_top_h - bottom;
  tex_dy = part-&gt;y_mat.x * xy_len;

  // horizontal sliding door hack
  if (mid_masked &gt;= 2)
  {
    slider_move_t *smov = cur_seg-&gt;linedef-&gt;slider_move;
    line_t *L;

    float_t start, end;
    float_t seg_start, seg_end;

    // which side is seg on ?
    int side = 0;

    if ((cur_seg-&gt;v2-&gt;x - cur_seg-&gt;v1-&gt;x) * cur_seg-&gt;linedef-&gt;dx &lt; 0 ||
        (cur_seg-&gt;v2-&gt;y - cur_seg-&gt;v1-&gt;y) * cur_seg-&gt;linedef-&gt;dy &lt; 0)
    {
      side = 1;
    }

    if (side == 0)
    {
      seg_start = xy_ofs;
      seg_end   = seg_start + xy_len;
    }
    else
    {
      seg_end   = smov-&gt;line_len - xy_ofs;
      seg_start = seg_end - xy_len;
    }

    DEV_ASSERT2(smov);

    switch (smov-&gt;info-&gt;type * 2 + (mid_masked &amp; 1))
    {
      case (SLIDE_Left * 2 + 0):
        start = 0;
        end = smov-&gt;line_len - smov-&gt;opening;
        break;

      case (SLIDE_Right * 2 + 0):
        start = smov-&gt;opening;
        end = smov-&gt;line_len;
        break;

      case (SLIDE_Center * 2 + 0):
        start = 0;
        end = (smov-&gt;line_len - smov-&gt;opening) / 2;
        break;

      case (SLIDE_Center * 2 + 1):
        start = (smov-&gt;line_len + smov-&gt;opening) / 2;
        end = smov-&gt;line_len;
        break;
        
      default:
        return;
    }

    start = MAX(start, seg_start);
    end = MIN(end, seg_end);

    // no overlap ?
    if (end &lt;= start + 1)
      return;

    L = cur_seg-&gt;linedef;
    CHECKVAL(smov-&gt;line_len);
    
    x1 = L-&gt;v1-&gt;x + L-&gt;dx * start / smov-&gt;line_len;
    y1 = L-&gt;v1-&gt;y + L-&gt;dy * start / smov-&gt;line_len;

    x2 = L-&gt;v1-&gt;x + L-&gt;dx * end / smov-&gt;line_len;
    y2 = L-&gt;v1-&gt;y + L-&gt;dy * end / smov-&gt;line_len;

    switch (smov-&gt;info-&gt;type * 2 + (mid_masked &amp; 1))
    {
      case (SLIDE_Left * 2 + 0):
        tex_x1 = seg_start + smov-&gt;opening;
        tex_x2 = seg_end   + smov-&gt;opening;
        break;

      case (SLIDE_Right * 2 + 0):
        tex_x1 = seg_start - smov-&gt;opening;
        tex_x2 = seg_end   - smov-&gt;opening;
        break;

      case (SLIDE_Center * 2 + 0):
        tex_x1 = seg_start + smov-&gt;opening/2;
        tex_x2 = seg_end   + smov-&gt;opening/2;
        break;

      case (SLIDE_Center * 2 + 1):
        tex_x1 = seg_start - smov-&gt;opening/2;
        tex_x2 = seg_end   - smov-&gt;opening/2;
        break;
    }

    if (side == 1)
    {
      float_t tex_tmp = tex_x1;
      tex_x1 = tex_x2;
      tex_x2 = tex_tmp;
    }
  }
  else if (mid_masked == 1 &amp;&amp; cur_seg-&gt;linedef-&gt;special &amp;&amp;
      cur_seg-&gt;linedef-&gt;special-&gt;s.type != SLIDE_None)
  {
    // which side is seg on ?
    int side = 0;

    if ((cur_seg-&gt;v2-&gt;x - cur_seg-&gt;v1-&gt;x) * cur_seg-&gt;linedef-&gt;dx &lt; 0 ||
        (cur_seg-&gt;v2-&gt;y - cur_seg-&gt;v1-&gt;y) * cur_seg-&gt;linedef-&gt;dy &lt; 0)
    {
      side = 1;
    }

    if (side == 1)
    {
      tex_x1 = w - tex_x1;
      tex_x2 = w - tex_x2;
    }
  }
 
  tex_x1 /= (float_t) w * part-&gt;x_mat.x;
  tex_x2 /= (float_t) w * part-&gt;x_mat.x;

  data.tx  = tex_x1;
  data.tdx = tex_x2 - tex_x1;
  
  tex_y1 /= (float_t) h * part-&gt;y_mat.y;
  tex_y2 /= (float_t) h * part-&gt;y_mat.y;
  tex_dy /= (float_t) h * part-&gt;y_mat.y;

  tex_y1 = 1.0 - t_bottom * tex_y1;
  tex_y2 = 1.0 - t_bottom * tex_y2;

  data.ty_top = tex_top_h;

  data.ty = 1.0;
  data.ty_mul = -1.0 / (float_t)part-&gt;image-&gt;total_h / part-&gt;y_mat.y;
  data.ty_skew = 0;  //!!!! FIXME

#if (DEBUG &gt;= 3) 
    L_WriteDebug( "WALL (%d,%d,%d) -&gt; (%d,%d,%d)\n", 
      (int) x1, (int) y1, (int) top, (int) x2, (int) y2, (int) bottom);
#endif

  data.normal.x = y2 - y1;
  data.normal.y = x1 - x2;
  data.normal.z = 0;

  data.div.x  = cur_seg-&gt;v1-&gt;x;
  data.div.y  = cur_seg-&gt;v1-&gt;y;
  data.div.dx = cur_seg-&gt;v2-&gt;x - data.div.x;
  data.div.dy = cur_seg-&gt;v2-&gt;y - data.div.y;

  poly = RGL_NewPolyQuad(4, true);

  PQ_ADD_VERT(poly, x1, y1, bottom);
  PQ_ADD_VERT(poly, x1, y1, top);
  PQ_ADD_VERT(poly, x2, y2, bottom);
  PQ_ADD_VERT(poly, x2, y2, top);

  RGL_BoundPolyQuad(poly);
  
  if (use_dlights &amp;&amp; data.dlights)
  {
    RGL_SplitPolyQuadLOD(poly, 1, 128 &gt;&gt; detail_level);
  }

  RGL_RenderPolyQuad(poly, &amp;data, WallCoordFunc, tex_id, 
      mid_masked, blended);
   
  RGL_FreePolyQuad(poly);
}
</t>
<t tx="T1168">@ Analyses floor/ceiling heights, and add corresponding walls/floors
to the drawfloor. Returns true if the whole region was "solid".
@c

static boolean_t RGL_BuildWalls(drawfloor_t *dfloor)
{
  side_t *sd = cur_seg-&gt;sidedef;

  float_t f1 = dfloor-&gt;f_h;
  float_t c1 = dfloor-&gt;c_h;

  float_t f, c, x_offset;
  float_t tex_top_h;

  int j;
  wall_tile_t *wt;
  boolean_t opaque;

#if (DEBUG &gt;= 3)
    L_WriteDebug( "   BUILD WALLS %1.1f .. %1.1f\n", f1, c1);
#endif

  // handle TRANSLUCENT + THICK floors (a bit of a hack)
  if (dfloor-&gt;ef &amp;&amp; dfloor-&gt;higher &amp;&amp;
      (dfloor-&gt;ef-&gt;ef_info-&gt;type &amp; EXFL_Thick) &amp;&amp;
      (dfloor-&gt;ef-&gt;top-&gt;translucency &lt;= 0.99))
  {
    c1 = dfloor-&gt;ef-&gt;top_h;
  }

  for (j=0; j &lt; sd-&gt;tile_used; j++)
  {
    wt = sd-&gt;tiles + j;

    c = MIN(c1, wt-&gt;z2);
    f = MAX(f1, wt-&gt;z1);

    // not visible ?
    if (f &gt;= c)
      continue;

    DEV_ASSERT2(wt-&gt;surface-&gt;image);
 
    tex_top_h = wt-&gt;tex_z + wt-&gt;surface-&gt;offset.y;

    if (wt-&gt;flags &amp; WTILF_Extra)
      x_offset = cur_seg-&gt;sidedef-&gt;middle.offset.x;
    else
      x_offset = wt-&gt;surface-&gt;offset.x;
    
    opaque = (! cur_seg-&gt;backsector) ||
      (wt-&gt;surface-&gt;translucency &gt; 0.99 &amp;&amp; wt-&gt;surface-&gt;image-&gt;solid);
    
    // check for horizontal sliders
    if ((wt-&gt;flags &amp; WTILF_MidMask) &amp;&amp; cur_seg-&gt;linedef-&gt;special &amp;&amp; 
        cur_seg-&gt;linedef-&gt;special-&gt;s.type != SLIDE_None &amp;&amp;
        cur_seg-&gt;linedef-&gt;slider_move)
    {
      RGL_DrawWall(dfloor, c, f, tex_top_h,
          wt-&gt;surface, 2, opaque, x_offset);

      if (cur_seg-&gt;linedef-&gt;special-&gt;s.type == SLIDE_Center)
      {
        RGL_DrawWall(dfloor, c, f, tex_top_h,
            wt-&gt;surface, 3, opaque, x_offset);
      }
      continue;
    }
     
    RGL_DrawWall(dfloor, c, f, tex_top_h,
        wt-&gt;surface, (wt-&gt;flags &amp; WTILF_MidMask) ? 1 : 0, 
        opaque, x_offset);
  }

  if (cur_seg-&gt;sidedef-&gt;middle.image == NULL)
  {
    // -AJA- hack for transparent doors (this test would normally be
    // above this block, not inside it).
    //
    if (f1 &gt;= c1)
      return true;

    return false;
  }

  // handle sliders that are totally solid and closed
  if (cur_seg-&gt;linedef-&gt;special &amp;&amp;
      cur_seg-&gt;linedef-&gt;special-&gt;s.type != SLIDE_None &amp;&amp;
      ! cur_seg-&gt;linedef-&gt;special-&gt;s.see_through &amp;&amp;
      ! cur_seg-&gt;linedef-&gt;slider_move)
  {
    return true;
  }

  return false;
}
</t>
<t tx="T1169">static void RGL_WalkWall(seg_t *seg)
{
  drawfloor_t *dfloor;

  cur_seg = seg;

#if (DEBUG &gt;= 2)
    L_WriteDebug("   DRAW SEG %p\n", seg);
#endif

  DEV_ASSERT2(!seg-&gt;miniseg &amp;&amp; seg-&gt;linedef);
  
  // mark the segment on the automap
  seg-&gt;linedef-&gt;flags |= ML_Mapped;

  // --- handle each floor ---
  
  frontsector = seg-&gt;front_sub-&gt;sector;
  backsector  = NULL;

  if (seg-&gt;back_sub)
    backsector = seg-&gt;back_sub-&gt;sector;

  cur_upper_sky = cur_lower_sky = false;
  cur_upper_invis = cur_lower_invis = false;

  // --- handle sky ---
  
  if (backsector &amp;&amp; IS_SKY(frontsector-&gt;floor) &amp;&amp; IS_SKY(backsector-&gt;floor))
    cur_lower_sky = true;

  if (backsector &amp;&amp; IS_SKY(frontsector-&gt;ceil) &amp;&amp; IS_SKY(backsector-&gt;ceil))
    cur_upper_sky = true;

  if (cur_lower_sky &amp;&amp; solid_mode &amp;&amp;
      frontsector-&gt;f_h &lt; backsector-&gt;f_h)
  {
    RGL_DrawSkyWall(cur_seg, frontsector-&gt;f_h, backsector-&gt;f_h);
  }

  if (IS_SKY(frontsector-&gt;ceil) &amp;&amp; solid_mode)
  {
    if (frontsector-&gt;c_h &lt; frontsector-&gt;sky_h &amp;&amp;
        (! backsector || ! IS_SKY(backsector-&gt;ceil) ||
         backsector-&gt;f_h &gt;= frontsector-&gt;c_h))
    {
      RGL_DrawSkyWall(cur_seg, frontsector-&gt;c_h, frontsector-&gt;sky_h);
    }
    else if (backsector &amp;&amp; IS_SKY(backsector-&gt;ceil))
    {
      float_t max_f = MAX(frontsector-&gt;f_h, backsector-&gt;f_h);

      if (backsector-&gt;c_h &lt;= max_f &amp;&amp; max_f &lt; frontsector-&gt;sky_h)
      {
        RGL_DrawSkyWall(cur_seg, max_f, frontsector-&gt;sky_h);
      }
    }
  }

  // -AJA- hack to allow transparent doors
  if (backsector)
  {
    cur_lower_invis = (seg-&gt;sidedef-&gt;bottom.image == NULL) &amp;&amp;
        (backsector-&gt;f_h != frontsector-&gt;f_h);

    cur_upper_invis = (seg-&gt;sidedef-&gt;top.image == NULL) &amp;&amp;
        (backsector-&gt;c_h != frontsector-&gt;c_h);
  }

  for (dfloor=cur_sub-&gt;floors; dfloor; dfloor=dfloor-&gt;next)
  {
    RGL_BuildWalls(dfloor);
  }
}
</t>
<t tx="T1170">@ Visit a single seg of the subsector, and for one-sided lines update
the 1D occlusion buffer.
@c

static void RGL_WalkSeg(seg_t *seg)
{
  angle_t angle1, angle2;
  angle_t span, tspan1, tspan2;

  seg-&gt;visible = false;

  // compute distances
  {
    float_t tx1 = seg-&gt;v1-&gt;x - viewx;
    float_t ty1 = seg-&gt;v1-&gt;y - viewy;
    float_t tx2 = seg-&gt;v2-&gt;x - viewx;
    float_t ty2 = seg-&gt;v2-&gt;y - viewy;

    seg-&gt;tx1 = tx1 * viewsin - ty1 * viewcos;
    seg-&gt;tz1 = tx1 * viewcos + ty1 * viewsin;

    seg-&gt;tx2 = tx2 * viewsin - ty2 * viewcos;
    seg-&gt;tz2 = tx2 * viewcos + ty2 * viewsin;
  }

  angle1 = R_PointToAngle(viewx, viewy, seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y);
  angle2 = R_PointToAngle(viewx, viewy, seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y);

#if (DEBUG &gt;= 3)
    L_WriteDebug( "INIT ANGLE1 = %1.2f  ANGLE2 = %1.2f\n", 
        ANG_2_FLOAT(angle1), ANG_2_FLOAT(angle2));
#endif

  // Clip to view edges.
  // -ES- 1999/03/20 Replaced clipangle with clipscope/leftclipangle/rightclipangle

  span = angle1 - angle2;

  // back side ?
  if (span &gt;= ANG180)
    return;

  angle1 -= viewangle;
  angle2 -= viewangle;

#if (DEBUG &gt;= 3)
    L_WriteDebug( "ANGLE1 = %1.2f  ANGLE2 = %1.2f\n", 
        ANG_2_FLOAT(angle1), ANG_2_FLOAT(angle2));
#endif

  tspan1 = angle1 - rightclipangle;
  tspan2 = leftclipangle - angle2;

  if (tspan1 &gt; clipscope)
  {
    // Totally off the left edge?
    if (tspan2 &gt;= ANG180)
      return;

    angle1 = leftclipangle;
  }

  if (tspan2 &gt; clipscope)
  {
    // Totally off the left edge?
    if (tspan1 &gt;= ANG180)
      return;

    angle2 = rightclipangle;
  }

#if (DEBUG &gt;= 3)
    L_WriteDebug( "CLIPPED ANGLE1 = %1.2f  ANGLE2 = %1.2f\n", 
        ANG_2_FLOAT(angle1), ANG_2_FLOAT(angle2));
#endif

  // The seg is in the view range,
  // but not necessarily visible.

#if (DEBUG &gt;= 2)
    L_WriteDebug( "  %sSEG %p (%1.1f, %1.1f) -&gt; (%1.1f, %1.1f)\n",
        seg-&gt;miniseg ? "MINI" : "", seg, seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y, 
        seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y);
#endif
 
  // check if visible
#if 1
  if (span &gt; (ANG1/4) &amp;&amp; RGL_1DOcclusionTest(angle2, angle1))
  {
    return;
  }
#endif

  seg-&gt;visible = span &gt; (ANG1 / 64);

  seg-&gt;angle1 = angle1;
  seg-&gt;angle2 = angle2;

  if (seg-&gt;miniseg)
    return;

  // only 1 sided walls affect the 1D occlusion buffer
  // FIXME: may need a hack for transparent doors
  if (seg-&gt;linedef-&gt;blocked)
    RGL_1DOcclusionSet(angle2, angle1);
}
</t>
<t tx="T1171">@ Checks BSP node/subtree bounding box.
Returns true if some part of the bbox might be visible.

Placed here to be close to RGL_WalkSeg(), which has similiar angle
clipping stuff in it.
@c

extern int checkcoord[12][4];

boolean_t RGL_CheckBBox(float_t *bspcoord)
{
  int boxx, boxy;
  int boxpos;

  float_t x1, y1, x2, y2;

  angle_t angle1, angle2;
  angle_t span, tspan1, tspan2;

  // Find the corners of the box
  // that define the edges from current viewpoint.
  if (viewx &lt;= bspcoord[BOXLEFT])
    boxx = 0;
  else if (viewx &lt; bspcoord[BOXRIGHT])
    boxx = 1;
  else
    boxx = 2;

  if (viewy &gt;= bspcoord[BOXTOP])
    boxy = 0;
  else if (viewy &gt; bspcoord[BOXBOTTOM])
    boxy = 1;
  else
    boxy = 2;

  boxpos = (boxy &lt;&lt; 2) + boxx;

  if (boxpos == 5)
    return true;

  x1 = bspcoord[checkcoord[boxpos][0]];
  y1 = bspcoord[checkcoord[boxpos][1]];
  x2 = bspcoord[checkcoord[boxpos][2]];
  y2 = bspcoord[checkcoord[boxpos][3]];

  // check clip list for an open space
  angle1 = R_PointToAngle(viewx, viewy, x1, y1) - viewangle;
  angle2 = R_PointToAngle(viewx, viewy, x2, y2) - viewangle;

  span = angle1 - angle2;

  // Sitting on a line?
  if (span &gt;= ANG180)
    return true;

  // -ES- 1999/03/20 Replaced clipangle with clipscope/leftclipangle/rightclipangle

  tspan1 = angle1 - rightclipangle;
  tspan2 = leftclipangle - angle2;

  if (tspan1 &gt; clipscope)
  {
    // Totally off the left edge?
    if (tspan2 &gt;= ANG180)
      return false;

    angle1 = leftclipangle;
  }

  if (tspan2 &gt; clipscope)
  {
    // Totally off the right edge?
    if (tspan1 &gt;= ANG180)
      return false;

    angle2 = rightclipangle;
  }

  return ! RGL_1DOcclusionTest(angle2, angle1);
}
</t>
<t tx="T1172">static void RGL_DrawPlane(drawfloor_t *dfloor, float_t h,
    surface_t *info, int face_dir)
{
  seg_t *seg;

  boolean_t mid_masked = false;
  boolean_t blended;

  wall_plane_data_t data;
  raw_polyquad_t *poly;

  GLuint tex_id;
  const cached_image_t *cim;

  int num_vert, i;

  region_properties_t *props = info-&gt;override_p ?
      info-&gt;override_p : dfloor-&gt;props;

  int lit_Nom = RGL_Light(props-&gt;lightlevel);
  const colourmap_t *colmap = props-&gt;colourmap;
  float_t c_r, c_g, c_b;

  float_t trans = info-&gt;translucency;

  // ignore sky
  if (IS_SKY(*info))
    return;

  // ignore invisible planes
  if (trans &lt; 0.01)
    return;
 
  // ignore non-facing planes
  if ((viewz &gt; h) != (face_dir &gt; 0))
    return;

  // ignore non-solid planes in solid_mode (&amp; vice versa)
  blended = (trans &lt;= 0.99) ? true : false;
  if (blended == solid_mode)
    return;

  // ignore dud regions (floor &gt;= ceiling)
  if (dfloor-&gt;f_h &gt; dfloor-&gt;c_h)
    return;

  // ignore empty subsectors
  if (cur_sub-&gt;segs == NULL)
    return;

  // count number of actual vertices
  for (seg=cur_sub-&gt;segs, num_vert=0; seg; seg=seg-&gt;sub_next, num_vert++)
  {
    /* nothing here */
  }

  if (num_vert &gt; MAX_PLVERT)
    num_vert = MAX_PLVERT;
 
  V_GetColmapRGB(colmap, &amp;c_r, &amp;c_g, &amp;c_b, false);

  data.col[0] = lit_Nom * c_r;
  data.col[1] = lit_Nom * c_g;
  data.col[2] = lit_Nom * c_b;

  data.trans = trans;

  data.dlights = dfloor-&gt;dlights;

  data.normal.x = 0;
  data.normal.y = 0;
  data.normal.z = (viewz &gt; h) ? 1.0 : -1.0;
 
  DEV_ASSERT2(info-&gt;image);
  cim = W_ImageCache(info-&gt;image, IMG_OGL, 0, true);
  tex_id = W_ImageGetOGL(cim);
  
  // Note: normally this would be wrong, since we're using the GL
  // texture ID later on (after W_ImageDone).  The W_LockImagesOGL
  // call saves us though.
  //
  W_ImageDone(cim);

  data.tx = info-&gt;offset.x;
  data.ty = info-&gt;offset.y;

  data.x_mat = info-&gt;x_mat;
  data.y_mat = info-&gt;y_mat;

  poly = RGL_NewPolyQuad(num_vert, false);

  for (seg=cur_sub-&gt;segs, i=0; seg &amp;&amp; (i &lt; MAX_PLVERT); 
       seg=seg-&gt;sub_next, i++)
  {
    PQ_ADD_VERT(poly, seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y, h);
  }

  RGL_BoundPolyQuad(poly);
 
  if (use_dlights &amp;&amp; data.dlights)
  {
    RGL_SplitPolyQuadLOD(poly, 1, 128 &gt;&gt; detail_level);
  }

  RGL_RenderPolyQuad(poly, &amp;data, PlaneCoordFunc, tex_id, 
      mid_masked, blended);
 
  RGL_FreePolyQuad(poly);
}
</t>
<t tx="T1173">@ Visit a single thing that exists in the current subsector.
@c

static void RGL_WalkThing(mobj_t *mo)
{
  drawthing_t *dthing;
  
  float_t tr_x;
  float_t tr_y;

  float_t pos1, pos2;
  float_t tx, tx1, tx2;
  float_t tz;

  float_t gzb, gzt;

  float_t xscale;
  float_t yscale;
  float_t dist_scale;
  int clip_vert = 0;

  const image_t *image;
  int sprite_height;
  int top_offset;

  boolean_t spr_flip;

  // ignore invisible things
  if (mo-&gt;visibility == INVISIBLE)
      return;

  // transform the origin point
  tr_x = mo-&gt;x - viewx;
  tr_y = mo-&gt;y - viewy;

  tz = tr_x * viewcos + tr_y * viewsin;

  // thing is behind view plane?
  if (tz &lt; MINZ)
    return;

  // -ES- 1999/03/14 Use distunit for y and x scale.
  CHECKVAL(tz);
  xscale = x_distunit / tz;
  yscale = y_distunit / tz;
  dist_scale = yscale;

  tx = tr_x * viewsin - tr_y * viewcos;

  // too far off the side?
  // -ES- 1999/03/13 Fixed clipping to work with large FOVs (up to 176 deg)
  // rejects all sprites where angle&gt;176 deg (arctan 32), since those
  // sprites would result in overflow in future calculations
  if (fabs(tx) / 32 &gt; tz)
    return;
  
  image = R2_GetThingSprite(mo, &amp;spr_flip);

  if (!image)
    return;

  // calculate edges of the shape
  pos1 = - IM_OFFSETX(image) * mo-&gt;info-&gt;xscale;
  pos2 = pos1 + IM_WIDTH(image) * mo-&gt;info-&gt;xscale;
  
  tx1 = tx + pos1;
  tx2 = tx + pos2;

  xscale *= mo-&gt;info-&gt;xscale;
  yscale *= mo-&gt;info-&gt;yscale;

  sprite_height = IM_HEIGHT(image);
  top_offset = IM_OFFSETY(image);

  gzt = mo-&gt;z + top_offset * mo-&gt;info-&gt;yscale;
  gzb = gzt - sprite_height * mo-&gt;info-&gt;yscale;

  // fix for sprites that sit wrongly into the floor/ceiling

  if (mo-&gt;flags &amp; MF_FUZZY)
  {
    clip_vert = -1;
  }
  else if (sprite_kludge==0 &amp;&amp; gzb &lt; mo-&gt;floorz)
  {
    // explosion ?
    if (mo-&gt;info-&gt;flags &amp; MF_MISSILE)
    {
      clip_vert = +1;
    }
    else
    {
      gzt += mo-&gt;floorz - gzb;
      gzb = mo-&gt;floorz;
    }
  }
  else if (sprite_kludge==0 &amp;&amp; gzt &gt; mo-&gt;ceilingz)
  {
    // explosion ?
    if (mo-&gt;info-&gt;flags &amp; MF_MISSILE)
    {
      clip_vert = +1;
    }
    else
    {
      gzb -= gzt - mo-&gt;ceilingz;
      gzt = mo-&gt;ceilingz;
    }
  }

  if (gzb &gt;= gzt)
    return;

  // create new draw thing

  dthing = R2_GetDrawThing();
  R2_CommitDrawThing(1);

  dthing-&gt;mo = mo;
  dthing-&gt;props = cur_sub-&gt;floors-&gt;props;
  dthing-&gt;clip_vert = clip_vert;
  dthing-&gt;clipped_left = dthing-&gt;clipped_right = false;

  dthing-&gt;image  = image;
  dthing-&gt;flip   = spr_flip;
  dthing-&gt;bright = mo-&gt;bright ? true : false;
  dthing-&gt;is_shadow = false;
  dthing-&gt;is_halo   = false;
  
  dthing-&gt;xscale = xscale;
  dthing-&gt;yscale = yscale;
  dthing-&gt;iyscale = 1.0 / mo-&gt;info-&gt;yscale;
  dthing-&gt;dist_scale = dist_scale;

  dthing-&gt;tx = tx;
  dthing-&gt;tz = tz;
  dthing-&gt;tx1 = tx1;
  dthing-&gt;tx2 = tx2;

  dthing-&gt;top = gzt;
  dthing-&gt;bottom = gzb;
  dthing-&gt;area.y_offset = 0;

  dthing-&gt;left_dx  = pos1 *  viewsin;
  dthing-&gt;left_dy  = pos1 * -viewcos;
  dthing-&gt;right_dx = pos2 *  viewsin;
  dthing-&gt;right_dy = pos2 * -viewcos;
  
  // translation support
  if (mo-&gt;info-&gt;palremap)
    dthing-&gt;trans_table = V_GetTranslationTable(mo-&gt;info-&gt;palremap);
  else
    dthing-&gt;trans_table = NULL;

  // create shadow
  if (level_flags.shadows &amp;&amp; mo-&gt;info-&gt;shadow_trans &gt; 0 &amp;&amp;
      mo-&gt;floorz &lt; viewz &amp;&amp; ! IS_SKY(mo-&gt;subsector-&gt;sector-&gt;floor))
  {
    drawthing_t *dshadow = R2_GetDrawThing();
    R2_CommitDrawThing(1);

    dshadow[0] = dthing[0];

    dshadow-&gt;is_shadow = true;
    dshadow-&gt;clip_vert = -1;
    dshadow-&gt;trans_table = NULL;
    dshadow-&gt;tz += 1.5;

    // shadows are 1/4 the height
    dshadow-&gt;yscale *= 4.0;
    dshadow-&gt;iyscale *= 4.0;

    gzb = mo-&gt;floorz;
    gzt = gzb + sprite_height / 4.0 * mo-&gt;info-&gt;yscale;

    dshadow-&gt;top = gzt;
    dshadow-&gt;bottom = gzb;

    R2_ClipSpriteVertically(cur_sub, dshadow);
  }

#if 0  // DISABLED
  // create halo
  if (level_flags.halos &amp;&amp; mo-&gt;info-&gt;halo.height &gt; 0)
  {
    drawthing_t *dhalo = R2_GetDrawThing();
    R2_CommitDrawThing(1);

    dhalo[0] = dthing[0];

    dhalo-&gt;is_halo = true;
    dhalo-&gt;image = W_ImageFromHalo(mo-&gt;info-&gt;halo.graphic);
    dhalo-&gt;clip_vert = -1;
    dhalo-&gt;trans_table = NULL;
    dhalo-&gt;tz -= 7.5;

    gzb = mo-&gt;z + mo-&gt;height * 0.75 - mo-&gt;info-&gt;halo.height / 2;
    gzt = mo-&gt;z + mo-&gt;height * 0.75 + mo-&gt;info-&gt;halo.height / 2;

    dhalo-&gt;top = gzt;
    dhalo-&gt;bottom = gzb;

    pos1 = - mo-&gt;info-&gt;halo.height / 2;
    pos2 = + mo-&gt;info-&gt;halo.height / 2;

    dhalo-&gt;tx1 = tx + pos1;
    dhalo-&gt;tx2 = tx + pos2;

    dhalo-&gt;left_dx  = pos1 *  viewsin;  // FIXME: move forward
    dhalo-&gt;left_dy  = pos1 * -viewcos;
    dhalo-&gt;right_dx = pos2 *  viewsin;
    dhalo-&gt;right_dy = pos2 * -viewcos;

    dhalo-&gt;iyscale = mo-&gt;info-&gt;halo.height / IM_HEIGHT(dhalo-&gt;image);

    R2_ClipSpriteVertically(cur_sub, dhalo);
  }
#endif

  R2_ClipSpriteVertically(cur_sub, dthing);
}
</t>
<t tx="T1174">void RGL_DrawThing(drawfloor_t *dfloor, drawthing_t *dthing)
{
  int w, h;
  float_t right, bottom;

  float_t dx, dy;
  float_t tex_x1, tex_y1;
  float_t tex_x2, tex_y2;

  boolean_t blended;

  local_gl_vert_t *vert, *orig;

  float_t x1b, y1b, z1b, x1t, y1t, z1t;
  float_t x2b, y2b, z2b, x2t, y2t, z2t;

  int L_r, L_g, L_b;

  const image_t *image;
  const cached_image_t *cim;
  GLuint tex_id;

  int lit_Nom = dthing-&gt;bright ? 255 : 
      RGL_Light(dthing-&gt;props-&gt;lightlevel);
  const colourmap_t *colmap = dthing-&gt;props-&gt;colourmap;
  float_t c_r, c_g, c_b;

  int fuzzy = (dthing-&gt;mo-&gt;flags &amp; MF_FUZZY);
  float_t trans = fuzzy ? FUZZY_TRANS : dthing-&gt;mo-&gt;visibility;

  V_GetColmapRGB(colmap, &amp;c_r, &amp;c_g, &amp;c_b, false);

  dx = dy = 0;

  if (dthing-&gt;is_shadow)
  {
    L_r = L_g = L_b = 0;

    trans = dthing-&gt;mo-&gt;visibility * 
        PERCENT_2_FLOAT(dthing-&gt;mo-&gt;info-&gt;shadow_trans);

    dx = viewcos * 2;
    dy = viewsin * 2;
  }
#if 0  // HALO disabled
  else if (dthing-&gt;is_halo)
  {
    L_r = L_g = L_b = 255;  //!!

    trans = 0.5;  //!!

    dx = -viewcos * 5;
    dy = -viewsin * 5;
  }
#endif
  else
  {
    L_r = lit_Nom * c_r;
    L_g = lit_Nom * c_g;
    L_b = lit_Nom * c_b;
  }

  image = dthing-&gt;image;

  w = IM_WIDTH(image);
  h = IM_HEIGHT(image);
  right = IM_RIGHT(image);
  bottom = IM_BOTTOM(image);

  x1b = x1t = dthing-&gt;mo-&gt;x + dthing-&gt;left_dx;
  y1b = y1t = dthing-&gt;mo-&gt;y + dthing-&gt;left_dy;
  x2b = x2t = dthing-&gt;mo-&gt;x + dthing-&gt;right_dx;
  y2b = y2t = dthing-&gt;mo-&gt;y + dthing-&gt;right_dy;

  z1b = z2b = dthing-&gt;bottom;
  z1t = z2t = dthing-&gt;top;

  tex_x1 = 0.01;
  tex_x2 = right - 0.01;

  tex_y1 = dthing-&gt;area.y_offset * dthing-&gt;iyscale;
  tex_y2 = tex_y1 + (z1t - z1b) * dthing-&gt;iyscale;

  CHECKVAL(h);
  tex_y1 = 1.00 - tex_y1 / h * bottom;
  tex_y2 = 1.00 - tex_y2 / h * bottom;
 
  if (dthing-&gt;flip)
  {
    float_t temp = tex_x2;
    tex_x1 = right - tex_x1;
    tex_x2 = right - temp;
  }

  //
  //  Dynamic Lighting Stuff
  //

  if (use_dlights &amp;&amp; !dthing-&gt;is_shadow &amp;&amp; !dthing-&gt;is_halo &amp;&amp; !fuzzy)
  {
    drawthing_t *dl;
    float_t wx[4], wy[4], wz[4];

    wx[0] = x1b;  wy[0] = y1b;  wz[0] = z1b;
    wx[1] = x1t;  wy[1] = y1t;  wz[1] = z1t;
    wx[2] = x2t;  wy[2] = y2t;  wz[2] = z2t;
    wx[3] = x2b;  wy[3] = y2b;  wz[3] = z2b;

    for (dl=dfloor-&gt;dlights; dl; dl=dl-&gt;next)
    {
      if (dl-&gt;mo == dthing-&gt;mo)
        continue;

      R2_AddColourDLights(1, &amp;L_r, &amp;L_g, &amp;L_b, wx, wy, wz, dl-&gt;mo);
    }
  }
 
  //
  // Special FUZZY effect
  //
  if (fuzzy &amp;&amp; !dthing-&gt;is_shadow &amp;&amp; !dthing-&gt;is_halo)
  {
    float_t range_x = fabs(dthing-&gt;right_dx - dthing-&gt;left_dx) / 12.0;
    float_t range_y = fabs(dthing-&gt;right_dy - dthing-&gt;left_dy) / 12.0;
    float_t range_z = fabs(z1t - z1b) / 24.0 / 2;

    float_t bl = sin(rgl_currtimeval / 5.0);
    float_t tl = sin(rgl_currtimeval / 11.0);
    float_t tr = sin(rgl_currtimeval / 7.0);
    float_t br = sin(rgl_currtimeval / 13.0);

    float_t zbl = 1.0 + cos(rgl_currtimeval / 5.0);
    float_t ztl = 1.0 + cos(rgl_currtimeval / 11.0);
    float_t ztr = 1.0 + cos(rgl_currtimeval / 7.0);
    float_t zbr = 1.0 + cos(rgl_currtimeval / 13.0);
    
    x1b += bl * range_x; y1b += bl * range_y; z1b += zbl * range_z;
    x1t += tl * range_x; y1t += tl * range_y; z1t += ztl * range_z;
    x2t += tr * range_x; y2t += tr * range_y; z2t += ztr * range_z;
    x2b += br * range_x; y2b += br * range_y; z2b += zbr * range_z;

    L_r = L_g = L_b = 0;
  }

  cim = W_ImageCache(image, IMG_OGL, 0, true);

  tex_id = W_ImageGetOGL(cim);

  // Blended sprites, even if opaque (trans &gt; 0.99), have nicer
  // edges.
  blended = true;

  vert = orig = RGL_BeginUnit(GL_QUADS, 4, tex_id, true, blended);

  SET_COLOR(LT_RED(L_r), LT_GRN(L_g), LT_BLU(L_b), trans);
  SET_TEXCOORD(tex_x1, tex_y2);
  SET_NORMAL(-viewcos, -viewsin, 0.0);
  SET_EDGE_FLAG(GL_TRUE);
  SET_VERTEX(x1b+dx, y1b+dy, z1b);
  vert++;
  
  SET_COLOR(LT_RED(L_r), LT_GRN(L_g), LT_BLU(L_b), trans);
  SET_TEXCOORD(tex_x1, tex_y1);
  SET_NORMAL(-viewcos, -viewsin, 0.0);
  SET_EDGE_FLAG(GL_TRUE);
  SET_VERTEX(x1t+dx, y1t+dy, z1t);
  vert++;
  
  SET_COLOR(LT_RED(L_r), LT_GRN(L_g), LT_BLU(L_b), trans);
  SET_TEXCOORD(tex_x2, tex_y1);
  SET_NORMAL(-viewcos, -viewsin, 0.0);
  SET_EDGE_FLAG(GL_TRUE);
  SET_VERTEX(x2t+dx, y2t+dy, z2t);
  vert++;
  
  SET_COLOR(LT_RED(L_r), LT_GRN(L_g), LT_BLU(L_b), trans);
  SET_TEXCOORD(tex_x2, tex_y2);
  SET_NORMAL(-viewcos, -viewsin, 0.0);
  SET_EDGE_FLAG(GL_TRUE);
  SET_VERTEX(x2b+dx, y2b+dy, z2b);
  vert++;

  RGL_EndUnit(vert - orig);

  // Note: normally this would be wrong, since we're using the GL
  // texture ID later on (after W_ImageDone).  The W_LockImagesOGL
  // call saves us though.
  //
  W_ImageDone(cim);
}
</t>
<t tx="T1175">static drawthing_t **mapdrawthings = NULL;
static int mapdrawthing_num = 0;

static void RGL_DrawSortThings(drawfloor_t *dfloor)
{
  drawthing_t *dthing;

  int i, count=0;

  for (dthing=dfloor-&gt;things; dthing; dthing=dthing-&gt;next)
    count++;

  if (count == 0)
    return;

  // maybe reallocate array
  if (count &gt; mapdrawthing_num)
  {
    Z_Resize(mapdrawthings, drawthing_t *, count);
    mapdrawthing_num = count;
  }

  // fill array
  count=0;

  for (dthing=dfloor-&gt;things; dthing; dthing=dthing-&gt;next)
    mapdrawthings[count++] = dthing;

  // sort array into decreasing distance
  #define CMP(a,b)  ((a)-&gt;tz &gt; (b)-&gt;tz)
  QSORT(drawthing_t *, mapdrawthings, count, CUTOFF);
  #undef CMP

  // draw array
  for (i=0; i &lt; count; i++)
    RGL_DrawThing(dfloor, mapdrawthings[i]);
}
</t>
<t tx="T1176">static void LightUpPlayerWeapon(player_t *p, drawfloor_t *dfloor)
{
  drawthing_t *dl;

  float_t x, y, z;

  x = p-&gt;mo-&gt;x;
  y = p-&gt;mo-&gt;y;
  z = p-&gt;mo-&gt;z + p-&gt;mo-&gt;height *
      PERCENT_2_FLOAT(p-&gt;mo-&gt;info-&gt;shotheight);

  for (dl=dfloor-&gt;dlights; dl; dl=dl-&gt;next)
  {
    R2_AddColourDLights(1, &amp;rgl_weapon_r, &amp;rgl_weapon_g, &amp;rgl_weapon_b, 
        &amp;x, &amp;y, &amp;z, dl-&gt;mo);
  }
}
</t>
<t tx="T1177">static INLINE void AddNewDrawFloor(extrafloor_t *ef,
    float_t f_h, float_t c_h, float_t top_h,
    surface_t *floor, surface_t *ceil,
    region_properties_t *props)
{
  drawfloor_t *dfloor;
  drawfloor_t *tail;

  dfloor = R2_GetDrawFloor();
  R2_CommitDrawFloor(1);

  Z_Clear(dfloor, drawfloor_t, 1);

  dfloor-&gt;f_h   = f_h;
  dfloor-&gt;c_h   = c_h;
  dfloor-&gt;top_h = top_h;
  dfloor-&gt;floor = floor;
  dfloor-&gt;ceil  = ceil;
  dfloor-&gt;ef    = ef;
  dfloor-&gt;props = props;
  
  // link it in
  // (order is very important)

  if (cur_sub-&gt;floors == NULL || f_h &gt; viewz)
  {
    // add to head
    dfloor-&gt;next = cur_sub-&gt;floors;
    dfloor-&gt;prev = NULL;

    if (cur_sub-&gt;floors)
      cur_sub-&gt;floors-&gt;prev = dfloor;

    cur_sub-&gt;floors = dfloor;
  }
  else
  {
    // add to tail
    for (tail=cur_sub-&gt;floors; tail-&gt;next; tail=tail-&gt;next)
    { /* nothing here */ }

    dfloor-&gt;next = NULL;
    dfloor-&gt;prev = tail;

    tail-&gt;next = dfloor;
  }

  // add to tail of height order list (for sprite clipping)
  for (tail=cur_sub-&gt;z_floors; tail &amp;&amp; tail-&gt;higher; tail=tail-&gt;higher)
  { /* nothing here */ }

  dfloor-&gt;higher = NULL;
  dfloor-&gt;lower = tail;

  if (tail)
    tail-&gt;higher = dfloor;
  else
    cur_sub-&gt;z_floors = dfloor;

  if (use_dlights &amp;&amp; blocklights)
  {
    R2_FindDLights(cur_sub, dfloor);

    if (cur_sub == viewsubsector &amp;&amp; f_h &lt;= viewz &amp;&amp; viewz &lt;= c_h)
      LightUpPlayerWeapon(consoleplayer, dfloor);
  }
}
</t>
<t tx="T1178">@ Visit a subsector, and collect information, such as where the
walls, planes (ceilings &amp; floors) and things need to be drawn.
@c

static void RGL_WalkSubsector(int num)
{
  subsector_t *sub = &amp;subsectors[num];
  seg_t *seg;
  mobj_t *mo;
  sector_t *sector;
  surface_t *floor_s;
  float_t floor_h;

  extrafloor_t *S, *L, *C;

#if (DEBUG &gt;= 1)
    L_WriteDebug( "\nVISITING SUBSEC %d\n\n", num);
#endif

  cur_sub = sub;
  sector = cur_sub-&gt;sector;

  sub-&gt;ranges = NULL;
  sub-&gt;floors = sub-&gt;z_floors = NULL;
  sub-&gt;raw_things = NULL;

  // add in each extrafloor, traversing strictly upwards

  floor_s = &amp;sector-&gt;floor;
  floor_h = sector-&gt;f_h;

  S = sector-&gt;bottom_ef;
  L = sector-&gt;bottom_liq;

  while (S || L)
  {
    if (!L || (S &amp;&amp; S-&gt;bottom_h &lt; L-&gt;bottom_h))
    {
      C = S;  S = S-&gt;higher;
    }
    else
    {
      C = L;  L = L-&gt;higher;
    }

    DEV_ASSERT2(C);

    // ignore liquids in the middle of THICK solids, or below real
    // floor or above real ceiling
    //
    if (C-&gt;bottom_h &lt; floor_h || C-&gt;bottom_h &gt; sector-&gt;c_h)
      continue;
    
    AddNewDrawFloor(C, floor_h, C-&gt;bottom_h, C-&gt;top_h, floor_s, C-&gt;bottom, C-&gt;p);

    floor_s = C-&gt;top;
    floor_h = C-&gt;top_h;
  }

  AddNewDrawFloor(NULL, floor_h, sector-&gt;c_h, sector-&gt;c_h, 
      floor_s, &amp;sector-&gt;ceil, sector-&gt;p);
 

  // handle each sprite in the subsector.  Must be done before walls,
  // since the wall code will update the 1D occlusion buffer.
  
  for (mo=cur_sub-&gt;thinglist; mo; mo=mo-&gt;snext)
  {
    RGL_WalkThing(mo);
  }

  // clip 1D occlusion buffer.
  for (seg=sub-&gt;segs; seg; seg=seg-&gt;sub_next)
  {
    RGL_WalkSeg(seg);
  }

  // add drawsub to list
  // (add to head, thus the eventual order is furthest -&gt; closest)
  
  sub-&gt;rend_next = drawsubs_head;
  sub-&gt;rend_prev = NULL;
  
  if (drawsubs_head)
    drawsubs_head-&gt;rend_prev = sub;
  else
    drawsubs_tail = sub;

  drawsubs_head = sub;
}
</t>
<t tx="T1179">static void RGL_DrawSubsector(subsector_t *sub)
{
  drawfloor_t *dfloor;
  seg_t *seg;
  int vis_num = 0;

#if (DEBUG &gt;= 1)
    L_WriteDebug("\nREVISITING SUBSEC %d\n\n", (int)(sub - subsectors));
#endif

  cur_sub = sub;

  // handle each seg in the subsector
  for (seg=sub-&gt;segs; seg; seg=seg-&gt;sub_next)
  {
    if (seg-&gt;visible)
    {
      vis_num++;

      if (! seg-&gt;miniseg)
        RGL_WalkWall(seg);
    }
  }

  // are any segs visible ?  If not, abort now
  if (vis_num == 0)
    return;

  // handle sky
  if (solid_mode)
  {
    if (IS_SKY(cur_sub-&gt;sector-&gt;floor) &amp;&amp; 
        viewz &gt; cur_sub-&gt;sector-&gt;f_h)
    {
      RGL_DrawSkyPlane(cur_sub, cur_sub-&gt;sector-&gt;f_h);
    }

    if (IS_SKY(cur_sub-&gt;sector-&gt;ceil) &amp;&amp; 
        viewz &lt; cur_sub-&gt;sector-&gt;sky_h)
    {
      RGL_DrawSkyPlane(cur_sub, cur_sub-&gt;sector-&gt;sky_h);
    }
  }

  // handle each floor, drawing planes and things
  for (dfloor=sub-&gt;floors; dfloor; dfloor=dfloor-&gt;next)
  {
    RGL_DrawPlane(dfloor, dfloor-&gt;c_h, dfloor-&gt;ceil,  -1);
    RGL_DrawPlane(dfloor, dfloor-&gt;f_h, dfloor-&gt;floor, +1);

    if (solid_mode)
      continue;

    RGL_DrawSortThings(dfloor);
  }
}
</t>
<t tx="T1180">@ Walks all subsectors below a given node, traversing subtree
recursively, collecting information. Just call with BSP root.
@c

static void RGL_WalkBSPNode(int bspnum)
{
  node_t *node;
  int side;

  // Found a subsector?
  if (bspnum &amp; NF_SUBSECTOR)
  {
    RGL_WalkSubsector(bspnum &amp; (~NF_SUBSECTOR));
    return;
  }

  node = &amp;nodes[bspnum];

  // Decide which side the view point is on.
  side = P_PointOnDivlineSide(viewx, viewy, &amp;node-&gt;div);

#if (DEBUG &gt;= 2)
    L_WriteDebug( "NODE %d (%1.1f, %1.1f) -&gt; (%1.1f, %1.1f)  SIDE %d\n",
        bspnum, node-&gt;div.x, node-&gt;div.y, node-&gt;div.x +
        node-&gt;div.dx, node-&gt;div.y + node-&gt;div.dy, side);
#endif

  // Recursively divide front space.
  if (RGL_CheckBBox(node-&gt;bbox[side]))
    RGL_WalkBSPNode(node-&gt;children[side]);

  // Recursively divide back space.
  if (RGL_CheckBBox(node-&gt;bbox[side ^ 1]))
    RGL_WalkBSPNode(node-&gt;children[side ^ 1]);
}
</t>
<t tx="T1181">@ OpenGL BSP rendering. Initialises all structures, then walks the
BSP tree collecting information, then renders each subsector:
firstly front to back (drawing all solid walls &amp; planes) and then
from back to front (drawing everything else, sprites etc..).
@c

void RGL_RenderTrueBSP(void)
{
  subsector_t *cur;

  rgl_currtimeval = I_GetTime();

  // compute the 1D projection of the view angle
  {
    float_t k, d;

    // k is just the mlook angle (in radians)
    k = fabs(atan(viewvertangle));

    if (k &gt;= M_PI/4 || normalfov &gt; ANG90)
      oned_side_angle = ANG90;
    else
    {
      // d is just the distance horizontally forward from the eye to
      // the top/bottom edge of the view rectangle.
      d = M_ROOT2 * sin(M_PI/2 - (k + M_PI/4));

      oned_side_angle = ANG90 - M_ATan(d);
    }
  }

  // setup clip angles
  {
    leftclipangle  = 0 + oned_side_angle;
    rightclipangle = 0 - oned_side_angle;
    clipscope = leftclipangle - rightclipangle;
  }

  // clear extra light on player's weapon
  rgl_weapon_r = rgl_weapon_g = rgl_weapon_b = 0;

  R2_ClearBSP();
  RGL_1DOcclusionClear(0 - oned_side_angle, 0 + oned_side_angle);

  drawsubs_head = drawsubs_tail = NULL;

  // walk the bsp tree
  RGL_WalkBSPNode(root_node);

  // handle powerup effects
  RGL_RainbowEffect(consoleplayer);

//---  // NOTE: this call will be unneeded later.
//---  RGL_SetupMatrices2D();
//---  RGL_DrawSky();

  if (hom_detect)
  {
    glClearColor(0.0, 1.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
  }

  RGL_SetupMatrices3D();

  // enable depth buffer, and clear it
  glEnable(GL_DEPTH_TEST);
  glClear(GL_DEPTH_BUFFER_BIT);

  // make sure we don't delete any GL textures
  W_LockImagesOGL();

  // draw all solid walls and planes
  solid_mode = true;
  RGL_StartUnits(solid_mode);

  for (cur=drawsubs_tail; cur; cur=cur-&gt;rend_prev)
    RGL_DrawSubsector(cur);
    
  RGL_FinishUnits();
  
  // draw all sprites and masked/translucent walls/planes
  solid_mode = false;
  RGL_StartUnits(solid_mode);
  
  for (cur=drawsubs_head; cur; cur=cur-&gt;rend_next)
    RGL_DrawSubsector(cur);

  RGL_FinishUnits();
  glDisable(GL_DEPTH_TEST);

  W_UnlockImagesOGL();

  // now draw 2D stuff like psprites, and add effects
  RGL_SetupMatrices2D();

  RGL_DrawPlayerSprites(consoleplayer);

  RGL_ColourmapEffect(consoleplayer);

  // NOTE: this call will move for layer system (should be topmost).
  RGL_PaletteEffect(consoleplayer);
 
#if (DEBUG &gt;= 3) 
    L_WriteDebug( "\n\n");
#endif
}
</t>
<t tx="T1182">void RGL_RenderScene(int x, int y, int w, int h, vid_view_t *view)
{
  //!!!
  RGL_RenderTrueBSP();
}
</t>
<t tx="T1183">@ignore
@language c

// OpenGL Rendering (Main Stuff)

// this conditional applies to the whole file
#ifdef USE_GL

&lt;&lt; rgl_main #includes &gt;&gt;
&lt;&lt; rgl_main declarations &gt;&gt;
@others

#endif  // USE_GL
</t>
<t tx="T1184">#include "i_defs.h"

#include "am_map.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "e_search.h"
#include "m_bbox.h"
#include "m_random.h"
#include "p_local.h"
#include "p_mobj.h"
#include "r_defs.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_sky.h"
#include "r_state.h"
#include "r_things.h"
#include "r2_defs.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "v_res.h"
#include "w_textur.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1185">

#define DEBUG  0


// OpenGL video context
video_context_t vctx;


// implementation limits

int glmax_lights;
int glmax_clip_planes;
int glmax_tex_size;

int rgl_light_map[256];
static lighting_model_e rgl_light_model = 999;

char *glstr_vendor = NULL;
char *glstr_renderer = NULL;
char *glstr_version = NULL;
char *glstr_extensions = NULL;

boolean_t glcap_hardware = true;
boolean_t glcap_multitex = false;
boolean_t glcap_paletted = false;

angle_t oned_side_angle;


int glpar_invuln = 0;

boolean_t ren_allbright;
float_t ren_red_mul;
float_t ren_grn_mul;
float_t ren_blu_mul;

extern int rgl_currtimeval; </t>
<t tx="T1186">@ hack..
@c

#define RGB_RED(rgbcol)  ((float_t)((rgbcol &gt;&gt; 16) &amp; 0xFF) / 255.0)
#define RGB_GRN(rgbcol)  ((float_t)((rgbcol &gt;&gt;  8) &amp; 0xFF) / 255.0)
#define RGB_BLU(rgbcol)  ((float_t)((rgbcol      ) &amp; 0xFF) / 255.0)

#define PAL_RED(pix)  ((float_t)(playpal_data[0][pix][0]) / 255.0)
#define PAL_GRN(pix)  ((float_t)(playpal_data[0][pix][1]) / 255.0)
#define PAL_BLU(pix)  ((float_t)(playpal_data[0][pix][2]) / 255.0)

#define LT_RED(light)  (MIN(255,light) * ren_red_mul / 255.0)
#define LT_GRN(light)  (MIN(255,light) * ren_grn_mul / 255.0)
#define LT_BLU(light)  (MIN(255,light) * ren_blu_mul / 255.0)

static void SetupLightMap(lighting_model_e model)
{
  int i;
  
  rgl_light_model = model;

  for (i=0; i &lt; 256; i++)
  {
    if (model &gt;= LMODEL_Flat)
    {
      rgl_light_map[i] = i;
      continue;
    }

    // Approximation of standard Doom lighting: 
    // (based on side-by-side comparison)
    //    [0,72] --&gt; [0,16]
    //    [72,112] --&gt; [16,48]
    //    [112,256] --&gt; [48,240]   (bit of room for DLight)

    if (i &lt;= 72)
      rgl_light_map[i] = i * 2 / 9;
    else if (i &lt;= 112)
      rgl_light_map[i] = 16 + (i - 72) * 32 / 40;
    else
      rgl_light_map[i] = 48 + (i - 112) * 192 / 144;
  }
}
</t>
<t tx="T1187">@ Setup the GL matrices for drawing 2D stuff.
@c

void RGL_SetupMatrices2D(void)
{
  glViewport(0, 0, SCREENWIDTH, SCREENHEIGHT);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(0.0, (float_t)SCREENWIDTH, 
          0.0, (float_t)SCREENHEIGHT, -1.0, 1.0);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  // turn off lighting stuff
  glDisable(GL_LIGHTING);
  glDisable(GL_COLOR_MATERIAL);

  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}
</t>
<t tx="T1188">@ Setup the GL matrices for drawing 3D stuff.
@c

#define Z_NEAR  1.0
#define Z_FAR   32000.0

void RGL_SetupMatrices3D(void)
{
  glViewport(viewwindowx, SCREENHEIGHT - viewwindowy - viewwindowheight,
             viewwindowwidth, viewwindowheight);

  // calculate perspective matrix

  glMatrixMode(GL_PROJECTION);

  glLoadIdentity();
  glFrustum(rightslope, leftslope, bottomslope, topslope, Z_NEAR, Z_FAR);
#if 0
  glOrtho(rightslope * 240, leftslope * 240, bottomslope * 240, topslope * 240, Z_NEAR, Z_FAR);
#endif

  // calculate look-at matrix

  glMatrixMode(GL_MODELVIEW);

  glLoadIdentity();
  glRotatef(270.0 - atan(viewvertangle) * 180.0 / M_PI, 1.0, 0.0, 0.0);
  glRotatef(90.0 - ANG_2_FLOAT(viewangle), 0.0, 0.0, 1.0);
  glTranslatef(-viewx, -viewy, -viewz);

  // turn on lighting.  Some drivers (e.g. TNT2) don't work properly
  // without it.
  glEnable(GL_LIGHTING);

  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

  DEV_ASSERT2(currentmap);
  if (currentmap-&gt;lighting != rgl_light_model)
    SetupLightMap(currentmap-&gt;lighting);
}
</t>
<t tx="T1189">static void RGL_DrawPSprite(pspdef_t * psp, int which,
    player_t * player, region_properties_t *props, const state_t *state)
{
  const image_t *image;
  const cached_image_t *cim;
  boolean_t flip;

  int fuzzy = (player-&gt;mo-&gt;flags &amp; MF_FUZZY);

  float_t x1b, y1b, x1t, y1t, x2b, y2b, x2t, y2t;  // screen coords
  float_t tx1, ty1, tx2, ty2;  // texture coords

  float_t tex_x1, tex_x2;
  float_t tex_top_h, tex_bot_h;
  float_t trans;

  GLuint tex_id;
  int w, h;
  float_t right, bottom;

  int lit_Nom, L_r, L_g, L_b;
  float_t c_r, c_g, c_b;

  lit_Nom = (ren_allbright || state-&gt;bright) ? 240 :
      (props-&gt;lightlevel * 240 / 255);

  if (effect_infrared)
    lit_Nom += (int)(effect_strength * 255);

  lit_Nom = GAMMA_CONV(MIN(255,lit_Nom));

  // determine sprite patch
  image = R2_GetOtherSprite(state-&gt;sprite, state-&gt;frame, &amp;flip);

  if (!image)
    return;

  cim = W_ImageCache(image, IMG_OGL, 0, true);

  tex_id = W_ImageGetOGL(cim);

  w = IM_WIDTH(image);
  h = IM_HEIGHT(image);
  right = IM_RIGHT(image);
  bottom = IM_BOTTOM(image);

  trans = fuzzy ? FUZZY_TRANS : player-&gt;mo-&gt;visibility;
  trans *= psp-&gt;visibility;

  // psprites are never totally opaque
  if (trans &lt;= 0.99)
    glEnable(GL_BLEND);
  else
    glEnable(GL_ALPHA_TEST);

  glEnable(GL_TEXTURE_2D);
  glBindTexture(GL_TEXTURE_2D, tex_id);

  tex_top_h = 1.00; // 0.98;
  tex_bot_h = 1.00 - bottom;  // 1.02 - bottom;

  tex_x1 = 0.01;
  tex_x2 = right - 0.01;

  if (flip)
  {
    tex_x1 = right - tex_x1;
    tex_x2 = right - tex_x2;
  }

  tx1 = psp-&gt;sx - BASEXCENTER - IM_OFFSETX(image);
  tx2 = tx1 + w;

  ty1 = psp-&gt;sy - IM_OFFSETY(image);
  ty2 = ty1 + h;

  // compute lighting

  V_GetColmapRGB(props-&gt;colourmap, &amp;c_r, &amp;c_g, &amp;c_b, false);

  if (which == ps_weapon || which == ps_flash)
  {
    L_r = rgl_weapon_r + lit_Nom * c_r;
    L_g = rgl_weapon_g + lit_Nom * c_g;
    L_b = rgl_weapon_b + lit_Nom * c_b;
  }
  else
  {
    L_r = L_g = L_b = 255;
  }

  x1b = x1t = (160.0 + tx1) * viewwindowwidth / 320.0;
  x2b = x2t = (160.0 + tx2) * viewwindowwidth / 320.0;

  y1b = y2b = (ty2) * viewwindowheight / 200.0;
  y1t = y2t = (ty1) * viewwindowheight / 200.0;

  if (fuzzy)
  {
    float_t range_x = fabs(x2b - x1b) / 12.0;
    float_t range_y = fabs(y1t - y1b) / 12.0;

    float_t bl_x = sin(rgl_currtimeval / 5.0);
    float_t tl_x = sin(rgl_currtimeval / 11.0);
    float_t tr_x = sin(rgl_currtimeval / 7.0);
    float_t br_x = sin(rgl_currtimeval / 13.0);

    float_t tl_y = cos(rgl_currtimeval / 11.0);
    float_t tr_y = cos(rgl_currtimeval / 7.0);
    
    // don't adjust the bottom Y positions
    
    x1b += bl_x * range_x;
    x1t += tl_x * range_x; y1t += tl_y * range_y;
    x2t += tr_x * range_x; y2t += tr_y * range_y;
    x2b += br_x * range_x;

    L_r = L_g = L_b = 0;
  }

  // clip psprite to view window
  glEnable(GL_SCISSOR_TEST);

  glScissor(viewwindowx, SCREENHEIGHT-viewwindowheight-viewwindowy,
            viewwindowwidth, viewwindowheight);

  x1b = (float_t)viewwindowx + x1b;
  x1t = (float_t)viewwindowx + x1t;
  x2t = (float_t)viewwindowx + x2t;
  x2b = (float_t)viewwindowx + x2b;

  y1b = (float_t)(SCREENHEIGHT - viewwindowy) - y1b - 1;
  y1t = (float_t)(SCREENHEIGHT - viewwindowy) - y1t - 1;
  y2t = (float_t)(SCREENHEIGHT - viewwindowy) - y2t - 1;
  y2b = (float_t)(SCREENHEIGHT - viewwindowy) - y2b - 1;
 
  glColor4f(LT_RED(L_r), LT_GRN(L_g), LT_BLU(L_b), trans);

  glBegin(GL_QUADS);
  
  glTexCoord2f(tex_x1, tex_bot_h);
  glVertex2f(x1b, y1b);
  
  glTexCoord2f(tex_x1, tex_top_h);
  glVertex2f(x1t, y1t);
  
  glTexCoord2f(tex_x2, tex_top_h);
  glVertex2f(x2t, y1t);
  
  glTexCoord2f(tex_x2, tex_bot_h);
  glVertex2f(x2b, y2b);
  
  glEnd();

  glDisable(GL_TEXTURE_2D);
  glDisable(GL_ALPHA_TEST);
  glDisable(GL_BLEND);
  glDisable(GL_SCISSOR_TEST);

  W_ImageDone(cim);
}
</t>
<t tx="T1190">void RGL_DrawPlayerSprites(player_t * p)
{
  int i;

  DEV_ASSERT2(p-&gt;in_game);

  // special handling for zoom: show viewfinder
  if (viewiszoomed)
  {
    weaponinfo_t *w;
    pspdef_t *psp = &amp;p-&gt;psprites[ps_weapon];

    if ((p-&gt;ready_wp &lt; 0) || (psp-&gt;state == S_NULL))
      return;

    w = p-&gt;weapons[p-&gt;ready_wp].info;

    if (w-&gt;zoom_state &lt;= 0)
      return;

    RGL_DrawPSprite(psp, ps_weapon, p, view_props,
        states + w-&gt;zoom_state);
    
    return;
  }

  // add all active psprites
  // Note: order is significant

  for (i = 0; i &lt; NUMPSPRITES; i++)
  {
    pspdef_t *psp = &amp;p-&gt;psprites[i];

    if (psp-&gt;state == S_NULL)
      continue;

    RGL_DrawPSprite(psp, i, p, view_props, psp-&gt;state);
  }
}
</t>
<t tx="T1191">@ Effects that modify all colours, e.g. nightvision green.
@c

void RGL_RainbowEffect(player_t *player)
{
  float_t s;
  
  ren_allbright = false;
  ren_red_mul = ren_grn_mul = ren_blu_mul = 1.0;

  s = player-&gt;powers[PW_Invulnerable];  

  if (s &gt; 0)
  {
    s = MIN(128.0, s);
    ren_allbright = true;
    ren_red_mul = ren_grn_mul = ren_blu_mul = s / 256.0;
    return;
  }

  s = player-&gt;powers[PW_NightVision];

  if (s &gt; 0)
  {
    s = MIN(128.0, s);
    ren_red_mul = ren_blu_mul = 1.0 - s / 128.0;
    return;
  }

  // do berserk here... (rather than as a palette effect)
}
</t>
<t tx="T1192">@ For example: all white for invulnerability.
@c

void RGL_ColourmapEffect(player_t *player)
{
  int x1, y1;
  int x2, y2;

  if (player-&gt;powers[PW_Invulnerable] &lt;= 0)
    return;

  {
    float_t s = (float_t) player-&gt;powers[PW_Invulnerable];
    
    s = MIN(128.0, s) / 128.0;

    if (glpar_invuln == 0)
    {
      glColor4f(1.0, 1.0, 1.0, 0.0);
      glBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ZERO);
    }
    else
    {
      glColor4f(0.75 * s, 0.75 * s, 0.75 * s, 0.0);
      glBlendFunc(GL_ONE, GL_ONE);
    }
  }

  glEnable(GL_BLEND);

  glBegin(GL_QUADS);
  
  x1 = viewwindowx;
  x2 = viewwindowx + viewwindowwidth;

  y1 = SCREENHEIGHT - viewwindowy;
  y2 = SCREENHEIGHT - viewwindowy - viewwindowheight;

  glVertex2i(x1, y1);
  glVertex2i(x2, y1);
  glVertex2i(x2, y2);
  glVertex2i(x1, y2);

  glEnd();
  
  glDisable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}
</t>
<t tx="T1193">@ For example: red wash for pain.
@c

void RGL_PaletteEffect(player_t *player)
{
  byte rgb_data[3];
  int rgb_max;

  if (player-&gt;powers[PW_Invulnerable] &gt; 0)
    return;

  V_IndexColourToRGB(pal_black, rgb_data);

  rgb_max = MAX(rgb_data[0], MAX(rgb_data[1], rgb_data[2]));

  if (rgb_max == 0)
    return;
  
  rgb_max = MIN(200, rgb_max);

  glColor4f((float_t) rgb_data[0] / (float_t) rgb_max,
            (float_t) rgb_data[1] / (float_t) rgb_max,
            (float_t) rgb_data[2] / (float_t) rgb_max,
            (float_t) rgb_max / 255.0);

  glEnable(GL_BLEND);

  glBegin(GL_QUADS);
  
  glVertex2i(0, SCREENHEIGHT);
  glVertex2i(SCREENWIDTH, SCREENHEIGHT);
  glVertex2i(SCREENWIDTH, 0);
  glVertex2i(0, 0);

  glEnd();
  
  glDisable(GL_BLEND);
}
</t>
<t tx="T1194">void RGL_NewScreenSize(int width, int height, int bpp)
{
  //!!! quick hack
  RGL_SetupMatrices2D();
}
</t>
<t tx="T1195">void RGL_BeginDraw(int x1, int y1, int x2, int y2)
{
  //!!! set the SCISSORS test (&amp; optimise)

  //!!! optimise: don't setup 2D matrices when already setup
  RGL_SetupMatrices2D();
}
</t>
<t tx="T1196">void RGL_EndDraw(void)
{
  //!!! unset the SCISSORS test
}
</t>
<t tx="T1197">void RGL_DrawImage(int x, int y, int w, int h, const image_t *image, 
    float_t tx1, float_t ty1, float_t tx2, float_t ty2,
    const colourmap_t *colmap, float_t alpha)
{
  float_t r = 1.0, g = 1.0, b = 1.0;

  const cached_image_t *cim = W_ImageCache(image, IMG_OGL, 0, false);

  glEnable(GL_TEXTURE_2D);
  glBindTexture(GL_TEXTURE_2D, W_ImageGetOGL(cim));
 
  if (alpha &lt; 0.99 || !image-&gt;solid)
    glEnable(GL_BLEND);

///  else if (!image-&gt;solid)
///    glEnable(GL_ALPHA_TEST);
  
  if (colmap)
    V_GetColmapRGB(colmap, &amp;r, &amp;g, &amp;b, true);

  glColor4f(r, g, b, alpha);

  glBegin(GL_QUADS);
  
  glTexCoord2f(tx1, 1.0 - ty1);
  glVertex2i(x, SCREENHEIGHT - y);

  glTexCoord2f(tx2, 1.0 - ty1); 
  glVertex2i(x+w, SCREENHEIGHT - y);
  
  glTexCoord2f(tx2, 1.0 - ty2);
  glVertex2i(x+w, SCREENHEIGHT - y - h);
  
  glTexCoord2f(tx1, 1.0 - ty2);
  glVertex2i(x, SCREENHEIGHT - y - h);
  
  glEnd();

  glDisable(GL_TEXTURE_2D);
  glDisable(GL_ALPHA_TEST);
  glDisable(GL_BLEND);

  W_ImageDone(cim);
}
</t>
<t tx="T1198">void RGL_SolidBox(int x, int y, int w, int h, int colour, float_t alpha)
{
  if (alpha &lt; 0.99)
    glEnable(GL_BLEND);
  
  glColor4f(PAL_RED(colour), PAL_GRN(colour), PAL_BLU(colour), alpha);
  
  glBegin(GL_QUADS);

  glVertex2i(x,   (SCREENHEIGHT - y));
  glVertex2i(x,   (SCREENHEIGHT - y - h));
  glVertex2i(x+w, (SCREENHEIGHT - y - h));
  glVertex2i(x+w, (SCREENHEIGHT - y));
  
  glEnd();
  glDisable(GL_BLEND);
}
</t>
<t tx="T1199">void RGL_SolidLine(int x1, int y1, int x2, int y2, int colour)
{
  glColor3f(PAL_RED(colour), PAL_GRN(colour), PAL_BLU(colour));
  
  glBegin(GL_LINES);

  glVertex2i(x1, (SCREENHEIGHT - y1));
  glVertex2i(x2, (SCREENHEIGHT - y2));
  
  glEnd();
}
</t>
<t tx="T1200">void RGL_ReadScreen(int x1, int y1, int x2, int y2, byte *rgb_buffer)
{
  //...
}
</t>
<t tx="T1201">@ Based on code by Bruce Lewis.
@c

void RGL_CheckExtensions(void)
{
  glstr_version = Z_StrDup(glGetString(GL_VERSION));
  I_Printf("OpenGL: Version: %s\n", glstr_version);

  glstr_vendor = Z_StrDup(glGetString(GL_VENDOR));
  I_Printf("OpenGL: Vendor: %s\n", glstr_vendor);

  if (DDF_CompareName(glstr_vendor, "3DLABS") == 0)
  {
    // Permedia 3...  -AJA- implication ?
  }

  glstr_renderer = Z_StrDup(glGetString(GL_RENDERER));
  I_Printf("OpenGL: Renderer: %s\n", glstr_renderer);

  if (DDF_CompareName(glstr_vendor, "Microsoft Corporation") == 0 &amp;&amp;
      DDF_CompareName(glstr_renderer, "GDI Generic") == 0)
  {
    I_Error("OpenGL: SOFTWARE Renderer !\n");
    // glcap_hardware = false;
  }

  glstr_extensions = Z_StrDup(glGetString(GL_EXTENSIONS));

  if ((strstr(glstr_extensions, "ARB_multitexture") != NULL) ||
      (strstr(glstr_extensions, "EXT_multitexture") != NULL))
  {
    I_Printf("OpenGL: Multitexture extension found.\n");
    glcap_multitex = true;
  }

  if (strstr(glstr_extensions, "EXT_paletted_texture") != NULL)
  {
    I_Printf("OpenGL: Paletted texture extension found.\n");
    glcap_paletted = true;
  }
}
</t>
<t tx="T1202">@ All the stuff that can be re-initialised multiple times.
@c

void RGL_SoftInit(void)
{
  glDisable(GL_FOG);
  glDisable(GL_BLEND);
  glDisable(GL_LIGHTING);
  glDisable(GL_CULL_FACE);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_SCISSOR_TEST);
  glDisable(GL_STENCIL_TEST);

  glDisable(GL_LINE_SMOOTH);
  glDisable(GL_POLYGON_SMOOTH);

  if (use_dithering)
    glEnable(GL_DITHER);
  else
    glDisable(GL_DITHER);

  glEnable(GL_NORMALIZE);

  glShadeModel(GL_SMOOTH);
  glDepthFunc(GL_LEQUAL);
  glAlphaFunc(GL_GREATER, 1.0 / 32.0);

  glHint(GL_FOG_HINT, GL_FASTEST);
  glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
}
</t>
<t tx="T1203">void RGL_Init(void)
{
  I_Printf("OpenGL: Initialising...\n");

  RGL_SoftInit();
  RGL_CheckExtensions();

  // read implementation limits
  glGetIntegerv(GL_MAX_LIGHTS,       &amp;glmax_lights);
  glGetIntegerv(GL_MAX_CLIP_PLANES,  &amp;glmax_clip_planes);
  glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;glmax_tex_size);

  I_Printf("OpenGL: Lights: %d  Clippers: %d  Max_tex: %d\n",
      glmax_lights, glmax_clip_planes, glmax_tex_size);
  
  R2_InitUtil();

  // initialise unit system
  RGL_InitUnits();

  RGL_SetupMatrices2D();

  // setup video context

  vctx.double_buffered = true;

  vctx.NewScreenSize = RGL_NewScreenSize;
  vctx.RenderScene = RGL_RenderScene;
  vctx.BeginDraw = RGL_BeginDraw;
  vctx.EndDraw = RGL_EndDraw;
  vctx.DrawImage = RGL_DrawImage;
  vctx.SolidBox = RGL_SolidBox;
  vctx.SolidLine = RGL_SolidLine;
  vctx.ReadScreen = RGL_ReadScreen;
}
</t>
<t tx="T1204">@ignore
@language c

// OpenGL Rendering (Skies)

// this conditional applies to the whole file
#ifdef USE_GL

&lt;&lt; rgl_sky #includes &gt;&gt;
@others

#endif  // USE_GL
</t>
<t tx="T1205">#include "i_defs.h"

#include "am_map.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "e_search.h"
#include "m_bbox.h"
#include "m_random.h"
#include "p_local.h"
#include "p_mobj.h"
#include "r_defs.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_sky.h"
#include "r_state.h"
#include "r_things.h"
#include "r2_defs.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "v_res.h"
#include "w_textur.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1206">

#define DEBUG  0


#define RGB_RED(rgbcol)  ((float_t)((rgbcol &gt;&gt; 16) &amp; 0xFF) / 255.0)
#define RGB_GRN(rgbcol)  ((float_t)((rgbcol &gt;&gt;  8) &amp; 0xFF) / 255.0)
#define RGB_BLU(rgbcol)  ((float_t)((rgbcol      ) &amp; 0xFF) / 255.0)


#if 0  // TEMPORARILY DISABLED

static INLINE void DrawSkyTilePoint(const tilesky_info_t *info,
    const image_t *image, int p, int xmul, int ymul, int zmul, 
    float_t dx, float_t dy)
{
  float_t x = tilepoints[p].x * xmul;
  float_t y = tilepoints[p].y * ymul;
  float_t z = tilepoints[p].z * zmul;

  float_t tx = (zmul &gt; 0) ? tilepoints[p].tx : tilepoints[p].bx;
  float_t ty = (zmul &gt; 0) ? tilepoints[p].ty : tilepoints[p].by;

  if (xmul &lt; 0)
  {
    float_t tmp = tx; tx = 1 - ty; ty = 1 - tmp;
  }
  
  if (ymul &lt; 0)
  {
    float_t tmp = tx; tx = ty; ty = tmp;
  }
  
  CHECKVAL(info-&gt;number);
  CHECKVAL(info-&gt;squish);

  glTexCoord2f(tx * info-&gt;number + dx, ty * info-&gt;number + dy);
  glVertex3f(y * 1000, x * 1000, (z + info-&gt;offset) * 1000 / 
      info-&gt;squish);
}
</t>
<t tx="T1207">    
static void DrawSkyTilePart(const tilesky_info_t *info,
    const image_t *image, int xmul, int ymul, int zmul, 
    float_t dx, float_t dy)
{
  int s;
  int len, top, bot;

  for (s=0; tilestrips[s].len &gt; 0; s++)
  {
    glBegin(GL_TRIANGLE_STRIP);

    len = tilestrips[s].len;
    top = tilestrips[s].top;
    bot = tilestrips[s].bottom;

    for (; len &gt; 0; len--, top++, bot++)
    {
      DrawSkyTilePoint(info, image, top, xmul, ymul, zmul, dx, dy);
      DrawSkyTilePoint(info, image, bot, xmul, ymul, zmul, dx, dy);
    }

    DrawSkyTilePoint(info, image, top, xmul, ymul, zmul, dx, dy);
    
    glEnd();
  }
}
</t>
<t tx="T1208">
static void RGL_DrawTiledSky(void)
{
  int i;
  const image_t *image;
  const cached_image_t *cim;
  const tilesky_info_t *info;

  side_t *side;
  float_t trans;
  float_t dx, dy;

  RGL_SetupMatricesTiledSky();

  for (i=0; i &lt; MAX_TILESKY; i++)
  {
    if (! sky_tiles[i].active)
      continue;

    info = sky_tiles[i].info;
    side = sky_tiles[i].line-&gt;side[0];
    trans = side-&gt;middle.translucency;
    dx = side-&gt;middle.x_offset * info-&gt;number / 1024.0;
    dy = side-&gt;middle.y_offset * info-&gt;number / 1024.0;

    if (info-&gt;type == TILESKY_Flat)
      image = sky_tiles[i].line-&gt;frontsector-&gt;floor.image;
    else
      image = side-&gt;middle.image;

    if (!image || trans &lt; 0.01)
      continue;

    glEnable(GL_TEXTURE_2D);

    cim = W_ImageCache(image, IMG_OGL, 0, true);
    glBindTexture(GL_TEXTURE_2D, W_ImageGetOGL(cim));

    if (trans &lt;= 0.99 || !image-&gt;solid)
      glEnable(GL_BLEND);

    // sky is always 100% bright
    glColor4f(1.0, 1.0, 1.0, trans);

    DrawSkyTilePart(info, image,  1,  1,  1, dx, dy);
    DrawSkyTilePart(info, image, -1,  1,  1, dx, dy);
    DrawSkyTilePart(info, image, -1, -1,  1, dx, dy);
    DrawSkyTilePart(info, image,  1, -1,  1, dx, dy);

    DrawSkyTilePart(info, image,  1,  1, -1, dx, dy);
    DrawSkyTilePart(info, image, -1,  1, -1, dx, dy);
    DrawSkyTilePart(info, image, -1, -1, -1, dx, dy);
    DrawSkyTilePart(info, image,  1, -1, -1, dx, dy);

    W_ImageDone(cim);
    
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_BLEND);
  }
}
</t>
<t tx="T1209">@ RGL_DrawSky
@c

void RGL_DrawSky(void)
{
  int x, y, w, h;
  float_t right, bottom;

  const cached_image_t *cim;
  GLuint tex_id;

  float_t mlook_rad;
  int top_L, bottom_L;
  int base_a = viewangle &gt;&gt; 6;

  int sx1, sy1, sx2, sy2;  // screen coords
  float_t tx1, tx2, ty, bx1, bx2, by;  // tex coords

  if (! draw_sky)
    return;

  // reset draw-sky flag
  draw_sky = false;
 
  if (sky_tiles_active &gt; 0)
  {
    RGL_DrawTiledSky();
    return;
  }
  
  DEV_ASSERT2(sky_image);
  cim = W_ImageCache(sky_image, IMG_OGL, 0, true);
  tex_id = W_ImageGetOGL(cim);

  glEnable(GL_TEXTURE_2D);
  glBindTexture(GL_TEXTURE_2D, tex_id);

  w = sky_image-&gt;actual_w;
  h = sky_image-&gt;actual_h;
  right  = w / (float_t)sky_image-&gt;total_w;
  bottom = h / (float_t)sky_image-&gt;total_h;

  // sky is always 100% bright
  glColor4f(1.0, 1.0, 1.0, 1.0);

  sx1 = viewwindowx;
  sx2 = viewwindowx + viewwindowwidth;

  sy1 = viewwindowy;
  sy2 = viewwindowy + viewwindowheight;

  // compute sky horizontally tex coords
  mlook_rad = atan(viewvertangle);

  if (mlook_rad &gt;= M_PI/4)
    top_L = ANG90;
  else if (mlook_rad &lt;= -M_PI/4)
    top_L = ANG45;
  else
  {
    // d is just the distance horizontally forward from the eye to
    // the top edge of the view rectangle.
    float_t d = M_ROOT2 * sin(M_PI/2 - (mlook_rad + M_PI/4));

    top_L = ANG90 - M_ATan(d);
  }

  if (mlook_rad &lt;= -M_PI/4)
    bottom_L = ANG90;
  else if (mlook_rad &gt;= M_PI/4)
    bottom_L = ANG45;
  else
  {
    // d is just the distance horizontally forward from the eye to
    // the bottom edge of the view rectangle.
    float_t d = M_ROOT2 * sin(M_PI/2 - (M_PI/4 - mlook_rad));

    bottom_L = ANG90 - M_ATan(d);
  }

  if (! level_flags.stretchsky)
  {
    top_L = bottom_L = ANG90;
  }
  
  #define NEWSKYSHIFT  ((float_t)(1 &lt;&lt; (ANGLEBITS - 16)))

  top_L &gt;&gt;= 6;
  bottom_L &gt;&gt;= 6;

  base_a *= 2;

  CHECKVAL(w);
  tx1 = (float_t)(base_a + top_L) / NEWSKYSHIFT / (float_t)w;
  tx2 = (float_t)(base_a - top_L) / NEWSKYSHIFT / (float_t)w;

  bx1 = (float_t)(base_a + bottom_L) / NEWSKYSHIFT / (float_t)w;
  bx2 = (float_t)(base_a - bottom_L) / NEWSKYSHIFT / (float_t)w;

  if (w &lt;= 512)
  {
    tx1 /= 2.0; tx2 /= 2.0;
    bx1 /= 2.0; bx2 /= 2.0;
  }

  // compute sky vertical tex coords
  {
    float_t top_a    = (M_PI/2 - mlook_rad - M_PI/4) / M_PI;
    float_t bottom_a = (M_PI/2 - mlook_rad + M_PI/4) / M_PI;
    
    if (top_a &lt; 0)
      top_a = 0;

    if (bottom_a &gt; 1.0)
      bottom_a = 1.0;
    
    DEV_ASSERT2(bottom_a &gt; top_a);

    ty = top_a * bottom;
    by = bottom_a * bottom;
  }

  glBegin(GL_QUADS);
  
  // divide screen into many squares, to reduce distortion
  for (y=0; y &lt; 8; y++)
  for (x=0; x &lt; 8; x++)
  {
    int xa = sx1 + (sx2 - sx1) * x     / 8;
    int xb = sx1 + (sx2 - sx1) * (x+1) / 8;

    int ya = sy1 + (sy2 - sy1) * y     / 8;
    int yb = sy1 + (sy2 - sy1) * (y+1) / 8;
    
    float_t la = tx1 + (bx1 - tx1) * y     / 8;
    float_t ra = tx2 + (bx2 - tx2) * y     / 8;
    float_t lb = tx1 + (bx1 - tx1) * (y+1) / 8;
    float_t rb = tx2 + (bx2 - tx2) * (y+1) / 8;

    float_t txa = la + (ra - la) * x     / 8;
    float_t bxa = lb + (rb - lb) * x     / 8;
    float_t txb = la + (ra - la) * (x+1) / 8;
    float_t bxb = lb + (rb - lb) * (x+1) / 8;
    
    float_t tya = ty + (by - ty) * y     / 8;
    float_t bya = ty + (by - ty) * (y+1) / 8;
    
    glTexCoord2f(txa, 1.0 - bottom * tya);
    glVertex2i(xa, SCREENHEIGHT - ya);
    
    glTexCoord2f(txb, 1.0 - bottom * tya);
    glVertex2i(xb, SCREENHEIGHT - ya);
    
    glTexCoord2f(bxb, 1.0 - bottom * bya);
    glVertex2i(xb, SCREENHEIGHT - yb);
    
    glTexCoord2f(bxa, 1.0 - bottom * bya);
    glVertex2i(xa, SCREENHEIGHT - yb);
  }

  glEnd();
  
  glDisable(GL_TEXTURE_2D);

  W_ImageDone(cim);
}
</t>
<t tx="T1210">
#endif  // TEMPORARILY DISABLED


static INLINE void CalcSkyTexCoord(float_t x, float_t y, float_t z, 
    float_t *tx, float_t *ty)
{
  float_t dist;
  float_t tile_num = 1;
  float_t base_val, angle_val;

  angle_t angle;
  
  x -= viewx;
  y -= viewy;
  z -= viewz;

  // OPTIMISE
  dist = sqrt(x*x + y*y + z*z);

  if (dist &lt; 1) 
    dist = 1;

  x /= dist;
  y /= dist;
  z /= dist;

  angle = viewangle - R_PointToAngle(0, 0, x, y);

  base_val = ANG_2_FLOAT(viewangle);

  if (angle &lt; ANG180)
    angle_val = ANG_2_FLOAT(angle);
  else
    angle_val = ANG_2_FLOAT(angle) - 360.0;

  (*tx) = tile_num * (base_val - angle_val) /
    (sky_image-&gt;actual_w &gt; 256 ? 360.0 : 180.0);
  (*ty) = tile_num * ((1 + z) / 2);  /// * IM_BOTTOM(sky_image);
  return;
 
#if 0  // EXPERIMENTAL
  dist = sqrt(x*x + z*z);

  if (dist &gt; 0.01)
  {
    x /= dist;
    z /= dist;
  }
  
  x = (1 + x) / 2;
  z = (1 + z) / 2;

  if (0)  // sky_image-&gt;actual_w &gt; 256)
  {
    x /= 2;

    if (y &lt; 0)
      x = 1.0 - x;
  }
  else
  {
    if (y &lt; 0)
      x = -x;
  }

  (*tx) = x;
  (*ty) = z * IM_BOTTOM(sky_image);
#endif
}
</t>
<t tx="T1211">
typedef struct sky_data_s
{
  vec3_t normal;
}
sky_data_t;

void SkyPolyCoordFunc(vec3_t *src, local_gl_vert_t *vert, void *d)
{
  sky_data_t *data = (sky_data_t *)d;

  float_t tx, ty;

  CalcSkyTexCoord(src-&gt;x, src-&gt;y, src-&gt;z, &amp;tx, &amp;ty);
 
  SET_COLOR(1.0, 1.0, 1.0, 1.0);
  SET_TEXCOORD(tx, ty);
  SET_NORMAL(data-&gt;normal.x, data-&gt;normal.y, data-&gt;normal.z);
  SET_EDGE_FLAG(GL_TRUE);
  SET_VERTEX(src-&gt;x, src-&gt;y, src-&gt;z);
}
</t>
<t tx="T1212">@ RGL_DrawSkyPlane
@c

void RGL_DrawSkyPlane(subsector_t *sub, float_t h)
{
  raw_polyquad_t *poly;
  sky_data_t data;

  seg_t *seg;

  GLuint tex_id;
  const cached_image_t *cim;

  int num_vert, i;

  // count number of actual vertices
  for (seg=sub-&gt;segs, num_vert=0; seg; seg=seg-&gt;sub_next, num_vert++)
  { /* nothing here */ }
    
  if (num_vert &gt; MAX_PLVERT)
    num_vert = MAX_PLVERT;
  
  DEV_ASSERT2(sky_image);
  cim = W_ImageCache(sky_image, IMG_OGL, 0, true);
  tex_id = W_ImageGetOGL(cim);
  
  // normally this is wrong -- W_LockImagesOGL saves us though.
  W_ImageDone(cim);
  
  data.normal.x = 0;
  data.normal.y = 0;
  data.normal.z = (viewz &gt; h) ? 1.0 : -1.0;

  // create PolyQuad and transfer vertices
  
  poly = RGL_NewPolyQuad(num_vert, false);

  for (seg=sub-&gt;segs, i=0; seg &amp;&amp; (i &lt; MAX_PLVERT); 
       seg=seg-&gt;sub_next, i++)
  {
    PQ_ADD_VERT(poly, seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y, h);
  }

  RGL_BoundPolyQuad(poly);
  RGL_SplitPolyQuadLOD(poly, 1, 128 &gt;&gt; detail_level);
  
  RGL_RenderPolyQuad(poly, &amp;data, &amp;SkyPolyCoordFunc, tex_id, 
      false, false);
 
  RGL_FreePolyQuad(poly);
}
</t>
<t tx="T1213">@ RGL_DrawSkyWall
@c

void RGL_DrawSkyWall(seg_t *seg, float_t h1, float_t h2)
{
  float_t x1 = seg-&gt;v1-&gt;x;
  float_t y1 = seg-&gt;v1-&gt;y;
  float_t x2 = seg-&gt;v2-&gt;x;
  float_t y2 = seg-&gt;v2-&gt;y;

  GLuint tex_id;
  const cached_image_t *cim;

  sky_data_t data;
  raw_polyquad_t *poly;
  
  poly = RGL_NewPolyQuad(4, true);

  PQ_ADD_VERT(poly, x1, y1, h1);
  PQ_ADD_VERT(poly, x1, y1, h2);
  PQ_ADD_VERT(poly, x2, y2, h1);
  PQ_ADD_VERT(poly, x2, y2, h2);

  // get texture id for sky
  DEV_ASSERT2(sky_image);
  cim = W_ImageCache(sky_image, IMG_OGL, 0, true);
  tex_id = W_ImageGetOGL(cim);

  // normally this is wrong -- W_LockImagesOGL saves us though.
  W_ImageDone(cim);
  
  data.normal.x = y2 - y1;
  data.normal.y = x1 - x2;
  data.normal.z = 0;

  RGL_BoundPolyQuad(poly);
  RGL_SplitPolyQuadLOD(poly, 1, 128 &gt;&gt; detail_level);
  
  RGL_RenderPolyQuad(poly, &amp;data, &amp;SkyPolyCoordFunc, tex_id, 
      false, false);
 
  RGL_FreePolyQuad(poly);
}
</t>
<t tx="T1214">@ignore
@language c

// OpenGL Rendering (Textures)

// this conditional applies to the whole file
#ifdef USE_GL

&lt;&lt; rgl_tex #includes &gt;&gt;

/* NOTE: texture handling now done by image system */

#endif  // USE_GL
</t>
<t tx="T1215">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "e_search.h"
#include "m_bbox.h"
#include "m_random.h"
#include "p_local.h"
#include "p_mobj.h"
#include "r_defs.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_sky.h"
#include "r_state.h"
#include "r_things.h"
#include "r2_defs.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "v_res.h"
#include "w_textur.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1216">@ignore
@language c

// OpenGL Rendering (Unit batching)

// -AJA- 2000/10/09: Began work on this new unit system.

// this conditional applies to the whole file
#ifdef USE_GL

&lt;&lt; rgl_unit #includes &gt;&gt;
&lt;&lt; rgl_unit declarations &gt;&gt;
@others

#endif  // USE_GL
</t>
<t tx="T1217">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "e_search.h"
#include "m_bbox.h"
#include "m_random.h"
#include "p_local.h"
#include "p_mobj.h"
#include "r_defs.h"
#include "r_main.h"
#include "r_plane.h"
#include "r_sky.h"
#include "r_state.h"
#include "r_things.h"
#include "r2_defs.h"
#include "rgl_defs.h"
#include "v_colour.h"
#include "v_res.h"
#include "w_textur.h"
#include "w_wad.h"
#include "v_ctx.h"
#include "z_zone.h"
</t>
<t tx="T1218">

#define DEBUG  0


#define MAX_L_VERT  4096
#define MAX_L_UNIT  (MAX_L_VERT / 4)

// a single unit (polygon, quad, etc) to pass to the GL
typedef struct local_gl_unit_s
{
  // unit mode (e.g. GL_POLYGON)
  GLuint mode;

  // range of local vertices
  int first, count;
  
  // texture used
  GLuint tex_id;

  // texture contains see-through parts (i.e. significant areas where
  // alpha = 0, like sprites).
  boolean_t masked;

  // texture/vertices should be alpha blended (e.g. translucent
  // water).
  boolean_t blended;
}
local_gl_unit_t;

static local_gl_vert_t local_verts[MAX_L_VERT];
static local_gl_unit_t local_units[MAX_L_UNIT];

static GLuint local_unit_map[MAX_L_UNIT];

static int cur_vert;
static int cur_unit;

static boolean_t solid_mode;
</t>
<t tx="T1219">@ RGL_InitUnits

Initialise the unit system. Once-only call.
@c

void RGL_InitUnits(void)
{
  // GL client state stuff disabled, due to problems with certain
  // drivers (in particular, Voodoo3 under Win32).
#if 0
  // setup pointers to client state
  glVertexPointer(3, GL_FLOAT, sizeof(local_gl_vert_t), &amp;local_verts[0].x);
  glColorPointer (4, GL_FLOAT, sizeof(local_gl_vert_t), &amp;local_verts[0].r);
  glTexCoordPointer(2, GL_FLOAT, sizeof(local_gl_vert_t), &amp;local_verts[0].t_x);
  glNormalPointer(GL_FLOAT, sizeof(local_gl_vert_t), &amp;local_verts[0].n_x);
  glEdgeFlagPointer(sizeof(local_gl_vert_t), &amp;local_verts[0].edge);

  glEnableClientState(GL_EDGE_FLAG_ARRAY);
  glEnableClientState(GL_VERTEX_ARRAY);
  glEnableClientState(GL_COLOR_ARRAY);
  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
  glEnableClientState(GL_NORMAL_ARRAY);
#endif
}
</t>
<t tx="T1220">@ RGL_StartUnits

Starts a fresh batch of units. There should be two batches of
units, the first with solid == true (handling all solid
walls/floors), and the second with solid == false (handling
everything else: sprites, masked textures, translucent planes).

The solid batch will be sorted to keep texture changes to a
minimum. The non-solid batch is drawn in-order (and should be
processed from furthest to closest).
@c

void RGL_StartUnits(boolean_t solid)
{
  cur_vert = cur_unit = 0;
  solid_mode = solid;
}
</t>
<t tx="T1221">@ RGL_FinishUnits

Finishes a batch of units, drawing any that haven't been drawn yet.
@c

void RGL_FinishUnits(void)
{
  RGL_DrawUnits();
}
</t>
<t tx="T1222">@ RGL_BeginUnit

Begin a new unit, with the given parameters (mode and texture ID).
`max_vert' is the maximum expected vertices of the quad/poly (the
actual number can be less, but never more). Returns a pointer to
the first vertex structure. `masked' should be true if the texture
contains "holes" (like sprites). `blended' should be true if the
texture should be blended (like for translucent water or sprites).
@c

local_gl_vert_t *RGL_BeginUnit(GLuint mode, int max_vert,
    GLuint tex_id, boolean_t masked, boolean_t blended)
{
  local_gl_unit_t *unit;
  
  DEV_ASSERT2(max_vert &gt; 0);
  DEV_ASSERT2(tex_id != 0);

  // check for out-of-space
  if (cur_vert + max_vert &gt; MAX_L_VERT || cur_unit &gt;= MAX_L_UNIT)
  {
    RGL_DrawUnits();
  }

  unit = local_units + cur_unit;

  unit-&gt;mode    = mode;
  unit-&gt;tex_id  = tex_id;
  unit-&gt;first   = cur_vert;  // count set later
  unit-&gt;masked  = masked;
  unit-&gt;blended = blended;

  return local_verts + cur_vert;
}
</t>
<t tx="T1223">@ RGL_EndUnit
@c

void RGL_EndUnit(int actual_vert)
{
  local_gl_unit_t *unit;

  DEV_ASSERT2(actual_vert &gt; 0);

  unit = local_units + cur_unit;

  unit-&gt;count = actual_vert;

  cur_vert += actual_vert;
  cur_unit++;
  
  DEV_ASSERT2(cur_vert &lt;= MAX_L_VERT);
  DEV_ASSERT2(cur_unit &lt;= MAX_L_UNIT);
}
</t>
<t tx="T1224">@ RGL_DrawUnits

Forces the set of current units to be drawn. This call is
optional (it never _needs_ to be called by client code).
@c

void RGL_DrawUnits(void)
{
  int i, j;
  GLuint cur_tex = 0xABE74C74;
  GLfloat d_col[4] = { 1.0, 1.0, 1.0, 1.0 };

  boolean_t cur_masking  = false;
  boolean_t cur_blending = false;

  if (cur_unit == 0)
    return;
   
  for (i=0; i &lt; cur_unit; i++)
    local_unit_map[i] = i;

  // need to sort ?
  if (solid_mode)
  {
    #define CMP(a,b)  \
        (local_units[a].tex_id &lt; local_units[b].tex_id ||        \
         (local_units[a].tex_id == local_units[b].tex_id &amp;&amp;      \
          (local_units[a].blended &lt; local_units[b].blended ||    \
           (local_units[a].blended == local_units[b].blended &amp;&amp;  \
            local_units[a].masked &lt; local_units[b].masked))))
    QSORT(GLuint, local_unit_map, cur_unit, CUTOFF);
    #undef CMP
  }

  glEnable(GL_TEXTURE_2D);
  glDisable(GL_ALPHA_TEST);
  glDisable(GL_BLEND);

  for (i=0; i &lt; cur_unit; i++)
  {
    local_gl_unit_t *unit = local_units + local_unit_map[i];
    
    DEV_ASSERT2(unit-&gt;count &gt; 0);
    DEV_ASSERT2(unit-&gt;tex_id != 0);

    // detect changes in texture/alpha/blending and change state
    
    if (cur_masking != unit-&gt;masked)
    {
      cur_masking = unit-&gt;masked;

      if (cur_masking)
        glEnable(GL_ALPHA_TEST);
      else
        glDisable(GL_ALPHA_TEST);
    }

    if (cur_blending != unit-&gt;blended)
    {
      cur_blending = unit-&gt;blended;

      if (cur_blending)
        glEnable(GL_BLEND);
      else 
        glDisable(GL_BLEND);
    }

    if (cur_tex != unit-&gt;tex_id)
    {
      cur_tex = unit-&gt;tex_id;
      glBindTexture(GL_TEXTURE_2D, cur_tex);
    }

    // set alpha from first vertex (we never interpolate it)
    d_col[3] = local_verts[unit-&gt;first].col[3];

    glBegin(unit-&gt;mode);
 
    for (j=0; j &lt; unit-&gt;count; j++)
    {
      local_gl_vert_t *V = local_verts + unit-&gt;first + j;

      glTexCoord2f(V-&gt;t_x, V-&gt;t_y);
      glNormal3f(V-&gt;n_x, V-&gt;n_y, V-&gt;n_z);
      glEdgeFlag(V-&gt;edge);
      glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, V-&gt;col);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, d_col);

      // vertex must be last
      glVertex3f(V-&gt;x, V-&gt;y, V-&gt;z);
    }

    glEnd();
  }

  // all done
  cur_vert = cur_unit = 0;

  glDisable(GL_TEXTURE_2D);
  glDisable(GL_ALPHA_TEST);
  glDisable(GL_BLEND);
}
</t>
<t tx="T1225">@ ----------------------------------------------------------------------------

SPECIAL 1D OCCLUSION BUFFER
@c

#define ONED_POWER  12  // 4096 angles
#define ONED_SIZE   (1 &lt;&lt; ONED_POWER)

// 1 bit per angle, packed into 32 bit values.
// (NOTE: for speed reasons, 1 is "clear", and 0 is "blocked")
//
static unsigned long oned_oculus_buffer[ONED_SIZE / 32];

// -AJA- these values could be computed (rather than looked-up)
// without too much trouble.  For now I want to get the logic correct.
//
static unsigned long oned_low_masks[32] =
{
  0xFFFFFFFF, 0x7FFFFFFF, 0x3FFFFFFF, 0x1FFFFFFF,
  0x0FFFFFFF, 0x07FFFFFF, 0x03FFFFFF, 0x01FFFFFF,
  0x00FFFFFF, 0x007FFFFF, 0x003FFFFF, 0x001FFFFF,
  0x000FFFFF, 0x0007FFFF, 0x0003FFFF, 0x0001FFFF,
  0x0000FFFF, 0x00007FFF, 0x00003FFF, 0x00001FFF,
  0x00000FFF, 0x000007FF, 0x000003FF, 0x000001FF,
  0x000000FF, 0x0000007F, 0x0000003F, 0x0000001F,
  0x0000000F, 0x00000007, 0x00000003, 0x00000001
};

static unsigned long oned_high_masks[32] =
{
  0x80000000, 0xC0000000, 0xE0000000, 0xF0000000,
  0xF8000000, 0xFC000000, 0xFE000000, 0xFF000000,
  0xFF800000, 0xFFC00000, 0xFFE00000, 0xFFF00000,
  0xFFF80000, 0xFFFC0000, 0xFFFE0000, 0xFFFF0000,
  0xFFFF8000, 0xFFFFC000, 0xFFFFE000, 0xFFFFF000,
  0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00, 0xFFFFFF00,
  0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0, 0xFFFFFFF0,
  0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE, 0xFFFFFFFF
};

#define LOW_MASK(L)   oned_low_masks[L]
#define HIGH_MASK(H)  oned_high_masks[H]


//
// RGL_1DOcclusionClear
//
// Clear all angles in the given range.  (Clear means open, i.e. not
// blocked).  The angles are relative to the VIEW angle, and must lie
// in the range -90 to +90 degrees (inclusive).
//
void RGL_1DOcclusionClear(angle_t low, angle_t high)
{
  unsigned int low_b, high_b;

  low  += ANG90;
  high += ANG90;

  DEV_ASSERT2(low  &lt;= ANG180);
  DEV_ASSERT2(high &lt;= ANG180);
  DEV_ASSERT2(low  &lt;= high);

  if (low  == ANG180) low--;
  if (high == ANG180) high--;

  low  &gt;&gt;= (ANGLEBITS - ONED_POWER);
  high &gt;&gt;= (ANGLEBITS - ONED_POWER);

  low_b  = low  &amp; 0x1F;  low  &gt;&gt;= 5; 
  high_b = high &amp; 0x1F;  high &gt;&gt;= 5; 

  if (low == high)
  {
    oned_oculus_buffer[low] |= (LOW_MASK(low_b) &amp; HIGH_MASK(high_b));
  }
  else
  {
    oned_oculus_buffer[low]  |= LOW_MASK(low_b);
    oned_oculus_buffer[high] |= HIGH_MASK(high_b);

    for (low++; low &lt; high; low++)
      oned_oculus_buffer[low] = 0xFFFFFFFF;
  }
}
</t>
<t tx="T1226">@ RGL_1DOcclusionSet

Set all angles in the given range, i.e. mark them as blocking. The
angles are relative to the VIEW angle, and must lie in the range
-90 to +90 degrees (inclusive).
@c

void RGL_1DOcclusionSet(angle_t low, angle_t high)
{
  unsigned int low_b, high_b;

  low  += ANG90;
  high += ANG90;

  DEV_ASSERT2(low  &lt;= ANG180);
  DEV_ASSERT2(high &lt;= ANG180);
  DEV_ASSERT2(low  &lt;= high);

  if (low  == ANG180) low--;
  if (high == ANG180) high--;

  low  &gt;&gt;= (ANGLEBITS - ONED_POWER);
  high &gt;&gt;= (ANGLEBITS - ONED_POWER);

  low_b  = low  &amp; 0x1F;  low  &gt;&gt;= 5; 
  high_b = high &amp; 0x1F;  high &gt;&gt;= 5; 

  if (low == high)
  {
    oned_oculus_buffer[low] &amp;= ~(LOW_MASK(low_b) &amp; HIGH_MASK(high_b));
  }
  else
  {
    oned_oculus_buffer[low]  &amp;= ~LOW_MASK(low_b);
    oned_oculus_buffer[high] &amp;= ~HIGH_MASK(high_b);

    for (low++; low &lt; high; low++)
      oned_oculus_buffer[low] = 0x00000000;
  }
}
</t>
<t tx="T1227">@ RGL_1DOcclusionTest

Check whether all angles in the given range are set (i.e. blocked).
Returns true if the entire range is blocked, false otherwise.
Angles are relative to the VIEW angle, and must lie in the range
-90 to +90 degrees (inclusive).
@c

boolean_t RGL_1DOcclusionTest(angle_t low, angle_t high)
{
  unsigned int low_b, high_b;

  low  += ANG90;
  high += ANG90;

  DEV_ASSERT2(low  &lt;= ANG180);
  DEV_ASSERT2(high &lt;= ANG180);
  DEV_ASSERT2(low  &lt;= high);

  if (low  == ANG180) low--;
  if (high == ANG180) high--;

  low  &gt;&gt;= (ANGLEBITS - ONED_POWER);
  high &gt;&gt;= (ANGLEBITS - ONED_POWER);

  // make the check a little wider, to be sure to be sure
  if (low &gt; 0) low--;
  if (high &lt; (ONED_SIZE-1)) high++;
 
  low_b  = low  &amp; 0x1F;  low  &gt;&gt;= 5; 
  high_b = high &amp; 0x1F;  high &gt;&gt;= 5; 

  if (low == high)
    return (oned_oculus_buffer[low] &amp; 
        LOW_MASK(low_b) &amp; HIGH_MASK(high_b)) ? false : true;

  if (oned_oculus_buffer[low] &amp; LOW_MASK(low_b))
    return false;
   
  if (oned_oculus_buffer[high] &amp; HIGH_MASK(high_b))
    return false;

  for (low++; low &lt; high; low++)
    if (oned_oculus_buffer[low])
      return false;

  return true;
}
</t>
<t tx="T1228">@ ----------------------------------------------------------------------------

RAW POLYQUAD CODE

Note: quads are always vertical rectangles, and currently the
bottom and top lines are always horizontal (i.e. never sloped).

Note 2: polygons are always horizontal.
@c

raw_polyquad_t *RGL_NewPolyQuad(int maxvert, boolean_t quad)
{
  raw_polyquad_t *poly;

  poly = Z_ClearNew(raw_polyquad_t, 1);

  poly-&gt;verts = Z_New(vec3_t, maxvert);
  poly-&gt;num_verts = 0;
  poly-&gt;max_verts = maxvert;

  poly-&gt;quad = quad;

  return poly;
}
</t>
<t tx="T1229">
void RGL_FreePolyQuad(raw_polyquad_t *poly)
{
  while (poly)
  {
    raw_polyquad_t *cur = poly;
    poly = poly-&gt;sisters;

    Z_Free(cur-&gt;verts);
    Z_Free(cur);
  }
}
</t>
<t tx="T1230">
void RGL_BoundPolyQuad(raw_polyquad_t *poly)
{
  int j;
  
  raw_polyquad_t *cur = poly;
///    poly = poly-&gt;sisters;

  DEV_ASSERT2(cur-&gt;num_verts &gt; 0);

  cur-&gt;min = cur-&gt;verts[0];
  cur-&gt;max = cur-&gt;verts[0];

  for (j=1; j &lt; cur-&gt;num_verts; j++)
  {
    vec3_t *src = cur-&gt;verts + j;

    if (src-&gt;x &lt; cur-&gt;min.x) cur-&gt;min.x = src-&gt;x;
    else if (src-&gt;x &gt; cur-&gt;max.x) cur-&gt;max.x = src-&gt;x;

    if (src-&gt;y &lt; cur-&gt;min.y) cur-&gt;min.y = src-&gt;y;
    else if (src-&gt;y &gt; cur-&gt;max.y) cur-&gt;max.y = src-&gt;y;

    if (src-&gt;z &lt; cur-&gt;min.z) cur-&gt;min.z = src-&gt;z;
    else if (src-&gt;z &gt; cur-&gt;max.z) cur-&gt;max.z = src-&gt;z;
  }
}
</t>
<t tx="T1231">
#ifdef DEVELOPERS
static void RGL_DumpPolyQuad(raw_polyquad_t *poly, boolean_t single)
{
  int j;

  L_WriteDebug("DUMP POLY %p quad=%d num=%d max=%d\n", poly, 
      poly-&gt;quad, poly-&gt;num_verts, poly-&gt;max_verts);

  while (poly)
  {
    raw_polyquad_t *cur = poly;
    poly = single ? NULL : poly-&gt;sisters;

    if (! single)
      L_WriteDebug("--CUR SISTER: %p\n", cur);

#if 0
    L_WriteDebug("  BBOX: (%1.0f,%1.0f,%1.0f) -&gt; (%1.0f,%1.0f,%1.0f)\n",
        cur-&gt;min.x, cur-&gt;min.y, cur-&gt;min.z, 
        cur-&gt;max.x, cur-&gt;max.y, cur-&gt;max.z);
#endif

    if (cur-&gt;quad)
    {
      for (j=0; j &lt; cur-&gt;num_verts; j += 2)
      {
        L_WriteDebug("  SIDE: (%1.0f,%1.0f,%1.0f) -&gt; (%1.0f,%1.0f,%1.0f)\n",
            cur-&gt;verts[j].x, cur-&gt;verts[j].y, cur-&gt;verts[j].z,
            cur-&gt;verts[j+1].x, cur-&gt;verts[j+1].y, cur-&gt;verts[j+1].z);
      }
    }
    else
    {
      for (j=0; j &lt; cur-&gt;num_verts; j += 1)
      {
        L_WriteDebug("  POINT: (%1.0f,%1.0f,%1.0f)\n",
            cur-&gt;verts[j].x, cur-&gt;verts[j].y, cur-&gt;verts[j].z);
      }
    }
  }

  L_WriteDebug("\n");
}
</t>
<t tx="T1232">#endif

static void RGL_DoSplitQuadVertSep(raw_polyquad_t *quad, int extras)
{
  int j;
  float_t h1, h2;
  float_t span_z;
  
  DEV_ASSERT2(extras &gt;= 1);

  // Note: doesn't handle already split quads (i.e. num_verts &gt; 4).
  DEV_ASSERT2(quad-&gt;num_verts == 4);
  
  // the original QUAD will end up being the top-most part, and we
  // create the newbies from the bottom upwards.  Hence final order is
  // top piece to bottom piece.
  //
  h1 = quad-&gt;min.z;
  span_z = quad-&gt;max.z - quad-&gt;min.z;

  for (j=0; j &lt; extras; j++, h1 = h2)
  {
    raw_polyquad_t *N = RGL_NewPolyQuad(4, true);
    N-&gt;num_verts = 4;

    Z_MoveData(N-&gt;verts, quad-&gt;verts, vec3_t, 4);

    h2 = quad-&gt;min.z + span_z * (j+1) / (float_t)(extras + 1);

    N-&gt;verts[0].z = h1;  N-&gt;verts[1].z = h2;
    N-&gt;verts[2].z = h1;  N-&gt;verts[3].z = h2;

    // link it in
    RGL_BoundPolyQuad(N);

    N-&gt;sisters = quad-&gt;sisters;
    quad-&gt;sisters = N;
  }

  quad-&gt;verts[0].z = h1;
  quad-&gt;verts[2].z = h1;

  RGL_BoundPolyQuad(quad);
}
</t>
<t tx="T1233">
static void RGL_DoSplitQuadHorizSep(raw_polyquad_t *quad, int extras)
{
  int j;
  vec2_t p1, p2;
  vec2_t span;
  
  DEV_ASSERT2(extras &gt;= 1);

  // Note: doesn't handle already split quads (i.e. num_verts &gt; 4).
  DEV_ASSERT2(quad-&gt;num_verts == 4);
  
  // the original QUAD will end up being the right-most part, and we
  // create the newbies from the left.  Hence final order is right
  // piece to left piece.
  //
  p1.x = quad-&gt;verts[0].x;
  p1.y = quad-&gt;verts[0].y;

  span.x = quad-&gt;verts[2].x - p1.x;
  span.y = quad-&gt;verts[2].y - p1.y;

  for (j=0; j &lt; extras; j++, p1 = p2)
  {
    raw_polyquad_t *N = RGL_NewPolyQuad(4, true);
    N-&gt;num_verts = 4;

    Z_MoveData(N-&gt;verts, quad-&gt;verts, vec3_t, 4);

    p2.x = quad-&gt;verts[0].x + span.x * (j+1) / (float_t)(extras + 1);
    p2.y = quad-&gt;verts[0].y + span.y * (j+1) / (float_t)(extras + 1);

    N-&gt;verts[0].x = p1.x;  N-&gt;verts[0].y = p1.y;
    N-&gt;verts[1].x = p1.x;  N-&gt;verts[1].y = p1.y;

    N-&gt;verts[2].x = p2.x;  N-&gt;verts[2].y = p2.y;
    N-&gt;verts[3].x = p2.x;  N-&gt;verts[3].y = p2.y;

    // link it in
    RGL_BoundPolyQuad(N);

    N-&gt;sisters = quad-&gt;sisters;
    quad-&gt;sisters = N;
  }

  quad-&gt;verts[0].x = p1.x; quad-&gt;verts[0].y = p1.y;
  quad-&gt;verts[1].x = p1.x; quad-&gt;verts[1].y = p1.y;

  RGL_BoundPolyQuad(quad);
}
</t>
<t tx="T1234">
static void RGL_DoSplitQuadHoriz(raw_polyquad_t *quad, int extras)
{
  int j;
  vec3_t p1, p2;
  vec2_t span;

  DEV_ASSERT2(extras &gt;= 1);

  // Note: doesn't handle already split quads (i.e. num_verts &gt; 4).
  DEV_ASSERT2(quad-&gt;num_verts == 4);

  p1 = quad-&gt;verts[0];
  p2 = quad-&gt;verts[3];

  // resize vertex array in the polyquad
  if (extras*2 + 4 &gt; quad-&gt;max_verts)
  {
    Z_Resize(quad-&gt;verts, vec3_t, extras*2 + 4);
    quad-&gt;max_verts = extras*2 + 4;
  }

  quad-&gt;num_verts = extras*2 + 4;

  quad-&gt;verts[0] = p1;
  quad-&gt;verts[1] = p1;
  quad-&gt;verts[1].z = p2.z;
  quad-&gt;verts[extras*2 + 2] = p2;
  quad-&gt;verts[extras*2 + 3] = p2;
  quad-&gt;verts[extras*2 + 2].z = p1.z;

  span.x = p2.x - p1.x;
  span.y = p2.y - p1.y;

  for (j=0; j &lt; extras; j++)
  {
    vec3_t *pair = quad-&gt;verts + (j+1) * 2;

    pair[0].x = p1.x + span.x * (j+1) / (float_t)(extras + 1);
    pair[0].y = p1.y + span.y * (j+1) / (float_t)(extras + 1);
    pair[0].z = p1.z;

    pair[1].x = pair[0].x;
    pair[1].y = pair[0].y;
    pair[1].z = p2.z;
  }

  // no need to recompute the bounds, they are still valid
}
</t>
<t tx="T1235">
static void RGL_DoSplitQuad(raw_polyquad_t *quad, int division,
    boolean_t separate)
{
  float_t span_xy, span_z;

  raw_polyquad_t *orig = quad;

  // first pass: split vertically
  for (quad = orig; quad; )
  {
    raw_polyquad_t *cur = quad;
    quad = quad-&gt;sisters;

    span_z = cur-&gt;max.z - cur-&gt;min.z;

    if (span_z &gt; division)
    {
      RGL_DoSplitQuadVertSep(cur, floor(span_z / division));
    }
  }

  // second pass: split horizontally
  for (quad = orig; quad; )
  {
    raw_polyquad_t *cur = quad;
    quad = quad-&gt;sisters;

    span_xy = MAX(cur-&gt;max.x - cur-&gt;min.x, cur-&gt;max.y - cur-&gt;min.y);

    if (span_xy &gt; division)
    {
      if (separate)
        RGL_DoSplitQuadHorizSep(cur, floor(span_xy / division));
      else
        RGL_DoSplitQuadHoriz(cur, floor(span_xy / division));
    }
  }
}
</t>
<t tx="T1236">@ ----------------------------------------------------------------------------
@c

static INLINE void AddPolyDynPoint(raw_polyquad_t *poly,
    float_t x, float_t y, float_t z)
{
  DEV_ASSERT2(poly);
  DEV_ASSERT2(poly-&gt;num_verts &lt;= poly-&gt;max_verts);
  
  if (poly-&gt;num_verts == poly-&gt;max_verts)
  {
    poly-&gt;max_verts += 8;
    Z_Resize(poly-&gt;verts, vec3_t, poly-&gt;max_verts);
  }

  DEV_ASSERT2(poly-&gt;num_verts &lt; poly-&gt;max_verts);
  
  PQ_ADD_VERT(poly, x, y ,z);
}
</t>
<t tx="T1237">
static INLINE void AddPolyVertIntercept(raw_polyquad_t *poly,
    vec3_t *P, vec3_t *S, float_t y)
{
  float_t frac;

  DEV_ASSERT2(P-&gt;y != S-&gt;y);
  DEV_ASSERT2(MIN(P-&gt;y, S-&gt;y)-1 &lt;= y &amp;&amp; y &lt;= MAX(P-&gt;y, S-&gt;y)+1);
  
  frac = (y - P-&gt;y) / (S-&gt;y - P-&gt;y);

  AddPolyDynPoint(poly, P-&gt;x + (S-&gt;x - P-&gt;x) * frac, y,
      P-&gt;z + (S-&gt;z - P-&gt;z) * frac);
}
</t>
<t tx="T1238">
static INLINE void AddPolyHorizIntercept(raw_polyquad_t *poly,
    vec3_t *P, vec3_t *S, float_t x)
{
  float_t frac;

  DEV_ASSERT2(P-&gt;x != S-&gt;x);
  DEV_ASSERT2(MIN(P-&gt;x, S-&gt;x)-1 &lt;= x &amp;&amp; x &lt;= MAX(P-&gt;x, S-&gt;x)+1);
  
  frac = (x - P-&gt;x) / (S-&gt;x - P-&gt;x);

  AddPolyDynPoint(poly, x, P-&gt;y + (S-&gt;y - P-&gt;y) * frac,
      P-&gt;z + (S-&gt;z - P-&gt;z) * frac);
}
</t>
<t tx="T1239">@ RGL_DoSplitPolyVert

ALGORITHM:

(a) Traverse the points of the polygon in normal (clockwise)
order. Let P be the current point, and S be the successor
point (or the first point if P is the last).

(b) Add point P to new polygon.

(c) If P is lower than S, traverse the set of extra lines
upwards. If P is higher than S, traverse the set of extra
lines downwards. If P same height as S, do nothing (continue
main loop).

(d) Check each extra line (height Y) for intercept, and if it
does intercept P-&gt;S then add the new point to the new
polygon. Ignore exact matches (P.y == Y or S.y == Y).
@c

static void RGL_DoSplitPolyVert(raw_polyquad_t *poly, int extras)
{
  int j, k;
  float_t y;
  float_t span_y = poly-&gt;max.y - poly-&gt;min.y;
  float_t min_y = poly-&gt;min.y;

  vec3_t *orig_verts;
  int orig_num;

  int start, end, step;
    
  // copy original vertices
  orig_num = poly-&gt;num_verts;
  DEV_ASSERT2(orig_num &gt;= 3);
  
  orig_verts = Z_New(vec3_t, orig_num);
  Z_MoveData(orig_verts, poly-&gt;verts, vec3_t, orig_num);
  
  // clear current polygon
  poly-&gt;num_verts = 0;

  for (k=0; k &lt; orig_num; k++)
  {
    vec3_t P, S;
    boolean_t down;

    P = orig_verts[k];
    S = orig_verts[(k+1) % orig_num];

    down = (P.y &gt; S.y);

    // always add current point
    AddPolyDynPoint(poly, P.x, P.y, P.z);

    // handle same Y coords
    if (fabs(P.y - S.y) &lt; 0.01)
      continue;

    if (down)
      start = extras-1, end = -1, step = -1;
    else
      start = 0, end = extras, step = +1;
        
    for (j=start; j != end; j += step)
    {
      y = min_y + span_y * (j+1) / (float_t)(extras+1);

      // no intercept ?
      if (y &lt;= (down ? S.y : P.y) + 0.01 || 
          y &gt;= (down ? P.y : S.y) - 0.01)
        continue;

      AddPolyVertIntercept(poly, &amp;P, &amp;S, y);
    }
  }

  // no need to recompute bbox -- still valid

  Z_Free(orig_verts);
}
</t>
<t tx="T1240">
static void RGL_DoSplitPolyHoriz(raw_polyquad_t *poly, int extras)
{
  int j, k;
  float_t x;
  float_t span_x= poly-&gt;max.x - poly-&gt;min.x;
  float_t min_x= poly-&gt;min.x;

  vec3_t *orig_verts;
  int orig_num;

  int start, end, step;
    
  // copy original vertices
  orig_num = poly-&gt;num_verts;
  DEV_ASSERT2(orig_num &gt;= 3);
  
  orig_verts = Z_New(vec3_t, orig_num);
  Z_MoveData(orig_verts, poly-&gt;verts, vec3_t, orig_num);
  
  // clear current polygon
  poly-&gt;num_verts = 0;

  for (k=0; k &lt; orig_num; k++)
  {
    vec3_t P, S;
    boolean_t left;

    P = orig_verts[k];
    S = orig_verts[(k+1) % orig_num];

    left = (P.x &gt; S.x);

    // always add current point
    AddPolyDynPoint(poly, P.x, P.y, P.z);

    // handle same X coords
    if (fabs(P.x - S.x) &lt; 0.01)
      continue;

    if (left)
      start = extras-1, end = -1, step = -1;
    else
      start = 0, end = extras, step = +1;
        
    for (j=start; j != end; j += step)
    {
      x = min_x + span_x * (j+1) / (float_t)(extras+1);

      // no intercept ?
      if (x &lt;= (left ? S.x : P.x) + 0.01 || 
          x &gt;= (left ? P.x : S.x) - 0.01)
        continue;

      AddPolyHorizIntercept(poly, &amp;P, &amp;S, x);
    }
  }

  // no need to recompute bbox -- still valid

  Z_Free(orig_verts);
}
</t>
<t tx="T1241">@ RGL_DoSplitPolyVertSep

ALGORITHM:

(a) Let the vertical range be Y1..Y2 which will contain the
new piece of the original polygon.

(b) Traverse the points of the polygon in normal (clockwise)
order. Let P be the current point, and S be the successor
point (or the first point if P is the last).

(c) If P is lower than S, let CY = Y1 and DY = Y2, otherwise
let CY = Y2 and DY = Y1.

(d) Detect whether points P and S are: above the range (U),
on the top border of range (Y2), inside the range (M), on the
bottom border (Y1), or below the range (L).

(e) The following table shows what to do:

P  S  | Action
------------+------------------------------------------
L  L,Y1 | nothing
L  M,Y2 | add intercept (P-&gt;S on CY)
L  U  | double intercept (P-&gt;S on CY then DY)
------------+------------------------------------------
Y1  L  | add P
M,Y2 L  | add P then intercept (P-&gt;S on DY)
------------+------------------------------------------
M*  M* | add P
------------+------------------------------------------
Y1,M U  | add P then intercept (P-&gt;S on DY)
Y2  U  | add P
------------+------------------------------------------
U  L  | double intercept (P-&gt;S on CY then DY)
U  Y1,M | add intercept (P-&gt;S on CY)
U  Y2,U | nothing
------------+------------------------------------------

Where "M*" means M or Y1 or Y2.
@c

static void RGL_DoSplitPolyVertSep(raw_polyquad_t *poly, int extras)
{
  int j, k;
  float_t y1, y2;
  float_t span_y = poly-&gt;max.y - poly-&gt;min.y;
  float_t min_y = poly-&gt;min.y;

  raw_polyquad_t *N;
  vec3_t *orig_verts;
  int orig_num;
    
  // copy original vertices
  orig_num = poly-&gt;num_verts;
  DEV_ASSERT2(orig_num &gt;= 3);
  
  orig_verts = Z_New(vec3_t, orig_num);
  Z_MoveData(orig_verts, poly-&gt;verts, vec3_t, orig_num);
  
  // clear current polygon
  poly-&gt;num_verts = 0;
  
  y1 = poly-&gt;min.y;

  for (j=0; j &lt; extras+1; j++, y1 = y2)
  {
    y2 = min_y + span_y * (j+1) / (float_t)(extras+1);

    if (j == 0)
    {
      N = poly;
    }
    else
    {
      N = RGL_NewPolyQuad(8, false);

      // link it in
      N-&gt;sisters = poly-&gt;sisters;
      poly-&gt;sisters = N;
    }

    for (k=0; k &lt; orig_num; k++)
    {
      vec3_t P, S;
      int Ppos, Spos;
      int Pedg, Sedg;
      float_t cy, dy;
        
      P = orig_verts[k];
      S = orig_verts[(k+1) % orig_num];

      Ppos = (P.y &lt; y1) ? -1 : (P.y &gt; y2) ? +1 : 0;
      Spos = (S.y &lt; y1) ? -1 : (S.y &gt; y2) ? +1 : 0;
      
      // handle boundary conditions
      Pedg = (fabs(P.y-y1)&lt;0.01) ? -1 : (fabs(P.y-y2)&lt;0.01) ? +1 : 0;
      Sedg = (fabs(S.y-y1)&lt;0.01) ? -1 : (fabs(S.y-y2)&lt;0.01) ? +1 : 0;

      if (Pedg != 0)
        Ppos = 0;

      if (Sedg != 0)
        Spos = 0;

      if (P.y &lt; S.y)
        cy = y1, dy = y2;
      else
        cy = y2, dy = y1;

      // always add current point if inside the range
      if (Ppos == 0)
        AddPolyDynPoint(N, P.x, P.y, P.z);
       
      // handle the do nothing cases
      if (Ppos == Spos)
        continue;

      if ((Ppos &lt; 0 &amp;&amp; Sedg &lt; 0) || (Ppos &gt; 0 &amp;&amp; Sedg &gt; 0))
        continue;

      if ((Spos &lt; 0 &amp;&amp; Pedg &lt; 0) || (Spos &gt; 0 &amp;&amp; Pedg &gt; 0))
        continue;

      // handle the "branching inside-&gt;outside" case
      if (Ppos == 0)
      {
        AddPolyVertIntercept(N, &amp;P, &amp;S, dy);
        continue;
      }

      // OK, we know the P-&gt;S line must cross CY
      AddPolyVertIntercept(N, &amp;P, &amp;S, cy);
      
      // check for double intercept
      if (Ppos * Spos &lt; 0)
      {
        AddPolyVertIntercept(N, &amp;P, &amp;S, dy);
      }
    }
 
    RGL_BoundPolyQuad(N);
  }

  Z_Free(orig_verts);
}
</t>
<t tx="T1242">
static void RGL_DoSplitPolyHorizSep(raw_polyquad_t *poly, int extras)
{
  int j, k;
  float_t x1, x2;
  float_t span_x = poly-&gt;max.x - poly-&gt;min.x;
  float_t min_x = poly-&gt;min.x;

  raw_polyquad_t *N;
  vec3_t *orig_verts;
  int orig_num;
    
  // copy original vertices
  orig_num = poly-&gt;num_verts;
  DEV_ASSERT2(orig_num &gt;= 3);
  
  orig_verts = Z_New(vec3_t, orig_num);
  Z_MoveData(orig_verts, poly-&gt;verts, vec3_t, orig_num);
  
  // clear current polygon
  poly-&gt;num_verts = 0;
  
  x1 = poly-&gt;min.x;

  for (j=0; j &lt; extras+1; j++, x1 = x2)
  {
    x2 = min_x + span_x * (j+1) / (float_t)(extras+1);

    if (j == 0)
    {
      N = poly;
    }
    else
    {
      N = RGL_NewPolyQuad(8, false);

      // link it in
      N-&gt;sisters = poly-&gt;sisters;
      poly-&gt;sisters = N;
    }

    for (k=0; k &lt; orig_num; k++)
    {
      vec3_t P, S;
      int Ppos, Spos;
      int Pedg, Sedg;
      float_t cx, dx;
        
      P = orig_verts[k];
      S = orig_verts[(k+1) % orig_num];

      Ppos = (P.x &lt; x1) ? -1 : (P.x &gt; x2) ? +1 : 0;
      Spos = (S.x &lt; x1) ? -1 : (S.x &gt; x2) ? +1 : 0;
      
      // handle boundary conditions
      Pedg = (fabs(P.x-x1)&lt;0.01) ? -1 : (fabs(P.x-x2)&lt;0.01) ? +1 : 0;
      Sedg = (fabs(S.x-x1)&lt;0.01) ? -1 : (fabs(S.x-x2)&lt;0.01) ? +1 : 0;

      if (Pedg != 0)
        Ppos = 0;

      if (Sedg != 0)
        Spos = 0;

      if (P.x &lt; S.x)
        cx = x1, dx = x2;
      else
        cx = x2, dx = x1;

      // always add current point if inside the range
      if (Ppos == 0)
        AddPolyDynPoint(N, P.x, P.y, P.z);
       
      // handle the do nothing cases
      if (Ppos == Spos)
        continue;

      if ((Ppos &lt; 0 &amp;&amp; Sedg &lt; 0) || (Ppos &gt; 0 &amp;&amp; Sedg &gt; 0))
        continue;

      if ((Spos &lt; 0 &amp;&amp; Pedg &lt; 0) || (Spos &gt; 0 &amp;&amp; Pedg &gt; 0))
        continue;

      // handle the "branching inside-&gt;outside" case
      if (Ppos == 0)
      {
        AddPolyHorizIntercept(N, &amp;P, &amp;S, dx);
        continue;
      }

      // OK, we know the P-&gt;S line must cross CX
      AddPolyHorizIntercept(N, &amp;P, &amp;S, cx);
      
      // check for double intercept
      if (Ppos * Spos &lt; 0)
      {
        AddPolyHorizIntercept(N, &amp;P, &amp;S, dx);
      }
    }
 
    RGL_BoundPolyQuad(N);
  }

  Z_Free(orig_verts);
}
</t>
<t tx="T1243">
static void RGL_DoSplitPolyListVert(raw_polyquad_t *poly,
    int extras, boolean_t separate)
{
  while (poly)
  {
    raw_polyquad_t *cur = poly;
    poly = poly-&gt;sisters;

    if (separate)
      RGL_DoSplitPolyVertSep(cur, extras);
    else
      RGL_DoSplitPolyVert(cur, extras);
  }
}
</t>
<t tx="T1244">
static void RGL_DoSplitPolyListHoriz(raw_polyquad_t *poly,
    int extras, boolean_t separate)
{
  while (poly)
  {
    raw_polyquad_t *cur = poly;
    poly = poly-&gt;sisters;

    if (separate)
      RGL_DoSplitPolyHorizSep(cur, extras);
    else
      RGL_DoSplitPolyHoriz(cur, extras);
  }
}
</t>
<t tx="T1245">
static void RGL_DoSplitPolygon(raw_polyquad_t *poly, int division,
    boolean_t separate)
{
  float_t span_x = poly-&gt;max.x - poly-&gt;min.x;
  float_t span_y = poly-&gt;max.y - poly-&gt;min.y;

  DEV_ASSERT2(division &gt; 0);

  if (span_x &gt; division &amp;&amp; span_y &gt; division)
  {
    // split the shortest axis before longest one
    if (span_x &lt; span_y)
    {
      RGL_DoSplitPolyListHoriz(poly, floor(span_x / division), true);
      span_x = 0;
    }
    else
    {
      RGL_DoSplitPolyListVert(poly, floor(span_y / division), true);
      span_y = 0;
    }
  }
 
  if (span_x &gt; division)
  {
    RGL_DoSplitPolyListHoriz(poly, floor(span_x / division), separate);
  }

  if (span_y &gt; division)
  {
    RGL_DoSplitPolyListVert(poly, floor(span_y / division), separate);
  }
}
</t>
<t tx="T1246">@ ----------------------------------------------------------------------------
@c

void RGL_SplitPolyQuad(raw_polyquad_t *poly, int division,
    boolean_t separate)
{
  if (poly-&gt;quad)
    RGL_DoSplitQuad(poly, division, separate);
  else
    RGL_DoSplitPolygon(poly, division, separate);
}
</t>
<t tx="T1247">
void RGL_SplitPolyQuadLOD(raw_polyquad_t *poly, int max_lod, int base_div)
{
  raw_polyquad_t *trav, *tail;
  int lod;

  // first step: make sure nothing is larger than 1024
 
  RGL_SplitPolyQuad(poly, 1024, true);

  // second step: compute LOD of each bit

  for (trav = poly; trav; )
  {
    raw_polyquad_t *cur = trav;
    trav = trav-&gt;sisters;

    lod = R2_GetBBoxLOD(cur-&gt;min.x, cur-&gt;min.y, cur-&gt;min.z,
        cur-&gt;max.x, cur-&gt;max.y, cur-&gt;max.z);

    lod = MAX(lod, max_lod) * base_div;

    if (lod &gt; (1024 * 3/4))
      continue;

    // unlink remaining pieces, putting them back in after splitting
    // this piece.
    //
    cur-&gt;sisters = NULL;
    
    RGL_SplitPolyQuad(cur, lod, (cur-&gt;quad) ? false : true);
 
    for (tail = cur; tail-&gt;sisters; tail = tail-&gt;sisters)
    { /* nothing here */ }
    
    DEV_ASSERT2(tail);
    tail-&gt;sisters = trav;
  }
}
</t>
<t tx="T1248">
void RGL_RenderPolyQuad(raw_polyquad_t *poly, void *data,
    void (* CoordFunc)(vec3_t *src, local_gl_vert_t *vert, void *data),
    GLuint tex_id, boolean_t masked, boolean_t blended)
{
  int j;
  local_gl_vert_t *vert;
  
  while (poly)
  {
    raw_polyquad_t *cur = poly;
    poly = poly-&gt;sisters;

    DEV_ASSERT2(cur-&gt;num_verts &gt; 0);
    DEV_ASSERT2(cur-&gt;num_verts &lt;= cur-&gt;max_verts);

    vert = RGL_BeginUnit(cur-&gt;quad ? GL_QUAD_STRIP : GL_POLYGON,
        cur-&gt;num_verts, tex_id, masked, blended);

    for (j=0; j &lt; cur-&gt;num_verts; j++)
    {
      (* CoordFunc)(cur-&gt;verts + j, vert + j, data);
    }
 
    RGL_EndUnit(j);
  }
}
</t>
<t tx="T1249">

#if 0  // DEBUG ONLY
static raw_polyquad_t * CreateTestQuad(float_t x1, float_t y1,
    float_t z1, float_t x2, float_t y2, float_t z2)
{
  raw_polyquad_t *poly = RGL_NewPolyQuad(4, true);

  PQ_ADD_VERT(poly, x1, y1, z1);
  PQ_ADD_VERT(poly, x1, y1, z2);
  PQ_ADD_VERT(poly, x2, y2, z1);
  PQ_ADD_VERT(poly, x2, y2, z2);

  RGL_BoundPolyQuad(poly);

  return poly;
}
</t>
<t tx="T1250">
static raw_polyquad_t * CreateTestPolygon1(void)
{
  raw_polyquad_t *poly = RGL_NewPolyQuad(10, false);

  PQ_ADD_VERT(poly, 200, 200,  88);
  PQ_ADD_VERT(poly, 500, 2600, 88);
  PQ_ADD_VERT(poly, 550, 2600, 88);
  PQ_ADD_VERT(poly, 750, 1400, 88);
//  PQ_ADD_VERT(poly, 800, 1000, 88);
  PQ_ADD_VERT(poly, 800, 800,  88);

  RGL_BoundPolyQuad(poly);

  return poly;
}
</t>
<t tx="T1251">
void RGL_TestPolyQuads(void)
{
  raw_polyquad_t *test;

  L_WriteDebug("=== QUAD TEST ===\n");
  test = CreateTestQuad(300, 400, 150, 3700, 2200, 1750);
  RGL_DumpPolyQuad(test, false);

  L_WriteDebug("Splitting to 1000 division...\n");
  RGL_SplitPolyQuad(test, 1000, true);
  RGL_DumpPolyQuad(test, false);

  L_WriteDebug("Further splitting to 128 division...\n");
  RGL_SplitPolyQuad(test, 128, false);
  RGL_DumpPolyQuad(test, false);

  L_WriteDebug("=== POLYGON TEST ===\n");
  test = CreateTestPolygon1();
  RGL_DumpPolyQuad(test, false);

  L_WriteDebug("Splitting to 1000 division...\n");
  RGL_SplitPolyQuad(test, 1000, false);
  RGL_DumpPolyQuad(test, false);
}

#endif  // DEBUG
</t>
<t tx="T1253">@ignore
@language c

// Data Definition File Code (Weapons)

// Player Weapons Setup and Parser Code

// -KM- 1998/11/25 File Written

&lt;&lt; ddf_weap #includes &gt;&gt;
&lt;&lt; ddf_weap declarations &gt;&gt;
@others
</t>
<t tx="T1254">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "e_search.h"
#include "m_math.h"
#include "m_fixed.h"
#include "p_action.h"
#include "p_mobj.h"
#include "z_zone.h"
</t>
<t tx="T1255">
#undef  DF
#define DF  DDF_CMD

static weaponinfo_t buffer_weapon;
static weaponinfo_t *dynamic_weapon;

static const weaponinfo_t template_weapon =
{
  DDF_BASE_NIL,  // ddf

  NULL,        // attack
  AM_NoAmmo,   // ammo;
  0,           // ammopershot;
  1,           // clip;
  false,       // autofire;
  0.0,         // kick;

  NULL,        // sa_attack;
  AM_NoAmmo,   // sa_ammo;
  0,           // sa_ammopershot;
  1,           // sa_clip;
  false,       // sa_autofire;

  0,    // first_state
  0,    // last_state
  
  0,    // up_state;
  0,    // down_state;
  0,    // ready_state;
  0,    // attack_state;
  0,    // reload_state;
  0,    // flash_state;
  0,    // sa_attack_state;
  0,    // sa_reload_state;
  0,    // sa_flash_state;
  0,    // crosshair;
  0,    // zoom_state;

  false,  // autogive;
  false,  // feedback;
  -1,     // upgraded_weap;
  0,      // priority;
  false,  // dangerous;

  NULL,   // eject_attack;
  NULL,   // idle;
  NULL,   // engaged;
  NULL,   // hit;
  NULL,   // start;
  NULL,   // sound1;
  NULL,   // sound2;
  NULL,   // sound3;

  false,  // nothrust;
  -1,     // bind_key;
  0,      // special_flags;
  0,      // zoom_fov
  false,  // refire_inacc
  false,  // show_clip
  PERCENT_MAKE(100), // bobbing
  PERCENT_MAKE(100)  // swaying
};

weaponinfo_t ** weaponinfo = NULL;
int numweapons = 0;
int num_disabled_weapons = 0;

static stack_array_t weaponinfo_a;


// -KM- 1998/11/25 Always 10 weapon keys, 1 - 9 and 0
weaponkey_t weaponkey[10];

static void DDF_WGetAmmo(const char *info, void *storage);
static void DDF_WGetUpgrade(const char *info, void *storage);
static void DDF_WGetSpecialFlags(const char *info, void *storage);

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_weapon

static const commandlist_t weapon_commands[] =
{
  DF("AMMOTYPE", ammo, DDF_WGetAmmo),
  DF("AMMOPERSHOT", ammopershot, DDF_MainGetNumeric),
  DF("CLIPSIZE", clip, DDF_MainGetNumeric),
  DF("AUTOMATIC", autofire, DDF_MainGetBoolean),
  DF("SEC AMMOTYPE", sa_ammo, DDF_WGetAmmo),
  DF("SEC AMMOPERSHOT", sa_ammopershot, DDF_MainGetNumeric),
  DF("SEC CLIPSIZE", sa_clip, DDF_MainGetNumeric),
  DF("SEC AUTOMATIC", sa_autofire, DDF_MainGetBoolean),
  DF("ATTACK", attack, DDF_MainRefAttack),
  DF("SECOND ATTACK", sa_attack, DDF_MainRefAttack),
  DF("EJECT ATTACK", eject_attack, DDF_MainRefAttack),
  DF("FREE", autogive, DDF_MainGetBoolean),
  DF("BINDKEY", bind_key, DDF_MainGetNumeric),
  DF("PRIORITY", priority, DDF_MainGetNumeric),
  DF("DANGEROUS", dangerous, DDF_MainGetBoolean),
  DF("UPGRADES", upgraded_weap, DDF_WGetUpgrade),
  DF("IDLE SOUND", idle, DDF_MainLookupSound),
  DF("ENGAGED SOUND", engaged, DDF_MainLookupSound),
  DF("HIT SOUND", hit, DDF_MainLookupSound),
  DF("START SOUND", start, DDF_MainLookupSound),
  DF("NOTHRUST", nothrust, DDF_MainGetBoolean),
  DF("FEEDBACK", feedback, DDF_MainGetBoolean),
  DF("KICK", kick, DDF_MainGetFloat),
  DF("SPECIAL", special_flags, DDF_WGetSpecialFlags),
  DF("ZOOM FOV", zoom_fov, DDF_MainGetAngle),
  DF("REFIRE INACCURATE", refire_inacc, DDF_MainGetBoolean),
  DF("SHOW CLIP", show_clip, DDF_MainGetBoolean),
  DF("BOBBING", bobbing, DDF_MainGetPercent),
  DF("SWAYING", swaying, DDF_MainGetPercent),
  
  // -AJA- backwards compatibility cruft...
  DF("!SOUND1", sound1, DDF_MainLookupSound),
  DF("!SOUND2", sound2, DDF_MainLookupSound),
  DF("!SOUND3", sound3, DDF_MainLookupSound),

  DDF_CMD_END
};

static const state_starter_t weapon_starters[] =
{
  {"UP",        "UP",     &amp;buffer_weapon.up_state},
  {"DOWN",      "DOWN",   &amp;buffer_weapon.down_state},
  {"READY",     "READY",  &amp;buffer_weapon.ready_state},
  {"ATTACK",    "READY",  &amp;buffer_weapon.attack_state},
  {"RELOAD",    "READY",  &amp;buffer_weapon.reload_state},
  {"FLASH",     "REMOVE", &amp;buffer_weapon.flash_state},
  {"SECATTACK", "READY",  &amp;buffer_weapon.sa_attack_state},
  {"SECRELOAD", "READY",  &amp;buffer_weapon.sa_reload_state},
  {"SECFLASH",  "REMOVE", &amp;buffer_weapon.sa_flash_state},
  {"CROSSHAIR", "REMOVE", &amp;buffer_weapon.crosshair},
  {"ZOOM",      "ZOOM",   &amp;buffer_weapon.zoom_state},
  {NULL, NULL, NULL}
};

static const actioncode_t weapon_actions[] =
{
  {"NOTHING", NULL, NULL},
  {"RAISE",             A_Raise, NULL},
  {"LOWER",             A_Lower, NULL},
  {"READY",             A_WeaponReady, NULL},
  {"SHOOT",             A_WeaponShoot, DDF_StateGetAttack},
  {"EJECT",             A_WeaponEject, DDF_StateGetAttack},
  {"REFIRE",            A_ReFire, NULL},
  {"NOFIRE",            A_NoFire, NULL},
  {"NOFIRE RETURN",     A_NoFireReturn, NULL},
  {"KICK",              A_WeaponKick, DDF_StateGetFloat},
  {"SETCROSS",          A_SetCrosshair, NULL},
  {"TARGET",            A_GotTarget, NULL},
  {"LIGHT0",            A_Light0, NULL},
  {"LIGHT1",            A_Light1, NULL},
  {"LIGHT2",            A_Light2, NULL},
  {"CHECKRELOAD",       A_CheckReload, NULL},
  {"FLASH",             A_GunFlash, NULL},
  {"PLAYSOUND",         A_WeaponPlaySound, DDF_StateGetSound},
  {"KILLSOUND",         A_WeaponKillSound, NULL},
  {"JUMP",              A_WeaponJump, DDF_StateGetJump},
  {"RTS ENABLE TAGGED", A_WeaponEnableRadTrig,  DDF_StateGetInteger},
  {"RTS DISABLE TAGGED",A_WeaponDisableRadTrig, DDF_StateGetInteger},
  {"TRANS SET",         A_WeaponTransSet,  DDF_StateGetPercent},
  {"TRANS FADE",        A_WeaponTransFade, DDF_StateGetPercent},
  {"SEC SHOOT",         A_WeaponShootSA, DDF_StateGetAttack},
  {"SEC REFIRE",        A_ReFireSA, NULL},
  {"SEC NOFIRE",        A_NoFireSA, NULL},
  {"SEC NOFIRE RETURN", A_NoFireReturnSA, NULL},
  {"SEC FLASH",         A_GunFlashSA, NULL},
  {"SEC CHECKRELOAD",   A_CheckReloadSA, NULL},

  // -AJA- backwards compatibility cruft...
  {"!SOUND1",           A_SFXWeapon1, NULL},
  {"!SOUND2",           A_SFXWeapon2, NULL},
  {"!SOUND3",           A_SFXWeapon3, NULL},
  {"!RANDOMJUMP", NULL, NULL},
  {NULL, NULL, NULL}
};

const specflags_t ammo_types[] =
{
    {"NOAMMO",  AM_NoAmmo, 0},
    
    {"BULLETS", AM_Bullet, 0},
    {"SHELLS",  AM_Shell,  0},
    {"ROCKETS", AM_Rocket, 0},
    {"CELLS",   AM_Cell,   0},
    
    {"PELLETS", AM_Pellet, 0},
    {"NAILS",   AM_Nail,   0},
    {"GRENADES",AM_Grenade,0},
    {"GAS",     AM_Gas,    0},

    {NULL, 0, 0}
};
</t>
<t tx="T1256">
static boolean_t WeaponTryParseState(const char *field, 
    const char *contents, int index, boolean_t is_last)
{
  int i;
  const state_starter_t *starter;
  const char *pos;

  char labname[68];

  if (strncasecmp(field, "STATES(", 7) != 0)
    return false;

  // extract label name
  field += 7;

  pos = strchr(field, ')');
  
  if (pos == NULL || pos == field || pos &gt; (field+64))
    return false;

  Z_StrNCpy(labname, field, pos - field);
  
  // check for the "standard" states
  starter = NULL;

  for (i=0; weapon_starters[i].label; i++)
    if (DDF_CompareName(weapon_starters[i].label, labname) == 0)
      break;
  
  if (weapon_starters[i].label)
    starter = &amp;weapon_starters[i];

  DDF_StateReadState(contents, labname,
      &amp;buffer_weapon.first_state, &amp;buffer_weapon.last_state,
      starter ? starter-&gt;state_num : NULL, index, 
      is_last ? starter ? starter-&gt;last_redir : "READY" : NULL, 
      weapon_actions);

  return true;
}
</t>
<t tx="T1257">@ DDF PARSE ROUTINES
@c

static boolean_t WeaponStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=num_disabled_weapons; i &lt; numweapons; i++)
    {
      if (DDF_CompareName(weaponinfo[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_weapon = weaponinfo[i];
        replaces = true;
        break;
      }
    }
    
    // ** NOTE **
    // Normally we adjust the pointer array here to keep the
    // newest entries at the end.  For weapons however, there are
    // integer indices stored in various places (E.g. benefit
    // system), so we must keep the order one-to-one between
    // pointer and weaponinfo_t structure.
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;weaponinfo_a, ++numweapons);
 
    dynamic_weapon = weaponinfo[numweapons - 1];
    dynamic_weapon-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_WEAPON", numweapons);
  }

  dynamic_weapon-&gt;ddf.number = 0;

  // instantiate the static entry
  buffer_weapon = template_weapon;

  return replaces;
}
</t>
<t tx="T1258">
static void WeaponParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("WEAPON_PARSE: %s = %s;\n", field, contents);
#endif

  if (DDF_MainParseField(weapon_commands, field, contents))
    return;
  
  if (WeaponTryParseState(field, contents, index, is_last))
    return;

  // handle properties
  if (index == 0 &amp;&amp; DDF_CompareName(contents, "TRUE") == 0)
  {
    DDF_WGetSpecialFlags(field, NULL);  // FIXME FOR OFFSETS
    return;
  }

  DDF_WarnError("Unknown weapons.ddf command: %s\n", field);
}
</t>
<t tx="T1259">
static void WeaponFinishEntry(void)
{
  ddf_base_t base;
  
  if (! buffer_weapon.first_state)
    DDF_Error("Weapon `%s' has missing states.\n",
        dynamic_weapon-&gt;ddf.name);

  DDF_StateFinishStates(buffer_weapon.first_state, buffer_weapon.last_state);

  // check stuff...

  if (buffer_weapon.ammopershot &lt; 0)
  {
    DDF_WarnError("Bad AMMOPERSHOT value for weapon: %d\n",
      buffer_weapon.ammopershot);
    buffer_weapon.ammopershot = 1;
  }

  // backwards compatibility (REMOVE for 1.26)
  if (buffer_weapon.priority &lt; 0)
  {
    if (! no_obsoletes)
      DDF_Warning("Using PRIORITY=-1 in weapons.ddf is obsolete !\n");

    buffer_weapon.dangerous = true;
    buffer_weapon.priority = 10;
  }
 
  // transfer static entry to dynamic entry
  
  base = dynamic_weapon-&gt;ddf;
  dynamic_weapon[0] = buffer_weapon;
  dynamic_weapon-&gt;ddf = base;

  // compute CRC...
  CRC32_Init(&amp;dynamic_weapon-&gt;ddf.crc);

  CRC32_ProcessInt(&amp;dynamic_weapon-&gt;ddf.crc, dynamic_weapon-&gt;ammo);
  CRC32_ProcessInt(&amp;dynamic_weapon-&gt;ddf.crc, dynamic_weapon-&gt;ammopershot);

  // FIXME: do more stuff...

  CRC32_Done(&amp;dynamic_weapon-&gt;ddf.crc);
}
</t>
<t tx="T1260">
static void WeaponClearAll(void)
{
  // not safe to delete weapons, there are (integer) references

  num_disabled_weapons = numweapons;
}
</t>
<t tx="T1261">@ DDF_ReadWeapons
@c

void DDF_ReadWeapons(void *data, int size)
{
  readinfo_t weapons;

  weapons.memfile = data;
  weapons.memsize = size;
  weapons.tag = "WEAPONS";
  weapons.entries_per_dot = 1;

  if (weapons.memfile)
  {
    weapons.message = NULL;
    weapons.filename = NULL;
    weapons.lumpname = "DDFWEAP";
  }
  else
  {
    weapons.message = "DDF_InitWeapons";
    weapons.filename = "weapons.ddf";
    weapons.lumpname = NULL;
  }

  weapons.start_entry  = WeaponStartEntry;
  weapons.parse_field  = WeaponParseField;
  weapons.finish_entry = WeaponFinishEntry;
  weapons.clear_all    = WeaponClearAll;

  DDF_MainReadFile(&amp;weapons);
}
</t>
<t tx="T1262">
void DDF_WeaponInit(void)
{
  Z_InitStackArray(&amp;weaponinfo_a, (void ***)&amp;weaponinfo, sizeof(weaponinfo_t), 0);
}
</t>
<t tx="T1263">
void DDF_WeaponCleanUp(void)
{
  // compute the weaponkey array

  int key, i;

  memset(&amp;weaponkey, 0, sizeof(weaponkey));

  for (key=0; key &lt; 10; key++)
  {
    weaponkey_t *w = &amp;weaponkey[key];
    
    for (i=num_disabled_weapons; i &lt; numweapons; i++)
    {
      if (weaponinfo[i]-&gt;bind_key != key)
        continue;
      
      Z_Resize(w-&gt;choices, weaponinfo_t *, ++w-&gt;numchoices);
      w-&gt;choices[w-&gt;numchoices-1] = weaponinfo[i];
    }

#if (DEBUG_DDF)
    L_WriteDebug("DDF_Weap: CHOICES ON KEY %d:\n", key);
    for (i=0; i &lt; w-&gt;numchoices; i++)
    {
      L_WriteDebug("  [%s] pri=%d\n", w-&gt;choices[i]-&gt;ddf.name,
          w-&gt;choices[i]-&gt;priority);
    }
#endif

    if (w-&gt;numchoices &lt; 2)
      continue;
    
    // sort choices based on weapon priority
#define CMP(a, b)  ((a)-&gt;priority &lt; (b)-&gt;priority)
    QSORT(weaponinfo_t *, w-&gt;choices, w-&gt;numchoices, CUTOFF);
#undef CMP

  }
}
</t>
<t tx="T1264">
static void DDF_WGetAmmo(const char *info, void *storage)
{
  int *ammo = (int *)storage;
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, ammo_types, &amp;flag_value,
      false, false))
  {
    case CHKF_Positive:
    case CHKF_Negative:
      (*ammo) = flag_value;
      break;
    
    case CHKF_User:
    case CHKF_Unknown:
        DDF_WarnError("Unknown Ammo type '%s'\n", info);
      break;
  }
}
</t>
<t tx="T1265">
int DDF_WeaponLookup(const char *name)
{
  int i;

  for (i=num_disabled_weapons; i &lt; numweapons; i++)
  {
    if (DDF_CompareName(weaponinfo[i]-&gt;ddf.name, name) == 0)
      return i;
  }

  return -1;
}
</t>
<t tx="T1266">
static void DDF_WGetUpgrade(const char *info, void *storage)
{
  int *dest = (int *)storage;

  *dest = DDF_WeaponLookup(info);

  if (*dest &lt; 0)
    DDF_WarnError("Unknown weapon to upgrade: %s\n", info);
}
</t>
<t tx="T1267">
static specflags_t weapon_specials[] =
{
    {"SILENT TO MONSTERS", WPSP_SilentToMonsters, 0},
    {NULL, 0, 0}
};

//
// DDF_WGetSpecialFlags
//
static void DDF_WGetSpecialFlags(const char *info, void *storage)
{
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, weapon_specials, &amp;flag_value,
      true, false))
  {
    case CHKF_Positive:
      buffer_weapon.special_flags |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_weapon.special_flags &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("DDF_WGetSpecialFlags: Unknown Special: %s", info);
      break;
  }
}
</t>
<t tx="T1268">@ignore
@language c

// Basic Definitions File

#include "i_defs.h"

#include "dm_defs.h"

// Location for any defines turned variables.

// None.
</t>
<t tx="T1270">@ignore
@language c

// Global State Variables

#include "i_defs.h"
#include "dm_state.h"

/*
   // Game Mode - identify IWAD as shareware, retail etc.
   GameMode_t gamemode = indetermined;
   GameMission_t gamemission = doom;

   // Language.
   Language_t   language = english;
 */
// Set if homebrew PWAD stuff has been added.
boolean_t modifiedgame;
</t>
<t tx="T1272">@ignore
@language c

// Main Init + Program Loop Code

// DESCRIPTION:
//      EDGE main program (E_EDGEMain),
//      game loop (E_EDGELoop) and startup functions.
//
// -MH- 1998/07/02 "shootupdown" --&gt; "true3dgameplay"
// -MH- 1998/08/19 added up/down movement variables

&lt;&lt; e_main #includes &gt;&gt;
&lt;&lt; e_main declarations &gt;&gt;
@others
</t>
<t tx="T1273">#include "i_defs.h"
#include "e_main.h"

#include "am_map.h"
#include "con_defs.h" // Ansi C++ wants to know what funclist_s is.
#include "con_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "dstrings.h"
#include "f_finale.h"
#include "g_game.h"
#include "gui_main.h"
#include "gui_gui.h"
#include "hu_stuff.h"
#include "l_glbsp.h"
#include "m_argv.h"
#include "m_bbox.h"
#include "m_misc.h"
#include "m_menu.h"
#include "p_setup.h"
#include "p_spec.h"
#include "r_local.h"
#include "rad_trig.h"
#include "r_draw1.h"
#include "r_draw2.h"
#include "r_layers.h"
#include "r_vbinit.h"
#include "r2_defs.h"
#include "rgl_defs.h"
#include "s_sound.h"
#include "st_stuff.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "version.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "v_res.h"
#include "v_toplev.h"
#include "w_image.h"
#include "w_textur.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "wp_main.h"
#include "z_zone.h"
</t>
<t tx="T1274">
// Internals
static boolean_t SetGlobalVars(void);
static boolean_t SpecialWadVerify(void);
static boolean_t ShowNotice(void);

typedef struct
{
  boolean_t (*function)(void);
  char *LDFmessage;
}
startuporder_t;

startuporder_t startcode[] =
{
  { M_LoadDefaults,      "DefaultLoad"   },
  { SetGlobalVars,       NULL            },
  { RAD_Init,            NULL            },
  { W_InitMultipleFiles, "WadFileInit"   },
  { V_InitPalette,       NULL            },
  { W_InitImages,        NULL            },
  { R_InitFlats,         NULL            },
  { W_InitTextures,      NULL            },
  { DDF_MainCleanUp,     NULL            },
  { SpecialWadVerify,    NULL            },
  { ShowNotice,          NULL            },
  { V_MultiResInit,      "AllocScreens"  },
  { I_SystemStartup,     "InitMachine"   },
  { RAD_LoadParam,       NULL            },
  { GUI_MainInit,        NULL            },
  { SV_ChunkInit,        NULL            },
  { SV_MainInit,         NULL            },
  { M_Init,              "MiscInfo"      },
  { R_Init,              "RefreshDaemon" },
  { P_Init,              "PlayState"     },
  { P_MapInit,           NULL            },
  { P_InitSwitchList,    NULL            },
  { R_InitPicAnims,      NULL            },
  { R_InitSprites,       NULL            },
  { S_Init,              "SoundInit"     },
  { HU_Init,             "HeadsUpInit"   },
  { E_CheckNetGame,      "CheckNetGame"  },
  { ST_Init,             "STBarInit"     },
  { NULL,                NULL            }
};

boolean_t devparm;  // started game with -devparm
boolean_t singletics = false;  // debug flag to cancel adaptiveness

// -ES- 2000/02/13 Takes screenshot every screenshot_rate tics.
// Must be used in conjunction with singletics.
static int screenshot_rate;

// For savegame screenies...
boolean_t need_save_screenshot = false;

FILE *debugfile = NULL;

gameflags_t default_gameflags =
{
     false,  // nomonsters
     false,  // fastparm

     false,  // res_respawn setting
     false,  // respawn
     false,  // item respawn

     false,  // true 3d gameplay
     MENU_GRAV_NORMAL, // gravity
     false,  // more blood

     true,   // jump
     true,   // crouch
     true,   // mlook
     AA_ON,  // autoaim
     
     true,   // trans
     true,   // cheats
     
     true,   // stretchsky
     true,   // have_extra
     false,  // limit_zoom
     false,  // shadows
     false,  // halos

     CM_EDGE,  // compat_mode
     true      // kicking
};

// -KM- 1998/12/16 These flags hold everything needed about a level
// -KM- 1999/01/29 Added autoaim flag.
// -AJA- 2000/02/02: Removed initialisation (it *should* be setup at
//       level start).

gameflags_t level_flags;

// -KM- 1998/12/16 These flags are the users prefs and are copied to
//   gameflags when a new level is started.
// -AJA- 2000/02/02: Removed initialisation (done in code using
//       `default_gameflags').

gameflags_t global_flags;

boolean_t drone = false;

skill_t startskill;
char *startmap;

boolean_t autostart;
boolean_t advancedemo;

int newnmrespawn = 0;

boolean_t rotatemap = false;
boolean_t showstats = false;
boolean_t swapstereo = false;
boolean_t mus_pause_stop = false;
boolean_t infight = false;

boolean_t external_ddf = false;
boolean_t strict_errors = false;
boolean_t lax_errors = false;
boolean_t hom_detect = false;
boolean_t no_warnings = false;
boolean_t no_obsoletes = false;
boolean_t autoquickload = false;

char *iwaddir;
char *homedir;
char *gamedir;
char *savedir;
char *ddfdir;

int crosshair = 0;
int missileteleport = 0;
int teleportdelay = 0;

layer_t *backbg_layer = NULL;
layer_t *conplayer_layer = NULL;
layer_t *pause_layer = NULL;

boolean_t e_display_OK = false;

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t events[MAXEVENTS];
int eventhead;
int eventtail;
</t>
<t tx="T1275">@ ===================Internal====================

SetGlobalVars

-ACB- 1999/09/20 Created. Sets Global Stuff.
@c

static boolean_t SetGlobalVars(void)
{
  int p;
  const char *s;

  // Screen Resolution Check...
  s = M_GetParm("-width");
  if (s)
    SCREENWIDTH = atoi(s);

  s = M_GetParm("-height");
  if (s)
    SCREENHEIGHT = atoi(s);

  p = M_CheckParm("-res");
  if (p &amp;&amp; p + 2 &lt; M_GetArgCount())
  {
    SCREENWIDTH  = atoi(M_GetArgument(p + 1));
    SCREENHEIGHT = atoi(M_GetArgument(p + 2));
  }

  // Bits per pixel check....
  s = M_GetParm("-bpp");
  if (s)
    SCREENBITS = atoi(s) * 8;

  M_CheckBooleanParm("windowed",   &amp;SCREENWINDOW, false);
  M_CheckBooleanParm("fullscreen", &amp;SCREENWINDOW, true);

  // deathmatch check...
  if (M_CheckParm("-altdeath"))
  {
    deathmatch = 2;
  }
  else
  {
    p = M_CheckParm("-deathmatch");

    if (p)
    {
      deathmatch = 1;

      if (p + 1 &lt; M_GetArgCount())
        deathmatch = atoi(M_GetArgument(p + 1));

      if (!deathmatch)
        deathmatch = 1;
    }
  }

  // sprite kludge (TrueBSP)
  p = M_CheckParm("-spritekludge");
  if (p)
  {
    if (p + 1 &lt; M_GetArgCount())
      sprite_kludge = atoi(M_GetArgument(p + 1));

    if (!sprite_kludge)
      sprite_kludge = 1;
  }

  // speed for mouse look
  s = M_GetParm("-vspeed");
  if (s)
    mlookspeed = atoi(s) / 64;

  // -AJA- 1999/10/18: Reworked these with M_CheckBooleanParm
  M_CheckBooleanParm("rotatemap", &amp;rotatemap, false);
  M_CheckBooleanParm("invertmouse", &amp;invertmouse, false);
  M_CheckBooleanParm("showstats", &amp;showstats, false);
  M_CheckBooleanParm("hom", &amp;hom_detect, false);
  M_CheckBooleanParm("sound", &amp;nosound, true);
  M_CheckBooleanParm("music", &amp;nomusic, true);
  M_CheckBooleanParm("devparm", &amp;devparm, false);
  M_CheckBooleanParm("itemrespawn", &amp;global_flags.itemrespawn, false);
  M_CheckBooleanParm("stretchsky", &amp;global_flags.stretchsky, false);
  M_CheckBooleanParm("mlook", &amp;global_flags.mlook, false);
  M_CheckBooleanParm("monsters", &amp;global_flags.nomonsters, true);
  M_CheckBooleanParm("fast", &amp;global_flags.fastparm, false);
  M_CheckBooleanParm("extras", &amp;global_flags.have_extra, false);
  M_CheckBooleanParm("shadows", &amp;global_flags.shadows, false);
  M_CheckBooleanParm("halos", &amp;global_flags.halos, false);
  M_CheckBooleanParm("kick", &amp;global_flags.kicking, false);
  M_CheckBooleanParm("singletics", &amp;singletics, false);
  M_CheckBooleanParm("infight", &amp;infight, false);
  M_CheckBooleanParm("true3d", &amp;global_flags.true3dgameplay, false);
  M_CheckBooleanParm("blood", &amp;global_flags.more_blood, false);
  M_CheckBooleanParm("cheats", &amp;global_flags.cheats, false);
  M_CheckBooleanParm("trans", &amp;global_flags.trans, false);
  M_CheckBooleanParm("jumping", &amp;global_flags.jump, false);
  M_CheckBooleanParm("crouching", &amp;global_flags.crouch, false);
  M_CheckBooleanParm("dlights", &amp;use_dlights, false);
  M_CheckBooleanParm("autoload", &amp;autoquickload, false);

  if (M_CheckParm("-boom"))
    global_flags.compat_mode = CM_BOOM;
  else if (M_CheckParm("-edge") || M_CheckParm("-noboom"))
    global_flags.compat_mode = CM_EDGE;

  if (!global_flags.respawn)
  {
    if (M_CheckParm("-newnmrespawn"))
    {
      global_flags.res_respawn = true;
      global_flags.respawn = true;
    }
    else if (M_CheckParm("-respawn"))
    {
      global_flags.respawn = true;
    }
  }

  return true;
}
</t>
<t tx="T1276">@ SpecialWadVerify
@c

static boolean_t SpecialWadVerify(void)
{
  int lump;

  // the WAD version
  int wad_ver;
  int wad_ver_frac;

  // the backward compatibility of the WAD
  int wad_bc;
  int wad_bc_frac;

  // The sub-version of the WAD (100% compatible with other WADs within the same wad_version)
  int wad_sub_ver;
  const void *data;
  const char *s;

  lump = W_CheckNumForName("EDGEVER");
  if (lump &lt; 0)
    I_Error("EDGEVER lump not found. Get EDGE.WAD at http://edge.sourceforge.net/");

  s = data = W_CacheLumpNum(lump);

  wad_ver = atoi(s);
  while (isdigit(*s))
    s++;

  s++;
  wad_ver_frac = atoi(s);
  while (isdigit(*s))
    s++;

  s++;
  wad_sub_ver = atoi(s);
  while (*s != '\n')
    s++;

  while (!isdigit(*s))
    s++;

  wad_bc = atoi(s);
  while (isdigit(*s))
    s++;

  s++;
  wad_bc_frac = atoi(s);

  W_DoneWithLump(data);

  if (wad_ver * 1024 + wad_ver_frac &lt; EDGE_WAD_VERSION * 1024 + EDGE_WAD_VERSION_FRAC)
  {
    I_Error("EDGE.WAD version %d.%d found, version %d.%d is required.\n"
        "Get it at http://edge.sourceforge.net/", wad_ver, wad_ver_frac,
        EDGE_WAD_VERSION, EDGE_WAD_VERSION_FRAC);
    return false;
  }

  if (wad_bc * 1024 + wad_bc_frac &gt; EDGE_WAD_VERSION * 1024 + EDGE_WAD_VERSION_FRAC)
  {
    I_Error("EDGE.WAD version %d.%d required, found too new version %d.%d\n"
        "which is not backward compatible enough. Get an older EDGE.WAD or\n"
        "a newer EDGE version at http://edge.sourceforge.net/",
        EDGE_WAD_VERSION, EDGE_WAD_VERSION_FRAC, wad_ver, wad_ver_frac);
    return false;
  }

  if (wad_ver &gt; EDGE_WAD_VERSION)
  {
    I_Warning("EDGE.WAD version %d.%d required, found newer version %d.%d.\n"
        "This version of EDGE is probably out-of-date, newer versions are\n"
        "available at http://edge.sourceforge.net/",
        EDGE_WAD_VERSION, EDGE_WAD_VERSION_FRAC, wad_ver, wad_ver_frac);
  }
  else if (EDGE_WAD_SUB_VERSION &gt; wad_sub_ver)
  {
    I_Warning("Slightly out-of-date EDGE.WAD (v%d.%d.%d) found,\n"
        "%d.%d.%d is recommended. Get it at http://edge.sourceforge.net/",
        wad_ver, wad_ver_frac, wad_sub_ver,
        EDGE_WAD_VERSION, EDGE_WAD_VERSION_FRAC, EDGE_WAD_SUB_VERSION);
  }

  I_Printf("EDGE.WAD version %d.%d.%d found.\n", wad_ver, wad_ver_frac, wad_sub_ver);

  return true;
}
</t>
<t tx="T1277">@ ShowNotice
@c

static boolean_t ShowNotice(void)
{
  I_Printf("%s", DDF_LanguageLookup("Notice"));
 
  return true;
}
</t>
<t tx="T1278">@ ===============End of Internals================

E_PostEvent

Called by the I/O functions when input is detected
@c

void E_PostEvent(event_t * ev)
{
  events[eventhead] = *ev;
  eventhead = (++eventhead) &amp; (MAXEVENTS - 1);
}
</t>
<t tx="T1279">@ E_ProcessEvents

Send all the events of the given timestamp down the responder chain
@c

void E_ProcessEvents(void)
{
  event_t *ev;

  for (; eventtail != eventhead; eventtail = (++eventtail) &amp; (MAXEVENTS - 1))
  {
    ev = &amp;events[eventtail];
    if (chat_on &amp;&amp; HU_Responder(ev))
      continue;  // let chat eat the event first of all

    if (GUI_MainResponder(ev))
      continue;  // GUI ate the event

    if (M_Responder(ev))
      continue;  // menu ate the event

    G_Responder(ev);  // let game eat it, nobody else wanted it
  }
}
</t>
<t tx="T1280">
static void M_DisplayPause(void)
{
  static const image_t *pause_image = NULL;

  if (! pause_image)
    pause_image = W_ImageFromPatch("M_PAUSE");

  // FIXME: should center image
  VCTX_ImageEasy320(100, 10, pause_image);
}
</t>
<t tx="T1281">@ E_Display

Draw current display, possibly wiping it from the previous

-ACB- 1998/07/27 Removed doublebufferflag check (unneeded).
wipegamestate can be set to -1 to force a wipe on the next draw
@c

gamestate_t wipegamestate = GS_DEMOSCREEN;
int wipe_method = WIPE_Melt;
int wipe_reverse = 0;
boolean_t redrawsbar;

static boolean_t wipe_gl_active = false;

void E_Display(void)
{
  static boolean_t viewactivestate = false;
  static boolean_t menuactivestate = false;
  static boolean_t inhelpscreensstate = false;
  static boolean_t fullscreen = false;
  static int borderdrawcount;
  static gamestate_t oldgamestate = -1;

  // for wiping
  static wipeinfo_t *wipeinfo = NULL;
  static screen_t *wipestart = NULL, *wipeend = NULL;

  int nowtime;
  int tics;
  int wipestarttime;
  boolean_t done;
  boolean_t wipe;

  if (nodrawers)
    return;  // for comparative timing / profiling

  // -ES- 1998/08/20 Resolution Change Check
  if (changeresneeded)
    R_ExecuteChangeResolution();

  // Start the frame - should we need to.
  I_StartFrame();

  // change the view size if needed
  if (setsizeneeded)
  {
    R_ExecuteSetViewSize();
    oldgamestate = -1;  // force background redraw

    borderdrawcount = 3;
  }

  // -AJA- 1999/07/03: removed PLAYPAL reference.
  if (gamestate != oldgamestate &amp;&amp; gamestate != GS_LEVEL)
  {
    V_SetPalette(PALETTE_NORMAL, 0);
  }

  // -AJA- 1999/08/02: Make sure palette/gamma is OK. This also should
  //       fix (finally !) the "gamma too late on walls" bug.
  V_ColourNewFrame();

  // save the current screen if about to wipe
  if (gamestate != wipegamestate)
  {
    wipe = true;
    wipestart = V_ResizeScreen(wipestart, SCREENWIDTH, SCREENHEIGHT, BPP);

#ifdef USE_GL
    wipe_gl_active = true;
    RGL_InitWipe(wipe_reverse, wipe_method);
#else
    V_CopyScreen(wipestart, main_scr);
#endif
  }
  else
    wipe = false;

  if (gamestate == GS_LEVEL &amp;&amp; gametic)
    HU_Erase();

  // do buffered drawing
  switch (gamestate)
  {
    case GS_LEVEL:
      if (!gametic)
        break;
      if (automapactive == 2)
        AM_Drawer();
      if (wipe || (viewwindowheight != SCREENHEIGHT &amp;&amp; fullscreen))
        redrawsbar = true;
      if (inhelpscreensstate &amp;&amp; !inhelpscreens)
        redrawsbar = true;  // just put away the help screen

      ST_Drawer(viewwindowheight == SCREENHEIGHT, redrawsbar);
      redrawsbar = false;
      fullscreen = viewwindowheight == SCREENHEIGHT;
      break;

    case GS_INTERMISSION:
      WI_Drawer();
      break;

    case GS_FINALE:
      F_Drawer();
      break;

    case GS_DEMOSCREEN:
      E_PageDrawer();
      break;

    case GS_NOTHING:
      break;
  }

  if (need_save_screenshot)
  {
    R_Render();
    M_MakeSaveScreenShot();

    need_save_screenshot = false;
  }

  // draw the view directly
  if (gamestate == GS_LEVEL &amp;&amp; gametic &amp;&amp; automapactive != 2)
  {
    R_Render();

    if (automapactive != 2)
      AM_Drawer();
  }

  // clean up border stuff

#if 1  // #ifdef USE_GL
  // -AJA- temp hack for GL
  oldgamestate = -1;
#endif

  // see if the border needs to be initially drawn
  if (gamestate == GS_LEVEL &amp;&amp; oldgamestate != GS_LEVEL)
  {
    viewactivestate = false;  // view was not active

    R_FillBackScreen();  // draw the pattern into the back screen
    // fixme hack

    ST_Drawer(viewwindowheight == SCREENHEIGHT, true);
  }

  // see if the border needs to be updated to the screen
  if (gamestate == GS_LEVEL &amp;&amp; automapactive != 2)
  {
    if (menuactive || menuactivestate || !viewactivestate)
      borderdrawcount = 3;
    if (borderdrawcount)
    {
      R_DrawViewBorder();  // erase old menu stuff

      borderdrawcount--;
    }
  }

  if (gamestate == GS_LEVEL &amp;&amp; gametic)
  {
    HU_Drawer();
    M_DisplayAir();
  }

  menuactivestate = menuactive;
  viewactivestate = viewactive;
  inhelpscreensstate = inhelpscreens;
  oldgamestate = wipegamestate = gamestate;

  if (paused)
    M_DisplayPause();

  // -AJA- hack to draw glbsp progress bars
  if (gb_draw_progress)
    GB_DrawProgress();

  // menus go directly to the screen
  GUI_MainDrawer();
  M_Drawer();  // menu is drawn even on top of everything
  M_DisplayDisk();

  E_NetUpdate();  // send out any new accumulation

  if (screenshot_rate &amp;&amp; gamestate == GS_LEVEL)
  {
    if (!singletics)
      I_Error("E_Display: -screenshot must be used in conjunction with timedemo or singletics!");

    if (leveltime % screenshot_rate == 0)
      G_ScreenShot();
  }
  
  // normal update
  if (!wipe &amp;&amp; !wipe_gl_active)
  {
    I_FinishFrame();  // page flip or blit buffer
    return;
  }

#ifdef USE_GL
  // -AJA- Wipe code for GL.  Sorry for all this ugliness, but it just
  //       didn't fit into the existing wipe framework.
  //
  if (RGL_DoWipe())
  {
    RGL_StopWipe();
    wipe_gl_active = false;
  }

  M_Drawer();  // menu is drawn even on top of wipes
  I_FinishFrame();  // page flip or blit buffer
      
#else // USE_GL
  
  // -ES- 1999/08/10 New wiping system
  // wipe update
  wipeend = V_ResizeScreen(wipeend, SCREENWIDTH, SCREENHEIGHT, BPP);
  V_CopyScreen(wipeend, main_scr);

  wipeinfo = WIPE_InitWipe(main_scr, 0, 0,
      wipestart, 0, 0, 1,
      wipeend, 0, 0, 1,
      SCREENWIDTH, SCREENHEIGHT, wipeinfo,
      -1, wipe_reverse, wipe_method);

  wipestarttime = I_GetTime();
  tics = 0;

  do
  {
    do
    {
      nowtime = I_GetTime();
    }
    while (tics == nowtime - wipestarttime);
    tics = nowtime - wipestarttime;
    done = WIPE_DoWipe(main_scr, wipestart, wipeend, tics, wipeinfo);
    M_Drawer();  // menu is drawn even on top of wipes

    I_FinishFrame();  // page flip or blit buffer

  }
  while (!done);
  redrawsbar = true;

#endif // USE_GL
}
</t>
<t tx="T1282">@ E_EDGELoopRoutine

This Function is called by I_EDGELoop for a single loop in the
system.

-ACB- 1999/09/24 Written
@c

void E_EDGELoopRoutine(void)
{

  // -ES- 1998/09/11 It's a good idea to frequently check the heap
#ifdef DEVELOPERS
  Z_CheckHeap();
#endif

  // process one or more tics
  if (singletics)
  {
    I_ControlGetEvents();
    E_ProcessEvents();
    G_BuildTiccmd(&amp;consoleplayer-&gt;netcmds[maketic % BACKUPTICS]);

    if (advancedemo)
      E_DoAdvanceDemo();

    M_Ticker();
    GUI_MainTicker();
    G_Ticker();
    S_SoundTicker();
    S_MusicTicker();
    gametic++;
    maketic++;
  }
  else
  {
    E_TryRunTics();  // will run at least one tic
  }

  // Update display, next frame, with current state.
  E_Display();

  // -AJA- hack to allow other code to know when they can call
  //       E_Display().
  e_display_OK = true;
}
</t>
<t tx="T1283">@ E_EDGELoop

Not a globally visible function, just included for source reference,
called by E_EDGEMain, never exits.

This called I_EDGELoop which performs the main loop. I_EDGELoop is
required because the loop is not alway infinite on platforms.
@c

static void E_EDGELoop(void)
{
// SV_MainTestPrimitives();
// RGL_TestPolyQuads();

  // -ES- 1998/09/11 Use R_ChangeResolution to enter gfx mode
  R_ChangeResolution(SCREENWIDTH, SCREENHEIGHT, SCREENBITS, SCREENWINDOW);

  // -ES- 1999/09/27 This will trap any errors before we have to set gfxmode
  Z_CheckHeap();

  // -KM- 1998/09/27 Change res now, so music doesn't start before
  // screen.  Reset clock too.
  R_ExecuteChangeResolution();

  //
  // -ACB- 1999/09/24 Call System Specific Looping function. Some systems
  //                  don't loop forever.
  //
  I_EDGELoop();
  return;
}
</t>
<t tx="T1284">@ DEMO LOOP
@c

int demosequence;
static int demo_num;
static int page_map;
static int page_pic;
static int pagetic;
static const image_t *page_image = NULL;

//
// E_PageTicker
//
// Handles timing for warped projection
//
void E_PageTicker(void)
{
  if (--pagetic &lt; 0)
    E_AdvanceDemo();
}
</t>
<t tx="T1285">
#define NOPAGE_COLOUR  (GRAY + GRAY_LEN*4/5)

//
// E_PageDrawer
//
void E_PageDrawer(void)
{
  if (page_image)
    VCTX_Image(0, 0, SCREENWIDTH, SCREENHEIGHT, page_image);
  else
    vctx.SolidBox(0, 0, SCREENWIDTH, SCREENHEIGHT, NOPAGE_COLOUR, 1);
}
</t>
<t tx="T1286">@ E_AdvanceDemo

Called after each demo or intro demosequence finishes
@c

void E_AdvanceDemo(void)
{
  advancedemo = true;
}
</t>
<t tx="T1287">
static void DemoNextPicture(void)
{
  int count;
  wi_map_t *wi;
  
  // prevent an infinite loop
  for (count=0; count &lt; 200; count++)
  {
    wi = wi_maps[page_map];

    if (page_pic &gt;= wi-&gt;numtitlepics)
    {
      page_map = (page_map + 1) % num_wi_maps;
      page_pic = 0;
      continue;
    }

    // ignore non-existing episodes.  Doesn't include title-only ones
    // like [EDGE].
    if (page_pic == 0 &amp;&amp; wi-&gt;firstmap &amp;&amp; wi-&gt;firstmap[0] &amp;&amp;
        W_CheckNumForName(wi-&gt;firstmap) == -1)
    {
      page_map = (page_map + 1) % num_wi_maps;
      continue;
    }

    // ignore non-existing images
    if (W_CheckNumForName(wi-&gt;titlepics[page_pic]) &lt; 0)
    {
      page_pic += 1;
      continue;
    }

    // found one !!

    if (page_pic == 0 &amp;&amp; wi-&gt;titlemusic &gt; 0)
      S_ChangeMusic(wi-&gt;titlemusic, false);

    page_image = W_ImageFromPatch(wi-&gt;titlepics[page_pic]);
    page_pic += 1;
    
    return;
  }
}
</t>
<t tx="T1288">@ This cycles through the demo sequences.
-KM- 1998/12/16 Fixed for DDF.
@c

void E_DoAdvanceDemo(void)
{
  consoleplayer-&gt;playerstate = PST_LIVE;  // not reborn

  advancedemo = false;
  usergame = false;     // no save or end game here
  paused = false;
  gameaction = ga_nothing;

  demosequence = (demosequence + 1) % 2;  // - Kester

  switch (demosequence)  // - Kester
  {
    case 0:  // Title Picture
    {
      gamestate = GS_DEMOSCREEN;

      DemoNextPicture();

      pagetic = wi_maps[page_map]-&gt;titletics;
      break;
    }

    default:  // Play Demo
    {
      char buffer[9];

      sprintf(buffer, "DEMO%x", demo_num++);

      if (W_CheckNumForName(buffer) &lt; 0)
      {
        demo_num = 1;
        sprintf(buffer, "DEMO1");
      }

      G_DeferedPlayDemo(buffer);
      break;
    }
  }
}
</t>
<t tx="T1289">@ E_StartTitle
@c

void E_StartTitle(void)
{
  gameaction = ga_nothing;
  demosequence = 1;
  demo_num = 1;

  // force pic overflow -&gt; first available titlepic
  page_map = num_wi_maps - 1;
  page_pic = 999;
 
  E_AdvanceDemo();
}
</t>
<t tx="T1290">@ InitDirectories

Detects which directories to search for DDFs, WADs and other files in.
Does not set iwaddir though (E_IdentifyVersion does that).

-ES- 2000/01/01 Written.
@c

static void InitDirectories(void)
{
  const char *location;
  const char *p;
  char *parmfile;

  location = M_GetParm("-home");
  // Get the Home Directory from environment if set
  if (!location)
    location = getenv(EDGEWADDIR);

  if (location)
  {
    homedir = I_PreparePath(location);
  }
  else
  {
    homedir = Z_StrDup(".");
  }

  // Get the Game Directory from parameter.
  location = M_GetParm("-game");
  if (location)
    gamedir = I_PreparePath(location);
  else
    gamedir = Z_StrDup(homedir);

  // add parameter file "gamedir/parms" if it exists.
  parmfile = I_TmpMalloc(strlen(gamedir) + strlen("parms") + 2);
  sprintf(parmfile, "%s%cparms", gamedir, DIRSEPARATOR);

#ifdef DEVELOPERS
  L_WriteDebug("Response file '%s' ", parmfile);
#endif

  if (I_Access(parmfile))
  {
#ifdef DEVELOPERS
    L_WriteDebug("found.\n");
#endif
    // Insert it right after the game parameter
    M_ApplyResponseFile(parmfile, M_CheckParm("-game") + 2);
  }
#ifdef DEVELOPERS
  else
  {
    L_WriteDebug("not found.\n");
  }
#endif

  I_TmpFree(parmfile);

  location = M_GetParm("-ddf");
  if (location)
  {
    external_ddf = true;
    ddfdir = I_PreparePath(location);
  } 
  else
  {
    ddfdir = Z_StrDup(gamedir);
  }

  // config file
  p = M_GetParm("-config");
  if (p)
  {
    cfgfile = M_ComposeFileName(gamedir, p);
  }
  else
  {
    char *s = Z_New(char, strlen(gamedir) + strlen(EDGECONFIGFILE) + 2);
    sprintf(s, "%s%c%s", gamedir, DIRSEPARATOR, EDGECONFIGFILE);
    cfgfile = s;
  }

  // savegame directory
  savedir = M_ComposeFileName(gamedir, SAVEGAMEDIR);

#ifdef WIN32
  mkdir(savedir);
#else
  mkdir(savedir, SAVEGAMEMODE);
#endif
}
</t>
<t tx="T1291">@ CheckExternal

Checks if DDF files exist in the DDF directory, and if so then
enables "external-ddf mode", which prevents the DDF lumps within
EDGE.WAD from being parsed.

-AJA- 2000/05/23: written.
@c

#define EXTERN_FILE  "things.ddf"

static void CheckExternal(void)
{
  char *testfile;
  
  // too simplistic ?

  testfile = I_TmpMalloc(strlen(gamedir) + strlen(EXTERN_FILE) + 2);
  sprintf(testfile, "%s%c%s", gamedir, DIRSEPARATOR, EXTERN_FILE);

  if (I_Access(testfile))
    external_ddf = true;
  
  I_TmpFree(testfile);
}
</t>
<t tx="T1292">@ E_IdentifyVersion

Adds an IWAD and EDGE.WAD. -ES- 2000/01/01 Rewritten.
@c

const char *wadname[] = { "doom2", "doom", "plutonia", "tnt", NULL };

static void IdentifyVersion(void)
{
  int i;
  char *filename;
  boolean_t done;
  int wadnum;
  int length;
  const char *location;
  char *iwad;

  // Check -iwad parameter, find out if we are talking directory or file
  location = M_GetParm("-iwad");

  if (!location)
    location = getenv("DOOMWADDIR");

  if (location)
  {
    iwad = I_PreparePath(location);

    if (I_PathIsDirectory(iwad))
    {
      // it was a directory
      iwaddir = iwad;
      iwad = NULL;
    }
    else
    {
      // it was a file
      iwaddir = Z_StrDup(homedir);
    }
  }
  else
  {
    iwaddir = Z_StrDup(homedir);
    iwad = NULL;
  }

  // Has an iwad name been specified?
  if (iwad)
  {
    length = strlen(iwad) + strlen(EDGEWADEXT) + 2;
    filename = I_TmpMalloc(length);

    if (M_CheckExtension(EDGEWADEXT, iwad) != EXT_MATCHING)
    {
      sprintf(filename, "%s.%s", iwad, EDGEWADEXT);
    }
    else
    {
      strcpy(filename, iwad);
    }

    if (I_Access(filename))
      W_AddRawFilename(filename, false);
    else
      I_Error("IdentifyVersion: Unable to add specified '%s'", filename);

    I_TmpFree(filename);
    Z_Free(iwad);
  }
  else // cycle through default wad names and add them if they exist
  {
    done = false;
    for (i = 0; i &lt; 3 &amp;&amp; !done; i++)
    {
      location = (i == 0 ? iwaddir : (i == 1 ? gamedir : homedir));

      //
      // go through the available wad names constructing an access
      // name for each, adding the file if they exist.
      //
      // -ACB- 2000/06/08 Quit after we found a file - don't load
      //                  more than one IWAD
      //
      wadnum = 0;
      while (wadname[wadnum] &amp;&amp; !done)
      {
        length = strlen(location) + strlen(wadname[wadnum]) + strlen(EDGEWADEXT) + 3;

        filename = I_TmpMalloc(length);

        sprintf(filename, "%s%c%s.%s", location, DIRSEPARATOR, 
            wadname[wadnum], EDGEWADEXT);

        if (I_Access(filename))
        {
          W_AddRawFilename(filename, false);
          done = true;
        }

        I_TmpFree(filename);

        wadnum++;
      }
    }
  }

  if (!addwadnum)
    I_Error("IdentifyVersion: No IWADS found!\n");

  // Add the required WAD file (EDGE.WAD), search in iwaddir and homedir.
  length = MAX(strlen(homedir), strlen(iwaddir)) + strlen(REQUIREDWAD) + strlen(EDGEWADEXT) + 3;
  filename = I_TmpMalloc(length);

  done = false;
  for (i = 0; i &lt; 2 &amp;&amp; !done; i++)
  {
    location = (i == 0 ? iwaddir : homedir);

    sprintf(filename, "%s%c%s.%s", location, DIRSEPARATOR, REQUIREDWAD, EDGEWADEXT);

    if (I_Access(filename))
    {
      // Only read the DDF/RTS lumps in EDGE.WAD if we are not in
      // external-ddf mode.

      W_AddRawFilename(filename, external_ddf ? false : true);
      done = true;
    }
  }

  if (!done)
    I_Error("IdentifyVersion: Could not find required %s.%s!\n", REQUIREDWAD, EDGEWADEXT);

  I_TmpFree(filename);
}
</t>
<t tx="T1293">
static void ShowVersion(void)
{
  // 23-6-98 KM Changed to hex to allow versions such as 0.65a etc
  I_Printf("EDGE v" EDGEVERSTR " compiled on " __DATE__ " at " __TIME__ "\n");
  I_Printf("EDGE homepage is at http://edge.sourceforge.net/\n");
  I_Printf("EDGE is based on DOOM by id Software http://www.idsoftware.com/\n");
}
</t>
<t tx="T1294">@ E_EDGEMain

-ACB- 1998/08/10 Removed all reference to a gamemap, episode and mission
Used LanguageLookup() for lang specifics.

-ACB- 1998/09/06 Removed all the unused code that no longer has
relevance.

-ACB- 1999/09/04 Removed statcopy parm check - UNUSED
@c

void E_EDGEMain(void)
{
  int p;
  const char *ps;
  char *filename;
  char title[] = "EDGE v" EDGEVERSTR;
  int turbo_scale = 100;
  boolean_t success;

  // Start memory allocation system at the very start
  Z_Init();

  // Version check ?
  if (M_CheckParm("-version"))
  {
    // -AJA- using I_Error here, since I_Printf crashes this early on
    I_Error("\nEDGE version is " EDGEVERSTR "\n");
  }

  // -AJA- 2000/02/02: initialise global gameflags to defaults
  global_flags = default_gameflags;

  //
  // -ACB- 1998/09/06 Only used for debugging.
  //                  Moved here to setup debug file for DDF Parsing...
  //
  // -ES- 1999/08/01 Debugfiles can now be used without -DDEVELOPERS, and
  //                 then logs all the CON_Printfs, I_Printfs and I_Errors.
  //
  // -ACB- 1999/10/02 Don't print to console, since we don't have a console yet.
  //
  p = M_CheckParm("-debugfile");
  if (p)
  {
    char filename[128];
    int i = 1;

    // -ES- 1999/03/29 allow -debugfile &lt;file&gt;
    if (p + 1 &lt; M_GetArgCount() &amp;&amp; (ps = M_GetArgument(p + 1))[0] != '-')
    {
      Z_StrNCpy(filename, ps, 127);
    }
    else
    {
      // -KM- 1999/01/29 Consoleplayer is always 0 at this stage.
      sprintf(filename, "debug0.txt");
      while (I_Access(filename))
      {
        sprintf(filename, "debug%d.txt", i++);

        // give up: File system is probably corrupt. If not, there are 1000
        // debug files already, and it's about time to delete some of them...
        if (i &gt;= 1000)
          I_Error("E_EDGEMain: Couldn't create debug file!");
      }
    }
    debugfile = fopen(filename, "w");

    if (!debugfile)
      I_Error("E_EDGEMain: Unable to create debugfile");
    
    L_WriteDebug("%s\n",title);
  }
  else
  {
    debugfile = NULL;
  }

  // Assume that we are using a standard game setup...
  modifiedgame = false;

  // -ACB- 1999/09/20 defines to be used?
  CON_InitConsole(79, 25, false);

  // -ES- 1999/10/29 Declare all function lists.
  R_InitFunctions_Draw1();
#ifndef NOHICOLOUR
  R_InitFunctions_Draw2();
#endif
  R_InitVBFunctions();
  I_RegisterAssembler();
  I_PutTitle(title);

  ShowVersion();

  InitDirectories();

  // check for strict and no-warning options
  M_CheckBooleanParm("strict", &amp;strict_errors, false);
  M_CheckBooleanParm("warn", &amp;no_warnings, true);
  M_CheckBooleanParm("obsolete", &amp;no_obsoletes, true);
  M_CheckBooleanParm("lax", &amp;lax_errors, false);

  CheckExternal();

  DDF_MainInit();

  IdentifyVersion();

  if (devparm)
    I_Printf("%s", DDF_LanguageLookup("DevelopmentMode"));

  p = M_CheckParm("-turbo");
  if (p)
  {
    if (p + 1 &lt; M_GetArgCount())
      turbo_scale = atoi(M_GetArgument(p + 1));
    else
      turbo_scale = 200;

    if (turbo_scale &lt; 10)
      turbo_scale = 10;

    if (turbo_scale &gt; 400)
      turbo_scale = 400;

    CON_MessageLDF("TurboScale", turbo_scale);
  }

  G_SetTurboScale(turbo_scale);

  I_CheckCPU();

  ps = M_GetParm("-col8");
  if (ps)
    CON_ChooseFunctionFromList(&amp;drawcol8_funcs, ps);

  ps = M_GetParm("-span8");
  if (ps)
    CON_ChooseFunctionFromList(&amp;drawspan8_funcs, ps);

  ps = M_GetParm("-col16");
  if (ps)
    CON_ChooseFunctionFromList(&amp;drawcol16_funcs, ps);

  ps = M_GetParm("-span16");
  if (ps)
    CON_ChooseFunctionFromList(&amp;drawspan16_funcs, ps);

  p = M_CheckNextParm("-file", 0);
  while (p)
  {
    // the parms after p are wadfile/lump names,
    // until end of parms or another - preceded parm
    modifiedgame = true;

    p++;
    while (p &lt; M_GetArgCount() &amp;&amp; '-' != (ps = M_GetArgument(p))[0])
    {
      filename = M_ComposeFileName(gamedir, ps);
      W_AddRawFilename(filename, true);
      Z_Free(filename);
      p++;
    }

    p = M_CheckNextParm("-file", p-1);
  }

  ps = M_GetParm("-playdemo");

  if (!ps)
    ps = M_GetParm("-timedemo");

  if (ps)
  {
    filename = M_ComposeFileName(gamedir, ps);
    Z_Resize(filename, char, strlen(filename) + 5);
    strcat(filename, ".lmp");
    W_AddRawFilename(filename, false);
    I_Printf("Playing demo %s.\n", filename);
    Z_Free(filename);
  }

  // get skill / episode / map from parms
  startskill = sk_medium;
  autostart = false;

  // -KM- 1999/01/29 Use correct skill: 1 is easiest, not 0
  ps = M_GetParm("-skill");
  if (ps)
  {
    startskill = atoi(ps) - 1;
    autostart = true;
  }

  ps = M_GetParm("-timer");
  if (ps &amp;&amp; deathmatch)
  {
    int time;

    time = atoi(ps);
    I_Printf("Levels will end after %d minute", time);

    if (time &gt; 1)
      I_Printf("s");

    I_Printf(".\n");
  }

  ps = M_GetParm("-warp");
  if (ps)
  {
    startmap = Z_StrDup(ps);
    autostart = true;
  }
  else
  {
    startmap = Z_StrDup("MAP01"); // MUNDO HACK!!!!
  }

  // Cycle through all the startup functions, quit on failure.
  for (p=0; startcode[p].function != NULL; p++)
  {
    // Print Message On Screen
    if (startcode[p].LDFmessage)
      I_Printf(DDF_LanguageLookup(startcode[p].LDFmessage));

    // if the startup function fails - quit startup
    success = startcode[p].function();
    if (!success)
      return;
  }

  ps = M_GetParm("-screenshot");
  if (ps)
  {
    screenshot_rate = atoi(ps);
  }
  
  // start the appropriate game based on parms
  ps = M_GetParm("-record");
  if (ps)
  {
    G_RecordDemo(ps);
    autostart = true;
  }

  ps = M_GetParm("-playdemo");
  if (ps)
  {
    // quit after one demo
    singledemo = true;
    G_DeferedPlayDemo(ps);

    // never returns
    E_EDGELoop();
  }

  ps = M_GetParm("-timedemo");
  if (ps)
  {
    G_TimeDemo(ps);

    // never returns
    E_EDGELoop();
  }

  ps = M_GetParm("-loadgame");
  if (ps)
  {
    G_LoadGame(atoi(ps));
  }

  // -ACB- 1998/09/06 use new mapping system
  if (gameaction != ga_loadgame)
  {
    if (autostart || netgame)
    {
      // if startmap is failed, do normal start.
      if (! G_DeferedInitNew(startskill, startmap, true))
        E_StartTitle();

      Z_Free(startmap);
    }
    else
    {
      E_StartTitle();  // start up intro loop
    }
  }

  E_EDGELoop();  // never returns
}
</t>
<t tx="T1295">@ E_EngineShutdown
@c

void E_EngineShutdown(void)
{
  if (demorecording)
    G_CheckDemoStatus();

  S_StopMusic();
  E_QuitNetGame();
}
</t>
<t tx="T1296">@ignore
@language c

// Networking Code (OS independend parts)

// -MH- 1998/07/02 "shootupdown" --&gt; "true3dgameplay"
//
// -ACB- 1998/07/25 DEVELOPERS define for debugging
//                  Extended Settings output more descriptive
//
// -ACB- 1998/09/06 Removed the startmap/startepisode stuff
//
// -KM- 1998/12/21 3 monitor view works.
// TODO: Make sure DDF/RTS files are the same on all PC's on a network

&lt;&lt; e_net #includes &gt;&gt;
&lt;&lt; e_net declarations &gt;&gt;
@others
</t>
<t tx="T1297">#include "i_defs.h"
#include "e_net.h"

#include "con_main.h"
#include "ddf_main.h"
#include "g_game.h"
#include "gui_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "e_main.h"
#include "m_argv.h"
#include "m_fixed.h"
#include "m_menu.h"
#include "p_local.h"
#include "p_spec.h"
#include "p_bot.h"
#include "s_sound.h"
#include "version.h"
#include "z_zone.h"
</t>
<t tx="T1298">
#define NCMD_EXIT 0x80000000
#define NCMD_RETRANSMIT 0x40000000
#define NCMD_SETUP 0x20000000
#define NCMD_KILL 0x10000000  // kill game
#define NCMD_CHECKSUM 0x0fffffff

typedef struct
{
  int tics;
  // set false as nodes leave game
  boolean_t in_game;
  // set when local needs tics
  boolean_t remoteresend;
  // set when remote needs tics
  int resendto;
  int resendcount;
} netnode_t;

netnode_t *netnodes;
netnode_t *localnode;

doomcom_t *doomcom;
static doomdata_t *netbuffer;  // points inside doomcom

//
// NETWORKING
//
// gametic is the tic about to (or currently being) run
// maketic is the tick that hasn't had control made for it yet
// netnode-&gt;tics has the maketics for a node
//
// a gametic cannot be run until tics &gt; gametic for all netnodes
//
#define RESENDCOUNT 10
#define PL_DRONE 0x80  // bit flag in doomdata-&gt;player

int ticdup;
int maketic;

static int skiptics;
static int maxsend;  // BACKUPTICS/(2*ticdup)-1

int gametime;

// -KM- 1998/01/29 New Setup code.
static int setupflags;

// -ES- The server's random seed in netgames.
static long net_seed;

// Local communication (send packets to self) is always done through this,
// to simplify the system specifics.
static doomdata_t *localcom_queue;
static int localcom_size;

// true if there may be other nodes on the network
static int network_active = false;
</t>
<t tx="T1299">@ NetbufferSize

Returns the size of netbuffer. This depends on the number of tics to send
@c

static int NetBufferSize(void)
{
  return (int)&amp;(((doomdata_t *) 0)-&gt;cmds[netbuffer-&gt;numtics]);
}
</t>
<t tx="T1300">@ NetbufferChecksum

Calculates a checksum for netbuffer.
@c

static unsigned int NetBufferChecksum(void)
{
  unsigned c;
  int i, l;

  c = 0x1234567;

  l = (NetBufferSize() - (int)&amp;(((doomdata_t *) 0)-&gt;retransmitfrom)) / 4;
  for (i = 0; i &lt; l; i++)
    c += ((unsigned *)&amp;netbuffer-&gt;retransmitfrom)[i] * (i + 1);

  return c &amp; NCMD_CHECKSUM;
}
</t>
<t tx="T1301">@ ExpandTics
@c

static int ExpandTics(int low)
{
  int delta;

  delta = low - (maketic &amp; 0xff);

  if (delta &gt;= -64 &amp;&amp; delta &lt;= 64)
    return (maketic &amp; ~0xff) + low;
  if (delta &gt; 64)
    return (maketic &amp; ~0xff) - 256 + low;
  if (delta &lt; -64)
    return (maketic &amp; ~0xff) + 256 + low;

  I_Error("ExpandTics: strange value %i at maketic %i", low, maketic);
  return 0;
}
</t>
<t tx="T1302">@ HSendPacket
@c

static void HSendPacket(int node, int flags)
{
#if (DEBUG_NET)
  int i;
  int realretrans;
#endif

  netbuffer-&gt;checksum = NetBufferChecksum() | flags;

  if (node == consoleplayer-&gt;netnode)
  {
    // Send packet to self.
    localcom_size++;
    Z_Resize(localcom_queue, doomdata_t, localcom_size);
    localcom_queue[localcom_size - 1] = *netbuffer;
    return;
  }

  if (demoplayback)
    return;

  if (!netgame)
    I_Error("Tried to transmit to another node");

  doomcom-&gt;command = CMD_SEND;
  doomcom-&gt;remotenode = node;
  doomcom-&gt;datalength = NetBufferSize();

#if (DEBUG_NET)
  if (netbuffer-&gt;checksum &amp; NCMD_RETRANSMIT)
    realretrans = ExpandTics(netbuffer-&gt;retransmitfrom);
  else
    realretrans = -1;

  L_WriteDebug("HSendPacket: send %d (%i + %i, R %i) [%i] ",
      node,
      ExpandTics(netbuffer-&gt;starttic),
      netbuffer-&gt;numtics, realretrans, doomcom-&gt;datalength);

  for (i = 0; i &lt; doomcom-&gt;datalength; i++)
    L_WriteDebug("%i ", ((byte *) netbuffer)[i]);

  L_WriteDebug("\n");
#endif

  I_NetCmd();
}
</t>
<t tx="T1303">@ -KM- 1999/01/29 Recieves a setup packet. Should change settings instantly.
works at startup, needs a bit of work to fix for in-game changes.
@c

static boolean_t gotinfo[MAXNETNODES];
static void E_ReceiveSetupPacket(void)
{
  setupdata_t *packet = (setupdata_t *) &amp; doomcom-&gt;data;

  if (packet-&gt;info.version != DEMOVERSION)
    I_Error("EDGE Versions are incompatable!");

  packet-&gt;player &amp;= 0x7f;

  if (packet-&gt;info.drone)
  {
    if (packet-&gt;player)
      doomcom-&gt;drone |= 1 &lt;&lt; packet-&gt;player;
    else
      doomcom-&gt;drone = packet-&gt;info.drone;
  }

  if ((packet-&gt;checksum &amp; ~NCMD_CHECKSUM) != (unsigned int)setupflags)
    return;

  // This is an ACK Packet
  gotinfo[packet-&gt;player] = true;
  if (packet-&gt;player)
    return;

  global_flags = packet-&gt;info.setupflags;
  level_flags  = packet-&gt;info.setupflags;
  startskill = packet-&gt;info.skill;
  deathmatch = packet-&gt;info.deathmatch;

  if (gamestate != -1)
    I_Error("E_ReceiveSetupPacket: Can only be called at startup!");

  startmap = Z_StrDup(packet-&gt;info.startmap);

  net_seed = packet-&gt;info.random_seed;
//    else if (!currentmap || strcmp(packet-&gt;startmap, currentmap-&gt;ddf.name))
//      G_InitNew(packet-&gt;skill, DDF_LevelMapLookup(packet-&gt;startmap), packet-&gt;random_seed);

  // ACK setup packet
  packet-&gt;player = (byte)doomcom-&gt;consoleplayer;
  packet-&gt;info.drone = drone;

  HSendPacket(doomcom-&gt;remotenode, packet-&gt;checksum &amp; ~NCMD_CHECKSUM);
}
</t>
<t tx="T1304">@ HGetPacket
Returns false if no packet is waiting
@c

static boolean_t E_HGetPacket(void)
{
#if (DEBUG_NET)
  int realretrans;
  int i;
#endif

  if (localcom_size)
  {
    localcom_size--;
    *netbuffer = localcom_queue[localcom_size];
    Z_Resize(localcom_queue, doomdata_t, localcom_size);
    return true;
  }

  if (!netgame)
    return false;

  if (demoplayback)
    return false;

  if (!network_active)
    return false;
    
  doomcom-&gt;command = CMD_GET;
  I_NetCmd();

  // Some consistency checks
  if (doomcom-&gt;datalength != NetBufferSize())
  {
#if (DEBUG_NET)
    L_WriteDebug("E_HGetPacket: bad packet length %i\n",
doomcom-&gt;datalength);
#endif
    return false;
  }

  if (NetBufferChecksum() != (netbuffer-&gt;checksum &amp; NCMD_CHECKSUM))
  {
#if (DEBUG_NET)
    L_WriteDebug("E_HGetPacket: bad packet checksum %i\n",
doomcom-&gt;datalength);
#endif
    return false;
  }

  if (doomcom-&gt;remotenode == -1)
    return false;

  if (netbuffer-&gt;checksum &amp; NCMD_SETUP)
  {
    L_WriteDebug("E_HGetPacket: Setup packet %d\n", doomcom-&gt;remotenode);
    E_ReceiveSetupPacket();
    return true;
  }

#if (DEBUG_NET)
  if (netbuffer-&gt;checksum &amp; NCMD_RETRANSMIT)
    realretrans = ExpandTics(netbuffer-&gt;retransmitfrom);
  else
    realretrans = -1;

  L_WriteDebug("E_HGetPacket: get %i = (%i + %i, R %i)[%i] ",
      doomcom-&gt;remotenode,
      ExpandTics(netbuffer-&gt;starttic),
      netbuffer-&gt;numtics, realretrans, doomcom-&gt;datalength);

  for (i = 0; i &lt; doomcom-&gt;datalength; i++)
    L_WriteDebug("%i ", ((byte *) netbuffer)[i]);

  L_WriteDebug("\n");
#endif

  return true;
}
</t>
<t tx="T1305">@ GetPackets
@c

static void GetPackets(void)
{
  player_t *pl;
  netnode_t *netnode;
  int realend;
  int realstart;

  while (E_HGetPacket())
  {
    if (netbuffer-&gt;checksum &amp; NCMD_SETUP)
      continue;  // extra setup packet

    pl = playerlookup[netbuffer-&gt;player &amp; ~PL_DRONE];
    if (! pl)
      continue;

    if (netbuffer-&gt;player &amp; PL_DRONE)
      doomcom-&gt;drone |= 1 &lt;&lt; pl-&gt;pnum;

    netnode = &amp;netnodes[doomcom-&gt;remotenode];

    // to save bytes, only the low byte of tic numbers are sent
    // Figure out what the rest of the bytes are
    realstart = ExpandTics(netbuffer-&gt;starttic);
    realend = (realstart + netbuffer-&gt;numtics);

    // check for exiting the game
    if (netbuffer-&gt;checksum &amp; NCMD_EXIT)
    {
      if (!netnode-&gt;in_game)
        continue;
      netnode-&gt;in_game = false;
      P_RemovePlayerFromGame(pl);

      // -KM- 1998/12/21 Player numbers are 0 based, add 1.
      CON_Printf("Player %d left the game", pl-&gt;pnum + 1);

      if (demorecording)
        G_CheckDemoStatus();
      continue;
    }

    // check for a remote game kill
    if (netbuffer-&gt;checksum &amp; NCMD_KILL)
      I_Error("Killed by network driver");

    pl-&gt;netnode = netnode - netnodes;

    // check for retransmit request
    if (netnode-&gt;resendcount &lt;= 0
        &amp;&amp; (netbuffer-&gt;checksum &amp; NCMD_RETRANSMIT))
    {
      netnode-&gt;resendto = ExpandTics(netbuffer-&gt;retransmitfrom);

#if (DEBUG_NET)
      L_WriteDebug("GetPackets: retransmit from %i\n", netnode-&gt;resendto);
#endif
      netnode-&gt;resendcount = RESENDCOUNT;
    }
    else
      netnode-&gt;resendcount--;

    // check for out of order / duplicated packet  
    if (realend == netnode-&gt;tics)
      continue;

    if (realend &lt; netnode-&gt;tics)
    {

#if (DEBUG_NET)
      L_WriteDebug("out of order packet (%i + %i)\n",
          realstart, netbuffer-&gt;numtics);
#endif
      continue;
    }

    // check for a missed packet
    if (realstart &gt; netnode-&gt;tics)
    {
      // stop processing until the other system resends the missed tics

#if (DEBUG_NET)
      L_WriteDebug(
          "missed tics from %i (%i - %i)\n",
          (int)(netnode-netnodes), realstart, netnode-&gt;tics);
#endif
      netnode-&gt;remoteresend = true;
      continue;
    }

    // update command store from the packet
    {
      int start;
      ticcmd_t *cmd;

      netnode-&gt;remoteresend = false;

      start = netnode-&gt;tics - realstart;
      cmd = &amp;netbuffer-&gt;cmds[start];

      while (netnode-&gt;tics &lt; realend)
      {
        pl-&gt;netcmds[netnode-&gt;tics % BACKUPTICS] = *cmd;
        netnode-&gt;tics++;
        cmd++;
      }
    }
  }
}
</t>
<t tx="T1306">@ E_NetUpdate
Builds ticcmds for console player,
sends out a packet
@c

void E_NetUpdate(void)
{
  int nowtime;
  int newtics;
  int i, j;
  int realstart;
  int gameticdiv;
  ticcmd_t *cmd;
  netnode_t *netnode;
  player_t *p;

  // check time
  nowtime = I_GetTime() / ticdup;
  newtics = nowtime - gametime;
  gametime = nowtime;

  // -ACB- 1998/07/17 removed goto - educational note: GOTO's are best avoided.
  if (newtics &lt;= 0)
  {
    // nothing new to update
    GetPackets();
    return;
  }

  if (skiptics &lt;= newtics)
  {
    newtics -= skiptics;
    skiptics = 0;
  }
  else
  {
    skiptics -= newtics;
    newtics = 0;
  }

  // build new ticcmds for console player
  gameticdiv = gametic / ticdup;
  for (i = 0; i &lt; newtics; i++)
  {
    I_ControlGetEvents();
    E_ProcessEvents();
    if (maketic - gameticdiv &gt;= BACKUPTICS / 2 - 1)
      break;  // can't hold any more

    // think
    for (p = players; p; p = p-&gt;next)
    {
      if (p-&gt;thinker)
      {
        cmd = &amp;p-&gt;netcmds[maketic % BACKUPTICS];
        p-&gt;thinker(p, p-&gt;data, cmd);
        cmd-&gt;consistency = p-&gt;consistency[maketic % BACKUPTICS];
      }
    }

    maketic++;
  }

  if (singletics)
    return;  // singletic update is syncronous

  // send packets from all local players
  for (p = players; p; p = p-&gt;next)
  {
    // thinker is only set on local players, net players will be updated over
    // the network.
    if (p-&gt;thinker)
    {
      // Prepare and send the packet to the other nodes
      for (i = 0, netnode = netnodes; i &lt; doomcom-&gt;numnodes; i++, netnode++)
      {
        if (netnode-&gt;in_game)
        {
          netbuffer-&gt;player = p-&gt;pnum;
          netbuffer-&gt;starttic = realstart = netnode-&gt;resendto;
          netbuffer-&gt;numtics = maketic - realstart;
          if (netbuffer-&gt;numtics &gt; BACKUPTICS)
            I_Error("NetUpdate: netbuffer-&gt;numtics &gt; BACKUPTICS");
          for (j = 0; j &lt; netbuffer-&gt;numtics; j++)
            netbuffer-&gt;cmds[j] = p-&gt;netcmds[(realstart + j) % BACKUPTICS];
          netnode-&gt;resendto = maketic - doomcom-&gt;extratics;
    
          if (netnode-&gt;remoteresend)
          {
            netbuffer-&gt;retransmitfrom = netnode-&gt;tics;
            HSendPacket(i, NCMD_RETRANSMIT);
          }
          else
          {
            netbuffer-&gt;retransmitfrom = 0;
            HSendPacket(i, 0);
          }
        }
      }
    }
  }

  GetPackets();
}
</t>
<t tx="T1307">@ E_CheckAbort
@c

static void E_CheckAbort(void)
{
  event_t *ev;
  int stoptic;

  stoptic = I_GetTime() + 2;
  while (I_GetTime() &lt; stoptic)
    I_ControlGetEvents();

  I_ControlGetEvents();
  for (; eventtail != eventhead; eventtail = (++eventtail) &amp; (MAXEVENTS - 1))
  {
    ev = &amp;events[eventtail];
    if (ev-&gt;type == ev_keydown &amp;&amp; ev-&gt;value.key == KEYD_ESCAPE)
      I_Error("Network game synchronization aborted.");
  }
}
</t>
<t tx="T1308">
static void E_PrintSetupPacket(void)
{
  // -ACB- 1998/07/25 Display the current settings

  I_Printf("             True3D: %s\n",
      global_flags.true3dgameplay ? "On" : "Off");
  I_Printf("   Enemy Respawning:\n");
  if (global_flags.res_respawn)
    I_Printf("       Resurrection:");
  else
    I_Printf("           Teleport:");
  I_Printf(global_flags.respawn ? "On\n" : "Off\n");

  // Shows enabled even if not set with altdeath
  I_Printf("       Item Respawn: %s\n",
      global_flags.itemrespawn ? "On" : "Off");

  I_Printf("      Gravity Level: %1.1f\n",
    (float_t)global_flags.menu_grav / (float_t)MENU_GRAV_NORMAL);

  I_Printf("           Fastparm: %s\n", global_flags.fastparm ? "On" : "Off");
  I_Printf("         More Blood: %s\n", global_flags.more_blood ? "On" : "Off");
  I_Printf("            Jumping: %s\n", global_flags.jump ? "On" : "Off");
  I_Printf("          Crouching: %s\n", global_flags.crouch ? "On" : "Off");
  I_Printf("              Mlook: %s\n", global_flags.mlook ? "On" : "Off");
  I_Printf("       Translucency: %s\n", global_flags.trans ? "On" : "Off");
  I_Printf("           Monsters: %s\n", global_flags.nomonsters ? "Off" : "On");
  I_Printf("             Extras: %s\n", global_flags.have_extra ? "On" : "Off");
}
</t>
<t tx="T1309">
void E_SendSetupPacket(int flags)
{
  setupdata_t *packet = (setupdata_t *) &amp; doomcom-&gt;data;
  int i;
  boolean_t done;

  net_seed = I_PureRandom();

  // Only player 0 can send setup packets
  if (doomcom-&gt;consoleplayer)
    return;

  memset(gotinfo, false, sizeof(boolean_t)*MAXNETNODES);
  setupflags = flags;

  do
  {
    E_CheckAbort();
    L_WriteDebug("Sending Setup Packet...\n");
    done = true;
    for (i = 1; i &lt; doomcom-&gt;numnodes; i++)
    {
      if (gotinfo[i])
        continue;

      done = false;
      packet-&gt;info.version = DEMOVERSION;
      packet-&gt;player = (byte)doomcom-&gt;consoleplayer;
      packet-&gt;info.deathmatch = deathmatch;
      packet-&gt;info.drone = (byte)doomcom-&gt;drone;
      packet-&gt;info.random_seed = net_seed;
      
      if ((int)gamestate == -1)
      {
        unsigned int len;

        len = sizeof(doomdata_t) - sizeof(setupdata_t);
        if (len &lt; strlen(startmap))
          I_Error("Startmap name '%s' too long (max is %d chars)", startmap, len);

        strcpy(packet-&gt;info.startmap, startmap);
        packet-&gt;info.skill = startskill;
        packet-&gt;info.setupflags = global_flags;
      }
      else
      {
        I_Error("E_SendSetupPacket: Can only be called at startup");
//        packet-&gt;info.skill = gameskill;
//        if (currentmap)
//          strcpy(packet-&gt;startmap, currentmap-&gt;ddf.name);  // FIXME
//        else
//          packet-&gt;startmap[0] = 0;
//
//        packet-&gt;info.setupflags = level_flags;
      }
      // number of ticcmds is total_size/ticcmd_size rounded up
      packet-&gt;numtics = (sizeof(setup_info_t) + strlen(packet-&gt;info.startmap) +
         sizeof(ticcmd_t) - 1) / sizeof(ticcmd_t);
      HSendPacket(i, flags);
    }

    while (E_HGetPacket())
      ;
  }
  while (!done);
}
</t>
<t tx="T1310">@ E_ArbitrateNetStart

-ACB- 1998/07/25 Cleaned up the extended settings; Output more descriptive.
@c

static void E_ArbitrateNetStart(void)
{
  autostart = true;

  if (doomcom-&gt;consoleplayer != 0)
  {
    // listen for setup info from key player
    CON_Message("ListenNet");
    memset(gotinfo, false, sizeof(gotinfo));
    setupflags = NCMD_SETUP;
    while (!gotinfo[0])
    {
      E_HGetPacket();
      E_CheckAbort();
    }
    E_PrintSetupPacket();
    memset(gotinfo, false, sizeof(gotinfo));
    setupflags = NCMD_SETUP | NCMD_EXIT;
    do
    {
      E_HGetPacket();
      E_CheckAbort();
    }
    while (!gotinfo[0]);
  }
  else
  {
    // key player, send the setup info
    CON_Message("SendNet");
    E_PrintSetupPacket();
    E_SendSetupPacket(NCMD_SETUP);
    E_SendSetupPacket(NCMD_EXIT | NCMD_SETUP);
  }
}
</t>
<t tx="T1311">@ E_QuitNetGame
Called before quitting to leave a net game
without hanging the other players
@c

void E_QuitNetGame(void)
{
  int i, j;

  if (!netgame || !usergame || consoleplayer == NULL || demoplayback)
    return;

  // send a bunch of packets for security
  netbuffer-&gt;player = consoleplayer-&gt;pnum;
  if (drone)
    netbuffer-&gt;player |= PL_DRONE;
  netbuffer-&gt;numtics = 0;
  for (i = 0; i &lt; 4; i++)
  {
    for (j = 1; j &lt; doomcom-&gt;numnodes; j++)
      if (netnodes[j].in_game)
        HSendPacket(j, NCMD_EXIT);
    I_WaitVBL(1);
  }
}
</t>
<t tx="T1312">@ E_TryRunTics
@c

void E_TryRunTics(void)
{
  static int oldentertics;
  static int frameskip[4] = {0,0,0,0};
  static int oldnettics = -1;
  static int frameon = 0;
  int i;
  player_t *p;
  int lowtic;
  int entertic;
  int realtics;
  int availabletics;
  int counts;
  netnode_t *netnode;

  // get real tics  
  entertic = I_GetTime() / ticdup;
  realtics = entertic - oldentertics;
  oldentertics = entertic;

  // get available tics
  E_NetUpdate();

  lowtic = INT_MAX;

  for (i = 0, netnode = netnodes; i &lt; doomcom-&gt;numnodes; i++, netnode++)
  {
    if (netnode-&gt;in_game)
    {
      if (netnode-&gt;tics &lt; lowtic)
        lowtic = netnode-&gt;tics;
    }
  }
  availabletics = lowtic - gametic / ticdup;

  // decide how many tics to run
  if (realtics &lt; availabletics - 1)
    counts = realtics + 1;
  else if (realtics &lt; availabletics)
    counts = realtics;
  else
    counts = availabletics;

  if (counts &lt; 1)
    counts = 1;

  frameon++;

#if (DEBUG_NET)
  L_WriteDebug("=======real: %i  avail: %i  game: %i\n",
      realtics, availabletics, counts);
#endif

  if (!demoplayback)
  {
    // ideally nettics[0] should be 1 - 3 tics above lowtic
    // if we are consistantly slower, speed up time
    for (p = players; p; p = p-&gt;next)
    {
      if (p-&gt;in_game)
        break;
    }

    DEV_ASSERT2(p);

    // the key player does not adapt
    if (consoleplayer != p)
    {
      i = netnodes[p-&gt;netnode].tics;
      if (netnodes[0].tics &lt;= i)
        gametime--;
      frameskip[frameon &amp; 3] = (oldnettics &gt; i);
      oldnettics = netnodes[0].tics;
      if (frameskip[0] &amp;&amp; frameskip[1] &amp;&amp; frameskip[2] &amp;&amp; frameskip[3])
        skiptics = 1;
    }
  }  // demoplayback

  // wait for new tics if needed
  while (lowtic &lt; gametic / ticdup + counts)
  {
    E_NetUpdate();
    lowtic = INT_MAX;

    for (i = 0, netnode = netnodes; i &lt; doomcom-&gt;numnodes; i++, netnode++)
      if (netnode-&gt;in_game &amp;&amp; netnode-&gt;tics &lt; lowtic)
        lowtic = netnode-&gt;tics;

    if (lowtic &lt; gametic / ticdup)
      I_Error("TryRunTics: lowtic &lt; gametic");

    // don't stay in here forever -- give the menu a chance to work
    if (I_GetTime() / ticdup - entertic &gt;= 20)
    {
      GUI_MainTicker();
      M_Ticker();
      return;
    }

  }

  // run the count * ticdup dics
  while (counts--)
  {
    for (i = 0; i &lt; ticdup; i++)
    {
      if (gametic / ticdup &gt; lowtic)
        I_Error("gametic&gt;lowtic");
    
      if (advancedemo)
        E_DoAdvanceDemo();
      
      GUI_MainTicker();
      M_Ticker();
      G_Ticker();
      S_SoundTicker(); // -ACB- 1999/10/11 Improved sound update routines
      S_MusicTicker(); // -ACB- 1999/11/13 Improved music update routines
      gametic++;

      // modify command for duplicated tics
      if (i != ticdup - 1)
      {
        ticcmd_t *cmd;
        int buf;

        buf = (gametic / ticdup) % BACKUPTICS;
        for (p = players; p; p = p-&gt;next)
        {
          cmd = &amp;p-&gt;netcmds[buf];
          cmd-&gt;chatchar = 0;
          if (cmd-&gt;buttons &amp; BT_SPECIAL)
            cmd-&gt;buttons = 0;
        }
      }
    }
    E_NetUpdate();  // check for new console commands
  }
}
</t>
<t tx="T1313">@ E_NetGetRandomSeed

Returns the random seed for the level. In multiplayer, this is received
from the server, in single player it's created.
@c

long E_NetGetRandomSeed(void)
{
  if (network_active)
    return net_seed;
  else
    return I_PureRandom();
}
</t>
<t tx="T1314">@ E_CheckNetGame

Works out player numbers among the net participants

-KM- 1999/01/29 Fixed network play for 3 view and normal play.
@c

boolean_t E_CheckNetGame(void)
{
  int i;
  float_t f;
  const char *s;

  //
  // -ES- Major fixme: Clean up netnodes. They should be more dynamic,
  // players should not depend on different DDF entries (they should all
  // use the same entry), and btw C/S networking should be used instead.
  //
  netnodes = Z_ClearNew(netnode_t, MAXPLAYERS);

  for (i = 0; i &lt; MAXPLAYERS; i++)
  {
    netnodes[i].in_game = false;
    netnodes[i].tics = 0;
    netnodes[i].remoteresend = false;  // set when local needs tics

    netnodes[i].resendto = 0;  // which tic to start sending
  }

  doomcom = Z_ClearNew(doomcom_t, 1);

  netgame = false;
  doomcom-&gt;id = DOOMCOM_ID;
  doomcom-&gt;numplayers = doomcom-&gt;numnodes = 1;
  doomcom-&gt;deathmatch = 0;
  doomcom-&gt;consoleplayer = 0;
  doomcom-&gt;extratics = 0;
  doomcom-&gt;ticdup = 1;

  // I_InitNetwork sets doomcom and netgame if networking will be done
  I_InitNetwork();

  if (doomcom-&gt;id != DOOMCOM_ID)
    I_Error("Doomcom buffer invalid!");

  if (doomcom-&gt;numnodes &gt; 1)
    network_active = true;

  // Additional players will be paralysed unless they are bots
  if (doomcom-&gt;numplayers == 1)
  {
    s = M_GetParm("-players");
    if (s)
    {
      doomcom-&gt;numplayers = atoi(s);
    }
  }
  else
    netgame = true;

  if (doomcom-&gt;numplayers &gt; MAXPLAYERS)
    I_Error("E_CheckNetGame: Only %d player entries in DDF, %d required", MAXPLAYERS, doomcom-&gt;numplayers);

  for (i = 0; i &lt; doomcom-&gt;numplayers; i++)
    if (! playerlookup[i])
      I_Error("E_CheckNetGame: Missing DDF entry for player %d!", i);

  // -ES- FIXME: Need a better bot adding system when multiplayer over network
  // is possible
  s = M_GetParm("-bots");
  if (s)
  {
    I_Printf("  Bots: ");
    i = atoi(s);
    if (i &gt; doomcom-&gt;numplayers-1)
      I_Error("E_CheckNetGame: More bots than available players!");
    for (; i &gt; 0; i--)
    {
      P_BotCreate(playerlookup[i]);
      I_Printf("%d", i + 1);
      if (i &gt; 1)
        I_Printf(", ");
    }
    I_Printf("\n");
    netgame = true;
  }

  netbuffer = &amp;doomcom-&gt;data;
  consoleplayer = displayplayer = playerlookup[doomcom-&gt;consoleplayer];

  // -ES- Fixme: This belongs somewhere else (around G_PlayerReborn).
  // Needs a big cleanup though.
  consoleplayer-&gt;thinker = P_ConsolePlayerThinker;
  consoleplayer-&gt;data = NULL;

  //
  // -viewangle &lt;angle&gt; [num]
  //
  // Offsets the viewangle by &lt;angle&gt; degrees.
  // Set the displayplayer to num if passed.
  //
  i = M_CheckParm("-viewangle");
  if (i &amp;&amp; i + 1 &lt; M_GetArgCount())
  {
    sscanf(M_GetArgument(i + 1), "%f", &amp;f);
    viewanglebaseoffset = ANG1 * f;
    if (netgame)
    {
      drone = true;
      doomcom-&gt;drone |= 1 &lt;&lt; consoleplayer-&gt;pnum;
    }

    // -KM- 1998/12/21 Find the display player.
    //  EDGE has enough network players for
    //  more than one persone with 3 monitors each.
    if (i + 1 &gt;= M_GetArgCount() || (1 != sscanf(M_GetArgument(i + 2), "%d", &amp;i)))
      i = 0;
      
    displayplayer = playerlookup[i];
  }

  if (netgame)
    E_ArbitrateNetStart();

  I_Printf("  startmap: %s  startskill: %i  deathmatch: %i\n", startmap, startskill, deathmatch);

  // read values out of doomcom
  ticdup = doomcom-&gt;ticdup;
  maxsend = BACKUPTICS / (2 * ticdup) - 1;
  if (maxsend &lt; 1)
    maxsend = 1;

  for (i = 0; i &lt; doomcom-&gt;numplayers; i++)
    if (playerlookup[i])
      P_AddPlayerToGame(playerlookup[i]);

  for (i = 0; i &lt; doomcom-&gt;numnodes; i++)
    netnodes[i].in_game = true;

  I_Printf("  Console: Player %i of %i (%i nodes)\n",
      consoleplayer-&gt;pnum + 1, doomcom-&gt;numplayers, doomcom-&gt;numnodes);

  return true;
}
</t>
<t tx="T1315">@ignore
@language c

// EDGE Finale Code on Game Completion

// -KM- 1998/07/21 Clear the background behind those end pics.
// -KM- 1998/09/27 sounds.ddf stuff: seesound -&gt; DDF_LookupSound(seesound)
// -KM- 1998/11/25 Finale generalised.

&lt;&lt; f_finale #includes &gt;&gt;
&lt;&lt; f_finale declarations &gt;&gt;
@others
</t>
<t tx="T1316">#include "i_defs.h"
#include "f_finale.h"

#include "ddf_main.h"
#include "dm_state.h"
#include "dstrings.h"
#include "hu_lib.h"
#include "hu_stuff.h"
#include "m_random.h"
#include "m_swap.h"
#include "p_action.h"
#include "r2_defs.h"
#include "r_state.h"
#include "s_sound.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "v_res.h"
#include "z_zone.h"
#include "w_wad.h"
</t>
<t tx="T1317">
typedef enum
{
  f_text,
  f_pic,
  f_bunny,
  f_cast,
  f_end
}
finalestage_t;

// Stage of animation:
//  0 = text, 1 = art screen, 2 = character cast
static finalestage_t finalestage;

// -ES- 2000/03/11 skip to the next finale stage
static boolean_t skip_finale;
static int finalecount;
static int picnum;

#define TEXTSPEED 3
#define TEXTWAIT  250

static const char *finaletext;

static gameaction_t newgameaction;
static const finale_t *finale;
static void StartCast(void);
static void CastTicker(void);
static boolean_t CastResponder(event_t * ev);

static const image_t *finale_textback;
static float_t finale_textbackscale;
static const image_t *finale_bossback;
</t>
<t tx="T1318">@ F_StartFinale
@c

void F_StartFinale(const finale_t * f, gameaction_t newaction)
{
  player_t *p;

  finalestage = f_text;
  finalecount = 0;
  gameaction = ga_nothing;
  viewactive = false;
  automapactive = false;
  finale = f;
  newgameaction = newaction;
  picnum = 0;
  
  for (p = players; p; p = p-&gt;next)
    p-&gt;cmd.buttons = 0;

  // here is where we lookup the required images

  if (f-&gt;text_flat[0])
  {
    finale_textback = W_ImageFromFlat(f-&gt;text_flat);
    finale_textbackscale = 5.0;
  }
  else if (f-&gt;text_back[0])
  {
    finale_textback = W_ImageFromPatch(f-&gt;text_back);
    finale_textbackscale = 1.0;
  }
  else
  {
    finale_textback = NULL;
  }

  finale_bossback = W_ImageFromPatch("BOSSBACK");

  F_Ticker();
}
</t>
<t tx="T1319">
boolean_t F_Responder(event_t * event)
{
  int i;

  if (finalestage == f_cast)
    return CastResponder(event);

  if (event-&gt;type != ev_keydown)
    return false;
    
  // -ES- 2000/02/27 Hack: The first parts of the final stage may be
  // accelerated, but not the last one, so we have to check if there are
  // any more to do.
  for (i = f_end-1; i &gt; finalestage; i--)
  {
    if ((i == f_cast &amp;&amp; finale-&gt;docast) || (i == f_bunny &amp;&amp; finale-&gt;dobunny)
       || (i == f_pic &amp;&amp; finale-&gt;pics) || (i == f_text &amp;&amp; finale-&gt;text))
      break;
  }

  // Skip finale if there either is a next final stage, or if there is a next
  // sub-stage (for the two-stage text acceleration)
  if (i &gt; finalestage ||
      (finalestage == f_text &amp;&amp;
       (unsigned int)finalecount &lt; (TEXTSPEED * strlen(DDF_LanguageLookup(finale-&gt;text)))))
  {
    skip_finale = true;
    return true;
  }

  return false;
}
</t>
<t tx="T1320">@ F_Ticker
@c

void F_Ticker(void)
{
  int fstage = finalestage;

  if (skip_finale)
  {
    skip_finale = false;
    if (finalestage == f_text &amp;&amp; 
        (unsigned int)finalecount &lt; TEXTSPEED * strlen(DDF_LanguageLookup(finale-&gt;text)))
    {
      // -ES- 2000/03/08 Two-stage text acceleration. Complete the text the
      // first time, skip to next finale the second time.
      finalecount = TEXTSPEED * strlen(DDF_LanguageLookup(finale-&gt;text));
    }
    else
    {
      finalestage++;
      finalecount = 0;
    }
  }

  switch (finalestage)
  {
    case f_text:
      if (finale-&gt;text)
      {
        gamestate = GS_FINALE;
        if (!finalecount)
        {
          finaletext = DDF_LanguageLookup(finale-&gt;text);
          S_ChangeMusic(finale-&gt;music, true);
          wipegamestate = -1;
          break;
        }
        else if ((unsigned int)finalecount &gt; strlen(finaletext) * TEXTSPEED + TEXTWAIT)
        {
          finalecount = 0;
        }
        else
          break;
      }
      finalestage++;
    case f_pic:
      if (finale-&gt;pics)
      {
        gamestate = GS_FINALE;
        if ((unsigned int)finalecount &gt; finale-&gt;picwait)
        {
          finalecount = 0;
          picnum++;
        }

        if ((unsigned int)picnum &gt;= finale-&gt;numpics)
        {
          finalecount = 0;
          picnum = 0;
        }
        else
          break;
      }
      finalestage++;
    case f_bunny:
      if (finale-&gt;dobunny)
      {
        gamestate = GS_FINALE;
        if (!finalecount)
          // force a wipe
          wipegamestate = -1;

        break;
      }
      finalestage++;
    case f_cast:
      if (finale-&gt;docast)
      {
        gamestate = GS_FINALE;
        if (!finalecount)
          StartCast();
        else
          CastTicker();
        break;
      }
      finalestage++;
    case f_end:
      if (newgameaction != ga_nothing)
        gameaction = newgameaction;
      else
        finalestage = fstage;
      break;
  }

  if (finalestage != (finalestage_t)fstage &amp;&amp; finalestage != f_end)
    wipegamestate = -1;

  // advance animation
  finalecount++;

}
</t>
<t tx="T1321">@ TextWrite
@c

static void TextWrite(void)
{
  int count;
  const char *ch;
  int c, cx, cy;
  hu_textline_t L;

  // 98-7-10 KM erase the entire screen to a tiled background
  if (finale_textback)
    vctx.DrawImage(0, 0, SCREENWIDTH, SCREENHEIGHT, finale_textback,
         0.0, 0.0, IM_RIGHT(finale_textback) * finale_textbackscale,
         IM_BOTTOM(finale_textback) * finale_textbackscale, NULL, 1.0);
   
  // draw some of the text onto the screen
  cx = 10;
  cy = 10;
  ch = finaletext;

  count = (finalecount - 10) / finale-&gt;text_speed;
  if (count &lt; 0)
    count = 0;

  HL_InitTextLine(&amp;L, 10, cy, &amp;hu_font);

  for (;;)
  {
    if (count == 0 || !(*ch))
    {
      HL_DrawTextLineTrans(&amp;L, false, text_red_map);
      break;
    }

    c = *ch++;
    count--;

    if (c == '\n')
    {
      cy += 11;
      HL_DrawTextLineTrans(&amp;L, false, text_red_map);
      HL_InitTextLine(&amp;L, 10, cy, &amp;hu_font);
      continue;
    }

    HL_AddCharToTextLine(&amp;L, c);
  }
}
</t>
<t tx="T1322">@ Final DOOM 2 animation
Casting by id Software.
in order of appearance
@c

static const mobjinfo_t *castorder;
static int casttics;
static state_t *caststate;
static boolean_t castdeath;
static int castframes;
static int castonmelee;
static boolean_t castattacking;
static int shotsfxchannel = -1;

//
// CastSetState, CastPerformAction
// 
// -AJA- 2001/05/28: separated this out from CastTicker
// 
static void CastSetState(statenum_t st)
{
  if (st == S_NULL)
    return;

  caststate = &amp;states[st];

  casttics = caststate-&gt;tics;
  if (casttics &lt; 0)
    casttics = 15;
}
</t>
<t tx="T1323">
static void CAST_RangeAttack(const attacktype_t *range)
{
  sfx_t *sfx = NULL;

  DEV_ASSERT2(range);

  // special handling for shot attacks (AJA: dunno why)
  if (range-&gt;attackstyle == ATK_SHOT)
  {
    sfx = range-&gt;sound;
    
    if (sfx &amp;&amp; shotsfxchannel &gt;= 0)
      S_StopChannel(shotsfxchannel);
    
    if (sfx)
      shotsfxchannel = S_StartSound(NULL, sfx);

    return;
  }

  if (range-&gt;attackstyle == ATK_SKULLFLY)
  {
    sfx = range-&gt;initsound;
  }
  else if (range-&gt;attackstyle == ATK_SPAWNER)
  {
    if (range-&gt;spawnedobj &amp;&amp; range-&gt;spawnedobj-&gt;rangeattack)
      sfx = range-&gt;spawnedobj-&gt;rangeattack-&gt;initsound;
  }
  else if (range-&gt;attackstyle == ATK_TRACKER)
  {
    sfx = range-&gt;initsound;
  }
  else if (range-&gt;atk_mobj)
  {
    sfx = range-&gt;atk_mobj-&gt;seesound;
  }

  if (sfx)
    S_StartSound(NULL, sfx);
}
</t>
<t tx="T1324">
static void CastPerformAction(void)
{
  sfx_t *sfx = NULL;

  // Yuk, handles sounds

  if (caststate-&gt;action == P_ActMakeCloseAttemptSound)
  {
    if (castorder-&gt;closecombat)
      sfx = castorder-&gt;closecombat-&gt;initsound;
  }
  else if (caststate-&gt;action == P_ActMeleeAttack)
  {
    if (castorder-&gt;closecombat)
      sfx = castorder-&gt;closecombat-&gt;sound;
  }
  else if (caststate-&gt;action == P_ActMakeRangeAttemptSound)
  {
    if (castorder-&gt;rangeattack)
      sfx = castorder-&gt;rangeattack-&gt;initsound;
  }
  else if (caststate-&gt;action == P_ActRangeAttack)
  {
    if (castorder-&gt;rangeattack)
      CAST_RangeAttack(castorder-&gt;rangeattack);
  }
  else if (caststate-&gt;action == P_ActComboAttack)
  {
    if (castonmelee &amp;&amp; castorder-&gt;closecombat)
    {
      sfx = castorder-&gt;closecombat-&gt;sound;
    }
    else if (castorder-&gt;rangeattack)
    {
      CAST_RangeAttack(castorder-&gt;rangeattack);
    }
  }
  else if (castorder-&gt;activesound &amp;&amp; (M_Random() &lt; 2) &amp;&amp; !castdeath)
  {
    sfx = castorder-&gt;activesound;
  }
  else if (caststate-&gt;action == P_ActWalkSoundChase)
  {
    sfx = castorder-&gt;walksound;
  }

  if (sfx)
    S_StartSound(NULL, sfx);
}
</t>
<t tx="T1325">@ StartCast
@c

static void StartCast(void)
{
  wipegamestate = -1;  // force a screen wipe

  castorder = DDF_MobjLookupCast(2);
  castdeath = false;
  castframes = 0;
  castonmelee = 0;
  castattacking = false;

  CastSetState(castorder-&gt;chase_state);
 
  // S_ChangeMusic("d_evil", true);
}
</t>
<t tx="T1326">@ CastTicker

-KM- 1998/10/29 Use sfx_t.
Known bug: Chaingun/Spiderdemon's sounds aren't stopped.
@c

static void CastTicker(void)
{
  int st;

  // time to change state yet ?
  casttics--;
  if (casttics &gt; 0)
    return;

  // switch from deathstate to next monster
  if (caststate-&gt;tics == -1 || caststate-&gt;nextstate == S_NULL ||
      (castdeath &amp;&amp; castframes &gt;= 30))
  {
    castorder = DDF_MobjLookupCast(castorder-&gt;castorder + 1);
    castframes = 0;
    castdeath = false;
    castattacking = false;

    DEV_ASSERT2(castorder-&gt;chase_state);  // checked in ddf_mobj.c
    CastSetState(castorder-&gt;chase_state);

    if (castorder-&gt;seesound)
      S_StartSound(NULL, castorder-&gt;seesound);

    return;
  }

  CastPerformAction();

  // advance to next state in animation
  // -AJA- if there's a jumpstate, enter it occasionally

  if (caststate-&gt;jumpstate &amp;&amp; (M_Random() &lt; 64))
    st = caststate-&gt;jumpstate;
  else
    st = caststate-&gt;nextstate;

  CastSetState(st);
  castframes++;

  // go into attack frame
  if (castframes == 24 &amp;&amp; !castdeath)
  {
    castonmelee ^= 1;
    st = castonmelee ? castorder-&gt;melee_state : castorder-&gt;missile_state;

    if (st == S_NULL)
    {
      castonmelee ^= 1;
      st = castonmelee ? castorder-&gt;melee_state : castorder-&gt;missile_state;
    }

    // check if missing both melee and missile states
    if (st != S_NULL)
    {
      castattacking = true;
      CastSetState(st);

      if (castorder-&gt;attacksound)
        S_StartSound(NULL, castorder-&gt;attacksound);
    }
  }

  // leave attack frames after a certain time
  if (castattacking &amp;&amp; (castframes == 48 || 
        caststate == &amp;states[castorder-&gt;chase_state]))
  {
    castattacking = false;
    castframes = 0;
    CastSetState(castorder-&gt;chase_state);
  }
}
</t>
<t tx="T1327">@ CastResponder
@c

static boolean_t CastResponder(event_t * ev)
{
  if (ev-&gt;type != ev_keydown)
    return false;

  if (castdeath)
    return true;  // already in dying frames

  // go into death frame
  castdeath = true;

  if (castorder-&gt;overkill_state &amp;&amp; (M_Random() &lt; 32))
    caststate = &amp;states[castorder-&gt;overkill_state];
  else
  {
    DEV_ASSERT2(castorder-&gt;death_state);  // checked in ddf_mobj.c
    caststate = &amp;states[castorder-&gt;death_state];
  }

  casttics = caststate-&gt;tics;
  castframes = 0;
  castattacking = false;

  if (castorder-&gt;deathsound)
    S_StartSound(NULL, castorder-&gt;deathsound);

  return true;
}
</t>
<t tx="T1328">
static void CastPrint(char *text)
{
  HL_WriteText(160 - HL_StringWidth(text)/2, 180, text);
}
</t>
<t tx="T1329">@ CastDrawer
@c

static void CastDrawer(void)
{
  const image_t *image;
  boolean_t flip;

  // erase the entire screen to a background
  // -KM- 1998/07/21 Clear around the pic too.
  DEV_ASSERT2(finale_bossback);
  VCTX_Image(0, 0, SCREENWIDTH, SCREENHEIGHT, finale_bossback);

  CastPrint(castorder-&gt;ddf.name);

  // draw the current frame in the middle of the screen
  image = R2_GetOtherSprite(caststate-&gt;sprite, caststate-&gt;frame, &amp;flip);

  if (! image)
    return;

  vctx.DrawImage(FROM_320(160 - image-&gt;offset_x),
                 FROM_200(170 - image-&gt;offset_y), 
                 FROM_320(IM_WIDTH(image)), 
                 FROM_200(IM_HEIGHT(image)), image,
                 flip ? IM_RIGHT(image) : 0, 0,
                 flip ? 0 : IM_RIGHT(image), IM_BOTTOM(image),
                 NULL, 1.0);
}
</t>
<t tx="T1330">@ BunnyScroll

-KM- 1998/07/31 Made our bunny friend take up more screen space.
-KM- 1998/12/16 Removed fading routine.
@c

static void BunnyScroll(void)
{
  int scrolled;
  const image_t *p1;
  const image_t *p2;
  char name[10];
  int stage;
  static int laststage;

  p1 = W_ImageFromPatch("PFUB2");
  p2 = W_ImageFromPatch("PFUB1");

  scrolled = 320 - (finalecount - 230) / 2;

  if (scrolled &gt; 320)
    scrolled = 320;
  if (scrolled &lt; 0)
    scrolled = 0;

  // 23-6-1998 KM Changed the background colour to black not real dark grey
  // -KM- 1998/07/21  Replaced SCREENWIDTH*BPP with SCREENPITCH (two places)
 
  VCTX_Image320(0   - scrolled, 0, 320, 200, p1);
  VCTX_Image320(320 - scrolled, 0, 320, 200, p2);

  if (finalecount &lt; 1130)
    return;
  
  if (finalecount &lt; 1180)
  {
    p1 = W_ImageFromPatch("END0");

    VCTX_ImageEasy320((320 - 13 * 8) / 2, (200 - 8 * 8) / 2, p1);
    laststage = 0;
    return;
  }

  stage = (finalecount - 1180) / 5;
  
  if (stage &gt; 6)
    stage = 6;
  
  if (stage &gt; laststage)
  {
    S_StartSound(NULL, sfx_pistol);
    laststage = stage;
  }

  sprintf(name, "END%i", stage);

  p1 = W_ImageFromPatch(name);

  VCTX_ImageEasy320((320 - 13 * 8) / 2, (200 - 8 * 8) / 2, p1);
}
</t>
<t tx="T1331">@ F_Drawer
@c

void F_Drawer(void)
{
  switch (finalestage)
  {
    case f_text:
      TextWrite();
      break;

    case f_pic:
      {
        const image_t *image = W_ImageFromPatch(
            finale-&gt;pics + (picnum * 9));

        VCTX_Image320(0, 0, 320, 200, image);
      }
      break;
      
    case f_bunny:
      BunnyScroll();
      break;
      
    case f_cast:
      CastDrawer();
      break;

    case f_end:
      break;
  }
}
</t>
<t tx="T1332">@ignore
@language c

// Game Handling Code

// -MH- 1998/07/02 Added key_flyup and key_flydown variables (no logic yet)
// -MH- 1998/08/18 Flyup and flydown logic

&lt;&lt; g_game #includes &gt;&gt;
&lt;&lt; g_game declarations &gt;&gt;
@others</t>
<t tx="T1333">#include "i_defs.h"
#include "g_game.h"

#include "am_map.h"
#include "con_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "dstrings.h"
#include "e_main.h"
#include "f_finale.h"
#include "m_argv.h"
#include "m_cheat.h"
#include "m_inline.h"
#include "m_misc.h"
#include "m_menu.h"
#include "m_swap.h"
#include "m_random.h"
#include "hu_stuff.h"
#include "p_bot.h"
#include "p_local.h"
#include "p_saveg.h"
#include "p_setup.h"
#include "p_tick.h"
#include "r_data.h"
#include "r_layers.h"
#include "r_sky.h"
#include "r_view.h"
#include "rad_trig.h"
#include "s_sound.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "st_stuff.h"
#include "version.h"
#include "v_res.h"
#include "w_textur.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"
</t>
<t tx="T1334">
#define SAVEGAMESIZE    0x50000
#define SAVESTRINGSIZE  24

boolean_t G_CheckDemoStatus(void);
void G_ReadDemoTiccmd(ticcmd_t * cmd);
void G_WriteDemoTiccmd(ticcmd_t * cmd);

static void G_DoReborn(player_t *p);

void G_DoLoadLevel(void);
void G_DoNewGame(void);
void G_DoLoadGame(void);
void G_DoPlayDemo(void);
void G_DoCompleted(void);
void G_DoVictory(void);
void G_DoWorldDone(void);
void G_DoSaveGame(void);

gameaction_t gameaction;
gamestate_t gamestate = -1;
skill_t gameskill = -1;
const mapstuff_t *currentmap = NULL;  // currentmap
const mapstuff_t *nextmap = NULL;  // currentmap

boolean_t paused = false;

// ok to save / end game 
boolean_t usergame;

// send a pause event next tic 
static boolean_t sendpause = false;

// send a save event next tic 
static boolean_t sendsave = false;

// if true, exit with report on completion 
static boolean_t timingdemo;

// for comparative timing purposes 
boolean_t nodrawers;
boolean_t noblit;
static int starttime;

// -KM- 1998/11/25 Exit time is the time when the level will actually finish
// after hitting the exit switch/killing the boss.  So that you see the
// switch change or the boss die.

int exittime = 0x7fffffff;
boolean_t secretexit;

boolean_t viewactive;

// GAMEPLAY MODES:
//
//   netgame  deathmatch   mode
//   --------------------------------------
//     N         0         single player
//     Y         0         coop
//     -         1         deathmatch
//     -         2         altdeath

// only if started as net death
int deathmatch;

// only true if packets are broadcast 
boolean_t netgame;

player_t *players = NULL;
player_t **playerlookup = NULL;

// player taking events and displaying 
player_t *consoleplayer;

// view being displayed 
player_t *displayplayer;

int gametic;

// for intermission
int totalkills, totalitems, totalsecret;

static long random_seed;
static char *demoname;
boolean_t demorecording;
boolean_t demoplayback;
boolean_t netdemo;
boolean_t newdemo;

// 98-7-10 KM Remove maxdemo limit
static const byte *playdemobuffer = NULL;
static FILE *demofile = NULL;
static int demo_p;
// -ES- 2000/01/28 Added.
static int demo_length;
int maxdemo;

// quit after playing a demo from cmdline 
boolean_t singledemo;

// if true, load all graphics at start 
boolean_t precache = true;

// parms for world map / intermission 
wbstartstruct_t wminfo;

//
// controls (have defaults) 
// 
int key_right;
int key_left;
int key_lookup;
int key_lookdown;
int key_lookcenter;

// -ES- 1999/03/28 Zoom Key
int key_zoom;

int key_up;
int key_down;
int key_strafeleft;
int key_straferight;
int key_fire;
int key_use;
int key_strafe;
int key_speed;
int key_autorun;
int key_nextweapon;
int key_jump;
int key_map;
int key_180;
int key_talk;
int key_mlook;  // -AJA- 1999/07/27.
int key_secondatk;  // -AJA- 2000/02/08.

// -MH- 1998/07/10 Flying keys
int key_flyup;
int key_flydown;

#define MAXPLMOVE  (forwardmove[1])

#define TURBOTHRESHOLD  0x32

static int forwardmove[2] =
{0x19, 0x32};
static int upwardmove[2] =
{0x19, 0x32};  // -MH- 1998/08/18 Up/Down movement
static int sidemove[2] =
{0x18, 0x28};
static int angleturn[3] =
{640, 1280, 320};  // + slow turn 

#define ZOOM_ANGLE_DIV  3

#define SLOWTURNTICS    6

#define NUMKEYS         512

static boolean_t gamekeydown[NUMKEYS];
int turnheld;  // for accelerative turning 

//-------------------------------------------
// -KM-  1998/09/01 Analogue binding
// -ACB- 1998/09/06 Two-stage turning switch
//
int mouse_xaxis = AXIS_TURN;  // joystick values are used once
int mouse_yaxis = AXIS_FORWARD;
int joy_xaxis = AXIS_TURN;  // joystick values are repeated
int joy_yaxis = AXIS_FORWARD;

// The last one is ignored (AXIS_DISABLE)
static int analogue[6] = {0, 0, 0, 0, 0, 0};

boolean_t stageturn;  // Stage Turn Control

int forwardmovespeed;  // Speed controls

int angleturnspeed;
int sidemovespeed;

fixed_t mlookspeed = 1000 / 64;

// -ACB- 1999/09/30 Has to be true or false - bool-ified
boolean_t invertmouse = false;

//--------------------------------------------

static int loadgame_slot;
static int savegame_slot;
static char savedescription[32];

#define BODYQUESIZE     32

mobj_t *bodyque[BODYQUESIZE];
int bodyqueslot;

void *statcopy;  // for statistics driver

static const mapstuff_t *d_newmap = NULL;
static skill_t d_newskill;
static boolean_t d_newwarp;
</t>
<t tx="T1335">@ -KM- 1998/09/01 Made static.
@c

static int CheckKey(int keynum)
{
#ifdef DEVELOPERS
  if ((keynum &gt;&gt; 16) &gt; NUMKEYS)
    I_Error("Invalid key!");
  else if ((keynum &amp; 0xffff) &gt; NUMKEYS)
    I_Error("Invalid key!");
#endif

  if (gamekeydown[keynum &gt;&gt; 16])
    return true;
  else if (gamekeydown[keynum &amp; 0xffff])
    return true;
  else
    return false;
}
</t>
<t tx="T1336">@ Writes data to the demo

-ES- 1999/10/17 Added.
@c

static void WriteToDemo(const void *src, int length)
{
  fwrite(src,1,length,demofile);
  // This will make sure that also the last bytes are written at a crash
  fflush(demofile);
}
</t>
<t tx="T1337">@ Stores a single byte to the demo.
@c

static void WriteByteToDemo(byte c)
{
  WriteToDemo(&amp;c, 1);
}
</t>
<t tx="T1338">
#if 0  // UNUSED ???
static int CmdChecksum(ticcmd_t * cmd)
{
  int i;
  int sum = 0;

  for (i = 0; i &lt; (int)sizeof(ticcmd_t) / 4 - 1; i++)
    sum += ((int *)cmd)[i];

  return sum;
}
</t>
<t tx="T1339">#endif

//
// G_BuildTiccmd
//
// Builds a ticcmd from all of the available inputs
//
// -ACB- 1998/07/02 Added Vertical angle checking for mlook.
// -ACB- 1998/07/10 Reformatted: I can read the code! :)
// -ACB- 1998/09/06 Apply speed controls to -KM-'s analogue controls
// -AJA- 1999/08/10: Reworked the GetSpeedDivisor macro.
//
#define G_DefineGetSpeedDivisor(speed) \
	(((speed) == 8) ? 1 : (8 - (speed)) &lt;&lt; 4)

void G_BuildTiccmd(ticcmd_t * cmd)
{
  int i;
  boolean_t strafe;
  float_t vertangle;  // -ACB- 1998/07/02 Look angle
#ifdef MOUSE_ACC
  // Define MOUSE_ACC to get smoother movements
  // These values are first added to the movements, and then
  // 66% of the total movement is subtracted from the actual movement,
  // &amp; added to these.
  static float_t slope_acc = 0;
  static angle_t angle_acc = 0;
#endif

  int speed;
  int tspeed;
  int forward;
  int upward;  // -MH- 1998/08/18 Fly Up/Down movement

  int side;
  // -ACB- 1999/09/20 Removed. base tic is zero-ed out ticcmd.
  //  ticcmd_t *base;
  static boolean_t allow180 = true;
  static boolean_t allowzoom = true;
  static boolean_t allowautorun = true;

  // -ACB- 1999/09/20 Removed. base tic is zero-ed out ticcmd.
  //base = I_BaseTiccmd();  // empty, or external driver
  Z_Clear(cmd, ticcmd_t, 1);

  // -KM- 1998/12/21 If a drone player, do not accept input.
  if (drone)
    return;

  vertangle = 0;

  strafe = CheckKey(key_strafe);
  speed = CheckKey(key_speed);

  if (autorunning)
    speed = !speed;

  upward = forward = side = 0;

  //
  // -KM- 1998/09/01 use two stage accelerative turning on all devices
  //
  // -ACB- 1998/09/06 Allow stage turning to be switched off for
  //                  analogue devices...
  //
  if (CheckKey(key_right) || CheckKey(key_left) || (analogue[AXIS_TURN] &amp;&amp; stageturn))
    turnheld += ticdup;
  else
    turnheld = 0;

  // slow turn ?
  if (turnheld &lt; SLOWTURNTICS)
    tspeed = 2;
  else
    tspeed = speed;

  // -ES- 1999/03/28 Zoom Key
  if (CheckKey(key_zoom))
  {
    if (allowzoom)
    {
      cmd-&gt;extbuttons |= EBT_ZOOM;
      allowzoom = false;
    }
  }
  else
    allowzoom = true;

  // -AJA- 2000/04/14: Autorun toggle
  if (CheckKey(key_autorun))
  {
    if (allowautorun)
    {
      autorunning  = !autorunning;
      allowautorun = false;
    }
  }
  else
    allowautorun = true;

  if (level_flags.mlook)
  {
    fixed_t mlook_rate = mlookspeed;

    // -ACB- 1998/07/02 Use VertAngle for Look/up down.
    if (CheckKey(key_lookup))
      vertangle += (float_t)mlook_rate / 1024.0;

    // -ACB- 1998/07/02 Use VertAngle for Look/up down.
    if (CheckKey(key_lookdown))
      vertangle -= (float_t)mlook_rate / 1024.0;

    if (viewiszoomed)
      mlook_rate /= ZOOM_ANGLE_DIV;
     
    // -ACB- 1998/07/02 Use CENTER flag to center the vertical look.
    if (CheckKey(key_lookcenter))
      cmd-&gt;extbuttons |= EBT_CENTER;

    // -KM- 1998/09/01 More analogue binding
    vertangle += M_FixedToFloat(analogue[AXIS_MLOOK] * mlook_rate);
  }

  // You have to release the 180 deg turn key before you can press it again
  if (CheckKey(key_180))
  {
    if (allow180)
      cmd-&gt;angleturn = ANG180 &gt;&gt; 16;
    allow180 = false;
  }
  else
  {
    allow180 = true;
    cmd-&gt;angleturn = 0;
  }

  //let movement keys cancel each other out
  if (strafe)
  {
    if (CheckKey(key_right))
      side += sidemove[speed];

    if (CheckKey(key_left))
      side -= sidemove[speed];

    // -KM- 1998/09/01 Analogue binding
    // -ACB- 1998/09/06 Side Move Speed Control
    i = G_DefineGetSpeedDivisor(sidemovespeed);
    side += analogue[AXIS_TURN] * sidemove[speed] / i;
  }
  else
  {
    int angle_rate = angleturn[tspeed];

    if (viewiszoomed)
      angle_rate /= ZOOM_ANGLE_DIV;

    if (CheckKey(key_right))
      cmd-&gt;angleturn -= angle_rate;

    if (CheckKey(key_left))
      cmd-&gt;angleturn += angle_rate;

    // -KM- 1998/09/01 Analogue binding
    // -ACB- 1998/09/06 Angle Turn Speed Control
    i = G_DefineGetSpeedDivisor(angleturnspeed);
    cmd-&gt;angleturn -= analogue[AXIS_TURN] * angle_rate / i;
  }

  // -MH- 1998/08/18 Fly up
  if (level_flags.true3dgameplay)
  {
    if ((CheckKey(key_flyup)))
      upward += upwardmove[speed];

    // -MH- 1998/08/18 Fly down
    if ((CheckKey(key_flydown)))
      upward -= upwardmove[speed];

    i = G_DefineGetSpeedDivisor(forwardmovespeed);
    upward += analogue[AXIS_FLY] * upwardmove[speed] / i;
  }

  if (CheckKey(key_up))
    forward += forwardmove[speed];

  if (CheckKey(key_down))
    forward -= forwardmove[speed];

  // -KM- 1998/09/01 Analogue binding
  // -ACB- 1998/09/06 Forward Move Speed Control
  i = G_DefineGetSpeedDivisor(forwardmovespeed);
  forward -= analogue[AXIS_FORWARD] * forwardmove[speed] / i;

  // -ACB- 1998/09/06 Side Move Speed Control
  i = G_DefineGetSpeedDivisor(sidemovespeed);
  side += analogue[AXIS_STRAFE] * sidemove[speed] / i;

  if (CheckKey(key_straferight))
    side += sidemove[speed];

  if (CheckKey(key_strafeleft))
    side -= sidemove[speed];

  // buttons
  cmd-&gt;chatchar = HU_DequeueChatChar();

  if (CheckKey(key_fire))
    cmd-&gt;buttons |= BT_ATTACK;

  if (CheckKey(key_use))
    cmd-&gt;buttons |= BT_USE;

  if (CheckKey(key_jump))
    cmd-&gt;extbuttons |= EBT_JUMP;

  if (CheckKey(key_secondatk))
    cmd-&gt;extbuttons |= EBT_SECONDATK;

  // -KM- 1998/11/25 Weapon change key
  for (i = 0; i &lt; 10; i++)
  {
    if (CheckKey('0' + i))
    {
      cmd-&gt;buttons |= BT_CHANGE;
      cmd-&gt;buttons |= i &lt;&lt; BT_WEAPONSHIFT;
      break;
    }
  }

  // -MH- 1998/08/18 Yep. More flying controls...
  if (upward &gt; MAXPLMOVE)
    upward = MAXPLMOVE;
  else if (upward &lt; -MAXPLMOVE)
    upward = -MAXPLMOVE;

  if (forward &gt; MAXPLMOVE)
    forward = MAXPLMOVE;
  else if (forward &lt; -MAXPLMOVE)
    forward = -MAXPLMOVE;

  if (side &gt; MAXPLMOVE)
    side = MAXPLMOVE;
  else if (side &lt; -MAXPLMOVE)
    side = -MAXPLMOVE;

  if (vertangle &gt; 0.5)
    vertangle = 0.5;
  else if (vertangle &lt; -0.5)
    vertangle = -0.5;

  cmd-&gt;upwardmove += upward;
  cmd-&gt;forwardmove += forward;
  cmd-&gt;sidemove += side;

#ifdef MOUSE_ACC
  cmd-&gt;angleturn += angle_acc;
  angle_acc = cmd-&gt;angleturn * 2/3;
  if (angle_acc &lt; 64)
    // disable acc at very small angles (0.35 deg)
    angle_acc = 0;
  cmd-&gt;angleturn -= angle_acc;

  vertangle += slope_acc;
  slope_acc = vertangle * 2/3;
  if (slope_acc &lt; 64 * 2 * M_PI / 65536.0)
    // disable acc at very small angles (0.35 deg)
    slope_acc = 0;
  vertangle -= slope_acc;
#endif

  if (vertangle != 0)
  {
    cmd-&gt;extbuttons |= EBT_MLOOK;

    if (vertangle &gt; LOOKUPLIMIT)
      vertangle = LOOKUPLIMIT;

    if (vertangle &lt; LOOKDOWNLIMIT)
      vertangle = LOOKDOWNLIMIT;

    cmd-&gt;vertangle = vertangle * 254;
  }

  // special buttons
  if (sendpause)
  {
    sendpause = false;
    cmd-&gt;buttons = BT_SPECIAL | BTS_PAUSE;
  }

  if (sendsave)
  {
    sendsave = false;

#if 0  // -AJA- FIXME: doesn't handle save_pages
    if (netgame)
      cmd-&gt;buttons = BT_SPECIAL | BTS_SAVEGAME | (savegame_slot &lt;&lt; BTS_SAVESHIFT);
    else
#endif
      gameaction = ga_savegame;
  }

  // -KM- 1998/09/01 Analogue binding
  Z_Clear(analogue, int, 5);
}
</t>
<t tx="T1340">@ G_DoLoadLevel
@c

void G_DoLoadLevel(void)
{
  player_t *p;

  if (currentmap == NULL)
    I_Error("G_DoLoadLevel: No Current Map selected");

  // Set the sky map.
  //
  // First thing, we have a dummy sky texture name, a flat. The data is
  // in the WAD only because we look for an actual index, instead of simply
  // setting one.
  //
  // -ACB- 1998/08/09 Reference current map for sky name.

  sky_image = W_ImageFromTexture(currentmap-&gt;sky);

  if (wipegamestate == GS_LEVEL)
    wipegamestate = -1;  // force a wipe

  // -AJA- need this for GLBSP plugin
  gamestate = GS_NOTHING;

  // -AJA- FIXME: this background camera stuff is a mess
  background_camera_mo = NULL;
  R_ExecuteSetViewSize();

  for (p = players; p; p = p-&gt;next)
  {
    if (p-&gt;playerstate == PST_DEAD ||
        (currentmap-&gt;force_on &amp; MPF_ResetPlayer))
    {
      p-&gt;playerstate = PST_REBORN;
    }

    p-&gt;frags = 0;
  }

  // -KM- 1998/12/16 Make map flags actually do stuff.
  // -AJA- 2000/02/02: Made it more generic.

  #define HANDLE_FLAG(var, specflag)  \
      if (currentmap-&gt;force_on &amp; (specflag))  \
        (var) = true;  \
      else if (currentmap-&gt;force_off &amp; (specflag))  \
        (var) = false;

  HANDLE_FLAG(level_flags.jump, MPF_Jumping);
  HANDLE_FLAG(level_flags.crouch, MPF_Crouching);
  HANDLE_FLAG(level_flags.mlook, MPF_Mlook);
  HANDLE_FLAG(level_flags.itemrespawn, MPF_ItemRespawn);
  HANDLE_FLAG(level_flags.fastparm, MPF_FastParm);
  HANDLE_FLAG(level_flags.true3dgameplay, MPF_True3D);
  HANDLE_FLAG(level_flags.more_blood, MPF_MoreBlood);
  HANDLE_FLAG(level_flags.cheats, MPF_Cheats);
  HANDLE_FLAG(level_flags.trans, MPF_Translucency);
  HANDLE_FLAG(level_flags.respawn, MPF_Respawn);
  HANDLE_FLAG(level_flags.res_respawn, MPF_ResRespawn);
  HANDLE_FLAG(level_flags.have_extra, MPF_Extras);
  HANDLE_FLAG(level_flags.limit_zoom, MPF_LimitZoom);
  HANDLE_FLAG(level_flags.shadows, MPF_Shadows);
  HANDLE_FLAG(level_flags.halos, MPF_Halos);
  HANDLE_FLAG(level_flags.kicking, MPF_Kicking);

  #undef HANDLE_FLAG
  
  if (currentmap-&gt;force_on &amp; MPF_BoomCompat)
    level_flags.compat_mode = CM_BOOM;
  else if (currentmap-&gt;force_off &amp; MPF_BoomCompat)
    level_flags.compat_mode = CM_EDGE;

  if (currentmap-&gt;force_on &amp; MPF_AutoAim)
  {
    if (currentmap-&gt;force_on &amp; MPF_AutoAimMlook)
      level_flags.autoaim = AA_MLOOK;
    else
      level_flags.autoaim = AA_ON;
  }
  else if (currentmap-&gt;force_off &amp; MPF_AutoAim)
    level_flags.autoaim = AA_OFF;

  //
  // Note: It should be noted that only the gameskill is
  // passed as the level is already defined in currentmap,
  // The method for changing currentmap, is using by
  // G_DeferedInitNew.
  //
  // -ACB- 1998/08/09 New P_SetupLevel
  // -KM- 1998/11/25 P_SetupLevel accepts the autotag
  //
  RAD_ClearTriggers();

  P_SetupLevel(gameskill, currentmap-&gt;autotag);

  RAD_SpawnTriggers(currentmap-&gt;ddf.name);

  // -KM- 1998/12/21 If a drone player, the display player is already
  //   set up.
  if (!drone)
    displayplayer = consoleplayer;  // view the guy you are playing

  Z_CheckHeap();
  starttime = I_GetTime();
  exittime = 0x7fffffff;

  gamestate = GS_LEVEL;
  gameaction = ga_nothing;

  CON_SetVisible( /* !!! showMessages?vs_minimal: */ vs_notvisible);
  CON_Printf("%s\n", currentmap-&gt;ddf.name);

  // clear cmd building stuff
  Z_Clear(gamekeydown, boolean_t, NUMKEYS);
  Z_Clear(analogue, int, 5);
  sendpause = sendsave = paused = false;
}
</t>
<t tx="T1341">@ G_Responder

Get info needed to make ticcmd_ts for the players.
@c

boolean_t G_Responder(event_t * ev)
{
  // 25-6-98 KM Allow spy mode for demos even in deathmatch
  if ((gamestate == GS_LEVEL) &amp;&amp; (ev-&gt;type == ev_keydown) &amp;&amp; 
      (ev-&gt;value.key == KEYD_F12) &amp;&amp; (demoplayback || !deathmatch))
  {
    // spy mode 
    do
    {
      displayplayer = displayplayer-&gt;next;
      if (!displayplayer)
        displayplayer = players;
    }
    while (!displayplayer-&gt;in_game &amp;&amp; displayplayer != consoleplayer);
    return true;
  }

  // any other key pops up menu if in demos
  if (gameaction == ga_nothing &amp;&amp; !singledemo &amp;&amp; (demoplayback || gamestate == GS_DEMOSCREEN))
  {
    if (ev-&gt;type == ev_keydown)
    {
      M_StartControlPanel();
      S_StartSound(NULL, sfx_swtchn);
      return true;
    }
    return false;
  }

  if (gamestate == GS_LEVEL)
  {
    if (ST_Responder(ev))
      return true;  // status window ate it 

    if (AM_Responder(ev))
      return true;  // automap ate it 
  }

  if (gamestate == GS_LEVEL)
  {
    if (HU_Responder(ev))
      return true;  // chat ate the event

    if (M_CheatResponder(ev))
      return true;  // cheat code at it
  }

  if (gamestate == GS_FINALE)
  {
    if (F_Responder(ev))
      return true;  // finale ate the event 
  }

  // -ES- Fixme: Clean up globals gamekeydown and analogue.
  switch (ev-&gt;type)
  {
    case ev_keydown:
      if (ev-&gt;value.key == KEYD_PAUSE)
      {
        sendpause = true;
        return true;
      }

      if (ev-&gt;value.key &lt; NUMKEYS)
        gamekeydown[ev-&gt;value.key] = true;

      // eat key down events 
      return true;

    case ev_keyup:
      if (ev-&gt;value.key &lt; NUMKEYS)
        gamekeydown[ev-&gt;value.key] = false;

      // always let key up events filter down 
      return false;

      // -KM- 1998/09/01 Change mouse/joystick to analogue
    case ev_analogue:
      {
        // -AJA- 1999/07/27: Mlook key like quake's.
        if (level_flags.mlook &amp;&amp; CheckKey(key_mlook))
        {
          if (ev-&gt;value.analogue.axis == mouse_xaxis)
          {
            analogue[AXIS_TURN] += ev-&gt;value.analogue.amount;
            return true;
          }
          if (ev-&gt;value.analogue.axis == mouse_yaxis)
          {
            analogue[AXIS_MLOOK] += ev-&gt;value.analogue.amount;
            return true;
          }
        }

        analogue[ev-&gt;value.analogue.axis] += ev-&gt;value.analogue.amount;
        return true;  // eat events
      }

    default:
      break;
  }

  return false;
}
</t>
<t tx="T1342">@ G_Ticker

Make ticcmd_ts for the players.

-ACB- 1998/08/10 Use DDF_LanguageLookup() for language specifics.
@c

void G_Ticker(void)
{
  int buf;
  ticcmd_t *cmd;
  player_t *p;

  // do player reborns if needed
  for (p = players; p; p = p-&gt;next)
  {
    if (p-&gt;playerstate == PST_REBORN)
      G_DoReborn(p);
  }

  if (exittime == leveltime)
  {
    gameaction = ga_completed;
    exittime = -1;
  }

  // do things to change the game state
  while (gameaction != ga_nothing)
  {
    switch (gameaction)
    {
      case ga_loadlevel:
        G_DoLoadLevel();
        break;
      case ga_newgame:
        G_DoNewGame();
        break;
      case ga_loadgame:
        G_DoLoadGame();
        break;
      case ga_savegame:
        G_DoSaveGame();
        break;
      case ga_playdemo:
        G_DoPlayDemo();
        break;
      case ga_completed:
        G_DoCompleted();
        break;
      case ga_briefing:
        F_StartFinale(&amp;nextmap-&gt;f[1], ga_worlddone);
        break;
      case ga_worlddone:
        G_DoWorldDone();
        break;
      case ga_screenshot:
        M_ScreenShot();
        gameaction = ga_nothing;
        break;
      case ga_nothing:
        break;
      default:
        I_Error("G_Ticker: Unknown gameaction %d", gameaction);
    }
  }

  // get commands, check consistency,
  // and build new consistency check
  buf = (gametic / ticdup) % BACKUPTICS;

  for (p = players; p; p = p-&gt;next)
  {
    cmd = &amp;p-&gt;cmd;

    // -ES- FIXME: Change format of player_t-&gt;cmd?
    *cmd = p-&gt;netcmds[buf];

    if (demoplayback)
      G_ReadDemoTiccmd(cmd);

    if (demorecording)
      G_WriteDemoTiccmd(cmd);

    // check for turbo cheats
    if (cmd-&gt;forwardmove &gt; TURBOTHRESHOLD
        &amp;&amp; !(gametic &amp; 31) &amp;&amp; ((gametic &gt;&gt; 5) &amp; 3) == p-&gt;pnum)
    {
      CON_Printf(DDF_LanguageLookup("IsTurbo"), p-&gt;playername);
    }

    if (netgame &amp;&amp; !netdemo &amp;&amp; !(gametic % ticdup))
    {
      if (gametic &gt; BACKUPTICS
          &amp;&amp; p-&gt;consistency[buf] != cmd-&gt;consistency)
      {
        I_Error("Consistency failure on player %d (%i should be %i)",
            p-&gt;pnum + 1, cmd-&gt;consistency, p-&gt;consistency[buf]);
      }
      if (p-&gt;mo)
        p-&gt;consistency[buf] = (int)p-&gt;mo-&gt;x;
      else
        p-&gt;consistency[buf] = P_ReadRandomState() &amp; 0xff;
    }
  }
  // check for special buttons
  for (p = players; p; p = p-&gt;next)
  {
    if (!(p-&gt;cmd.buttons &amp; BT_SPECIAL))
      continue;

    switch (p-&gt;cmd.buttons &amp; BT_SPECIALMASK)
    {
      case BTS_PAUSE:
        paused = !paused;
        if (paused)
        {
          S_PauseMusic();  // -ACB- 1999/10/07 New Music API
          S_PauseSounds();  // -ACB- 1999/10/17 New Sound API
        }
        else
        {
          S_ResumeMusic(); // -ACB- 1999/10/07 New Music API
          S_ResumeSounds();  // -ACB- 1999/10/17 New Sound API
        }
        // explicit as probably killed the initial effect
        S_StartSound(NULL, sfx_swtchn);
        break;

#if 0  // -AJA- disabled for now
      case BTS_SAVEGAME:
        if (!savedescription[0])
          strcpy(savedescription, "NET GAME");
        savegame_slot =
            (p-&gt;cmd.buttons &amp; BTS_SAVEMASK) &gt;&gt; BTS_SAVESHIFT;
        gameaction = ga_savegame;
        break;
#endif
    }
  }

  // do main actions
  switch (gamestate)
  {
    case GS_LEVEL:
      P_Ticker();
      ST_Ticker();
      AM_Ticker();
      HU_Ticker();
      RAD_Ticker();  // -AJA- 1999/09/07.
      break;

    case GS_INTERMISSION:
      WI_Ticker();
      break;

    case GS_FINALE:
      F_Ticker();
      break;

    case GS_DEMOSCREEN:
      E_PageTicker();
      break;
    
    case GS_NOTHING:
      break;
  }
}
</t>
<t tx="T1343">@ PLAYER STRUCTURE FUNCTIONS
also see P_SpawnPlayer in P_Things


G_PlayerFinishLevel

Called when a player completes a level.
@c

static void G_PlayerFinishLevel(player_t *p)
{
  int i;

  for (i = 0; i &lt; NUMPOWERS; i++)
    p-&gt;powers[i] = 0;
  
  p-&gt;cards = KF_NONE;
  
  p-&gt;mo-&gt;flags &amp;= ~MF_FUZZY;  // cancel invisibility 

  p-&gt;extralight = 0;  // cancel gun flashes 

  // cancel colourmap effects
  p-&gt;effect_colourmap = NULL;
  p-&gt;effect_infrared = false;

  // no palette changes 
  p-&gt;damagecount = 0;
  p-&gt;bonuscount  = 0;
  p-&gt;grin_count  = 0;
}
</t>
<t tx="T1344">@ G_PlayerReborn

Called after a player dies.
almost everything is cleared and initialised.
@c

void G_PlayerReborn(player_t *p)
{
  boolean_t in_game;
  const mobjinfo_t *info;
  player_t *next, *prev;
  void *data;
  void (*thinker)(const player_t *, void *, ticcmd_t *);

  int frags;
  int totalfrags;
  int killcount;
  int itemcount;
  int secretcount;
  int pnum;

  frags = p-&gt;frags;
  totalfrags = p-&gt;totalfrags;
  killcount = p-&gt;killcount;
  itemcount = p-&gt;itemcount;
  secretcount = p-&gt;secretcount;
  thinker = p-&gt;thinker;
  data = p-&gt;data;
  prev = p-&gt;prev;
  next = p-&gt;next;

  info = DDF_MobjLookupPlayer(p-&gt;pnum+1);
  
  in_game = p-&gt;in_game;
  pnum = p-&gt;pnum;

  Z_Clear(p, player_t, 1);

  p-&gt;pnum = pnum;
  p-&gt;in_game = in_game;

  p-&gt;frags = frags;
  p-&gt;totalfrags = totalfrags;
  p-&gt;killcount = killcount;
  p-&gt;itemcount = itemcount;
  p-&gt;secretcount = secretcount;
  p-&gt;thinker = thinker;
  p-&gt;data = data;
  p-&gt;prev = prev;
  p-&gt;next = next;

  // don't do anything immediately 
  p-&gt;usedown = p-&gt;attackdown = false;

  p-&gt;playerstate = PST_LIVE;

  P_GiveInitialBenefits(p, info);
}
</t>
<t tx="T1345">@ G_CheckSpot

Returns false if the player cannot be respawned at the given spot
because something is occupying it
@c

static boolean_t G_CheckSpot(player_t *player, spawnpoint_t *point)
{
  float_t x, y, z;
  player_t *p;

  if (!player-&gt;mo)
  {
    // first spawn of level, before corpses
    for (p = players; p != player; p = p-&gt;next)
    {
      if (p-&gt;mo-&gt;x == point-&gt;x &amp;&amp; p-&gt;mo-&gt;y == point-&gt;y)
        return false;
    }
    return true;
  }

  x = point-&gt;x;
  y = point-&gt;y;
  z = point-&gt;z;

  if (!P_CheckAbsPosition(player-&gt;mo, x, y, z))
    return false;

  // flush an old corpse if needed 
  if (bodyqueslot &gt;= BODYQUESIZE)
    P_RemoveMobj(bodyque[bodyqueslot % BODYQUESIZE]);
  bodyque[bodyqueslot % BODYQUESIZE] = player-&gt;mo;
  bodyqueslot++;

  // spawn a teleport fog 
  // (temp fix for teleport effect)
  x += 20 * M_Cos(point-&gt;angle);
  y += 20 * M_Sin(point-&gt;angle);
  P_MobjCreateObject(x, y, z, DDF_MobjLookup("TELEPORT FLASH"));

  return true;
}
</t>
<t tx="T1346">@ G_DeathMatchSpawnPlayer

Spawns a player at one of the random death match spots
called at level load and each death
@c

void G_DeathMatchSpawnPlayer(player_t *p)
{
  int i, j;
  int selections;
  int begin;

  selections = deathmatch_p - deathmatchstarts;

  if (p-&gt;pnum &gt;= selections)
    I_Warning("Few deathmatch spots, %d recommended.\n", p-&gt;pnum + 1);

  if (selections)
  {
    begin = P_Random() % selections;

    for (j = 0; j &lt; selections; j++)
    {
      i = (begin + j) % selections;

      if (G_CheckSpot(p, &amp;deathmatchstarts[i]))
      {
        P_SpawnPlayer(p, &amp;deathmatchstarts[i]);
        return;
      }
    }
  
    // no good spot, so the player will probably get stuck
    if (playerstarts[p-&gt;pnum].info)
      P_SpawnPlayer(p, &amp;playerstarts[p-&gt;pnum]);
    else
      P_SpawnPlayer(p, &amp;deathmatchstarts[begin]);
  }
  else
  {
    // No deathmatch spawn exists.
    if (playerstarts[p-&gt;pnum].info)
    {
      P_SpawnPlayer(p, &amp;playerstarts[p-&gt;pnum]);
    }
    else
    {
      for (i = 0; i &lt; MAXPLAYERS; i++)
      {
        if (playerstarts[i].info)
        {
          P_SpawnPlayer(p, &amp;playerstarts[i]);
          break;
        }
      }

      // no player or deathmatch starts could be found.
      if (i == MAXPLAYERS)
        I_Error("No player starts found!");
    }
  }
}
</t>
<t tx="T1347">@ G_DoReborn
@c

static void G_DoReborn(player_t *p)
{
  int i;

  // single player ?
  if (!(netgame || deathmatch))
  {
    gameaction = ga_loadlevel;
  }
  else
  {
    // respawn at the start

    // first dissasociate the corpse 
    p-&gt;mo-&gt;player = NULL;

    // spawn at random spot if in death match 
    if (deathmatch)
    {
      G_DeathMatchSpawnPlayer(p);
      return;
    }

    if (playerstarts[p-&gt;pnum].info == NULL)
      I_Error("Missing player %d start !\n", p-&gt;pnum+1);

    if (G_CheckSpot(p, &amp;playerstarts[p-&gt;pnum]))
    {
      P_SpawnPlayer(p, &amp;playerstarts[p-&gt;pnum]);
      return;
    }

    I_Warning("Player %d start is invalid.\n", p-&gt;pnum+1);
    
    // try to spawn at one of the other players spots
    for (i = 0; i &lt; MAXPLAYERS; i++)
    {
      if (playerstarts[i].info == NULL)
        continue;

      if (G_CheckSpot(p, &amp;playerstarts[i]))
      {
        P_SpawnPlayer(p, &amp;playerstarts[i]);
        return;
      }
    }

    // he's going to be inside something.  Too bad.
    P_SpawnPlayer(p, &amp;playerstarts[p-&gt;pnum]);
  }
}
</t>
<t tx="T1348">
void G_ScreenShot(void)
{
  gameaction = ga_screenshot;
}
</t>
<t tx="T1349">@ -KM- 1998/11/25 Added time param which is the time to wait before
actually exiting level.
@c

void G_ExitLevel(int time)
{
  nextmap = DDF_LevelMapLookup(currentmap-&gt;nextmapname);
  exittime = leveltime + time;
}
</t>
<t tx="T1350">@ -ACB- 1998/08/08 We don't have support for the german edition
removed the check for map31.
@c

void G_SecretExitLevel(int time)
{
  nextmap = DDF_LevelMapLookup(currentmap-&gt;secretmapname);
  exittime = leveltime + time;
}
</t>
<t tx="T1351">
void G_ExitToLevel(char *name, int time)
{
  nextmap = DDF_LevelMapLookup(name);
  exittime = leveltime + time;
}
</t>
<t tx="T1352">@ G_DoCompleted
@c

void G_DoCompleted(void)
{
  player_t *p;

  gameaction = ga_nothing;

  for (p = players; p; p = p-&gt;next)
  {
    // take away cards and stuff
    G_PlayerFinishLevel(p);
  }

  if (automapactive)
    AM_Stop();

  // handle "no stat" levels
  if (currentmap-&gt;wistyle == WISTYLE_None)
  {
    viewactive = false;
    automapactive = false;

    G_WorldDone();
    return;
  }

  wminfo.level = currentmap-&gt;ddf.name;
  wminfo.last = currentmap;
  wminfo.next = nextmap;
  wminfo.maxkills = totalkills;
  wminfo.maxitems = totalitems;
  wminfo.maxsecret = totalsecret;
  wminfo.maxfrags = 0;
  wminfo.partime = currentmap-&gt;partime;
  wminfo.pnum = consoleplayer-&gt;pnum;

  if (!wminfo.plyr)
    wminfo.plyr = Z_New(wbplayerstruct_t, MAXPLAYERS);

  // FIXME: can overflow ???
  for (p = players; p; p = p-&gt;next)
  {
    wminfo.plyr[p-&gt;pnum].in = p-&gt;in_game;
    wminfo.plyr[p-&gt;pnum].skills = p-&gt;killcount;
    wminfo.plyr[p-&gt;pnum].sitems = p-&gt;itemcount;
    wminfo.plyr[p-&gt;pnum].ssecret = p-&gt;secretcount;
    wminfo.plyr[p-&gt;pnum].stime = leveltime;
    wminfo.plyr[p-&gt;pnum].frags = p-&gt;frags;
    wminfo.plyr[p-&gt;pnum].totalfrags = p-&gt;totalfrags;
  }

  gamestate = GS_INTERMISSION;
  viewactive = false;
  automapactive = false;

  WI_Start(&amp;wminfo);
}
</t>
<t tx="T1353">@ G_WorldDone
@c

void G_WorldDone(void)
{
  F_StartFinale(&amp;currentmap-&gt;f[0], nextmap ? ga_briefing : ga_nothing);
}
</t>
<t tx="T1354">
void G_DoWorldDone(void)
{
  gamestate = GS_LEVEL;
  currentmap = nextmap;

  G_DoLoadLevel();
  gameaction = ga_nothing;
  viewactive = true;
  secretexit = false;
}
</t>
<t tx="T1355">@ G_FileNameFromSlot

Creates a savegame file name. Z_Free() the returned string.
@c

char *G_FileNameFromSlot(int slot)
{
  char tmpname[64];

  sprintf(tmpname, "%s%04d.%s", SAVEGAMEBASE, slot + 1, SAVEGAMEEXT);

  return M_ComposeFileName(savedir, tmpname);
}
</t>
<t tx="T1356">@ G_InitFromSavegame

Can be called by the startup code or the menu task.
@c

void G_LoadGame(int slot)
{
  loadgame_slot = slot;
  gameaction = ga_loadgame;
}
</t>
<t tx="T1357">
void G_DoLoadGame(void)
{
  char *filename;
  int version;
  saveglobals_t *globs;
  const mapstuff_t *tempmap;

  gameaction = ga_nothing;

#if 0  // DEBUGGING CODE
  SV_DumpSaveGame(loadgame_slot);
  return;
#endif
  
  filename = G_FileNameFromSlot(loadgame_slot);

  if (! SV_OpenReadFile(filename))
  {
    I_Printf("LOAD-GAME: cannot open %s\n", filename);
    Z_Free(filename);
    return;
  }
  Z_Free(filename);

  if (! SV_VerifyHeader(&amp;version) || ! SV_VerifyContents())
  {
    I_Printf("LOAD-GAME: Savegame is corrupt !\n");
    SV_CloseReadFile();
    return;
  }

  SV_BeginLoad();

  globs = SV_LoadGLOB();
  
  if (!globs)
    I_Error("LOAD-GAME: Bad savegame file (no GLOB)\n");

  // --- pull info from global structure ---
  
  tempmap = DDF_LevelMapLookup(globs-&gt;level);

  if (! tempmap)
    I_Error("LOAD-GAME: No such map %s !  Check WADS\n", globs-&gt;level);

  gameskill = globs-&gt;skill;
  random_seed = globs-&gt;p_random;

  G_InitNew(gameskill, tempmap, random_seed);

  // -- Check LEVEL consistency (crc) --
  //
  // FIXME: ideally we shouldn't bomb out, just display an error box
 
  if (globs-&gt;mapsector.count != numsectors ||
      globs-&gt;mapsector.crc != mapsector_CRC ||
      globs-&gt;mapline.count != numlines ||
      globs-&gt;mapline.crc != mapline_CRC ||
      globs-&gt;mapthing.count != mapthing_NUM ||
      globs-&gt;mapthing.crc != mapthing_CRC)
  {
    I_Error("LOAD-GAME: Level data does not match !  Check WADs\n");
  }

  //!!! FIXME: Check DDF/RTS consistency (crc), warning only
 
  level_flags = globs-&gt;flags;
  level_flags.menu_grav = globs-&gt;gravity;

  leveltime   = globs-&gt;level_time;
  totalkills  = globs-&gt;total_kills;
  totalitems  = globs-&gt;total_items;
  totalsecret = globs-&gt;total_secrets;

  // con_player = globs-&gt;console_player;
  gameskill = globs-&gt;skill;
  netgame = globs-&gt;netgame;  /// FIXME: deathmatch var

  // clear line/sector lookup caches, in case level_flags.compat_mode
  // changed (e.g. CM_BOOM -&gt; CM_EDGE).
  DDF_LineClearGeneralised();
  DDF_SectorClearGeneralised();

  if (SV_LoadEverything() &amp;&amp; SV_GetError() == 0)
  {
    /* all went well */ 
  }
  else
  {
    // something went horribly wrong...
    // FIXME (oneday) : show message &amp; go back to title screen
    
    I_Error("Bad Save Game !\n");
  }

  SV_FreeGLOB(globs);

  SV_FinishLoad();
  SV_CloseReadFile();

  ST_Start();
  HU_Start();
}
</t>
<t tx="T1358">@ G_SaveGame

Called by the menu task.
Description is a 24 byte text string
@c

void G_SaveGame(int slot, const char *description)
{
  savegame_slot = slot;
  strcpy(savedescription, description);
  sendsave = true;
}
</t>
<t tx="T1359">
void G_DoSaveGame(void)
{
  char *filename = G_FileNameFromSlot(savegame_slot);
  saveglobals_t *globs;

  time_t cur_time;
  char timebuf[100];
  
  if (! SV_OpenWriteFile(filename, (EDGEVER &lt;&lt; 8) | EDGEPATCH))
  {
    //!!! do something
    Z_Free(filename);
    return;
  }
  Z_Free(filename);

  globs = SV_NewGLOB();

  // --- fill in global structure ---
  
  globs-&gt;game = Z_StrDup(currentmap-&gt;episode_name);
  globs-&gt;level = Z_StrDup(currentmap-&gt;ddf.name);
  globs-&gt;flags = level_flags;
  globs-&gt;gravity = level_flags.menu_grav;

  globs-&gt;level_time = leveltime;
  globs-&gt;p_random = P_ReadRandomState();
  globs-&gt;total_kills   = totalkills;
  globs-&gt;total_items   = totalitems;
  globs-&gt;total_secrets = totalsecret;
  
  globs-&gt;console_player = consoleplayer-&gt;pnum;
  globs-&gt;skill = gameskill;
  globs-&gt;netgame = netgame ? (1+deathmatch) : 0;
  
  time(&amp;cur_time);
  strftime(timebuf, 99, "%I:%M %p  %d/%b/%Y", localtime(&amp;cur_time));

  if (timebuf[0] == '0' &amp;&amp; isdigit(timebuf[1]))
    timebuf[0] = ' ';
 
  globs-&gt;description = Z_StrDup(savedescription);
  globs-&gt;desc_date   = Z_StrDup(timebuf);
  
  globs-&gt;mapsector.count = numsectors;
  globs-&gt;mapsector.crc = mapsector_CRC;
  globs-&gt;mapline.count = numlines;
  globs-&gt;mapline.crc = mapline_CRC;
  globs-&gt;mapthing.count = mapthing_NUM;
  globs-&gt;mapthing.crc = mapthing_CRC;
 
  // FIXME: store DDF CRC values too...

  SV_BeginSave();

  SV_SaveGLOB(globs);
  SV_SaveEverything();

  SV_FreeGLOB(globs);

  SV_FinishSave();
  SV_CloseWriteFile();

  savedescription[0] = 0;

  CON_Printf("%s", DDF_LanguageLookup("GameSaved"));

  // draw the pattern into the back screen
  //   R_FillBackScreen();

  gameaction = ga_nothing;
}
</t>
<t tx="T1360">@ G_InitNew

Can be called by the startup code or the menu task.
consoleplayer, displayplayer, playeringame[] should
be set.


G_DeferedInitNew

This is the procedure that changes the currentmap
at the start of the game and outside the normal
progression of the game. All thats needed is the
skill and the name (The name in the DDF File itself).

Returns true if OK, or false if no such map exists.
@c

boolean_t G_DeferedInitNew(skill_t skill, const char *mapname,
    boolean_t warpopt)
{
  d_newmap = DDF_LevelMapLookup(mapname);

  if (!d_newmap)
    return false;

  d_newskill = skill;

  // this is true only when called by -warp option
  d_newwarp = warpopt;

  gameaction = ga_newgame;
  return true;
}
</t>
<t tx="T1361">
void G_DoNewGame(void)
{
  player_t *p;

  demoplayback = false;
  
  if (d_newwarp)
  {
    if (netdemo)
    {
      deathmatch = netdemo = netgame = false;
      consoleplayer = players;

      // !!! FIXME: this is wrong
      for (p = players-&gt;next; p; p = p-&gt;next)
        p-&gt;in_game = false;
    }

    level_flags.fastparm = false;
    level_flags.nomonsters = false;
  }

  quickSaveSlot = -1;

  G_InitNew(d_newskill, d_newmap, I_PureRandom());
  gameaction = ga_nothing;
}
</t>
<t tx="T1362">@ G_InitNew

-ACB- 1998/07/12 Removed Lost Soul/Spectre Ability stuff
-ACB- 1998/08/10 Inits new game without the need for gamemap or episode.
-ACB- 1998/09/06 Removed remarked code.
-KM- 1998/12/21 Added mapstuff param so no need for defered init new
which was conflicting with net games.
@c

void G_InitNew(skill_t skill, const mapstuff_t * map, long seed)
{
  player_t *p;

  for (p = players; p; p = p-&gt;next)
    memset(p-&gt;consistency, -1, sizeof(p-&gt;consistency));

  if (paused)
  {
    paused = false;
    S_ResumeMusic(); // -ACB- 1999/10/07 New Music API
    S_ResumeSounds();  // -ACB- 1999/10/17 New Sound API
  }

  currentmap = map;

  if (skill &gt; sk_nightmare)
    skill = sk_nightmare;

  random_seed = seed;
  P_WriteRandomState(seed);

  // we can not call this until we have the random seed.
  if (demorecording)
    G_BeginRecording();

  // force players to be initialised upon first level load         
  for (p = players; p; p = p-&gt;next)
    p-&gt;playerstate = PST_REBORN;

  usergame = true;  // will be set false if a demo 

  demoplayback = false;
  automapactive = false;
  viewactive = true;
  gameskill = skill;

  viewactive = true;

  // copy global flags into the level-specific flags
  level_flags = global_flags;

  if (skill == sk_nightmare)
  {
    level_flags.fastparm = true;
    level_flags.respawn = true;
#ifdef NO_NIGHTMARE_CHEATS
    level_flags.cheats = false;
#endif
  }

  G_DoLoadLevel();
}
</t>
<t tx="T1363">@ DEMO RECORDING
@c

#define DEMOMARKER              0x80

//
// G_ReadDemoTiccmd
//
// A demo file is essentially a stream of ticcmds: every tic,
// the ticcmd holds all the info for movement for a player on
// that tic. This means that a demo merely replays the movements
// and actions of the player.
//
// This function gets the actions from the recdemobuffer and gives
// them to ticcmd to be played out. Its worth a note that this
// is the reason demos desync when played on two different
// versions, since any alteration to the gameplay could give
// a different reaction to a player action and therefore the
// game is different to the original.
//  
void G_ReadDemoTiccmd(ticcmd_t * cmd)
{
  // 98-7-10 KM Demolimit removed
  if (demo_p &gt;= demo_length)
  {
    // end of demo data stream
    G_CheckDemoStatus();
    return;
  }

  // -ACB- 1998/07/11 Added additional ticcmd stuff to demo
  // -MH-  1998/08/18 Added same for fly up/down
  //                  Keep all upward stuff before all forward stuff, to
  //                  keep consistent. Will break existing demos. Damn.
  *cmd = *(ticcmd_t *)&amp;playdemobuffer[demo_p];
  demo_p += sizeof(ticcmd_t);
}
</t>
<t tx="T1364">@ G_WriteDemoTiccmd

A demo file is essentially a stream of ticcmds: every tic,
the ticcmd holds all the info for movement for a player on
that tic. This means that a demo merely replays the movements
and actions of the player.

This function writes the ticcmd to the recdemobuffer and
then get G_ReadDemoTiccmd to read it, so that whatever is
recorded is played out.
@c

void G_WriteDemoTiccmd(ticcmd_t * cmd)
{
  // press q to end demo recording
  if (gamekeydown['q'])
    G_CheckDemoStatus();

  // -ACB- 1998/07/11 Added additional ticcmd stuff to demo
  // -MH-  1998/08/18 Added same for fly up/down
  //                  Keep all upward stuff before all forward stuff, to
  //                  keep consistent. Will break existing demos. Damn.
  WriteToDemo(cmd, sizeof(ticcmd_t));
}
</t>
<t tx="T1365">@ G_RecordDemo

98-7-10 KM Demolimit removed
@c

void G_RecordDemo(const char *name)
{
  // assume demo name is less than 256 chars
  char tmp[256];

  if (demoname)
    Z_Free(demoname);
  sprintf(tmp, "%s.lmp", name);
  demoname = M_ComposeFileName(gamedir, tmp);
  usergame = false;
  maxdemo = 0x20000;

  // Write directly to file. Possibly a bit slower without disk cache, but
  // uses less memory, and the demo can record EDGE crashes.
  if (!demofile)
    demofile = fopen(demoname, "wb");
  Z_Free(demoname);
  demoname = NULL;
  demorecording = true;
}
</t>
<t tx="T1366">@ G_BeginRecording

-ACB- 1998/07/02 Changed the code to record as version 0.65 (065),
All of the additional EDGE features are stored in
the demo.

-KM- 1998/07/10 Removed the demo limit.

-ACB- 1998/07/12 Removed Lost Soul/Spectre Ability Check
@c

void G_BeginRecording(void)
{
  int i;
///  player_t *p;

  demo_p = 0;

  WriteByteToDemo(DEMOVERSION);

  if ((int)gameskill == -1)
    gameskill = startskill;

  //---------------------------------------------------------
  // -ACB- 1998/09/03 Record Level Name In Demo
  i = strlen(currentmap-&gt;ddf.name);
  WriteByteToDemo(i);
  WriteToDemo(currentmap-&gt;ddf.name, i);
  L_WriteDebug("G_BeginRecording: %s\n", currentmap-&gt;ddf.name);
  //---------------------------------------------------------

  WriteByteToDemo(gameskill);
  WriteByteToDemo(deathmatch);
  WriteByteToDemo(consoleplayer-&gt;pnum);
  WriteToDemo(&amp;level_flags, sizeof(level_flags));

///  for (p = players; p; p = p-&gt;next)
///    WriteByteToDemo(p-&gt;in_game);

  i = LONG(random_seed);
  WriteToDemo(&amp;i, 4);
}
</t>
<t tx="T1367">@ G_SetTurboScale

Sets the turbo scale (100 is normal)
@c

void G_SetTurboScale(int scale)
{
  const int origforwardmove[2] = {0x19, 0x32};
  const int origupwardmove[2] = {0x19, 0x32};
  const int origsidemove[2] = {0x18, 0x28};

  upwardmove[0]  = origupwardmove[0] * scale / 100;
  upwardmove[1]  = origupwardmove[1] * scale / 100;
  forwardmove[0] = origforwardmove[0] * scale / 100;
  forwardmove[1] = origforwardmove[1] * scale / 100;
  sidemove[0]    = origsidemove[0] * scale / 100;
  sidemove[1]    = origsidemove[1] * scale / 100;
}
</t>
<t tx="T1368">@ G_PlayDemo
@c

static const char *defdemoname;

void G_DeferedPlayDemo(const char *name)
{
  if (defdemoname)
    Z_Free((char *)defdemoname);
  
  defdemoname = Z_StrDup(name);
  gameaction = ga_playdemo;
}
</t>
<t tx="T1369">@ G_DoPlayDemo
Sets up the system to play a demo.

-ACB- 1998/07/02 Change the code only to play version 0.65 demos.
-KM- 1998/07/10 Displayed error message on screen and make demos limitless
-ACB- 1998/07/12 Removed Lost Soul/Spectre Ability Check
-ACB- 1998/07/12 Removed error message (became bloody annoying...)
@c

void G_DoPlayDemo(void)
{
  skill_t skill;
  int i,j;
  int demversion;
  char mapname[30];
  const mapstuff_t *newmap;
  long random_seed;
///  player_t *p;

  gameaction = ga_nothing;
  playdemobuffer = W_CacheLumpName(defdemoname);
  demo_p = 0;
  demversion = playdemobuffer[demo_p++];

  // -ES- 1999/10/17 Allow cut off demos: Add a demo marker if it doesn't exist.
  demo_length = W_LumpLength(W_GetNumForName(defdemoname));
  if (demo_length &lt; 16)
    // no real demo could be smaller than 16 bytes
    I_Error("Demo '%s' is too small!", defdemoname);
  if (playdemobuffer[demo_length-1] != DEMOMARKER)
    I_Warning("Warning: Demo has no end marker! It might be corrupt.\n");
  else
    demo_length--;

  if (demversion != DEMOVERSION)
  {
    gameaction = ga_nothing;
    return;
  }
  else
  {
    //------------------------------------------------------
    // -ACB- 1998/09/03 Read the Level Name from the demo.
    i = playdemobuffer[demo_p++];

    for (j = 0; j &lt; i; j++)
      mapname[j] = playdemobuffer[demo_p + j];
    mapname[i] = 0;

    demo_p += i;
    //------------------------------------------------------

    skill = playdemobuffer[demo_p++];
    deathmatch = playdemobuffer[demo_p++];
    consoleplayer = playerlookup[playdemobuffer[demo_p++]];

    level_flags = *(gameflags_t *)&amp;playdemobuffer[demo_p];
    demo_p += sizeof(level_flags);

///    for (p = players; p; p = p-&gt;next)
///      p-&gt;in_game = playdemobuffer[demo_p++];

    // -ES- 2000/02/04 Random seed
    random_seed = LONG(*(long*)&amp;playdemobuffer[demo_p]);
    demo_p += 4;
  }

  //----------------------------------------------------------------
  // -ACB- 1998/09/03 Setup the given mapname; fail if map does not
  // exist.
  newmap = DDF_LevelMapLookup(mapname);

  if (newmap == NULL)
  {
    gameaction = ga_nothing;
    return;
  }

  //----------------------------------------------------------------

  if (players-&gt;next &amp;&amp; players-&gt;next-&gt;in_game)
  {
    netgame = true;
    netdemo = true;
  }

  // don't spend a lot of time in loadlevel
  precache = false;
  G_InitNew(skill, newmap, random_seed);
  precache = true;
  usergame = false;
  demoplayback = true;
}
</t>
<t tx="T1370">@ G_TimeDemo
@c

void G_TimeDemo(const char *name)
{
  nodrawers = M_CheckParm("-nodraw");
  noblit = M_CheckParm("-noblit");
  timingdemo = true;
  singletics = true;

  defdemoname = name;
  gameaction = ga_playdemo;
}
</t>
<t tx="T1371">@ G_CheckDemoStatus

Called after a death or level completion to allow demos to be cleaned up,
Returns true if a new demo loop action will take place

-KM- 1998/07/10 Reformed code for limitless demo
@c

boolean_t G_CheckDemoStatus(void)
{
  int endtime;
  player_t *p;
  
  if (timingdemo)
  {
    float fps;

    endtime = I_GetTime();
    fps = ((float_t)(gametic * TICRATE)) / (endtime - starttime);
    I_Error("timed %i gametics in %i realtics, which equals %f fps", gametic,
        endtime - starttime, fps);
  }

  if (demoplayback)
  {
    if (singledemo)
    {
      // -ACB- 1999/09/20 New code order, shutdown system then close program.
      I_SystemShutdown();
      I_CloseProgram(0);
    }

    W_DoneWithLump(playdemobuffer);
    demoplayback = false;
    netdemo = false;
    netgame = false;
    deathmatch = false;

    //!!! FIXME: this is wrong
    for (p = players; p; p = p-&gt;next)
      p-&gt;in_game = false;

    level_flags.fastparm = false;
    level_flags.nomonsters = false;
    consoleplayer = playerlookup[0];
    E_AdvanceDemo();
    return true;
  }

  if (demorecording)
  {
    // Finish it
    WriteByteToDemo(DEMOMARKER);
    // Finish the demo file:
    fclose(demofile);
    demofile = NULL;
    I_Error("Demo recorded");

    demorecording = false;
  }

  return false;
}
</t>
<t tx="T1372">@ G_CheckWhenAppear

-AJA- 1999/10/23: written.
@c

boolean_t G_CheckWhenAppear(when_appear_e appear)
{
  if (! (appear &amp; (1 &lt;&lt; gameskill)))
    return false;

  if (!netgame &amp;&amp; !deathmatch &amp;&amp; !(appear &amp; WNAP_Single))
    return false;
    
  if (netgame &amp;&amp; !deathmatch &amp;&amp; !(appear &amp; WNAP_Coop))
    return false;

  if (deathmatch &amp;&amp; !(appear &amp; WNAP_DeathMatch))
    return false;

  return true;
}
</t>
<t tx="T1373">@ G_CheckConditions

-AJA- 2000/07/23: written.
@c

boolean_t G_CheckConditions(mobj_t *mo, condition_check_t *cond)
{
  player_t *p = mo-&gt;player;
  boolean_t temp;

  for (; cond; cond = cond-&gt;next)
  {
    switch (cond-&gt;cond_type)
    {
      case COND_Health:
        temp = (mo-&gt;health &gt;= cond-&gt;amount);
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
            return false;
        break;

      case COND_Armour:
        if (!p)
          return false;
        temp = (p-&gt;armours[cond-&gt;subtype] &gt;= cond-&gt;amount);
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Key:
        if (!p)
          return false;
        temp = ((p-&gt;cards &amp; cond-&gt;subtype) != 0);
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Weapon:
        if (!p)
          return false;
        temp = false;
        {
          int i;
          for (i=0; i &lt; MAXWEAPONS; i++)
          {
            if (p-&gt;weapons[i].owned &amp;&amp;
                p-&gt;weapons[i].info-&gt;bind_key == cond-&gt;subtype)
            {
              temp = true;
              break;
            }
          }
        }
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;
        
      case COND_Powerup:
        if (!p)
          return false;
        temp = (p-&gt;powers[cond-&gt;subtype] &gt; 0);
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Ammo:
        if (!p)
          return false;
        temp = (p-&gt;ammo[cond-&gt;subtype].num &gt;= cond-&gt;amount);
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Jumping:
        if (!p)
          return false;
        temp = (p-&gt;jumpwait &gt; 0);
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Crouching:
        if (!p)
          return false;
        temp = (mo-&gt;extendedflags &amp; EF_CROUCHING) ? true : false;
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Swimming:
        if (!p)
          return false;
        temp = p-&gt;swimming;
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Attacking:
        if (!p)
          return false;
        temp = p-&gt;attackdown || p-&gt;secondatk_down;
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Rampaging:
        if (!p)
          return false;
        temp = (p-&gt;attackdown_count &gt;= 70);
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_Using:
        if (!p)
          return false;
        temp = p-&gt;usedown;
        if ((!cond-&gt;negate &amp;&amp; !temp) || (cond-&gt;negate &amp;&amp; temp))
          return false;
        break;

      case COND_NONE:
      default:
        // unknown condition -- play it safe and succeed
        break;
    }
  }

  // all conditions succeeded
  return true;
}
</t>
<t tx="T1374">@ignore
@language c

// GUI Controls

&lt;&lt; gui_ctls #includes &gt;&gt;
&lt;&lt; gui_ctls declarations &gt;&gt;
@others
</t>
<t tx="T1375">#include "i_defs.h"
#include "gui_ctls.h"

#include "con_main.h"
#include "con_cvar.h"
#include "dm_state.h"
#include "gui_gui.h"
#include "hu_stuff.h"
#include "m_menu.h"
#include "m_misc.h"
#include "m_swap.h"
#include "v_res.h"
#include "v_colour.h"
#include "z_zone.h"
</t>
<t tx="T1376">
typedef struct button_s
{
  boolean_t status;
  char *string;
  gui_t *parent;
}
button_t;

typedef struct msgbox_s
{
  int msg;
  char *string;
  gui_t *gui;
  gui_t *parent;
}
msgbox_t;

typedef struct drag_s
{
  boolean_t mouse;
  gui_t *parent;
}
drag_t;

void BT_Drawer(gui_t * g);
boolean_t BT_Responder(gui_t * g, guievent_t * ev);
void MSG_Drawer(gui_t * g);
boolean_t MSG_Responder(gui_t * g, guievent_t * ev);
</t>
<t tx="T1377">
gui_t *GUI_BTStart(gui_t ** g, gui_t * parent, int id, int x, int y, char *string)
{
  gui_t *gui;
  button_t *bt;

  gui = Z_ClearNew(gui_t, 1);
  bt = gui-&gt;process = Z_New(button_t, 1);
  bt-&gt;string = Z_StrDup(string);

  gui-&gt;Responder = &amp;BT_Responder;
  gui-&gt;Drawer = &amp;BT_Drawer;

  gui-&gt;id = id;
  bt-&gt;parent = parent;

  gui-&gt;left = x;
  gui-&gt;top = y;
  gui-&gt;right = x + HL_StringWidth(string);
  gui-&gt;bottom = y + HL_StringHeight(string);

  GUI_Start(g, gui);
  return gui;
}
</t>
<t tx="T1378">
boolean_t BT_Responder(gui_t * g, guievent_t * ev)
{
  button_t *bt = g-&gt;process;
  guievent_t click;

  // Proper Init under ANSI C++
  click.type  = gev_bnclick;
  click.data1 = g-&gt;id;

  switch (ev-&gt;type)
  {
    case gev_keydown:
      if (ev-&gt;data1 == KEYD_MOUSE1)
        bt-&gt;status = true;
      break;
    case gev_keyup:
      if (ev-&gt;data1 == KEYD_MOUSE1 &amp;&amp; bt-&gt;status)
      {
        bt-&gt;status = false;
        return GUI_Responder(&amp;bt-&gt;parent, &amp;click);
      }
      bt-&gt;status = false;
      break;
    case gev_destroy:
      Z_Free(bt-&gt;string);
      Z_Free(bt);
      return false;
    default:
      break;
  }

  return false;
}
</t>
<t tx="T1379">
void BT_Drawer(gui_t * g)
{
  button_t *bt = g-&gt;process;

  GUI_WriteText(main_scr, g-&gt;left, g-&gt;top, bt-&gt;string);
}
</t>
<t tx="T1380">
gui_t *GUI_MSGStart(gui_t ** g, gui_t * parent, int msg_id, int id, char *string)
{
  gui_t *gui;
  msgbox_t *msg;

  gui = Z_ClearNew(gui_t, 1);
  msg = gui-&gt;process = Z_New(msgbox_t, 1);

  gui-&gt;Responder = &amp;MSG_Responder;
  gui-&gt;Drawer = &amp;MSG_Drawer;

  msg-&gt;string = Z_StrDup(string);
  msg-&gt;parent = parent;
  msg-&gt;msg = msg_id;
  gui-&gt;id = id;

  gui-&gt;top = SCREENHEIGHT / 2 - 30;
  gui-&gt;bottom = SCREENHEIGHT / 2 + 30;
  gui-&gt;left = SCREENWIDTH / 4;
  gui-&gt;right = 3 * SCREENWIDTH / 4;

  GUI_Init(&amp;msg-&gt;gui);
  GUI_BTStart(&amp;msg-&gt;gui, gui, 0, SCREENWIDTH / 2 - 4, SCREENHEIGHT / 2 + 16, "OK");

  GUI_Start(g, gui);
  return gui;
}
</t>
<t tx="T1381">
boolean_t MSG_Responder(gui_t * g, guievent_t * ev)
{
  int r;
  msgbox_t *msg = g-&gt;process;
  guievent_t ok;

  switch (ev-&gt;type)
  {
    case gev_bnclick:
      {
        // Proper init under ANSI C++
        ok.type  = msg-&gt;msg;
        ok.data1 = g-&gt;id;

        r = GUI_Responder(&amp;msg-&gt;parent, &amp;ok);
        GUI_Destroy(g);
        return r;
      }
    case gev_destroy:
      GUI_Destroy(msg-&gt;gui);
      Z_Free(msg-&gt;string);
      Z_Free(msg-&gt;gui);
      Z_Free(msg);
      break;

    default:
      return GUI_Responder(&amp;msg-&gt;gui, ev);
  }

  return false;
}
</t>
<t tx="T1382">
void MSG_Drawer(gui_t * g)
{
  msgbox_t *msg = g-&gt;process;

#if 0
  V_TextureBackScreen(main_scr, "FLOOR0_1", g-&gt;left, g-&gt;top, g-&gt;right, g-&gt;bottom);
#endif

  GUI_WriteText(main_scr, (g-&gt;left + g-&gt;right - HL_StringWidth(msg-&gt;string)) / 2,
      (g-&gt;top + 12), msg-&gt;string);

  GUI_Drawer(&amp;msg-&gt;gui);
}
</t>
<t tx="T1383">
static boolean_t DRAG_Responder(gui_t * g, guievent_t * ev)
{
  drag_t *drag = (drag_t *) g-&gt;process;
  guievent_t event;

  switch (ev-&gt;type)
  {
    case gev_hover:
      if (drag-&gt;mouse)
      {
        event = *ev;
        event.type = gev_drag;
        GUI_Responder(&amp;drag-&gt;parent, &amp;event);
        return true;
      }
      break;
    case gev_keydown:
      if (ev-&gt;data1 == KEYD_MOUSE1)
      {
        drag-&gt;mouse = true;
        return true;
      }
      return false;
    case gev_keyup:
      if (drag-&gt;mouse &amp;&amp; ev-&gt;data1 == KEYD_MOUSE1)
        drag-&gt;mouse = false;
      return false;
    case gev_destroy:
      Z_Free(drag);
      return false;
    default:
      return false;
  }
  return false;
}
</t>
<t tx="T1384">
gui_t *GUI_DRAGStart(gui_t ** g, gui_t * parent, int id)
{
  gui_t *gui;
  drag_t *drag;

  gui = Z_ClearNew(gui_t, 1);
  drag = gui-&gt;process = Z_New(drag_t, 1);

  gui-&gt;Responder = &amp;DRAG_Responder;

  drag-&gt;parent = parent;
  drag-&gt;mouse = 0;
  gui-&gt;id = id;

  GUI_Start(g, gui);
  return gui;
}
</t>
<t tx="T1385">
void GUI_WriteText(screen_t * scr, int x, int y, char *string)
{
  //!!!!! IGNORES `scr' -- will fix for layer system
  
  HL_WriteText(x, y, string);
}
</t>
<t tx="T1386">
typedef struct
{
  char *watch;
  gui_t *gui;
  int max;
}
bar_t;

static boolean_t BAR_Responder(gui_t * g, guievent_t * ev)
{
  bar_t *bar = g-&gt;process;

  switch (ev-&gt;type)
  {
    case gev_drag:
      ev-&gt;type = gev_move;
      GUI_Responder(&amp;g, ev);
      return true;
    
    case gev_destroy:
      GUI_Destroy(bar-&gt;gui);
      Z_Free(bar-&gt;watch);
      Z_Free(bar);
      break;
      
    case gev_keydown:
      if (ev-&gt;data1 == KEYD_MOUSE2)
      {
        GUI_Destroy(g);
        return true;
      }
    
    default:
      return GUI_Responder(&amp;bar-&gt;gui, ev);
      
    case gev_move:
    case gev_size:
      GUI_Responder(&amp;bar-&gt;gui, ev);
      break;
  }

  return false;
}
</t>
<t tx="T1387">@ BAR_Drawer

This does?
@c

static void BAR_Drawer(gui_t * gui)
{
  bar_t *bar = gui-&gt;process;
  const int *valp;
  unsigned int val;
  unsigned int x, y;
  int r, g, b;
// --UNUSED--
//  int left = gui-&gt;left, right = gui-&gt;right, top = gui-&gt;top, bottom = gui-&gt;bottom;
  char *dest;

  if (!CON_GetCVar(bar-&gt;watch, (const void **)&amp;valp))
    return;

  if (!valp)
    return;

  val = *valp;
  val = val * 100 / bar-&gt;max;

  r = val / 2;
  if (val &gt;= 31)
    r = 31 - r;
  if (r &lt; 0)
    r = 0;

  g = val / 3;
  if (g &gt; 31)
    g = 31;

  b = 0;

// --UNUSED--
//  if (left &lt; 0)
//    left = 0;
  
// --UNUSED--
//  if (right &gt;= SCREENWIDTH)
//    right = SCREENWIDTH - 1;
  
// --UNUSED--
//  if (top &lt; 0)
//    top = 0;

// --UNUSED--
//  if (bottom &gt;= SCREENHEIGHT)
//    bottom = SCREENHEIGHT - 1;

  for (y = (unsigned int)gui-&gt;top; y &lt; (unsigned int)gui-&gt;bottom; y++)
  {
    dest = main_scr-&gt;data + y * SCREENDEPTH + gui-&gt;left * BPP;
    for (x = gui-&gt;left; x &lt; (gui-&gt;right - gui-&gt;left) * val / 100 + gui-&gt;left; x++, dest++)
      *dest = rgb_32k[r][g][b];
  }
}
</t>
<t tx="T1388">
gui_t *GUI_BARStart(gui_t ** g, char *watch, int max)
{
  gui_t *gui;
  bar_t *bar;
  guievent_t ev;

  gui = Z_ClearNew(gui_t, 1);
  gui-&gt;process = bar = Z_New(bar_t, 1);

  bar-&gt;watch = Z_StrDup(watch);
  bar-&gt;max = max;

  gui-&gt;Responder = &amp;BAR_Responder;
  gui-&gt;Drawer = &amp;BAR_Drawer;

  gui-&gt;id = 0;

  GUI_Init(&amp;bar-&gt;gui);
  GUI_DRAGStart(&amp;bar-&gt;gui, gui, 0);
  ev.type = gev_size;
  ev.data1 = 100;
  ev.data2 = 16;
  GUI_Responder(&amp;bar-&gt;gui, &amp;ev);

  gui-&gt;right = 100;
  gui-&gt;bottom = 16;

  GUI_Start(g, gui);
  return gui;
}
</t>
<t tx="T1389">@ignore
@language c

// GUI Main

&lt;&lt; gui_main #includes &gt;&gt;
&lt;&lt; gui_main declarations &gt;&gt;
@others
</t>
<t tx="T1390">#include "i_defs.h"
#include "gui_main.h"

#include "dm_type.h"
#include "dm_state.h"
#include "gui_gui.h"
#include "con_main.h"
#include "con_cvar.h"
#include "v_res.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1391">
static int mouse_x = 0, mouse_y = 0;
static boolean_t mouse_visible = false;

static int mouse;

static gui_t *main_gui;
</t>
<t tx="T1392">
void GUI_Init(gui_t **gui)
{
  *gui = Z_ClearNew(gui_t, 1);

  (*gui)-&gt;prev = *gui;
  (*gui)-&gt;next = *gui;
  (*gui)-&gt;gui = gui;
}
</t>
<t tx="T1393">
gui_t **GUI_NULL(void)
{
  return &amp;main_gui;
}
</t>
<t tx="T1394">
void GUI_Start(gui_t ** gui, gui_t * g)
{
  guievent_t spawn =
  {gev_spawn, 0,0,0,0};

  g-&gt;next = *gui;
  g-&gt;prev = (*gui)-&gt;prev;
  g-&gt;next-&gt;prev = g;
  g-&gt;prev-&gt;next = g;
  g-&gt;gui = gui;
  GUI_Responder(&amp;g, &amp;spawn);
  GUI_SetFocus(gui, g);
}
</t>
<t tx="T1395">
void GUI_Destroy(gui_t * g)
{
  guievent_t destroy =
  {gev_destroy, 0,0,0,0};

  if (!GUI_Responder(&amp;g, &amp;destroy))
  {
    g-&gt;next-&gt;prev = g-&gt;prev;
    g-&gt;prev-&gt;next = g-&gt;next;
    if (*g-&gt;gui == g)
      *g-&gt;gui = g-&gt;next;
    Z_Free(g);
  }
}
</t>
<t tx="T1396">
void GUI_SetFocus(gui_t ** gui, gui_t * g)
{
  guievent_t lose =
  {gev_losefocus, 0,0,0,0};

  if (!GUI_Responder(gui, &amp;lose))
    *gui = g;
}
</t>
<t tx="T1397">
void GUI_Ticker(gui_t ** gui)
{
  gui_t *g = *gui;

  do
  {
    if (g-&gt;Ticker)
      g-&gt;Ticker(g);

    g = g-&gt;next;
  }
  while (g != *gui);
}
</t>
<t tx="T1398">
static boolean_t GUI_InBox(int x, int y, gui_t * g)
{
  return (x &lt;= g-&gt;right &amp;&amp; x &gt;= g-&gt;left &amp;&amp; y &lt;= g-&gt;bottom &amp;&amp; y &gt;= g-&gt;top);
}
</t>
<t tx="T1399">
boolean_t GUI_Responder(gui_t ** gui, guievent_t * e)
{
  gui_t *g = *gui;
  guievent_t event = *e;
  boolean_t eat;
  const visible_t *v;

  switch (event.type)
  {
    case gev_analogue:
      mouse_x += event.data2;
      if (mouse_x &gt;= SCREENWIDTH)
        mouse_x = SCREENWIDTH - 1;
      else if (mouse_x &lt; 0)
        mouse_x = 0;

      mouse_y += event.data4;
      if (mouse_y &gt;= SCREENHEIGHT)
        mouse_y = SCREENHEIGHT - 1;
      else if (mouse_y &lt; 0)
        mouse_y = 0;

      event.type = gev_hover;
      event.data1 = event.data2;
      event.data2 = event.data4;
      event.data3 = mouse_x;
      event.data4 = mouse_y;
      if (!mouse_visible)
        return false;
      break;
    case gev_keydown:
      if (event.data1 == KEYD_TILDE)
      {
        CON_GetCVar("constate", (const void **)&amp;v);
        CON_SetVisible(((*v) + 1) % NUMVIS);
        return true;
      }
      break;
    default:
      break;
  }

  if (event.type == gev_keydown
      &amp;&amp; event.data1 &gt;= KEYD_MOUSE1
      &amp;&amp; event.data1 &lt;= KEYD_MOUSE4)
    eat = GUI_InBox(mouse_x, mouse_y, g) &amp;&amp; mouse_visible;
  else
    eat = true;
  if (g-&gt;Responder &amp;&amp; eat)
  {
    eat = g-&gt;Responder(g, &amp;event);
    if (!eat)
    {
      switch (e-&gt;type)
      {
        case gev_move:
          g-&gt;left += event.data1;
          g-&gt;right += event.data1;
          g-&gt;top += event.data2;
          g-&gt;bottom += event.data2;
          return true;
        case gev_size:
          g-&gt;right += event.data1;
          g-&gt;bottom += event.data2;
          return true;
        default:
          return false;
      }
    }
    return eat;
  }
  else if (!eat &amp;&amp; mouse_visible)
  {
    g = g-&gt;next;
    do
    {
      if (GUI_InBox(mouse_x, mouse_y, g))
      {
        GUI_SetFocus(gui, g);
        if (g-&gt;Responder)
          return g-&gt;Responder(g, &amp;event);
        else
          return false;
      }

      g = g-&gt;next;
    }
    while (g != *gui);
  }

  return false;
}
</t>
<t tx="T1400">
void GUI_Drawer(gui_t ** gui)
{
  gui_t *g = (*gui)-&gt;prev;

  do
  {
    if (g-&gt;Drawer)
      g-&gt;Drawer(g);

    g = g-&gt;prev;
  }
  while (g != (*gui)-&gt;prev);

#if 0  // V_DrawPatch no longer usable
  if (mouse_visible)
  {
    const patch_t *p;
    p = W_CacheLumpNum(mouse);
    V_DrawPatch(main_scr, mouse_x, mouse_y, p);
    W_DoneWithLump(p);
  }
#endif
}
</t>
<t tx="T1401">
void GUI_MainTicker(void)
{
  GUI_Ticker(&amp;main_gui);
}
</t>
<t tx="T1402">
boolean_t GUI_MainResponder(event_t * ev)
{
  guievent_t ge;

  if (ev-&gt;type == ev_analogue)
  {
    ge.type = gev_analogue;
    ge.data1 = ev-&gt;value.analogue.axis;
    ge.data2 = ev-&gt;value.analogue.amount;
    ge.data3 = AXIS_DISABLE;
  }
  else
  {
    if (ev-&gt;type == ev_keyup)
      ge.type = gev_keyup;
    else
    {
      DEV_ASSERT2(ev-&gt;type == gev_keydown);
      ge.type = gev_keydown;
    }

    ge.data1 = ev-&gt;value.key;
  }
  
  return GUI_Responder(&amp;main_gui, &amp;ge);
}
</t>
<t tx="T1403">
void GUI_MainDrawer(void)
{
  GUI_Drawer(&amp;main_gui);
}
</t>
<t tx="T1404">@ GUI_MainInit
@c

boolean_t GUI_MainInit(void)
{
  mouse = W_GetNumForName("mouse");
  GUI_Init(&amp;main_gui);
  CON_Start(&amp;main_gui);
  return true;
}
</t>
<t tx="T1405">
void GUI_InitResolution(void)
{
  CON_InitResolution();
}
</t>
<t tx="T1406">
void GUI_MainSetMouseVisibility(boolean_t visible)
{
  mouse_visible = visible;
}
</t>
<t tx="T1407">
boolean_t GUI_MainGetMouseVisibility(void)
{
  return mouse_visible;
}
</t>
<t tx="T1408">
boolean_t GUI_SetMouse(char *name)
{
  mouse = W_CheckNumForName(name);
  if (mouse == -1)
  {
    mouse = W_GetNumForName("mouse");
    return false;
  }
  return true;
}
</t>
<t tx="T1409">@ignore
@language c

// Heads-up-display library Code

// -KM- 1998/10/29 Modified to allow foreign characters like ''

&lt;&lt; hu_lib #includes &gt;&gt;
@others
</t>
<t tx="T1410">#include "i_defs.h"
#include "hu_lib.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "hu_stuff.h"
#include "m_inline.h"
#include "m_swap.h"
#include "r_local.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "v_res.h"
</t>
<t tx="T1411">
#define DUMMY_WIDTH(font)  (4)

//
// HL_Init
//
void HL_Init(void)
{
  /* nothing to init */
}
</t>
<t tx="T1412">@ HL_CharWidth

Returns the width of the IBM cp437 char in the font.
@c

int HL_CharWidth(const H_font_t *font, int ch)
{
  // catch sign extension from (char)
  DEV_ASSERT2(ch &gt;= 0);

  if (ch &lt; 128)
    ch = toupper(ch);

  if (ch &lt; font-&gt;first_ch || ch &gt; font-&gt;last_ch)
    return DUMMY_WIDTH(font);

  return IM_WIDTH(HFONT_GET_CH(font, ch));
}
</t>
<t tx="T1413">@ HL_TextMaxLen

Returns the maximum number of characters which can fit within max_w
pixels. The string may not contain any newline characters.
@c

int HL_TextMaxLen(int max_w, const unsigned char *str)
{
  int w;
  const unsigned char *s;

  // just add one char at a time until it gets too wide or the string ends.
  for (w=0, s=str; *s; s++)
  {
    w += HL_CharWidth(&amp;hu_font, *s);

    if (w &gt; max_w)
    {
      // if no character could fit, an infinite loop would probably start,
      // so it's better to just imagine that one character fits.
      if (s == str)
        s = str + 1;
      break;
    }
  }

  // extra spaces at the end of the line can always be added
  while (*s == ' ')
    s++;

  return s - str;
}
</t>
<t tx="T1414">@ HL_StringWidth

Find string width from hu_font chars. The string may not contain
any newline characters.
@c

int HL_StringWidth(const unsigned char *str)
{
  int w;

  for (w=0; *str; str++)
  {
    w += HL_CharWidth(&amp;hu_font, *str);
  }

  return w;
}
</t>
<t tx="T1415">@ HL_StringHeight

Find string height from hu_font chars
@c

int HL_StringHeight(const unsigned char *string)
{
  int h;
  int height = hu_font.height;

  h = height;

  for (; *string; string++)
    if (*string == '\n')
      h += height;

  return h;
}
</t>
<t tx="T1416">@ HL_WriteChar
@c

static void HL_WriteChar(int x, int y, const H_font_t *font, int c,
    const colourmap_t *colmap, fixed_t alpha)
{
  const image_t *image = HFONT_GET_CH(font, c);
  
  vctx.DrawImage(FROM_320(x - image-&gt;offset_x), 
      FROM_200(y - image-&gt;offset_y),
      FROM_320(IM_WIDTH(image)), FROM_200(IM_HEIGHT(image)), image,
      0.0, 0.0, IM_RIGHT(image), IM_BOTTOM(image), colmap,
      M_FixedToFloat(alpha));
}
</t>
<t tx="T1417">@ HL_WriteTextTrans

Write a string using the hu_font and index translator.
@c

void HL_WriteTextTrans(int x, int y, const colourmap_t *colmap, 
    const unsigned char *string)
{
  int w, c, cx, cy;

  cx = x;
  cy = y;

  for (; *string; string++)
  {
    c = *string;

    if (c == '\n')
    {
      cx = x;
      cy += 12;
      continue;
    }

    if (c &lt; 128)
      c = toupper(c);

    if (c &lt; hu_font.first_ch || c &gt; hu_font.last_ch)
    {
      cx += DUMMY_WIDTH(&amp;hu_font);
      continue;
    }

    w = HL_CharWidth(&amp;hu_font, c);

    if (cx + w &gt; 320)
      continue;

    HL_WriteChar(cx, cy, &amp;hu_font, c, colmap, FRACUNIT);

    cx += w;
  }
}
</t>
<t tx="T1418">@ HL_WriteText

Write a string using the hu_font.
@c

void HL_WriteText(int x, int y, const unsigned char *string)
{
  HL_WriteTextTrans(x, y, text_red_map, string);
}
</t>
<t tx="T1419">@ ----------------------------------------------------------------------------
@c

void HL_ClearTextLine(hu_textline_t * t)
{
  t-&gt;len = 0;
  t-&gt;ch[0] = 0;
  t-&gt;needsupdate = true;
  t-&gt;centre = false;
}
</t>
<t tx="T1420">
void HL_InitTextLine(hu_textline_t * t, int x, int y, 
    const H_font_t *font)
{
  t-&gt;x = x;
  t-&gt;y = y;
  t-&gt;font = font;
  HL_ClearTextLine(t);
}
</t>
<t tx="T1421">
boolean_t HL_AddCharToTextLine(hu_textline_t * t, char ch)
{
  if (t-&gt;len &gt;= HU_MAXLINELENGTH-1)
    return false;

  t-&gt;ch[t-&gt;len++] = ch;
  t-&gt;ch[t-&gt;len] = 0;
  t-&gt;needsupdate = 4;
  return true;
}
</t>
<t tx="T1422">
boolean_t HL_DelCharFromTextLine(hu_textline_t * t)
{
  if (!t-&gt;len)
    return false;

  t-&gt;len--;
  t-&gt;ch[t-&gt;len] = 0;
  t-&gt;needsupdate = 4;
  return true;
}
</t>
<t tx="T1423">
#define HU_CHAR(ch)  ((ch) &lt; 128 ? toupper(ch) : (ch))

//
// HL_DrawTextLineAlpha
//
// New Procedure: Same as HL_DrawTextLine, but the
// colour is passed through the given translation table
// and scaled if possible.
//
// -ACB- 1998/06/10 Procedure Written.
//
// -ACB- 1998/09/11 Index changed from JC's Pre-Calculated to using
//                  the PALREMAP translation maps.
//
// -AJA- 2000/03/05: Index replaced with pointer to trans table.
// -AJA- 2000/10/22: Renamed for alpha support.
//
void HL_DrawTextLineAlpha(hu_textline_t * L, boolean_t drawcursor, 
    const colourmap_t *colmap, fixed_t alpha)
{
  int i, w, x, y;
  unsigned char c;

  // draw the new stuff
  x = L-&gt;x;
  y = L-&gt;y;

  // -AJA- 1999/09/07: centred text.
  if (L-&gt;centre)
  {
    x -= HL_StringWidth(L-&gt;ch) / 2;
  }

  for (i=0; (i &lt; L-&gt;len) &amp;&amp; (x &lt; 320); i++, x += w)
  {
    c = HU_CHAR(L-&gt;ch[i]);
    w = HL_CharWidth(L-&gt;font, c);

    if (c &lt; L-&gt;font-&gt;first_ch || c &gt; L-&gt;font-&gt;last_ch)
      continue;

    if (x &lt; 0)
      continue;

    if (x + w &gt; 320)
      continue;

    HL_WriteChar(x, y, L-&gt;font, c, colmap, alpha);
  }

  // draw the cursor if requested
  if (drawcursor &amp;&amp; x + L-&gt;font-&gt;width &lt;= 320)
  {
    HL_WriteChar(x, y, L-&gt;font, '_', colmap, alpha);
  }
}
</t>
<t tx="T1424">
void HL_DrawTextLine(hu_textline_t * L, boolean_t drawcursor)
{
  HL_DrawTextLineAlpha(L, drawcursor, text_red_map, FRACUNIT);
  
#if 0  // OLD CODE
  int i, w, x, y;
  unsigned char c;
  
  // draw the new stuff
  x = L-&gt;x;
  y = L-&gt;y;

  // -AJA- 1999/09/07: centred text.
  if (L-&gt;centre)
  {
    x -= HL_StringWidth(L-&gt;ch) / 2;
  }

  for (i=0; (i &lt; L-&gt;len) &amp;&amp; (x &lt; SCREENWIDTH); i++, x += w)
  {
    c = HU_CHAR(L-&gt;ch[i]);
    w = HL_CharWidth(L-&gt;font, c);

    if (c &lt; L-&gt;font-&gt;first_ch || c &gt; L-&gt;font-&gt;last_ch)
      continue;

    if (x &lt; 0)
      continue;

    // -ACB- 1998/06/09 was (x+w &gt; 320):
    //       not displaying all text at high resolutions.
    if (x + w &gt; SCREENWIDTH)
      continue;

#ifdef USE_GL
    /// RGL_DrawPatch(hu_font_nums[c - l-&gt;sc], x, l-&gt;y);
#else
    V_DrawPatchDirect(main_scr, x, y, HFONT_GET_CH(L-&gt;font,c));
#endif
  }

  // draw the cursor if requested
  if (drawcursor &amp;&amp; x + L-&gt;font-&gt;width &lt;= SCREENWIDTH)
    V_DrawPatchDirect(main_scr, x, L-&gt;y, HFONT_GET_CH(L-&gt;font,'_'));
#endif
}
</t>
<t tx="T1425">@ sorta called by HU_Erase and just better darn get things straight
@c

void HL_EraseTextLine(hu_textline_t * l)
{
#if 0 // OLD STUFF
  int lh;
  int y;
  int yoffset;
  static boolean_t lastautomapactive = true;

  // Only erases when NOT in automap and the screen is reduced,
  // and the text must either need updating or refreshing
  // (because of a recent change back from the automap)

  if (!automapactive &amp;&amp; viewwindowx &amp;&amp; l-&gt;needsupdate)
  {
    lh = SHORT(l-&gt;f[0]-&gt;height) + 1;
    for (y = l-&gt;y, yoffset = y * SCREENWIDTH; y &lt; l-&gt;y + lh; y++, yoffset += SCREENWIDTH)
    {
      if (y &lt; viewwindowy || y &gt;= viewwindowy + viewwindowheight)
        R_VideoErase(yoffset, SCREENWIDTH);  // erase entire line

      else
      {
        R_VideoErase(yoffset, viewwindowx);  // erase left border

        R_VideoErase(yoffset + viewwindowx + viewwidth, viewwindowx);
        // erase right border
      }
    }
  }

  lastautomapactive = automapactive;
  if (l-&gt;needsupdate)
    l-&gt;needsupdate--;
#endif
}
</t>
<t tx="T1426">@ ----------------------------------------------------------------------------
@c

void HL_InitSText(hu_stext_t * s, int x, int y, int h, 
    const H_font_t *font, boolean_t * on)
{
  int i;

  s-&gt;h = h;
  s-&gt;on = on;
  s-&gt;laston = true;
  s-&gt;curline = 0;

  for (i = 0; i &lt; h; i++)
  {
    HL_InitTextLine(&amp;s-&gt;L[i], x, y - i * (font-&gt;height+1), font);
  }
}
</t>
<t tx="T1427">
void HL_AddLineToSText(hu_stext_t * s)
{
  int i;

  // add a clear line
  if (++s-&gt;curline == s-&gt;h)
    s-&gt;curline = 0;

  HL_ClearTextLine(&amp;s-&gt;L[s-&gt;curline]);

  // everything needs updating
  for (i=0; i &lt; s-&gt;h; i++)
    s-&gt;L[i].needsupdate = 4;
}
</t>
<t tx="T1428">
void HL_AddMessageToSText(hu_stext_t * s, 
    const unsigned char *prefix, const unsigned char *msg)
{
  HL_AddLineToSText(s);

  if (prefix)
    for (; *prefix; prefix++)
      HL_AddCharToTextLine(&amp;s-&gt;L[s-&gt;curline], *prefix);

  for (; *msg; msg++)
    HL_AddCharToTextLine(&amp;s-&gt;L[s-&gt;curline], *msg);
}
</t>
<t tx="T1429">
void HL_DrawSText(hu_stext_t * s)
{
  int i, idx;

  if (!*s-&gt;on)
    return;  // if not on, don't draw

  // draw everything
  for (i=0; i &lt; s-&gt;h; i++)
  {
    idx = s-&gt;curline - i;
    if (idx &lt; 0)
      idx += s-&gt;h;  // handle queue of lines

    // need a decision made here on whether to skip the draw.
    // no cursor, please.
    HL_DrawTextLine(&amp;s-&gt;L[idx], false);
  }
}
</t>
<t tx="T1430">
void HL_EraseSText(hu_stext_t * s)
{
  int i;

  for (i=0; i &lt; s-&gt;h; i++)
  {
    if (s-&gt;laston &amp;&amp; !*s-&gt;on)
      s-&gt;L[i].needsupdate = 4;

    HL_EraseTextLine(&amp;s-&gt;L[i]);
  }
  s-&gt;laston = *s-&gt;on;
}
</t>
<t tx="T1431">@ ----------------------------------------------------------------------------
@c

void HL_InitIText(hu_itext_t * it, int x, int y, 
    const H_font_t *font, boolean_t * on)
{
  // default left margin is start of text
  it-&gt;margin = 0;

  it-&gt;on = on;
  it-&gt;laston = true;

  HL_InitTextLine(&amp;it-&gt;L, x, y, font);
}
</t>
<t tx="T1432">@ The following deletion routines adhere to the left margin restriction
@c

void HL_DelCharFromIText(hu_itext_t * it)
{
  if (it-&gt;L.len != it-&gt;margin)
    HL_DelCharFromTextLine(&amp;it-&gt;L);
}
</t>
<t tx="T1433">
void HL_EraseLineFromIText(hu_itext_t * it)
{
  while (it-&gt;margin != it-&gt;L.len)
    HL_DelCharFromTextLine(&amp;it-&gt;L);
}
</t>
<t tx="T1434">@ Resets left margin as well
@c

void HL_ResetIText(hu_itext_t * it)
{
  it-&gt;margin = 0;
  HL_ClearTextLine(&amp;it-&gt;L);
}
</t>
<t tx="T1435">
void HL_AddPrefixToIText(hu_itext_t * it, const unsigned char *str)
{
  for (; *str; str++)
    HL_AddCharToTextLine(&amp;it-&gt;L, *str);

  it-&gt;margin = it-&gt;L.len;
}
</t>
<t tx="T1436">@ wrapper function for handling general keyed input.
returns true if it ate the key
@c

boolean_t HL_KeyInIText(hu_itext_t * it, const unsigned char ch)
{
  if (ch &gt;= ' ' &amp;&amp; ch &lt;= '_')
    HL_AddCharToTextLine(&amp;it-&gt;L, (char)ch);
  else if (ch == KEYD_BACKSPACE)
    HL_DelCharFromIText(it);
  else if (ch != KEYD_ENTER)
    return false;

  // ate the key
  return true;
}
</t>
<t tx="T1437">
void HL_DrawIText(hu_itext_t * it)
{
  if (!*it-&gt;on)
    return;

  // draw the line with cursor
  HL_DrawTextLine(&amp;it-&gt;L, true);

}
</t>
<t tx="T1438">
void HL_EraseIText(hu_itext_t * it)
{
  if (it-&gt;laston &amp;&amp; !*it-&gt;on)
    it-&gt;L.needsupdate = 4;
    
  HL_EraseTextLine(&amp;it-&gt;L);

  it-&gt;laston = *it-&gt;on;
}
</t>
<t tx="T1439">@ignore
@language c

// Heads-Up-Display Code

&lt;&lt; hu_stuff #includes &gt;&gt;
&lt;&lt; hu_stuff declarations &gt;&gt;
@others
</t>
<t tx="T1440">#include "i_defs.h"
#include "hu_stuff.h"

#include "con_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "dstrings.h"
#include "hu_lib.h"
#include "m_misc.h"
#include "m_swap.h"
#include "r_defs.h"
#include "r_plane.h"
#include "r_things.h"
#include "rad_trig.h"
#include "s_sound.h"
#include "st_stuff.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "v_res.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1441">
//
// Locally used constants, shortcuts.
//
// -ACB- 1998/08/09 Removed the HU_TITLE stuff; Use currentmap-&gt;description.
//
#define HU_TITLEHEIGHT	1
#define HU_TITLEX	0
#define HU_TITLEY	(200 - 32 - 10) 
#define HU_INPUTTOGGLE	key_talk
#define HU_INPUTX	HU_MSGX
#define HU_INPUTY	(HU_MSGY + HU_MSGHEIGHT * (hu_font.height+1))
#define HU_INPUTWIDTH	64
#define HU_INPUTHEIGHT	1

#define HU_CROSSHAIRCOLOUR  RED

const char *chat_macros[10];

H_font_t hu_font;

boolean_t chat_on;
static hu_textline_t w_title;
static hu_itext_t w_chat;
static boolean_t always_off = false;

static char *chat_dest;
static hu_itext_t *w_inputbuffer;

boolean_t message_dontfuckwithme;
static boolean_t message_on;
static boolean_t message_nottobefuckedwith;

static hu_stext_t w_message;
static int message_counter;

static boolean_t headsupactive = false;

// 23-6-98 KM Added a line showing the current limits in the
// render code.  Note that these are not really limits,
// just show how many items we have enough memory for.  These
// numbers will increase as needed.  vp = visplanes, vs = vissprites,
static hu_textline_t textlinefps;
static hu_textline_t textlinepos;
static hu_textline_t textlinestats;
static hu_textline_t textlinememory;

// -ACB- 1999/09/28 was english_shiftxform. Only one used.
static const unsigned char shiftxform[] =
{
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
  21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  
  ' ', '!', '"', '#', '$', '%', '&amp;',
  '"',  // shift-'
  '(', ')', '*', '+',
  '&lt;',  // shift-,
  '_',  // shift--
  '&gt;',  // shift-.
  '?',  // shift-/
  ')',  // shift-0
  '!',  // shift-1
  '@',  // shift-2
  '#',  // shift-3
  '$',  // shift-4
  '%',  // shift-5
  '^',  // shift-6
  '&amp;',  // shift-7
  '*',  // shift-8
  '(',  // shift-9
  ':',
  ':',  // shift-;
  '&lt;',
  '+',  // shift-=
  '&gt;', '?', '@',
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  '[',  // shift-[
  '!',  // shift-backslash
  ']',  // shift-]
  '"', '_',
  '\'',  // shift-`
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  '{', '|', '}', '~', 127,
  
  128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
  140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,
  152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
  164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
  176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187,
  188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 
  200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 
  212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
  224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 
  236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 
  248, 249, 250, 251, 252, 253, 254, 255
};
</t>
<t tx="T1442">@ Heads-up Init
@c

boolean_t HU_Init(void)
{
  int i;
  char buffer[10];
  const image_t *missing;

  chat_dest = Z_New(char, MAXPLAYERS);
  w_inputbuffer = Z_New(hu_itext_t, MAXPLAYERS);

  // load the heads-up font
  strcpy(hu_font.name, "HEADS_UP");
  strcpy(hu_font.prefix, "STCFN");
  hu_font.first_ch = '!';
  hu_font.last_ch  = 255;
 
  hu_font.images = Z_ClearNew(const image_t *, 256 - '!');

  missing = W_ImageFromFont("STCFN000");

  for (i=hu_font.first_ch; i &lt;= hu_font.last_ch; i++)
  {
    int j = i - hu_font.first_ch;
    
    // -KM- 1998/10/29 Chars not found will be replaced by a default.
    sprintf(buffer, "%s%.3d", hu_font.prefix, i);

    if (W_CheckNumForName(buffer) &gt;= 0)
      hu_font.images[j] = W_ImageFromFont(buffer);
    else
      hu_font.images[j] = missing;
  }
 
  hu_font.width  = IM_WIDTH(hu_font.images['M' - '!']);
  hu_font.height = IM_HEIGHT(hu_font.images['M' - '!']);

  return true;
}
</t>
<t tx="T1443">
static void HU_Stop(void)
{
  headsupactive = false;
}
</t>
<t tx="T1444">@ -ACB- 1998/08/09 Used Currentmap to set the map name in string
@c

void HU_Start(void)
{
  int i;
  const char *string;

  if (headsupactive)
    HU_Stop();

  message_on = false;
  message_dontfuckwithme = false;
  message_nottobefuckedwith = false;
  chat_on = false;

  // create the message widget
  HL_InitSText(&amp;w_message,
      HU_MSGX, HU_MSGY, HU_MSGHEIGHT,
      &amp;hu_font, &amp;message_on);

  // create the map title widget
  HL_InitTextLine(&amp;w_title, HU_TITLEX, HU_TITLEY, &amp;hu_font);

  //create stuff for showstats cheat
  // 23-6-98 KM Limits info added.
  HL_InitTextLine(&amp;textlinefps,
      0, 1 * (1 + hu_font.height), &amp;hu_font);
  HL_InitTextLine(&amp;textlinestats,
      0, 2 * (1 + hu_font.height), &amp;hu_font);
  HL_InitTextLine(&amp;textlinepos,
      0, 3 * (1 + hu_font.height), &amp;hu_font);
  HL_InitTextLine(&amp;textlinememory,
      0, 5 * (1 + hu_font.height), &amp;hu_font);

  // -ACB- 1998/08/09 Use Currentmap settings
  if (currentmap-&gt;description &amp;&amp;
      DDF_LanguageValidRef(currentmap-&gt;description))
  {
    string = DDF_LanguageLookup(currentmap-&gt;description);
    I_Printf("Entering %s\n", string);

    for (; *string; string++)
      HL_AddCharToTextLine(&amp;w_title, *string);
  }

  // create the chat widget
  HL_InitIText(&amp;w_chat, HU_INPUTX, HU_INPUTY,
      &amp;hu_font, &amp;chat_on);

  // create the inputbuffer widgets
  for (i = 0; i &lt; MAXPLAYERS; i++)
    HL_InitIText(&amp;w_inputbuffer[i], 0, 0, &amp;hu_font, &amp;always_off);

  headsupactive = true;
}
</t>
<t tx="T1445">
static void HU_DrawCrossHair(int sbarheight)
{
  static int crhcount = 0;
  static int crhdir = 1;   // -ACB- 1999/09/19 change from ch * to crh *. chdir is a function.
  static int crhtimer = 0;

  int col, mul;
  int x, y;

  // -jc- Pulsating
  if (crhtimer++ % 6)
  {
    if (crhcount == 15)
      crhdir = -1;
    else if (crhcount == 0)
      crhdir = 1;
    crhcount += crhdir;
  }

  col = HU_CROSSHAIRCOLOUR + crhcount / 2;
  mul = 1 + (SCREENWIDTH / 300);
  x = SCREENWIDTH / 2;
  y = (SCREENHEIGHT - sbarheight) / 2;
 
  switch (crosshair)
  {
    case 1:
      vctx.SolidLine(x - 3*mul, y, x - 2*mul, y, col);
      vctx.SolidLine(x + 2*mul, y, x + 3*mul, y, col);
      vctx.SolidLine(x, y - 3*mul, x, y - 2*mul, col);
      vctx.SolidLine(x, y + 2*mul, x, y + 3*mul, col);
      break;
  
    case 2:
      vctx.SolidLine(x, y, x + 1, y, col);
      break;

    case 3:
      vctx.SolidLine(x, y, x + 2*mul, y, col);
      vctx.SolidLine(x, y + 1, x, y + 2*mul, col);
      break;

    default:
      break;
  }
}
</t>
<t tx="T1446">    
void HU_Drawer(void)
{
  int sbarheight = FROM_200(ST_HEIGHT);

  if (!automapactive)
    RAD_DisplayTips();

  HL_DrawSText(&amp;w_message);
  HL_DrawIText(&amp;w_chat);

  if (automapactive)
    HL_DrawTextLine(&amp;w_title, false);

  if (setblocks == 11 &amp;&amp; !automapactive)
    sbarheight = 0;  //-JC- Make sure crosshair works full scr.

  if (!automapactive)
    HU_DrawCrossHair(sbarheight);

  //now, draw stats
  // -ACB- 1998/09/11 Used White Colour Scaling.
  if (showstats)
  {
    static int numframes = 0, lasttime = 0;
    static float_t fps = 0, mspf = 0;

    char textbuf[100];
    char *s;
    int currtime, timediff;

    numframes++;
    currtime = I_GetTime();
    timediff = currtime - lasttime;

    if (timediff &gt; 70)
    {
      fps  = (float_t) (numframes * TICRATE) / (float_t) timediff;
      mspf = (float_t) timediff * 1000.0 / (float_t) (numframes * TICRATE);

      lasttime = currtime;
      numframes = 0;
    }

    HL_ClearTextLine(&amp;textlinefps);
    sprintf(textbuf, "fps: %1.1f  ms/f:%1.1f   time:%d:%02d", fps, 
        mspf, (leveltime / TICRATE) / 60, (leveltime / TICRATE) % 60);

#if 0  // DEBUG ONLY (TOUCHNODES)
    {
      int total=0;
      touch_node_t *tn;

      sprintf(textbuf, "sectors (");
      s = textbuf + strlen(textbuf);
      
      for (tn=consoleplayer-&gt;mo-&gt;touch_sectors; 
           tn &amp;&amp; total &lt; 10; tn=tn-&gt;mo_next)
      {
        if (isdigit(s[-1]))
        {
          strcat(textbuf, " ");
          s++;
        }

        sprintf(s, "%d", tn-&gt;sec - sectors);
        s = textbuf + strlen(textbuf);

        total++;
      }

      strcat(textbuf, ")");
    }
#endif

#if 0  // DEBUG ONLY (TOUCHNODES)
    {
      sector_t *testsec = sectors + 57;
      int total=0;
      touch_node_t *tn;

      sprintf(textbuf, "sectors (");
      s = textbuf + strlen(textbuf);
      
      for (tn=testsec-&gt;touch_things; tn &amp;&amp; total &lt; 6; tn=tn-&gt;sec_next)
      {
        if (s[-1] != ' ' &amp;&amp; s[-1] != '(')
        {
          strcat(textbuf, " ");
          s++;
        }

        sprintf(s, "%5.5s", tn-&gt;mo-&gt;info-&gt;ddf.name);
        s = textbuf + strlen(textbuf);

        total++;
      }

      strcat(textbuf, ")");
    }
#endif

    s = textbuf;
    while (*s)
      HL_AddCharToTextLine(&amp;textlinefps, *(s++));
    HL_DrawTextLine(&amp;textlinefps, 0);

#ifdef USE_GL
    return;  // don't want non-FPS info causing extra slowdown
#endif

    HL_ClearTextLine(&amp;textlinememory);
    sprintf(textbuf, "used cache: %d/%d",
        Z_UsedMemory(1),
        Z_UsedMemory(2));
    s = textbuf;
    while (*s)
      HL_AddCharToTextLine(&amp;textlinememory, *(s++));
    HL_DrawTextLine(&amp;textlinememory, 0);

    if (!netgame)
    {
      HL_ClearTextLine(&amp;textlinepos);
      HL_ClearTextLine(&amp;textlinestats);

      // Convert angle &amp; x,y co-ordinates so they are easier to read.
      // -KM- 1998/11/25 Added z co-ordinate
      sprintf(textbuf, "LookDir=%1.0f; x,y,z=( %1.0f, %1.0f, %1.0f );"
          " sec=%d/%d", ANG_2_FLOAT(consoleplayer-&gt;mo-&gt;angle),
          consoleplayer-&gt;mo-&gt;x, consoleplayer-&gt;mo-&gt;y,
          consoleplayer-&gt;mo-&gt;z,
          (int) (consoleplayer-&gt;mo-&gt;subsector-&gt;sector - sectors),
          (int) (consoleplayer-&gt;mo-&gt;subsector - subsectors));
      s = textbuf;
      while (*s)
        HL_AddCharToTextLine(&amp;textlinepos, *(s++));

      sprintf(textbuf, "Kills:%d/%d   Items:%d/%d   Secrets:%d/%d",
          consoleplayer-&gt;killcount, totalkills,
          consoleplayer-&gt;itemcount, totalitems,
          consoleplayer-&gt;secretcount, totalsecret);
      s = textbuf;
      while (*s)
        HL_AddCharToTextLine(&amp;textlinestats, *(s++));
      HL_DrawTextLine(&amp;textlinepos, 0);
      HL_DrawTextLine(&amp;textlinestats, 0);
    }
  }

}
</t>
<t tx="T1447">
void HU_Erase(void)
{
  if (!headsupactive)
    return;

  HL_EraseSText(&amp;w_message);
  HL_EraseIText(&amp;w_chat);
  HL_EraseTextLine(&amp;w_title);
}
</t>
<t tx="T1448">@ Starts displaying the message.
@c

void HU_StartMessage(const char *msg)
{
  // only display message if necessary
  if (!message_nottobefuckedwith
      || message_dontfuckwithme)
  {
    HL_AddMessageToSText(&amp;w_message, 0, msg);
    message_on = true;
    message_counter = HU_MSGTIMEOUT;
    message_nottobefuckedwith = message_dontfuckwithme;
    message_dontfuckwithme = 0;
  }
}
</t>
<t tx="T1449">
void HU_Ticker(void)
{
  int i,rc;
  char c;
  player_t *p;

  // tick down message counter if message is up
  if (message_counter &amp;&amp; !--message_counter)
  {
    message_on = false;
    message_nottobefuckedwith = false;
  }

  // check for incoming chat characters
  if (! netgame)
    return;

  for (p = players; p; p = p-&gt;next)
  {
    if (p == consoleplayer)
      continue;

    c = p-&gt;cmd.chatchar;
    i = p-&gt;pnum;
    if (c)
    {
      if (c &lt;= HU_BROADCAST)
        chat_dest[i] = c;
      else
      {
        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
          c = (char)shiftxform[(unsigned char)c];
        rc = HL_KeyInIText(&amp;w_inputbuffer[i], c);
        if (rc &amp;&amp; c == KEYD_ENTER)
        {
          if (w_inputbuffer[i].L.len
              &amp;&amp; (chat_dest[i] == consoleplayer-&gt;pnum + 1
                  || chat_dest[i] == HU_BROADCAST))
          {
            HL_AddMessageToSText(&amp;w_message, p-&gt;playername,
                w_inputbuffer[i].L.ch);

            message_nottobefuckedwith = true;
            message_on = true;
            message_counter = HU_MSGTIMEOUT;

            if (W_CheckNumForName("DSRADIO") &gt;= 0)
              S_StartSound(NULL, sfx_radio);
            else
              S_StartSound(NULL, sfx_tink);
          }
          HL_ResetIText(&amp;w_inputbuffer[i]);
        }
      }
      p-&gt;cmd.chatchar = 0;
    }
  }
}
</t>
<t tx="T1450">
#define QUEUESIZE 128

static char chatchars[QUEUESIZE];
static int head = 0;
static int tail = 0;

void HU_QueueChatChar(char c)
{
  if (((head + 1) &amp; (QUEUESIZE - 1)) == tail)
  {
    CON_PlayerMessageLDF(consoleplayer, "UnsentMsg");
  }
  else
  {
    chatchars[head] = c;
    head = (head + 1) &amp; (QUEUESIZE - 1);
  }
}
</t>
<t tx="T1451">
char HU_DequeueChatChar(void)
{
  char c;

  if (head != tail)
  {
    c = chatchars[tail];
    tail = (tail + 1) &amp; (QUEUESIZE - 1);
  }
  else
  {
    c = 0;
  }

  return c;
}
</t>
<t tx="T1452">
const char *destination_keys;

boolean_t HU_Responder(event_t * ev)
{
  static char lastmessage[HU_MAXLINELENGTH + 1];
  const char *macromessage;
  boolean_t eatkey = false;
  static boolean_t shiftdown = false;
  static boolean_t altdown = false;
  unsigned char c;
  player_t *p;
  int numplayers;

  static int num_nobrainers = 0;

  if (ev-&gt;type == ev_analogue)
    return false;

  c = ev-&gt;value.key;

  numplayers = 0;
  for (p = players; p; p = p-&gt;next)
    numplayers++;

  if (c == KEYD_RSHIFT)
  {
    shiftdown = (ev-&gt;type == ev_keydown);
    return false;
  }
  else if (c == KEYD_RALT || c == KEYD_LALT)
  {
    altdown = (ev-&gt;type == ev_keydown);
    return false;
  }

  if (ev-&gt;type != ev_keydown)
    return false;

  if (!chat_on)
  {
    if (c == HU_MSGREFRESH)
    {
      message_on = true;
      message_counter = HU_MSGTIMEOUT;
      eatkey = true;
    }
    else if (netgame &amp;&amp; c &amp;&amp; ((c == (HU_INPUTTOGGLE &gt;&gt; 16)) || (c == (HU_INPUTTOGGLE &amp; 0xffff))))
    {
      eatkey = chat_on = true;
      HL_ResetIText(&amp;w_chat);
      HU_QueueChatChar(HU_BROADCAST);
    }
    else if (netgame &amp;&amp; numplayers &gt; 2)
    {
      for (p = players; p; p = p-&gt;next)
      {
        if (p-&gt;pnum &lt; (int)strlen(destination_keys) &amp;&amp; c == destination_keys[p-&gt;pnum])
        {
          if (p != consoleplayer)
          {
            eatkey = chat_on = true;
            HL_ResetIText(&amp;w_chat);
            HU_QueueChatChar((char)(p-&gt;pnum+1));
            break;
          }
          else
          {
            num_nobrainers++;
            if (num_nobrainers &lt; 3)
              CON_PlayerMessageLDF(consoleplayer, "TALKTOSELF1");
            else if (num_nobrainers &lt; 6)
              CON_PlayerMessageLDF(consoleplayer, "TALKTOSELF2");
            else if (num_nobrainers &lt; 9)
              CON_PlayerMessageLDF(consoleplayer, "TALKTOSELF3");
            else if (num_nobrainers &lt; 32)
              CON_PlayerMessageLDF(consoleplayer, "TALKTOSELF4");
            else
              CON_PlayerMessageLDF(consoleplayer, "TALKTOSELF5");
          }
        }
      }
    }
  }
  else
  {
    // send a macro
    if (altdown)
    {
      c = c - '0';
      if (c &gt; 9)
        return false;
      macromessage = chat_macros[c];

      // kill last message with a '\n'
      HU_QueueChatChar(KEYD_ENTER);  // DEBUG!!!

      // send the macro message
      while (*macromessage)
        HU_QueueChatChar(*macromessage++);

      HU_QueueChatChar(KEYD_ENTER);

      // leave chat mode and notify that it was sent
      chat_on = false;
      strcpy(lastmessage, chat_macros[c]);
      CON_PlayerMessage(consoleplayer, lastmessage);
      eatkey = true;
    }
    else
    {
      if (shiftdown || (c &gt;= 'a' &amp;&amp; c &lt;= 'z'))
        c = shiftxform[c];

      eatkey = HL_KeyInIText(&amp;w_chat, c);
      if (eatkey)
      {
        // static unsigned char buf[20]; // DEBUG
        HU_QueueChatChar(c);

        // sprintf(buf, "KEY: %d =&gt; %d", ev-&gt;data1, c);
        //      consoleplayer-&gt;message = buf;
      }
      if (c == KEYD_ENTER)
      {
        chat_on = false;
        if (w_chat.L.len)
        {
          CON_PlayerMessage(consoleplayer, lastmessage, w_chat.L.ch);
        }
      }
      else if (c == KEYD_ESCAPE)
        chat_on = false;
    }
  }

  return eatkey;

}
</t>
<t tx="T1453">@ignore
@language c

//  EDGE&lt;-&gt;GLBSP Bridging code

&lt;&lt; l_glbsp #includes &gt;&gt;
&lt;&lt; l_glbsp declarations &gt;&gt;
@others
</t>
<t tx="T1454">#include "i_defs.h"
#include "l_glbsp.h"

#include "dm_type.h"
#include "e_main.h"
#include "hu_lib.h"
#include "m_menu.h"
#include "v_ctx.h"
#include "v_colour.h"
#include "v_res.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"

#include "glbsp/glbsp.h"
</t>
<t tx="T1455">

boolean_t gb_draw_progress = false;

static char message_buf[1024];
static int ticker_time;

// time between redrawing screen (bit under 1/6 second)
#define REDRAW_TICS  6

static void GB_InitProgress(void);
static void GB_TermProgress(void);

static const image_t *gb_background = NULL;


// -AJA- FIXME: put this in LANGUAGE.LDF sometime

#define MESSAGE1  "EDGE IS NOW CREATING THE GWA FILE..."
#define MESSAGE2  "THIS ONLY HAS TO BE DONE ONCE FOR THIS WAD"


#define MAXBARTEXT  100

typedef struct
{
  // current limit
  int limit;
  
  // current position (0.0 to 1.0)
  float_t pos;

  char text[MAXBARTEXT];
}
gb_bar_t;

static const gb_bar_t default_bar = { 0, 0.0f, { 0, }};

static gb_bar_t bars[2];
static displaytype_e cur_disp = DIS_INVALID;

static boolean_t gb_refresh;
</t>
<t tx="T1456">@ GB_PrintMsg
@c

void GB_PrintMsg(const char *str, ...)
{
  va_list args;

  va_start(args, str);
  vsprintf(message_buf, str, args);
  va_end(args);

  I_Printf("GB: %s", message_buf);
}
</t>
<t tx="T1457">@ GB_FatalError

Terminates the program reporting an error.
@c

void GB_FatalError(const char *str, ...)
{
  va_list args;

  va_start(args, str);
  vsprintf(message_buf, str, args);
  va_end(args);

  I_Error("Builing nodes failed: %s\n", message_buf);
}
</t>
<t tx="T1458">@ GB_Ticker
@c

void GB_Ticker(void)
{
  int cur_time;
  
  if (! e_display_OK)
    return;
  
  cur_time = I_GetTime();
  
  if (ticker_time != 0 &amp;&amp; cur_time &lt; ticker_time + REDRAW_TICS)
    return;
  
  E_Display();
  
  // Note: get the time _after_ rendering the frame.  This handles the
  // situation of very low framerates better, as we can at least
  // perform REDRAW_TICS amount of work for each frame.
 
  ticker_time = I_GetTime();
}
</t>
<t tx="T1459">@ GB_DisplayOpen
@c

boolean_g GB_DisplayOpen(displaytype_e type)
{
  cur_disp = type;

  bars[0] = default_bar;
  bars[1] = default_bar;

  gb_refresh = true;
   
  return TRUE;
}
</t>
<t tx="T1460">@ GB_DisplaySetTitle
@c

void GB_DisplaySetTitle(const char *str)
{
  /* does nothing */
}
</t>
<t tx="T1461">@ GB_DisplaySetText
@c

void GB_DisplaySetText(const char *str)
{
  /* does nothing */
}
</t>
<t tx="T1462">@ GB_DisplaySetBarText
@c

void GB_DisplaySetBarText(int barnum, const char *str)
{
  DEV_ASSERT2(1 &lt;= barnum &amp;&amp; barnum &lt;= 2);

  Z_StrNCpy(bars[barnum - 1].text, str, MAXBARTEXT-1);

  // only need to refresh on text changes (not on bar changes)
  gb_refresh = true;
}
</t>
<t tx="T1463">@ GB_DisplaySetBarLimit
@c

void GB_DisplaySetBarLimit(int barnum, int limit)
{
  DEV_ASSERT2(1 &lt;= barnum &amp;&amp; barnum &lt;= 2);

  bars[barnum - 1].limit = limit;
}
</t>
<t tx="T1464">@ GB_DisplaySetBar
@c

void GB_DisplaySetBar(int barnum, int count)
{
  DEV_ASSERT2(1 &lt;= barnum &amp;&amp; barnum &lt;= 2);

  if (count &lt; 0 || bars[barnum - 1].limit &lt;= 0 ||
      count &gt; bars[barnum - 1].limit)
  {
    return;
  }

  // compute fractional position
  bars[barnum - 1].pos = (float_t)count / bars[barnum - 1].limit;
}
</t>
<t tx="T1465">@ GB_DisplayClose
@c

void GB_DisplayClose(void)
{
  /* does nothing */
}
</t>
<t tx="T1466">
const nodebuildfuncs_t edge_build_funcs =
{
  GB_FatalError,
  GB_PrintMsg,
  GB_Ticker,

  GB_DisplayOpen,
  GB_DisplaySetTitle,
  GB_DisplaySetText,
  GB_DisplaySetBar,
  GB_DisplaySetBarLimit,
  GB_DisplaySetBarText,
  GB_DisplayClose
};


//
// GB_BuildNodes
//
// Attempt to build nodes for the WAD file containing the given
// map_lump (a lump number from w_wad for the start marker, e.g.
// "MAP01").  Returns true if successful, false if it failed.
//
boolean_t GB_BuildNodes(int map_lump)
{
  nodebuildinfo_t nb_info;
  volatile nodebuildcomms_t nb_comms;
  glbsp_ret_e ret;

  nb_info  = default_buildinfo;
  nb_comms = default_buildcomms;
  
  nb_info.input_file = W_GetFileName(map_lump);
  
  // FIXME: check parm "-node-factor"
  
  if (GLBSP_E_OK != GlbspCheckInfo(&amp;nb_info, &amp;nb_comms))
    return false;
  
  GB_InitProgress();

  ret = GlbspBuildNodes(&amp;nb_info, &amp;edge_build_funcs, &amp;nb_comms);
 
  GB_TermProgress();

  if (ret != GLBSP_E_OK)
    return false;

  DEV_ASSERT2(nb_info.output_file);
  DEV_ASSERT2(nb_info.gwa_mode);
  
  W_AddDynamicGWA(nb_info.output_file, map_lump);

  return true;
}
</t>
<t tx="T1467">@ GB_InitProgress
@c

void GB_InitProgress(void)
{
  ticker_time = 0;
  cur_disp = DIS_INVALID;
  gb_draw_progress = true;
  gb_refresh = true;

  if (! e_display_OK)
    return;

  //...
}
</t>
<t tx="T1468">@ GB_TermProgress
@c

void GB_TermProgress(void)
{
  gb_draw_progress = false;

  if (! e_display_OK)
    return;

  //...
}
</t>
<t tx="T1469">@ GB_DrawProgress
@c

void GB_DrawProgress(void)
{
  int i;
  
  // -AJA- funky maths for "scaled resolution" thing
  int lx = 32;
  int rx = 240;

  int x1 = X_OFFSET + lx * DX;
  int x2 = X_OFFSET + rx * DX;

  int num_bars, dy;
  int filecol, nodecol;

  DEV_ASSERT2(e_display_OK);

  if (! gb_background)
    gb_background = W_ImageFromFlat("FLAT10");

  if (gb_refresh)
  {
    vctx.DrawImage(0, 0, SCREENWIDTH, SCREENHEIGHT, gb_background,
        0.0, 0.0, IM_RIGHT(gb_background) * 5.0, 
        IM_BOTTOM(gb_background) * 5.0, NULL, 1.0);

    gb_refresh = false;
  }

  HL_WriteTextTrans(12, 10, text_green_map, MESSAGE1);
  HL_WriteTextTrans(12, 24, text_green_map, MESSAGE2);

  switch (cur_disp)
  {
    case DIS_BUILDPROGRESS:
      num_bars = 2; dy = 0; 
      filecol = RED; nodecol = (CYAN + CYAN_LEN/2);
      break;
    
    case DIS_FILEPROGRESS:
      num_bars = 1; dy = 0; 
      filecol = nodecol = YELLOW;
      break;

    default:
      return;
  }

  for (i=0; i &lt; num_bars; i++)
  {
    int x3 = x1 + (int)(bars[i].pos * (x2 - x1));

    int ty = 60 + i * 30 + dy;
    int uy = 70 + i * 30 + dy;
    int by = 80 + i * 30 + dy;

    int y1 = Y_OFFSET + uy * DY;
    int y2 = Y_OFFSET + by * DY;

    int bg = DBLUE;
    int fg = (i == num_bars-1) ? filecol : nodecol;

    HL_WriteTextTrans(lx, ty, text_white_map, bars[i].text);
    
    if (x3 &gt; x1)
      vctx.SolidBox(x1, y1, x3-x1, y2-y1, fg, 1.0);

    if (x3 &lt; x2)
      vctx.SolidBox(x3, y1, x2-x3, y2-y1, bg, 1.0);
  }
}
</t>
<t tx="T1470">@ignore
@language c

// MP3 Interface

&lt;&lt; l_mp3 #includes &gt;&gt;
&lt;&lt; l_mp3 declarations &gt;&gt;
@others
</t>
<t tx="T1471">#include "i_defs.h"
#include "l_mp3.h"

#include "z_zone.h"

#include "xingmp3/mhead.h"
</t>
<t tx="T1472">
// sound parameters
static int current_rate = -1;
static int current_bits = -1;
static int current_chan = -1;
static int bytes_per_sample = -1;

// Maximum samples that decoding from MP3 will ever produce.
// Also the maximum samples that the platform code can ever request.
#define MAX_OVERFLOW  8192

// the ring buffer
static byte *ring_buffer = NULL;
static int ring_samples;

// the bitstream buffer
static byte *bs_buffer = NULL;
static int bs_total;
static int bs_pos;
static int bs_len;

// info from the MP3 file
static int file_handle = -1;
static int file_pos;
static int file_startpos;
static int file_endpos;   // &lt; 0 for files, &gt;= 0 for lumps.

static MPEG_HEAD file_head;
static DEC_INFO file_info;
static int file_framebytes;
static boolean_t file_eof;

// Current read/write positions in the ring, in samples.  When
// read_pos == write_pos, then the ring buffer is empty.  When
// write_pos == (read_pos - 1), the ring buffer is completely full.
//
// NOTE: the volatile is necessary, as these values can be
// used/updated in different threads/execution contexts.

static volatile int r_read_pos;
static volatile int r_write_pos;

#define RING_SIZE()   \
    (((r_write_pos - r_read_pos) + ring_samples) % ring_samples)

#define RING_SPACE()  \
    (ring_samples - RING_SIZE())


// stuff needed by XingMP3

float_t equalizer[32] = 
{
  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
};
int enableEQ = 0;
</t>
<t tx="T1473">@ L_MP3Init

Initialise this MP3 interface. Should be called right after the
platform sound code is successfully initialised, passing the sound
device's sample rate, bits and mono/stereo-ness.
@c

void L_MP3Init(int sample_rate, int sample_bits, int channels)
{
  DEV_ASSERT2(4000 &lt;= sample_rate &amp;&amp; sample_rate &lt;= 44100);
  DEV_ASSERT2(sample_bits == 8 || sample_bits == 16);
  DEV_ASSERT2(channels == 1 || channels == 2);

  current_rate = sample_rate;
  current_bits = sample_bits;
  current_chan = channels;

  bytes_per_sample = (current_bits/8) * current_chan;

  // setup ring buffer.  Allocate enough space in the ring buffer for
  // at least one complete second of sound.

  ring_samples = MAX(current_rate, 4 * MAX_OVERFLOW);
  ring_buffer = Z_New(byte, (ring_samples + MAX_OVERFLOW) * bytes_per_sample);
}
</t>
<t tx="T1474">@ L_MP3Shutdown

Shuts down the MP3 interface. The platform code *must* ensure
(before calling this routine) that any thread/interrupt/signal
handler which calls L_MP3ReadBuffer() or L_MP3ReadAdvance() has
already been disabled.
@c

void L_MP3Shutdown(void)
{
  DEV_ASSERT2(current_rate &gt; 0);

  current_rate = -1;

  if (file_handle &gt;= 0)
  {
    if (file_endpos &lt; 0)
      close(file_handle);

    file_handle = -1;
  }
  
  if (bs_buffer)
  {
    Z_Free(bs_buffer);
    bs_buffer = NULL;
  }

  if (ring_buffer)
  {
    byte *temp = ring_buffer;

    ring_buffer = NULL;
    Z_Free(temp);
  }
}
</t>
<t tx="T1475">@ TryReadInfo

Attempts to parse the MP3 header information at the beginning of
the MP3 file. Returns true if all went well, otherwise false.
When successful, the bitstream buffer will be ready for reading.
@c

static boolean_t TryReadInfo(int reduction_code)
{
  int bitrate;
  int freq_limit = 24000;
  int convert_code = ((current_chan == 1) ? 1 : 0) +
      ((current_bits == 8) ? 8 : 0);
  int start_idx;

  // seek to beginning
  lseek(file_handle, file_startpos, SEEK_SET);

  // read in initial amount
  bs_len = read(file_handle, bs_buffer, bs_total);

  if (bs_len &lt;= 0)
  {
    I_Warning("L_MP3SetMusicFile: Couldn't read MP3 file.\n");
    return false;
  }

  file_pos = file_startpos + bs_len;

  // parse mpeg header
  file_framebytes = head_info3(bs_buffer, bs_len, &amp;file_head, 
      &amp;bitrate, &amp;start_idx);

  if (file_framebytes == 0)
  {
    I_Warning("L_MP3SetMusicFile: Bad MP3 file !\n");
    return false;
  }

  L_WriteDebug("MP3: Framebytes: %d  Bitrate: %d  StartIdx: %d\n", 
      file_framebytes, bitrate, start_idx);

  bs_pos += start_idx;
  file_startpos += start_idx;

  if (file_endpos &gt; 0)
    file_endpos -= start_idx;

  // initialise decoder
  if (!audio_decode_init(&amp;file_head, file_framebytes,
      reduction_code, 0, convert_code, freq_limit))
  {
    I_Warning("L_MP3SetMusicFile: Decoder init fail !\n");
    return false;
  }

  // read info
  audio_decode_info(&amp;file_info);

  L_WriteDebug("MP3: channels %d  samprate %ld  bits %d  "
      "framebytes %d  type %d\n", file_info.channels, file_info.samprate,
      file_info.bits, file_info.framebytes, file_info.type);

  L_WriteDebug("MP3: sync %d  id %d  opt %d  prot %d  mode %d\n",
      file_head.sync, file_head.id, file_head.option,
      file_head.prot, file_head.mode);

  if (file_info.channels &lt; 1 || file_info.channels &gt; 2 ||
      (file_info.bits != 8 &amp;&amp; file_info.bits != 16))
  {
    I_Warning("L_MP3SetMusicFile: Weird channels or bitsize !\n");
    return false;
  }
 
  return true;
}
</t>
<t tx="T1476">@ L_MP3SetMusicFile

Attempt to begin decoding the given MP3 file. Returns true if all
systems are go, and returns false is something went wrong. When
successful, sets the `sample_rate' parameter to what the MP3 file
is (a reduction value is chosen to make it as close to the sound
device's sample_rate as possible).
@c

boolean_t L_MP3SetMusicFile(const char *filename, int *sample_rate)
{
  int handle;

  DEV_ASSERT2(bs_buffer == NULL);
  DEV_ASSERT2(ring_buffer);

  // open file
  handle = open(filename, O_RDONLY | O_BINARY);

  if (handle &lt; 0)
  {
    I_Warning("L_MP3SetMusicFile: couldn't open file: %s\n", filename);
    return false;
  }

  L_WriteDebug("MP3: Opened file: %s\n", filename);

  if (! L_MP3SetMusicLump(handle, 0, -1, sample_rate))
  {
    close(handle);
    return false;
  }

  return true;
}
</t>
<t tx="T1477">@ L_MP3SetMusicLump

Like L_MP3SetMusicFile() above, but for a lump in a PWAD. `handle'
is the file handle as returned from open() (and stored by the
w_wad.c code in data_file_t).
@c

boolean_t L_MP3SetMusicLump(int handle, int position, int size, 
    int *sample_rate)
{
  int reduction_code = 0;

  DEV_ASSERT2(handle &gt;= 0);
  DEV_ASSERT2(bs_buffer == NULL);
  DEV_ASSERT2(ring_buffer);

  file_handle = handle;
  file_eof = false;
  file_startpos = position;
  file_endpos = (size &lt; 0) ? -1 : (position + size);
  file_pos = 0;

  if (size &gt;= 0)
    L_WriteDebug("MP3: Using lump from %d..%d in file %d\n",
      file_startpos, file_endpos, handle);

  //
  // -ACB- 2000/08/23: Read position and write position are matched
  //                   so that the ring buffer is considered to be
  //                   empty.
  //
  r_read_pos = r_write_pos = 0;

  // setup bitstream buffer
  bs_total  = 80 * 1024;
  bs_buffer = Z_New(byte, bs_total);
  bs_pos    = 0;
  bs_len    = 0;

  // read initial information
  if (!TryReadInfo(reduction_code))
  {
    Z_Free(bs_buffer);
    bs_buffer = NULL;

    file_handle = -1;
    return false;
  }
  
  while (reduction_code &lt; 2 &amp;&amp; 
      (file_info.samprate &gt;&gt; (reduction_code+1)) &gt;= current_rate)
  {
    reduction_code++;
  }

  L_WriteDebug("MP3: Reduction code chosen = %d\n", reduction_code);

  if (reduction_code &gt; 0)
  {
    if (! TryReadInfo(reduction_code))
    {
      Z_Free(bs_buffer);
      bs_buffer = NULL;

      file_handle = -1;
      return false;
    }
  }

  (*sample_rate) = file_info.samprate;
  
  return true;
}
</t>
<t tx="T1478">@ L_MP3ClearMusicFile

Clear any data associated with a previously successful
L_MP3SetMusicFile call. The platform code *must* ensure (before
calling this routine) that any thread/interrupt/signal handler will
no longer call L_MP3ReadBuffer() or L_MP3ReadAdvance().

Note: There is no shutdown function for XingMP3
@c

void L_MP3ClearMusicFile(void)
{
  DEV_ASSERT2(file_handle &gt;= 0);
  DEV_ASSERT2(bs_buffer);

  if (file_endpos &lt; 0)
    close(file_handle);

  file_handle = -1;

  Z_Free(bs_buffer);
  bs_buffer = NULL;
}
</t>
<t tx="T1479">@ DecodeIntoRingBuffer

Reads data from the file (when necessary) and calls XingMP3 to
convert a frame of MP3 to audio data in the ring buffer.

NOTE: channel number differences and bitsize differences are
handled by XingMP3 itself (via convert_code), and sample rate
differences need to be handled in the platform sound code.
@c

static boolean_t DecodeIntoRingBuffer(void)
{
  IN_OUT inout;
 
  volatile byte *write_pos = ring_buffer + (r_write_pos * bytes_per_sample);

  DEV_ASSERT2(bs_buffer);
  DEV_ASSERT2(0 &lt;= bs_len &amp;&amp; bs_len &lt;= bs_total);
  DEV_ASSERT2(0 &lt;= bs_pos &amp;&amp; bs_pos &lt;= bs_total);

  // fill bitstream buffer, if needed
  if (bs_len &lt; file_framebytes)
  {
    int num = bs_total - bs_len;
    
    if (bs_len &gt; 0)
      memmove(bs_buffer, bs_buffer + bs_pos, bs_len);
      
    if (file_endpos &gt;= 0 &amp;&amp; num &gt; file_endpos - file_pos)
      num = file_endpos - file_pos;

    if (num &gt; 0)
    {
      // NOTE WELL: must do a seek when using lumps, as the w_wad code
      // may have read other lumps (and hence moved the read position)
      // since the last time we were here.

      if (file_endpos &gt;= 0)
        lseek(file_handle, file_pos, SEEK_SET);

      num = read(file_handle, bs_buffer + bs_len, num);
    }

    if (num &lt;= 0 || bs_len + num &lt; file_framebytes)
    {
      L_WriteDebug("MP3: EOF !\n");
      file_eof = true;
      return 0;
    }

    bs_pos = 0;
    bs_len += num;
    file_pos += num;
  }

  inout = audio_decode(bs_buffer + bs_pos, (short *) write_pos);

#if 0
  L_WriteDebug("MP3: IN=%d  OUT=%d\n", inout.in_bytes, inout.out_bytes);
  L_WriteDebug("MP3: Data: %02X %02X %02X %02X %02X %02X %02X %02X\n",
      write_pos[0], write_pos[1], write_pos[2], write_pos[3],
      write_pos[4], write_pos[5], write_pos[6], write_pos[7]);
#endif

  //
  // -ACB- 2000/08/23 Errors Suck: If the input bytes are zero
  //                               or less, just return zero - this
  //                               will stop the current MP3 playing.
  //                               Some MP3's have bad sync at
  //                               the end of them for termination
  //                               reasons.
  //
  if (inout.in_bytes &lt;= 0)
  {
    L_WriteDebug("MP3: OUT OF SYNC !\n");
    file_eof = true;
    return 0;
  }
 
  bs_pos += inout.in_bytes;
  bs_len -= inout.in_bytes;

  return inout.out_bytes / file_info.channels;
}
</t>
<t tx="T1480">@ L_MP3FillBuffer

Fill the ring buffer with data decoded from the MP3 file. Returns
true if all went well, or false if the file's EOF was reached.
@c

boolean_t L_MP3FillBuffer(void)
{
  int space;
  int samples;
  boolean_t got_some = false;
 
  DEV_ASSERT2(file_handle &gt;= 0);
  DEV_ASSERT2(bs_buffer);
  DEV_ASSERT2(ring_buffer);

  if (file_eof)
    return false;

  space = RING_SPACE();

  while (space &gt;= MAX_OVERFLOW)
  {
    samples = DecodeIntoRingBuffer();

    if (!samples)
      return got_some;
    
    got_some = true;

    // handle case of overflowing ring buffer
    if (r_write_pos + samples &gt; ring_samples)
    {
      // must copy samples to the bottom of the ring buffer
      int over_num = (r_write_pos + samples - ring_samples);

      I_MoveData(ring_buffer, 
          ring_buffer + (ring_samples * bytes_per_sample),
          over_num * bytes_per_sample);
    }

    r_write_pos = (r_write_pos + samples) % ring_samples;
    space -= samples;
  }

  return true;
}
</t>
<t tx="T1481">@ L_MP3RestartMusicFile

Cause the MP3 file to start playing from the beginning again.
Usually called after L_MP3FillBuffer() returns an EOF indication.
@c

void L_MP3RestartMusicFile(void)
{
  DEV_ASSERT2(file_handle &gt;= 0);
  DEV_ASSERT2(bs_buffer);
  DEV_ASSERT2(ring_buffer);

  L_WriteDebug("MP3: Restarting...\n");

  // seek to the beginning of the file
  lseek(file_handle, file_startpos, SEEK_SET);

  // clear bitstream buffer
  bs_pos = 0;
  bs_len = 0;

  file_eof = false;
  file_pos = file_startpos;
}
</t>
<t tx="T1482">@ L_MP3ReadBuffer

Attempt to read a block of samples of the given size, returning a
pointer to it, or NULL if there wasn't enough data to satisfy the
request.
@c

byte *L_MP3ReadBuffer(int samples)
{
  DEV_ASSERT2(samples &lt;= MAX_OVERFLOW);

  if (!ring_buffer)
    return NULL;
  
  if (RING_SIZE() &lt; samples)
  {
    // Ouch, we ran out of data
    return NULL;
  }

  // does this request overflow the ring buffer ?
  if ((r_read_pos+samples) &gt; ring_samples)
  {
    // must copy samples from bottom of ring buffer
    int over_num = ((r_read_pos + samples) - ring_samples);

    I_MoveData(ring_buffer + (ring_samples * bytes_per_sample),
        ring_buffer, over_num * bytes_per_sample);
  }
  
  return ring_buffer + (r_read_pos * bytes_per_sample);
}
</t>
<t tx="T1483">@ L_MP3ReadAdvance

Move the read position within the ring buffer by the given number
of samples. Should be called after a successful L_MP3ReadBuffer()
call, using the same number of samples.
@c

void L_MP3ReadAdvance(int samples)
{
  DEV_ASSERT2(samples &lt;= MAX_OVERFLOW);
  DEV_ASSERT2(ring_buffer);
  DEV_ASSERT2(RING_SIZE() &gt;= samples);

  r_read_pos = (r_read_pos + samples) % ring_samples;
}
</t>
<t tx="T1484">@ignore
@language c

// Gamma Lookup Table

&lt;&lt; lu_gamma #includes &gt;&gt;

// Now where did these came from?
byte gammatable[5][256] =
{
    {
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
        49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
        65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
        81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
        97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,
        128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
        144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
        160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
        176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
        192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
        208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
        224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
        240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
    },
    {
        2, 4, 5, 7, 8, 10, 11, 12, 14, 15, 16, 18, 19, 20, 21, 23, 24, 25, 26, 27, 29, 30, 31,
        32, 33, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55,
        56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77,
        78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
        99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
        115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 129,
        130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,
        146, 147, 148, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
        161, 162, 163, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
        175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 186, 187, 188, 189,
        190, 191, 192, 193, 194, 195, 196, 196, 197, 198, 199, 200, 201, 202, 203, 204,
        205, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 214, 215, 216, 217, 218,
        219, 220, 221, 222, 222, 223, 224, 225, 226, 227, 228, 229, 230, 230, 231, 232,
        233, 234, 235, 236, 237, 237, 238, 239, 240, 241, 242, 243, 244, 245, 245, 246,
        247, 248, 249, 250, 251, 252, 252, 253, 254, 255
    },
    {
        4, 7, 9, 11, 13, 15, 17, 19, 21, 22, 24, 26, 27, 29, 30, 32, 33, 35, 36, 38, 39, 40, 42,
        43, 45, 46, 47, 48, 50, 51, 52, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69,
        70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,
        94, 95, 96, 97, 98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
        113, 114, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,
        129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144,
        144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 155, 156, 157, 158, 159,
        160, 160, 161, 162, 163, 164, 165, 166, 166, 167, 168, 169, 170, 171, 172, 172, 173,
        174, 175, 176, 177, 178, 178, 179, 180, 181, 182, 183, 183, 184, 185, 186, 187, 188,
        188, 189, 190, 191, 192, 193, 193, 194, 195, 196, 197, 197, 198, 199, 200, 201, 201,
        202, 203, 204, 205, 206, 206, 207, 208, 209, 210, 210, 211, 212, 213, 213, 214, 215,
        216, 217, 217, 218, 219, 220, 221, 221, 222, 223, 224, 224, 225, 226, 227, 228, 228,
        229, 230, 231, 231, 232, 233, 234, 235, 235, 236, 237, 238, 238, 239, 240, 241, 241,
        242, 243, 244, 244, 245, 246, 247, 247, 248, 249, 250, 251, 251, 252, 253, 254, 254,
        255
    },
    {
        8, 12, 16, 19, 22, 24, 27, 29, 31, 34, 36, 38, 40, 41, 43, 45, 47, 49, 50, 52, 53, 55,
        57, 58, 60, 61, 63, 64, 65, 67, 68, 70, 71, 72, 74, 75, 76, 77, 79, 80, 81, 82, 84, 85,
        86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
        108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124,
        125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 135, 136, 137, 138, 139, 140,
        141, 142, 143, 143, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155,
        155, 156, 157, 158, 159, 160, 160, 161, 162, 163, 164, 165, 165, 166, 167, 168, 169,
        169, 170, 171, 172, 173, 173, 174, 175, 176, 176, 177, 178, 179, 180, 180, 181, 182,
        183, 183, 184, 185, 186, 186, 187, 188, 189, 189, 190, 191, 192, 192, 193, 194, 195,
        195, 196, 197, 197, 198, 199, 200, 200, 201, 202, 202, 203, 204, 205, 205, 206, 207,
        207, 208, 209, 210, 210, 211, 212, 212, 213, 214, 214, 215, 216, 216, 217, 218, 219,
        219, 220, 221, 221, 222, 223, 223, 224, 225, 225, 226, 227, 227, 228, 229, 229, 230,
        231, 231, 232, 233, 233, 234, 235, 235, 236, 237, 237, 238, 238, 239, 240, 240, 241,
        242, 242, 243, 244, 244, 245, 246, 246, 247, 247, 248, 249, 249, 250, 251, 251, 252,
        253, 253, 254, 254, 255
    },
    {
        16, 23, 28, 32, 36, 39, 42, 45, 48, 50, 53, 55, 57, 60, 62, 64, 66, 68, 69, 71, 73, 75, 76,
        78, 80, 81, 83, 84, 86, 87, 89, 90, 92, 93, 94, 96, 97, 98, 100, 101, 102, 103, 105, 106,
        107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124,
        125, 126, 128, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141,
        142, 143, 143, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 155,
        156, 157, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 166, 166, 167, 168, 169,
        169, 170, 171, 172, 172, 173, 174, 175, 175, 176, 177, 177, 178, 179, 180, 180, 181,
        182, 182, 183, 184, 184, 185, 186, 187, 187, 188, 189, 189, 190, 191, 191, 192, 193,
        193, 194, 195, 195, 196, 196, 197, 198, 198, 199, 200, 200, 201, 202, 202, 203, 203,
        204, 205, 205, 206, 207, 207, 208, 208, 209, 210, 210, 211, 211, 212, 213, 213, 214,
        214, 215, 216, 216, 217, 217, 218, 219, 219, 220, 220, 221, 221, 222, 223, 223, 224,
        224, 225, 225, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 232, 232, 233, 233,
        234, 234, 235, 235, 236, 236, 237, 237, 238, 239, 239, 240, 240, 241, 241, 242, 242,
        243, 243, 244, 244, 245, 245, 246, 246, 247, 247, 248, 248, 249, 249, 250, 250, 251,
        251, 252, 252, 253, 254, 254, 255, 255
    }
};</t>
<t tx="T1485">#include "i_defs.h"
#include "v_colour.h"
</t>
<t tx="T1486">@ignore
@language c

// Mathematics LookUp Tables

// In the order of appearance:
//
// int finetangent[4096] - Tangens LUT.
//   Should work with BAM fairly well (12 of 16bit, effectively, by shifting).
//
// int finesine[10240]  - Sine lookup.
//   Guess what, serves as cosine, too.
//   Remarkable thing is, how to use BAMs with this?
//
// int tantoangle[2049] - ArcTan LUT,
//   maps tan(angle) to angle fast. Gotta search.

&lt;&lt; lu_math #includes &gt;&gt;
@others

fixed_t *finecosine = &amp;finesine[FINEANGLES / 4];

int finetangent[4096] =
{
    -170910304, -56965752, -34178904, -24413316, -18988036, -15535599, -13145455, -11392683,
    -10052327, -8994149, -8137527, -7429880, -6835455, -6329090, -5892567, -5512368,
    -5178251, -4882318, -4618375, -4381502, -4167737, -3973855, -3797206, -3635590,
    -3487165, -3350381, -3223918, -3106651, -2997613, -2895966, -2800983, -2712030,
    -2628549, -2550052, -2476104, -2406322, -2340362, -2277919, -2218719, -2162516,
    -2109087, -2058233, -2009771, -1963536, -1919378, -1877161, -1836758, -1798063,
    -1760956, -1725348, -1691149, -1658278, -1626658, -1596220, -1566898, -1538632,
    -1511367, -1485049, -1459630, -1435065, -1411312, -1388330, -1366084, -1344537,
    -1323658, -1303416, -1283783, -1264730, -1246234, -1228269, -1210813, -1193846,
    -1177345, -1161294, -1145673, -1130465, -1115654, -1101225, -1087164, -1073455,
    -1060087, -1047046, -1034322, -1021901, -1009774, -997931, -986361, -975054,
    -964003, -953199, -942633, -932298, -922186, -912289, -902602, -893117,
    -883829, -874730, -865817, -857081, -848520, -840127, -831898, -823827,
    -815910, -808143, -800521, -793041, -785699, -778490, -771411, -764460,
    -757631, -750922, -744331, -737853, -731486, -725227, -719074, -713023,
    -707072, -701219, -695462, -689797, -684223, -678737, -673338, -668024,
    -662792, -657640, -652568, -647572, -642651, -637803, -633028, -628323,
    -623686, -619117, -614613, -610174, -605798, -601483, -597229, -593033,
    -588896, -584815, -580789, -576818, -572901, -569035, -565221, -561456,
    -557741, -554074, -550455, -546881, -543354, -539870, -536431, -533034,
    -529680, -526366, -523094, -519861, -516667, -513512, -510394, -507313,
    -504269, -501261, -498287, -495348, -492443, -489571, -486732, -483925,
    -481150, -478406, -475692, -473009, -470355, -467730, -465133, -462565,
    -460024, -457511, -455024, -452564, -450129, -447720, -445337, -442978,
    -440643, -438332, -436045, -433781, -431540, -429321, -427125, -424951,
    -422798, -420666, -418555, -416465, -414395, -412344, -410314, -408303,
    -406311, -404338, -402384, -400448, -398530, -396630, -394747, -392882,
    -391034, -389202, -387387, -385589, -383807, -382040, -380290, -378555,
    -376835, -375130, -373440, -371765, -370105, -368459, -366826, -365208,
    -363604, -362013, -360436, -358872, -357321, -355783, -354257, -352744,
    -351244, -349756, -348280, -346816, -345364, -343924, -342495, -341078,
    -339671, -338276, -336892, -335519, -334157, -332805, -331464, -330133,
    -328812, -327502, -326201, -324910, -323629, -322358, -321097, -319844,
    -318601, -317368, -316143, -314928, -313721, -312524, -311335, -310154,
    -308983, -307819, -306664, -305517, -304379, -303248, -302126, -301011,
    -299904, -298805, -297714, -296630, -295554, -294485, -293423, -292369,
    -291322, -290282, -289249, -288223, -287204, -286192, -285186, -284188,
    -283195, -282210, -281231, -280258, -279292, -278332, -277378, -276430,
    -275489, -274553, -273624, -272700, -271782, -270871, -269965, -269064,
    -268169, -267280, -266397, -265519, -264646, -263779, -262917, -262060,
    -261209, -260363, -259522, -258686, -257855, -257029, -256208, -255392,
    -254581, -253774, -252973, -252176, -251384, -250596, -249813, -249035,
    -248261, -247492, -246727, -245966, -245210, -244458, -243711, -242967,
    -242228, -241493, -240763, -240036, -239314, -238595, -237881, -237170,
    -236463, -235761, -235062, -234367, -233676, -232988, -232304, -231624,
    -230948, -230275, -229606, -228941, -228279, -227621, -226966, -226314,
    -225666, -225022, -224381, -223743, -223108, -222477, -221849, -221225,
    -220603, -219985, -219370, -218758, -218149, -217544, -216941, -216341,
    -215745, -215151, -214561, -213973, -213389, -212807, -212228, -211652,
    -211079, -210509, -209941, -209376, -208815, -208255, -207699, -207145,
    -206594, -206045, -205500, -204956, -204416, -203878, -203342, -202809,
    -202279, -201751, -201226, -200703, -200182, -199664, -199149, -198636,
    -198125, -197616, -197110, -196606, -196105, -195606, -195109, -194614,
    -194122, -193631, -193143, -192658, -192174, -191693, -191213, -190736,
    -190261, -189789, -189318, -188849, -188382, -187918, -187455, -186995,
    -186536, -186080, -185625, -185173, -184722, -184274, -183827, -183382,
    -182939, -182498, -182059, -181622, -181186, -180753, -180321, -179891,
    -179463, -179037, -178612, -178190, -177769, -177349, -176932, -176516,
    -176102, -175690, -175279, -174870, -174463, -174057, -173653, -173251,
    -172850, -172451, -172053, -171657, -171263, -170870, -170479, -170089,
    -169701, -169315, -168930, -168546, -168164, -167784, -167405, -167027,
    -166651, -166277, -165904, -165532, -165162, -164793, -164426, -164060,
    -163695, -163332, -162970, -162610, -162251, -161893, -161537, -161182,
    -160828, -160476, -160125, -159775, -159427, -159079, -158734, -158389,
    -158046, -157704, -157363, -157024, -156686, -156349, -156013, -155678,
    -155345, -155013, -154682, -154352, -154024, -153697, -153370, -153045,
    -152722, -152399, -152077, -151757, -151438, -151120, -150803, -150487,
    -150172, -149859, -149546, -149235, -148924, -148615, -148307, -148000,
    -147693, -147388, -147084, -146782, -146480, -146179, -145879, -145580,
    -145282, -144986, -144690, -144395, -144101, -143808, -143517, -143226,
    -142936, -142647, -142359, -142072, -141786, -141501, -141217, -140934,
    -140651, -140370, -140090, -139810, -139532, -139254, -138977, -138701,
    -138426, -138152, -137879, -137607, -137335, -137065, -136795, -136526,
    -136258, -135991, -135725, -135459, -135195, -134931, -134668, -134406,
    -134145, -133884, -133625, -133366, -133108, -132851, -132594, -132339,
    -132084, -131830, -131576, -131324, -131072, -130821, -130571, -130322,
    -130073, -129825, -129578, -129332, -129086, -128841, -128597, -128353,
    -128111, -127869, -127627, -127387, -127147, -126908, -126669, -126432,
    -126195, -125959, -125723, -125488, -125254, -125020, -124787, -124555,
    -124324, -124093, -123863, -123633, -123404, -123176, -122949, -122722,
    -122496, -122270, -122045, -121821, -121597, -121374, -121152, -120930,
    -120709, -120489, -120269, -120050, -119831, -119613, -119396, -119179,
    -118963, -118747, -118532, -118318, -118104, -117891, -117678, -117466,
    -117254, -117044, -116833, -116623, -116414, -116206, -115998, -115790,
    -115583, -115377, -115171, -114966, -114761, -114557, -114354, -114151,
    -113948, -113746, -113545, -113344, -113143, -112944, -112744, -112546,
    -112347, -112150, -111952, -111756, -111560, -111364, -111169, -110974,
    -110780, -110586, -110393, -110200, -110008, -109817, -109626, -109435,
    -109245, -109055, -108866, -108677, -108489, -108301, -108114, -107927,
    -107741, -107555, -107369, -107184, -107000, -106816, -106632, -106449,
    -106266, -106084, -105902, -105721, -105540, -105360, -105180, -105000,
    -104821, -104643, -104465, -104287, -104109, -103933, -103756, -103580,
    -103404, -103229, -103054, -102880, -102706, -102533, -102360, -102187,
    -102015, -101843, -101671, -101500, -101330, -101159, -100990, -100820,
    -100651, -100482, -100314, -100146, -99979, -99812, -99645, -99479,
    -99313, -99148, -98982, -98818, -98653, -98489, -98326, -98163,
    -98000, -97837, -97675, -97513, -97352, -97191, -97030, -96870,
    -96710, -96551, -96391, -96233, -96074, -95916, -95758, -95601,
    -95444, -95287, -95131, -94975, -94819, -94664, -94509, -94354,
    -94200, -94046, -93892, -93739, -93586, -93434, -93281, -93129,
    -92978, -92826, -92675, -92525, -92375, -92225, -92075, -91926,
    -91777, -91628, -91480, -91332, -91184, -91036, -90889, -90742,
    -90596, -90450, -90304, -90158, -90013, -89868, -89724, -89579,
    -89435, -89292, -89148, -89005, -88862, -88720, -88577, -88435,
    -88294, -88152, -88011, -87871, -87730, -87590, -87450, -87310,
    -87171, -87032, -86893, -86755, -86616, -86479, -86341, -86204,
    -86066, -85930, -85793, -85657, -85521, -85385, -85250, -85114,
    -84980, -84845, -84710, -84576, -84443, -84309, -84176, -84043,
    -83910, -83777, -83645, -83513, -83381, -83250, -83118, -82987,
    -82857, -82726, -82596, -82466, -82336, -82207, -82078, -81949,
    -81820, -81691, -81563, -81435, -81307, -81180, -81053, -80925,
    -80799, -80672, -80546, -80420, -80294, -80168, -80043, -79918,
    -79793, -79668, -79544, -79420, -79296, -79172, -79048, -78925,
    -78802, -78679, -78557, -78434, -78312, -78190, -78068, -77947,
    -77826, -77705, -77584, -77463, -77343, -77223, -77103, -76983,
    -76864, -76744, -76625, -76506, -76388, -76269, -76151, -76033,
    -75915, -75797, -75680, -75563, -75446, -75329, -75213, -75096,
    -74980, -74864, -74748, -74633, -74517, -74402, -74287, -74172,
    -74058, -73944, -73829, -73715, -73602, -73488, -73375, -73262,
    -73149, -73036, -72923, -72811, -72699, -72587, -72475, -72363,
    -72252, -72140, -72029, -71918, -71808, -71697, -71587, -71477,
    -71367, -71257, -71147, -71038, -70929, -70820, -70711, -70602,
    -70494, -70385, -70277, -70169, -70061, -69954, -69846, -69739,
    -69632, -69525, -69418, -69312, -69205, -69099, -68993, -68887,
    -68781, -68676, -68570, -68465, -68360, -68255, -68151, -68046,
    -67942, -67837, -67733, -67629, -67526, -67422, -67319, -67216,
    -67113, -67010, -66907, -66804, -66702, -66600, -66498, -66396,
    -66294, -66192, -66091, -65989, -65888, -65787, -65686, -65586,
    -65485, -65385, -65285, -65185, -65085, -64985, -64885, -64786,
    -64687, -64587, -64488, -64389, -64291, -64192, -64094, -63996,
    -63897, -63799, -63702, -63604, -63506, -63409, -63312, -63215,
    -63118, -63021, -62924, -62828, -62731, -62635, -62539, -62443,
    -62347, -62251, -62156, -62060, -61965, -61870, -61775, -61680,
    -61585, -61491, -61396, -61302, -61208, -61114, -61020, -60926,
    -60833, -60739, -60646, -60552, -60459, -60366, -60273, -60181,
    -60088, -59996, -59903, -59811, -59719, -59627, -59535, -59444,
    -59352, -59261, -59169, -59078, -58987, -58896, -58805, -58715,
    -58624, -58534, -58443, -58353, -58263, -58173, -58083, -57994,
    -57904, -57815, -57725, -57636, -57547, -57458, -57369, -57281,
    -57192, -57104, -57015, -56927, -56839, -56751, -56663, -56575,
    -56487, -56400, -56312, -56225, -56138, -56051, -55964, -55877,
    -55790, -55704, -55617, -55531, -55444, -55358, -55272, -55186,
    -55100, -55015, -54929, -54843, -54758, -54673, -54587, -54502,
    -54417, -54333, -54248, -54163, -54079, -53994, -53910, -53826,
    -53741, -53657, -53574, -53490, -53406, -53322, -53239, -53156,
    -53072, -52989, -52906, -52823, -52740, -52657, -52575, -52492,
    -52410, -52327, -52245, -52163, -52081, -51999, -51917, -51835,
    -51754, -51672, -51591, -51509, -51428, -51347, -51266, -51185,
    -51104, -51023, -50942, -50862, -50781, -50701, -50621, -50540,
    -50460, -50380, -50300, -50221, -50141, -50061, -49982, -49902,
    -49823, -49744, -49664, -49585, -49506, -49427, -49349, -49270,
    -49191, -49113, -49034, -48956, -48878, -48799, -48721, -48643,
    -48565, -48488, -48410, -48332, -48255, -48177, -48100, -48022,
    -47945, -47868, -47791, -47714, -47637, -47560, -47484, -47407,
    -47331, -47254, -47178, -47102, -47025, -46949, -46873, -46797,
    -46721, -46646, -46570, -46494, -46419, -46343, -46268, -46193,
    -46118, -46042, -45967, -45892, -45818, -45743, -45668, -45593,
    -45519, -45444, -45370, -45296, -45221, -45147, -45073, -44999,
    -44925, -44851, -44778, -44704, -44630, -44557, -44483, -44410,
    -44337, -44263, -44190, -44117, -44044, -43971, -43898, -43826,
    -43753, -43680, -43608, -43535, -43463, -43390, -43318, -43246,
    -43174, -43102, -43030, -42958, -42886, -42814, -42743, -42671,
    -42600, -42528, -42457, -42385, -42314, -42243, -42172, -42101,
    -42030, -41959, -41888, -41817, -41747, -41676, -41605, -41535,
    -41465, -41394, -41324, -41254, -41184, -41113, -41043, -40973,
    -40904, -40834, -40764, -40694, -40625, -40555, -40486, -40416,
    -40347, -40278, -40208, -40139, -40070, -40001, -39932, -39863,
    -39794, -39726, -39657, -39588, -39520, -39451, -39383, -39314,
    -39246, -39178, -39110, -39042, -38973, -38905, -38837, -38770,
    -38702, -38634, -38566, -38499, -38431, -38364, -38296, -38229,
    -38161, -38094, -38027, -37960, -37893, -37826, -37759, -37692,
    -37625, -37558, -37491, -37425, -37358, -37291, -37225, -37158,
    -37092, -37026, -36959, -36893, -36827, -36761, -36695, -36629,
    -36563, -36497, -36431, -36365, -36300, -36234, -36168, -36103,
    -36037, -35972, -35907, -35841, -35776, -35711, -35646, -35580,
    -35515, -35450, -35385, -35321, -35256, -35191, -35126, -35062,
    -34997, -34932, -34868, -34803, -34739, -34675, -34610, -34546,
    -34482, -34418, -34354, -34289, -34225, -34162, -34098, -34034,
    -33970, -33906, -33843, -33779, -33715, -33652, -33588, -33525,
    -33461, -33398, -33335, -33272, -33208, -33145, -33082, -33019,
    -32956, -32893, -32830, -32767, -32705, -32642, -32579, -32516,
    -32454, -32391, -32329, -32266, -32204, -32141, -32079, -32017,
    -31955, -31892, -31830, -31768, -31706, -31644, -31582, -31520,
    -31458, -31396, -31335, -31273, -31211, -31150, -31088, -31026,
    -30965, -30904, -30842, -30781, -30719, -30658, -30597, -30536,
    -30474, -30413, -30352, -30291, -30230, -30169, -30108, -30048,
    -29987, -29926, -29865, -29805, -29744, -29683, -29623, -29562,
    -29502, -29441, -29381, -29321, -29260, -29200, -29140, -29080,
    -29020, -28959, -28899, -28839, -28779, -28719, -28660, -28600,
    -28540, -28480, -28420, -28361, -28301, -28241, -28182, -28122,
    -28063, -28003, -27944, -27884, -27825, -27766, -27707, -27647,
    -27588, -27529, -27470, -27411, -27352, -27293, -27234, -27175,
    -27116, -27057, -26998, -26940, -26881, -26822, -26763, -26705,
    -26646, -26588, -26529, -26471, -26412, -26354, -26295, -26237,
    -26179, -26120, -26062, -26004, -25946, -25888, -25830, -25772,
    -25714, -25656, -25598, -25540, -25482, -25424, -25366, -25308,
    -25251, -25193, -25135, -25078, -25020, -24962, -24905, -24847,
    -24790, -24732, -24675, -24618, -24560, -24503, -24446, -24389,
    -24331, -24274, -24217, -24160, -24103, -24046, -23989, -23932,
    -23875, -23818, -23761, -23704, -23647, -23591, -23534, -23477,
    -23420, -23364, -23307, -23250, -23194, -23137, -23081, -23024,
    -22968, -22911, -22855, -22799, -22742, -22686, -22630, -22573,
    -22517, -22461, -22405, -22349, -22293, -22237, -22181, -22125,
    -22069, -22013, -21957, -21901, -21845, -21789, -21733, -21678,
    -21622, -21566, -21510, -21455, -21399, -21343, -21288, -21232,
    -21177, -21121, -21066, -21010, -20955, -20900, -20844, -20789,
    -20734, -20678, -20623, -20568, -20513, -20457, -20402, -20347,
    -20292, -20237, -20182, -20127, -20072, -20017, -19962, -19907,
    -19852, -19797, -19742, -19688, -19633, -19578, -19523, -19469,
    -19414, -19359, -19305, -19250, -19195, -19141, -19086, -19032,
    -18977, -18923, -18868, -18814, -18760, -18705, -18651, -18597,
    -18542, -18488, -18434, -18380, -18325, -18271, -18217, -18163,
    -18109, -18055, -18001, -17946, -17892, -17838, -17784, -17731,
    -17677, -17623, -17569, -17515, -17461, -17407, -17353, -17300,
    -17246, -17192, -17138, -17085, -17031, -16977, -16924, -16870,
    -16817, -16763, -16710, -16656, -16603, -16549, -16496, -16442,
    -16389, -16335, -16282, -16229, -16175, -16122, -16069, -16015,
    -15962, -15909, -15856, -15802, -15749, -15696, -15643, -15590,
    -15537, -15484, -15431, -15378, -15325, -15272, -15219, -15166,
    -15113, -15060, -15007, -14954, -14901, -14848, -14795, -14743,
    -14690, -14637, -14584, -14531, -14479, -14426, -14373, -14321,
    -14268, -14215, -14163, -14110, -14057, -14005, -13952, -13900,
    -13847, -13795, -13742, -13690, -13637, -13585, -13533, -13480,
    -13428, -13375, -13323, -13271, -13218, -13166, -13114, -13062,
    -13009, -12957, -12905, -12853, -12800, -12748, -12696, -12644,
    -12592, -12540, -12488, -12436, -12383, -12331, -12279, -12227,
    -12175, -12123, -12071, -12019, -11967, -11916, -11864, -11812,
    -11760, -11708, -11656, -11604, -11552, -11501, -11449, -11397,
    -11345, -11293, -11242, -11190, -11138, -11086, -11035, -10983,
    -10931, -10880, -10828, -10777, -10725, -10673, -10622, -10570,
    -10519, -10467, -10415, -10364, -10312, -10261, -10209, -10158,
    -10106, -10055, -10004, -9952, -9901, -9849, -9798, -9747,
    -9695, -9644, -9592, -9541, -9490, -9438, -9387, -9336,
    -9285, -9233, -9182, -9131, -9080, -9028, -8977, -8926,
    -8875, -8824, -8772, -8721, -8670, -8619, -8568, -8517,
    -8466, -8414, -8363, -8312, -8261, -8210, -8159, -8108,
    -8057, -8006, -7955, -7904, -7853, -7802, -7751, -7700,
    -7649, -7598, -7547, -7496, -7445, -7395, -7344, -7293,
    -7242, -7191, -7140, -7089, -7038, -6988, -6937, -6886,
    -6835, -6784, -6733, -6683, -6632, -6581, -6530, -6480,
    -6429, -6378, -6327, -6277, -6226, -6175, -6124, -6074,
    -6023, -5972, -5922, -5871, -5820, -5770, -5719, -5668,
    -5618, -5567, -5517, -5466, -5415, -5365, -5314, -5264,
    -5213, -5162, -5112, -5061, -5011, -4960, -4910, -4859,
    -4808, -4758, -4707, -4657, -4606, -4556, -4505, -4455,
    -4404, -4354, -4303, -4253, -4202, -4152, -4101, -4051,
    -4001, -3950, -3900, -3849, -3799, -3748, -3698, -3648,
    -3597, -3547, -3496, -3446, -3395, -3345, -3295, -3244,
    -3194, -3144, -3093, -3043, -2992, -2942, -2892, -2841,
    -2791, -2741, -2690, -2640, -2590, -2539, -2489, -2439,
    -2388, -2338, -2288, -2237, -2187, -2137, -2086, -2036,
    -1986, -1935, -1885, -1835, -1784, -1734, -1684, -1633,
    -1583, -1533, -1483, -1432, -1382, -1332, -1281, -1231,
    -1181, -1131, -1080, -1030, -980, -929, -879, -829,
    -779, -728, -678, -628, -578, -527, -477, -427,
    -376, -326, -276, -226, -175, -125, -75, -25,
    25, 75, 125, 175, 226, 276, 326, 376,
    427, 477, 527, 578, 628, 678, 728, 779,
    829, 879, 929, 980, 1030, 1080, 1131, 1181,
    1231, 1281, 1332, 1382, 1432, 1483, 1533, 1583,
    1633, 1684, 1734, 1784, 1835, 1885, 1935, 1986,
    2036, 2086, 2137, 2187, 2237, 2288, 2338, 2388,
    2439, 2489, 2539, 2590, 2640, 2690, 2741, 2791,
    2841, 2892, 2942, 2992, 3043, 3093, 3144, 3194,
    3244, 3295, 3345, 3395, 3446, 3496, 3547, 3597,
    3648, 3698, 3748, 3799, 3849, 3900, 3950, 4001,
    4051, 4101, 4152, 4202, 4253, 4303, 4354, 4404,
    4455, 4505, 4556, 4606, 4657, 4707, 4758, 4808,
    4859, 4910, 4960, 5011, 5061, 5112, 5162, 5213,
    5264, 5314, 5365, 5415, 5466, 5517, 5567, 5618,
    5668, 5719, 5770, 5820, 5871, 5922, 5972, 6023,
    6074, 6124, 6175, 6226, 6277, 6327, 6378, 6429,
    6480, 6530, 6581, 6632, 6683, 6733, 6784, 6835,
    6886, 6937, 6988, 7038, 7089, 7140, 7191, 7242,
    7293, 7344, 7395, 7445, 7496, 7547, 7598, 7649,
    7700, 7751, 7802, 7853, 7904, 7955, 8006, 8057,
    8108, 8159, 8210, 8261, 8312, 8363, 8414, 8466,
    8517, 8568, 8619, 8670, 8721, 8772, 8824, 8875,
    8926, 8977, 9028, 9080, 9131, 9182, 9233, 9285,
    9336, 9387, 9438, 9490, 9541, 9592, 9644, 9695,
    9747, 9798, 9849, 9901, 9952, 10004, 10055, 10106,
    10158, 10209, 10261, 10312, 10364, 10415, 10467, 10519,
    10570, 10622, 10673, 10725, 10777, 10828, 10880, 10931,
    10983, 11035, 11086, 11138, 11190, 11242, 11293, 11345,
    11397, 11449, 11501, 11552, 11604, 11656, 11708, 11760,
    11812, 11864, 11916, 11967, 12019, 12071, 12123, 12175,
    12227, 12279, 12331, 12383, 12436, 12488, 12540, 12592,
    12644, 12696, 12748, 12800, 12853, 12905, 12957, 13009,
    13062, 13114, 13166, 13218, 13271, 13323, 13375, 13428,
    13480, 13533, 13585, 13637, 13690, 13742, 13795, 13847,
    13900, 13952, 14005, 14057, 14110, 14163, 14215, 14268,
    14321, 14373, 14426, 14479, 14531, 14584, 14637, 14690,
    14743, 14795, 14848, 14901, 14954, 15007, 15060, 15113,
    15166, 15219, 15272, 15325, 15378, 15431, 15484, 15537,
    15590, 15643, 15696, 15749, 15802, 15856, 15909, 15962,
    16015, 16069, 16122, 16175, 16229, 16282, 16335, 16389,
    16442, 16496, 16549, 16603, 16656, 16710, 16763, 16817,
    16870, 16924, 16977, 17031, 17085, 17138, 17192, 17246,
    17300, 17353, 17407, 17461, 17515, 17569, 17623, 17677,
    17731, 17784, 17838, 17892, 17946, 18001, 18055, 18109,
    18163, 18217, 18271, 18325, 18380, 18434, 18488, 18542,
    18597, 18651, 18705, 18760, 18814, 18868, 18923, 18977,
    19032, 19086, 19141, 19195, 19250, 19305, 19359, 19414,
    19469, 19523, 19578, 19633, 19688, 19742, 19797, 19852,
    19907, 19962, 20017, 20072, 20127, 20182, 20237, 20292,
    20347, 20402, 20457, 20513, 20568, 20623, 20678, 20734,
    20789, 20844, 20900, 20955, 21010, 21066, 21121, 21177,
    21232, 21288, 21343, 21399, 21455, 21510, 21566, 21622,
    21678, 21733, 21789, 21845, 21901, 21957, 22013, 22069,
    22125, 22181, 22237, 22293, 22349, 22405, 22461, 22517,
    22573, 22630, 22686, 22742, 22799, 22855, 22911, 22968,
    23024, 23081, 23137, 23194, 23250, 23307, 23364, 23420,
    23477, 23534, 23591, 23647, 23704, 23761, 23818, 23875,
    23932, 23989, 24046, 24103, 24160, 24217, 24274, 24331,
    24389, 24446, 24503, 24560, 24618, 24675, 24732, 24790,
    24847, 24905, 24962, 25020, 25078, 25135, 25193, 25251,
    25308, 25366, 25424, 25482, 25540, 25598, 25656, 25714,
    25772, 25830, 25888, 25946, 26004, 26062, 26120, 26179,
    26237, 26295, 26354, 26412, 26471, 26529, 26588, 26646,
    26705, 26763, 26822, 26881, 26940, 26998, 27057, 27116,
    27175, 27234, 27293, 27352, 27411, 27470, 27529, 27588,
    27647, 27707, 27766, 27825, 27884, 27944, 28003, 28063,
    28122, 28182, 28241, 28301, 28361, 28420, 28480, 28540,
    28600, 28660, 28719, 28779, 28839, 28899, 28959, 29020,
    29080, 29140, 29200, 29260, 29321, 29381, 29441, 29502,
    29562, 29623, 29683, 29744, 29805, 29865, 29926, 29987,
    30048, 30108, 30169, 30230, 30291, 30352, 30413, 30474,
    30536, 30597, 30658, 30719, 30781, 30842, 30904, 30965,
    31026, 31088, 31150, 31211, 31273, 31335, 31396, 31458,
    31520, 31582, 31644, 31706, 31768, 31830, 31892, 31955,
    32017, 32079, 32141, 32204, 32266, 32329, 32391, 32454,
    32516, 32579, 32642, 32705, 32767, 32830, 32893, 32956,
    33019, 33082, 33145, 33208, 33272, 33335, 33398, 33461,
    33525, 33588, 33652, 33715, 33779, 33843, 33906, 33970,
    34034, 34098, 34162, 34225, 34289, 34354, 34418, 34482,
    34546, 34610, 34675, 34739, 34803, 34868, 34932, 34997,
    35062, 35126, 35191, 35256, 35321, 35385, 35450, 35515,
    35580, 35646, 35711, 35776, 35841, 35907, 35972, 36037,
    36103, 36168, 36234, 36300, 36365, 36431, 36497, 36563,
    36629, 36695, 36761, 36827, 36893, 36959, 37026, 37092,
    37158, 37225, 37291, 37358, 37425, 37491, 37558, 37625,
    37692, 37759, 37826, 37893, 37960, 38027, 38094, 38161,
    38229, 38296, 38364, 38431, 38499, 38566, 38634, 38702,
    38770, 38837, 38905, 38973, 39042, 39110, 39178, 39246,
    39314, 39383, 39451, 39520, 39588, 39657, 39726, 39794,
    39863, 39932, 40001, 40070, 40139, 40208, 40278, 40347,
    40416, 40486, 40555, 40625, 40694, 40764, 40834, 40904,
    40973, 41043, 41113, 41184, 41254, 41324, 41394, 41465,
    41535, 41605, 41676, 41747, 41817, 41888, 41959, 42030,
    42101, 42172, 42243, 42314, 42385, 42457, 42528, 42600,
    42671, 42743, 42814, 42886, 42958, 43030, 43102, 43174,
    43246, 43318, 43390, 43463, 43535, 43608, 43680, 43753,
    43826, 43898, 43971, 44044, 44117, 44190, 44263, 44337,
    44410, 44483, 44557, 44630, 44704, 44778, 44851, 44925,
    44999, 45073, 45147, 45221, 45296, 45370, 45444, 45519,
    45593, 45668, 45743, 45818, 45892, 45967, 46042, 46118,
    46193, 46268, 46343, 46419, 46494, 46570, 46646, 46721,
    46797, 46873, 46949, 47025, 47102, 47178, 47254, 47331,
    47407, 47484, 47560, 47637, 47714, 47791, 47868, 47945,
    48022, 48100, 48177, 48255, 48332, 48410, 48488, 48565,
    48643, 48721, 48799, 48878, 48956, 49034, 49113, 49191,
    49270, 49349, 49427, 49506, 49585, 49664, 49744, 49823,
    49902, 49982, 50061, 50141, 50221, 50300, 50380, 50460,
    50540, 50621, 50701, 50781, 50862, 50942, 51023, 51104,
    51185, 51266, 51347, 51428, 51509, 51591, 51672, 51754,
    51835, 51917, 51999, 52081, 52163, 52245, 52327, 52410,
    52492, 52575, 52657, 52740, 52823, 52906, 52989, 53072,
    53156, 53239, 53322, 53406, 53490, 53574, 53657, 53741,
    53826, 53910, 53994, 54079, 54163, 54248, 54333, 54417,
    54502, 54587, 54673, 54758, 54843, 54929, 55015, 55100,
    55186, 55272, 55358, 55444, 55531, 55617, 55704, 55790,
    55877, 55964, 56051, 56138, 56225, 56312, 56400, 56487,
    56575, 56663, 56751, 56839, 56927, 57015, 57104, 57192,
    57281, 57369, 57458, 57547, 57636, 57725, 57815, 57904,
    57994, 58083, 58173, 58263, 58353, 58443, 58534, 58624,
    58715, 58805, 58896, 58987, 59078, 59169, 59261, 59352,
    59444, 59535, 59627, 59719, 59811, 59903, 59996, 60088,
    60181, 60273, 60366, 60459, 60552, 60646, 60739, 60833,
    60926, 61020, 61114, 61208, 61302, 61396, 61491, 61585,
    61680, 61775, 61870, 61965, 62060, 62156, 62251, 62347,
    62443, 62539, 62635, 62731, 62828, 62924, 63021, 63118,
    63215, 63312, 63409, 63506, 63604, 63702, 63799, 63897,
    63996, 64094, 64192, 64291, 64389, 64488, 64587, 64687,
    64786, 64885, 64985, 65085, 65185, 65285, 65385, 65485,
    65586, 65686, 65787, 65888, 65989, 66091, 66192, 66294,
    66396, 66498, 66600, 66702, 66804, 66907, 67010, 67113,
    67216, 67319, 67422, 67526, 67629, 67733, 67837, 67942,
    68046, 68151, 68255, 68360, 68465, 68570, 68676, 68781,
    68887, 68993, 69099, 69205, 69312, 69418, 69525, 69632,
    69739, 69846, 69954, 70061, 70169, 70277, 70385, 70494,
    70602, 70711, 70820, 70929, 71038, 71147, 71257, 71367,
    71477, 71587, 71697, 71808, 71918, 72029, 72140, 72252,
    72363, 72475, 72587, 72699, 72811, 72923, 73036, 73149,
    73262, 73375, 73488, 73602, 73715, 73829, 73944, 74058,
    74172, 74287, 74402, 74517, 74633, 74748, 74864, 74980,
    75096, 75213, 75329, 75446, 75563, 75680, 75797, 75915,
    76033, 76151, 76269, 76388, 76506, 76625, 76744, 76864,
    76983, 77103, 77223, 77343, 77463, 77584, 77705, 77826,
    77947, 78068, 78190, 78312, 78434, 78557, 78679, 78802,
    78925, 79048, 79172, 79296, 79420, 79544, 79668, 79793,
    79918, 80043, 80168, 80294, 80420, 80546, 80672, 80799,
    80925, 81053, 81180, 81307, 81435, 81563, 81691, 81820,
    81949, 82078, 82207, 82336, 82466, 82596, 82726, 82857,
    82987, 83118, 83250, 83381, 83513, 83645, 83777, 83910,
    84043, 84176, 84309, 84443, 84576, 84710, 84845, 84980,
    85114, 85250, 85385, 85521, 85657, 85793, 85930, 86066,
    86204, 86341, 86479, 86616, 86755, 86893, 87032, 87171,
    87310, 87450, 87590, 87730, 87871, 88011, 88152, 88294,
    88435, 88577, 88720, 88862, 89005, 89148, 89292, 89435,
    89579, 89724, 89868, 90013, 90158, 90304, 90450, 90596,
    90742, 90889, 91036, 91184, 91332, 91480, 91628, 91777,
    91926, 92075, 92225, 92375, 92525, 92675, 92826, 92978,
    93129, 93281, 93434, 93586, 93739, 93892, 94046, 94200,
    94354, 94509, 94664, 94819, 94975, 95131, 95287, 95444,
    95601, 95758, 95916, 96074, 96233, 96391, 96551, 96710,
    96870, 97030, 97191, 97352, 97513, 97675, 97837, 98000,
    98163, 98326, 98489, 98653, 98818, 98982, 99148, 99313,
    99479, 99645, 99812, 99979, 100146, 100314, 100482, 100651,
    100820, 100990, 101159, 101330, 101500, 101671, 101843, 102015,
    102187, 102360, 102533, 102706, 102880, 103054, 103229, 103404,
    103580, 103756, 103933, 104109, 104287, 104465, 104643, 104821,
    105000, 105180, 105360, 105540, 105721, 105902, 106084, 106266,
    106449, 106632, 106816, 107000, 107184, 107369, 107555, 107741,
    107927, 108114, 108301, 108489, 108677, 108866, 109055, 109245,
    109435, 109626, 109817, 110008, 110200, 110393, 110586, 110780,
    110974, 111169, 111364, 111560, 111756, 111952, 112150, 112347,
    112546, 112744, 112944, 113143, 113344, 113545, 113746, 113948,
    114151, 114354, 114557, 114761, 114966, 115171, 115377, 115583,
    115790, 115998, 116206, 116414, 116623, 116833, 117044, 117254,
    117466, 117678, 117891, 118104, 118318, 118532, 118747, 118963,
    119179, 119396, 119613, 119831, 120050, 120269, 120489, 120709,
    120930, 121152, 121374, 121597, 121821, 122045, 122270, 122496,
    122722, 122949, 123176, 123404, 123633, 123863, 124093, 124324,
    124555, 124787, 125020, 125254, 125488, 125723, 125959, 126195,
    126432, 126669, 126908, 127147, 127387, 127627, 127869, 128111,
    128353, 128597, 128841, 129086, 129332, 129578, 129825, 130073,
    130322, 130571, 130821, 131072, 131324, 131576, 131830, 132084,
    132339, 132594, 132851, 133108, 133366, 133625, 133884, 134145,
    134406, 134668, 134931, 135195, 135459, 135725, 135991, 136258,
    136526, 136795, 137065, 137335, 137607, 137879, 138152, 138426,
    138701, 138977, 139254, 139532, 139810, 140090, 140370, 140651,
    140934, 141217, 141501, 141786, 142072, 142359, 142647, 142936,
    143226, 143517, 143808, 144101, 144395, 144690, 144986, 145282,
    145580, 145879, 146179, 146480, 146782, 147084, 147388, 147693,
    148000, 148307, 148615, 148924, 149235, 149546, 149859, 150172,
    150487, 150803, 151120, 151438, 151757, 152077, 152399, 152722,
    153045, 153370, 153697, 154024, 154352, 154682, 155013, 155345,
    155678, 156013, 156349, 156686, 157024, 157363, 157704, 158046,
    158389, 158734, 159079, 159427, 159775, 160125, 160476, 160828,
    161182, 161537, 161893, 162251, 162610, 162970, 163332, 163695,
    164060, 164426, 164793, 165162, 165532, 165904, 166277, 166651,
    167027, 167405, 167784, 168164, 168546, 168930, 169315, 169701,
    170089, 170479, 170870, 171263, 171657, 172053, 172451, 172850,
    173251, 173653, 174057, 174463, 174870, 175279, 175690, 176102,
    176516, 176932, 177349, 177769, 178190, 178612, 179037, 179463,
    179891, 180321, 180753, 181186, 181622, 182059, 182498, 182939,
    183382, 183827, 184274, 184722, 185173, 185625, 186080, 186536,
    186995, 187455, 187918, 188382, 188849, 189318, 189789, 190261,
    190736, 191213, 191693, 192174, 192658, 193143, 193631, 194122,
    194614, 195109, 195606, 196105, 196606, 197110, 197616, 198125,
    198636, 199149, 199664, 200182, 200703, 201226, 201751, 202279,
    202809, 203342, 203878, 204416, 204956, 205500, 206045, 206594,
    207145, 207699, 208255, 208815, 209376, 209941, 210509, 211079,
    211652, 212228, 212807, 213389, 213973, 214561, 215151, 215745,
    216341, 216941, 217544, 218149, 218758, 219370, 219985, 220603,
    221225, 221849, 222477, 223108, 223743, 224381, 225022, 225666,
    226314, 226966, 227621, 228279, 228941, 229606, 230275, 230948,
    231624, 232304, 232988, 233676, 234367, 235062, 235761, 236463,
    237170, 237881, 238595, 239314, 240036, 240763, 241493, 242228,
    242967, 243711, 244458, 245210, 245966, 246727, 247492, 248261,
    249035, 249813, 250596, 251384, 252176, 252973, 253774, 254581,
    255392, 256208, 257029, 257855, 258686, 259522, 260363, 261209,
    262060, 262917, 263779, 264646, 265519, 266397, 267280, 268169,
    269064, 269965, 270871, 271782, 272700, 273624, 274553, 275489,
    276430, 277378, 278332, 279292, 280258, 281231, 282210, 283195,
    284188, 285186, 286192, 287204, 288223, 289249, 290282, 291322,
    292369, 293423, 294485, 295554, 296630, 297714, 298805, 299904,
    301011, 302126, 303248, 304379, 305517, 306664, 307819, 308983,
    310154, 311335, 312524, 313721, 314928, 316143, 317368, 318601,
    319844, 321097, 322358, 323629, 324910, 326201, 327502, 328812,
    330133, 331464, 332805, 334157, 335519, 336892, 338276, 339671,
    341078, 342495, 343924, 345364, 346816, 348280, 349756, 351244,
    352744, 354257, 355783, 357321, 358872, 360436, 362013, 363604,
    365208, 366826, 368459, 370105, 371765, 373440, 375130, 376835,
    378555, 380290, 382040, 383807, 385589, 387387, 389202, 391034,
    392882, 394747, 396630, 398530, 400448, 402384, 404338, 406311,
    408303, 410314, 412344, 414395, 416465, 418555, 420666, 422798,
    424951, 427125, 429321, 431540, 433781, 436045, 438332, 440643,
    442978, 445337, 447720, 450129, 452564, 455024, 457511, 460024,
    462565, 465133, 467730, 470355, 473009, 475692, 478406, 481150,
    483925, 486732, 489571, 492443, 495348, 498287, 501261, 504269,
    507313, 510394, 513512, 516667, 519861, 523094, 526366, 529680,
    533034, 536431, 539870, 543354, 546881, 550455, 554074, 557741,
    561456, 565221, 569035, 572901, 576818, 580789, 584815, 588896,
    593033, 597229, 601483, 605798, 610174, 614613, 619117, 623686,
    628323, 633028, 637803, 642651, 647572, 652568, 657640, 662792,
    668024, 673338, 678737, 684223, 689797, 695462, 701219, 707072,
    713023, 719074, 725227, 731486, 737853, 744331, 750922, 757631,
    764460, 771411, 778490, 785699, 793041, 800521, 808143, 815910,
    823827, 831898, 840127, 848520, 857081, 865817, 874730, 883829,
    893117, 902602, 912289, 922186, 932298, 942633, 953199, 964003,
    975054, 986361, 997931, 1009774, 1021901, 1034322, 1047046, 1060087,
    1073455, 1087164, 1101225, 1115654, 1130465, 1145673, 1161294, 1177345,
    1193846, 1210813, 1228269, 1246234, 1264730, 1283783, 1303416, 1323658,
    1344537, 1366084, 1388330, 1411312, 1435065, 1459630, 1485049, 1511367,
    1538632, 1566898, 1596220, 1626658, 1658278, 1691149, 1725348, 1760956,
    1798063, 1836758, 1877161, 1919378, 1963536, 2009771, 2058233, 2109087,
    2162516, 2218719, 2277919, 2340362, 2406322, 2476104, 2550052, 2628549,
    2712030, 2800983, 2895966, 2997613, 3106651, 3223918, 3350381, 3487165,
    3635590, 3797206, 3973855, 4167737, 4381502, 4618375, 4882318, 5178251,
    5512368, 5892567, 6329090, 6835455, 7429880, 8137527, 8994149, 10052327,
    11392683, 13145455, 15535599, 18988036, 24413316, 34178904, 56965752, 170910304
};

int finesine[10240] =
{
    25, 75, 125, 175, 226, 276, 326, 376,
    427, 477, 527, 578, 628, 678, 728, 779,
    829, 879, 929, 980, 1030, 1080, 1130, 1181,
    1231, 1281, 1331, 1382, 1432, 1482, 1532, 1583,
    1633, 1683, 1733, 1784, 1834, 1884, 1934, 1985,
    2035, 2085, 2135, 2186, 2236, 2286, 2336, 2387,
    2437, 2487, 2537, 2587, 2638, 2688, 2738, 2788,
    2839, 2889, 2939, 2989, 3039, 3090, 3140, 3190,
    3240, 3291, 3341, 3391, 3441, 3491, 3541, 3592,
    3642, 3692, 3742, 3792, 3843, 3893, 3943, 3993,
    4043, 4093, 4144, 4194, 4244, 4294, 4344, 4394,
    4445, 4495, 4545, 4595, 4645, 4695, 4745, 4796,
    4846, 4896, 4946, 4996, 5046, 5096, 5146, 5197,
    5247, 5297, 5347, 5397, 5447, 5497, 5547, 5597,
    5647, 5697, 5748, 5798, 5848, 5898, 5948, 5998,
    6048, 6098, 6148, 6198, 6248, 6298, 6348, 6398,
    6448, 6498, 6548, 6598, 6648, 6698, 6748, 6798,
    6848, 6898, 6948, 6998, 7048, 7098, 7148, 7198,
    7248, 7298, 7348, 7398, 7448, 7498, 7548, 7598,
    7648, 7697, 7747, 7797, 7847, 7897, 7947, 7997,
    8047, 8097, 8147, 8196, 8246, 8296, 8346, 8396,
    8446, 8496, 8545, 8595, 8645, 8695, 8745, 8794,
    8844, 8894, 8944, 8994, 9043, 9093, 9143, 9193,
    9243, 9292, 9342, 9392, 9442, 9491, 9541, 9591,
    9640, 9690, 9740, 9790, 9839, 9889, 9939, 9988,
    10038, 10088, 10137, 10187, 10237, 10286, 10336, 10386,
    10435, 10485, 10534, 10584, 10634, 10683, 10733, 10782,
    10832, 10882, 10931, 10981, 11030, 11080, 11129, 11179,
    11228, 11278, 11327, 11377, 11426, 11476, 11525, 11575,
    11624, 11674, 11723, 11773, 11822, 11872, 11921, 11970,
    12020, 12069, 12119, 12168, 12218, 12267, 12316, 12366,
    12415, 12464, 12514, 12563, 12612, 12662, 12711, 12760,
    12810, 12859, 12908, 12957, 13007, 13056, 13105, 13154,
    13204, 13253, 13302, 13351, 13401, 13450, 13499, 13548,
    13597, 13647, 13696, 13745, 13794, 13843, 13892, 13941,
    13990, 14040, 14089, 14138, 14187, 14236, 14285, 14334,
    14383, 14432, 14481, 14530, 14579, 14628, 14677, 14726,
    14775, 14824, 14873, 14922, 14971, 15020, 15069, 15118,
    15167, 15215, 15264, 15313, 15362, 15411, 15460, 15509,
    15557, 15606, 15655, 15704, 15753, 15802, 15850, 15899,
    15948, 15997, 16045, 16094, 16143, 16191, 16240, 16289,
    16338, 16386, 16435, 16484, 16532, 16581, 16629, 16678,
    16727, 16775, 16824, 16872, 16921, 16970, 17018, 17067,
    17115, 17164, 17212, 17261, 17309, 17358, 17406, 17455,
    17503, 17551, 17600, 17648, 17697, 17745, 17793, 17842,
    17890, 17939, 17987, 18035, 18084, 18132, 18180, 18228,
    18277, 18325, 18373, 18421, 18470, 18518, 18566, 18614,
    18663, 18711, 18759, 18807, 18855, 18903, 18951, 19000,
    19048, 19096, 19144, 19192, 19240, 19288, 19336, 19384,
    19432, 19480, 19528, 19576, 19624, 19672, 19720, 19768,
    19816, 19864, 19912, 19959, 20007, 20055, 20103, 20151,
    20199, 20246, 20294, 20342, 20390, 20438, 20485, 20533,
    20581, 20629, 20676, 20724, 20772, 20819, 20867, 20915,
    20962, 21010, 21057, 21105, 21153, 21200, 21248, 21295,
    21343, 21390, 21438, 21485, 21533, 21580, 21628, 21675,
    21723, 21770, 21817, 21865, 21912, 21960, 22007, 22054,
    22102, 22149, 22196, 22243, 22291, 22338, 22385, 22433,
    22480, 22527, 22574, 22621, 22668, 22716, 22763, 22810,
    22857, 22904, 22951, 22998, 23045, 23092, 23139, 23186,
    23233, 23280, 23327, 23374, 23421, 23468, 23515, 23562,
    23609, 23656, 23703, 23750, 23796, 23843, 23890, 23937,
    23984, 24030, 24077, 24124, 24171, 24217, 24264, 24311,
    24357, 24404, 24451, 24497, 24544, 24591, 24637, 24684,
    24730, 24777, 24823, 24870, 24916, 24963, 25009, 25056,
    25102, 25149, 25195, 25241, 25288, 25334, 25381, 25427,
    25473, 25520, 25566, 25612, 25658, 25705, 25751, 25797,
    25843, 25889, 25936, 25982, 26028, 26074, 26120, 26166,
    26212, 26258, 26304, 26350, 26396, 26442, 26488, 26534,
    26580, 26626, 26672, 26718, 26764, 26810, 26856, 26902,
    26947, 26993, 27039, 27085, 27131, 27176, 27222, 27268,
    27313, 27359, 27405, 27450, 27496, 27542, 27587, 27633,
    27678, 27724, 27770, 27815, 27861, 27906, 27952, 27997,
    28042, 28088, 28133, 28179, 28224, 28269, 28315, 28360,
    28405, 28451, 28496, 28541, 28586, 28632, 28677, 28722,
    28767, 28812, 28858, 28903, 28948, 28993, 29038, 29083,
    29128, 29173, 29218, 29263, 29308, 29353, 29398, 29443,
    29488, 29533, 29577, 29622, 29667, 29712, 29757, 29801,
    29846, 29891, 29936, 29980, 30025, 30070, 30114, 30159,
    30204, 30248, 30293, 30337, 30382, 30426, 30471, 30515,
    30560, 30604, 30649, 30693, 30738, 30782, 30826, 30871,
    30915, 30959, 31004, 31048, 31092, 31136, 31181, 31225,
    31269, 31313, 31357, 31402, 31446, 31490, 31534, 31578,
    31622, 31666, 31710, 31754, 31798, 31842, 31886, 31930,
    31974, 32017, 32061, 32105, 32149, 32193, 32236, 32280,
    32324, 32368, 32411, 32455, 32499, 32542, 32586, 32630,
    32673, 32717, 32760, 32804, 32847, 32891, 32934, 32978,
    33021, 33065, 33108, 33151, 33195, 33238, 33281, 33325,
    33368, 33411, 33454, 33498, 33541, 33584, 33627, 33670,
    33713, 33756, 33799, 33843, 33886, 33929, 33972, 34015,
    34057, 34100, 34143, 34186, 34229, 34272, 34315, 34358,
    34400, 34443, 34486, 34529, 34571, 34614, 34657, 34699,
    34742, 34785, 34827, 34870, 34912, 34955, 34997, 35040,
    35082, 35125, 35167, 35210, 35252, 35294, 35337, 35379,
    35421, 35464, 35506, 35548, 35590, 35633, 35675, 35717,
    35759, 35801, 35843, 35885, 35927, 35969, 36011, 36053,
    36095, 36137, 36179, 36221, 36263, 36305, 36347, 36388,
    36430, 36472, 36514, 36555, 36597, 36639, 36681, 36722,
    36764, 36805, 36847, 36889, 36930, 36972, 37013, 37055,
    37096, 37137, 37179, 37220, 37262, 37303, 37344, 37386,
    37427, 37468, 37509, 37551, 37592, 37633, 37674, 37715,
    37756, 37797, 37838, 37879, 37920, 37961, 38002, 38043,
    38084, 38125, 38166, 38207, 38248, 38288, 38329, 38370,
    38411, 38451, 38492, 38533, 38573, 38614, 38655, 38695,
    38736, 38776, 38817, 38857, 38898, 38938, 38979, 39019,
    39059, 39100, 39140, 39180, 39221, 39261, 39301, 39341,
    39382, 39422, 39462, 39502, 39542, 39582, 39622, 39662,
    39702, 39742, 39782, 39822, 39862, 39902, 39942, 39982,
    40021, 40061, 40101, 40141, 40180, 40220, 40260, 40300,
    40339, 40379, 40418, 40458, 40497, 40537, 40576, 40616,
    40655, 40695, 40734, 40773, 40813, 40852, 40891, 40931,
    40970, 41009, 41048, 41087, 41127, 41166, 41205, 41244,
    41283, 41322, 41361, 41400, 41439, 41478, 41517, 41556,
    41595, 41633, 41672, 41711, 41750, 41788, 41827, 41866,
    41904, 41943, 41982, 42020, 42059, 42097, 42136, 42174,
    42213, 42251, 42290, 42328, 42366, 42405, 42443, 42481,
    42520, 42558, 42596, 42634, 42672, 42711, 42749, 42787,
    42825, 42863, 42901, 42939, 42977, 43015, 43053, 43091,
    43128, 43166, 43204, 43242, 43280, 43317, 43355, 43393,
    43430, 43468, 43506, 43543, 43581, 43618, 43656, 43693,
    43731, 43768, 43806, 43843, 43880, 43918, 43955, 43992,
    44029, 44067, 44104, 44141, 44178, 44215, 44252, 44289,
    44326, 44363, 44400, 44437, 44474, 44511, 44548, 44585,
    44622, 44659, 44695, 44732, 44769, 44806, 44842, 44879,
    44915, 44952, 44989, 45025, 45062, 45098, 45135, 45171,
    45207, 45244, 45280, 45316, 45353, 45389, 45425, 45462,
    45498, 45534, 45570, 45606, 45642, 45678, 45714, 45750,
    45786, 45822, 45858, 45894, 45930, 45966, 46002, 46037,
    46073, 46109, 46145, 46180, 46216, 46252, 46287, 46323,
    46358, 46394, 46429, 46465, 46500, 46536, 46571, 46606,
    46642, 46677, 46712, 46747, 46783, 46818, 46853, 46888,
    46923, 46958, 46993, 47028, 47063, 47098, 47133, 47168,
    47203, 47238, 47273, 47308, 47342, 47377, 47412, 47446,
    47481, 47516, 47550, 47585, 47619, 47654, 47688, 47723,
    47757, 47792, 47826, 47860, 47895, 47929, 47963, 47998,
    48032, 48066, 48100, 48134, 48168, 48202, 48237, 48271,
    48305, 48338, 48372, 48406, 48440, 48474, 48508, 48542,
    48575, 48609, 48643, 48676, 48710, 48744, 48777, 48811,
    48844, 48878, 48911, 48945, 48978, 49012, 49045, 49078,
    49112, 49145, 49178, 49211, 49244, 49278, 49311, 49344,
    49377, 49410, 49443, 49476, 49509, 49542, 49575, 49608,
    49640, 49673, 49706, 49739, 49771, 49804, 49837, 49869,
    49902, 49935, 49967, 50000, 50032, 50065, 50097, 50129,
    50162, 50194, 50226, 50259, 50291, 50323, 50355, 50387,
    50420, 50452, 50484, 50516, 50548, 50580, 50612, 50644,
    50675, 50707, 50739, 50771, 50803, 50834, 50866, 50898,
    50929, 50961, 50993, 51024, 51056, 51087, 51119, 51150,
    51182, 51213, 51244, 51276, 51307, 51338, 51369, 51401,
    51432, 51463, 51494, 51525, 51556, 51587, 51618, 51649,
    51680, 51711, 51742, 51773, 51803, 51834, 51865, 51896,
    51926, 51957, 51988, 52018, 52049, 52079, 52110, 52140,
    52171, 52201, 52231, 52262, 52292, 52322, 52353, 52383,
    52413, 52443, 52473, 52503, 52534, 52564, 52594, 52624,
    52653, 52683, 52713, 52743, 52773, 52803, 52832, 52862,
    52892, 52922, 52951, 52981, 53010, 53040, 53069, 53099,
    53128, 53158, 53187, 53216, 53246, 53275, 53304, 53334,
    53363, 53392, 53421, 53450, 53479, 53508, 53537, 53566,
    53595, 53624, 53653, 53682, 53711, 53739, 53768, 53797,
    53826, 53854, 53883, 53911, 53940, 53969, 53997, 54026,
    54054, 54082, 54111, 54139, 54167, 54196, 54224, 54252,
    54280, 54308, 54337, 54365, 54393, 54421, 54449, 54477,
    54505, 54533, 54560, 54588, 54616, 54644, 54672, 54699,
    54727, 54755, 54782, 54810, 54837, 54865, 54892, 54920,
    54947, 54974, 55002, 55029, 55056, 55084, 55111, 55138,
    55165, 55192, 55219, 55246, 55274, 55300, 55327, 55354,
    55381, 55408, 55435, 55462, 55489, 55515, 55542, 55569,
    55595, 55622, 55648, 55675, 55701, 55728, 55754, 55781,
    55807, 55833, 55860, 55886, 55912, 55938, 55965, 55991,
    56017, 56043, 56069, 56095, 56121, 56147, 56173, 56199,
    56225, 56250, 56276, 56302, 56328, 56353, 56379, 56404,
    56430, 56456, 56481, 56507, 56532, 56557, 56583, 56608,
    56633, 56659, 56684, 56709, 56734, 56760, 56785, 56810,
    56835, 56860, 56885, 56910, 56935, 56959, 56984, 57009,
    57034, 57059, 57083, 57108, 57133, 57157, 57182, 57206,
    57231, 57255, 57280, 57304, 57329, 57353, 57377, 57402,
    57426, 57450, 57474, 57498, 57522, 57546, 57570, 57594,
    57618, 57642, 57666, 57690, 57714, 57738, 57762, 57785,
    57809, 57833, 57856, 57880, 57903, 57927, 57950, 57974,
    57997, 58021, 58044, 58067, 58091, 58114, 58137, 58160,
    58183, 58207, 58230, 58253, 58276, 58299, 58322, 58345,
    58367, 58390, 58413, 58436, 58459, 58481, 58504, 58527,
    58549, 58572, 58594, 58617, 58639, 58662, 58684, 58706,
    58729, 58751, 58773, 58795, 58818, 58840, 58862, 58884,
    58906, 58928, 58950, 58972, 58994, 59016, 59038, 59059,
    59081, 59103, 59125, 59146, 59168, 59190, 59211, 59233,
    59254, 59276, 59297, 59318, 59340, 59361, 59382, 59404,
    59425, 59446, 59467, 59488, 59509, 59530, 59551, 59572,
    59593, 59614, 59635, 59656, 59677, 59697, 59718, 59739,
    59759, 59780, 59801, 59821, 59842, 59862, 59883, 59903,
    59923, 59944, 59964, 59984, 60004, 60025, 60045, 60065,
    60085, 60105, 60125, 60145, 60165, 60185, 60205, 60225,
    60244, 60264, 60284, 60304, 60323, 60343, 60363, 60382,
    60402, 60421, 60441, 60460, 60479, 60499, 60518, 60537,
    60556, 60576, 60595, 60614, 60633, 60652, 60671, 60690,
    60709, 60728, 60747, 60766, 60785, 60803, 60822, 60841,
    60859, 60878, 60897, 60915, 60934, 60952, 60971, 60989,
    61007, 61026, 61044, 61062, 61081, 61099, 61117, 61135,
    61153, 61171, 61189, 61207, 61225, 61243, 61261, 61279,
    61297, 61314, 61332, 61350, 61367, 61385, 61403, 61420,
    61438, 61455, 61473, 61490, 61507, 61525, 61542, 61559,
    61577, 61594, 61611, 61628, 61645, 61662, 61679, 61696,
    61713, 61730, 61747, 61764, 61780, 61797, 61814, 61831,
    61847, 61864, 61880, 61897, 61913, 61930, 61946, 61963,
    61979, 61995, 62012, 62028, 62044, 62060, 62076, 62092,
    62108, 62125, 62141, 62156, 62172, 62188, 62204, 62220,
    62236, 62251, 62267, 62283, 62298, 62314, 62329, 62345,
    62360, 62376, 62391, 62407, 62422, 62437, 62453, 62468,
    62483, 62498, 62513, 62528, 62543, 62558, 62573, 62588,
    62603, 62618, 62633, 62648, 62662, 62677, 62692, 62706,
    62721, 62735, 62750, 62764, 62779, 62793, 62808, 62822,
    62836, 62850, 62865, 62879, 62893, 62907, 62921, 62935,
    62949, 62963, 62977, 62991, 63005, 63019, 63032, 63046,
    63060, 63074, 63087, 63101, 63114, 63128, 63141, 63155,
    63168, 63182, 63195, 63208, 63221, 63235, 63248, 63261,
    63274, 63287, 63300, 63313, 63326, 63339, 63352, 63365,
    63378, 63390, 63403, 63416, 63429, 63441, 63454, 63466,
    63479, 63491, 63504, 63516, 63528, 63541, 63553, 63565,
    63578, 63590, 63602, 63614, 63626, 63638, 63650, 63662,
    63674, 63686, 63698, 63709, 63721, 63733, 63745, 63756,
    63768, 63779, 63791, 63803, 63814, 63825, 63837, 63848,
    63859, 63871, 63882, 63893, 63904, 63915, 63927, 63938,
    63949, 63960, 63971, 63981, 63992, 64003, 64014, 64025,
    64035, 64046, 64057, 64067, 64078, 64088, 64099, 64109,
    64120, 64130, 64140, 64151, 64161, 64171, 64181, 64192,
    64202, 64212, 64222, 64232, 64242, 64252, 64261, 64271,
    64281, 64291, 64301, 64310, 64320, 64330, 64339, 64349,
    64358, 64368, 64377, 64387, 64396, 64405, 64414, 64424,
    64433, 64442, 64451, 64460, 64469, 64478, 64487, 64496,
    64505, 64514, 64523, 64532, 64540, 64549, 64558, 64566,
    64575, 64584, 64592, 64601, 64609, 64617, 64626, 64634,
    64642, 64651, 64659, 64667, 64675, 64683, 64691, 64699,
    64707, 64715, 64723, 64731, 64739, 64747, 64754, 64762,
    64770, 64777, 64785, 64793, 64800, 64808, 64815, 64822,
    64830, 64837, 64844, 64852, 64859, 64866, 64873, 64880,
    64887, 64895, 64902, 64908, 64915, 64922, 64929, 64936,
    64943, 64949, 64956, 64963, 64969, 64976, 64982, 64989,
    64995, 65002, 65008, 65015, 65021, 65027, 65033, 65040,
    65046, 65052, 65058, 65064, 65070, 65076, 65082, 65088,
    65094, 65099, 65105, 65111, 65117, 65122, 65128, 65133,
    65139, 65144, 65150, 65155, 65161, 65166, 65171, 65177,
    65182, 65187, 65192, 65197, 65202, 65207, 65212, 65217,
    65222, 65227, 65232, 65237, 65242, 65246, 65251, 65256,
    65260, 65265, 65270, 65274, 65279, 65283, 65287, 65292,
    65296, 65300, 65305, 65309, 65313, 65317, 65321, 65325,
    65329, 65333, 65337, 65341, 65345, 65349, 65352, 65356,
    65360, 65363, 65367, 65371, 65374, 65378, 65381, 65385,
    65388, 65391, 65395, 65398, 65401, 65404, 65408, 65411,
    65414, 65417, 65420, 65423, 65426, 65429, 65431, 65434,
    65437, 65440, 65442, 65445, 65448, 65450, 65453, 65455,
    65458, 65460, 65463, 65465, 65467, 65470, 65472, 65474,
    65476, 65478, 65480, 65482, 65484, 65486, 65488, 65490,
    65492, 65494, 65496, 65497, 65499, 65501, 65502, 65504,
    65505, 65507, 65508, 65510, 65511, 65513, 65514, 65515,
    65516, 65518, 65519, 65520, 65521, 65522, 65523, 65524,
    65525, 65526, 65527, 65527, 65528, 65529, 65530, 65530,
    65531, 65531, 65532, 65532, 65533, 65533, 65534, 65534,
    65534, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
    65535, 65535, 65535, 65535, 65535, 65535, 65535, 65534,
    65534, 65534, 65533, 65533, 65532, 65532, 65531, 65531,
    65530, 65530, 65529, 65528, 65527, 65527, 65526, 65525,
    65524, 65523, 65522, 65521, 65520, 65519, 65518, 65516,
    65515, 65514, 65513, 65511, 65510, 65508, 65507, 65505,
    65504, 65502, 65501, 65499, 65497, 65496, 65494, 65492,
    65490, 65488, 65486, 65484, 65482, 65480, 65478, 65476,
    65474, 65472, 65470, 65467, 65465, 65463, 65460, 65458,
    65455, 65453, 65450, 65448, 65445, 65442, 65440, 65437,
    65434, 65431, 65429, 65426, 65423, 65420, 65417, 65414,
    65411, 65408, 65404, 65401, 65398, 65395, 65391, 65388,
    65385, 65381, 65378, 65374, 65371, 65367, 65363, 65360,
    65356, 65352, 65349, 65345, 65341, 65337, 65333, 65329,
    65325, 65321, 65317, 65313, 65309, 65305, 65300, 65296,
    65292, 65287, 65283, 65279, 65274, 65270, 65265, 65260,
    65256, 65251, 65246, 65242, 65237, 65232, 65227, 65222,
    65217, 65212, 65207, 65202, 65197, 65192, 65187, 65182,
    65177, 65171, 65166, 65161, 65155, 65150, 65144, 65139,
    65133, 65128, 65122, 65117, 65111, 65105, 65099, 65094,
    65088, 65082, 65076, 65070, 65064, 65058, 65052, 65046,
    65040, 65033, 65027, 65021, 65015, 65008, 65002, 64995,
    64989, 64982, 64976, 64969, 64963, 64956, 64949, 64943,
    64936, 64929, 64922, 64915, 64908, 64902, 64895, 64887,
    64880, 64873, 64866, 64859, 64852, 64844, 64837, 64830,
    64822, 64815, 64808, 64800, 64793, 64785, 64777, 64770,
    64762, 64754, 64747, 64739, 64731, 64723, 64715, 64707,
    64699, 64691, 64683, 64675, 64667, 64659, 64651, 64642,
    64634, 64626, 64617, 64609, 64600, 64592, 64584, 64575,
    64566, 64558, 64549, 64540, 64532, 64523, 64514, 64505,
    64496, 64487, 64478, 64469, 64460, 64451, 64442, 64433,
    64424, 64414, 64405, 64396, 64387, 64377, 64368, 64358,
    64349, 64339, 64330, 64320, 64310, 64301, 64291, 64281,
    64271, 64261, 64252, 64242, 64232, 64222, 64212, 64202,
    64192, 64181, 64171, 64161, 64151, 64140, 64130, 64120,
    64109, 64099, 64088, 64078, 64067, 64057, 64046, 64035,
    64025, 64014, 64003, 63992, 63981, 63971, 63960, 63949,
    63938, 63927, 63915, 63904, 63893, 63882, 63871, 63859,
    63848, 63837, 63825, 63814, 63803, 63791, 63779, 63768,
    63756, 63745, 63733, 63721, 63709, 63698, 63686, 63674,
    63662, 63650, 63638, 63626, 63614, 63602, 63590, 63578,
    63565, 63553, 63541, 63528, 63516, 63504, 63491, 63479,
    63466, 63454, 63441, 63429, 63416, 63403, 63390, 63378,
    63365, 63352, 63339, 63326, 63313, 63300, 63287, 63274,
    63261, 63248, 63235, 63221, 63208, 63195, 63182, 63168,
    63155, 63141, 63128, 63114, 63101, 63087, 63074, 63060,
    63046, 63032, 63019, 63005, 62991, 62977, 62963, 62949,
    62935, 62921, 62907, 62893, 62879, 62865, 62850, 62836,
    62822, 62808, 62793, 62779, 62764, 62750, 62735, 62721,
    62706, 62692, 62677, 62662, 62648, 62633, 62618, 62603,
    62588, 62573, 62558, 62543, 62528, 62513, 62498, 62483,
    62468, 62453, 62437, 62422, 62407, 62391, 62376, 62360,
    62345, 62329, 62314, 62298, 62283, 62267, 62251, 62236,
    62220, 62204, 62188, 62172, 62156, 62141, 62125, 62108,
    62092, 62076, 62060, 62044, 62028, 62012, 61995, 61979,
    61963, 61946, 61930, 61913, 61897, 61880, 61864, 61847,
    61831, 61814, 61797, 61780, 61764, 61747, 61730, 61713,
    61696, 61679, 61662, 61645, 61628, 61611, 61594, 61577,
    61559, 61542, 61525, 61507, 61490, 61473, 61455, 61438,
    61420, 61403, 61385, 61367, 61350, 61332, 61314, 61297,
    61279, 61261, 61243, 61225, 61207, 61189, 61171, 61153,
    61135, 61117, 61099, 61081, 61062, 61044, 61026, 61007,
    60989, 60971, 60952, 60934, 60915, 60897, 60878, 60859,
    60841, 60822, 60803, 60785, 60766, 60747, 60728, 60709,
    60690, 60671, 60652, 60633, 60614, 60595, 60576, 60556,
    60537, 60518, 60499, 60479, 60460, 60441, 60421, 60402,
    60382, 60363, 60343, 60323, 60304, 60284, 60264, 60244,
    60225, 60205, 60185, 60165, 60145, 60125, 60105, 60085,
    60065, 60045, 60025, 60004, 59984, 59964, 59944, 59923,
    59903, 59883, 59862, 59842, 59821, 59801, 59780, 59759,
    59739, 59718, 59697, 59677, 59656, 59635, 59614, 59593,
    59572, 59551, 59530, 59509, 59488, 59467, 59446, 59425,
    59404, 59382, 59361, 59340, 59318, 59297, 59276, 59254,
    59233, 59211, 59190, 59168, 59146, 59125, 59103, 59081,
    59059, 59038, 59016, 58994, 58972, 58950, 58928, 58906,
    58884, 58862, 58840, 58818, 58795, 58773, 58751, 58729,
    58706, 58684, 58662, 58639, 58617, 58594, 58572, 58549,
    58527, 58504, 58481, 58459, 58436, 58413, 58390, 58367,
    58345, 58322, 58299, 58276, 58253, 58230, 58207, 58183,
    58160, 58137, 58114, 58091, 58067, 58044, 58021, 57997,
    57974, 57950, 57927, 57903, 57880, 57856, 57833, 57809,
    57785, 57762, 57738, 57714, 57690, 57666, 57642, 57618,
    57594, 57570, 57546, 57522, 57498, 57474, 57450, 57426,
    57402, 57377, 57353, 57329, 57304, 57280, 57255, 57231,
    57206, 57182, 57157, 57133, 57108, 57083, 57059, 57034,
    57009, 56984, 56959, 56935, 56910, 56885, 56860, 56835,
    56810, 56785, 56760, 56734, 56709, 56684, 56659, 56633,
    56608, 56583, 56557, 56532, 56507, 56481, 56456, 56430,
    56404, 56379, 56353, 56328, 56302, 56276, 56250, 56225,
    56199, 56173, 56147, 56121, 56095, 56069, 56043, 56017,
    55991, 55965, 55938, 55912, 55886, 55860, 55833, 55807,
    55781, 55754, 55728, 55701, 55675, 55648, 55622, 55595,
    55569, 55542, 55515, 55489, 55462, 55435, 55408, 55381,
    55354, 55327, 55300, 55274, 55246, 55219, 55192, 55165,
    55138, 55111, 55084, 55056, 55029, 55002, 54974, 54947,
    54920, 54892, 54865, 54837, 54810, 54782, 54755, 54727,
    54699, 54672, 54644, 54616, 54588, 54560, 54533, 54505,
    54477, 54449, 54421, 54393, 54365, 54337, 54308, 54280,
    54252, 54224, 54196, 54167, 54139, 54111, 54082, 54054,
    54026, 53997, 53969, 53940, 53911, 53883, 53854, 53826,
    53797, 53768, 53739, 53711, 53682, 53653, 53624, 53595,
    53566, 53537, 53508, 53479, 53450, 53421, 53392, 53363,
    53334, 53304, 53275, 53246, 53216, 53187, 53158, 53128,
    53099, 53069, 53040, 53010, 52981, 52951, 52922, 52892,
    52862, 52832, 52803, 52773, 52743, 52713, 52683, 52653,
    52624, 52594, 52564, 52534, 52503, 52473, 52443, 52413,
    52383, 52353, 52322, 52292, 52262, 52231, 52201, 52171,
    52140, 52110, 52079, 52049, 52018, 51988, 51957, 51926,
    51896, 51865, 51834, 51803, 51773, 51742, 51711, 51680,
    51649, 51618, 51587, 51556, 51525, 51494, 51463, 51432,
    51401, 51369, 51338, 51307, 51276, 51244, 51213, 51182,
    51150, 51119, 51087, 51056, 51024, 50993, 50961, 50929,
    50898, 50866, 50834, 50803, 50771, 50739, 50707, 50675,
    50644, 50612, 50580, 50548, 50516, 50484, 50452, 50420,
    50387, 50355, 50323, 50291, 50259, 50226, 50194, 50162,
    50129, 50097, 50065, 50032, 50000, 49967, 49935, 49902,
    49869, 49837, 49804, 49771, 49739, 49706, 49673, 49640,
    49608, 49575, 49542, 49509, 49476, 49443, 49410, 49377,
    49344, 49311, 49278, 49244, 49211, 49178, 49145, 49112,
    49078, 49045, 49012, 48978, 48945, 48911, 48878, 48844,
    48811, 48777, 48744, 48710, 48676, 48643, 48609, 48575,
    48542, 48508, 48474, 48440, 48406, 48372, 48338, 48304,
    48271, 48237, 48202, 48168, 48134, 48100, 48066, 48032,
    47998, 47963, 47929, 47895, 47860, 47826, 47792, 47757,
    47723, 47688, 47654, 47619, 47585, 47550, 47516, 47481,
    47446, 47412, 47377, 47342, 47308, 47273, 47238, 47203,
    47168, 47133, 47098, 47063, 47028, 46993, 46958, 46923,
    46888, 46853, 46818, 46783, 46747, 46712, 46677, 46642,
    46606, 46571, 46536, 46500, 46465, 46429, 46394, 46358,
    46323, 46287, 46252, 46216, 46180, 46145, 46109, 46073,
    46037, 46002, 45966, 45930, 45894, 45858, 45822, 45786,
    45750, 45714, 45678, 45642, 45606, 45570, 45534, 45498,
    45462, 45425, 45389, 45353, 45316, 45280, 45244, 45207,
    45171, 45135, 45098, 45062, 45025, 44989, 44952, 44915,
    44879, 44842, 44806, 44769, 44732, 44695, 44659, 44622,
    44585, 44548, 44511, 44474, 44437, 44400, 44363, 44326,
    44289, 44252, 44215, 44178, 44141, 44104, 44067, 44029,
    43992, 43955, 43918, 43880, 43843, 43806, 43768, 43731,
    43693, 43656, 43618, 43581, 43543, 43506, 43468, 43430,
    43393, 43355, 43317, 43280, 43242, 43204, 43166, 43128,
    43091, 43053, 43015, 42977, 42939, 42901, 42863, 42825,
    42787, 42749, 42711, 42672, 42634, 42596, 42558, 42520,
    42481, 42443, 42405, 42366, 42328, 42290, 42251, 42213,
    42174, 42136, 42097, 42059, 42020, 41982, 41943, 41904,
    41866, 41827, 41788, 41750, 41711, 41672, 41633, 41595,
    41556, 41517, 41478, 41439, 41400, 41361, 41322, 41283,
    41244, 41205, 41166, 41127, 41088, 41048, 41009, 40970,
    40931, 40891, 40852, 40813, 40773, 40734, 40695, 40655,
    40616, 40576, 40537, 40497, 40458, 40418, 40379, 40339,
    40300, 40260, 40220, 40180, 40141, 40101, 40061, 40021,
    39982, 39942, 39902, 39862, 39822, 39782, 39742, 39702,
    39662, 39622, 39582, 39542, 39502, 39462, 39422, 39382,
    39341, 39301, 39261, 39221, 39180, 39140, 39100, 39059,
    39019, 38979, 38938, 38898, 38857, 38817, 38776, 38736,
    38695, 38655, 38614, 38573, 38533, 38492, 38451, 38411,
    38370, 38329, 38288, 38248, 38207, 38166, 38125, 38084,
    38043, 38002, 37961, 37920, 37879, 37838, 37797, 37756,
    37715, 37674, 37633, 37592, 37551, 37509, 37468, 37427,
    37386, 37344, 37303, 37262, 37220, 37179, 37137, 37096,
    37055, 37013, 36972, 36930, 36889, 36847, 36805, 36764,
    36722, 36681, 36639, 36597, 36556, 36514, 36472, 36430,
    36388, 36347, 36305, 36263, 36221, 36179, 36137, 36095,
    36053, 36011, 35969, 35927, 35885, 35843, 35801, 35759,
    35717, 35675, 35633, 35590, 35548, 35506, 35464, 35421,
    35379, 35337, 35294, 35252, 35210, 35167, 35125, 35082,
    35040, 34997, 34955, 34912, 34870, 34827, 34785, 34742,
    34699, 34657, 34614, 34571, 34529, 34486, 34443, 34400,
    34358, 34315, 34272, 34229, 34186, 34143, 34100, 34057,
    34015, 33972, 33929, 33886, 33843, 33799, 33756, 33713,
    33670, 33627, 33584, 33541, 33498, 33454, 33411, 33368,
    33325, 33281, 33238, 33195, 33151, 33108, 33065, 33021,
    32978, 32934, 32891, 32847, 32804, 32760, 32717, 32673,
    32630, 32586, 32542, 32499, 32455, 32411, 32368, 32324,
    32280, 32236, 32193, 32149, 32105, 32061, 32017, 31974,
    31930, 31886, 31842, 31798, 31754, 31710, 31666, 31622,
    31578, 31534, 31490, 31446, 31402, 31357, 31313, 31269,
    31225, 31181, 31136, 31092, 31048, 31004, 30959, 30915,
    30871, 30826, 30782, 30738, 30693, 30649, 30604, 30560,
    30515, 30471, 30426, 30382, 30337, 30293, 30248, 30204,
    30159, 30114, 30070, 30025, 29980, 29936, 29891, 29846,
    29801, 29757, 29712, 29667, 29622, 29577, 29533, 29488,
    29443, 29398, 29353, 29308, 29263, 29218, 29173, 29128,
    29083, 29038, 28993, 28948, 28903, 28858, 28812, 28767,
    28722, 28677, 28632, 28586, 28541, 28496, 28451, 28405,
    28360, 28315, 28269, 28224, 28179, 28133, 28088, 28042,
    27997, 27952, 27906, 27861, 27815, 27770, 27724, 27678,
    27633, 27587, 27542, 27496, 27450, 27405, 27359, 27313,
    27268, 27222, 27176, 27131, 27085, 27039, 26993, 26947,
    26902, 26856, 26810, 26764, 26718, 26672, 26626, 26580,
    26534, 26488, 26442, 26396, 26350, 26304, 26258, 26212,
    26166, 26120, 26074, 26028, 25982, 25936, 25889, 25843,
    25797, 25751, 25705, 25658, 25612, 25566, 25520, 25473,
    25427, 25381, 25334, 25288, 25241, 25195, 25149, 25102,
    25056, 25009, 24963, 24916, 24870, 24823, 24777, 24730,
    24684, 24637, 24591, 24544, 24497, 24451, 24404, 24357,
    24311, 24264, 24217, 24171, 24124, 24077, 24030, 23984,
    23937, 23890, 23843, 23796, 23750, 23703, 23656, 23609,
    23562, 23515, 23468, 23421, 23374, 23327, 23280, 23233,
    23186, 23139, 23092, 23045, 22998, 22951, 22904, 22857,
    22810, 22763, 22716, 22668, 22621, 22574, 22527, 22480,
    22433, 22385, 22338, 22291, 22243, 22196, 22149, 22102,
    22054, 22007, 21960, 21912, 21865, 21817, 21770, 21723,
    21675, 21628, 21580, 21533, 21485, 21438, 21390, 21343,
    21295, 21248, 21200, 21153, 21105, 21057, 21010, 20962,
    20915, 20867, 20819, 20772, 20724, 20676, 20629, 20581,
    20533, 20485, 20438, 20390, 20342, 20294, 20246, 20199,
    20151, 20103, 20055, 20007, 19959, 19912, 19864, 19816,
    19768, 19720, 19672, 19624, 19576, 19528, 19480, 19432,
    19384, 19336, 19288, 19240, 19192, 19144, 19096, 19048,
    19000, 18951, 18903, 18855, 18807, 18759, 18711, 18663,
    18614, 18566, 18518, 18470, 18421, 18373, 18325, 18277,
    18228, 18180, 18132, 18084, 18035, 17987, 17939, 17890,
    17842, 17793, 17745, 17697, 17648, 17600, 17551, 17503,
    17455, 17406, 17358, 17309, 17261, 17212, 17164, 17115,
    17067, 17018, 16970, 16921, 16872, 16824, 16775, 16727,
    16678, 16629, 16581, 16532, 16484, 16435, 16386, 16338,
    16289, 16240, 16191, 16143, 16094, 16045, 15997, 15948,
    15899, 15850, 15802, 15753, 15704, 15655, 15606, 15557,
    15509, 15460, 15411, 15362, 15313, 15264, 15215, 15167,
    15118, 15069, 15020, 14971, 14922, 14873, 14824, 14775,
    14726, 14677, 14628, 14579, 14530, 14481, 14432, 14383,
    14334, 14285, 14236, 14187, 14138, 14089, 14040, 13990,
    13941, 13892, 13843, 13794, 13745, 13696, 13646, 13597,
    13548, 13499, 13450, 13401, 13351, 13302, 13253, 13204,
    13154, 13105, 13056, 13007, 12957, 12908, 12859, 12810,
    12760, 12711, 12662, 12612, 12563, 12514, 12464, 12415,
    12366, 12316, 12267, 12218, 12168, 12119, 12069, 12020,
    11970, 11921, 11872, 11822, 11773, 11723, 11674, 11624,
    11575, 11525, 11476, 11426, 11377, 11327, 11278, 11228,
    11179, 11129, 11080, 11030, 10981, 10931, 10882, 10832,
    10782, 10733, 10683, 10634, 10584, 10534, 10485, 10435,
    10386, 10336, 10286, 10237, 10187, 10137, 10088, 10038,
    9988, 9939, 9889, 9839, 9790, 9740, 9690, 9640,
    9591, 9541, 9491, 9442, 9392, 9342, 9292, 9243,
    9193, 9143, 9093, 9043, 8994, 8944, 8894, 8844,
    8794, 8745, 8695, 8645, 8595, 8545, 8496, 8446,
    8396, 8346, 8296, 8246, 8196, 8147, 8097, 8047,
    7997, 7947, 7897, 7847, 7797, 7747, 7697, 7648,
    7598, 7548, 7498, 7448, 7398, 7348, 7298, 7248,
    7198, 7148, 7098, 7048, 6998, 6948, 6898, 6848,
    6798, 6748, 6698, 6648, 6598, 6548, 6498, 6448,
    6398, 6348, 6298, 6248, 6198, 6148, 6098, 6048,
    5998, 5948, 5898, 5848, 5798, 5748, 5697, 5647,
    5597, 5547, 5497, 5447, 5397, 5347, 5297, 5247,
    5197, 5146, 5096, 5046, 4996, 4946, 4896, 4846,
    4796, 4745, 4695, 4645, 4595, 4545, 4495, 4445,
    4394, 4344, 4294, 4244, 4194, 4144, 4093, 4043,
    3993, 3943, 3893, 3843, 3792, 3742, 3692, 3642,
    3592, 3541, 3491, 3441, 3391, 3341, 3291, 3240,
    3190, 3140, 3090, 3039, 2989, 2939, 2889, 2839,
    2788, 2738, 2688, 2638, 2587, 2537, 2487, 2437,
    2387, 2336, 2286, 2236, 2186, 2135, 2085, 2035,
    1985, 1934, 1884, 1834, 1784, 1733, 1683, 1633,
    1583, 1532, 1482, 1432, 1382, 1331, 1281, 1231,
    1181, 1130, 1080, 1030, 980, 929, 879, 829,
    779, 728, 678, 628, 578, 527, 477, 427,
    376, 326, 276, 226, 175, 125, 75, 25,
    -25, -75, -125, -175, -226, -276, -326, -376,
    -427, -477, -527, -578, -628, -678, -728, -779,
    -829, -879, -929, -980, -1030, -1080, -1130, -1181,
    -1231, -1281, -1331, -1382, -1432, -1482, -1532, -1583,
    -1633, -1683, -1733, -1784, -1834, -1884, -1934, -1985,
    -2035, -2085, -2135, -2186, -2236, -2286, -2336, -2387,
    -2437, -2487, -2537, -2588, -2638, -2688, -2738, -2788,
    -2839, -2889, -2939, -2989, -3039, -3090, -3140, -3190,
    -3240, -3291, -3341, -3391, -3441, -3491, -3541, -3592,
    -3642, -3692, -3742, -3792, -3843, -3893, -3943, -3993,
    -4043, -4093, -4144, -4194, -4244, -4294, -4344, -4394,
    -4445, -4495, -4545, -4595, -4645, -4695, -4745, -4796,
    -4846, -4896, -4946, -4996, -5046, -5096, -5146, -5197,
    -5247, -5297, -5347, -5397, -5447, -5497, -5547, -5597,
    -5647, -5697, -5748, -5798, -5848, -5898, -5948, -5998,
    -6048, -6098, -6148, -6198, -6248, -6298, -6348, -6398,
    -6448, -6498, -6548, -6598, -6648, -6698, -6748, -6798,
    -6848, -6898, -6948, -6998, -7048, -7098, -7148, -7198,
    -7248, -7298, -7348, -7398, -7448, -7498, -7548, -7598,
    -7648, -7697, -7747, -7797, -7847, -7897, -7947, -7997,
    -8047, -8097, -8147, -8196, -8246, -8296, -8346, -8396,
    -8446, -8496, -8545, -8595, -8645, -8695, -8745, -8794,
    -8844, -8894, -8944, -8994, -9043, -9093, -9143, -9193,
    -9243, -9292, -9342, -9392, -9442, -9491, -9541, -9591,
    -9640, -9690, -9740, -9790, -9839, -9889, -9939, -9988,
    -10038, -10088, -10137, -10187, -10237, -10286, -10336, -10386,
    -10435, -10485, -10534, -10584, -10634, -10683, -10733, -10782,
    -10832, -10882, -10931, -10981, -11030, -11080, -11129, -11179,
    -11228, -11278, -11327, -11377, -11426, -11476, -11525, -11575,
    -11624, -11674, -11723, -11773, -11822, -11872, -11921, -11970,
    -12020, -12069, -12119, -12168, -12218, -12267, -12316, -12366,
    -12415, -12464, -12514, -12563, -12612, -12662, -12711, -12760,
    -12810, -12859, -12908, -12957, -13007, -13056, -13105, -13154,
    -13204, -13253, -13302, -13351, -13401, -13450, -13499, -13548,
    -13597, -13647, -13696, -13745, -13794, -13843, -13892, -13941,
    -13990, -14040, -14089, -14138, -14187, -14236, -14285, -14334,
    -14383, -14432, -14481, -14530, -14579, -14628, -14677, -14726,
    -14775, -14824, -14873, -14922, -14971, -15020, -15069, -15118,
    -15167, -15215, -15264, -15313, -15362, -15411, -15460, -15509,
    -15557, -15606, -15655, -15704, -15753, -15802, -15850, -15899,
    -15948, -15997, -16045, -16094, -16143, -16191, -16240, -16289,
    -16338, -16386, -16435, -16484, -16532, -16581, -16629, -16678,
    -16727, -16775, -16824, -16872, -16921, -16970, -17018, -17067,
    -17115, -17164, -17212, -17261, -17309, -17358, -17406, -17455,
    -17503, -17551, -17600, -17648, -17697, -17745, -17793, -17842,
    -17890, -17939, -17987, -18035, -18084, -18132, -18180, -18228,
    -18277, -18325, -18373, -18421, -18470, -18518, -18566, -18614,
    -18663, -18711, -18759, -18807, -18855, -18903, -18951, -19000,
    -19048, -19096, -19144, -19192, -19240, -19288, -19336, -19384,
    -19432, -19480, -19528, -19576, -19624, -19672, -19720, -19768,
    -19816, -19864, -19912, -19959, -20007, -20055, -20103, -20151,
    -20199, -20246, -20294, -20342, -20390, -20438, -20485, -20533,
    -20581, -20629, -20676, -20724, -20772, -20819, -20867, -20915,
    -20962, -21010, -21057, -21105, -21153, -21200, -21248, -21295,
    -21343, -21390, -21438, -21485, -21533, -21580, -21628, -21675,
    -21723, -21770, -21817, -21865, -21912, -21960, -22007, -22054,
    -22102, -22149, -22196, -22243, -22291, -22338, -22385, -22433,
    -22480, -22527, -22574, -22621, -22668, -22716, -22763, -22810,
    -22857, -22904, -22951, -22998, -23045, -23092, -23139, -23186,
    -23233, -23280, -23327, -23374, -23421, -23468, -23515, -23562,
    -23609, -23656, -23703, -23750, -23796, -23843, -23890, -23937,
    -23984, -24030, -24077, -24124, -24171, -24217, -24264, -24311,
    -24357, -24404, -24451, -24497, -24544, -24591, -24637, -24684,
    -24730, -24777, -24823, -24870, -24916, -24963, -25009, -25056,
    -25102, -25149, -25195, -25241, -25288, -25334, -25381, -25427,
    -25473, -25520, -25566, -25612, -25658, -25705, -25751, -25797,
    -25843, -25889, -25936, -25982, -26028, -26074, -26120, -26166,
    -26212, -26258, -26304, -26350, -26396, -26442, -26488, -26534,
    -26580, -26626, -26672, -26718, -26764, -26810, -26856, -26902,
    -26947, -26993, -27039, -27085, -27131, -27176, -27222, -27268,
    -27313, -27359, -27405, -27450, -27496, -27542, -27587, -27633,
    -27678, -27724, -27770, -27815, -27861, -27906, -27952, -27997,
    -28042, -28088, -28133, -28179, -28224, -28269, -28315, -28360,
    -28405, -28451, -28496, -28541, -28586, -28632, -28677, -28722,
    -28767, -28812, -28858, -28903, -28948, -28993, -29038, -29083,
    -29128, -29173, -29218, -29263, -29308, -29353, -29398, -29443,
    -29488, -29533, -29577, -29622, -29667, -29712, -29757, -29801,
    -29846, -29891, -29936, -29980, -30025, -30070, -30114, -30159,
    -30204, -30248, -30293, -30337, -30382, -30426, -30471, -30515,
    -30560, -30604, -30649, -30693, -30738, -30782, -30826, -30871,
    -30915, -30959, -31004, -31048, -31092, -31136, -31181, -31225,
    -31269, -31313, -31357, -31402, -31446, -31490, -31534, -31578,
    -31622, -31666, -31710, -31754, -31798, -31842, -31886, -31930,
    -31974, -32017, -32061, -32105, -32149, -32193, -32236, -32280,
    -32324, -32368, -32411, -32455, -32499, -32542, -32586, -32630,
    -32673, -32717, -32760, -32804, -32847, -32891, -32934, -32978,
    -33021, -33065, -33108, -33151, -33195, -33238, -33281, -33325,
    -33368, -33411, -33454, -33498, -33541, -33584, -33627, -33670,
    -33713, -33756, -33799, -33843, -33886, -33929, -33972, -34015,
    -34057, -34100, -34143, -34186, -34229, -34272, -34315, -34358,
    -34400, -34443, -34486, -34529, -34571, -34614, -34657, -34699,
    -34742, -34785, -34827, -34870, -34912, -34955, -34997, -35040,
    -35082, -35125, -35167, -35210, -35252, -35294, -35337, -35379,
    -35421, -35464, -35506, -35548, -35590, -35633, -35675, -35717,
    -35759, -35801, -35843, -35885, -35927, -35969, -36011, -36053,
    -36095, -36137, -36179, -36221, -36263, -36305, -36347, -36388,
    -36430, -36472, -36514, -36555, -36597, -36639, -36681, -36722,
    -36764, -36805, -36847, -36889, -36930, -36972, -37013, -37055,
    -37096, -37137, -37179, -37220, -37262, -37303, -37344, -37386,
    -37427, -37468, -37509, -37551, -37592, -37633, -37674, -37715,
    -37756, -37797, -37838, -37879, -37920, -37961, -38002, -38043,
    -38084, -38125, -38166, -38207, -38248, -38288, -38329, -38370,
    -38411, -38451, -38492, -38533, -38573, -38614, -38655, -38695,
    -38736, -38776, -38817, -38857, -38898, -38938, -38979, -39019,
    -39059, -39100, -39140, -39180, -39221, -39261, -39301, -39341,
    -39382, -39422, -39462, -39502, -39542, -39582, -39622, -39662,
    -39702, -39742, -39782, -39822, -39862, -39902, -39942, -39982,
    -40021, -40061, -40101, -40141, -40180, -40220, -40260, -40299,
    -40339, -40379, -40418, -40458, -40497, -40537, -40576, -40616,
    -40655, -40695, -40734, -40773, -40813, -40852, -40891, -40931,
    -40970, -41009, -41048, -41087, -41127, -41166, -41205, -41244,
    -41283, -41322, -41361, -41400, -41439, -41478, -41517, -41556,
    -41595, -41633, -41672, -41711, -41750, -41788, -41827, -41866,
    -41904, -41943, -41982, -42020, -42059, -42097, -42136, -42174,
    -42213, -42251, -42290, -42328, -42366, -42405, -42443, -42481,
    -42520, -42558, -42596, -42634, -42672, -42711, -42749, -42787,
    -42825, -42863, -42901, -42939, -42977, -43015, -43053, -43091,
    -43128, -43166, -43204, -43242, -43280, -43317, -43355, -43393,
    -43430, -43468, -43506, -43543, -43581, -43618, -43656, -43693,
    -43731, -43768, -43806, -43843, -43880, -43918, -43955, -43992,
    -44029, -44067, -44104, -44141, -44178, -44215, -44252, -44289,
    -44326, -44363, -44400, -44437, -44474, -44511, -44548, -44585,
    -44622, -44659, -44695, -44732, -44769, -44806, -44842, -44879,
    -44915, -44952, -44989, -45025, -45062, -45098, -45135, -45171,
    -45207, -45244, -45280, -45316, -45353, -45389, -45425, -45462,
    -45498, -45534, -45570, -45606, -45642, -45678, -45714, -45750,
    -45786, -45822, -45858, -45894, -45930, -45966, -46002, -46037,
    -46073, -46109, -46145, -46180, -46216, -46252, -46287, -46323,
    -46358, -46394, -46429, -46465, -46500, -46536, -46571, -46606,
    -46642, -46677, -46712, -46747, -46783, -46818, -46853, -46888,
    -46923, -46958, -46993, -47028, -47063, -47098, -47133, -47168,
    -47203, -47238, -47273, -47308, -47342, -47377, -47412, -47446,
    -47481, -47516, -47550, -47585, -47619, -47654, -47688, -47723,
    -47757, -47792, -47826, -47860, -47895, -47929, -47963, -47998,
    -48032, -48066, -48100, -48134, -48168, -48202, -48236, -48271,
    -48304, -48338, -48372, -48406, -48440, -48474, -48508, -48542,
    -48575, -48609, -48643, -48676, -48710, -48744, -48777, -48811,
    -48844, -48878, -48911, -48945, -48978, -49012, -49045, -49078,
    -49112, -49145, -49178, -49211, -49244, -49278, -49311, -49344,
    -49377, -49410, -49443, -49476, -49509, -49542, -49575, -49608,
    -49640, -49673, -49706, -49739, -49771, -49804, -49837, -49869,
    -49902, -49935, -49967, -50000, -50032, -50065, -50097, -50129,
    -50162, -50194, -50226, -50259, -50291, -50323, -50355, -50387,
    -50420, -50452, -50484, -50516, -50548, -50580, -50612, -50644,
    -50675, -50707, -50739, -50771, -50803, -50834, -50866, -50898,
    -50929, -50961, -50993, -51024, -51056, -51087, -51119, -51150,
    -51182, -51213, -51244, -51276, -51307, -51338, -51369, -51401,
    -51432, -51463, -51494, -51525, -51556, -51587, -51618, -51649,
    -51680, -51711, -51742, -51773, -51803, -51834, -51865, -51896,
    -51926, -51957, -51988, -52018, -52049, -52079, -52110, -52140,
    -52171, -52201, -52231, -52262, -52292, -52322, -52353, -52383,
    -52413, -52443, -52473, -52503, -52534, -52564, -52594, -52624,
    -52653, -52683, -52713, -52743, -52773, -52803, -52832, -52862,
    -52892, -52922, -52951, -52981, -53010, -53040, -53069, -53099,
    -53128, -53158, -53187, -53216, -53246, -53275, -53304, -53334,
    -53363, -53392, -53421, -53450, -53479, -53508, -53537, -53566,
    -53595, -53624, -53653, -53682, -53711, -53739, -53768, -53797,
    -53826, -53854, -53883, -53911, -53940, -53969, -53997, -54026,
    -54054, -54082, -54111, -54139, -54167, -54196, -54224, -54252,
    -54280, -54308, -54337, -54365, -54393, -54421, -54449, -54477,
    -54505, -54533, -54560, -54588, -54616, -54644, -54672, -54699,
    -54727, -54755, -54782, -54810, -54837, -54865, -54892, -54920,
    -54947, -54974, -55002, -55029, -55056, -55084, -55111, -55138,
    -55165, -55192, -55219, -55246, -55274, -55300, -55327, -55354,
    -55381, -55408, -55435, -55462, -55489, -55515, -55542, -55569,
    -55595, -55622, -55648, -55675, -55701, -55728, -55754, -55781,
    -55807, -55833, -55860, -55886, -55912, -55938, -55965, -55991,
    -56017, -56043, -56069, -56095, -56121, -56147, -56173, -56199,
    -56225, -56250, -56276, -56302, -56328, -56353, -56379, -56404,
    -56430, -56456, -56481, -56507, -56532, -56557, -56583, -56608,
    -56633, -56659, -56684, -56709, -56734, -56760, -56785, -56810,
    -56835, -56860, -56885, -56910, -56935, -56959, -56984, -57009,
    -57034, -57059, -57083, -57108, -57133, -57157, -57182, -57206,
    -57231, -57255, -57280, -57304, -57329, -57353, -57377, -57402,
    -57426, -57450, -57474, -57498, -57522, -57546, -57570, -57594,
    -57618, -57642, -57666, -57690, -57714, -57738, -57762, -57785,
    -57809, -57833, -57856, -57880, -57903, -57927, -57950, -57974,
    -57997, -58021, -58044, -58067, -58091, -58114, -58137, -58160,
    -58183, -58207, -58230, -58253, -58276, -58299, -58322, -58345,
    -58367, -58390, -58413, -58436, -58459, -58481, -58504, -58527,
    -58549, -58572, -58594, -58617, -58639, -58662, -58684, -58706,
    -58729, -58751, -58773, -58795, -58818, -58840, -58862, -58884,
    -58906, -58928, -58950, -58972, -58994, -59016, -59038, -59059,
    -59081, -59103, -59125, -59146, -59168, -59190, -59211, -59233,
    -59254, -59276, -59297, -59318, -59340, -59361, -59382, -59404,
    -59425, -59446, -59467, -59488, -59509, -59530, -59551, -59572,
    -59593, -59614, -59635, -59656, -59677, -59697, -59718, -59739,
    -59759, -59780, -59801, -59821, -59842, -59862, -59883, -59903,
    -59923, -59944, -59964, -59984, -60004, -60025, -60045, -60065,
    -60085, -60105, -60125, -60145, -60165, -60185, -60205, -60225,
    -60244, -60264, -60284, -60304, -60323, -60343, -60363, -60382,
    -60402, -60421, -60441, -60460, -60479, -60499, -60518, -60537,
    -60556, -60576, -60595, -60614, -60633, -60652, -60671, -60690,
    -60709, -60728, -60747, -60766, -60785, -60803, -60822, -60841,
    -60859, -60878, -60897, -60915, -60934, -60952, -60971, -60989,
    -61007, -61026, -61044, -61062, -61081, -61099, -61117, -61135,
    -61153, -61171, -61189, -61207, -61225, -61243, -61261, -61279,
    -61297, -61314, -61332, -61350, -61367, -61385, -61403, -61420,
    -61438, -61455, -61473, -61490, -61507, -61525, -61542, -61559,
    -61577, -61594, -61611, -61628, -61645, -61662, -61679, -61696,
    -61713, -61730, -61747, -61764, -61780, -61797, -61814, -61831,
    -61847, -61864, -61880, -61897, -61913, -61930, -61946, -61963,
    -61979, -61995, -62012, -62028, -62044, -62060, -62076, -62092,
    -62108, -62125, -62141, -62156, -62172, -62188, -62204, -62220,
    -62236, -62251, -62267, -62283, -62298, -62314, -62329, -62345,
    -62360, -62376, -62391, -62407, -62422, -62437, -62453, -62468,
    -62483, -62498, -62513, -62528, -62543, -62558, -62573, -62588,
    -62603, -62618, -62633, -62648, -62662, -62677, -62692, -62706,
    -62721, -62735, -62750, -62764, -62779, -62793, -62808, -62822,
    -62836, -62850, -62865, -62879, -62893, -62907, -62921, -62935,
    -62949, -62963, -62977, -62991, -63005, -63019, -63032, -63046,
    -63060, -63074, -63087, -63101, -63114, -63128, -63141, -63155,
    -63168, -63182, -63195, -63208, -63221, -63235, -63248, -63261,
    -63274, -63287, -63300, -63313, -63326, -63339, -63352, -63365,
    -63378, -63390, -63403, -63416, -63429, -63441, -63454, -63466,
    -63479, -63491, -63504, -63516, -63528, -63541, -63553, -63565,
    -63578, -63590, -63602, -63614, -63626, -63638, -63650, -63662,
    -63674, -63686, -63698, -63709, -63721, -63733, -63745, -63756,
    -63768, -63779, -63791, -63803, -63814, -63825, -63837, -63848,
    -63859, -63871, -63882, -63893, -63904, -63915, -63927, -63938,
    -63949, -63960, -63971, -63981, -63992, -64003, -64014, -64025,
    -64035, -64046, -64057, -64067, -64078, -64088, -64099, -64109,
    -64120, -64130, -64140, -64151, -64161, -64171, -64181, -64192,
    -64202, -64212, -64222, -64232, -64242, -64252, -64261, -64271,
    -64281, -64291, -64301, -64310, -64320, -64330, -64339, -64349,
    -64358, -64368, -64377, -64387, -64396, -64405, -64414, -64424,
    -64433, -64442, -64451, -64460, -64469, -64478, -64487, -64496,
    -64505, -64514, -64523, -64532, -64540, -64549, -64558, -64566,
    -64575, -64584, -64592, -64601, -64609, -64617, -64626, -64634,
    -64642, -64651, -64659, -64667, -64675, -64683, -64691, -64699,
    -64707, -64715, -64723, -64731, -64739, -64747, -64754, -64762,
    -64770, -64777, -64785, -64793, -64800, -64808, -64815, -64822,
    -64830, -64837, -64844, -64852, -64859, -64866, -64873, -64880,
    -64887, -64895, -64902, -64908, -64915, -64922, -64929, -64936,
    -64943, -64949, -64956, -64963, -64969, -64976, -64982, -64989,
    -64995, -65002, -65008, -65015, -65021, -65027, -65033, -65040,
    -65046, -65052, -65058, -65064, -65070, -65076, -65082, -65088,
    -65094, -65099, -65105, -65111, -65117, -65122, -65128, -65133,
    -65139, -65144, -65150, -65155, -65161, -65166, -65171, -65177,
    -65182, -65187, -65192, -65197, -65202, -65207, -65212, -65217,
    -65222, -65227, -65232, -65237, -65242, -65246, -65251, -65256,
    -65260, -65265, -65270, -65274, -65279, -65283, -65287, -65292,
    -65296, -65300, -65305, -65309, -65313, -65317, -65321, -65325,
    -65329, -65333, -65337, -65341, -65345, -65349, -65352, -65356,
    -65360, -65363, -65367, -65371, -65374, -65378, -65381, -65385,
    -65388, -65391, -65395, -65398, -65401, -65404, -65408, -65411,
    -65414, -65417, -65420, -65423, -65426, -65429, -65431, -65434,
    -65437, -65440, -65442, -65445, -65448, -65450, -65453, -65455,
    -65458, -65460, -65463, -65465, -65467, -65470, -65472, -65474,
    -65476, -65478, -65480, -65482, -65484, -65486, -65488, -65490,
    -65492, -65494, -65496, -65497, -65499, -65501, -65502, -65504,
    -65505, -65507, -65508, -65510, -65511, -65513, -65514, -65515,
    -65516, -65518, -65519, -65520, -65521, -65522, -65523, -65524,
    -65525, -65526, -65527, -65527, -65528, -65529, -65530, -65530,
    -65531, -65531, -65532, -65532, -65533, -65533, -65534, -65534,
    -65534, -65535, -65535, -65535, -65535, -65535, -65535, -65535,
    -65535, -65535, -65535, -65535, -65535, -65535, -65535, -65534,
    -65534, -65534, -65533, -65533, -65532, -65532, -65531, -65531,
    -65530, -65530, -65529, -65528, -65527, -65527, -65526, -65525,
    -65524, -65523, -65522, -65521, -65520, -65519, -65518, -65516,
    -65515, -65514, -65513, -65511, -65510, -65508, -65507, -65505,
    -65504, -65502, -65501, -65499, -65497, -65496, -65494, -65492,
    -65490, -65488, -65486, -65484, -65482, -65480, -65478, -65476,
    -65474, -65472, -65470, -65467, -65465, -65463, -65460, -65458,
    -65455, -65453, -65450, -65448, -65445, -65442, -65440, -65437,
    -65434, -65431, -65429, -65426, -65423, -65420, -65417, -65414,
    -65411, -65408, -65404, -65401, -65398, -65395, -65391, -65388,
    -65385, -65381, -65378, -65374, -65371, -65367, -65363, -65360,
    -65356, -65352, -65349, -65345, -65341, -65337, -65333, -65329,
    -65325, -65321, -65317, -65313, -65309, -65305, -65300, -65296,
    -65292, -65287, -65283, -65279, -65274, -65270, -65265, -65260,
    -65256, -65251, -65246, -65242, -65237, -65232, -65227, -65222,
    -65217, -65212, -65207, -65202, -65197, -65192, -65187, -65182,
    -65177, -65171, -65166, -65161, -65155, -65150, -65144, -65139,
    -65133, -65128, -65122, -65117, -65111, -65105, -65099, -65094,
    -65088, -65082, -65076, -65070, -65064, -65058, -65052, -65046,
    -65040, -65033, -65027, -65021, -65015, -65008, -65002, -64995,
    -64989, -64982, -64976, -64969, -64963, -64956, -64949, -64943,
    -64936, -64929, -64922, -64915, -64908, -64902, -64895, -64887,
    -64880, -64873, -64866, -64859, -64852, -64844, -64837, -64830,
    -64822, -64815, -64808, -64800, -64793, -64785, -64777, -64770,
    -64762, -64754, -64747, -64739, -64731, -64723, -64715, -64707,
    -64699, -64691, -64683, -64675, -64667, -64659, -64651, -64642,
    -64634, -64626, -64617, -64609, -64601, -64592, -64584, -64575,
    -64566, -64558, -64549, -64540, -64532, -64523, -64514, -64505,
    -64496, -64487, -64478, -64469, -64460, -64451, -64442, -64433,
    -64424, -64414, -64405, -64396, -64387, -64377, -64368, -64358,
    -64349, -64339, -64330, -64320, -64310, -64301, -64291, -64281,
    -64271, -64261, -64252, -64242, -64232, -64222, -64212, -64202,
    -64192, -64181, -64171, -64161, -64151, -64140, -64130, -64120,
    -64109, -64099, -64088, -64078, -64067, -64057, -64046, -64035,
    -64025, -64014, -64003, -63992, -63981, -63971, -63960, -63949,
    -63938, -63927, -63915, -63904, -63893, -63882, -63871, -63859,
    -63848, -63837, -63825, -63814, -63803, -63791, -63779, -63768,
    -63756, -63745, -63733, -63721, -63709, -63698, -63686, -63674,
    -63662, -63650, -63638, -63626, -63614, -63602, -63590, -63578,
    -63565, -63553, -63541, -63528, -63516, -63504, -63491, -63479,
    -63466, -63454, -63441, -63429, -63416, -63403, -63390, -63378,
    -63365, -63352, -63339, -63326, -63313, -63300, -63287, -63274,
    -63261, -63248, -63235, -63221, -63208, -63195, -63182, -63168,
    -63155, -63141, -63128, -63114, -63101, -63087, -63074, -63060,
    -63046, -63032, -63019, -63005, -62991, -62977, -62963, -62949,
    -62935, -62921, -62907, -62893, -62879, -62865, -62850, -62836,
    -62822, -62808, -62793, -62779, -62764, -62750, -62735, -62721,
    -62706, -62692, -62677, -62662, -62648, -62633, -62618, -62603,
    -62588, -62573, -62558, -62543, -62528, -62513, -62498, -62483,
    -62468, -62453, -62437, -62422, -62407, -62391, -62376, -62360,
    -62345, -62329, -62314, -62298, -62283, -62267, -62251, -62236,
    -62220, -62204, -62188, -62172, -62156, -62141, -62125, -62108,
    -62092, -62076, -62060, -62044, -62028, -62012, -61995, -61979,
    -61963, -61946, -61930, -61913, -61897, -61880, -61864, -61847,
    -61831, -61814, -61797, -61780, -61764, -61747, -61730, -61713,
    -61696, -61679, -61662, -61645, -61628, -61611, -61594, -61577,
    -61559, -61542, -61525, -61507, -61490, -61473, -61455, -61438,
    -61420, -61403, -61385, -61367, -61350, -61332, -61314, -61297,
    -61279, -61261, -61243, -61225, -61207, -61189, -61171, -61153,
    -61135, -61117, -61099, -61081, -61062, -61044, -61026, -61007,
    -60989, -60971, -60952, -60934, -60915, -60897, -60878, -60859,
    -60841, -60822, -60803, -60785, -60766, -60747, -60728, -60709,
    -60690, -60671, -60652, -60633, -60614, -60595, -60576, -60556,
    -60537, -60518, -60499, -60479, -60460, -60441, -60421, -60402,
    -60382, -60363, -60343, -60323, -60304, -60284, -60264, -60244,
    -60225, -60205, -60185, -60165, -60145, -60125, -60105, -60085,
    -60065, -60045, -60025, -60004, -59984, -59964, -59944, -59923,
    -59903, -59883, -59862, -59842, -59821, -59801, -59780, -59759,
    -59739, -59718, -59697, -59677, -59656, -59635, -59614, -59593,
    -59572, -59551, -59530, -59509, -59488, -59467, -59446, -59425,
    -59404, -59382, -59361, -59340, -59318, -59297, -59276, -59254,
    -59233, -59211, -59189, -59168, -59146, -59125, -59103, -59081,
    -59059, -59038, -59016, -58994, -58972, -58950, -58928, -58906,
    -58884, -58862, -58840, -58818, -58795, -58773, -58751, -58729,
    -58706, -58684, -58662, -58639, -58617, -58594, -58572, -58549,
    -58527, -58504, -58481, -58459, -58436, -58413, -58390, -58367,
    -58345, -58322, -58299, -58276, -58253, -58230, -58207, -58183,
    -58160, -58137, -58114, -58091, -58067, -58044, -58021, -57997,
    -57974, -57950, -57927, -57903, -57880, -57856, -57833, -57809,
    -57785, -57762, -57738, -57714, -57690, -57666, -57642, -57618,
    -57594, -57570, -57546, -57522, -57498, -57474, -57450, -57426,
    -57402, -57377, -57353, -57329, -57304, -57280, -57255, -57231,
    -57206, -57182, -57157, -57133, -57108, -57083, -57059, -57034,
    -57009, -56984, -56959, -56935, -56910, -56885, -56860, -56835,
    -56810, -56785, -56760, -56734, -56709, -56684, -56659, -56633,
    -56608, -56583, -56557, -56532, -56507, -56481, -56456, -56430,
    -56404, -56379, -56353, -56328, -56302, -56276, -56250, -56225,
    -56199, -56173, -56147, -56121, -56095, -56069, -56043, -56017,
    -55991, -55965, -55938, -55912, -55886, -55860, -55833, -55807,
    -55781, -55754, -55728, -55701, -55675, -55648, -55622, -55595,
    -55569, -55542, -55515, -55489, -55462, -55435, -55408, -55381,
    -55354, -55327, -55300, -55274, -55246, -55219, -55192, -55165,
    -55138, -55111, -55084, -55056, -55029, -55002, -54974, -54947,
    -54920, -54892, -54865, -54837, -54810, -54782, -54755, -54727,
    -54699, -54672, -54644, -54616, -54588, -54560, -54533, -54505,
    -54477, -54449, -54421, -54393, -54365, -54337, -54308, -54280,
    -54252, -54224, -54196, -54167, -54139, -54111, -54082, -54054,
    -54026, -53997, -53969, -53940, -53911, -53883, -53854, -53826,
    -53797, -53768, -53739, -53711, -53682, -53653, -53624, -53595,
    -53566, -53537, -53508, -53479, -53450, -53421, -53392, -53363,
    -53334, -53304, -53275, -53246, -53216, -53187, -53158, -53128,
    -53099, -53069, -53040, -53010, -52981, -52951, -52922, -52892,
    -52862, -52832, -52803, -52773, -52743, -52713, -52683, -52653,
    -52624, -52594, -52564, -52534, -52503, -52473, -52443, -52413,
    -52383, -52353, -52322, -52292, -52262, -52231, -52201, -52171,
    -52140, -52110, -52079, -52049, -52018, -51988, -51957, -51926,
    -51896, -51865, -51834, -51803, -51773, -51742, -51711, -51680,
    -51649, -51618, -51587, -51556, -51525, -51494, -51463, -51432,
    -51401, -51369, -51338, -51307, -51276, -51244, -51213, -51182,
    -51150, -51119, -51087, -51056, -51024, -50993, -50961, -50929,
    -50898, -50866, -50834, -50803, -50771, -50739, -50707, -50675,
    -50644, -50612, -50580, -50548, -50516, -50484, -50452, -50420,
    -50387, -50355, -50323, -50291, -50259, -50226, -50194, -50162,
    -50129, -50097, -50065, -50032, -50000, -49967, -49935, -49902,
    -49869, -49837, -49804, -49771, -49739, -49706, -49673, -49640,
    -49608, -49575, -49542, -49509, -49476, -49443, -49410, -49377,
    -49344, -49311, -49278, -49244, -49211, -49178, -49145, -49112,
    -49078, -49045, -49012, -48978, -48945, -48911, -48878, -48844,
    -48811, -48777, -48744, -48710, -48676, -48643, -48609, -48575,
    -48542, -48508, -48474, -48440, -48406, -48372, -48338, -48305,
    -48271, -48237, -48202, -48168, -48134, -48100, -48066, -48032,
    -47998, -47963, -47929, -47895, -47860, -47826, -47792, -47757,
    -47723, -47688, -47654, -47619, -47585, -47550, -47516, -47481,
    -47446, -47412, -47377, -47342, -47307, -47273, -47238, -47203,
    -47168, -47133, -47098, -47063, -47028, -46993, -46958, -46923,
    -46888, -46853, -46818, -46783, -46747, -46712, -46677, -46642,
    -46606, -46571, -46536, -46500, -46465, -46429, -46394, -46358,
    -46323, -46287, -46251, -46216, -46180, -46145, -46109, -46073,
    -46037, -46002, -45966, -45930, -45894, -45858, -45822, -45786,
    -45750, -45714, -45678, -45642, -45606, -45570, -45534, -45498,
    -45462, -45425, -45389, -45353, -45316, -45280, -45244, -45207,
    -45171, -45135, -45098, -45062, -45025, -44989, -44952, -44915,
    -44879, -44842, -44806, -44769, -44732, -44695, -44659, -44622,
    -44585, -44548, -44511, -44474, -44437, -44400, -44363, -44326,
    -44289, -44252, -44215, -44178, -44141, -44104, -44067, -44029,
    -43992, -43955, -43918, -43880, -43843, -43806, -43768, -43731,
    -43693, -43656, -43618, -43581, -43543, -43506, -43468, -43430,
    -43393, -43355, -43317, -43280, -43242, -43204, -43166, -43128,
    -43091, -43053, -43015, -42977, -42939, -42901, -42863, -42825,
    -42787, -42749, -42711, -42672, -42634, -42596, -42558, -42520,
    -42481, -42443, -42405, -42366, -42328, -42290, -42251, -42213,
    -42174, -42136, -42097, -42059, -42020, -41982, -41943, -41904,
    -41866, -41827, -41788, -41750, -41711, -41672, -41633, -41595,
    -41556, -41517, -41478, -41439, -41400, -41361, -41322, -41283,
    -41244, -41205, -41166, -41127, -41087, -41048, -41009, -40970,
    -40931, -40891, -40852, -40813, -40773, -40734, -40695, -40655,
    -40616, -40576, -40537, -40497, -40458, -40418, -40379, -40339,
    -40299, -40260, -40220, -40180, -40141, -40101, -40061, -40021,
    -39982, -39942, -39902, -39862, -39822, -39782, -39742, -39702,
    -39662, -39622, -39582, -39542, -39502, -39462, -39422, -39382,
    -39341, -39301, -39261, -39221, -39180, -39140, -39100, -39059,
    -39019, -38979, -38938, -38898, -38857, -38817, -38776, -38736,
    -38695, -38655, -38614, -38573, -38533, -38492, -38451, -38411,
    -38370, -38329, -38288, -38248, -38207, -38166, -38125, -38084,
    -38043, -38002, -37961, -37920, -37879, -37838, -37797, -37756,
    -37715, -37674, -37633, -37592, -37550, -37509, -37468, -37427,
    -37386, -37344, -37303, -37262, -37220, -37179, -37137, -37096,
    -37055, -37013, -36972, -36930, -36889, -36847, -36805, -36764,
    -36722, -36681, -36639, -36597, -36556, -36514, -36472, -36430,
    -36388, -36347, -36305, -36263, -36221, -36179, -36137, -36095,
    -36053, -36011, -35969, -35927, -35885, -35843, -35801, -35759,
    -35717, -35675, -35633, -35590, -35548, -35506, -35464, -35421,
    -35379, -35337, -35294, -35252, -35210, -35167, -35125, -35082,
    -35040, -34997, -34955, -34912, -34870, -34827, -34785, -34742,
    -34699, -34657, -34614, -34571, -34529, -34486, -34443, -34400,
    -34358, -34315, -34272, -34229, -34186, -34143, -34100, -34057,
    -34015, -33972, -33929, -33886, -33843, -33799, -33756, -33713,
    -33670, -33627, -33584, -33541, -33498, -33454, -33411, -33368,
    -33325, -33281, -33238, -33195, -33151, -33108, -33065, -33021,
    -32978, -32934, -32891, -32847, -32804, -32760, -32717, -32673,
    -32630, -32586, -32542, -32499, -32455, -32411, -32368, -32324,
    -32280, -32236, -32193, -32149, -32105, -32061, -32017, -31974,
    -31930, -31886, -31842, -31798, -31754, -31710, -31666, -31622,
    -31578, -31534, -31490, -31446, -31402, -31357, -31313, -31269,
    -31225, -31181, -31136, -31092, -31048, -31004, -30959, -30915,
    -30871, -30826, -30782, -30738, -30693, -30649, -30604, -30560,
    -30515, -30471, -30426, -30382, -30337, -30293, -30248, -30204,
    -30159, -30114, -30070, -30025, -29980, -29936, -29891, -29846,
    -29801, -29757, -29712, -29667, -29622, -29577, -29533, -29488,
    -29443, -29398, -29353, -29308, -29263, -29218, -29173, -29128,
    -29083, -29038, -28993, -28948, -28903, -28858, -28812, -28767,
    -28722, -28677, -28632, -28586, -28541, -28496, -28451, -28405,
    -28360, -28315, -28269, -28224, -28179, -28133, -28088, -28042,
    -27997, -27952, -27906, -27861, -27815, -27770, -27724, -27678,
    -27633, -27587, -27542, -27496, -27450, -27405, -27359, -27313,
    -27268, -27222, -27176, -27131, -27085, -27039, -26993, -26947,
    -26902, -26856, -26810, -26764, -26718, -26672, -26626, -26580,
    -26534, -26488, -26442, -26396, -26350, -26304, -26258, -26212,
    -26166, -26120, -26074, -26028, -25982, -25936, -25889, -25843,
    -25797, -25751, -25705, -25658, -25612, -25566, -25520, -25473,
    -25427, -25381, -25334, -25288, -25241, -25195, -25149, -25102,
    -25056, -25009, -24963, -24916, -24870, -24823, -24777, -24730,
    -24684, -24637, -24591, -24544, -24497, -24451, -24404, -24357,
    -24311, -24264, -24217, -24171, -24124, -24077, -24030, -23984,
    -23937, -23890, -23843, -23796, -23750, -23703, -23656, -23609,
    -23562, -23515, -23468, -23421, -23374, -23327, -23280, -23233,
    -23186, -23139, -23092, -23045, -22998, -22951, -22904, -22857,
    -22810, -22763, -22716, -22668, -22621, -22574, -22527, -22480,
    -22432, -22385, -22338, -22291, -22243, -22196, -22149, -22102,
    -22054, -22007, -21960, -21912, -21865, -21817, -21770, -21723,
    -21675, -21628, -21580, -21533, -21485, -21438, -21390, -21343,
    -21295, -21248, -21200, -21153, -21105, -21057, -21010, -20962,
    -20915, -20867, -20819, -20772, -20724, -20676, -20629, -20581,
    -20533, -20485, -20438, -20390, -20342, -20294, -20246, -20199,
    -20151, -20103, -20055, -20007, -19959, -19912, -19864, -19816,
    -19768, -19720, -19672, -19624, -19576, -19528, -19480, -19432,
    -19384, -19336, -19288, -19240, -19192, -19144, -19096, -19048,
    -19000, -18951, -18903, -18855, -18807, -18759, -18711, -18663,
    -18614, -18566, -18518, -18470, -18421, -18373, -18325, -18277,
    -18228, -18180, -18132, -18084, -18035, -17987, -17939, -17890,
    -17842, -17793, -17745, -17697, -17648, -17600, -17551, -17503,
    -17455, -17406, -17358, -17309, -17261, -17212, -17164, -17115,
    -17067, -17018, -16970, -16921, -16872, -16824, -16775, -16727,
    -16678, -16629, -16581, -16532, -16484, -16435, -16386, -16338,
    -16289, -16240, -16191, -16143, -16094, -16045, -15997, -15948,
    -15899, -15850, -15802, -15753, -15704, -15655, -15606, -15557,
    -15509, -15460, -15411, -15362, -15313, -15264, -15215, -15167,
    -15118, -15069, -15020, -14971, -14922, -14873, -14824, -14775,
    -14726, -14677, -14628, -14579, -14530, -14481, -14432, -14383,
    -14334, -14285, -14236, -14187, -14138, -14089, -14040, -13990,
    -13941, -13892, -13843, -13794, -13745, -13696, -13647, -13597,
    -13548, -13499, -13450, -13401, -13351, -13302, -13253, -13204,
    -13154, -13105, -13056, -13007, -12957, -12908, -12859, -12810,
    -12760, -12711, -12662, -12612, -12563, -12514, -12464, -12415,
    -12366, -12316, -12267, -12217, -12168, -12119, -12069, -12020,
    -11970, -11921, -11872, -11822, -11773, -11723, -11674, -11624,
    -11575, -11525, -11476, -11426, -11377, -11327, -11278, -11228,
    -11179, -11129, -11080, -11030, -10981, -10931, -10882, -10832,
    -10782, -10733, -10683, -10634, -10584, -10534, -10485, -10435,
    -10386, -10336, -10286, -10237, -10187, -10137, -10088, -10038,
    -9988, -9939, -9889, -9839, -9790, -9740, -9690, -9640,
    -9591, -9541, -9491, -9442, -9392, -9342, -9292, -9243,
    -9193, -9143, -9093, -9043, -8994, -8944, -8894, -8844,
    -8794, -8745, -8695, -8645, -8595, -8545, -8496, -8446,
    -8396, -8346, -8296, -8246, -8196, -8147, -8097, -8047,
    -7997, -7947, -7897, -7847, -7797, -7747, -7697, -7648,
    -7598, -7548, -7498, -7448, -7398, -7348, -7298, -7248,
    -7198, -7148, -7098, -7048, -6998, -6948, -6898, -6848,
    -6798, -6748, -6698, -6648, -6598, -6548, -6498, -6448,
    -6398, -6348, -6298, -6248, -6198, -6148, -6098, -6048,
    -5998, -5948, -5898, -5848, -5798, -5747, -5697, -5647,
    -5597, -5547, -5497, -5447, -5397, -5347, -5297, -5247,
    -5197, -5146, -5096, -5046, -4996, -4946, -4896, -4846,
    -4796, -4745, -4695, -4645, -4595, -4545, -4495, -4445,
    -4394, -4344, -4294, -4244, -4194, -4144, -4093, -4043,
    -3993, -3943, -3893, -3843, -3792, -3742, -3692, -3642,
    -3592, -3541, -3491, -3441, -3391, -3341, -3291, -3240,
    -3190, -3140, -3090, -3039, -2989, -2939, -2889, -2839,
    -2788, -2738, -2688, -2638, -2588, -2537, -2487, -2437,
    -2387, -2336, -2286, -2236, -2186, -2135, -2085, -2035,
    -1985, -1934, -1884, -1834, -1784, -1733, -1683, -1633,
    -1583, -1532, -1482, -1432, -1382, -1331, -1281, -1231,
    -1181, -1130, -1080, -1030, -980, -929, -879, -829,
    -779, -728, -678, -628, -578, -527, -477, -427,
    -376, -326, -276, -226, -175, -125, -75, -25,
    25, 75, 125, 175, 226, 276, 326, 376,
    427, 477, 527, 578, 628, 678, 728, 779,
    829, 879, 929, 980, 1030, 1080, 1130, 1181,
    1231, 1281, 1331, 1382, 1432, 1482, 1532, 1583,
    1633, 1683, 1733, 1784, 1834, 1884, 1934, 1985,
    2035, 2085, 2135, 2186, 2236, 2286, 2336, 2387,
    2437, 2487, 2537, 2587, 2638, 2688, 2738, 2788,
    2839, 2889, 2939, 2989, 3039, 3090, 3140, 3190,
    3240, 3291, 3341, 3391, 3441, 3491, 3542, 3592,
    3642, 3692, 3742, 3792, 3843, 3893, 3943, 3993,
    4043, 4093, 4144, 4194, 4244, 4294, 4344, 4394,
    4445, 4495, 4545, 4595, 4645, 4695, 4745, 4796,
    4846, 4896, 4946, 4996, 5046, 5096, 5146, 5197,
    5247, 5297, 5347, 5397, 5447, 5497, 5547, 5597,
    5647, 5697, 5747, 5798, 5848, 5898, 5948, 5998,
    6048, 6098, 6148, 6198, 6248, 6298, 6348, 6398,
    6448, 6498, 6548, 6598, 6648, 6698, 6748, 6798,
    6848, 6898, 6948, 6998, 7048, 7098, 7148, 7198,
    7248, 7298, 7348, 7398, 7448, 7498, 7548, 7598,
    7648, 7697, 7747, 7797, 7847, 7897, 7947, 7997,
    8047, 8097, 8147, 8196, 8246, 8296, 8346, 8396,
    8446, 8496, 8545, 8595, 8645, 8695, 8745, 8794,
    8844, 8894, 8944, 8994, 9043, 9093, 9143, 9193,
    9243, 9292, 9342, 9392, 9442, 9491, 9541, 9591,
    9640, 9690, 9740, 9790, 9839, 9889, 9939, 9988,
    10038, 10088, 10137, 10187, 10237, 10286, 10336, 10386,
    10435, 10485, 10534, 10584, 10634, 10683, 10733, 10782,
    10832, 10882, 10931, 10981, 11030, 11080, 11129, 11179,
    11228, 11278, 11327, 11377, 11426, 11476, 11525, 11575,
    11624, 11674, 11723, 11773, 11822, 11872, 11921, 11970,
    12020, 12069, 12119, 12168, 12218, 12267, 12316, 12366,
    12415, 12464, 12514, 12563, 12612, 12662, 12711, 12760,
    12810, 12859, 12908, 12957, 13007, 13056, 13105, 13154,
    13204, 13253, 13302, 13351, 13401, 13450, 13499, 13548,
    13597, 13647, 13696, 13745, 13794, 13843, 13892, 13941,
    13990, 14040, 14089, 14138, 14187, 14236, 14285, 14334,
    14383, 14432, 14481, 14530, 14579, 14628, 14677, 14726,
    14775, 14824, 14873, 14922, 14971, 15020, 15069, 15118,
    15167, 15215, 15264, 15313, 15362, 15411, 15460, 15509,
    15557, 15606, 15655, 15704, 15753, 15802, 15850, 15899,
    15948, 15997, 16045, 16094, 16143, 16191, 16240, 16289,
    16338, 16386, 16435, 16484, 16532, 16581, 16629, 16678,
    16727, 16775, 16824, 16872, 16921, 16970, 17018, 17067,
    17115, 17164, 17212, 17261, 17309, 17358, 17406, 17455,
    17503, 17551, 17600, 17648, 17697, 17745, 17793, 17842,
    17890, 17939, 17987, 18035, 18084, 18132, 18180, 18228,
    18277, 18325, 18373, 18421, 18470, 18518, 18566, 18614,
    18663, 18711, 18759, 18807, 18855, 18903, 18951, 19000,
    19048, 19096, 19144, 19192, 19240, 19288, 19336, 19384,
    19432, 19480, 19528, 19576, 19624, 19672, 19720, 19768,
    19816, 19864, 19912, 19959, 20007, 20055, 20103, 20151,
    20199, 20246, 20294, 20342, 20390, 20438, 20485, 20533,
    20581, 20629, 20676, 20724, 20772, 20819, 20867, 20915,
    20962, 21010, 21057, 21105, 21153, 21200, 21248, 21295,
    21343, 21390, 21438, 21485, 21533, 21580, 21628, 21675,
    21723, 21770, 21817, 21865, 21912, 21960, 22007, 22054,
    22102, 22149, 22196, 22243, 22291, 22338, 22385, 22432,
    22480, 22527, 22574, 22621, 22668, 22716, 22763, 22810,
    22857, 22904, 22951, 22998, 23045, 23092, 23139, 23186,
    23233, 23280, 23327, 23374, 23421, 23468, 23515, 23562,
    23609, 23656, 23703, 23750, 23796, 23843, 23890, 23937,
    23984, 24030, 24077, 24124, 24171, 24217, 24264, 24311,
    24357, 24404, 24451, 24497, 24544, 24591, 24637, 24684,
    24730, 24777, 24823, 24870, 24916, 24963, 25009, 25056,
    25102, 25149, 25195, 25241, 25288, 25334, 25381, 25427,
    25473, 25520, 25566, 25612, 25658, 25705, 25751, 25797,
    25843, 25889, 25936, 25982, 26028, 26074, 26120, 26166,
    26212, 26258, 26304, 26350, 26396, 26442, 26488, 26534,
    26580, 26626, 26672, 26718, 26764, 26810, 26856, 26902,
    26947, 26993, 27039, 27085, 27131, 27176, 27222, 27268,
    27313, 27359, 27405, 27450, 27496, 27542, 27587, 27633,
    27678, 27724, 27770, 27815, 27861, 27906, 27952, 27997,
    28042, 28088, 28133, 28179, 28224, 28269, 28315, 28360,
    28405, 28451, 28496, 28541, 28586, 28632, 28677, 28722,
    28767, 28812, 28858, 28903, 28948, 28993, 29038, 29083,
    29128, 29173, 29218, 29263, 29308, 29353, 29398, 29443,
    29488, 29533, 29577, 29622, 29667, 29712, 29757, 29801,
    29846, 29891, 29936, 29980, 30025, 30070, 30114, 30159,
    30204, 30248, 30293, 30337, 30382, 30427, 30471, 30516,
    30560, 30604, 30649, 30693, 30738, 30782, 30826, 30871,
    30915, 30959, 31004, 31048, 31092, 31136, 31181, 31225,
    31269, 31313, 31357, 31402, 31446, 31490, 31534, 31578,
    31622, 31666, 31710, 31754, 31798, 31842, 31886, 31930,
    31974, 32017, 32061, 32105, 32149, 32193, 32236, 32280,
    32324, 32368, 32411, 32455, 32499, 32542, 32586, 32630,
    32673, 32717, 32760, 32804, 32847, 32891, 32934, 32978,
    33021, 33065, 33108, 33151, 33195, 33238, 33281, 33325,
    33368, 33411, 33454, 33498, 33541, 33584, 33627, 33670,
    33713, 33756, 33799, 33843, 33886, 33929, 33972, 34015,
    34057, 34100, 34143, 34186, 34229, 34272, 34315, 34358,
    34400, 34443, 34486, 34529, 34571, 34614, 34657, 34699,
    34742, 34785, 34827, 34870, 34912, 34955, 34997, 35040,
    35082, 35125, 35167, 35210, 35252, 35294, 35337, 35379,
    35421, 35464, 35506, 35548, 35590, 35633, 35675, 35717,
    35759, 35801, 35843, 35885, 35927, 35969, 36011, 36053,
    36095, 36137, 36179, 36221, 36263, 36305, 36347, 36388,
    36430, 36472, 36514, 36556, 36597, 36639, 36681, 36722,
    36764, 36805, 36847, 36889, 36930, 36972, 37013, 37055,
    37096, 37137, 37179, 37220, 37262, 37303, 37344, 37386,
    37427, 37468, 37509, 37551, 37592, 37633, 37674, 37715,
    37756, 37797, 37838, 37879, 37920, 37961, 38002, 38043,
    38084, 38125, 38166, 38207, 38248, 38288, 38329, 38370,
    38411, 38451, 38492, 38533, 38573, 38614, 38655, 38695,
    38736, 38776, 38817, 38857, 38898, 38938, 38979, 39019,
    39059, 39100, 39140, 39180, 39221, 39261, 39301, 39341,
    39382, 39422, 39462, 39502, 39542, 39582, 39622, 39662,
    39702, 39742, 39782, 39822, 39862, 39902, 39942, 39982,
    40021, 40061, 40101, 40141, 40180, 40220, 40260, 40299,
    40339, 40379, 40418, 40458, 40497, 40537, 40576, 40616,
    40655, 40695, 40734, 40773, 40813, 40852, 40891, 40931,
    40970, 41009, 41048, 41087, 41127, 41166, 41205, 41244,
    41283, 41322, 41361, 41400, 41439, 41478, 41517, 41556,
    41595, 41633, 41672, 41711, 41750, 41788, 41827, 41866,
    41904, 41943, 41982, 42020, 42059, 42097, 42136, 42174,
    42213, 42251, 42290, 42328, 42366, 42405, 42443, 42481,
    42520, 42558, 42596, 42634, 42672, 42711, 42749, 42787,
    42825, 42863, 42901, 42939, 42977, 43015, 43053, 43091,
    43128, 43166, 43204, 43242, 43280, 43317, 43355, 43393,
    43430, 43468, 43506, 43543, 43581, 43618, 43656, 43693,
    43731, 43768, 43806, 43843, 43880, 43918, 43955, 43992,
    44029, 44067, 44104, 44141, 44178, 44215, 44252, 44289,
    44326, 44363, 44400, 44437, 44474, 44511, 44548, 44585,
    44622, 44659, 44695, 44732, 44769, 44806, 44842, 44879,
    44915, 44952, 44989, 45025, 45062, 45098, 45135, 45171,
    45207, 45244, 45280, 45316, 45353, 45389, 45425, 45462,
    45498, 45534, 45570, 45606, 45642, 45678, 45714, 45750,
    45786, 45822, 45858, 45894, 45930, 45966, 46002, 46037,
    46073, 46109, 46145, 46180, 46216, 46252, 46287, 46323,
    46358, 46394, 46429, 46465, 46500, 46536, 46571, 46606,
    46642, 46677, 46712, 46747, 46783, 46818, 46853, 46888,
    46923, 46958, 46993, 47028, 47063, 47098, 47133, 47168,
    47203, 47238, 47273, 47308, 47342, 47377, 47412, 47446,
    47481, 47516, 47550, 47585, 47619, 47654, 47688, 47723,
    47757, 47792, 47826, 47861, 47895, 47929, 47963, 47998,
    48032, 48066, 48100, 48134, 48168, 48202, 48237, 48271,
    48305, 48338, 48372, 48406, 48440, 48474, 48508, 48542,
    48575, 48609, 48643, 48676, 48710, 48744, 48777, 48811,
    48844, 48878, 48911, 48945, 48978, 49012, 49045, 49078,
    49112, 49145, 49178, 49211, 49244, 49278, 49311, 49344,
    49377, 49410, 49443, 49476, 49509, 49542, 49575, 49608,
    49640, 49673, 49706, 49739, 49771, 49804, 49837, 49869,
    49902, 49935, 49967, 50000, 50032, 50064, 50097, 50129,
    50162, 50194, 50226, 50259, 50291, 50323, 50355, 50387,
    50420, 50452, 50484, 50516, 50548, 50580, 50612, 50644,
    50675, 50707, 50739, 50771, 50803, 50834, 50866, 50898,
    50929, 50961, 50993, 51024, 51056, 51087, 51119, 51150,
    51182, 51213, 51244, 51276, 51307, 51338, 51369, 51401,
    51432, 51463, 51494, 51525, 51556, 51587, 51618, 51649,
    51680, 51711, 51742, 51773, 51803, 51834, 51865, 51896,
    51926, 51957, 51988, 52018, 52049, 52079, 52110, 52140,
    52171, 52201, 52231, 52262, 52292, 52322, 52353, 52383,
    52413, 52443, 52473, 52503, 52534, 52564, 52594, 52624,
    52653, 52683, 52713, 52743, 52773, 52803, 52832, 52862,
    52892, 52922, 52951, 52981, 53010, 53040, 53069, 53099,
    53128, 53158, 53187, 53216, 53246, 53275, 53304, 53334,
    53363, 53392, 53421, 53450, 53479, 53508, 53537, 53566,
    53595, 53624, 53653, 53682, 53711, 53739, 53768, 53797,
    53826, 53854, 53883, 53912, 53940, 53969, 53997, 54026,
    54054, 54082, 54111, 54139, 54167, 54196, 54224, 54252,
    54280, 54309, 54337, 54365, 54393, 54421, 54449, 54477,
    54505, 54533, 54560, 54588, 54616, 54644, 54672, 54699,
    54727, 54755, 54782, 54810, 54837, 54865, 54892, 54920,
    54947, 54974, 55002, 55029, 55056, 55084, 55111, 55138,
    55165, 55192, 55219, 55246, 55274, 55300, 55327, 55354,
    55381, 55408, 55435, 55462, 55489, 55515, 55542, 55569,
    55595, 55622, 55648, 55675, 55701, 55728, 55754, 55781,
    55807, 55833, 55860, 55886, 55912, 55938, 55965, 55991,
    56017, 56043, 56069, 56095, 56121, 56147, 56173, 56199,
    56225, 56250, 56276, 56302, 56328, 56353, 56379, 56404,
    56430, 56456, 56481, 56507, 56532, 56557, 56583, 56608,
    56633, 56659, 56684, 56709, 56734, 56760, 56785, 56810,
    56835, 56860, 56885, 56910, 56935, 56959, 56984, 57009,
    57034, 57059, 57083, 57108, 57133, 57157, 57182, 57206,
    57231, 57255, 57280, 57304, 57329, 57353, 57377, 57402,
    57426, 57450, 57474, 57498, 57522, 57546, 57570, 57594,
    57618, 57642, 57666, 57690, 57714, 57738, 57762, 57785,
    57809, 57833, 57856, 57880, 57903, 57927, 57950, 57974,
    57997, 58021, 58044, 58067, 58091, 58114, 58137, 58160,
    58183, 58207, 58230, 58253, 58276, 58299, 58322, 58345,
    58367, 58390, 58413, 58436, 58459, 58481, 58504, 58527,
    58549, 58572, 58594, 58617, 58639, 58662, 58684, 58706,
    58729, 58751, 58773, 58795, 58818, 58840, 58862, 58884,
    58906, 58928, 58950, 58972, 58994, 59016, 59038, 59059,
    59081, 59103, 59125, 59146, 59168, 59190, 59211, 59233,
    59254, 59276, 59297, 59318, 59340, 59361, 59382, 59404,
    59425, 59446, 59467, 59488, 59509, 59530, 59551, 59572,
    59593, 59614, 59635, 59656, 59677, 59697, 59718, 59739,
    59759, 59780, 59801, 59821, 59842, 59862, 59883, 59903,
    59923, 59944, 59964, 59984, 60004, 60025, 60045, 60065,
    60085, 60105, 60125, 60145, 60165, 60185, 60205, 60225,
    60244, 60264, 60284, 60304, 60323, 60343, 60363, 60382,
    60402, 60421, 60441, 60460, 60479, 60499, 60518, 60537,
    60556, 60576, 60595, 60614, 60633, 60652, 60671, 60690,
    60709, 60728, 60747, 60766, 60785, 60803, 60822, 60841,
    60859, 60878, 60897, 60915, 60934, 60952, 60971, 60989,
    61007, 61026, 61044, 61062, 61081, 61099, 61117, 61135,
    61153, 61171, 61189, 61207, 61225, 61243, 61261, 61279,
    61297, 61314, 61332, 61350, 61367, 61385, 61403, 61420,
    61438, 61455, 61473, 61490, 61507, 61525, 61542, 61559,
    61577, 61594, 61611, 61628, 61645, 61662, 61679, 61696,
    61713, 61730, 61747, 61764, 61780, 61797, 61814, 61831,
    61847, 61864, 61880, 61897, 61913, 61930, 61946, 61963,
    61979, 61995, 62012, 62028, 62044, 62060, 62076, 62092,
    62108, 62125, 62141, 62156, 62172, 62188, 62204, 62220,
    62236, 62251, 62267, 62283, 62298, 62314, 62329, 62345,
    62360, 62376, 62391, 62407, 62422, 62437, 62453, 62468,
    62483, 62498, 62513, 62528, 62543, 62558, 62573, 62588,
    62603, 62618, 62633, 62648, 62662, 62677, 62692, 62706,
    62721, 62735, 62750, 62764, 62779, 62793, 62808, 62822,
    62836, 62850, 62865, 62879, 62893, 62907, 62921, 62935,
    62949, 62963, 62977, 62991, 63005, 63019, 63032, 63046,
    63060, 63074, 63087, 63101, 63114, 63128, 63141, 63155,
    63168, 63182, 63195, 63208, 63221, 63235, 63248, 63261,
    63274, 63287, 63300, 63313, 63326, 63339, 63352, 63365,
    63378, 63390, 63403, 63416, 63429, 63441, 63454, 63466,
    63479, 63491, 63504, 63516, 63528, 63541, 63553, 63565,
    63578, 63590, 63602, 63614, 63626, 63638, 63650, 63662,
    63674, 63686, 63698, 63709, 63721, 63733, 63745, 63756,
    63768, 63779, 63791, 63803, 63814, 63825, 63837, 63848,
    63859, 63871, 63882, 63893, 63904, 63915, 63927, 63938,
    63949, 63960, 63971, 63981, 63992, 64003, 64014, 64025,
    64035, 64046, 64057, 64067, 64078, 64088, 64099, 64109,
    64120, 64130, 64140, 64151, 64161, 64171, 64181, 64192,
    64202, 64212, 64222, 64232, 64242, 64252, 64261, 64271,
    64281, 64291, 64301, 64310, 64320, 64330, 64339, 64349,
    64358, 64368, 64377, 64387, 64396, 64405, 64414, 64424,
    64433, 64442, 64451, 64460, 64469, 64478, 64487, 64496,
    64505, 64514, 64523, 64532, 64540, 64549, 64558, 64566,
    64575, 64584, 64592, 64600, 64609, 64617, 64626, 64634,
    64642, 64651, 64659, 64667, 64675, 64683, 64691, 64699,
    64707, 64715, 64723, 64731, 64739, 64747, 64754, 64762,
    64770, 64777, 64785, 64793, 64800, 64808, 64815, 64822,
    64830, 64837, 64844, 64852, 64859, 64866, 64873, 64880,
    64887, 64895, 64902, 64908, 64915, 64922, 64929, 64936,
    64943, 64949, 64956, 64963, 64969, 64976, 64982, 64989,
    64995, 65002, 65008, 65015, 65021, 65027, 65033, 65040,
    65046, 65052, 65058, 65064, 65070, 65076, 65082, 65088,
    65094, 65099, 65105, 65111, 65117, 65122, 65128, 65133,
    65139, 65144, 65150, 65155, 65161, 65166, 65171, 65177,
    65182, 65187, 65192, 65197, 65202, 65207, 65212, 65217,
    65222, 65227, 65232, 65237, 65242, 65246, 65251, 65256,
    65260, 65265, 65270, 65274, 65279, 65283, 65287, 65292,
    65296, 65300, 65305, 65309, 65313, 65317, 65321, 65325,
    65329, 65333, 65337, 65341, 65345, 65349, 65352, 65356,
    65360, 65363, 65367, 65371, 65374, 65378, 65381, 65385,
    65388, 65391, 65395, 65398, 65401, 65404, 65408, 65411,
    65414, 65417, 65420, 65423, 65426, 65429, 65431, 65434,
    65437, 65440, 65442, 65445, 65448, 65450, 65453, 65455,
    65458, 65460, 65463, 65465, 65467, 65470, 65472, 65474,
    65476, 65478, 65480, 65482, 65484, 65486, 65488, 65490,
    65492, 65494, 65496, 65497, 65499, 65501, 65502, 65504,
    65505, 65507, 65508, 65510, 65511, 65513, 65514, 65515,
    65516, 65518, 65519, 65520, 65521, 65522, 65523, 65524,
    65525, 65526, 65527, 65527, 65528, 65529, 65530, 65530,
    65531, 65531, 65532, 65532, 65533, 65533, 65534, 65534,
    65534, 65535, 65535, 65535, 65535, 65535, 65535, 65535
};

angle_t tantoangle[2049] =
{
    0, 333772, 667544, 1001315, 1335086, 1668857, 2002626, 2336395,
    2670163, 3003929, 3337694, 3671457, 4005219, 4338979, 4672736, 5006492,
    5340245, 5673995, 6007743, 6341488, 6675230, 7008968, 7342704, 7676435,
    8010164, 8343888, 8677609, 9011325, 9345037, 9678744, 10012447, 10346145,
    10679838, 11013526, 11347209, 11680887, 12014558, 12348225, 12681885, 13015539,
    13349187, 13682829, 14016464, 14350092, 14683714, 15017328, 15350936, 15684536,
    16018129, 16351714, 16685291, 17018860, 17352422, 17685974, 18019518, 18353054,
    18686582, 19020100, 19353610, 19687110, 20020600, 20354080, 20687552, 21021014,
    21354466, 21687906, 22021338, 22354758, 22688168, 23021568, 23354956, 23688332,
    24021698, 24355052, 24688396, 25021726, 25355046, 25688352, 26021648, 26354930,
    26688200, 27021456, 27354702, 27687932, 28021150, 28354356, 28687548, 29020724,
    29353888, 29687038, 30020174, 30353296, 30686404, 31019496, 31352574, 31685636,
    32018684, 32351718, 32684734, 33017736, 33350722, 33683692, 34016648, 34349584,
    34682508, 35015412, 35348300, 35681172, 36014028, 36346868, 36679688, 37012492,
    37345276, 37678044, 38010792, 38343524, 38676240, 39008936, 39341612, 39674272,
    40006912, 40339532, 40672132, 41004716, 41337276, 41669820, 42002344, 42334848,
    42667332, 42999796, 43332236, 43664660, 43997060, 44329444, 44661800, 44994140,
    45326456, 45658752, 45991028, 46323280, 46655512, 46987720, 47319908, 47652072,
    47984212, 48316332, 48648428, 48980500, 49312548, 49644576, 49976580, 50308556,
    50640512, 50972444, 51304352, 51636236, 51968096, 52299928, 52631740, 52963524,
    53295284, 53627020, 53958728, 54290412, 54622068, 54953704, 55285308, 55616888,
    55948444, 56279972, 56611472, 56942948, 57274396, 57605816, 57937212, 58268576,
    58599916, 58931228, 59262512, 59593768, 59924992, 60256192, 60587364, 60918508,
    61249620, 61580704, 61911760, 62242788, 62573788, 62904756, 63235692, 63566604,
    63897480, 64228332, 64559148, 64889940, 65220696, 65551424, 65882120, 66212788,
    66543420, 66874024, 67204600, 67535136, 67865648, 68196120, 68526568, 68856984,
    69187360, 69517712, 69848024, 70178304, 70508560, 70838776, 71168960, 71499112,
    71829224, 72159312, 72489360, 72819376, 73149360, 73479304, 73809216, 74139096,
    74468936, 74798744, 75128520, 75458264, 75787968, 76117632, 76447264, 76776864,
    77106424, 77435952, 77765440, 78094888, 78424304, 78753688, 79083032, 79412336,
    79741608, 80070840, 80400032, 80729192, 81058312, 81387392, 81716432, 82045440,
    82374408, 82703336, 83032224, 83361080, 83689896, 84018664, 84347400, 84676096,
    85004760, 85333376, 85661952, 85990488, 86318984, 86647448, 86975864, 87304240,
    87632576, 87960872, 88289128, 88617344, 88945520, 89273648, 89601736, 89929792,
    90257792, 90585760, 90913688, 91241568, 91569408, 91897200, 92224960, 92552672,
    92880336, 93207968, 93535552, 93863088, 94190584, 94518040, 94845448, 95172816,
    95500136, 95827416, 96154648, 96481832, 96808976, 97136080, 97463136, 97790144,
    98117112, 98444032, 98770904, 99097736, 99424520, 99751256, 100077944, 100404592,
    100731192, 101057744, 101384248, 101710712, 102037128, 102363488, 102689808, 103016080,
    103342312, 103668488, 103994616, 104320696, 104646736, 104972720, 105298656, 105624552,
    105950392, 106276184, 106601928, 106927624, 107253272, 107578872, 107904416, 108229920,
    108555368, 108880768, 109206120, 109531416, 109856664, 110181872, 110507016, 110832120,
    111157168, 111482168, 111807112, 112132008, 112456856, 112781648, 113106392, 113431080,
    113755720, 114080312, 114404848, 114729328, 115053760, 115378136, 115702464, 116026744,
    116350960, 116675128, 116999248, 117323312, 117647320, 117971272, 118295176, 118619024,
    118942816, 119266560, 119590248, 119913880, 120237456, 120560984, 120884456, 121207864,
    121531224, 121854528, 122177784, 122500976, 122824112, 123147200, 123470224, 123793200,
    124116120, 124438976, 124761784, 125084528, 125407224, 125729856, 126052432, 126374960,
    126697424, 127019832, 127342184, 127664472, 127986712, 128308888, 128631008, 128953072,
    129275080, 129597024, 129918912, 130240744, 130562520, 130884232, 131205888, 131527480,
    131849016, 132170496, 132491912, 132813272, 133134576, 133455816, 133776992, 134098120,
    134419184, 134740176, 135061120, 135382000, 135702816, 136023584, 136344272, 136664912,
    136985488, 137306016, 137626464, 137946864, 138267184, 138587456, 138907664, 139227808,
    139547904, 139867920, 140187888, 140507776, 140827616, 141147392, 141467104, 141786752,
    142106336, 142425856, 142745312, 143064720, 143384048, 143703312, 144022512, 144341664,
    144660736, 144979744, 145298704, 145617584, 145936400, 146255168, 146573856, 146892480,
    147211040, 147529536, 147847968, 148166336, 148484640, 148802880, 149121056, 149439152,
    149757200, 150075168, 150393072, 150710912, 151028688, 151346400, 151664048, 151981616,
    152299136, 152616576, 152933952, 153251264, 153568496, 153885680, 154202784, 154519824,
    154836784, 155153696, 155470528, 155787296, 156104000, 156420624, 156737200, 157053696,
    157370112, 157686480, 158002768, 158318976, 158635136, 158951216, 159267232, 159583168,
    159899040, 160214848, 160530592, 160846256, 161161840, 161477376, 161792832, 162108208,
    162423520, 162738768, 163053952, 163369040, 163684080, 163999040, 164313936, 164628752,
    164943504, 165258176, 165572784, 165887312, 166201776, 166516160, 166830480, 167144736,
    167458912, 167773008, 168087040, 168400992, 168714880, 169028688, 169342432, 169656096,
    169969696, 170283216, 170596672, 170910032, 171223344, 171536576, 171849728, 172162800,
    172475808, 172788736, 173101600, 173414384, 173727104, 174039728, 174352288, 174664784,
    174977200, 175289536, 175601792, 175913984, 176226096, 176538144, 176850096, 177161984,
    177473792, 177785536, 178097200, 178408784, 178720288, 179031728, 179343088, 179654368,
    179965568, 180276704, 180587744, 180898720, 181209616, 181520448, 181831184, 182141856,
    182452448, 182762960, 183073408, 183383760, 183694048, 184004240, 184314368, 184624416,
    184934400, 185244288, 185554096, 185863840, 186173504, 186483072, 186792576, 187102000,
    187411344, 187720608, 188029808, 188338912, 188647936, 188956896, 189265760, 189574560,
    189883264, 190191904, 190500448, 190808928, 191117312, 191425632, 191733872, 192042016,
    192350096, 192658096, 192966000, 193273840, 193581584, 193889264, 194196848, 194504352,
    194811792, 195119136, 195426400, 195733584, 196040688, 196347712, 196654656, 196961520,
    197268304, 197574992, 197881616, 198188144, 198494592, 198800960, 199107248, 199413456,
    199719584, 200025616, 200331584, 200637456, 200943248, 201248960, 201554576, 201860128,
    202165584, 202470960, 202776256, 203081456, 203386592, 203691632, 203996592, 204301472,
    204606256, 204910976, 205215600, 205520144, 205824592, 206128960, 206433248, 206737456,
    207041584, 207345616, 207649568, 207953424, 208257216, 208560912, 208864512, 209168048,
    209471488, 209774832, 210078112, 210381296, 210684384, 210987408, 211290336, 211593184,
    211895936, 212198608, 212501184, 212803680, 213106096, 213408432, 213710672, 214012816,
    214314880, 214616864, 214918768, 215220576, 215522288, 215823920, 216125472, 216426928,
    216728304, 217029584, 217330784, 217631904, 217932928, 218233856, 218534704, 218835472,
    219136144, 219436720, 219737216, 220037632, 220337952, 220638192, 220938336, 221238384,
    221538352, 221838240, 222138032, 222437728, 222737344, 223036880, 223336304, 223635664,
    223934912, 224234096, 224533168, 224832160, 225131072, 225429872, 225728608, 226027232,
    226325776, 226624240, 226922608, 227220880, 227519056, 227817152, 228115168, 228413088,
    228710912, 229008640, 229306288, 229603840, 229901312, 230198688, 230495968, 230793152,
    231090256, 231387280, 231684192, 231981024, 232277760, 232574416, 232870960, 233167440,
    233463808, 233760096, 234056288, 234352384, 234648384, 234944304, 235240128, 235535872,
    235831504, 236127056, 236422512, 236717888, 237013152, 237308336, 237603424, 237898416,
    238193328, 238488144, 238782864, 239077488, 239372016, 239666464, 239960816, 240255072,
    240549232, 240843312, 241137280, 241431168, 241724960, 242018656, 242312256, 242605776,
    242899200, 243192512, 243485744, 243778896, 244071936, 244364880, 244657744, 244950496,
    245243168, 245535744, 245828224, 246120608, 246412912, 246705104, 246997216, 247289216,
    247581136, 247872960, 248164688, 248456320, 248747856, 249039296, 249330640, 249621904,
    249913056, 250204128, 250495088, 250785968, 251076736, 251367424, 251658016, 251948512,
    252238912, 252529200, 252819408, 253109520, 253399536, 253689456, 253979280, 254269008,
    254558640, 254848176, 255137632, 255426976, 255716224, 256005376, 256294432, 256583392,
    256872256, 257161024, 257449696, 257738272, 258026752, 258315136, 258603424, 258891600,
    259179696, 259467696, 259755600, 260043392, 260331104, 260618704, 260906224, 261193632,
    261480960, 261768176, 262055296, 262342320, 262629248, 262916080, 263202816, 263489456,
    263776000, 264062432, 264348784, 264635024, 264921168, 265207216, 265493168, 265779024,
    266064784, 266350448, 266636000, 266921472, 267206832, 267492096, 267777264, 268062336,
    268347312, 268632192, 268916960, 269201632, 269486208, 269770688, 270055072, 270339360,
    270623552, 270907616, 271191616, 271475488, 271759296, 272042976, 272326560, 272610048,
    272893440, 273176736, 273459936, 273743040, 274026048, 274308928, 274591744, 274874432,
    275157024, 275439520, 275721920, 276004224, 276286432, 276568512, 276850528, 277132416,
    277414240, 277695936, 277977536, 278259040, 278540448, 278821728, 279102944, 279384032,
    279665056, 279945952, 280226752, 280507456, 280788064, 281068544, 281348960, 281629248,
    281909472, 282189568, 282469568, 282749440, 283029248, 283308960, 283588544, 283868032,
    284147424, 284426720, 284705920, 284985024, 285264000, 285542912, 285821696, 286100384,
    286378976, 286657440, 286935840, 287214112, 287492320, 287770400, 288048384, 288326240,
    288604032, 288881696, 289159264, 289436768, 289714112, 289991392, 290268576, 290545632,
    290822592, 291099456, 291376224, 291652896, 291929440, 292205888, 292482272, 292758528,
    293034656, 293310720, 293586656, 293862496, 294138240, 294413888, 294689440, 294964864,
    295240192, 295515424, 295790560, 296065600, 296340512, 296615360, 296890080, 297164704,
    297439200, 297713632, 297987936, 298262144, 298536256, 298810240, 299084160, 299357952,
    299631648, 299905248, 300178720, 300452128, 300725408, 300998592, 301271680, 301544640,
    301817536, 302090304, 302362976, 302635520, 302908000, 303180352, 303452608, 303724768,
    303996800, 304268768, 304540608, 304812320, 305083968, 305355520, 305626944, 305898272,
    306169472, 306440608, 306711616, 306982528, 307253344, 307524064, 307794656, 308065152,
    308335552, 308605856, 308876032, 309146112, 309416096, 309685984, 309955744, 310225408,
    310494976, 310764448, 311033824, 311303072, 311572224, 311841280, 312110208, 312379040,
    312647776, 312916416, 313184960, 313453376, 313721696, 313989920, 314258016, 314526016,
    314793920, 315061728, 315329408, 315597024, 315864512, 316131872, 316399168, 316666336,
    316933408, 317200384, 317467232, 317733984, 318000640, 318267200, 318533632, 318799968,
    319066208, 319332352, 319598368, 319864288, 320130112, 320395808, 320661408, 320926912,
    321192320, 321457632, 321722816, 321987904, 322252864, 322517760, 322782528, 323047200,
    323311744, 323576192, 323840544, 324104800, 324368928, 324632992, 324896928, 325160736,
    325424448, 325688096, 325951584, 326215008, 326478304, 326741504, 327004608, 327267584,
    327530464, 327793248, 328055904, 328318496, 328580960, 328843296, 329105568, 329367712,
    329629760, 329891680, 330153536, 330415264, 330676864, 330938400, 331199808, 331461120,
    331722304, 331983392, 332244384, 332505280, 332766048, 333026752, 333287296, 333547776,
    333808128, 334068384, 334328544, 334588576, 334848512, 335108352, 335368064, 335627712,
    335887200, 336146624, 336405920, 336665120, 336924224, 337183200, 337442112, 337700864,
    337959552, 338218112, 338476576, 338734944, 338993184, 339251328, 339509376, 339767296,
    340025120, 340282848, 340540480, 340797984, 341055392, 341312704, 341569888, 341826976,
    342083968, 342340832, 342597600, 342854272, 343110848, 343367296, 343623648, 343879904,
    344136032, 344392064, 344648000, 344903808, 345159520, 345415136, 345670656, 345926048,
    346181344, 346436512, 346691616, 346946592, 347201440, 347456224, 347710880, 347965440,
    348219872, 348474208, 348728448, 348982592, 349236608, 349490528, 349744320, 349998048,
    350251648, 350505152, 350758528, 351011808, 351264992, 351518048, 351771040, 352023872,
    352276640, 352529280, 352781824, 353034272, 353286592, 353538816, 353790944, 354042944,
    354294880, 354546656, 354798368, 355049952, 355301440, 355552800, 355804096, 356055264,
    356306304, 356557280, 356808128, 357058848, 357309504, 357560032, 357810464, 358060768,
    358311008, 358561088, 358811104, 359060992, 359310784, 359560480, 359810048, 360059520,
    360308896, 360558144, 360807296, 361056352, 361305312, 361554144, 361802880, 362051488,
    362300032, 362548448, 362796736, 363044960, 363293056, 363541024, 363788928, 364036704,
    364284384, 364531936, 364779392, 365026752, 365274016, 365521152, 365768192, 366015136,
    366261952, 366508672, 366755296, 367001792, 367248192, 367494496, 367740704, 367986784,
    368232768, 368478656, 368724416, 368970080, 369215648, 369461088, 369706432, 369951680,
    370196800, 370441824, 370686752, 370931584, 371176288, 371420896, 371665408, 371909792,
    372154080, 372398272, 372642336, 372886304, 373130176, 373373952, 373617600, 373861152,
    374104608, 374347936, 374591168, 374834304, 375077312, 375320224, 375563040, 375805760,
    376048352, 376290848, 376533248, 376775520, 377017696, 377259776, 377501728, 377743584,
    377985344, 378227008, 378468544, 378709984, 378951328, 379192544, 379433664, 379674688,
    379915584, 380156416, 380397088, 380637696, 380878176, 381118560, 381358848, 381599040,
    381839104, 382079072, 382318912, 382558656, 382798304, 383037856, 383277280, 383516640,
    383755840, 383994976, 384233984, 384472896, 384711712, 384950400, 385188992, 385427488,
    385665888, 385904160, 386142336, 386380384, 386618368, 386856224, 387093984, 387331616,
    387569152, 387806592, 388043936, 388281152, 388518272, 388755296, 388992224, 389229024,
    389465728, 389702336, 389938816, 390175200, 390411488, 390647680, 390883744, 391119712,
    391355584, 391591328, 391826976, 392062528, 392297984, 392533312, 392768544, 393003680,
    393238720, 393473632, 393708448, 393943168, 394177760, 394412256, 394646656, 394880960,
    395115136, 395349216, 395583200, 395817088, 396050848, 396284512, 396518080, 396751520,
    396984864, 397218112, 397451264, 397684288, 397917248, 398150080, 398382784, 398615424,
    398847936, 399080320, 399312640, 399544832, 399776928, 400008928, 400240832, 400472608,
    400704288, 400935872, 401167328, 401398720, 401629984, 401861120, 402092192, 402323136,
    402553984, 402784736, 403015360, 403245888, 403476320, 403706656, 403936896, 404167008,
    404397024, 404626944, 404856736, 405086432, 405316032, 405545536, 405774912, 406004224,
    406233408, 406462464, 406691456, 406920320, 407149088, 407377760, 407606336, 407834784,
    408063136, 408291392, 408519520, 408747584, 408975520, 409203360, 409431072, 409658720,
    409886240, 410113664, 410340992, 410568192, 410795296, 411022304, 411249216, 411476032,
    411702720, 411929312, 412155808, 412382176, 412608480, 412834656, 413060736, 413286720,
    413512576, 413738336, 413964000, 414189568, 414415040, 414640384, 414865632, 415090784,
    415315840, 415540800, 415765632, 415990368, 416215008, 416439552, 416663968, 416888288,
    417112512, 417336640, 417560672, 417784576, 418008384, 418232096, 418455712, 418679200,
    418902624, 419125920, 419349120, 419572192, 419795200, 420018080, 420240864, 420463552,
    420686144, 420908608, 421130976, 421353280, 421575424, 421797504, 422019488, 422241344,
    422463104, 422684768, 422906336, 423127776, 423349120, 423570400, 423791520, 424012576,
    424233536, 424454368, 424675104, 424895744, 425116288, 425336736, 425557056, 425777280,
    425997408, 426217440, 426437376, 426657184, 426876928, 427096544, 427316064, 427535488,
    427754784, 427974016, 428193120, 428412128, 428631040, 428849856, 429068544, 429287168,
    429505664, 429724064, 429942368, 430160576, 430378656, 430596672, 430814560, 431032352,
    431250048, 431467616, 431685120, 431902496, 432119808, 432336992, 432554080, 432771040,
    432987936, 433204736, 433421408, 433637984, 433854464, 434070848, 434287104, 434503296,
    434719360, 434935360, 435151232, 435367008, 435582656, 435798240, 436013696, 436229088,
    436444352, 436659520, 436874592, 437089568, 437304416, 437519200, 437733856, 437948416,
    438162880, 438377248, 438591520, 438805696, 439019744, 439233728, 439447584, 439661344,
    439875008, 440088576, 440302048, 440515392, 440728672, 440941824, 441154880, 441367872,
    441580736, 441793472, 442006144, 442218720, 442431168, 442643552, 442855808, 443067968,
    443280032, 443492000, 443703872, 443915648, 444127296, 444338880, 444550336, 444761696,
    444972992, 445184160, 445395232, 445606176, 445817056, 446027840, 446238496, 446449088,
    446659552, 446869920, 447080192, 447290400, 447500448, 447710432, 447920320, 448130112,
    448339776, 448549376, 448758848, 448968224, 449177536, 449386720, 449595808, 449804800,
    450013664, 450222464, 450431168, 450639776, 450848256, 451056640, 451264960, 451473152,
    451681248, 451889248, 452097152, 452304960, 452512672, 452720288, 452927808, 453135232,
    453342528, 453549760, 453756864, 453963904, 454170816, 454377632, 454584384, 454791008,
    454997536, 455203968, 455410304, 455616544, 455822688, 456028704, 456234656, 456440512,
    456646240, 456851904, 457057472, 457262912, 457468256, 457673536, 457878688, 458083744,
    458288736, 458493600, 458698368, 458903040, 459107616, 459312096, 459516480, 459720768,
    459924960, 460129056, 460333056, 460536960, 460740736, 460944448, 461148064, 461351584,
    461554976, 461758304, 461961536, 462164640, 462367680, 462570592, 462773440, 462976160,
    463178816, 463381344, 463583776, 463786144, 463988384, 464190560, 464392608, 464594560,
    464796448, 464998208, 465199872, 465401472, 465602944, 465804320, 466005600, 466206816,
    466407904, 466608896, 466809824, 467010624, 467211328, 467411936, 467612480, 467812896,
    468013216, 468213440, 468413600, 468613632, 468813568, 469013440, 469213184, 469412832,
    469612416, 469811872, 470011232, 470210528, 470409696, 470608800, 470807776, 471006688,
    471205472, 471404192, 471602784, 471801312, 471999712, 472198048, 472396288, 472594400,
    472792448, 472990400, 473188256, 473385984, 473583648, 473781216, 473978688, 474176064,
    474373344, 474570528, 474767616, 474964608, 475161504, 475358336, 475555040, 475751648,
    475948192, 476144608, 476340928, 476537184, 476733312, 476929376, 477125344, 477321184,
    477516960, 477712640, 477908224, 478103712, 478299104, 478494400, 478689600, 478884704,
    479079744, 479274656, 479469504, 479664224, 479858880, 480053408, 480247872, 480442240,
    480636512, 480830656, 481024736, 481218752, 481412640, 481606432, 481800128, 481993760,
    482187264, 482380704, 482574016, 482767264, 482960416, 483153472, 483346432, 483539296,
    483732064, 483924768, 484117344, 484309856, 484502240, 484694560, 484886784, 485078912,
    485270944, 485462880, 485654720, 485846464, 486038144, 486229696, 486421184, 486612576,
    486803840, 486995040, 487186176, 487377184, 487568096, 487758912, 487949664, 488140320,
    488330880, 488521312, 488711712, 488901984, 489092160, 489282240, 489472256, 489662176,
    489851968, 490041696, 490231328, 490420896, 490610336, 490799712, 490988960, 491178144,
    491367232, 491556224, 491745120, 491933920, 492122656, 492311264, 492499808, 492688256,
    492876608, 493064864, 493253056, 493441120, 493629120, 493817024, 494004832, 494192544,
    494380160, 494567712, 494755136, 494942496, 495129760, 495316928, 495504000, 495691008,
    495877888, 496064704, 496251424, 496438048, 496624608, 496811040, 496997408, 497183680,
    497369856, 497555936, 497741920, 497927840, 498113632, 498299360, 498484992, 498670560,
    498856000, 499041376, 499226656, 499411840, 499596928, 499781920, 499966848, 500151680,
    500336416, 500521056, 500705600, 500890080, 501074464, 501258752, 501442944, 501627040,
    501811072, 501995008, 502178848, 502362592, 502546240, 502729824, 502913312, 503096704,
    503280000, 503463232, 503646368, 503829408, 504012352, 504195200, 504377984, 504560672,
    504743264, 504925760, 505108192, 505290496, 505472736, 505654912, 505836960, 506018944,
    506200832, 506382624, 506564320, 506745952, 506927488, 507108928, 507290272, 507471552,
    507652736, 507833824, 508014816, 508195744, 508376576, 508557312, 508737952, 508918528,
    509099008, 509279392, 509459680, 509639904, 509820032, 510000064, 510180000, 510359872,
    510539648, 510719328, 510898944, 511078432, 511257856, 511437216, 511616448, 511795616,
    511974688, 512153664, 512332576, 512511392, 512690112, 512868768, 513047296, 513225792,
    513404160, 513582432, 513760640, 513938784, 514116800, 514294752, 514472608, 514650368,
    514828064, 515005664, 515183168, 515360608, 515537952, 515715200, 515892352, 516069440,
    516246432, 516423328, 516600160, 516776896, 516953536, 517130112, 517306592, 517482976,
    517659264, 517835488, 518011616, 518187680, 518363648, 518539520, 518715296, 518891008,
    519066624, 519242144, 519417600, 519592960, 519768256, 519943424, 520118528, 520293568,
    520468480, 520643328, 520818112, 520992800, 521167392, 521341888, 521516320, 521690656,
    521864896, 522039072, 522213152, 522387168, 522561056, 522734912, 522908640, 523082304,
    523255872, 523429376, 523602784, 523776096, 523949312, 524122464, 524295552, 524468512,
    524641440, 524814240, 524986976, 525159616, 525332192, 525504640, 525677056, 525849344,
    526021568, 526193728, 526365792, 526537760, 526709632, 526881440, 527053152, 527224800,
    527396352, 527567840, 527739200, 527910528, 528081728, 528252864, 528423936, 528594880,
    528765760, 528936576, 529107296, 529277920, 529448480, 529618944, 529789344, 529959648,
    530129856, 530300000, 530470048, 530640000, 530809888, 530979712, 531149440, 531319072,
    531488608, 531658080, 531827488, 531996800, 532166016, 532335168, 532504224, 532673184,
    532842080, 533010912, 533179616, 533348288, 533516832, 533685312, 533853728, 534022048,
    534190272, 534358432, 534526496, 534694496, 534862400, 535030240, 535197984, 535365632,
    535533216, 535700704, 535868128, 536035456, 536202720, 536369888, 536536992, 536704000,
    536870912
};
</t>
<t tx="T1487">#include "i_defs.h"
#include "lu_math.h"
</t>
<t tx="T1488">
int SlopeDiv(unsigned int num, unsigned int den)
{
  unsigned ans;

  if (den &lt; 512)
    return SLOPERANGE;

  ans = (num &lt;&lt; 3) / (den &gt;&gt; 8);

  return ans &lt;= SLOPERANGE ? ans : SLOPERANGE;
}
</t>
<t tx="T1489">@ignore
@language c

// Arguments/Parameters Code

&lt;&lt; m_argv #includes &gt;&gt;
&lt;&lt; m_argv declarations &gt;&gt;
@others
</t>
<t tx="T1490">#include "i_defs.h"
#include "m_argv.h"
</t>
<t tx="T1491">
static int myargc;
static const char **myargv = NULL;

// this one is here to avoid infinite recursion of param files.
typedef struct added_parm_s
{
  const char *name;
  struct added_parm_s *next;
}
added_parm_t;

static added_parm_t *added_parms;
</t>
<t tx="T1492">@ AddArgument

Helper function that adds s to the argument list.
Must use realloc, since this is done before Z_Init
@c

static void AddArgument(const char *s, int pos)
{
  int i;

#ifdef DEVELOPERS
  L_WriteDebug("Adding parameter '%s'\n", s);
#endif

  DEV_ASSERT2(pos &gt;= 0 &amp;&amp; pos &lt;= myargc);

  if (s[0] == '@')
  {  // add it as a response file
    M_ApplyResponseFile(&amp;s[1], pos);
    return;
  }

  myargc++;
  myargv = realloc((void*)myargv, myargc * sizeof(char *));
  if (!myargv)
    I_Error("AddArgument: Out of memory!");

  // move any parameters forward
  for (i = myargc - 1; i &gt; pos; i--)
    myargv[i] = myargv[i - 1];

  myargv[pos] = s;
}
</t>
<t tx="T1493">@ M_CheckNextParm

Checks for the given parameter in the program's command line arguments.
Starts at parameter prev+1, so this routine is useful if you want to
check for several equal parameters (pass the last parameter number as
prev).

Returns the argument number (last+1 to argc-1)
or 0 if not present

-ES- 2000/01/01 Written.
@c

int M_CheckNextParm(const char *check, int prev)
{
  int i;

  for (i = prev + 1; i &lt; myargc; i++)
  {
    if (!stricmp(check, myargv[i]))
      return i;
  }

  return 0;
}
</t>
<t tx="T1494">@ M_CheckParm

Checks for the given parameter
in the program's command line arguments.
Returns the argument number (1 to argc-1)
or 0 if not present
@c

int M_CheckParm(const char *check)
{
  return M_CheckNextParm(check, 0);
}
</t>
<t tx="T1495">@ M_GetParm

Checks for the string in the command line, and returns the parameter after
if it exists. Useful for all those parameters that look something like
"-foo bar".
@c

const char *M_GetParm(const char *check)
{
  int p;

  p = M_CheckParm(check);
  if (p &amp;&amp; p + 1 &lt; myargc)
    return myargv[p + 1];
  else
    return NULL;
}
</t>
<t tx="T1496">@ M_ApplyResponseFile

Adds a response file
@c

void M_ApplyResponseFile(const char *name, int position)
{
  char buf[1024];
  FILE *f;
  added_parm_t this_parm;
  added_parm_t *p;

  // check if the file has already been added
  for (p = added_parms; p; p = p-&gt;next)
  {
    if (!strcmp(p-&gt;name, name))
      return;
  }

  // mark that this file has been added
  this_parm.name = name;
  p = this_parm.next = added_parms;

  // add arguments from the given file
  f = fopen(name, "rb");
  if (!f)
    I_Error("Couldn't open \"%s\" for reading!", name);

  for (; EOF != fscanf(f, "%s", buf); position++)
    // we must use strdup: Z_Init might not have been called
    AddArgument(strdup(buf), position);

  // unlink from list
  added_parms = p;

  fclose(f);
}
</t>
<t tx="T1497">@ M_InitArguments

Initialises the CheckParm system. Only called once, by main().
@c

void M_InitArguments(int argc, const char **argv)
{
  int i;

  // argv[0] should always be placed before the response file.
  AddArgument(argv[0], 0);

  if (I_Access("edge.cmd"))
    M_ApplyResponseFile("edge.cmd", 1);

  // scan through the arguments
  for (i = 1; i &lt; argc; i++)
  {
    // add all new arguments to the end of the arg list.
    AddArgument(argv[i], myargc);
  }
}
</t>
<t tx="T1498">@ M_CheckBooleanParm

Sets boolean variable to true if parm (prefixed with `-') is
present, sets it to false if parm prefixed with `-no' is present,
otherwise leaves it unchanged.

-AJA- 1999/10/18: written.
@c

void M_CheckBooleanParm(const char *parm, boolean_t *bool, boolean_t reverse)
{
  char parmbuf[100];

  sprintf(parmbuf, "-%s", parm);

  if (M_CheckParm(parmbuf) &gt; 0)
  {
    *bool = ! reverse;
    return;
  }

  sprintf(parmbuf, "-no%s", parm);

  if (M_CheckParm(parmbuf) &gt; 0)
  {
    *bool = reverse;
    return;
  }
}
</t>
<t tx="T1499">@ M_GetArguments

FIXME: Remove, nobody should need this
(use GetArgumentCount/GetArgument instead)
@c

const char **M_GetArguments(int *ret_argc)
{
  *ret_argc = myargc;
  return myargv;
}
</t>
<t tx="T1500">@ M_GetArguments

Returns the wished argument. argnum must be less than M_GetArgCount().
@c

const char *M_GetArgument(int argnum)
{
  // this should never happen, so crash out if DEVELOPERS.
  if (argnum &lt;= 0 || argnum &gt;= myargc)
#ifdef DEVELOPERS
    I_Error("M_GetArgument: Out of range (%d)", argnum);
#else
    return "";
#endif

  return myargv[argnum];
}
</t>
<t tx="T1501">@ M_GetArgCount

Returns the number of program arguments.
@c

int M_GetArgCount(void)
{
  return myargc;
}
</t>
<t tx="T1502">@ignore
@language c

// Bounding Box Code

&lt;&lt; m_bbox #includes &gt;&gt;
@others
</t>
<t tx="T1503">#include "i_defs.h"
#include "m_bbox.h"
</t>
<t tx="T1504">
void M_ClearBox(float_t * box)
{
  box[BOXTOP] = box[BOXRIGHT] = INT_MIN;
  box[BOXBOTTOM] = box[BOXLEFT] = INT_MAX;
}
</t>
<t tx="T1505">
void M_AddToBox(float_t * box, float_t x, float_t y)
{
  if (x &lt; box[BOXLEFT])
    box[BOXLEFT] = x;

  if (x &gt; box[BOXRIGHT])
    box[BOXRIGHT] = x;

  if (y &lt; box[BOXBOTTOM])
    box[BOXBOTTOM] = y;

  if (y &gt; box[BOXTOP])
    box[BOXTOP] = y;
}
</t>
<t tx="T1506">
void M_CopyBox(float_t * box, float_t * other)
{
  box[BOXLEFT]   = other[BOXLEFT];
  box[BOXRIGHT]  = other[BOXRIGHT];
  box[BOXTOP]    = other[BOXTOP];
  box[BOXBOTTOM] = other[BOXBOTTOM];
}
</t>
<t tx="T1507">
void M_UnionBox(float_t * box, float_t * other)
{
  if (other[BOXLEFT] &lt; box[BOXLEFT])
    box[BOXLEFT] = other[BOXLEFT];

  if (other[BOXRIGHT] &gt; box[BOXRIGHT])
    box[BOXRIGHT] = other[BOXRIGHT];
    
  if (other[BOXBOTTOM] &lt; box[BOXBOTTOM])
    box[BOXBOTTOM] = other[BOXBOTTOM];

  if (other[BOXTOP] &gt; box[BOXTOP])
    box[BOXTOP] = other[BOXTOP];
}
</t>
<t tx="T1508">@ DIRTY REGION HANDLING
@c

byte dirty_region[DIRT_REG_H][DIRT_REG_W];

boolean_t dirty_region_whole = true;
boolean_t dirty_region_always = false;

//
// M_CleanMatrix
//
// Make the dirty matrix totally clean (spick and span).

void M_CleanMatrix(void)
{
  dirty_region_whole = false;

  memset(dirty_region, 0, sizeof(dirty_region));
}
</t>
<t tx="T1509">@ M_DirtyMatrix

Make the dirty matrix totally dirty.
@c

void M_DirtyMatrix(void)
{
  if (dirty_region_whole)
    return;

  dirty_region_whole = true;

  memset(dirty_region, 1, sizeof(dirty_region));
}
</t>
<t tx="T1510">@ M_DirtyRegion

Coordinates are in screen pixels (inclusive).
@c

void M_DirtyRegion(int x1, int y1, int x2, int y2)
{
  int x;

  if (dirty_region_whole)
    return;

  DEV_ASSERT2(x1 &gt;= 0);  DEV_ASSERT2(y1 &gt;= 0);
  DEV_ASSERT2(x1 &lt;= x2); DEV_ASSERT2(y1 &lt;= y2);

  x1 /= DIRT_X; y1 /= DIRT_Y;
  x2 /= DIRT_X; y2 /= DIRT_Y;

  DEV_ASSERT2(x2 &lt; DIRT_REG_W); 
  DEV_ASSERT2(y2 &lt; DIRT_REG_H);

  for (; y1 &lt;= y2; y1++)
  {
    for (x=x1; x &lt;= x2; x++)
      dirty_region[y1][x] = 1;
  }
}
</t>
<t tx="T1511">@ignore
@language c

// Cheat Sequence Checking

// -KM- 1998/07/21 Moved the cheat sequence here from st_stuff.c
//                 ST_Responder in st_stuff.c calls cht_Responder to check for
//                 cheat codes.  Also added NO_NIGHTMARE_CHEATS #define.
//                 if defined, there can be no cheating in nightmare. :-)
//                 Made all the cheat codes non global.
//
// -ACB- 1998/07/30 Naming Convention stuff, all procedures m_*.*.
//                  Added Touching Mobj "Cheat".
//
// -ACB- 1999/09/19 CD Audio cheats removed.

&lt;&lt; m_cheat #includes &gt;&gt;
&lt;&lt; m_cheat declarations &gt;&gt;
@others
</t>
<t tx="T1512">#include "i_defs.h"
#include "m_cheat.h"

#include "con_main.h"
#include "m_fixed.h"
#include "ddf_main.h"
#include "dstrings.h"
#include "g_game.h"
#include "m_menu.h"
#include "s_sound.h"
#include "p_local.h"
#include "p_mobj.h"
#include "p_bot.h"
#include "st_stuff.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1513">
//
// CHEAT SEQUENCE PACKAGE
//
// This is so hackers couldn't discover the cheat codes.
#define SCRAMBLE(a) (a)

static int firsttime = 1;
static unsigned char cheat_xlate_table[256];

static cheatseq_t cheat_powerup[9] =
{
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},  // -MH- 1998/06/17  added "give jetpack" cheat
    {0, 0}  // -ACB- 1998/07/15  added "give nightvision" cheat
};

static cheatseq_t cheat_mus               = {0, 0};
static cheatseq_t cheat_mypos             = {0, 0};
static cheatseq_t cheat_showstats         = {0, 0};
static cheatseq_t cheat_spawnbot          = {0, 0};

static cheatseq_t cheat_choppers          = {0, 0};
static cheatseq_t cheat_clev              = {0, 0};
static cheatseq_t cheat_killall           = {0, 0};
static cheatseq_t cheat_suicide           = {0, 0};
static cheatseq_t cheat_keys              = {0, 0};
static cheatseq_t cheat_loaded            = {0, 0};
static cheatseq_t cheat_takeall           = {0, 0};
static cheatseq_t cheat_god               = {0, 0};
static cheatseq_t cheat_lazarus           = {0, 0};
static cheatseq_t cheat_ammo              = {0, 0};
static cheatseq_t cheat_ammonokey         = {0, 0};
static cheatseq_t cheat_noclip            = {0, 0};
static cheatseq_t cheat_commercial_noclip = {0, 0};
static cheatseq_t cheat_hom               = {0, 0};

static cheatseq_t cheat_giveweapon[11] =
{
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
};
</t>
<t tx="T1514">@ M_CheckCheat

Called in M_CheatResponder module, which handles the input.
Returns a 1 if the cheat was successful, 0 if failed.
@c

int M_CheckCheat(cheatseq_t * cht, char key)
{
  int i;
  int rc = 0;

  if (firsttime)
  {
    firsttime = 0;
    for (i = 0; i &lt; 256; i++)
      cheat_xlate_table[i] = SCRAMBLE(i);
  }

  if (!cht-&gt;p)
    cht-&gt;p = cht-&gt;sequence;  // initialise if first time

  if (cheat_xlate_table[(unsigned char)key] == *cht-&gt;p)
    cht-&gt;p++;
  else
    cht-&gt;p = cht-&gt;sequence;

  if (*cht-&gt;p == 0)
  {  // end of sequence character

    cht-&gt;p = cht-&gt;sequence;
    rc = 1;
  }

  return rc;
}
</t>
<t tx="T1515">
static void M_ChangeLevelCheat(char *string)
{
  // User pressed &lt;ESC&gt;
  if (!string)
    return;

  if (! G_DeferedInitNew(gameskill, string, false))
  {
    CON_MessageLDF("ImpossibleChange");
    return;
  }

  CON_MessageLDF("LevelChange");
  Z_Free(string);
}
</t>
<t tx="T1516">@ M_ChangeMusicCheat
@c

static void M_ChangeMusicCheat(char *string)
{
  int entry_num;

  // User pressed &lt;ESC&gt;
  if (! string)
    return;
  
  entry_num = atoi(string);

  Z_Free(string);
  
  if (! entry_num)
    return;

  S_ChangeMusic(entry_num, true);
  CON_MessageLDF("MusChange");
}
</t>
<t tx="T1517">
boolean_t M_CheatResponder(event_t * ev)
{
  int i, j;
  char key;
  player_t *pl = consoleplayer;

#ifdef NOCHEATS
  return false;
#endif

  // if a user keypress...
  if (ev-&gt;type != ev_keydown)
    return false;
  key = (char) ev-&gt;value.key;
  
  // no cheating in netgames or if disallowed in levels.ddf
  if (netgame || !level_flags.cheats)
    return false;

  // 'dqd' cheat for toggleable god mode
  if (M_CheckCheat(&amp;cheat_god, key))
  {
    pl-&gt;cheats ^= CF_GODMODE;
    if (pl-&gt;cheats &amp; CF_GODMODE)
    {
      if (pl-&gt;mo)
      {
        pl-&gt;health = pl-&gt;mo-&gt;health = pl-&gt;mo-&gt;info-&gt;spawnhealth;
      }
      CON_MessageLDF("GodModeOn");
    }
    else
      CON_MessageLDF("GodModeOff");
  }

  // 'fa' cheat for killer fucking arsenal
  //
  // -ACB- 1998/06/26 removed backpack from this as backpack is variable
  //
  else if (M_CheckCheat(&amp;cheat_ammonokey, key))
  {
    pl-&gt;armours[CHEATARMOURTYPE] = CHEATARMOUR;

    for (i=num_disabled_weapons; i &lt; numweapons; i++)
      P_AddWeapon(pl, weaponinfo[i], NULL);
    
    for (i = 0; i &lt; NUMAMMO; i++)
      pl-&gt;ammo[i].num = pl-&gt;ammo[i].max;

    stbar_update = true;
    P_UpdateAvailWeapons(pl);

    CON_MessageLDF("AmmoAdded");
  }

  // 'kfa' cheat for key full ammo
  //
  // -ACB- 1998/06/26 removed backpack from this as backpack is variable
  //
  else if (M_CheckCheat(&amp;cheat_ammo, key))
  {
    pl-&gt;armours[CHEATARMOURTYPE] = CHEATARMOUR;

    for (i=num_disabled_weapons; i &lt; numweapons; i++)
      P_AddWeapon(pl, weaponinfo[i], NULL);

    for (i = 0; i &lt; NUMAMMO; i++)
      pl-&gt;ammo[i].num = 
        pl-&gt;ammo[i].max;

    pl-&gt;cards = KF_MASK;

    // refresh to add all stuff to status bar
    stbar_update = true;
    P_UpdateAvailWeapons(pl);

    CON_MessageLDF("VeryHappyAmmo");
  }
  else if (M_CheckCheat(&amp;cheat_keys, key))
  {
    pl-&gt;cards = KF_MASK;

    // refresh to remove all stuff from status bar
    stbar_update = true;

    CON_MessageLDF("UnlockCheat");
  }
  else if (M_CheckCheat(&amp;cheat_loaded, key))
  {
    for (i = 0; i &lt; NUMAMMO; i++)
      pl-&gt;ammo[i].num = pl-&gt;ammo[i].max;

    CON_MessageLDF("LoadedCheat");
  }
#if 0  // FIXME: this crashes ?
  else if (M_CheckCheat(&amp;cheat_takeall, key))
  {
    P_GiveInitialBenefits(pl, pl-&gt;mo-&gt;info);

    // -ACB- 1998/08/26 Stuff removed language reference
    CON_MessageLDF("StuffRemoval");
  }
#endif
  else if (M_CheckCheat(&amp;cheat_suicide, key))
  {
    P_DamageMobj(pl-&gt;mo, NULL, pl-&gt;mo, 10000, NULL);

    // -ACB- 1998/08/26 Suicide language reference
    CON_MessageLDF("SuicideCheat");
  }
  // -ACB- 1998/08/27 Used Mobj linked-list code, much cleaner.
  else if (M_CheckCheat(&amp;cheat_killall, key))
  {
    int killcount = 0;
    mobj_t *currmobj;

    // Note: this may miss monsters spawned during death frames (like
    // when the Pain Elemental dies).

    for (currmobj=mobjlisthead; currmobj; currmobj=currmobj-&gt;next)
    {
      if ((currmobj-&gt;extendedflags &amp; EF_MONSTER) &amp;&amp; (currmobj-&gt;health &gt; 0))
      {
        P_DamageMobj(currmobj, NULL, NULL, 10000, NULL);
        killcount++;
      }
    }

    CON_MessageLDF("MonstersKilled", killcount);
  }
  // Simplified, accepting both "noclip" and "idspispopd".
  // no clipping mode cheat
  else if (M_CheckCheat(&amp;cheat_noclip, key)
      || M_CheckCheat(&amp;cheat_commercial_noclip, key))
  {
    pl-&gt;cheats ^= CF_NOCLIP;

    if (pl-&gt;cheats &amp; CF_NOCLIP)
      CON_MessageLDF("ClipOn");
    else
      CON_MessageLDF("ClipOff");
  }
  else if (M_CheckCheat(&amp;cheat_hom, key))
  {
    hom_detect = ! hom_detect;

    if (hom_detect)
      CON_MessageLDF("HomDetectOn");
    else
      CON_MessageLDF("HomDetectOff");
  }
#ifdef DEVELOPERS
  else if (M_CheckCheat(&amp;cheat_lazarus, key))
  {
    if (pl-&gt;playerstate == PST_DEAD &amp;&amp; (netgame==0))
    {
      DEV_ASSERT2(pl-&gt;mo);
      P_BringCorpseToLife(pl-&gt;mo);
    }
  }
#endif

  // 'behold?' power-up cheats
  for (i = 0; i &lt; 9; i++)
  {
    if (M_CheckCheat(&amp;cheat_powerup[i], key))
    {
      if (!pl-&gt;powers[i])
        pl-&gt;powers[i] = 60 * TICRATE;
      else
        pl-&gt;powers[i] = 0;

      CON_MessageLDF("BeholdUsed");
    }
  }

#if 0  // -AJA- eh ?
  // 'behold' power-up menu
  if (M_CheckCheat(&amp;cheat_powerup[9], key))
  {
    CON_MessageLDF("BeholdNote");
  }
#endif

  // 'give#' power-up cheats
  for (i = 0; i &lt; 10; i++)
  {
    if (! M_CheckCheat(&amp;cheat_giveweapon[i + 1], key))
      continue;

    for (j=0; j &lt; weaponkey[i].numchoices; j++)
    {
      weaponinfo_t *info = weaponkey[i].choices[j];

      P_AddWeapon(pl, info, NULL);

      if (info-&gt;ammo &gt;= 0)
        pl-&gt;ammo[info-&gt;ammo].num = pl-&gt;ammo[info-&gt;ammo].max;
    }
  }

  // 'choppers' invulnerability &amp; chainsaw
  if (M_CheckCheat(&amp;cheat_choppers, key))
  {
    int w_num = DDF_WeaponLookup("CHAINSAW");

    if (w_num &gt;= 0)
    {
      P_AddWeapon(pl, weaponinfo[w_num], NULL);
      pl-&gt;powers[PW_Invulnerable] = 1;
      CON_MessageLDF("CHOPPERSNote");
    }
  }

  // 'mypos' for player position
  else if (M_CheckCheat(&amp;cheat_mypos, key))
  {
    CON_Message("ang=%f;x,y=(%f,%f)",
        pl-&gt;mo-&gt;angle * 45.0 / ANG45, pl-&gt;mo-&gt;x, pl-&gt;mo-&gt;y);
  }

  // 'clev' change-level cheat
  if (M_CheckCheat(&amp;cheat_clev, key))
    M_StartMessageInput(DDF_LanguageLookup("LevelQ"), M_ChangeLevelCheat);

  // 'mus' cheat for changing music
  else if (M_CheckCheat(&amp;cheat_mus, key))
    M_StartMessageInput(DDF_LanguageLookup("MusicQ"), M_ChangeMusicCheat);
  else if (M_CheckCheat(&amp;cheat_spawnbot, key))
  {
    BOT_DMSpawn();
    CON_MessageLDF("BotSpawn");
  }
  else if (M_CheckCheat(&amp;cheat_showstats, key))
    showstats = !showstats;

  return false;
}
</t>
<t tx="T1518">@ -KM- 1999/01/31 Loads cheats from languages file.
-ES- 1999/08/26 Removed M_ConvertCheat stuff, the cheat terminator is
now just 0.
@c

void M_CheatInit(void)
{
  int i;
  char temp[16];

  // Now what?
  cheat_mus.sequence = DDF_LanguageLookup("idmus");
  cheat_god.sequence = DDF_LanguageLookup("iddqd");
  cheat_lazarus.sequence = "idlazarus";
  cheat_ammo.sequence = DDF_LanguageLookup("idkfa");
  cheat_ammonokey.sequence = DDF_LanguageLookup("idfa");
  cheat_noclip.sequence = DDF_LanguageLookup("idspispopd");
  cheat_commercial_noclip.sequence = DDF_LanguageLookup("idclip");
  cheat_hom.sequence = DDF_LanguageLookup("idhom");

  for (i=0; i &lt; 9; i++)
  {
    sprintf(temp, "idbehold%d", i + 1);
    cheat_powerup[i].sequence = DDF_LanguageLookup(temp);
  }

  cheat_choppers.sequence = DDF_LanguageLookup("idchoppers");
  cheat_clev.sequence = DDF_LanguageLookup("idclev");
  cheat_mypos.sequence = DDF_LanguageLookup("idmypos");

  //new cheats
  cheat_killall.sequence = DDF_LanguageLookup("idkillall");
  cheat_showstats.sequence = DDF_LanguageLookup("idinfo");
  cheat_suicide.sequence = DDF_LanguageLookup("idsuicide");
  cheat_keys.sequence = DDF_LanguageLookup("idunlock");
  cheat_loaded.sequence = DDF_LanguageLookup("idloaded");
  cheat_takeall.sequence = DDF_LanguageLookup("idtakeall");

  cheat_spawnbot.sequence = DDF_LanguageLookup("idbot");

  for (i = 0; i &lt; 11; i++)
  {
    sprintf(temp, "idgive%d", i);
    cheat_giveweapon[i].sequence = DDF_LanguageLookup(temp);
  }
}
</t>
<t tx="T1519">@ignore
@language c

// Cyclic Rendundancy Checks

//  Based on the Adler-32 algorithm as described in RFC-1950.

&lt;&lt; m_crc32 #includes &gt;&gt;
@others
</t>
<t tx="T1520">#include "i_defs.h"
#include "m_math.h"

#include &lt;math.h&gt;
</t>
<t tx="T1521">@ CORE ROUTINES
@c

void CRC32_Init(unsigned long *crc)
{
  (*crc) = 1;
}
</t>
<t tx="T1522">
void CRC32_ProcessByte(unsigned long *crc, byte data)
{
  unsigned long s1 = (*crc) &amp; 0xFFFF;
  unsigned long s2 = ((*crc) &gt;&gt; 16) &amp; 0xFFFF;

  s1 = (s1 + data) % 65521;
  s2 = (s2 + s1)   % 65521;
  
  (*crc) = (s2 &lt;&lt; 16) | s1;
}
</t>
<t tx="T1523">
void CRC32_ProcessBlock(unsigned long *crc, const byte *data, int len)
{
  unsigned long s1 = (*crc) &amp; 0xFFFF;
  unsigned long s2 = ((*crc) &gt;&gt; 16) &amp; 0xFFFF;

  for (; len &gt; 0; data++, len--)
  {
    s1 = (s1 + data[0]) % 65521;
    s2 = (s2 + s1)      % 65521;
  }

  (*crc) = (s2 &lt;&lt; 16) | s1;
}
</t>
<t tx="T1524">
void CRC32_Done(unsigned long *crc)
{
  // nothing to do
}
</t>
<t tx="T1525">@ UTILITY ROUTINES
@c

void CRC32_ProcessInt(unsigned long *crc, int value)
{
  CRC32_ProcessByte(crc, (byte) (value &gt;&gt; 24));
  CRC32_ProcessByte(crc, (byte) (value &gt;&gt; 16));
  CRC32_ProcessByte(crc, (byte) (value &gt;&gt; 8));
  CRC32_ProcessByte(crc, (byte) (value));
}
</t>
<t tx="T1526">
void CRC32_ProcessFixed(unsigned long *crc, fixed_t value)
{
  CRC32_ProcessInt(crc, (int) value);
}
</t>
<t tx="T1527">
void CRC32_ProcessFloat(unsigned long *crc, float_t value)
{
  int exp;
  int mant;
  boolean_t neg;

  neg = (value &lt; 0.0);
  value = fabs(value);

  mant = (int) ldexp(frexp(value, &amp;exp), 30);

  CRC32_ProcessByte(crc, (byte) (neg ? '-' : '+'));
  CRC32_ProcessInt(crc, exp);
  CRC32_ProcessInt(crc, mant);
}
</t>
<t tx="T1528">
void CRC32_ProcessStr(unsigned long *crc, const char *str)
{
  for (; str[0]; str++)
    CRC32_ProcessByte(crc, (byte) str[0]);
}
</t>
<t tx="T1529">@ignore
@language c

// Fixed Point Stuff

&lt;&lt; m_fixed #includes &gt;&gt;

// nothing to do ?

</t>
<t tx="T1530">#include "i_defs.h"
#include "m_fixed.h"
</t>
<t tx="T1531">@ignore
@language c

// Inline Function Definitions

// This file will put all the inline functions into an object file, so that
// they can be referred to via function pointers, and also so they can be
// called if the system doesn't support function inlining.

&lt;&lt; m_inline #includes &gt;&gt;

#ifdef EDGE_INLINE
#undef EDGE_INLINE
#endif

#define EDGE_INLINE(decl, body) decl ; decl body

#include "m_inline.h"

</t>
<t tx="T1532">#include "i_defs.h"
</t>
<t tx="T1533">@ignore
@language c

// Floating Point Math Stuff

&lt;&lt; m_math #includes &gt;&gt;
@others
</t>
<t tx="T1534">#include "i_defs.h"
#include "m_math.h"
</t>
<t tx="T1535">@ Fixed Number shit - to be removed.
@c

static fixed_t FixedDiv2(fixed_t a, fixed_t b)
{
#ifdef USE_INT64
  return (fixed_t)(((Int64)a &lt;&lt; 16) / ((Int64)b));
#else
  return (fixed_t)(65536 * ((double)a / (double)b));
#endif
}
</t>
<t tx="T1536">
fixed_t FixedDiv(fixed_t a, fixed_t b)
{
  if ((abs(a) &gt;&gt; 14) &gt;= abs(b))
    return (a ^ b) &lt; 0 ? INT_MIN : INT_MAX;
  return FixedDiv2(a, b);
}
</t>
<t tx="T1537">
fixed_t FixedMul(fixed_t a, fixed_t b)
{
  return (fixed_t)((((Int64)(a)) * (b)) &gt;&gt; FRACBITS);
}
</t>
<t tx="T1538">@ M_FixedToFloat

Converts a fixed point number to float.

This has been moved to m_inline.h.

M_FloatToFixed

Converts a float to fixed-point.

This has been moved to m_inline.h.
@c

float_t M_Sin(angle_t ang)
{
  return (float_t) sin((double)ang * M_PI / (float_t) ANG180);
}
</t>
<t tx="T1539">
float_t M_Cos(angle_t ang)
{
  return (float_t) cos((double)ang * M_PI / (float_t) ANG180);
}
</t>
<t tx="T1540">
float_t M_Tan(angle_t ang)
{
  return (float_t) tan((double)ang * M_PI / (float_t) ANG180);
}
</t>
<t tx="T1541">
angle_t M_ATan(float_t slope)
{
  return (angle_t)((float_t) ANG180 * atan(slope) / M_PI);
}
</t>
<t tx="T1542">
void M_Angle2Matrix(angle_t ang, vec2_t *x, vec2_t *y)
{
  x-&gt;x =  M_Cos(ang);  x-&gt;y = M_Sin(ang);
  y-&gt;x = -M_Sin(ang);  y-&gt;y = M_Cos(ang);
}
</t>
<t tx="T1543">@ignore
@language c

// Main Menu Code

// See M_Option.C for text built menus.
//
// -KM- 1998/07/21 Add support for message input.

&lt;&lt; m_menu #includes &gt;&gt;
&lt;&lt; m_menu declarations &gt;&gt;
@others
</t>
<t tx="T1544">#include "i_defs.h"
#include "m_menu.h"

#include "dm_defs.h"
#include "dm_state.h"

#include "con_main.h"
#include "ddf_main.h"
#include "dstrings.h"
#include "e_main.h"
#include "g_game.h"
#include "hu_stuff.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_misc.h"
#include "m_option.h"
#include "m_swap.h"
#include "m_random.h"
#include "r_local.h"
#include "s_sound.h"
#include "st_stuff.h"
#include "sv_chunk.h"
#include "sv_main.h"
#include "v_ctx.h"
#include "v_res.h"
#include "v_colour.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"
</t>
<t tx="T1545">
//
// defaulted values
//
int mouseSensitivity;  // has default

// Show messages has default, 0 = off, 1 = on
int showMessages;

int screenblocks;  // has default

int darken_screen;

// 1 = message to be printed
int messageToPrint;

// ...and here is the message string!
const char *messageString;

// -KM- 1998/07/21  This string holds what the user has typed in
char *messageInputString;

// message x &amp; y
int messx;
int messy;
int messageLastMenuActive;

boolean_t inhelpscreens;
boolean_t menuactive;

#define SKULLXOFF   -24
#define LINEHEIGHT   15

// timed message = no input from user
static boolean_t messageNeedsInput;

static void (* message_key_routine)(int response) = NULL;
static void (* message_input_routine)(char *response) = NULL;

static int chosen_epi;

const char *gammamsg[5];


//
//  IMAGES USED
//
const image_t *therm_l;
const image_t *therm_m;
const image_t *therm_r;
const image_t *therm_o;

static const image_t *menu_loadg;
static const image_t *menu_saveg;
static const image_t *menu_svol;
static const image_t *menu_doom;
static const image_t *menu_newgame;
static const image_t *menu_skill;
static const image_t *menu_episode;
static const image_t *menu_skull[2];
static const image_t *menu_readthis[2];


//
//  SAVE STUFF
//
#define SAVESTRINGSIZE 	24

#define SAVE_SLOTS  8
#define SAVE_PAGES  100  // more would be rather unwieldy

// -1 = no quicksave slot picked!
int quickSaveSlot;
int quickSavePage;

// 25-6-98 KM Lots of save games... :-)
static int save_page = 0;
static int save_slot = 0;

// we are going to be entering a savegame string
static int saveStringEnter;

// which char we're editing
static int saveCharIndex;

// old save description before edit
static char saveOldString[SAVESTRINGSIZE];

typedef struct slot_extra_info_s
{
  boolean_t empty;
  boolean_t corrupt;

  char desc[SAVESTRINGSIZE];
  char timestr[32];
  
  char mapname[10];
  char gamename[32];
  
  int skill;
  int netgame;
  boolean_t has_view;
}
slot_extra_info_t;

static slot_extra_info_t ex_slots[SAVE_SLOTS];

// 98-7-10 KM New defines for slider left.
// Part of savegame changes.
#define SLIDERLEFT  -1
#define SLIDERRIGHT -2


//
// MENU TYPEDEFS
//
typedef struct
{
  // 0 = no cursor here, 1 = ok, 2 = arrows ok
  int status;

  // image for menu entry
  char patch_name[10];
  const image_t *image;

  // choice = menu item #.
  // if status = 2, choice can be SLIDERLEFT or SLIDERRIGHT
  void (* select_func)(int choice);

  // hotkey in menu
  char alpha_key;
}
menuitem_t;

typedef struct menu_s
{
  // # of menu items
  int numitems;

  // previous menu
  struct menu_s *prevMenu;

  // menu items
  menuitem_t *menuitems;

  // draw routine
  void (* draw_func)(void);

  // x,y of menu
  int x, y;

  // last item user was on in menu
  int lastOn;
}
menu_t;

// menu item skull is on
static int itemOn;

// skull animation counter
static int skullAnimCounter;

// which skull to draw
static int whichSkull;

// current menudef
static menu_t *currentMenu;

//
// PROTOTYPES
//
void M_NewGame(int choice);
void M_Episode(int choice);
void M_ChooseSkill(int choice);
void M_LoadGame(int choice);
void M_SaveGame(int choice);

// 25-6-98 KM
void M_LoadSavePage(int choice);
void M_Options(int choice);
void M_EndGame(int choice);
void M_ReadThis(int choice);
void M_ReadThis2(int choice);

void M_ChangeMessages(int choice);
void M_ChangeSensitivity(int choice);
void M_SfxVol(int choice);
void M_MusicVol(int choice);
void M_SizeDisplay(int choice);
void M_StartGame(int choice);
void M_Sound(int choice);

void M_FinishReadThis(int choice);
void M_LoadSelect(int choice);
void M_SaveSelect(int choice);
void M_ReadSaveStrings(void);
void M_QuickSave(void);
void M_QuickLoad(void);

void M_DrawMainMenu(void);
void M_DrawReadThis1(void);
void M_DrawReadThis2(void);
void M_DrawNewGame(void);
void M_DrawEpisode(void);
void M_DrawSound(void);
void M_DrawLoad(void);
void M_DrawSave(void);

void M_DrawSaveLoadBorder(int x, int y, int len);
void M_SetupNextMenu(menu_t * menudef);
void M_DrawEmptyCell(menu_t * menu, int item);
void M_DrawSelCell(menu_t * menu, int item);
void M_StartControlPanel(void);
void M_StopMessage(void);
void M_ClearMenus(void);

//
// DOOM MENU
//
enum
{
  newgame = 0,
  options,
  loadgame,
  savegame,
  readthis,
  quitdoom,
  main_end
}
main_e;

static menuitem_t MainMenu[] =
{
  {1, "M_NGAME",   NULL, M_NewGame, 'n'},
  {1, "M_OPTION",  NULL, M_Options, 'o'},
  {1, "M_LOADG",   NULL, M_LoadGame, 'l'},
  {1, "M_SAVEG",   NULL, M_SaveGame, 's'},
  // Another hickup with Special edition.
  {1, "M_RDTHIS",  NULL, M_ReadThis, 'r'},
  {1, "M_QUITG",   NULL, M_QuitEDGE, 'q'}
};

static menu_t MainDef =
{
  main_end,
  NULL,
  MainMenu,
  M_DrawMainMenu,
  97, 64,
  0
};

//
// EPISODE SELECT
//
// -KM- 1998/12/16 This is generated dynamically.
//
static menuitem_t *EpisodeMenu = NULL;

static menuitem_t DefaultEpiMenu =
{
  1,  // status
  "Working",  // name
  NULL,  // image
  NULL,  // select_func
  'w'  // alphakey
};

static menu_t EpiDef =
{
  0,  //ep_end,  // # of menu items
  &amp;MainDef,  // previous menu
  &amp;DefaultEpiMenu,  // menuitem_t -&gt;
  M_DrawEpisode,  // drawing routine -&gt;
  48, 63,  // x,y
  0  // lastOn
};

//
// NEW GAME
//
enum
{
  killthings,
  toorough,
  hurtme,
  violence,
  nightmare,
  newg_end
}
newgame_e;

static menuitem_t NewGameMenu[] =
{
  {1, "M_JKILL", NULL, M_ChooseSkill, 'p'},
  {1, "M_ROUGH", NULL, M_ChooseSkill, 'r'},
  {1, "M_HURT",  NULL, M_ChooseSkill, 'h'},
  {1, "M_ULTRA", NULL, M_ChooseSkill, 'u'},
  {1, "M_NMARE", NULL, M_ChooseSkill, 'n'}
};

static menu_t NewDef =
{
  newg_end,  // # of menu items
  &amp;EpiDef,  // previous menu
  NewGameMenu,  // menuitem_t -&gt;
  M_DrawNewGame,  // drawing routine -&gt;
  48, 63,  // x,y
  hurtme  // lastOn
};

//
// OPTIONS MENU
//
enum
{
  endgame,
  messages,
  scrnsize,
  option_empty1,
  mousesens,
  option_empty2,
  soundvol,
  opt_end
}
options_e;

//
// Read This! MENU 1 &amp; 2
//
enum
{
  rdthsempty1,
  read1_end
}
read_e;

static menuitem_t ReadMenu1[] =
{
  {1, "", NULL, M_ReadThis2, 0}
};

static menu_t ReadDef1 =
{
  read1_end,
  &amp;MainDef,
  ReadMenu1,
  M_DrawReadThis1,
  280, 185,
  0
};

enum
{
  rdthsempty2,
  read2_end
}
read_e2;

static menuitem_t ReadMenu2[] =
{
  {1, "", NULL, M_FinishReadThis, 0}
};

static menu_t ReadDef2 =
{
  read2_end,
  &amp;ReadDef1,
  ReadMenu2,
  M_DrawReadThis2,
  330, 175,
  0
};

//
// SOUND VOLUME MENU
//
enum
{
  sfx_vol,
  sfx_empty1,
  music_vol,
  sfx_empty2,
  sound_end
}
sound_e;

static menuitem_t SoundMenu[] =
{
  {2, "M_SFXVOL", NULL, M_SfxVol, 's'},
  {-1, "", NULL, 0},
  {2, "M_MUSVOL", NULL, M_MusicVol, 'm'},
  {-1, "", NULL, 0}
};

static menu_t SoundDef =
{
  sound_end,
  &amp;MainDef,  ///  &amp;OptionsDef,
  SoundMenu,
  M_DrawSound,
  80, 64,
  0
};

//
// LOAD GAME MENU
//
// Note: upto 10 slots per page
//
static menuitem_t LoadingMenu[] =
{
  {2, "", NULL, M_LoadSelect, '1'},
  {2, "", NULL, M_LoadSelect, '2'},
  {2, "", NULL, M_LoadSelect, '3'},
  {2, "", NULL, M_LoadSelect, '4'},
  {2, "", NULL, M_LoadSelect, '5'},
  {2, "", NULL, M_LoadSelect, '6'},
  {2, "", NULL, M_LoadSelect, '7'},
  {2, "", NULL, M_LoadSelect, '8'},
  {2, "", NULL, M_LoadSelect, '9'},
  {2, "", NULL, M_LoadSelect, '0'}
};

static menu_t LoadDef =
{
  SAVE_SLOTS,
  &amp;MainDef,
  LoadingMenu,
  M_DrawLoad,
  30, 34,
  0
};

//
// SAVE GAME MENU
//
static menuitem_t SavingMenu[] =
{
  {2, "", NULL, M_SaveSelect, '1'},
  {2, "", NULL, M_SaveSelect, '2'},
  {2, "", NULL, M_SaveSelect, '3'},
  {2, "", NULL, M_SaveSelect, '4'},
  {2, "", NULL, M_SaveSelect, '5'},
  {2, "", NULL, M_SaveSelect, '6'},
  {2, "", NULL, M_SaveSelect, '7'},
  {2, "", NULL, M_SaveSelect, '8'},
  {2, "", NULL, M_SaveSelect, '9'},
  {2, "", NULL, M_SaveSelect, '0'}
};

static menu_t SaveDef =
{
  SAVE_SLOTS,
  &amp;MainDef,
  SavingMenu,
  M_DrawSave,
  30, 34,
  0
};
</t>
<t tx="T1546">@ 98-7-10 KM Chooses the page of savegames to view
@c

void M_LoadSavePage(int choice)
{
  switch (choice)
  {
    case SLIDERLEFT:
      // -AJA- could use `OOF' sound...
      if (save_page == 0)
        return;

      save_page--;
      break;
      
    case SLIDERRIGHT:
      if (save_page &gt;= SAVE_PAGES-1)
        return;

      save_page++;
      break;
  }

  S_StartSound(NULL, sfx_swtchn);
  M_ReadSaveStrings();
}
</t>
<t tx="T1547">@ M_ReadSaveStrings

Read the strings from the savegame files

98-7-10 KM Savegame slots increased
@c

void M_ReadSaveStrings(void)
{
  int i, version;
  
  char *filename;
  saveglobals_t *globs;

  for (i=0; i &lt; SAVE_SLOTS; i++)
  {
    ex_slots[i].empty = false;
    ex_slots[i].corrupt = true;

    ex_slots[i].skill = -1;
    ex_slots[i].netgame = -1;
    ex_slots[i].has_view = false;

    ex_slots[i].desc[0] = 0;
    ex_slots[i].timestr[0] = 0;
    ex_slots[i].mapname[0] = 0;
    ex_slots[i].gamename[0] = 0;
    
    filename = G_FileNameFromSlot(save_page * SAVE_SLOTS + i);

    if (! SV_OpenReadFile(filename))
    {
      ex_slots[i].empty = true;
      ex_slots[i].corrupt = false;
      Z_Free(filename);
      continue;
    }

    Z_Free(filename);

    if (! SV_VerifyHeader(&amp;version))
    {
      SV_CloseReadFile();
      continue;
    }

    globs = SV_LoadGLOB();

    // close file now -- we only need the globals
    SV_CloseReadFile();

    if (! globs)
      continue;

    // --- pull info from global structure ---

    if (!globs-&gt;game || !globs-&gt;level || !globs-&gt;description)
    {
      SV_FreeGLOB(globs);
      continue;
    }

    ex_slots[i].corrupt = false;

    Z_StrNCpy(ex_slots[i].gamename, globs-&gt;game,  32-1);
    Z_StrNCpy(ex_slots[i].mapname,  globs-&gt;level, 10-1);

    Z_StrNCpy(ex_slots[i].desc, globs-&gt;description, SAVESTRINGSIZE-1);

    if (globs-&gt;desc_date)
      Z_StrNCpy(ex_slots[i].timestr, globs-&gt;desc_date, 32-1);

    ex_slots[i].skill   = globs-&gt;skill;
    ex_slots[i].netgame = globs-&gt;netgame;

    SV_FreeGLOB(globs);
    
#if 0
    // handle screenshot
    if (globs-&gt;view_pixels)
    {
      int x, y;
      
      for (y=0; y &lt; 100; y++)
      for (x=0; x &lt; 160; x++)
      {
        save_screenshot[x][y] = SV_GetShort();
      }
    }
#endif
  }

  // fix up descriptions
  for (i=0; i &lt; SAVE_SLOTS; i++)
  {
    if (ex_slots[i].corrupt)
    {
      strncpy(ex_slots[i].desc, DDF_LanguageLookup("CorruptSlot"),
          SAVESTRINGSIZE - 1);
      continue;
    }
    else if (ex_slots[i].empty)
    {
      strncpy(ex_slots[i].desc, DDF_LanguageLookup("EmptySlot"),
          SAVESTRINGSIZE - 1);
      continue;
    }
  }
}
</t>
<t tx="T1548">
static void M_DrawSaveLoadCommon(int row, int row2)
{
  int y = LoadDef.y + LINEHEIGHT * row;

  slot_extra_info_t *info;

  char mbuffer[200];


  sprintf(mbuffer, "PAGE %d", save_page + 1);

  // -KM-  1998/06/25 This could quite possibly be replaced by some graphics...
  if (save_page &gt; 0)
    HL_WriteTextTrans(LoadDef.x - 4, y, text_white_map, "&lt; PREV");

  HL_WriteTextTrans(LoadDef.x + 94 - HL_StringWidth(mbuffer) / 2, y,
      text_white_map, mbuffer);

  if (save_page &lt; SAVE_PAGES-1)
    HL_WriteTextTrans(LoadDef.x + 192 - HL_StringWidth("NEXT &gt;"), y,
        text_white_map, "NEXT &gt;");
 
  info = ex_slots + itemOn;
  DEV_ASSERT2(0 &lt;= itemOn &amp;&amp; itemOn &lt; SAVE_SLOTS);

  if (saveStringEnter || info-&gt;empty || info-&gt;corrupt)
    return;

  // show some info about the savegame

  y = LoadDef.y + LINEHEIGHT * (row2 + 1);

  mbuffer[0] = 0;

  strcat(mbuffer, info-&gt;timestr);

  HL_WriteTextTrans(310 - HL_StringWidth(mbuffer), y, 
      text_green_map, mbuffer);


  y -= LINEHEIGHT;
    
  mbuffer[0] = 0;

  // FIXME: LDF-itise these
  switch (info-&gt;skill)
  {
    case 0: strcat(mbuffer, "Too Young To Die"); break;
    case 1: strcat(mbuffer, "Not Too Rough"); break;
    case 2: strcat(mbuffer, "Hurt Me Plenty"); break;
    case 3: strcat(mbuffer, "Ultra Violence"); break;
    default: strcat(mbuffer, "NIGHTMARE"); break;
  }

  HL_WriteTextTrans(310 - HL_StringWidth(mbuffer), y,
      text_green_map, mbuffer);


  y -= LINEHEIGHT;
  
  mbuffer[0] = 0;

  switch (info-&gt;netgame)
  {
    case 0: strcat(mbuffer, "SP MODE"); break;
    case 1: strcat(mbuffer, "COOP MODE"); break;
    default: strcat(mbuffer, "DM MODE"); break;
  }
  
  HL_WriteTextTrans(310 - HL_StringWidth(mbuffer), y,
      text_green_map, mbuffer);


  y -= LINEHEIGHT;
  
  mbuffer[0] = 0;

  strcat(mbuffer, info-&gt;mapname);

  HL_WriteTextTrans(310 - HL_StringWidth(mbuffer), y,
      text_green_map, mbuffer);
}
</t>
<t tx="T1549">@ M_LoadGame

98-7-10 KM Savegame slots increased
@c

void M_DrawLoad(void)
{
  int i;

  VCTX_ImageEasy320(72, 8, menu_loadg);
      
  for (i = 0; i &lt; SAVE_SLOTS; i++)
    M_DrawSaveLoadBorder(LoadDef.x + 8, LoadDef.y + LINEHEIGHT * (i), 24);

  // draw screenshot ?

  for (i = 0; i &lt; SAVE_SLOTS; i++)
    HL_WriteText(LoadDef.x + 8, LoadDef.y + LINEHEIGHT * (i), ex_slots[i].desc);

  M_DrawSaveLoadCommon(i, i+1);
}
</t>
<t tx="T1550">@ Draw border for the savegame description
@c

void M_DrawSaveLoadBorder(int x, int y, int len)
{
  int i;

  const image_t *L = W_ImageFromPatch("M_LSLEFT");
  const image_t *C = W_ImageFromPatch("M_LSCNTR");
  const image_t *R = W_ImageFromPatch("M_LSRGHT");

  VCTX_ImageEasy320(x - IM_WIDTH(L), y + 7, L);

  for (i = 0; i &lt; len; i++, x += IM_WIDTH(C))
    VCTX_ImageEasy320(x, y + 7, C);

  VCTX_ImageEasy320(x, y + 7, R);
}
</t>
<t tx="T1551">@ User wants to load this game

98-7-10 KM Savegame slots increased
@c

void M_LoadSelect(int choice)
{
  if (choice &lt; 0)
  {
    M_LoadSavePage(choice);
    return;
  }

  G_LoadGame(save_page * SAVE_SLOTS + choice);
  M_ClearMenus();
}
</t>
<t tx="T1552">@ Selected from DOOM menu
@c

void M_LoadGame(int choice)
{
  if (netgame)
  {
    M_StartMessage(DDF_LanguageLookup("NoLoadInNetGame"), NULL, false);
    return;
  }

  M_SetupNextMenu(&amp;LoadDef);
  M_ReadSaveStrings();
}
</t>
<t tx="T1553">@ M_SaveGame

98-7-10 KM Savegame slots increased
@c

void M_DrawSave(void)
{
  int i, len;

  VCTX_ImageEasy320(72, 8, menu_saveg);

  for (i = 0; i &lt; SAVE_SLOTS; i++)
  {
    M_DrawSaveLoadBorder(LoadDef.x + 8, LoadDef.y + LINEHEIGHT * (i), 24);

    if (saveStringEnter &amp;&amp; i == save_slot)
    {
      len = HL_StringWidth(ex_slots[save_slot].desc);

      HL_WriteTextTrans(LoadDef.x + 8, LoadDef.y + LINEHEIGHT * (i), 
          text_yellow_map, ex_slots[i].desc);

      HL_WriteTextTrans(LoadDef.x + len + 8, LoadDef.y + LINEHEIGHT * 
          (i), text_yellow_map, "_");
    }
    else
      HL_WriteText(LoadDef.x + 8, LoadDef.y + LINEHEIGHT * (i), ex_slots[i].desc);
  }

  M_DrawSaveLoadCommon(i, i+1);
}
</t>
<t tx="T1554">@ M_Responder calls this when user is finished

98-7-10 KM Savegame slots increased
@c

void M_DoSave(int page, int slot)
{
  G_SaveGame(page * SAVE_SLOTS + slot, ex_slots[slot].desc);
  M_ClearMenus();

  // PICK QUICKSAVE SLOT YET?
  if (quickSaveSlot == -2)
  {
    quickSavePage = page;
    quickSaveSlot = slot;
  }
}
</t>
<t tx="T1555">@ User wants to save. Start string input for M_Responder
@c

void M_SaveSelect(int choice)
{
  if (choice &lt; 0)
  {
    M_LoadSavePage(choice);
    return;
  }

  // we are going to be intercepting all chars
  saveStringEnter = 1;

  save_slot = choice;
  strcpy(saveOldString, ex_slots[choice].desc);

  if (ex_slots[choice].empty)
    ex_slots[choice].desc[0] = 0;

  saveCharIndex = strlen(ex_slots[choice].desc);
}
</t>
<t tx="T1556">@ Selected from DOOM menu
@c

void M_SaveGame(int choice)
{
  if (!usergame)
  {
    M_StartMessage(DDF_LanguageLookup("SaveWhenNotPlaying"), NULL, false);
    return;
  }

  if (gamestate != GS_LEVEL)
    return;

  M_ReadSaveStrings();
  M_SetupNextMenu(&amp;SaveDef);

  need_save_screenshot = true;
  save_screenshot_valid = false;
}
</t>
<t tx="T1557">@ M_QuickSave
@c

static char tempstring[80];

static void QuickSaveResponse(int ch)
{
  if (ch == 'y')
  {
    M_DoSave(quickSavePage, quickSaveSlot);
    S_StartSound(NULL, sfx_swtchx);
  }
}
</t>
<t tx="T1558">
void M_QuickSave(void)
{
  if (!usergame)
  {
    S_StartSound(NULL, sfx_oof);
    return;
  }

  if (gamestate != GS_LEVEL)
    return;

  if (quickSaveSlot &lt; 0)
  {
    M_StartControlPanel();
    M_ReadSaveStrings();
    M_SetupNextMenu(&amp;SaveDef);

    need_save_screenshot = true;
    save_screenshot_valid = false;

    quickSaveSlot = -2;  // means to pick a slot now
    return;
  }

  sprintf(tempstring, DDF_LanguageLookup("QuickSaveOver"),
      ex_slots[quickSaveSlot].desc);

  M_StartMessage(tempstring, QuickSaveResponse, true);
}
</t>
<t tx="T1559">@ M_QuickLoad
@c

static void QuickLoadResponse(int ch)
{
  if (ch == 'y')
  {
    int tempsavepage = save_page;

    save_page = quickSavePage;
    M_LoadSelect(quickSaveSlot);

    save_page = tempsavepage;
    S_StartSound(NULL, sfx_swtchx);
  }
}
</t>
<t tx="T1560">
void M_QuickLoad(void)
{
  if (netgame)
  {
    M_StartMessage(DDF_LanguageLookup("NoQLoadInNet"), NULL, false);
    return;
  }

  if (quickSaveSlot &lt; 0)
  {
    M_StartMessage(DDF_LanguageLookup("NoQuickSaveSlot"), NULL, false);
    return;
  }

  sprintf(tempstring, DDF_LanguageLookup("QuickLoad"),
      ex_slots[quickSaveSlot].desc);
  
  M_StartMessage(tempstring, QuickLoadResponse, true);
}
</t>
<t tx="T1561">@ Read This Menus
Had a "quick hack to fix romero bug"
@c

void M_DrawReadThis1(void)
{
  inhelpscreens = true;
  
  VCTX_Image(0, 0, SCREENWIDTH, SCREENHEIGHT, menu_readthis[0]);
}
</t>
<t tx="T1562">@ Read This Menus - optional second page.
@c

void M_DrawReadThis2(void)
{
  inhelpscreens = true;

  VCTX_Image(0, 0, SCREENWIDTH, SCREENHEIGHT, menu_readthis[1]);
}
</t>
<t tx="T1563">@ M_DrawSound

Change Sfx &amp; Music volumes

-ACB- 1999/10/10 Sound API Volume re-added
-ACB- 1999/11/13 Music API Volume re-added
@c

void M_DrawSound(void)
{
  int musicvol;
  int soundvol;

  musicvol = S_GetMusicVolume();
  soundvol = S_GetSfxVolume();

  VCTX_ImageEasy320(60, 38, menu_svol);

  M_DrawThermo(SoundDef.x, SoundDef.y + LINEHEIGHT * (sfx_vol + 1), 16, soundvol, 1);
  M_DrawThermo(SoundDef.x, SoundDef.y + LINEHEIGHT * (music_vol + 1), 16, musicvol, 1);
}
</t>
<t tx="T1564">@ M_Sound
@c

void M_Sound(int choice)
{
  M_SetupNextMenu(&amp;SoundDef);
}
</t>
<t tx="T1565">@ M_SfxVol

-ACB- 1999/10/10 Sound API Volume re-added
@c

void M_SfxVol(int choice)
{
  int soundvol;

  soundvol = S_GetSfxVolume();

  switch (choice)
  {
    case SLIDERLEFT:
      if (soundvol &gt; S_MIN_VOLUME)
        soundvol--;

      break;

    case SLIDERRIGHT:
      if (soundvol &lt; S_MAX_VOLUME)
        soundvol++;

      break;
  }

  S_SetSfxVolume(soundvol);
}
</t>
<t tx="T1566">@ M_MusicVol

-ACB- 1999/10/07 Removed sound references: New Sound API
@c

void M_MusicVol(int choice)
{
  int musicvol;

  musicvol = S_GetMusicVolume();

  switch (choice)
  {
    case SLIDERLEFT:
      if (musicvol &gt; S_MIN_VOLUME)
        musicvol--;

      break;

    case SLIDERRIGHT:
      if (musicvol &lt; S_MAX_VOLUME)
        musicvol++;

      break;
  }

  S_SetMusicVolume(musicvol);
}
</t>
<t tx="T1567">@ M_DrawMainMenu
@c

void M_DrawMainMenu(void)
{
  VCTX_ImageEasy320(94, 2, menu_doom);
}
</t>
<t tx="T1568">@ M_NewGame
@c

void M_DrawNewGame(void)
{
  VCTX_ImageEasy320(96, 14, menu_newgame);
  VCTX_ImageEasy320(54, 38, menu_skill);
}
</t>
<t tx="T1569">
void M_NewGame(int choice)
{
  if (netgame &amp;&amp; !demoplayback)
  {
    M_StartMessage(DDF_LanguageLookup("NewNetGame"), NULL, false);
    return;
  }

  M_SetupNextMenu(&amp;EpiDef);
}
</t>
<t tx="T1570">@ M_Episode

-KM- 1998/12/16 Generates EpiDef menu dynamically.
@c

static void CreateEpisodeMenu(void)
{
  int i, j, k, e;
  char alpha;

  EpisodeMenu = Z_ClearNew(menuitem_t, num_wi_maps);

  for (i = 0, e = 0; i &lt; num_wi_maps; i++)
  {
    wi_map_t *wi = wi_maps[i];

    if (W_CheckNumForName(wi-&gt;firstmap) == -1)
      continue;

    k = 0;
    EpisodeMenu[e].status = 1;
    EpisodeMenu[e].select_func = M_Episode;
    Z_StrNCpy(EpisodeMenu[e].patch_name, wi-&gt;namegraphic, 8);
    EpisodeMenu[e].image = NULL;
    alpha = EpisodeMenu[e].patch_name[0];

    // ????
    for (j = 0; j &lt; e; j++)
    {
      if (alpha == EpisodeMenu[j].alpha_key)
      {
        while (EpisodeMenu[e].patch_name[k] &amp;&amp; EpisodeMenu[e].patch_name[k] != ' ')
          k++;

        k++;
        if (EpisodeMenu[e].patch_name[k])
          alpha = EpisodeMenu[e].patch_name[k];
        j = 0;
      }
    }
    EpisodeMenu[e].alpha_key = alpha;
    e++;
  }

  if (e == 0)
    I_Error("No available episodes !\n");

  EpiDef.numitems = e;
  EpiDef.menuitems = EpisodeMenu;
}
</t>
<t tx="T1571">

void M_DrawEpisode(void)
{
  if (!EpisodeMenu)
    CreateEpisodeMenu();
    
  VCTX_ImageEasy320(54, 38, menu_episode);
}
</t>
<t tx="T1572">
static void VerifyNightmare(int ch)
{
  int i;

  if (ch != 'y')
    return;

  // -KM- 1998/12/17 Clear the intermission.
  WI_MapInit(NULL);
  
  // find episode (???)
  for (i = 0; strcmp(wi_maps[i]-&gt;namegraphic, EpisodeMenu[chosen_epi].patch_name); i++) 
  { /* nothing here */ }

  if (! G_DeferedInitNew(nightmare, wi_maps[i]-&gt;firstmap, false))
  {
    // 23-6-98 KM Fixed this.
    M_SetupNextMenu(&amp;EpiDef);
    M_StartMessage(DDF_LanguageLookup("EpisodeNonExist"), NULL, false);
    return;
  }

  M_ClearMenus();
}
</t>
<t tx="T1573">
void M_ChooseSkill(int choice)
{
  int i;

  if (choice == nightmare)
  {
    M_StartMessage(DDF_LanguageLookup("NightMareCheck"), VerifyNightmare, true);
    return;
  }
  // -KM- 1998/12/17 Clear the intermission
  WI_MapInit(NULL);

  // find episode (???)
  for (i = 0; strcmp(wi_maps[i]-&gt;namegraphic, EpisodeMenu[chosen_epi].patch_name); i++)
  { /* nothing here */ }

  if (! G_DeferedInitNew(choice, wi_maps[i]-&gt;firstmap, false))
  {
    // 23-6-98 KM Fixed this.
    M_SetupNextMenu(&amp;EpiDef);
    M_StartMessage(DDF_LanguageLookup("EpisodeNonExist"), NULL, false);
    return;
  }

  M_ClearMenus();
}
</t>
<t tx="T1574">
void M_Episode(int choice)
{
  chosen_epi = choice;
  M_SetupNextMenu(&amp;NewDef);
}
</t>
<t tx="T1575">@ M_Options
@c

void M_Options(int choice)
{
  optionsmenuon = 1;
}
</t>
<t tx="T1576">@ Toggle messages on/off
@c

void M_ChangeMessages(int choice)
{
  // warning: unused parameter `int choice'
  (void) choice;

  if (!showMessages)
    CON_Printf("%s\n", DDF_LanguageLookup("MessagesOn"));
  else
    CON_Printf("%s\n", DDF_LanguageLookup("MessagesOff"));

  showMessages = 1 - showMessages;

  message_dontfuckwithme = true;
}
</t>
<t tx="T1577">@ M_EndGame
@c

static void EndGameResponse(int ch)
{
  if (ch != 'y')
    return;

  currentMenu-&gt;lastOn = itemOn;
  M_ClearMenus();
  E_StartTitle();
}
</t>
<t tx="T1578">
void M_EndGame(int choice)
{
  if (!usergame)
  {
    S_StartSound(NULL, sfx_oof);
    return;
  }

  if (netgame)
  {
    M_StartMessage(DDF_LanguageLookup("EndNetGame"), NULL, false);
    return;
  }

  M_StartMessage(DDF_LanguageLookup("EndGameCheck"), EndGameResponse, true);
}
</t>
<t tx="T1579">@ M_ReadThis
@c

void M_ReadThis(int choice)
{
  M_SetupNextMenu(&amp;ReadDef1);
}
</t>
<t tx="T1580">
void M_ReadThis2(int choice)
{
  M_SetupNextMenu(&amp;ReadDef2);
}
</t>
<t tx="T1581">
void M_FinishReadThis(int choice)
{
  M_SetupNextMenu(&amp;MainDef);
}
</t>
<t tx="T1582">@ M_QuitDOOM

-KM- 1998/12/16 Handle sfx that don't exist in this version.
-KM- 1999/01/31 Generate quitsounds from default.ldf
@c

static void QuitResponse(int ch)
{
  if (ch != 'y')
    return;
  if (!netgame)
  {
    int numsounds = 0;
    char refname[16];
    char sound[16];
    int i, start;

    // Count the quit messages
    do
    {
      sprintf(refname, "QuitSnd%d", numsounds + 1);
      if (DDF_LanguageValidRef(refname))
        numsounds++;
      else
        break;
    }
    while (true);

    if (numsounds)
    {
      // cycle through all the quit sounds, until one of them exists
      // (some of the default quit sounds do not exist in DOOM 1)
      start = i = M_Random() % numsounds;
      do
      {
        sprintf(refname, "QuitSnd%d", i + 1);
        sprintf(sound, "DS%s", DDF_LanguageLookup(refname));
        if (W_CheckNumForName(sound) != -1)
        {
          S_StartSound(NULL, DDF_SfxLookupSound(DDF_LanguageLookup(refname)));
          break;
        }
        i = (i + 1) % numsounds;
      }
      while (i != start);
    }

    I_WaitVBL(105);
  }

  // -ACB- 1999/09/20 New exit code order
  // Write the default config file first
  M_SaveDefaults();
  I_SystemShutdown();
  I_DisplayExitScreen();
  I_CloseProgram(0);
}
</t>
<t tx="T1583">@ -ACB- 1998/07/19 Removed offensive messages selection (to some people);
Better Random Selection.
-KM- 1998/07/21 Reinstated counting quit messages, so adding them to dstrings.c
is all you have to do. Using P_Random for the random number
automatically kills the demo sync...
(hence M_Random()... -AJA-).

-KM- 1998/07/31 Removed Limit. So there.
-KM- 1999/01/31 Load quit messages from default.ldf
@c

void M_QuitEDGE(int choice)
{
  static char *endstring = NULL;
  const char *DOSY;
  const char *chosen_msg;
  char refname[16];

  int num_quitmessages;

  DOSY = DDF_LanguageLookup("PressToQuit");

  num_quitmessages = 0;

  // Count the quit messages
  // -ES- 2000/02/04 Cleaned Up.
  do
  {
    sprintf(refname, "QUITMSG%d", num_quitmessages + 1);
    if (DDF_LanguageValidRef(refname))
      num_quitmessages++;
    else
      break;
  }
  while (true);

  //
  // We pick index 0 which is language sensitive,
  // or one at random, between 1 and maximum number.
  //
  sprintf(refname, "QUITMSG%d", (M_Random() % num_quitmessages) + 1);
  chosen_msg = DDF_LanguageLookup(refname);
  Z_Resize(endstring, char, strlen(chosen_msg) + 3 + strlen(DOSY));
  sprintf(endstring, "%s\n\n%s", chosen_msg, DOSY);

  M_StartMessage(endstring, QuitResponse, true);
}
</t>
<t tx="T1584">@ 98-7-10 KM Use new defines
@c

void M_ChangeSensitivity(int choice)
{
  switch (choice)
  {
    case SLIDERLEFT:
      if (mouseSensitivity)
        mouseSensitivity--;
      break;
    case SLIDERRIGHT:
      if (mouseSensitivity &lt; 9)
        mouseSensitivity++;
      break;
  }
}
</t>
<t tx="T1585">@ 98-7-10 KM Use new defines
@c

void M_SizeDisplay(int choice)
{
  switch (choice)
  {
    case SLIDERLEFT:
      if (screen_size &gt; 0)
      {
        screenblocks--;
        screen_size--;
      }
      break;
    case SLIDERRIGHT:
      if (screen_size &lt; 8)
      {
        screenblocks++;
        screen_size++;
      }
      break;
  }

  R_SetViewSize(screenblocks);
}
</t>
<t tx="T1586">@ MENU FUNCTIONS


M_DrawThermo
@c

void M_DrawThermo(int x, int y, int thermWidth, int thermDot, int div)
{
  int i, basex = x;
  int step = (8 / div);

  // Note: the (step+1) here is for compatibility with the original
  // code.  It seems required to make the thermo bar tile properly.

  VCTX_Image320(x, y, step+1, IM_HEIGHT(therm_l)/div, therm_l);

  for (i=0, x += step; i &lt; thermWidth; i++, x += step)
  {
    VCTX_Image320(x, y, step+1, IM_HEIGHT(therm_m)/div, therm_m);
  }

  VCTX_Image320(x, y, step+1, IM_HEIGHT(therm_r)/div, therm_r);

  x = basex + step + thermDot * step;

  VCTX_Image320(x, y, step+1, IM_HEIGHT(therm_o)/div, therm_o);
}
</t>
<t tx="T1587">
void M_StartMessage(const char *string, void (* routine)(int response), 
    boolean_t input)
{
  messageLastMenuActive = menuactive;
  messageToPrint = 1;
  messageString = string;
  message_key_routine = routine;
  message_input_routine = NULL;
  messageNeedsInput = input;
  menuactive = true;
  CON_SetVisible(vs_notvisible);
  return;
}
</t>
<t tx="T1588">@ M_StartMessageInput

-KM- 1998/07/21 Call M_StartMesageInput to start a message that needs a
string input. (You can convert it to a number if you want to.)

string: The prompt, eg "What is your name\n\n" must be either
static or globally visible.

routine: Format is void routine(char *s) Routine will be called
with a pointer to the input in s. s will be NULL if the user
pressed ESCAPE to cancel the input.

String is allocated by Z_Malloc, it is your responsibility to
Z_Free it.
@c

void M_StartMessageInput(const char *string,
    void (* routine)(char *response))
{
  messageLastMenuActive = menuactive;
  messageToPrint = 2;
  messageString = string;
  message_input_routine = routine;
  message_key_routine = NULL;
  messageNeedsInput = true;
  menuactive = true;
  CON_SetVisible(vs_notvisible);
  return;
}
</t>
<t tx="T1589">
void M_StopMessage(void)
{
  menuactive = messageLastMenuActive;
  messageToPrint = 0;
  
  if (!menuactive)
    save_screenshot_valid = false;
}
</t>
<t tx="T1590">@ CONTROL PANEL


M_Responder

-KM- 1998/09/01 Analogue binding, and hat support
@c

boolean_t M_Responder(event_t * ev)
{
  int ch;
  int i;

  if (ev-&gt;type != ev_keydown)
    return false;

  ch = ev-&gt;value.key;

  // -ACB- 1999/10/11 F1 is responsible for print screen at any time
  if (ch == KEYD_F1)
  {
    G_ScreenShot();
    return true;
  }

  // Take care of any messages that need input
  // -KM- 1998/07/21 Message Input
  if (messageToPrint == 1)
  {
    if (messageNeedsInput == true &amp;&amp;
        !(ch == ' ' || ch == 'n' || ch == 'y' || ch == KEYD_ESCAPE))
      return false;

    messageToPrint = 0;
    // -KM- 1998/07/31 Moved this up here to fix bugs.
    menuactive = messageLastMenuActive;

    if (message_key_routine)
      (* message_key_routine)(ch);

    S_StartSound(NULL, sfx_swtchx);
    return true;
  }
  else if (messageToPrint == 2)
  {
    static int messageLength;
    static int messageP;

    if (!messageInputString)
    {
      messageInputString = Z_New(char, 32);
      messageLength = 32;
      messageP = 0;
      Z_Clear(messageInputString, char, messageLength);
    }
    if (ch == KEYD_ENTER)
    {
      menuactive = messageLastMenuActive;
      messageToPrint = 0;

      if (message_input_routine)
        (* message_input_routine)(messageInputString);

      messageInputString = NULL;
      menuactive = false;
      S_StartSound(NULL, sfx_swtchx);
      return true;
    }

    if (ch == KEYD_ESCAPE)
    {
      menuactive = messageLastMenuActive;
      messageToPrint = 0;
      
      if (message_input_routine)
        (* message_input_routine)(NULL);

      menuactive = false;
      save_screenshot_valid = false;

      Z_Free(messageInputString);
      messageInputString = NULL;
      S_StartSound(NULL, sfx_swtchx);
      return true;
    }
    if (ch == KEYD_BACKSPACE)
    {
      if (messageP &gt; 0)
      {
        messageP--;
        messageInputString[messageP] = 0;
      }
      return true;
    }
    ch = toupper(ch);
    if (ch == '-')
      ch = '_';
    if (ch != 32)
      if (ch - HU_FONTSTART &lt; 0 || ch - HU_FONTSTART &gt;= HU_FONTSIZE)
        return true;
    if ((ch &gt;= 32) &amp;&amp; (ch &lt;= 127) &amp;&amp;
        (HL_StringWidth(messageInputString) &lt; 300))
    {
      messageInputString[messageP++] = ch;
      messageInputString[messageP] = 0;
    }
    if (messageP == (messageLength - 1))
      Z_Resize(messageInputString, char, ++messageLength);
    return true;
  }

  // new options menu on - use that responder
  if (optionsmenuon)
    return M_OptResponder(ev, ch);

  // Save Game string input
  if (saveStringEnter)
  {
    switch (ch)
    {
      case KEYD_BACKSPACE:
        if (saveCharIndex &gt; 0)
        {
          saveCharIndex--;
          ex_slots[save_slot].desc[saveCharIndex] = 0;
        }
        break;

      case KEYD_ESCAPE:
        saveStringEnter = 0;
        strcpy(ex_slots[save_slot].desc, saveOldString);
        break;

      case KEYD_ENTER:
        saveStringEnter = 0;
        if (ex_slots[save_slot].desc[0])
          M_DoSave(save_page, save_slot);
        break;

      default:
        ch = toupper(ch);
        if (ch != 32)
          if (ch - HU_FONTSTART &lt; 0 || ch - HU_FONTSTART &gt;= HU_FONTSIZE)
            break;
        if (ch &gt;= 32 &amp;&amp; ch &lt;= 127 &amp;&amp;
            saveCharIndex &lt; SAVESTRINGSIZE - 1 &amp;&amp;
            HL_StringWidth(ex_slots[save_slot].desc) &lt;
            (SAVESTRINGSIZE - 2) * 8)
        {
          ex_slots[save_slot].desc[saveCharIndex++] = ch;
          ex_slots[save_slot].desc[saveCharIndex] = 0;
        }
        break;
    }
    return true;
  }

  // F-Keys
  if (!menuactive)
  {
    switch (ch)
    {
      case KEYD_MINUS:  // Screen size down

        if (automapactive || chat_on)
          return false;
        // 98-7-10 KM Use new defines
        M_SizeDisplay(SLIDERLEFT);
        S_StartSound(NULL, sfx_stnmov);
        return true;

      case KEYD_EQUALS:  // Screen size up

        if (automapactive || chat_on)
          return false;
        // 98-7-10 KM Use new defines
        M_SizeDisplay(SLIDERRIGHT);
        S_StartSound(NULL, sfx_stnmov);
        return true;

/*
      case KEYD_F1:  // Help key

        M_StartControlPanel();

        //if ( gamemode == retail )
        //  currentMenu = &amp;ReadDef2;
        //else
        currentMenu = &amp;ReadDef1;

        itemOn = 0;
        S_StartSound(NULL, sfx_swtchn);
        return true;
*/

      case KEYD_F2:  // Save

        M_StartControlPanel();
        S_StartSound(NULL, sfx_swtchn);
        M_SaveGame(0);
        return true;

      case KEYD_F3:  // Load

        M_StartControlPanel();
        S_StartSound(NULL, sfx_swtchn);
        M_LoadGame(0);
        return true;

      case KEYD_F4:  // Sound Volume

        M_StartControlPanel();
        currentMenu = &amp;SoundDef;
        itemOn = sfx_vol;
        S_StartSound(NULL, sfx_swtchn);
        return true;

      case KEYD_F5:  // Detail toggle, now loads options menu
        // -KM- 1998/07/31 F5 now loads options menu, detail is obsolete.

        S_StartSound(NULL, sfx_swtchn);
        M_StartControlPanel();
        M_Options(0);
        return true;

      case KEYD_F6:  // Quicksave

        S_StartSound(NULL, sfx_swtchn);
        M_QuickSave();
        return true;

      case KEYD_F7:  // End game

        S_StartSound(NULL, sfx_swtchn);
        M_EndGame(0);
        return true;

      case KEYD_F8:  // Toggle messages

        M_ChangeMessages(0);
        S_StartSound(NULL, sfx_swtchn);
        return true;

      case KEYD_F9:  // Quickload

        S_StartSound(NULL, sfx_swtchn);
        M_QuickLoad();
        return true;

      case KEYD_F10:  // Quit DOOM

        S_StartSound(NULL, sfx_swtchn);
        M_QuitEDGE(0);
        return true;

      case KEYD_F11:  // gamma toggle

        current_gamma++;
        if (current_gamma &gt; 4)
          current_gamma = 0;
        CON_Printf("%s\n", gammamsg[current_gamma]);

        // -AJA- 1999/07/03: removed PLAYPAL reference.
        return true;

    }

    // Pop-up menu?
    if (ch == KEYD_ESCAPE)
    {
      M_StartControlPanel();
      S_StartSound(NULL, sfx_swtchn);
      return true;
    }
    return false;
  }

  // Keys usable within menu
  switch (ch)
  {
    case KEYD_DOWNARROW:
      do
      {
        if (itemOn + 1 &gt; currentMenu-&gt;numitems - 1)
          itemOn = 0;
        else
          itemOn++;
        S_StartSound(NULL, sfx_pstop);
      }
      while (currentMenu-&gt;menuitems[itemOn].status == -1);
      return true;

    case KEYD_UPARROW:
      do
      {
        if (!itemOn)
          itemOn = currentMenu-&gt;numitems - 1;
        else
          itemOn--;
        S_StartSound(NULL, sfx_pstop);
      }
      while (currentMenu-&gt;menuitems[itemOn].status == -1);
      return true;

    case KEYD_PGUP:
    case KEYD_LEFTARROW:
      if (currentMenu-&gt;menuitems[itemOn].select_func &amp;&amp;
          currentMenu-&gt;menuitems[itemOn].status == 2)
      {
        S_StartSound(NULL, sfx_stnmov);
        // 98-7-10 KM Use new defines
        (* currentMenu-&gt;menuitems[itemOn].select_func)(SLIDERLEFT);
      }
      return true;

    case KEYD_PGDN:
    case KEYD_RIGHTARROW:
      if (currentMenu-&gt;menuitems[itemOn].select_func &amp;&amp;
          currentMenu-&gt;menuitems[itemOn].status == 2)
      {
        S_StartSound(NULL, sfx_stnmov);
        // 98-7-10 KM Use new defines
        (* currentMenu-&gt;menuitems[itemOn].select_func)(SLIDERRIGHT);
      }
      return true;

    case KEYD_ENTER:
      if (currentMenu-&gt;menuitems[itemOn].select_func &amp;&amp;
          currentMenu-&gt;menuitems[itemOn].status)
      {
        currentMenu-&gt;lastOn = itemOn;
        (* currentMenu-&gt;menuitems[itemOn].select_func)(itemOn);
        S_StartSound(NULL, sfx_pistol);
      }
      return true;

    case KEYD_ESCAPE:
      currentMenu-&gt;lastOn = itemOn;
      M_ClearMenus();
      S_StartSound(NULL, sfx_swtchx);
      return true;

    case KEYD_BACKSPACE:
      currentMenu-&gt;lastOn = itemOn;
      if (currentMenu-&gt;prevMenu)
      {
        currentMenu = currentMenu-&gt;prevMenu;
        itemOn = currentMenu-&gt;lastOn;
        S_StartSound(NULL, sfx_swtchn);
      }
      return true;

    default:
      for (i = itemOn + 1; i &lt; currentMenu-&gt;numitems; i++)
        if (currentMenu-&gt;menuitems[i].alpha_key == ch)
        {
          itemOn = i;
          S_StartSound(NULL, sfx_pstop);
          return true;
        }
      for (i = 0; i &lt;= itemOn; i++)
        if (currentMenu-&gt;menuitems[i].alpha_key == ch)
        {
          itemOn = i;
          S_StartSound(NULL, sfx_pstop);
          return true;
        }
      break;

  }

  return false;
}
</t>
<t tx="T1591">@ M_StartControlPanel
@c

void M_StartControlPanel(void)
{
  // intro might call this repeatedly
  if (menuactive)
    return;

  menuactive = 1;
  CON_SetVisible(vs_notvisible);
  currentMenu = &amp;MainDef;  // JDC

  itemOn = currentMenu-&gt;lastOn;  // JDC
}
</t>
<t tx="T1592">@ M_Drawer

Called after the view has been rendered,
but before it has been blitted.
@c

void M_Drawer(void)
{
  static short x;
  static short y;
  unsigned int i;
  unsigned int max;
  int start;

  inhelpscreens = false;

  // 1998/07/10 KM Darken screen added for all messages (quit messages)
  if (!menuactive)
    return;

  if (darken_screen)
  {
    vctx.SolidBox(0, 0, SCREENWIDTH, SCREENHEIGHT, pal_black, 0.5);
    stbar_update = true;
  }

  // Horiz. &amp; Vertically center string and print it.
  if (messageToPrint)
  {
    // -KM- 1998/06/25 Remove limit.
    // -KM- 1998/07/21 Add space for input
    // -ACB- 1998/06/09 More space for message.
    // -KM- 1998/07/31 User input in different colour.
    char *string;
    char *Mstring;
    int len;
    int input_start;

    // Reserve space for prompt
    len = input_start = strlen(messageString);

    // Reserve space for what the user typed in
    len += messageInputString ? strlen(messageInputString) : 0;

    // Reserve space for '_' cursor
    len += (messageToPrint == 2) ? 1 : 0;

    // Reserve space for NULL Terminator
    len++;

    string = Z_New(char, len);
    Mstring = Z_New(char, len);

    strcpy(Mstring, messageString);

    if (messageToPrint == 2)
    {
      if (messageInputString)
        strcpy(Mstring + strlen(messageString), messageInputString);

      Mstring[i = strlen(Mstring)] = '_';
      Mstring[i + 1] = 0;
    }

    start = 0;

    y = 100 - HL_StringHeight(Mstring) / 2;

    while (*(Mstring + start))
    {
      for (i = 0; i &lt; strlen(Mstring + start); i++)
      {
        if (*(Mstring + start + i) == '\n')
        {
          // copy substring and apply terminator
          Z_MoveData(string, Mstring + start, char, i);
          string[i] = 0;
          start += (i + 1);
          break;
        }
      }

      if (i == strlen(Mstring + start))
      {
        strcpy(string, Mstring + start);
        start += i;
      }

      x = 160 - HL_StringWidth(string) / 2;

      // -KM- 1998/07/31 Colour should be a define or something...
      // -ACB- 1998/09/01 Colour is now a define
      if (start &gt; input_start)
        HL_WriteTextTrans(x, y, text_yellow_map, string);
      else
        HL_WriteText(x, y, string);

      y += hu_font.height;
    }

    Z_Free(string);
    Z_Free(Mstring);

    return;
  }

  // new options menu enable, use that drawer instead
  if (optionsmenuon)
  {
    M_OptDrawer();
    return;
  }

  // call Draw routine
  if (currentMenu-&gt;draw_func)
    (* currentMenu-&gt;draw_func)();

  // DRAW MENU
  x = currentMenu-&gt;x;
  y = currentMenu-&gt;y;
  max = currentMenu-&gt;numitems;

  for (i = 0; i &lt; max; i++, y += LINEHEIGHT)
  {
    const image_t *image;
    
    // ignore blank lines
    if (! currentMenu-&gt;menuitems[i].patch_name[0])
      continue;

    if (! currentMenu-&gt;menuitems[i].image)
      currentMenu-&gt;menuitems[i].image = W_ImageFromPatch(
          currentMenu-&gt;menuitems[i].patch_name);
    
    image = currentMenu-&gt;menuitems[i].image;

    VCTX_ImageEasy320(x, y, image);
  }

  // DRAW SKULL
  {
    int sx = x + SKULLXOFF;
    int sy = currentMenu-&gt;y - 5 + itemOn * LINEHEIGHT;

    VCTX_ImageEasy320(sx, sy, menu_skull[whichSkull]);
  }
}
</t>
<t tx="T1593">@ M_ClearMenus
@c

void M_ClearMenus(void)
{
  menuactive = 0;
  save_screenshot_valid = false;
}
</t>
<t tx="T1594">@ M_SetupNextMenu
@c

void M_SetupNextMenu(menu_t * menudef)
{
  currentMenu = menudef;
  itemOn = currentMenu-&gt;lastOn;
}
</t>
<t tx="T1595">@ M_Ticker
@c

void M_Ticker(void)
{
  if (optionsmenuon)
  {
    M_OptTicker();
    return;
  }

  if (--skullAnimCounter &lt;= 0)
  {
    whichSkull ^= 1;
    skullAnimCounter = 8;
  }
}
</t>
<t tx="T1596">@ M_Init
@c

boolean_t M_Init(void)
{
  currentMenu = &amp;MainDef;
  menuactive = 0;
  itemOn = currentMenu-&gt;lastOn;
  whichSkull = 0;
  skullAnimCounter = 10;
  screen_size = screenblocks - 3;
  messageToPrint = 0;
  messageString = NULL;
  messageLastMenuActive = menuactive;
  quickSaveSlot = -1;

  // lookup required images
  therm_l = W_ImageFromPatch("M_THERML");
  therm_m = W_ImageFromPatch("M_THERMM");
  therm_r = W_ImageFromPatch("M_THERMR");
  therm_o = W_ImageFromPatch("M_THERMO");

  menu_loadg    = W_ImageFromPatch("M_LOADG");
  menu_saveg    = W_ImageFromPatch("M_SAVEG");
  menu_svol     = W_ImageFromPatch("M_SVOL");
  menu_doom     = W_ImageFromPatch("M_DOOM");
  menu_newgame  = W_ImageFromPatch("M_NEWG");
  menu_skill    = W_ImageFromPatch("M_SKILL");
  menu_episode  = W_ImageFromPatch("M_EPISOD");
  menu_skull[0] = W_ImageFromPatch("M_SKULL1");
  menu_skull[1] = W_ImageFromPatch("M_SKULL2");

  // Here we could catch other version dependencies,
  //  like HELP1/2, and four episodes.
  //    if (W_CheckNumForName("M_EPI4") &lt; 0)
  //      EpiDef.numitems -= 2;
  //    else if (W_CheckNumForName("M_EPI5") &lt; 0)
  //      EpiDef.numitems--;

  if (W_CheckNumForName("HELP") &gt;= 0)
    menu_readthis[0] = W_ImageFromPatch("HELP");
  else
    menu_readthis[0] = W_ImageFromPatch("HELP1");

  if (W_CheckNumForName("HELP2") &gt;= 0)
    menu_readthis[1] = W_ImageFromPatch("HELP2");
  else
  {
    menu_readthis[1] = W_ImageFromPatch("CREDIT");

    // This is used because DOOM 2 had only one HELP
    //  page. I use CREDIT as second page now, but
    //  kept this hack for educational purposes.

    MainMenu[readthis] = MainMenu[quitdoom];
    MainDef.numitems--;
    MainDef.y += 8;
    NewDef.prevMenu = &amp;MainDef;
    ReadDef1.draw_func = M_DrawReadThis1;
    ReadDef1.x = 330;
    ReadDef1.y = 165;
    ReadMenu1[0].select_func = M_FinishReadThis;
  }

  M_InitOptmenu();

  return true;
}
</t>
<t tx="T1597">@ignore
@language c

// Misc: Screenshots, Menu and defaults Code

// -MH- 1998/07/02  Added key_flyup and key_flydown
// -MH- 1998/07/02 "shootupdown" --&gt; "true3dgameplay"
// -ACB- 2000/06/02 Removed Control Defaults

&lt;&lt; m_misc #includes &gt;&gt;
&lt;&lt; m_misc declarations &gt;&gt;
@others
</t>
<t tx="T1598">#include "i_defs.h"
#include "m_misc.h"

#include "con_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "dstrings.h"
#include "hu_stuff.h"
#include "m_argv.h"
#include "m_menu.h"
#include "m_option.h"
#include "m_swap.h"
#include "p_spec.h"
#include "w_wad.h"
#include "r_main.h"
#include "r2_defs.h"
#include "s_sound.h"
#include "v_ctx.h"
#include "v_res.h"
#include "v_colour.h"
#include "w_image.h"
#include "w_wad.h"
#include "wp_main.h"
#include "z_zone.h"
</t>
<t tx="T1599">
//
// DEFAULTS
//
int usemouse;
int usejoystick;

int cfgnormalfov;
int cfgzoomedfov;

// toggled by autorun button.
boolean_t autorunning = false;

boolean_t display_disk = false;
static const image_t *disk_image = NULL;
static const image_t *air_images[21] = { NULL, };

unsigned short save_screenshot[160][100];
boolean_t save_screenshot_valid = false;

#ifdef LINUX
char *mousetype;
char *mousedev;
char *videoInterface;
char *vid_path;
#endif

// -ACB- 1999/09/19 Sound API
int dummysndchan;
static int cfgsound;
static int cfgmusic;

default_t defaults[] =
{
    {"screenwidth",  &amp;SCREENWIDTH, 320},
    {"screenheight", &amp;SCREENHEIGHT, 200},
    {"screendepth",  &amp;SCREENBITS, 8},
    {"windowed", (int *)&amp;SCREENWINDOW, 0},
    {"boom_compatility", (int *)&amp;global_flags.compat_mode, 0},
 
    {"mouse_sensitivity", &amp;mouseSensitivity, 5},
    {"sfx_volume",        &amp;cfgsound,         8},
    {"music_volume",      &amp;cfgmusic,         8},
    {"show_messages",     &amp;showMessages,     1},

//    {"autorun", (int *)&amp;autorunning, (int)false},

    {"swapstereo", (int *)&amp;swapstereo, 0},
    {"invertmouse", (int *)&amp;invertmouse, (int)false},
    {"mlookspeed", &amp;mlookspeed, 1000 / 64},
    {"translucency", (int *)&amp;global_flags.trans, 1},
   
    // -ES- 1998/11/28 Save fade settings
    {"telept_effect", &amp;telept_effect, 0},
    {"telept_reverse", &amp;telept_reverse, 0},
    {"telept_flash", &amp;telept_flash, 1},
    {"wipe_method", &amp;wipe_method, WIPE_Melt},
    {"wipe_reverse", &amp;wipe_reverse, 0},
    {"crosshair", &amp;crosshair, 0},
    {"stretchsky", (int *)&amp;global_flags.stretchsky, 1},
    {"rotatemap", (int *)&amp;rotatemap, 0},
    {"newhud", (int *)&amp;newhud, 0},
    {"respawnsetting", (int *)&amp;global_flags.res_respawn, 0},
    {"itemrespawn", (int *)&amp;global_flags.itemrespawn, 0},
    {"respawn", (int *)&amp;global_flags.respawn, 0},
    {"fastparm", (int *)&amp;global_flags.fastparm, 0},
    {"grav", &amp;global_flags.menu_grav, MENU_GRAV_NORMAL},
    {"true3dgameplay", (int *)&amp;global_flags.true3dgameplay, 0},
    {"autoaim", (int *)&amp;global_flags.autoaim, 1},
    {"missileteleport", &amp;missileteleport, 0},
    {"teleportdelay", &amp;teleportdelay, 0},

    // -KM- 1998/07/21 Save the blood setting
    {"blood", (int *)&amp;global_flags.more_blood, 0},
    {"extra", (int *)&amp;global_flags.have_extra, 1},
    {"shadows", (int *)&amp;global_flags.shadows, 1},
    {"halos", (int *)&amp;global_flags.halos, 0},
    {"weaponkick", (int *)&amp;global_flags.kicking, 1},
    {"jumping", (int *)&amp;global_flags.jump, 1},
    {"crouching", (int *)&amp;global_flags.crouch, 1},
    {"mipmapping", &amp;use_mipmapping, 1},
    {"smoothing", (int *)&amp;use_smoothing, 1},
    {"dlights", (int *)&amp;use_dlights, 0},
    {"dither", (int *)&amp;use_dithering, 0},
    {"detail_level", (int *)&amp;detail_level, 1},

#ifdef LINUX
    // -AJA- FIXME: gotta be a better way than this...
    {"mousedev", (int *)&amp;mousedev, (int)"/dev/ttyS0"},
    {"mousetype", (int *)&amp;mousetype, (int)"microsoft"},

    {"video", (int *)&amp;videoInterface, (int)"x"},
    {"vid_path", (int *)&amp;vid_path, (int)"/usr/lib/games/doom"},
#endif

    // -KM- 1998/09/01 Useless mouse/joy stuff removed,
    //                 analogue binding added
    {"use_mouse",   &amp;usemouse,    1},
    {"mouse_xaxis", &amp;mouse_xaxis, 0},
    {"mouse_yaxis", &amp;mouse_yaxis, 0},

    // -ACB- 1998/09/06 Two-stage turning &amp; Speed controls added
    {"twostage_turning",  (int *)&amp;stageturn, 0},
    {"forwardmove_speed", &amp;forwardmovespeed, 0},
    {"angleturn_speed",   &amp;angleturnspeed,   0},
    {"sidemove_speed",    &amp;sidemovespeed,    0},

    {"use_joystick", &amp;usejoystick, 0},
    {"joy_xaxis", &amp;joy_xaxis, 0},
    {"joy_yaxis", &amp;joy_yaxis, 0},

    {"screenblocks", &amp;screenblocks, 10},
    // -ES- 1999/03/30 Added fov stuff.
    {"fieldofview", &amp;cfgnormalfov, 90},
    {"zoomedfieldofview", &amp;cfgzoomedfov, 10},

    {"darken_screen", &amp;darken_screen, 1},
    {"snd_channels",  &amp;dummysndchan, 3},
    {"usegamma",      &amp;current_gamma, 0},

    {"key_right",      &amp;key_right,      0},
    {"key_left",       &amp;key_left,       0},
    {"key_up",         &amp;key_up,         0},
    {"key_down",       &amp;key_down,       0},
    {"key_lookup",     &amp;key_lookup,     0},
    {"key_lookdown",   &amp;key_lookdown,   0},
    {"key_lookcenter", &amp;key_lookcenter, 0},

    // -ES- 1999/03/28 Zoom Key
    {"key_zoom",        &amp;key_zoom,        0},
    {"key_strafeleft",  &amp;key_strafeleft,  0},
    {"key_straferight", &amp;key_straferight, 0},

    // -ACB- for -MH- 1998/07/02 Flying Keys
    {"key_flyup",   &amp;key_flyup,           0},
    {"key_flydown", &amp;key_flydown,         0},

    {"key_fire",       &amp;key_fire,         0},
    {"key_use",        &amp;key_use,          0},
    {"key_strafe",     &amp;key_strafe,       0},
    {"key_speed",      &amp;key_speed,        0},
    {"key_autorun",    &amp;key_autorun,      0},
    {"key_nextweapon", &amp;key_nextweapon,   0},

    {"key_jump",      &amp;key_jump,          0},
    {"key_180",       &amp;key_180,           0},
    {"key_map",       &amp;key_map,           0},
    {"key_talk",      &amp;key_talk,          0},
    {"key_mlook",     &amp;key_mlook,         0},  // -AJA- 1999/07/27.
    {"key_secondatk", &amp;key_secondatk,     0},  // -AJA- 2000/02/08.

    {"chatmacro0", (int *)&amp;chat_macros[0], 0},  //(int) HUSTR_CHATMACRO0 },
    {"chatmacro1", (int *)&amp;chat_macros[1], 0},  //(int) HUSTR_CHATMACRO1 },
    {"chatmacro2", (int *)&amp;chat_macros[2], 0},  //(int) HUSTR_CHATMACRO2 },
    {"chatmacro3", (int *)&amp;chat_macros[3], 0},  //(int) HUSTR_CHATMACRO3 },
    {"chatmacro4", (int *)&amp;chat_macros[4], 0},  //(int) HUSTR_CHATMACRO4 },
    {"chatmacro5", (int *)&amp;chat_macros[5], 0},  //(int) HUSTR_CHATMACRO5 },
    {"chatmacro6", (int *)&amp;chat_macros[6], 0},  //(int) HUSTR_CHATMACRO6 },
    {"chatmacro7", (int *)&amp;chat_macros[7], 0},  //(int) HUSTR_CHATMACRO7 },
    {"chatmacro8", (int *)&amp;chat_macros[8], 0},  //(int) HUSTR_CHATMACRO8 },
    {"chatmacro9", (int *)&amp;chat_macros[9], 0}  //(int) HUSTR_CHATMACRO9 }
};

int numdefaults;
const char *cfgfile = NULL;

// TGA Graphics Header
typedef enum
{
  tga_id = 0,
  tga_cmaptype = 1,
  tga_imgtype = 2,
  tga_cmapfirst = 3,
  tga_cmaplen = 5,
  tga_cmapsize = 7,
  tga_imgorgx = 8,
  tga_imgorgy = 10,
  tga_imgwidth = 12,
  tga_imgheight = 14,
  tga_imgbpp = 16,
  tga_imgbits = 17
}
tgaheader_e;
</t>
<t tx="T1600">@ ======================= INTERNALS =======================

WriteTGAFile

Each pixel in `buffer' is three bytes (R,G,B).
@c

static void WriteTGAFile(const char *filename, int width, int height, 
    byte *buffer)
{
  FILE *fp;
  byte tgahead[18], *cr, *cb, tmp;
  int i;

  if ((fp = fopen(filename, "wb")) != NULL)
  {
    Z_Clear(tgahead, byte, 18);
    
    tgahead[tga_imgtype] = 2;  // Unmapped RGB
    tgahead[tga_imgbpp] = 24;  // 3 byte colours (B,G,R)
    
    *((short *) &amp;tgahead[tga_imgwidth])  = width;
    *((short *) &amp;tgahead[tga_imgheight]) = height;

    // flip the blue and red color components

    cr = &amp;buffer[2];
    cb = &amp;buffer[0];
    
    for (i=0; i &lt; (width*height); i++, cr += 3, cb += 3)
    {
      tmp = *cb;
      *cb = *cr;
      *cr = tmp;
    }

    fwrite(tgahead, 18, 1, fp);
    fwrite(buffer, sizeof(byte)*width*height*3, 1, fp);
    fclose(fp);
  }
}
</t>
<t tx="T1601">@ ===================== END OF INTERNALS =====================

M_WriteFile
@c

boolean_t M_WriteFile(char const *name, void *source, int length)
{
  int handle;
  int count;

  handle = open(name, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);

  if (handle == -1)
    return false;

  count = write(handle, source, length);
  close(handle);

  if (count &lt; length)
    return false;

  return true;
}
</t>
<t tx="T1602">@ M_ReadFile
@c

int M_ReadFile(char const *name, byte ** buffer)
{
  int handle, count, length;
  struct stat fileinfo;
  byte *buf;

  handle = open(name, O_RDONLY | O_BINARY);

  if (handle == -1)
    I_Error("Couldn't read file %s", name);
  if (fstat(handle, &amp;fileinfo) == -1)
    I_Error("Couldn't read file %s", name);
  length = fileinfo.st_size;
  buf = Z_New(byte, length);
  count = read(handle, buf, length);
  close(handle);

  if (count &lt; length)
    I_Error("Couldn't read file %s", name);

  *buffer = buf;
  return length;
}
</t>
<t tx="T1603">@ M_SaveDefaults
@c

void M_SaveDefaults(void)
{
  int i;
  int v;
  FILE *f;

  // Don't want to save settings in a network game: might not
  // be ours.
  if (netgame)
    return;

  // -ACB- 1999/09/24 idiot proof checking as required by MSVC
  DEV_ASSERT2(cfgfile);

  // -ACB- 1999/10/10 Sound API Values need to be set
  cfgmusic = S_GetMusicVolume();
  cfgsound = S_GetSfxVolume();

  f = fopen(cfgfile, "w");
  if (!f)
  {
    I_Warning("Couldn't open config file %s for writing.", cfgfile);
    return;  // can't write the file, but don't complain
  }

  for (i = 0; i &lt; numdefaults; i++)
  {
    if ((defaults[i].defaultvalue &gt; -0xfff
            &amp;&amp; defaults[i].defaultvalue &lt; 0xfff) || (memcmp(defaults[i].name, "key_", 4) == 0))
    {
      v = *defaults[i].location;

      if (memcmp(defaults[i].name, "key_", 4) == 0)
        fprintf(f, "%s\t\t0x%X\no%s\t\t0x%X\n", defaults[i].name, v, defaults[i].name, v &lt;&lt; 16);
      else
        fprintf(f, "%s\t\t%i\n", defaults[i].name, v);
    }
    else
    {
      fprintf(f, "%s\t\t\"%s\"\n", defaults[i].name,
                    *(char **)(defaults[i].location));
    }
  }

  fclose(f);
}
</t>
<t tx="T1604">@ M_LoadDefaults
@c

boolean_t M_LoadDefaults(void)
{
  int i;
  FILE *f;
  char def[80];
  char strparm[100];
  char *newstring = 0;
  int parm;
  boolean_t isstring;

  // set everything to base values
  numdefaults = sizeof(defaults) / sizeof(defaults[0]);
  for (i = 0; i &lt; numdefaults; i++)
    *defaults[i].location = defaults[i].defaultvalue;

  I_Printf("  from %s\n", cfgfile);

  // read the file in, overriding any set defaults
  f = fopen(cfgfile, "r");
  if (f)
  {
    while (!feof(f))
    {
      isstring = false;
      if (fscanf(f, "%79s %[^\n]\n", def, strparm) != 2)
        continue;

      if (strparm[0] == '"')
      {
        // get a string default
        isstring = true;
        // overwrite the last "
        strparm[strlen(strparm) - 1] = 0;
        // skip the first "
        newstring = Z_StrDup(strparm + 1);
      }
      else if (strparm[0] == '0' &amp;&amp; strparm[1] == 'x')
        sscanf(strparm + 2, "%x", &amp;parm);
      else
        sscanf(strparm, "%i", &amp;parm);

      // backwards compatibility
      if (strcmp(def, "bpp") == 0)
      {
        SCREENBITS = parm * 8;
        continue;
      }
      
      for (i = 0; i &lt; numdefaults; i++)
      {
        if (!strcmp(def, defaults[i].name))
        {
          if (!isstring)
          {
            if (memcmp(defaults[i].name, "key_", 4) != 0)
            {
              *defaults[i].location = parm;
            }
            else
            {
              if (parm != 0)
                *defaults[i].location = parm;
            }
          }
          else
            *defaults[i].location = (int)newstring;
          break;
        }
        if (def[0] == 'o')
          if (!strcmp(def + 1, defaults[i].name))
            if (!isstring)
              if (memcmp(defaults[i].name, "key_", 4) == 0)
                if (parm != 0)
                  *defaults[i].location |= parm &lt;&lt; 16;
      }
    }

    fclose(f);
  }
  else
  {
    I_Warning("Couldn't open config file %s for reading.\n", cfgfile);
    I_Warning("Resetting config to RECOMMENDED values...\n");

    M_ResetToDefaults(0);
  }

  // -ACB- 1999/10/10 Sound API Values need to be set
  S_SetMusicVolume(cfgmusic);
  S_SetSfxVolume(cfgsound);

  return true;
}
</t>
<t tx="T1605">@ M_DisplayDisk

Displays disk during loading...
@c

void M_DisplayDisk(void)
{
  int w, h;

  if (!graphicsmode)
    return;

  if (!display_disk)
    return;
   
  if (!disk_image)
    disk_image = W_ImageFromPatch("STDISK");

  // reset flag
  display_disk = false;

  w = IM_WIDTH(disk_image);
  h = IM_HEIGHT(disk_image);

  VCTX_Image320(314 - w, 164 - h, w, h, disk_image);
}
</t>
<t tx="T1606">@ M_DisplayAir

Displays air indicator when underwater
@c

void M_DisplayAir(void)
{
  int i;
  
  if (!graphicsmode)
    return;

  if (consoleplayer-&gt;playerstate != PST_LIVE)
    return;

  if (! consoleplayer-&gt;underwater)
    return;

  // load in patches for air indicator
  if (!air_images[0])
  {
    for (i=1; i &lt;= 21; i++)
    {
      char buffer[16];
      sprintf(buffer, "AIRBAR%02d", i);
      air_images[i - 1] = W_ImageFromPatch(buffer);
    }
  }

  DEV_ASSERT2(consoleplayer-&gt;mo);

  i = 21;

  if (consoleplayer-&gt;air_in_lungs &gt; 0)
  {
    int nom = consoleplayer-&gt;air_in_lungs;
    int denom = consoleplayer-&gt;mo-&gt;info-&gt;lung_capacity;
    
    i = 1 + (20 * (denom - nom) / denom);

    DEV_ASSERT2(1 &lt;= i &amp;&amp; i &lt;= 20);
  }
  
  VCTX_ImageEasy320(0, 0, air_images[i - 1]);
}
</t>
<t tx="T1607">
#define PIXEL_RED(pix)  (playpal_data[0][pix][0])
#define PIXEL_GRN(pix)  (playpal_data[0][pix][1])
#define PIXEL_BLU(pix)  (playpal_data[0][pix][2])

//
// M_ScreenShot
//
void M_ScreenShot(void)
{
#ifdef USE_GL
  byte *buffer;
  char filename[14];
  int i;

  // find a file name to save it to
  strcpy(filename,"SHOT0000.TGA");

  for (i = 0; i &lt;= 9999; i++)
  {
    filename[4] =  i / 1000 + '0';
    filename[5] = (i % 1000) / 100 + '0';
    filename[6] = (i % 100) / 10 + '0';
    filename[7] = i % 10 + '0';
  
    if (! I_Access(filename))
      break; // file doesn't exist
  }

  buffer = (byte*)Z_Malloc(SCREENWIDTH*SCREENHEIGHT*4);

  glReadBuffer(GL_FRONT);
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
  glReadPixels(0, 0, SCREENWIDTH, SCREENHEIGHT, GL_RGB, GL_UNSIGNED_BYTE, buffer);

  WriteTGAFile(filename, SCREENWIDTH, SCREENHEIGHT, buffer);

  Z_Free(buffer);
#else
  int i;
  byte *buffer;
  byte *startbuff;
  char filename[14];
  truecol_info_t colinfo;
  byte *bytepixel;
  byte *bytedata;
  short *pixel;
  short *data;
  int xcount;
  int ycount;

  buffer = Z_ClearNew(byte, main_scr-&gt;width*main_scr-&gt;height*3);

  startbuff = buffer;

  // find a file name to save it to
  strcpy(filename,"SHOT0000.TGA");

  for (i = 0; i &lt;= 9999; i++)
  {
    filename[4] =  i / 1000 + '0';
    filename[5] = (i % 1000) / 100 + '0';
    filename[6] = (i % 100) / 10 + '0';
    filename[7] = i % 10 + '0';
  
    if (! I_Access(filename))
      break; // file doesn't exist
  }

  if (main_scr-&gt;bytepp == 1)
  {
    bytedata = (byte*) main_scr-&gt;data;

    ycount = (main_scr-&gt;height-1);
    do
    {
      bytepixel = &amp;bytedata[main_scr-&gt;pitch*ycount];

      xcount = 0;
      do
      {
        V_IndexColourToRGB(bytepixel[xcount], buffer);
        buffer+=3;
        xcount++;
      }
      while (xcount &lt; main_scr-&gt;width);

      ycount--;
    }
    while (ycount &gt;= 0);
  }
  else
  {
    I_GetTruecolInfo(&amp;colinfo);

    data = (short*) main_scr-&gt;data;

    ycount = (main_scr-&gt;height-1);
    do
    {
      pixel = &amp;data[(main_scr-&gt;pitch*ycount)/sizeof(short)];

      xcount = 0;
      do
      {
        *buffer = (byte)((pixel[xcount]&amp;colinfo.red_mask)  &gt;&gt;colinfo.red_shift  )&lt;&lt;(8-colinfo.red_bits);
        buffer++;
        
        *buffer = (byte)((pixel[xcount]&amp;colinfo.green_mask)&gt;&gt;colinfo.green_shift)&lt;&lt;(8-colinfo.green_bits);
        buffer++; 
        
        *buffer = (byte)((pixel[xcount]&amp;colinfo.blue_mask) &gt;&gt;colinfo.blue_shift )&lt;&lt;(8-colinfo.blue_bits);
        buffer++;
        
        
        xcount++;
      }
      while (xcount &lt; main_scr-&gt;width);

      ycount--;
    }
    while (ycount &gt;= 0);
  }

  WriteTGAFile(filename, main_scr-&gt;width, main_scr-&gt;height, startbuff);

  Z_Free(startbuff);
#endif
}
</t>
<t tx="T1608">@ M_MakeSaveScreenShot
@c

void M_MakeSaveScreenShot(void)
{
#ifdef USE_GL
  /// FIXME:
  // buffer = (byte*)Z_Malloc(SCREENWIDTH*SCREENHEIGHT*4);
  // glReadBuffer(GL_FRONT);
  // glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
  // glReadPixels(0, 0, SCREENWIDTH, SCREENHEIGHT, GL_RGB, GL_UNSIGNED_BYTE, buffer);
  // ...
  // Z_Free(buffer);
  
#else
  int x, y;
  int ax, ay;

  byte pixel;
  unsigned short rgb;
  truecol_info_t colinfo;

  save_screenshot_valid = true;

  I_GetTruecolInfo(&amp;colinfo);

  switch (main_scr-&gt;bytepp)
  {
    case 1:
    {
      byte *top = (byte *) main_scr-&gt;data;

      top += viewwindowy * main_scr-&gt;pitch + viewwindowx;

      for (y=0; y &lt; 100; y++)
      for (x=0; x &lt; 160; x++)    
      {
        ax = x * viewwindowwidth  / 160;
        ay = y * viewwindowheight / 100;

        DEV_ASSERT2(0 &lt;= ax &amp;&amp; ax &lt; SCREENWIDTH);
        DEV_ASSERT2(0 &lt;= ay &amp;&amp; ay &lt; SCREENHEIGHT);

        pixel = top[ay * main_scr-&gt;pitch + ax];

        rgb = ((PIXEL_RED(pixel) &amp; 0xF8) &lt;&lt; 7) |
              ((PIXEL_GRN(pixel) &amp; 0xF8) &lt;&lt; 2) |
              ((PIXEL_BLU(pixel) &amp; 0xF8) &gt;&gt; 3);
        
        save_screenshot[x][y] = rgb;
      }
    }
    break;

    case 2:
    {
      unsigned short *top = (unsigned short *) main_scr-&gt;data;

      top += viewwindowy * main_scr-&gt;pitch/2 + viewwindowx;

      for (y=0; y &lt; 100; y++)
      for (x=0; x &lt; 160; x++)    
      {
        ax = x * viewwindowwidth  / 160;
        ay = y * viewwindowheight / 100;

        DEV_ASSERT2(0 &lt;= ax &amp;&amp; ax &lt; SCREENWIDTH);
        DEV_ASSERT2(0 &lt;= ay &amp;&amp; ay &lt; SCREENHEIGHT);

        rgb = top[ay * main_scr-&gt;pitch/2 + ax];

        // hack !
        if (colinfo.green_bits == 6)
          rgb = ((rgb &amp; 0xFFC0) &gt;&gt; 1) | (rgb &amp; 0x001F);
        
        save_screenshot[x][y] = rgb;
      }
    }
    break;
  }
#endif
}
</t>
<t tx="T1609">@ M_CheckExtension

Checks a filename extension against one given.

returns:
EXT_WEIRD (one of the parameters given was bad)
EXT_NONE (filename has no extension)
EXT_MATCHING (filename has a matching extension)
EXT_NOTMATCHING (filename has an extension, but it does not match)

-ACB- 1999/12/14 Written
@c

exttype_e M_CheckExtension(const char *ext, const char* filename)
{
  char filenameext[4];
  int i, ext_len, filename_len, filenameext_len;

  // check extension is valid
  if (ext == NULL)
    return EXT_WEIRD;

  ext_len = strlen(ext);

  if (ext_len &lt; 1 || ext_len &gt; 3)
    return EXT_WEIRD;

  for (i=0; i&lt;ext_len; i++)
  {
    if (!isalnum(ext[i]))
      return EXT_WEIRD;
  }

  // check filename is valid
  if (filename == NULL)
    return EXT_WEIRD;

  filename_len = strlen(filename);

  // Get filename extension
  i=(filename_len-1);
  while (i&gt;=0 &amp;&amp; filename[i] != '.')
    i--;

  if (i==-1 || i==(filename_len-1))
    return EXT_NONE;

  filenameext_len = ((filename_len-1)-i);

  // if the extension lengths differ, they can't match
  if (filenameext_len != ext_len)
    return EXT_NOTMATCHING;

  // copy extension to string to compare
  i=0;
  while (i&lt;filenameext_len)
  {
    filenameext[i] = filename[(filename_len-filenameext_len)+i];
    i++;
  }

  // add terminator on the end
  filenameext[filenameext_len] = '\0';

  // compare ignoring case: non-zero means not matching
  if (stricmp(filenameext, ext))
    return EXT_NOTMATCHING;

  return EXT_MATCHING;
}
</t>
<t tx="T1610">@ M_ComposeFileName

Allocates memory for and creates the file name "dir/file", or
just "file" if it was an absolute address.
@c

char *M_ComposeFileName(const char *dir, const char *file)
{
  char *path;

  if (I_PathIsAbsolute(file))
  {
    path = Z_StrDup(file);
  }
  else
  {
    path = Z_New(char, strlen(dir) + strlen(file) + 2);
    sprintf(path, "%s%c%s", dir, DIRSEPARATOR, file);
  }
  return path;
}
</t>
<t tx="T1611">@ M_GetFileData

Loads file into memory. This sets a pointer to the data and
the length.

NOTE: The data must be freed by Z_Free() when not used.

Returns false on failure.

-ACB- 2000/01/08

-ES- 2000/06/12 Now returns the allocated pointer, or NULL on failure.
@c

byte *M_GetFileData(char *filename, int *length)
{
  FILE *lumpfile;
  byte *data;

  // Sanity Checks..
  DEV_ASSERT2(filename);
  DEV_ASSERT2(length);

  lumpfile = fopen(filename, "rb");  
  if (!lumpfile)
  {
    I_Warning("M_GetFileData: Cannot open '%s'\n", filename);
    return NULL;
  }

  fseek(lumpfile, 0, SEEK_END);                   // get the end of the file
  (*length) = ftell(lumpfile);                    // get the size
  fseek(lumpfile, 0, SEEK_SET);                   // reset to beginning
  data = Z_New(char, (*length) + 1);              // malloc the size
  fread(data, sizeof(char), (*length), lumpfile); // read file
  fclose(lumpfile);                               // close the file

  return data;
}
</t>
<t tx="T1612">@ M_WarnError

Either displays a warning or produces a fatal error, depending on
whether the "-strict" option is used.
@c

void M_WarnError(const char *error,...)
{
  va_list argptr;
  char message_buf[4096];

  message_buf[4095] = 0;

  va_start(argptr, error);
  vsprintf(message_buf, error, argptr);
  va_end(argptr);

  // I hope nobody is printing strings longer than 4096 chars...
  DEV_ASSERT2(message_buf[4095] == 0);

  if (strict_errors)
    I_Error("%s", message_buf);
  else if (! no_warnings)
    I_Warning("%s", message_buf);
}
</t>
<t tx="T1613">@ L_WriteDebug

Write into the debug file.

-ACB- 1999/09/22: From #define to Procedure
-AJA- 2001/02/07: Moved here from platform codes.
@c

void L_WriteDebug(const char *message,...)
{
  va_list argptr;
  char message_buf[4096];

  if (!debugfile)
    return;

  // -ACB- 2001/02/08 Clear the message buffer
  memset(&amp;message_buf, 0, sizeof(char)*4096);

  // Print the message into a text string
  va_start(argptr, message);
  vsprintf(message_buf, message, argptr);
  va_end(argptr);

  // I hope nobody is printing strings longer than 4096 chars...
  DEV_ASSERT2(message_buf[4095] == 0);

  fprintf(debugfile, "%s", message_buf);
  fflush(debugfile);
}
</t>
<t tx="T1614">@ L_ConvertToDB

Converts the linear input volume to a DB output volume in the range
`min..max'. Input ranges from 0-255. This call is expensive,
should be used to build a lookup table.
@c

int L_ConvertToDB(int volume, int min, int max)
{
  float_t tmp;
  int result;

  DEV_ASSERT2(0 &lt;= volume &amp;&amp; volume &lt;= 255);

  tmp = 1.0 - log(256.0 / (volume + 1.0)) / log(256.0);

  result = min + (int) ((max - min) * tmp);

  // clamp result, in case of underflow/overflow
  return MAX(min, MIN(max, result));
}
</t>
<t tx="T1615">@ L_CompareTimeStamps

Returns -1 for less, 0 for equals, and +1 for greater.
I.e. the same values as used by strcmp() and friends.
@c

int L_CompareTimeStamps(i_time_t *A, i_time_t *B)
{
  int a_index;
  int b_index;

  // Form an index to compare the dates
  a_index = (A-&gt;year * 10000) + (A-&gt;month * 100) + A-&gt;day;
  b_index = (B-&gt;year * 10000) + (B-&gt;month * 100) + B-&gt;day;

  if (a_index &lt; b_index)
    return -1;
  else if (a_index &gt; b_index)
    return +1;

  // Form an index to compare times
  a_index = (A-&gt;hours * 10000) + (A-&gt;minutes * 100) + A-&gt;secs;
  b_index = (B-&gt;hours * 10000) + (B-&gt;minutes * 100) + B-&gt;secs;

  if (a_index &lt; b_index)
    return -1;
  else if (a_index &gt; b_index)
    return +1;
  else
    return 0;
}
</t>
<t tx="T1616">@ignore
@language c

// Option Menu Modification

// Original Author: Chi Hoang
//
// -ACB- 1998/06/15 All functions are now m_* to follow doom standard.
//
// -MH-  1998/07/01 Shoot Up/Down becomes "True 3D Gameplay"
//                  Added keys for fly up and fly down
//
// -KM-  1998/07/10 Used better names :-) (Controls Menu)
//
// -ACB- 1998/07/10 Print screen is now possible in this menu
//
// -ACB- 1998/07/12 Removed Lost Soul/Spectre Ability Menu Entries
//
// -ACB- 1998/07/15 Changed menu structure for graphic titles
//
// -ACB- 1998/07/30 Remove M_SetRespawn and the newnmrespawn &amp;
//                  respawnmonsters. Used new respawnsetting variable.
//
// -ACB- 1998/08/10 Edited the menu's to reflect the fact that currentmap
//                  flags can prevent changes.
//
// -ES-  1998/08/21 Added resolution options
//
// -ACB- 1998/08/29 Modified Resolution menus for user-friendlyness
//
// -ACB- 1998/09/06 MouseOptions renamed to AnalogueOptions
//
// -ACB- 1998/09/11 Cleaned up and used new white text colour for menu
//                  selections
//
// -KM- 1998/11/25 You can scroll backwards through the resolution list!
//
// -ES- 1998/11/28 Added faded teleportation option
//
// -ACB- 1999/09/19 Removed All CD Audio References.
//
// -ACB- 1999/10/11 Reinstated all sound volume controls.
//
// -ACB- 1999/11/19 Reinstated all music volume controls.
//
// -ACB- 2000/03/11 All menu functions now have the keypress passed
//                  that called them.
//
// -ACB- 2000/03/12 Menu resolution hack now allow user to cycle both
//                  ways through the resolution list.
//                  
// -AJA- 2001/07/26: Reworked colours, key config, and other code.

&lt;&lt; m_option #includes &gt;&gt;
&lt;&lt; m_option declarations &gt;&gt;
@others
</t>
<t tx="T1617">#include "i_defs.h"
#include "m_option.h"

#include "dm_state.h"

#include "ddf_main.h"
#include "g_game.h"
#include "hu_stuff.h"
#include "m_menu.h"
#include "m_misc.h"
#include "p_local.h"
#include "r_main.h"
#include "r_vbinit.h"
#include "r2_defs.h"
#include "s_sound.h"
#include "v_ctx.h"
#include "v_res.h"
#include "v_colour.h"
#include "w_image.h"
#include "w_wad.h"
#include "wp_main.h"
#include "z_zone.h"
</t>
<t tx="T1618">
#define OPTSHADE  text_white_map

int optionsmenuon = 0;

//submenus
static void M_StandardControlOptions(int keypressed);
static void M_ExtendedControlOptions(int keypressed);

static void M_VideoOptions(int keypressed);
static void M_GameplayOptions(int keypressed);
static void M_AnalogueOptions(int keypressed);

static void M_CalibrateJoystick(int keypressed);

void M_ResetToDefaults(int keypressed);

static void M_Key2String(int key, char *deststring);

// -ACB- 1998/08/09 "Does Map allow these changes?" procedures.
static void M_ChangeMonsterRespawn(int keypressed);
static void M_ChangeItemRespawn(int keypressed);
static void M_ChangeStretchSky(int keypressed);
static void M_ChangeTransluc(int keypressed);
static void M_ChangeTrue3d(int keypressed);
static void M_ChangeAutoAim(int keypressed);
static void M_ChangeFastparm(int keypressed);
static void M_ChangeRespawn(int keypressed);

//Special function declarations
int menunormalfov, menuzoomedfov;
int screen_size;

static void M_ChangeBlood(int keypressed);
static void M_ChangeJumping(int keypressed);
static void M_ChangeCrouching(int keypressed);
static void M_ChangeExtra(int keypressed);
static void M_ChangeGamma(int keypressed);
static void M_ChangeShadows(int keypressed);
static void M_ChangeHalos(int keypressed);
static void M_ChangeCompatMode(int keypressed);
static void M_ChangeKicking(int keypressed);
static void M_ChangeMipMap(int keypressed);
static void M_ChangeDLights(int keypressed);

// -ES- 1998/08/20 Added resolution options
// -ACB- 1998/08/29 Moved to top and tried different system

static void M_ResOptDrawer(int topy, int bottomy, int dy, int centrex);
static void M_ResolutionOptions(int keypressed);
static void M_OptionSetResolution(int keypressed);
static void M_OptionTestResolution(int keypressed);
static void M_RestoreResSettings(int keypressed);
static void M_ChangeStoredRes(int keypressed);
static void M_ChangeStoredBpp(int keypressed);

static void M_LanguageDrawer(int x, int y, int deltay);
static void M_ChangeLanguage(int keypressed);

static char YesNo[] = "Off/On";  // basic on/off
static char CompatSet[] = "EDGE/Boom";
static char CrosO[] = "None/Cross/Dot/Angle";  // crosshair options
static char Respw[] = "Teleport/Resurrect";  // monster respawning
static char Axis[] = "Turn/Forward/Strafe/MLook/Fly/Disable";

// Screen resolution changes
static int prevscrmode;
static int selectedscrmode;
static int testticker = -1;
static char setreserror[128];

// Volume Changes
static int menumusicvol;
static int menusoundvol;

// -ES- 1998/11/28 Wipe and Faded teleportation options
//static char FadeT[] = "Off/On, flash/On, no flash";
static char AAim[] = "Off/On/Mlook";
static char MipMaps[] = "None/Good/Best";
static char DLights[] = "Off/On";
static char Details[] = "Low/Medium/High";

static int scrcomp_o;


//
//  OPTION STRUCTURES
//

typedef struct optmenuitem_s
{
  enum
  {
    OPT_Plain = 0,      // 0 means plain text,
    OPT_Switch = 1,     // 1 is change a switch,
    OPT_Function = 2,   // 2 is call a function,
    OPT_Slider = 3,     // 3 is a slider,
    OPT_KeyConfig = 4   // 4 is a key config
  }
  type;

  char name[48];
  const char *typenames;
  
  int numtypes;
  int default_val;
  int *switchvar;
  
  void (*routine)(int keypressed);

  const char *help;
}
optmenuitem_t;


typedef struct menuinfo_s
{
  // array of menu items
  optmenuitem_t *items;
  int item_num;

  int menu_center;

  // title information
  int title_x;
  char title_name[10];
  const image_t *title_image;

  // current position
  int pos;

  // key config, with left and right sister menus ?
  char key_page[20];

  struct menuinfo_s *sister_prev;
  struct menuinfo_s *sister_next;
}
menuinfo_t;

// current menu and position
static menuinfo_t *curr_menu;
static optmenuitem_t *curr_item;
static int keyscan;

typedef struct specialkey_s
{
  int keycode;
  char keystring[20];
}
specialkey_t;
</t>
<t tx="T1619">
static void M_Toggle3dMode(int keypressed)
{
  R_SetViewSize(screenblocks);
}
</t>
<t tx="T1620">
static void M_ChangeScreenSize(int keypressed)
{
  R_SetViewSize(screen_size + 3);
}
</t>
<t tx="T1621">@ M_ChangeMusVol

-ACB- 1999/11/13 Music API Change implemented
@c

static void M_ChangeMusVol(int keypressed)
{
  S_SetMusicVolume(menumusicvol);
  return;
}
</t>
<t tx="T1622">@ M_ChangeSfxVol

-ACB- 1999/10/07 Sound API Change implemented
@c

static void M_ChangeSfxVol(int keypressed)
{
  S_SetSfxVolume(menusoundvol);
  return;
}
</t>
<t tx="T1623">@ M_ChangeNormalFOV
@c

static void M_ChangeNormalFOV(int keypressed)
{
  R_SetNormalFOV((ANG45 / 9) * (menunormalfov + 1));
}
</t>
<t tx="T1624">
static void M_ChangeZoomedFOV(int keypressed)
{
  R_SetZoomedFOV((ANG45 / 9) * (menuzoomedfov + 1));
}
</t>
<t tx="T1625">
static void M_ChangeScreenComp(int keypressed)
{
  screencomposition = scrcomp_o;
  setsizeneeded = 1;
}
</t>
<t tx="T1626">@ MAIN MENU

-ACB- 1998/07/15 Altered menu structure
-ACB- 1999/10/07 Removed sound references: New Sound API
@c

static optmenuitem_t mainmenu[] =
{
  {2, "Keyboard Controls", NULL, 0, 0, NULL, M_StandardControlOptions, "Controls"},
  {2, "Mouse Options", NULL, 0, 0, NULL, M_AnalogueOptions, "AnalogueOptions"},
  {2, "Gameplay Options", NULL, 0, 0, NULL, M_GameplayOptions, "GameplayOptions"},
  {2, "Video Options", NULL, 0, 0, NULL, M_VideoOptions, "VideoOptions"},
  {2, "Set Resolution", NULL, 0, 0, NULL, M_ResolutionOptions, "ChangeRes"},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {2, "Language", NULL, 0, 0, NULL, M_ChangeLanguage, NULL},
  {1, "Messages", YesNo, 2, 1, &amp;showMessages, NULL, "Messages"},
  {1, "Swap Stereo", YesNo, 2, 0, (int *)&amp;swapstereo, NULL, "SwapStereo"},
  {3, "Sound Volume", NULL, 16, 12,  &amp;menusoundvol, M_ChangeSfxVol, NULL},
  {3, "Music Volume", NULL, 16, 12,  &amp;menumusicvol, M_ChangeMusVol, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {2, "Reset to Defaults", NULL, 0, 0, NULL, M_ResetToDefaults, "ResetToDefaults"}
};

static menuinfo_t mainmenuinfo = 
{
  mainmenu, sizeof(mainmenu) / sizeof(optmenuitem_t), 
  164, 108, "M_OPTTTL", NULL, 0, "", NULL, NULL
};

//
//  VIDEO OPTIONS
//
// -ACB- 1998/07/15 Altered menu structure

// screen compostion routines
static char scrcomps[] = "Classic/Double Y/Low detail/Blur 1/Blur 2/Low detail at edges/Auto Detail/3x FOV/10x FOV";

// -ES- 1999/03/29 New fov stuff
static optmenuitem_t vidoptions[] =
{
  {3, "Brightness", NULL, 5, 0, &amp;current_gamma, M_ChangeGamma, NULL},
  {3, "Screensize", NULL, 9, 7, &amp;screen_size, M_ChangeScreenSize, NULL},
  {3, "Field Of View", NULL, 35, 17, &amp;menunormalfov, M_ChangeNormalFOV, NULL},
  {3, "Zoomed FOV", NULL, 35, 1, &amp;menuzoomedfov, M_ChangeZoomedFOV, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {1, "Translucency", YesNo, 2, 1, (int *)&amp;global_flags.trans, M_ChangeTransluc, NULL},
  {1, "Mipmapping", MipMaps, 3, 0, &amp;use_mipmapping, M_ChangeMipMap, NULL},
  {1, "Smoothing", YesNo, 2, 1, (int *)&amp;use_smoothing, M_ChangeMipMap, NULL},
  {1, "Shadows", YesNo, 2, 0, (int *)&amp;global_flags.shadows, M_ChangeShadows, NULL},
  {1, "Dynamic Lighting", DLights, 2, 0, (int *)&amp;use_dlights, M_ChangeDLights, NULL},
  {1, "Detail Level", Details, 3, 1, (int *)&amp;detail_level, NULL, NULL},
  {1, "Crosshair", CrosO, 4, 0, &amp;crosshair, NULL, NULL},
  {1, "Map Rotation", YesNo, 2, 0, (int *)&amp;rotatemap, NULL, NULL},
  {1, "Map Overlay", YesNo, 2, 0, (int *)&amp;newhud, NULL, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {1, "Teleportation effect", WIPE_EnumStr, WIPE_NUMWIPES, 0, &amp;telept_effect, NULL, NULL},
  {1, "Teleport Flash", YesNo, 2, 1, &amp;telept_flash, NULL, NULL},
  {1, "Wipe method", WIPE_EnumStr, WIPE_NUMWIPES, 1, &amp;wipe_method, NULL, NULL} 
  
#if 0  // TEMPORARILY DISABLED (we need an `Advanced Options' menu)
  {1, "Screen Composition", scrcomps, 9, 0, &amp;scrcomp_o, M_ChangeScreenComp, NULL},
    {1, "Reverse effect", YesNo, 2, 0, &amp;telept_reverse, NULL, NULL},
    {1, "Reversed wipe", YesNo, 2, 0, &amp;wipe_reverse, NULL, NULL},
    {1, "Stretch Sky", YesNo, 2, 0, (int *)&amp;global_flags.stretchsky, M_ChangeStretchSky, NULL},
    {1, "Cyan/Red 3d effect", YesNo, 2, 0, &amp;use_3d_mode, M_Toggle3dMode, NULL},
#endif
};

static menuinfo_t vidoptionsinfo = 
{
  vidoptions, sizeof(vidoptions) / sizeof(optmenuitem_t),
  150, 77, "M_VIDEO", NULL, 0, "", NULL, NULL
};

//
//  SET RESOLUTION MENU
//
static optmenuitem_t resoptions[] =
{
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {2, "Change Size", NULL, 0, 0, NULL, M_ChangeStoredRes, NULL},
  {2, "Change Depth", NULL, 0, 0, NULL, M_ChangeStoredBpp, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {2, "Set Resolution", NULL, 0, 0, NULL, M_OptionSetResolution, NULL},
  {2, "Test Resolution", NULL, 0, 0, NULL, M_OptionTestResolution, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL}
};

static menuinfo_t resoptionsinfo = 
{
  resoptions, sizeof(resoptions) / sizeof(optmenuitem_t),
  150, 77, "M_VIDEO", NULL, 3, "", NULL, NULL
};

//
//  MOUSE OPTIONS
//
// -ACB- 1998/06/15 Added new mouse menu
// -KM- 1998/09/01 Changed to an analogue menu.  Must change those names
// -ACB- 1998/07/15 Altered menu structure
//
static optmenuitem_t analogueoptions[] =
{
  {1, "Invert Mouse", YesNo, 2, false, (int*)&amp;invertmouse, NULL, NULL},
  {1, "Mouse X Axis", Axis, 6, AXIS_TURN, &amp;mouse_xaxis, NULL, NULL},
  {1, "Mouse Y Axis", Axis, 6, AXIS_FORWARD, &amp;mouse_yaxis, NULL, NULL},
  {3, "MouseSpeed", NULL, 20, 8, &amp;mouseSensitivity, NULL, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {3, "MLook Speed", NULL, 20, 8, &amp;mlookspeed, NULL, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {1, "Two-Stage Turning", YesNo, 2, 0, (int *)&amp;stageturn, NULL, NULL},
  {3, "Turning Speed", NULL, 9, 0, &amp;angleturnspeed, NULL, NULL},
  {3, "Side Move Speed", NULL, 9, 0, &amp;sidemovespeed, NULL, NULL},
  {3, "Forward Move Speed", NULL, 9, 0, &amp;forwardmovespeed, NULL, NULL}

#if 0  // DISABLED, Because no joystick support yet
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {1, "Joystick X Axis", Axis, 6, AXIS_TURN, &amp;joy_xaxis, NULL, NULL},
  {1, "Joystick Y Axis", Axis, 6, AXIS_FORWARD, &amp;joy_yaxis, NULL, NULL},
  {2, "Calibrate Joystick", NULL, 0, 0, NULL, M_CalibrateJoystick, NULL}
#endif
};

static menuinfo_t analogueoptionsinfo = 
{
  analogueoptions, sizeof(analogueoptions) / sizeof(optmenuitem_t),
  150, 75, "M_MSETTL", NULL, 0, "", NULL, NULL
};

//
//  GAMEPLAY OPTIONS
//
// -ACB- 1998/07/15 Altered menu structure
// -KM- 1998/07/21 Change blood to switch
//
optmenuitem_t playoptions[] =
{
  {1, "Compatibility", CompatSet, 2, 0, (int *)&amp;global_flags.compat_mode, M_ChangeCompatMode, NULL},
  {1, "AutoAiming", AAim, 3, 1, (int *)&amp;global_flags.autoaim, M_ChangeAutoAim, NULL},
  {1, "Jumping", YesNo, 2, 0, (int *)&amp;global_flags.jump, M_ChangeJumping, NULL},
  {1, "Crouching", YesNo, 2, 0, (int *)&amp;global_flags.crouch, M_ChangeCrouching, NULL},
  {1, "Weapon Kick", YesNo, 2, 1, (int *)&amp;global_flags.kicking, M_ChangeKicking, NULL},
  {1, "More Blood", YesNo, 2, 0, (int *)&amp;global_flags.more_blood, M_ChangeBlood, "Blood"},
  {1, "Extras", YesNo, 2, 1, (int *)&amp;global_flags.have_extra, M_ChangeExtra, NULL},
  {1, "True 3D Gameplay", YesNo, 2, 1, (int *)&amp;global_flags.true3dgameplay, M_ChangeTrue3d, "True3d"},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {3, "Gravity", NULL, 20, 8, &amp;global_flags.menu_grav, NULL, "Gravity"},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {1, "Enemy Respawn Mode", Respw, 2, 0, (int *)&amp;global_flags.res_respawn, M_ChangeMonsterRespawn, NULL},
  {1, "Item Respawn", YesNo, 2, 0, (int *)&amp;global_flags.itemrespawn, M_ChangeItemRespawn, NULL},
  {1, "Fast Monsters", YesNo, 2, 0, (int *)&amp;global_flags.fastparm, M_ChangeFastparm, NULL},
  {1, "Respawn", YesNo, 2, 0, (int *)&amp;global_flags.respawn, M_ChangeRespawn, NULL}
};

static menuinfo_t playoptionsinfo = 
{
  playoptions, sizeof(playoptions) / sizeof(optmenuitem_t),
  160, 46, "M_GAMEPL", NULL, 0, "", NULL, NULL
};

//
//  KEY CONFIG : STANDARD
//
// -ACB- 1998/07/15 Altered menuinfo struct
// -KM- 1998/07/10 Used better names :-)
//
static optmenuitem_t stdkeyconfig[] =
{
  {4, "Primary Attack", NULL, 0, KEYD_RCTRL + (KEYD_MOUSE1 &lt;&lt; 16), &amp;key_fire, NULL, NULL},
  {4, "Secondary Atk", NULL, 0, 'E', &amp;key_secondatk, NULL, NULL},
  {4, "Use Item", NULL, 0, ' ', &amp;key_use, NULL, NULL},
  {4, "Walk Forward", NULL, 0, KEYD_UPARROW, &amp;key_up, NULL, NULL},
  {4, "Walk Backwards", NULL, 0, KEYD_DOWNARROW, &amp;key_down, NULL, NULL},
  {4, "Turn Left", NULL, 0, KEYD_LEFTARROW, &amp;key_left, NULL, NULL},
  {4, "Turn Right", NULL, 0, KEYD_RIGHTARROW, &amp;key_right, NULL, NULL},
  {4, "Move Up", NULL, 0, KEYD_INSERT, &amp;key_flyup, NULL, NULL},
  {4, "Move Down", NULL, 0, KEYD_DELETE, &amp;key_flydown, NULL, NULL},
  {4, "Toggle Autorun", NULL, 0, KEYD_CAPSLOCK, &amp;key_autorun, NULL, NULL},
  {4, "Run", NULL, 0, KEYD_RSHIFT, &amp;key_speed, NULL, NULL},
  {0, "", NULL, 0, 0, NULL, NULL, NULL},
  {4, "Strafe Left", NULL, 0, ',', &amp;key_strafeleft, NULL, NULL},
  {4, "Strafe Right", NULL, 0, '.', &amp;key_straferight, NULL, NULL},
  {4, "Strafe", NULL, 0, KEYD_RALT + (KEYD_MOUSE2 &lt;&lt; 16), &amp;key_strafe, NULL, NULL}
};

// forward declaration
static menuinfo_t extkeyconfiginfo;

static menuinfo_t stdkeyconfiginfo = 
{
  stdkeyconfig, sizeof(stdkeyconfig) / sizeof(optmenuitem_t),
  110, 98, "M_CONTRL", NULL, 0, 
  "STD", NULL, &amp;extkeyconfiginfo
};

//
//  KEY CONFIG : EXTENDED
//
// -ACB- 1998/07/15 Altered menuinfo struct
// -ES- 1999/03/28 Added Zoom Key
//
static optmenuitem_t extkeyconfig[] =
{
  {4, "Look Up", NULL, 0, KEYD_PGUP, &amp;key_lookup, NULL, NULL},
  {4, "Look Down", NULL, 0, KEYD_PGDN, &amp;key_lookdown, NULL, NULL},
  {4, "Center View", NULL, 0, KEYD_HOME, &amp;key_lookcenter, NULL, NULL},
  {4, "Zoom in/out", NULL, 0, '\\', &amp;key_zoom, NULL, NULL},
  {4, "180 degree turn", NULL, 0, 0, &amp;key_180, NULL, NULL},
  {4, "Jump", NULL, 0, '/', &amp;key_jump, NULL, NULL},
  {4, "Mouse Look", NULL, 0, 0, &amp;key_mlook, NULL, NULL},
  {4, "Map Toggle", NULL, 0, KEYD_TAB, &amp;key_map, NULL, NULL},
  {4, "Multiplay Talk", NULL, 0, 't', &amp;key_talk, NULL, NULL}
};

static menuinfo_t extkeyconfiginfo = 
{
  extkeyconfig, sizeof(extkeyconfig) / sizeof(optmenuitem_t),
  110, 98, "M_CONTRL", NULL, 0, 
  "EXT", &amp;stdkeyconfiginfo, NULL
};

static char keystring1[] = "Enter to change, Backspace to Clear";
static char keystring2[] = "Press a key for this action";

static specialkey_t specialkeylist[] =  // terminate on -1
{
    {KEYD_RIGHTARROW, "Right Arrow"},
    {KEYD_LEFTARROW, "Left Arrow"},
    {KEYD_UPARROW, "Up Arrow"},
    {KEYD_DOWNARROW, "Down Arrow"},
    {KEYD_ESCAPE, "Escape"},
    {KEYD_ENTER, "Enter"},
    {KEYD_TAB, "Tab"},
    {KEYD_F1, "F1"},
    {KEYD_F2, "F2"},
    {KEYD_F3, "F3"},
    {KEYD_F4, "F4"},
    {KEYD_F5, "F5"},
    {KEYD_F6, "F6"},
    {KEYD_F7, "F7"},
    {KEYD_F8, "F8"},
    {KEYD_F9, "F9"},
    {KEYD_F10, "F10"},
    {KEYD_F11, "F11"},
    {KEYD_F12, "F12"},
    {KEYD_BACKSPACE, "Backspace"},
    {KEYD_EQUALS, "Equals"},
    {KEYD_MINUS, "Minus"},
    {KEYD_RSHIFT, "Shift"},
    {KEYD_RCTRL, "Ctrl"},
    {KEYD_RALT, "Alt"},
    {KEYD_INSERT, "Insert"},
    {KEYD_DELETE, "Delete"},
    {KEYD_PGDN, "PageDown"},
    {KEYD_PGUP, "PageUp"},
    {KEYD_HOME, "Home"},
    {KEYD_END, "End"},
    {KEYD_SCRLOCK,  "ScrollLock"},
    {KEYD_NUMLOCK,  "NumLock"},
    {KEYD_CAPSLOCK, "CapsLock"},
    {KEYD_END, "End"},
    {32, "Space"},
    {'\'', "\'"},
    {KEYD_TILDE, "Tilde"},
    {KEYD_MOUSE1, "Mouse1"},
    {KEYD_MOUSE2, "Mouse2"},
    {KEYD_MOUSE3, "Mouse3"},
    {KEYD_MOUSE4, "Mouse3"},
    {KEYD_MWHEEL_UP, "Wheel Up"},
    {KEYD_MWHEEL_DN, "Wheel Down"},
    {-1, ""}
};

//
// M_InitOptmenu
//
// Menu Initialisation
//
void M_InitOptmenu()
{
  optionsmenuon = 0;
  screen_size = screenblocks - 3;
  curr_menu = &amp;mainmenuinfo;
  curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
  keyscan = 0;

  menumusicvol = S_GetMusicVolume(); // -ACB- 1999/11/13 Music API Volume
  menusoundvol = S_GetSfxVolume();   // -ACB- 1999/10/10 Sound API Volume

  // Restore the config setting.
  M_ChangeBlood(-1);
}
</t>
<t tx="T1627">@ M_OptTicker

Text menu ticker
@c

void M_OptTicker(void)
{
  int displaybpp = 0;

  if (setresfailed)
  {
    displaybpp = scrmode[selectedscrmode].depth;

    sprintf(setreserror, DDF_LanguageLookup("ModeSelErr"),
            scrmode[selectedscrmode].width,
            scrmode[selectedscrmode].height,
            displaybpp);

    M_StartMessage(setreserror, NULL, false);
    testticker = -1;
    selectedscrmode = prevscrmode;
    setresfailed = false;
  }

  if (testticker &gt; 0)
  {
    testticker--;
  }
  else if (!testticker)
  {
    testticker--;
    M_RestoreResSettings(-1);
  }
}
</t>
<t tx="T1628">@ M_OptDrawer

Text menu drawer
@c

void M_OptDrawer()
{
  char tempstring[80];
  int curry, deltay, menutop;
  int i, j;
  unsigned int k;

  // make sure the local volume values are kept up-to-date
  menumusicvol = S_GetMusicVolume();
  menusoundvol = S_GetSfxVolume();
 
  // -ACB- 1998/06/15 Calculate height for menu and then center it.
  menutop = 68 - ((curr_menu-&gt;item_num * hu_font.height) / 2);

  {
    const image_t *image;

    if (! curr_menu-&gt;title_image)
      curr_menu-&gt;title_image = W_ImageFromPatch(curr_menu-&gt;title_name);

    image = curr_menu-&gt;title_image;

    VCTX_ImageEasy320(curr_menu-&gt;title_x, menutop, image);
  }

  //now, draw all the menuitems
  deltay = 1 + hu_font.height;

  curry = menutop + 25;

  if (curr_menu-&gt;key_page[0])
  {
    if (curr_menu-&gt;sister_prev)
      HL_WriteTextTrans(60, 200-deltay*4, text_yellow_map, "&lt; PREV");

    if (curr_menu-&gt;sister_next)
    HL_WriteTextTrans(260 - HL_StringWidth("NEXT &gt;"), 200-deltay*4, 
        text_yellow_map, "NEXT &gt;");

    HL_WriteTextTrans(160 - HL_StringWidth(curr_menu-&gt;key_page)/2, 
        200-deltay*4, text_yellow_map, curr_menu-&gt;key_page);
    
    if (keyscan)
      HL_WriteTextTrans(160 - (HL_StringWidth(keystring2) / 2), 
        200-deltay*2, text_green_map, keystring2);
    else
      HL_WriteTextTrans(160 - (HL_StringWidth(keystring1) / 2), 
        200-deltay*2, text_green_map, keystring1);
  }
  else if (curr_menu == &amp;resoptionsinfo)
  {
    M_ResOptDrawer(curry, curry + (deltay * (resoptionsinfo.item_num - 2)), 
        deltay, curr_menu-&gt;menu_center);
  }
  else if (curr_menu == &amp;mainmenuinfo)
  {
    M_LanguageDrawer(curr_menu-&gt;menu_center, curry, deltay);
  }

  for (i = 0; i &lt; curr_menu-&gt;item_num; i++)
  {
    HL_WriteText((curr_menu-&gt;menu_center) - HL_StringWidth(curr_menu-&gt;items[i].name),
        curry, curr_menu-&gt;items[i].name);

    // -ACB- 1998/07/15 Menu Cursor is colour indexed.
    if (i == curr_menu-&gt;pos)
    {
      HL_WriteTextTrans((curr_menu-&gt;menu_center + 4), curry, 
          text_yellow_map, "*");

      if (curr_menu-&gt;items[i].help)
      {
        const char *help = DDF_LanguageLookup(curr_menu-&gt;items[i].help);

        HL_WriteTextTrans(160 - (HL_StringWidth(help) / 2), 200 - deltay*2, 
            text_green_map, help);
      }
    }

    switch (curr_menu-&gt;items[i].type)
    {
      case OPT_Switch:

        k = 0;
        for (j = 0; j &lt; (*(curr_menu-&gt;items[i].switchvar)); j++)
        {
          while ((curr_menu-&gt;items[i].typenames[k] != '/') &amp;&amp; (k &lt; strlen(curr_menu-&gt;items[i].typenames)))
            k++;
          k++;
        }

        if (k &lt; strlen(curr_menu-&gt;items[i].typenames))
        {
          j = 0;
          while ((curr_menu-&gt;items[i].typenames[k] != '/') &amp;&amp; (k &lt; strlen(curr_menu-&gt;items[i].typenames)))
          {
            tempstring[j] = curr_menu-&gt;items[i].typenames[k];
            j++;
            k++;
          }
          tempstring[j] = 0;
        }
        else
        {
          sprintf(tempstring, "Invalid");
        }

        HL_WriteTextTrans((curr_menu-&gt;menu_center) + 15, curry, OPTSHADE, tempstring);
        break;

      case OPT_Slider:
        {
          M_DrawThermo(curr_menu-&gt;menu_center + 15, curry,
              curr_menu-&gt;items[i].numtypes - 1, *(curr_menu-&gt;items[i].switchvar), 2);
              
          break;
        }

      case OPT_KeyConfig:

        k = (*(curr_menu-&gt;items[i].switchvar));
        M_Key2String(k, tempstring);
        HL_WriteTextTrans((curr_menu-&gt;menu_center + 15), curry, OPTSHADE, tempstring);
        break;

      default:
        break;
    }
    curry += deltay;
  }
}
</t>
<t tx="T1629">@ M_OptResDrawer

Something of a hack, but necessary to give a better way of changing
resolution

-ACB- 1999/10/03 Written
@c

static void M_ResOptDrawer(int topy, int bottomy, int dy, int centrex)
{
  char tempstring[80];
  int y;
  int displaybpp = 8;

  // Draw current resolution
  y = topy;
  sprintf(tempstring, "Current Resolution:");
  HL_WriteText(160 - (HL_StringWidth(tempstring) / 2), y, tempstring);

  y += dy;
  sprintf(tempstring, "%d x %d in %d-bit mode", SCREENWIDTH, SCREENHEIGHT,
      SCREENBITS);
  HL_WriteTextTrans(160 - (HL_StringWidth(tempstring) / 2), y, OPTSHADE, tempstring);

  // Draw resolution selection option
  y += (dy*2);
  sprintf(tempstring, "%dx%d", scrmode[selectedscrmode].width, scrmode[selectedscrmode].height);
  HL_WriteTextTrans(centrex+15, y, OPTSHADE, tempstring);

  // Draw depth selection option
  displaybpp = scrmode[selectedscrmode].depth;

  y += dy;
  sprintf(tempstring, "%d bit", displaybpp);
  HL_WriteTextTrans(centrex+15, y, OPTSHADE, tempstring);

  // Draw selected resolution and mode:
  y = bottomy;
  sprintf(tempstring, "Selected Resolution:");
  HL_WriteText(160 - (HL_StringWidth(tempstring) / 2), y, tempstring);

  y += dy;

  sprintf(tempstring, "%d x %d in %d-bit mode",
                 scrmode[selectedscrmode].width,
                 scrmode[selectedscrmode].height,
                 displaybpp);

  HL_WriteTextTrans(160 - (HL_StringWidth(tempstring) / 2), y, OPTSHADE, tempstring);
}
</t>
<t tx="T1630">@ M_LanguageDrawer

Yet another hack (this stuff badly needs rewriting) to draw the
current language name.

-AJA- 2000/04/16 Written
@c

static void M_LanguageDrawer(int x, int y, int deltay)
{
  char tempstring[80];

  sprintf(tempstring, "%s", languages[cur_lang_index]-&gt;ddf.name);

  HL_WriteTextTrans(x+15, y + deltay * 6, OPTSHADE, tempstring);
}
</t>
<t tx="T1631">@ M_OptResponder
@c

boolean_t M_OptResponder(event_t * ev, int ch)
{
  if (testticker != -1)
    return true;

  // Scan for keycodes
  if (keyscan)
  {
    int *blah;
    int key;

    if (ev-&gt;type != ev_keydown)
      return false;
    key = ev-&gt;value.key;

    keyscan = 0;

    if (ch == KEYD_ESCAPE)
      return true;
     
    blah = (curr_item-&gt;switchvar);
    if (((*blah) &gt;&gt; 16) == key)
    {
      (*blah) &amp;= 0xffff;
      return true;
    }
    if (((*blah) &amp; 0xffff) == key)
    {
      (*blah) &gt;&gt;= 16;
      return true;
    }

    if (((*blah) &amp; 0xffff) == 0)
      *blah = key;
    else if (((*blah) &gt;&gt; 16) == 0)
      *blah |= key &lt;&lt; 16;
    else
    {
      *blah &gt;&gt;= 16;
      *blah |= key &lt;&lt; 16;
    }
    return true;
  }

  switch (ch)
  {
    case KEYD_BACKSPACE:
    {
      if (curr_item-&gt;type == OPT_KeyConfig)
        *(curr_item-&gt;switchvar) = 0;
      return true;
    }

    case KEYD_DOWNARROW:
    {
      do
      {
        curr_menu-&gt;pos++;
        if (curr_menu-&gt;pos &gt;= curr_menu-&gt;item_num)
          curr_menu-&gt;pos = 0;
        curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
      }
      while (curr_item-&gt;type == 0);

      S_StartSound(NULL, sfx_pstop);
      return true;
    }

    case KEYD_UPARROW:
    {
      do
      {
        curr_menu-&gt;pos--;
        if (curr_menu-&gt;pos &lt; 0)
          curr_menu-&gt;pos = curr_menu-&gt;item_num - 1;
        curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
      }
      while (curr_item-&gt;type == 0);

      S_StartSound(NULL, sfx_pstop);
      return true;
    }

    case KEYD_LEFTARROW:
    {
      if (curr_menu-&gt;key_page[0])
      {
        if (curr_menu-&gt;sister_prev)
        {
          curr_menu = curr_menu-&gt;sister_prev;
          curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;

          S_StartSound(NULL, sfx_pstop);
        }
        return true;
      }
       
      switch (curr_item-&gt;type)
      {
        case OPT_Plain:
        {
          return false;
        }

        case OPT_Switch:
        {
          (*(curr_item-&gt;switchvar))--;

          if ((*(curr_item-&gt;switchvar)) &lt; 0)
            (*(curr_item-&gt;switchvar)) = curr_item-&gt;numtypes - 1;

          S_StartSound(NULL, sfx_pistol);

          if (curr_item-&gt;routine != NULL)
            curr_item-&gt;routine(ch);

          return true;
        }

        case OPT_Function:
        {
          if (curr_item-&gt;routine != NULL)
            curr_item-&gt;routine(ch);

          S_StartSound(NULL, sfx_pistol);
          return true;
        }

        case OPT_Slider:
        {
          if ((*(curr_item-&gt;switchvar)) &gt; 0)
          {
            (*(curr_item-&gt;switchvar))--;
            S_StartSound(NULL, sfx_stnmov);
          }

          if (curr_item-&gt;routine != NULL)
            curr_item-&gt;routine(ch);

          return true;
        }

        default:
          break;
      }
    }

    case KEYD_RIGHTARROW:
      if (curr_menu-&gt;key_page[0])
      {
        if (curr_menu-&gt;sister_next)
        {
          curr_menu = curr_menu-&gt;sister_next;
          curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;

          S_StartSound(NULL, sfx_pstop);
        }
        return true;
      }
      /* FALL THROUGH... */
     
    case KEYD_ENTER:
    {
      switch (curr_item-&gt;type)
      {
        case OPT_Plain:
          return false;

        case OPT_Switch:
        {
          (*(curr_item-&gt;switchvar))++;

          if ((*(curr_item-&gt;switchvar)) &gt;= curr_item-&gt;numtypes)
            (*(curr_item-&gt;switchvar)) = 0;

          S_StartSound(NULL, sfx_pistol);

          if (curr_item-&gt;routine != NULL)
            curr_item-&gt;routine(ch);

          return true;
        }

        case OPT_Function:
        {
          if (curr_item-&gt;routine != NULL)
            curr_item-&gt;routine(ch);

          S_StartSound(NULL, sfx_pistol);
          return true;
        }

        case OPT_Slider:
        {
          if ((*(curr_item-&gt;switchvar)) &lt; (curr_item-&gt;numtypes - 1))
          {
            (*(curr_item-&gt;switchvar))++;
            S_StartSound(NULL, sfx_stnmov);
          }

          if (curr_item-&gt;routine != NULL)
            curr_item-&gt;routine(ch);

          return true;
        }

        case OPT_KeyConfig:
        {
          keyscan = 1;
          return true;
        }

        default:
          break;
      }
      I_Error("Invalid menu type!");
    }
    case KEYD_ESCAPE:
    {
      if (curr_menu == &amp;mainmenuinfo)
      {
        optionsmenuon = 0;
      }
      else
      {
        curr_menu = &amp;mainmenuinfo;
        curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
      }
      S_StartSound(NULL, sfx_swtchx);
      return true;
    }
  }
  return false;
}
</t>
<t tx="T1632">@ ===== SUB-MENU SETUP ROUTINES =====

M_VideoOptions
@c

static void M_VideoOptions(int keypressed)
{
  curr_menu = &amp;vidoptionsinfo;
  curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
}
</t>
<t tx="T1633">@ M_ResolutionOptions

This menu is different in the fact that is most be calculated at runtime,
this is because different resolutions are available on different machines.

-ES- 1998/08/20 Added
-ACB 1999/10/03 rewrote to Use scrmodes array.
@c

static void M_ResolutionOptions(int keypressed)
{
  int i;
  byte depth = SCREENBITS;
  screenmode_t curMode;

  // Get a depth mask for resolution selection
  DEV_ASSERT2(depth == 8 || depth == 16 || depth == 24);

  // Find the current mode in the scrmode[] table
  curMode.width = SCREENWIDTH;
  curMode.height = SCREENHEIGHT;
  curMode.depth = SCREENBITS;
  curMode.windowed = SCREENWINDOW;

  i = V_FindClosestResolution(&amp;curMode, true, true);

  if (i == -1)
    I_Error("M_ResolutionOptions: Graphics mode not listed in scrmode[]");

  selectedscrmode = i;
  prevscrmode = i;

  curr_menu = &amp;resoptionsinfo;
  curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
}
</t>
<t tx="T1634">@ M_AnalogueOptions
@c

static void M_AnalogueOptions(int keypressed)
{
  curr_menu = &amp;analogueoptionsinfo;
  curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
}
</t>
<t tx="T1635">@ M_GameplayOptions
@c

static void M_GameplayOptions(int keypressed)
{
  if (netgame)
    return;

  curr_menu = &amp;playoptionsinfo;
  curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
}
</t>
<t tx="T1636">@ M_StandardControlOptions
@c

static void M_StandardControlOptions(int keypressed)
{
  curr_menu = &amp;stdkeyconfiginfo;
  curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
}
</t>
<t tx="T1637">@ M_ExtendedControlOptions
@c

static void M_ExtendedControlOptions(int keypressed)
{
  curr_menu = &amp;extkeyconfiginfo;
  curr_item = curr_menu-&gt;items + curr_menu-&gt;pos;
}
</t>
<t tx="T1638">@ ===== END OF SUB-MENUS =====

M_ResetToDefaults
@c

void M_ResetToDefaults(int keypressed)
{
  int i;

  for (i = 0; i &lt; mainmenuinfo.item_num; i++)
  {
    if (mainmenu[i].type == OPT_Switch || 
        mainmenu[i].type == OPT_Slider)
    {
      (*(mainmenu[i].switchvar)) = mainmenu[i].default_val;
    }
  }

  for (i = 0; i &lt; vidoptionsinfo.item_num; i++)
  {
    if (vidoptions[i].type == OPT_Switch || 
        vidoptions[i].type == OPT_Slider)
    {
      (*(vidoptions[i].switchvar)) = vidoptions[i].default_val;
    }
  }

  for (i = 0; i &lt; playoptionsinfo.item_num; i++)
  {
    if (playoptions[i].type == OPT_Switch || 
        playoptions[i].type == OPT_Slider)
    {
      (*(playoptions[i].switchvar)) = playoptions[i].default_val;
    }
  }

  for (i = 0; i &lt; analogueoptionsinfo.item_num; i++)
  {
    if (analogueoptions[i].type == OPT_Switch || 
        analogueoptions[i].type == OPT_Slider)
    {
      (*(analogueoptions[i].switchvar)) = analogueoptions[i].default_val;
    }
  }

  for (i = 0; i &lt; stdkeyconfiginfo.item_num; i++)
  {
    if (stdkeyconfig[i].type == OPT_KeyConfig)
    {
      (*(stdkeyconfig[i].switchvar)) = stdkeyconfig[i].default_val;
    }
  }

  for (i = 0; i &lt; extkeyconfiginfo.item_num; i++)
  {
    if (extkeyconfig[i].type == OPT_KeyConfig)
    {
      (*(extkeyconfig[i].switchvar)) = extkeyconfig[i].default_val;
    }
  }
}
</t>
<t tx="T1639">@ M_Key2String
@c

static void M_Key2String(int key, char *deststring)
{
  int key1, key2;
  char key2string[100];
  int j;

  if (((key &amp; 0xffff) == 0) &amp;&amp; ((key &gt;&gt; 16) != 0))
    I_Error("key problem!");

  if (key == 0)
  {
    strcpy(deststring, "---");
    return;
  }
  key1 = key &amp; 0xffff;
  key2 = key &gt;&gt; 16;

  //first do key 1
  if ((toupper(key1) &gt;= ',') &amp;&amp; (toupper(key1) &lt;= ']'))
  {
    deststring[0] = toupper(key1);
    deststring[1] = 0;
  }
  else
  {
    if (key1 &gt;= KEYD_JOYBASE)
      sprintf(deststring, "Joystick %d", key1 - KEYD_JOYBASE + 1);
    else
      sprintf(deststring, "Keycode %d", key1);
    j = 0;
    while (specialkeylist[j].keycode != -1)
    {
      if (specialkeylist[j].keycode == key1)
      {
        strcpy(deststring, specialkeylist[j].keystring);
        break;
      }
      j++;
    }
  }

  if (key2 == 0)
    return;

  //now, do key 2
  if ((toupper(key2) &gt;= ',') &amp;&amp; (toupper(key2) &lt;= ']'))
  {
    key2string[0] = toupper(key2);
    key2string[1] = 0;
  }
  else
  {
    if (key2 &gt;= KEYD_JOYBASE)
      sprintf(key2string, "Joystick %d", key2 - KEYD_JOYBASE + 1);
    else
      sprintf(key2string, "Keycode %d", key2);
    j = 0;
    while (specialkeylist[j].keycode != -1)
    {
      if (specialkeylist[j].keycode == key2)
      {
        strcpy(key2string, specialkeylist[j].keystring);
        break;
      }
      j++;
    }
  }
  strcat(deststring, " or ");
  strcat(deststring, key2string);
  return;
}
</t>
<t tx="T1640">@ M_CalibrateJoystick

1998/07/10 -KM- Recalibration of Joystick
2000/11/03 -ACB- Unable to use as non-portable
@c

static void M_CalibrateJoystick(int keypressed)
{
//  I_CalibrateJoystick(0);
}
</t>
<t tx="T1641">@ M_ChangeGamma

-AJA- 1999/07/03: stuck this here &amp; removed PLAYPAL reference.
@c

static void M_ChangeGamma(int keypressed)
{
  /* nothing to do */
}
</t>
<t tx="T1642">@ M_ChangeBlood

-KM- 1998/07/21 Change blood to a boolean_t
-ACB- 1998/08/09 Check map setting allows this
@c

static void M_ChangeBlood(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_MoreBlood)
    return;

  level_flags.more_blood = global_flags.more_blood;
}
</t>
<t tx="T1643">
static void M_ChangeJumping(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_Jumping)
    return;

  level_flags.jump = global_flags.jump;
}
</t>
<t tx="T1644">
static void M_ChangeCrouching(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_Crouching)
    return;

  level_flags.crouch = global_flags.crouch;
}
</t>
<t tx="T1645">
static void M_ChangeExtra(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_Extras)
    return;

  level_flags.have_extra = global_flags.have_extra;
}
</t>
<t tx="T1646">@ M_ChangeMonsterRespawn

-ACB- 1998/08/09 New DDF settings, check that map allows the settings
@c

static void M_ChangeMonsterRespawn(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_ResRespawn)
    return;

  level_flags.res_respawn = global_flags.res_respawn;
}
</t>
<t tx="T1647">
static void M_ChangeItemRespawn(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_ItemRespawn)
    return;

  level_flags.itemrespawn = global_flags.itemrespawn;
}
</t>
<t tx="T1648">
static void M_ChangeStretchSky(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_StretchSky)
    return;

  level_flags.stretchsky = global_flags.stretchsky;
}
</t>
<t tx="T1649">
static void M_ChangeTransluc(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_Translucency)
    return;

  level_flags.trans = global_flags.trans;
}
</t>
<t tx="T1650">
static void M_ChangeTrue3d(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_True3D)
    return;

  level_flags.true3dgameplay = global_flags.true3dgameplay;
}
</t>
<t tx="T1651">
static void M_ChangeAutoAim(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_AutoAim)
    return;

  level_flags.autoaim = global_flags.autoaim;
}
</t>
<t tx="T1652">
static void M_ChangeRespawn(int keypressed)
{
  if (gameskill == sk_nightmare)
    return;

  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_Respawn)
    return;

  level_flags.respawn = global_flags.respawn;
}
</t>
<t tx="T1653">
static void M_ChangeFastparm(int keypressed)
{
  if (gameskill == sk_nightmare)
    return;

  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_FastParm)
    return;

  level_flags.fastparm = global_flags.fastparm;
}
</t>
<t tx="T1654">@ this used by both MIPMIP and SMOOTHING options
@c

static void M_ChangeMipMap(int keypressed)
{
  W_ResetImages();
}
</t>
<t tx="T1655">
static void M_ChangeShadows(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_Shadows)
    return;

  level_flags.shadows = global_flags.shadows;
}
</t>
<t tx="T1656">
static void M_ChangeHalos(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_Halos)
    return;

  level_flags.halos = global_flags.halos;
}
</t>
<t tx="T1657">
static void M_ChangeCompatMode(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_BoomCompat)
    return;

  level_flags.compat_mode = global_flags.compat_mode;

  // clear line/sector lookup caches
  DDF_LineClearGeneralised();
  DDF_SectorClearGeneralised();
}
</t>
<t tx="T1658">
static void M_ChangeKicking(int keypressed)
{
  if ((currentmap-&gt;force_on | currentmap-&gt;force_off) &amp; MPF_Kicking)
    return;

  level_flags.kicking = global_flags.kicking;
}
</t>
<t tx="T1659">
static void M_ChangeDLights(int keypressed)
{
  /* nothing to do -- change occurs at next level load */
}
</t>
<t tx="T1660">@ M_ChangeLanguage

-AJA- 2000/04/16 Run-time language changing...
@c

static void M_ChangeLanguage(int keypressed)
{
  if (keypressed == KEYD_LEFTARROW)
  {
    cur_lang_index += num_languages - 1;
    cur_lang_index %= num_languages;
  }
  else if (keypressed == KEYD_RIGHTARROW)
  {
    cur_lang_index += 1;
    cur_lang_index %= num_languages;
  }
}
</t>
<t tx="T1661">@ M_ChangeStoredRes

-ACB- 1998/08/29 Resolution Changes...
@c

static void M_ChangeStoredRes(int keypressed)
{
  int i;

  if (keypressed == KEYD_LEFTARROW)
  {
    i=selectedscrmode-1;
    while (i != selectedscrmode)
    {
      // allow for rotation
      if (i &lt; 0)
        i = (numscrmodes-1);

      // ignore different windowed-ness
      if (scrmode[i].windowed == scrmode[selectedscrmode].windowed &amp;&amp;
          scrmode[i].depth == scrmode[selectedscrmode].depth)
        break;

      i--;
    }
    selectedscrmode = i;
  }
  else if (keypressed == KEYD_RIGHTARROW)
  {
    i=selectedscrmode+1;
    while (i != selectedscrmode)
    {
      // allow for rotation
      if (i == numscrmodes)
        i = 0;

      // ignore different windowed-ness
      if (scrmode[i].windowed == scrmode[selectedscrmode].windowed &amp;&amp;
          scrmode[i].depth == scrmode[selectedscrmode].depth)
        break;

      i++;
    }
    selectedscrmode = i;
  }
}
</t>
<t tx="T1662">@ M_ChangeStoredBpp

-ACB- 1998/08/29 Depth Changes...
@c

static void M_ChangeStoredBpp(int keypressed)
{
  int newdepthbit;
  boolean_t gotnewdepth;  // Got new resolution setting
  screenmode_t newMode;
  int idx;

  // Ignore anything by LEFT and RIGHT arrow keys
  if (keypressed != KEYD_LEFTARROW &amp;&amp; keypressed != KEYD_RIGHTARROW)
    return;

  newdepthbit = scrmode[selectedscrmode].depth;

  gotnewdepth = false;
  while (!gotnewdepth)
  {
    if (keypressed == KEYD_LEFTARROW)
    {
      if (newdepthbit == 8)
        newdepthbit = 24;
      else if (newdepthbit == 24)
        newdepthbit = 16;
      else if (newdepthbit == 16)
        newdepthbit = 8;
    }
    else if (keypressed == KEYD_RIGHTARROW)
    {
      if (newdepthbit == 8)
        newdepthbit = 16;
      else if (newdepthbit == 16)
        newdepthbit = 24;
      else if (newdepthbit == 24)
        newdepthbit = 8;
    }
    
    newMode.width = scrmode[selectedscrmode].width;
    newMode.height = scrmode[selectedscrmode].height;
    newMode.depth = newdepthbit;
    newMode.windowed = SCREENWINDOW;

    idx = V_FindClosestResolution(&amp;newMode, false, true);
     
    // Select res
    if (idx != -1)
    { 
      selectedscrmode = idx;
      gotnewdepth = true;
    }
  }

  return;
}
</t>
<t tx="T1663">@ M_OptionSetResolution
@c

static void M_OptionSetResolution(int keypressed)
{
  R_ChangeResolution(
      scrmode[selectedscrmode].width, 
      scrmode[selectedscrmode].height, 
      scrmode[selectedscrmode].depth, SCREENWINDOW);
}
</t>
<t tx="T1664">@ M_OptionTestResolution
@c

static void M_OptionTestResolution(int keypressed)
{
  R_ChangeResolution(
      scrmode[selectedscrmode].width, 
      scrmode[selectedscrmode].height, 
      scrmode[selectedscrmode].depth, SCREENWINDOW);

  testticker = TICRATE * 3;
}
</t>
<t tx="T1665">@ M_RestoreResSettings
@c

static void M_RestoreResSettings(int keypressed)
{
  R_ChangeResolution(
      scrmode[prevscrmode].width, 
      scrmode[prevscrmode].height,
      scrmode[prevscrmode].depth, SCREENWINDOW);
}
</t>
<t tx="T1666">@ignore
@language c

// Random LUT

&lt;&lt; m_random #includes &gt;&gt;
&lt;&lt; m_random declarations &gt;&gt;
@others
</t>
<t tx="T1667">#include "i_defs.h"
#include "m_random.h"
</t>
<t tx="T1668">
unsigned char rndtable[256] =
{
    0, 8, 109, 220, 222, 241, 149, 107, 75, 248, 254, 140, 16, 66,
    74, 21, 211, 47, 80, 242, 154, 27, 205, 128, 161, 89, 77, 36,
    95, 110, 85, 48, 212, 140, 211, 249, 22, 79, 200, 50, 28, 188,
    52, 140, 202, 120, 68, 145, 62, 70, 184, 190, 91, 197, 152, 224,
    149, 104, 25, 178, 252, 182, 202, 182, 141, 197, 4, 81, 181, 242,
    145, 42, 39, 227, 156, 198, 225, 193, 219, 93, 122, 175, 249, 0,
    175, 143, 70, 239, 46, 246, 163, 53, 163, 109, 168, 135, 2, 235,
    25, 92, 20, 145, 138, 77, 69, 166, 78, 176, 173, 212, 166, 113,
    94, 161, 41, 50, 239, 49, 111, 164, 70, 60, 2, 37, 171, 75,
    136, 156, 11, 56, 42, 146, 138, 229, 73, 146, 77, 61, 98, 196,
    135, 106, 63, 197, 195, 86, 96, 203, 113, 101, 170, 247, 181, 113,
    80, 250, 108, 7, 255, 237, 129, 226, 79, 107, 112, 166, 103, 241,
    24, 223, 239, 120, 198, 58, 60, 82, 128, 3, 184, 66, 143, 224,
    145, 224, 81, 206, 163, 45, 63, 90, 168, 114, 59, 33, 159, 95,
    28, 139, 123, 98, 125, 196, 15, 70, 194, 253, 54, 14, 109, 226,
    71, 17, 161, 93, 186, 87, 244, 138, 20, 52, 123, 251, 26, 36,
    17, 46, 52, 231, 232, 76, 31, 221, 84, 37, 216, 165, 212, 106,
    197, 242, 98, 43, 39, 175, 254, 145, 190, 84, 118, 222, 187, 136,
    120, 163, 236, 249
};

static int m_index = 0;
static int p_index = 0;
static int p_step = 1;
</t>
<t tx="T1669">@ M_Random

Returns a number from 0 to 255.

-AJA- Note: this function should be called for all random values
that do not interfere with demo/netgame synchronisation (for example,
placement of bullet puffs).
@c

int M_Random(void)
{
  return rndtable[++m_index &amp; 0xff];
}
</t>
<t tx="T1670">@ P_Random

Returns a number from 0 to 255.

-AJA- Note: that this function should be called for all random values
values that determine demo/netgame synchronisation (for example,
which way a monster should travel).
@c

int P_Random(void)
{
  p_index += p_step;
  p_index &amp;= 0xff;

  if (p_index == 0)
    p_step += (47 * 2);

  return rndtable[p_index];
}
</t>
<t tx="T1671">@ P_RandomNegPos

Returns a number between -255 and 255, but skewed so that values near
zero have a higher probability. Replaces "P_Random()-P_Random()" in
the code, which as Lee Killough points out can produce different
results depending upon the order of evaluation.

-AJA- Note: same usage rules as P_Random.
@c

int P_RandomNegPos(void)
{
  int r1 = P_Random();
  int r2 = P_Random();

  return r1 - r2;
}
</t>
<t tx="T1672">@ M_RandomTest
@c

boolean_t M_RandomTest(percent_t chance)
{
  return (chance &lt;= 0) ? false :
         (chance &gt;= 1) ? true :
         (M_Random()/255.0 &lt; chance) ? true : false;
}
</t>
<t tx="T1673">@ P_RandomTest
@c

boolean_t P_RandomTest(percent_t chance)
{
  return (chance &lt;= 0) ? false :
         (chance &gt;= 1) ? true :
         (P_Random()/255.0 &lt; chance) ? true : false;
}
</t>
<t tx="T1674">@ P_ReadRandomState

These two routines are used for savegames.
@c

int P_ReadRandomState(void)
{
  return (p_index &amp; 0xff) | ((p_step &amp; 0xff) &lt;&lt; 8);
}
</t>
<t tx="T1675">@ P_WriteRandomState
@c

void P_WriteRandomState(int value)
{
  p_index = (value &amp; 0xff);
  p_step  = 1 + ((value &gt;&gt; 8) &amp; 0xfe);
}
</t>
<t tx="T1676">@ignore
@language c

// Play Simulation Action routines

// Notes:
//  All Procedures here are never called directly, except possibly
//  by another P_Act* Routine. Otherwise the procedure is called
//  by referencing an code pointer from the states[] table. The only
//  exception to these rules are P_ActMissileContact and
//  P_ActSlammedIntoObject that requiring "acting" on the part
//  of an obj.
//
// This file was created for all action code by DDF.
//
// -KM- 1998/09/27 Added sounds.ddf capability
// -KM- 1998/11/25 Visibility is now a fixed_t.
// -KM- 1998/12/21 New smooth visibility.
// -AJA- 1999/07/21: Replaced some non-critical P_Randoms with M_Random.
// -AJA- 1999/08/08: Replaced some P_Random()-P_Random() stuff.
//

&lt;&lt; p_action #includes &gt;&gt;
&lt;&lt; p_action declarations &gt;&gt;
@others
</t>
<t tx="T1677">#include "i_defs.h"
#include "p_action.h"

#include "con_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "g_game.h"
#include "m_inline.h"
#include "m_misc.h"
#include "m_random.h"
#include "p_local.h"
#include "p_weapon.h"
#include "r_state.h"
#include "rad_trig.h"
#include "s_sound.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1678">
#define TRACEANGLE 0xc000000

void P_DoAttack(mobj_t * object);
void P_ActRangeAttack(mobj_t * object);
void P_ActMeleeAttack(mobj_t * object);
</t>
<t tx="T1679">@ -----------------------------------------
--------------MISCELLANOUS---------------
-----------------------------------------

P_ActActivateLineType

Allows things to also activate linetypes, bringing them into the
fold with radius triggers, which can also do it. There's only two
parameters needed: linetype number &amp; tag number, which are stored
in the state's `action_par' field as a pointer to two integers.

-AJA- 2000/01/09: written.
@c

void P_ActActivateLineType(mobj_t * object)
{
  int *values;
  
  if (!object-&gt;state || !object-&gt;state-&gt;action_par)
    return;

  values = (int *) object-&gt;state-&gt;action_par;
  
  // Note the `NULL' here: this prevents the activation from failing
  // because the object isn't a PLAYER, for example.
  P_RemoteActivation(NULL, values[0], values[1], 0, line_Any);
}
</t>
<t tx="T1680">@ P_ActEnableRadTrig
P_ActDisableRadTrig

Allows things to enable or disable radius triggers (by tag number),
like linetypes can do already.

-AJA- 2000/01/09: written.
@c

void P_ActEnableRadTrig(mobj_t * object)
{
  int *value;
  
  if (!object-&gt;state || !object-&gt;state-&gt;action_par)
    return;

  value = (int *) object-&gt;state-&gt;action_par;
  RAD_EnableByTag(object, value[0], false);
}
</t>
<t tx="T1681">
void P_ActDisableRadTrig(mobj_t * object)
{
  int *value;
  
  if (!object-&gt;state || !object-&gt;state-&gt;action_par)
    return;

  value = (int *) object-&gt;state-&gt;action_par;
  RAD_EnableByTag(object, value[0], true);
}
</t>
<t tx="T1682">@ P_ActLookForTargets

Looks for targets: used in the same way as enemy things look
for players

TODO: Write a decent procedure.
-KM- 1999/01/31 Added sides. Still has to search every mobj on the
map to find a target. There must be a better way...
@c

boolean_t P_ActLookForTargets(mobj_t * object)
{
  mobj_t *currmobj;

  currmobj = mobjlisthead;

  while (currmobj != NULL)
  {
    if ((currmobj-&gt;side &amp; object-&gt;side) &amp;&amp; !object-&gt;supportobj)
    {
      if (currmobj-&gt;supportobj != object &amp;&amp; P_CheckSight(object, currmobj))
      {
        P_MobjSetSupportObj(object, currmobj);
        if (object-&gt;info-&gt;meander_state)
          P_SetMobjStateDeferred(object, object-&gt;info-&gt;meander_state, 0);
        return true;
      }
    }
    if ((((currmobj-&gt;target == object-&gt;supportobj || currmobj-&gt;target == object)
                &amp;&amp; currmobj-&gt;target)
            || (object-&gt;side &amp;&amp; !(currmobj-&gt;side &amp; object-&gt;side)))
        &amp;&amp; ((currmobj != object) &amp;&amp;
            (currmobj != object-&gt;supportobj) &amp;&amp;
            (object-&gt;info != currmobj-&gt;info || (object-&gt;extendedflags &amp; EF_DISLOYALTYPE)) &amp;&amp;
            (object-&gt;supportobj != currmobj-&gt;supportobj)))
    {
      if ((currmobj-&gt;flags &amp; MF_SHOOTABLE) &amp;&amp; P_CheckSight(object, currmobj))
      {
        P_MobjSetTarget(object, currmobj);
        if (object-&gt;info-&gt;chase_state)
          P_SetMobjStateDeferred(object, object-&gt;info-&gt;chase_state, 0);
        return true;
      }
    }
    currmobj = currmobj-&gt;next;
  }

  return false;
}
</t>
<t tx="T1683">@ DecideMeleeAttack

This is based on P_CheckMeleeRange, except that it relys upon
info from the objects close combat attack, the original code
used a set value for all objects which was MELEERANGE + 20,
this code allows different melee ranges for different objects.

-ACB- 1998/08/15
-KM- 1998/11/25 Added attack parameter.
@c

static boolean_t DecideMeleeAttack(mobj_t * object, const attacktype_t * attack)
{
  mobj_t *target;
  float_t distance;
  float_t meleedist;

  target = object-&gt;target;

  if (!target)
    return false;

  if (!P_CheckSight(object, target))
    return false;

  if (!attack)
    return false;  // cannot evaluate range with no attack range

  distance = P_ApproxDistance(target-&gt;x - object-&gt;x, target-&gt;y - object-&gt;y);
  if (level_flags.true3dgameplay)
    distance = P_ApproxDistance(target-&gt;z - object-&gt;z, distance);
  meleedist = attack-&gt;range - 20 + target-&gt;info-&gt;radius;

  if (distance &gt;= meleedist)
    return false;

  return true;
}
</t>
<t tx="T1684">@ P_ActDecideRangeAttack

This is based on P_CheckMissileRange, contrary the name it does more
than check the missile range, it makes a decision of whether or not an
attack should be made or not depending on the object with the option
to attack. A return of false is mandatory if the object cannot see its
target (makes sense, doesn't it?), after this the distance is calculated,
it will eventually be check to see if it is greater than a number from
the Random Number Generator; if so the procedure returns true. Essentially
the closer the object is to its target, the more chance an attack will
be made (another logical decision).

-ACB- 1998/08/15
@c

static boolean_t P_ActDecideRangeAttack(mobj_t * object)
{
  percent_t chance;
  float_t distance;
  const attacktype_t *attack;

  if (! object-&gt;target)
    return false;

  if (!P_CheckSight(object, object-&gt;target))
    return false;

  if (object-&gt;info-&gt;rangeattack)
    attack = object-&gt;info-&gt;rangeattack;
  else
    return false;  // cannot evaluate range with no attack range

  // Just been hit (and have felt pain), so in true tit-for-tat
  // style, the object - without regard to anything else - hits back.
  if (object-&gt;flags &amp; MF_JUSTHIT)
  {
    object-&gt;flags &amp;= ~MF_JUSTHIT;
    return true;
  }

  // Bit slow on the up-take: the object hasn't had time to
  // react his target.
  if (object-&gt;reactiontime)
    return false;

  // Get the distance, a basis for our decision making from now on
  distance = P_ApproxDistance(object-&gt;x - object-&gt;target-&gt;x,
      object-&gt;y - object-&gt;target-&gt;y);

  // If no close-combat attack, increase the chance of a missile attack
  if (!object-&gt;info-&gt;melee_state)
    distance -= 192;
  else
    distance -= 64;

  // Object is too far away to attack?
  if (attack-&gt;range &amp;&amp; distance &gt;= attack-&gt;range)
    return false;

  // Object is too close to target
  if (attack-&gt;tooclose &amp;&amp; attack-&gt;tooclose &gt;= distance)
    return false;

  // Object likes to fire? if so, double the chance of it happening
  if (object-&gt;extendedflags &amp; EF_TRIGGERHAPPY)
    distance /= 2;

  // The chance in the object is one given that the attack will happen, so
  // we inverse the result (since its one in 255) to get the chance that
  // the attack will not happen.
  chance = 1.0 - object-&gt;info-&gt;minatkchance;
  chance = MIN(distance / 255.0, chance);

  // now after modifing distance where applicable, we get the random number and
  // check if it is less than distance, if so no attack is made.
  if (P_RandomTest(chance))
    return false;

  return true;
}
</t>
<t tx="T1685">@ P_ActFaceTarget

Look at the prey......
@c

void P_ActFaceTarget(mobj_t * object)
{
  mobj_t *target;
  float_t dist, dz;

  target = object-&gt;target;

  if (!target || (target-&gt;extendedflags &amp; EF_DUMMYMOBJ))
    return;

  if (object-&gt;flags &amp; MF_STEALTH)
    object-&gt;vis_target = VISIBLE;

  object-&gt;flags &amp;= ~MF_AMBUSH;

  object-&gt;angle = R_PointToAngle(object-&gt;x, object-&gt;y, target-&gt;x, target-&gt;y);

  dist = R_PointToDist(object-&gt;x, object-&gt;y, target-&gt;x, target-&gt;y);

  if (dist &gt;= 0.1)
  {
    dz = MO_MIDZ(target) - MO_MIDZ(object);

    object-&gt;vertangle = dz / dist;
  }

  if (target-&gt;flags &amp; MF_FUZZY)
  {
    object-&gt;angle += P_RandomNegPos() &lt;&lt; (ANGLEBITS - 11);
    object-&gt;vertangle += P_RandomNegPos() / 1024.0;
  }

  if (target-&gt;visibility &lt; VISIBLE)
  {
    float_t amount = (VISIBLE - target-&gt;visibility);

    object-&gt;angle += P_RandomNegPos() * (ANGLEBITS - 12) * amount;
    object-&gt;vertangle += P_RandomNegPos() * amount / 2048.0;
  }

  // don't look up/down too far...
  if (object-&gt;vertangle &lt; LOOKDOWNLIMIT)
    object-&gt;vertangle = LOOKDOWNLIMIT;
  else if (object-&gt;vertangle &gt; LOOKUPLIMIT)
    object-&gt;vertangle = LOOKUPLIMIT;
}
</t>
<t tx="T1686">@ P_ActMakeIntoCorpse

Gives the effect of the object being a corpse....
@c

void P_ActMakeIntoCorpse(mobj_t * mo)
{
  if (mo-&gt;flags &amp; MF_STEALTH)
    mo-&gt;vis_target = VISIBLE;  // dead and very visible

  // object is on ground, it can be walked over
  mo-&gt;flags &amp;= ~MF_SOLID;
}
</t>
<t tx="T1687">@ P_BringCorpseToLife

Bring a corpse back to life (the opposite of the above routine).
Handles players too !
@c

void P_BringCorpseToLife(mobj_t * corpse)
{
  const mobjinfo_t *info = corpse-&gt;info;

  corpse-&gt;flags = info-&gt;flags;
  corpse-&gt;health = info-&gt;spawnhealth;
  corpse-&gt;radius = info-&gt;radius;
  corpse-&gt;height = info-&gt;height;
  corpse-&gt;extendedflags = info-&gt;extendedflags;
  corpse-&gt;vis_target = PERCENT_2_FLOAT(info-&gt;translucency);

  if (corpse-&gt;player)
  {
    corpse-&gt;player-&gt;playerstate = PST_LIVE;
    corpse-&gt;player-&gt;health = corpse-&gt;health;
    corpse-&gt;player-&gt;std_viewheight = corpse-&gt;height * 
        PERCENT_2_FLOAT(info-&gt;viewheight);
  }

  if (info-&gt;overkill_sound)
    S_StartSound(corpse, info-&gt;overkill_sound);

  if (info-&gt;raise_state)
    P_SetMobjState(corpse, info-&gt;raise_state);
  else if (info-&gt;meander_state)
    P_SetMobjState(corpse, info-&gt;meander_state);
  else if (info-&gt;idle_state)
    P_SetMobjState(corpse, info-&gt;idle_state);
  else
    I_Error("Object %s has no RESURRECT states.\n", info-&gt;ddf.name);
}
</t>
<t tx="T1688">@ P_ActResetSpreadCount

Resets the spreader count for fixed-order spreaders, normally used at the
beginning of a set of missile states to ensure that an object fires in
the same object each time.
@c

void P_ActResetSpreadCount(mobj_t * object)
{
  object-&gt;spreadcount = 0;
}
</t>
<t tx="T1689">@ -------------------------------------------------------------------
-------------------VISIBILITY HANDLING ROUTINES--------------------
-------------------------------------------------------------------

P_ActTransSet
@c

void P_ActTransSet(mobj_t * object)
{
  const state_t *st;
  float_t value = VISIBLE;

  st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    value = ((percent_t *)st-&gt;action_par)[0];
    value = MAX(0.0, MIN(1.0, value));
  }

  object-&gt;visibility = object-&gt;vis_target = value;
}
</t>
<t tx="T1690">@ P_ActTransFade
@c

void P_ActTransFade(mobj_t * object)
{
  const state_t *st;
  float_t value = INVISIBLE;

  st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    value = ((percent_t *)st-&gt;action_par)[0];
    value = MAX(0.0, MIN(1.0, value));
  }

  object-&gt;vis_target = value;
}
</t>
<t tx="T1691">@ P_ActTransLess
@c

void P_ActTransLess(mobj_t * object)
{
  const state_t *st;
  float_t value = 0.05;

  st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    value = ((percent_t *)st-&gt;action_par)[0];
    value = MAX(0.0, MIN(1.0, value));
  }

  object-&gt;vis_target -= value;

  if (object-&gt;vis_target &lt; INVISIBLE)
    object-&gt;vis_target = INVISIBLE;
}
</t>
<t tx="T1692">@ P_ActTransMore
@c

void P_ActTransMore(mobj_t * object)
{
  const state_t *st;
  float_t value = 0.05;

  st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    value = ((percent_t *)st-&gt;action_par)[0];
    value = MAX(0.0, MIN(1.0, value));
  }

  object-&gt;vis_target += value;

  if (object-&gt;vis_target &gt; VISIBLE)
    object-&gt;vis_target = VISIBLE;
}
</t>
<t tx="T1693">@ P_ActTransAlternate

Alters the translucency of an item, EF_LESSVIS is used
internally to tell the object if it should be getting
more visible or less visible; EF_LESSVIS is set when an
object is to get less visible (because it has become
to a level of lowest translucency) and the flag is unset
if the object has become as highly translucent as possible.
@c

void P_ActTransAlternate(mobj_t * object)
{
  const state_t *st;
  float_t value = 0.05;

  st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    value = ((percent_t *)st-&gt;action_par)[0];
    value = MAX(0.0, MIN(1.0, value));
  }

  if (object-&gt;extendedflags &amp; EF_LESSVIS)
  {
    object-&gt;vis_target -= value;
    if (object-&gt;vis_target &lt;= INVISIBLE)
    {
      object-&gt;vis_target = INVISIBLE;
      object-&gt;extendedflags &amp;= ~EF_LESSVIS;
    }
  }
  else
  {
    object-&gt;vis_target += value;
    if (object-&gt;vis_target &gt;= VISIBLE)
    {
      object-&gt;vis_target = VISIBLE;
      object-&gt;extendedflags |= EF_LESSVIS;
    }
  }
}
</t>
<t tx="T1694">@ P_ActDLightSet
@c

void P_ActDLightSet(mobj_t * mo)
{
  const state_t *st = mo-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    mo-&gt;dlight_qty = MAX(0, ((int *)st-&gt;action_par)[0]);
    mo-&gt;dlight_target = mo-&gt;dlight_qty;
  }
}
</t>
<t tx="T1695">@ P_ActDLightFade
@c

void P_ActDLightFade(mobj_t * mo)
{
  const state_t *st = mo-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    mo-&gt;dlight_target = MAX(0, ((int *)st-&gt;action_par)[0]);
  }
}
</t>
<t tx="T1696">@ P_ActDLightRandom
@c

void P_ActDLightRandom(mobj_t * mo)
{
  const state_t *st = mo-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    int low  = ((int *)st-&gt;action_par)[0];
    int high = ((int *)st-&gt;action_par)[1];

    // Note: using M_Random so that gameplay is unaffected
    int qty = low + (high - low) * M_Random() / 255;
    
    mo-&gt;dlight_qty = MAX(0, qty);
    mo-&gt;dlight_target = mo-&gt;dlight_qty;
  }
}
</t>
<t tx="T1697">@ -------------------------------------------------------------------
------------------- MOVEMENT ROUTINES -----------------------------
-------------------------------------------------------------------
@c

void P_ActFaceDir(mobj_t * object)
{
  const state_t *st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
    object-&gt;angle = *(angle_t *)st-&gt;action_par;
  else
    object-&gt;angle = 0;
}
</t>
<t tx="T1698">
void P_ActTurnDir(mobj_t * object)
{
  const state_t *st = object-&gt;state;
  angle_t turn = ANG180;

  if (st &amp;&amp; st-&gt;action_par)
  {
    int par = *(int *)st-&gt;action_par;
    turn = FLOAT_2_ANG((float_t) par);
  }

  object-&gt;angle += turn;
}
</t>
<t tx="T1699">
void P_ActTurnRandom(mobj_t * object)
{
  const state_t *st = object-&gt;state;
  int turn = 359;

  if (st &amp;&amp; st-&gt;action_par)
  {
    turn = *(int *)st-&gt;action_par;
  }

  turn = turn * P_Random() / 90;  // 10 bits of angle
   
  if (turn &lt; 0)
    object-&gt;angle -= (angle_t)((-turn) &lt;&lt; (ANGLEBITS - 10));
  else
    object-&gt;angle += (angle_t)(turn &lt;&lt; (ANGLEBITS - 10));
}
</t>
<t tx="T1700">
void P_ActMlookFace(mobj_t * object)
{
  const state_t *st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
    object-&gt;vertangle = *(float_t *)st-&gt;action_par;
  else
    object-&gt;vertangle = 0.0;
}
</t>
<t tx="T1701">
void P_ActMlookTurn(mobj_t * object)
{
  const state_t *st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
    object-&gt;vertangle = *(float_t *)st-&gt;action_par;
}
</t>
<t tx="T1702">
void P_ActMoveFwd(mobj_t * object)
{
  const state_t *st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    float_t amount = *(float_t *)st-&gt;action_par;
    
    float_t dx = M_Cos(object-&gt;angle);
    float_t dy = M_Sin(object-&gt;angle);

    object-&gt;mom.x += dx * amount;
    object-&gt;mom.y += dy * amount;
  }
}
</t>
<t tx="T1703">
void P_ActMoveRight(mobj_t * object)
{
  const state_t *st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
  {
    float_t amount = *(float_t *)st-&gt;action_par;
    
    float_t dx = M_Cos(object-&gt;angle - ANG90);
    float_t dy = M_Sin(object-&gt;angle - ANG90);

    object-&gt;mom.x += dx * amount;
    object-&gt;mom.y += dy * amount;
  }
}
</t>
<t tx="T1704">
void P_ActMoveUp(mobj_t * object)
{
  const state_t *st = object-&gt;state;

  if (st &amp;&amp; st-&gt;action_par)
    object-&gt;mom.z += *(float_t *)st-&gt;action_par;
}
</t>
<t tx="T1705">
void P_ActStopMoving(mobj_t * object)
{
  object-&gt;mom.x = object-&gt;mom.y = object-&gt;mom.z = 0;
}
</t>
<t tx="T1706">@ -------------------------------------------------------------------
-------------------SOUND CAUSING ROUTINES--------------------------
-------------------------------------------------------------------

P_ActPlaySound

Generate an arbitrary sound.
@c

void P_ActPlaySound(mobj_t * mo)
{
  sfx_t *sound = NULL;

  if (mo-&gt;state &amp;&amp; mo-&gt;state-&gt;action_par)
    sound = (sfx_t *) mo-&gt;state-&gt;action_par;

  if (! sound)
  {
    M_WarnError("P_ActPlaySound: missing sound name in %s.\n", 
        mo-&gt;info-&gt;ddf.name);
    return;
  }

  S_StartSound(mo, sound);
}
</t>
<t tx="T1707">@ P_ActKillSound

Kill any current sounds from this thing.
@c

void P_ActKillSound(mobj_t * mo)
{
  S_StopSound(mo);
}
</t>
<t tx="T1708">@ P_ActMakeAmbientSound

Just a sound generating procedure that cause the sound ref
in seesound to be generated.
@c

void P_ActMakeAmbientSound(mobj_t * object)
{
  if (object-&gt;info-&gt;seesound)
    S_StartSound(object, object-&gt;info-&gt;seesound);

#ifdef DEVELOPERS
  else
    L_WriteDebug("%s has no ambient sound\n", object-&gt;info-&gt;ddf.name);
#endif
}
</t>
<t tx="T1709">@ P_ActMakeAmbientSoundRandom

Give a small "random" chance that this object will make its
ambient sound. Currently this is a set value of 50, however
the code that drives this, should allow for the user to set
the value, note for further DDF Development.
@c

void P_ActMakeAmbientSoundRandom(mobj_t * object)
{
  if (object-&gt;info-&gt;seesound)
  {
    if (M_Random() &lt; 50)
      S_StartSound(object, object-&gt;info-&gt;seesound);
  }
#ifdef DEVELOPERS
  else
  {
    L_WriteDebug("%s has no ambient sound\n", object-&gt;info-&gt;ddf.name);
    return;
  }
#endif

}
</t>
<t tx="T1710">@ P_ActMakeActiveSound

Just a sound generating procedure that cause the sound ref
in seesound to be generated.

-KM- 1999/01/31
@c

void P_ActMakeActiveSound(mobj_t * object)
{
  if (object-&gt;info-&gt;activesound)
    S_StartSound(object, object-&gt;info-&gt;activesound);

#ifdef DEVELOPERS
  else
    L_WriteDebug("%s has no ambient sound\n", object-&gt;info-&gt;ddf.name);
#endif
}
</t>
<t tx="T1711">@ P_ActMakeDyingSound

This procedure is like everyother sound generating
procedure with the exception that if the object is
a boss (EF_BOSSMAN extended flag) then the sound is
generated at full volume (source = NULL).
@c

void P_ActMakeDyingSound(mobj_t * object)
{
  sfx_t *sound;

  sound = object-&gt;info-&gt;deathsound;

  if (sound)
  {
    if (object-&gt;info-&gt;extendedflags &amp; EF_BOSSMAN)
      S_StartSound(NULL, sound);
    else
      S_StartSound(object, sound);
    return;
  }

#ifdef DEVELOPERS
  L_WriteDebug("%s has no death sound\n", object-&gt;info-&gt;ddf.name);
#endif
}
</t>
<t tx="T1712">@ P_ActMakePainSound (Ow!! it hurts!)
@c

void P_ActMakePainSound(mobj_t * object)
{
  if (object-&gt;info-&gt;painsound)
  {
    if (object-&gt;info-&gt;extendedflags &amp; EF_BOSSMAN)
      S_StartSound(object, object-&gt;info-&gt;painsound);
    else
      S_StartSound(object, object-&gt;info-&gt;painsound);
  }
#ifdef DEVELOPERS
  else
  {
    L_WriteDebug("%s has no pain sound\n", object-&gt;info-&gt;ddf.name);
  }
#endif
}
</t>
<t tx="T1713">@ P_ActMakeOverKillSound

-AJA- 1999/12/01: made user definable.
@c

void P_ActMakeOverKillSound(mobj_t * object)
{
  if (object-&gt;info-&gt;overkill_sound)
  {
    if (object-&gt;info-&gt;extendedflags &amp; EF_BOSSMAN)
      S_StartSound(NULL, object-&gt;info-&gt;overkill_sound);
    else
      S_StartSound(object, object-&gt;info-&gt;overkill_sound);
  }
#ifdef DEVELOPERS
  else
    L_WriteDebug("%s has no overkill sound\n", object-&gt;info-&gt;ddf.name);
#endif
}
</t>
<t tx="T1714">@ P_ActMakeCloseAttemptSound

Attempting close combat sound
@c

void P_ActMakeCloseAttemptSound(mobj_t * object)
{
  sfx_t *sound;

  if (! object-&gt;info-&gt;closecombat)
    I_Error("Object [%s] used CLOSEATTEMPTSND action, "
        "but has no CLOSE_ATTACK\n", object-&gt;info-&gt;ddf.name);
   
  sound = object-&gt;info-&gt;closecombat-&gt;initsound;

  if (sound)
  {
    S_StartSound(object, sound);
  }
#ifdef DEVELOPERS
  else
    L_WriteDebug("%s has no close combat attempt sound\n", object-&gt;info-&gt;ddf.name);
#endif
}
</t>
<t tx="T1715">@ P_ActMakeRangeAttemptSound

Attempting attack at range sound
@c

void P_ActMakeRangeAttemptSound(mobj_t * object)
{
  sfx_t *sound;

  if (! object-&gt;info-&gt;rangeattack)
    I_Error("Object [%s] used RANGEATTEMPTSND action, "
        "but has no RANGE_ATTACK\n", object-&gt;info-&gt;ddf.name);     

  sound = object-&gt;info-&gt;rangeattack-&gt;initsound;

  if (sound)
    S_StartSound(object, sound);
#ifdef DEVELOPERS
  else
    L_WriteDebug("%s has no range attack attempt sound\n", object-&gt;info-&gt;ddf.name);
#endif
}
</t>
<t tx="T1716">@ -------------------------------------------------------------------
-------------------EXPLOSION DAMAGE ROUTINES-----------------------
-------------------------------------------------------------------

P_ActDamageExplosion

Radius Attack damage set by info-&gt;damage. Used for the original Barrels
@c

void P_ActDamageExplosion(mobj_t * object)
{
  float_t damage;
  
  DAMAGE_COMPUTE(damage, &amp;object-&gt;info-&gt;damage);

#ifdef DEVELOPERS
  if (!damage)
  {
    L_WriteDebug("%s caused no explosion damage\n", object-&gt;info-&gt;ddf.name);
    return;
  }
#endif

  P_RadiusAttack(object, object-&gt;source, damage, damage,
      &amp;object-&gt;info-&gt;damage, false);
}
</t>
<t tx="T1717">@ P_ActThrust

Thrust set by info-&gt;damage.

-AJA- 1999/11/06: written.
@c

void P_ActThrust(mobj_t * object)
{
  float_t damage;
  
  DAMAGE_COMPUTE(damage, &amp;object-&gt;info-&gt;damage);

#ifdef DEVELOPERS
  if (!damage)
  {
    L_WriteDebug("%s caused no thrust\n", object-&gt;info-&gt;ddf.name);
    return;
  }
#endif

  P_RadiusAttack(object, object-&gt;source, damage, damage,
      &amp;object-&gt;info-&gt;damage, true);
}
</t>
<t tx="T1718">@ -------------------------------------------------------------------
-------------------MISSILE HANDLING ROUTINES-----------------------
-------------------------------------------------------------------

P_ActExplode

The object blows up, like a missile.

-AJA- 1999/08/21: Replaced P_ActExplodeMissile (which was identical
to p_mobj's P_ExplodeMissile) with this.
@c

void P_ActExplode(mobj_t * object)
{
  P_MobjExplodeMissile(object);
}
</t>
<t tx="T1719">@ P_ActCheckMissileSpawn

This procedure handles a newly spawned missile, it moved
by half the amount of momentum and then checked to see
if the move is possible, if not the projectile is
exploded. Also the number of initial tics on its
current state is taken away from by a random number
between 0 and 3, although the number of tics will never
go below 1.

-ACB- 1998/08/04

-AJA- 1999/08/22: Fixed a bug that occasionally caused the game to
go into an infinite loop. NOTE WELL: don't fiddle with the
object's x &amp; y directly, use P_TryMove instead, or
P_ChangeThingPosition.
@c

static void CheckMissileSpawn(mobj_t * projectile)
{
  projectile-&gt;tics -= P_Random() &amp; 3;

  if (projectile-&gt;tics &lt; 1)
    projectile-&gt;tics = 1;

  projectile-&gt;z += projectile-&gt;mom.z / 2;

  if (!P_TryMove(projectile,
          projectile-&gt;x + projectile-&gt;mom.x / 2,
          projectile-&gt;y + projectile-&gt;mom.y / 2))
  {
    P_MobjExplodeMissile(projectile);
  }
}
</t>
<t tx="T1720">@ P_ActLaunchProjectile

This procedure launches a project the direction of the target mobj.
* source - the source of the projectile
* target - the target of the projectile
* type  - the mobj type of the projectile

For all sense and purposes it is possible for the target to be a dummy
mobj, just to act as a carrier for a set of target co-ordinates.

Missiles can be spawned at different locations on and around
the mobj. Traditionally an mobj would fire a projectile
at a height of 32 from the centerpoint of that
mobj, this was true for all creatures from the Cyberdemon to
the Imp. The currentattack holds the height and x &amp; y
offsets that dictates the spawning location of a projectile.

Traditionally: Height  = 4*8
x-offset = 0
y-offset = 0

The exception to this rule is the revenant, which did increase
its z value by 16 before firing: This was a hack
to launch a missile at a height of 48. The revenants
height was reduced to normal after firing, this new code
makes that an unnecesary procedure.

projx, projy &amp; projz are the projectiles spawn location

NOTE: may return NULL.

-ACB- 1998/08/04
-KM- 1998/11/25 Accuracy is now a fixed_t
@c

static mobj_t *LaunchProjectile(mobj_t * source, mobj_t * target,
    const mobjinfo_t * type)
{
  const attacktype_t *attack;
  float_t projx, projy, projz;
  angle_t angle;
  float_t slope;
  mobj_t *projectile;
  float_t yoffset;

  attack = source-&gt;currentattack;

  if (! attack)
    return NULL;

  // -AJA- prevent possible crashes.  Prolly not the best solution,
  //       more like a baid-aid solution.
  if (!target)
    target = P_MapTargetTheory(source);

  // -AJA- projz now handles crouching
  projx = source-&gt;x;
  projy = source-&gt;y;
  projz = source-&gt;z + attack-&gt;height * source-&gt;height /
      source-&gt;info-&gt;height;

  angle = source-&gt;angle;

  projx += attack-&gt;xoffset * M_Cos(source-&gt;angle + ANG90);
  projy += attack-&gt;xoffset * M_Sin(source-&gt;angle + ANG90);

  if (attack-&gt;yoffset)
    yoffset = attack-&gt;yoffset;
  else
    yoffset = source-&gt;radius - 0.5;

  projx += yoffset * M_Cos(angle);
  projy += yoffset * M_Sin(angle);
  projz += yoffset * source-&gt;vertangle;

  projectile = P_MobjCreateObject(projx, projy, projz, type);

  // currentattack is held so that when a collision takes place
  // with another object, we know whether or not the object hit
  // can shake off the attack or is damaged by it.
  //
  projectile-&gt;currentattack = attack;
  P_MobjSetRealSource(projectile, source);

  // check for blocking lines between source and projectile
  if (P_MapCheckBlockingLine(source, projectile))
  {
    P_MobjExplodeMissile(projectile);
    return NULL;
  }

  if (projectile-&gt;info &amp;&amp; projectile-&gt;info-&gt;seesound)
  {
    if (projectile-&gt;info-&gt;extendedflags &amp; EF_BOSSMAN)
      S_StartSound(NULL, projectile-&gt;info-&gt;seesound);
    else
      S_StartSound(projectile, projectile-&gt;info-&gt;seesound);
  }

  angle = R_PointToAngle(projx, projy, target-&gt;x, target-&gt;y);

  // Now add the fact that the target may be difficult to spot and
  // make the projectile's target the same as the sources. Only
  // do these if the object is not a dummy object, otherwise just
  // flag the missile not to trace: you cannot track a target that
  // does not exist...
  //
  if (target-&gt;extendedflags &amp; EF_DUMMYMOBJ)
  {
    projectile-&gt;extendedflags |= EF_NOTRACE;
    P_MobjSetTarget(projectile, NULL);
    target-&gt;z += attack-&gt;height;
  }
  else
  {
    P_MobjSetTarget(projectile, target);
    projectile-&gt;extendedflags |= EF_FIRSTCHECK;

    if (!attack-&gt;flags &amp; AF_Player)
    {
      if (target-&gt;flags &amp; MF_FUZZY)
        angle += P_RandomNegPos() &lt;&lt; (ANGLEBITS - 12);

      if (target-&gt;visibility &lt; VISIBLE)
        angle += P_RandomNegPos() * 64 * (VISIBLE - target-&gt;visibility);
    }
  }

  // Calculate slope
  slope = P_ApproxSlope(target-&gt;x - projx, target-&gt;y - projy,
      MO_MIDZ(target) - projz);

  // -AJA- 1999/09/11: add in attack's angle &amp; slope offsets.
  angle -= attack-&gt;angle_offset;
  slope += attack-&gt;slope_offset;
  
  // is the attack not accurate?
  if (!source-&gt;player || source-&gt;player-&gt;refire &gt; 0)
  {
    if (attack-&gt;accuracy_angle &gt; 0)
      angle += (attack-&gt;accuracy_angle &gt;&gt; 8) * P_RandomNegPos();
    if (attack-&gt;accuracy_slope &gt; 0)
      slope += attack-&gt;accuracy_slope * (P_RandomNegPos() / 255.0);
  }

  P_SetMobjDirAndSpeed(projectile, angle, slope, projectile-&gt;speed);
  CheckMissileSpawn(projectile);

  return projectile;
}
</t>
<t tx="T1721">@ P_ActLaunchSmartProjectile

This procedure has the same effect as
LaunchProjectile, but it calculates a point where the target
and missile will intersect. This comes from the fact that to shoot
something, you have to aim slightly ahead of it. It will also put
an end to circle-strafing. :-)

-KM- 1998/10/29
-KM- 1998/12/16 Fixed it up. Works quite well :-)
@c

static void LaunchSmartProjectile(mobj_t * source, mobj_t * target, 
    const mobjinfo_t * type)
{
  float_t a, b, c;
  float_t t1 = -1, t2 = -1, t;
  float_t dx, dy;
  float_t mx, my;
  float_t s;

  // -AJA- prevent possible crashes.  Prolly not the best solution,
  //       more like a baid-aid solution.
  if (!target)
    target = P_MapTargetTheory(source);

  mx = target-&gt;mom.x;
  my = target-&gt;mom.y;

  dx = source-&gt;x - target-&gt;x;
  dy = source-&gt;y - target-&gt;y;

  s = type-&gt;speed;
  if (level_flags.fastparm)
    s *= type-&gt;fast;

  a = mx * mx + my * my - s * s;
  b = 2 * (dx * mx + dy * my);
  c = dx * dx + dy * dy;

  if (a &amp;&amp; ((b * b - 4 * a * c) &gt;= 0))
  {
    t1 = -b + sqrt(b * b - 4 * a * c);
    t1 /= 2 * a;

    t2 = -b - sqrt(b * b - 4 * a * c);
    t2 /= 2 * a;
  }

  if (t1 &lt; 0)
    t1 = t2;

  if (t2 &lt; 0)
    t2 = t1;

  t = t1 &lt; t2 ? t1 : t2;

  if (t &gt; 0)
  {
    static mobj_t spot;
    mobj_t *projectile;

    spot.x = target-&gt;x + mx * t;
    spot.y = target-&gt;y + my * t;
    
    // -KM- 1999/01/31 Calculate the target for grenades.
    if (type-&gt;flags &amp; MF_NOGRAVITY)
      spot.z = target-&gt;z + 2 * target-&gt;height / 3 - source-&gt;currentattack-&gt;height;
    else
      spot.z = target-&gt;z - source-&gt;z +
          target-&gt;subsector-&gt;sector-&gt;props.gravity * t * t / 16.0;

    spot.height = 0;
    spot.extendedflags = EF_DUMMYMOBJ;

    projectile = LaunchProjectile(source, &amp;spot, type);

    if (projectile)
      source-&gt;angle = projectile-&gt;angle;

    return;
  }

  LaunchProjectile(source, target, type);
}
</t>
<t tx="T1722">@ P_ActMissileContact

Called by PIT_CheckRelThing when a missile comes into
contact with another object. Placed here with
the other missile code for cleaner code.

Returns true if damage was done.

-ACB- 1998/08/10
@c

boolean_t P_ActMissileContact(mobj_t * object, mobj_t * objecthit)
{
  mobj_t *source;
  const damage_t *damtype;
  float_t damage;

  source = object-&gt;source;

  if (source)
  {
    if (source-&gt;info == objecthit-&gt;info)
    {
      if (!(objecthit-&gt;extendedflags &amp; EF_DISLOYALTYPE))
        return false;
    }

    if (object-&gt;currentattack != NULL &amp;&amp;
        !(objecthit-&gt;extendedflags &amp; EF_OWNATTACKHURTS))
    {
      if (object-&gt;currentattack == objecthit-&gt;info-&gt;rangeattack)
        return false;
      if (object-&gt;currentattack == objecthit-&gt;info-&gt;closecombat)
        return false;
    }
  }

  // check for immunity against the attack
  if (object-&gt;currentattack &amp;&amp; BITSET_EMPTY ==
      (object-&gt;currentattack-&gt;attack_class &amp; ~objecthit-&gt;info-&gt;immunity))
  {
    return false;
  }

  // support for "tunnelling" missiles, which should only do damage at
  // the first impact.
  if (object-&gt;extendedflags &amp; EF_TUNNEL)
  {
    // this hash is very basic, but should work OK
    unsigned long hash = (unsigned long)objecthit;

    if (object-&gt;tunnel_hash[0] == hash || object-&gt;tunnel_hash[1] == hash)
      return false;
    
    object-&gt;tunnel_hash[0] = object-&gt;tunnel_hash[1];
    object-&gt;tunnel_hash[1] = hash;
  }

  // transitional hack
  if (object-&gt;currentattack)
    damtype = &amp;object-&gt;currentattack-&gt;damage;
  else
    damtype = &amp;object-&gt;info-&gt;damage;

  DAMAGE_COMPUTE(damage, damtype);

  if (!damage)
  {
#ifdef DEVELOPERS
    L_WriteDebug("%s missile did zero damage.\n", 
      object-&gt;info-&gt;ddf.name);
#endif
    return false;
  }

  P_DamageMobj(objecthit, object, object-&gt;source, damage, damtype);
  return true;
}
</t>
<t tx="T1723">@ P_ActBulletContact

Called by PTR_ShootTraverse when a bullet comes into contact with
another object. Needed so that the "DISLOYAL" special will behave
in the same manner for bullets as for missiles. Note: also used
for close combat attacks.

Returns true if damage was done.

-AJA- 2000/02/17: written.
@c

boolean_t P_ActBulletContact(mobj_t * object, mobj_t * objecthit, 
    float_t damage, const damage_t *damtype)
{
  if (object-&gt;info == objecthit-&gt;info)
  {
    if (! (objecthit-&gt;extendedflags &amp; EF_DISLOYALTYPE))
      return false;
  }

  if (object-&gt;currentattack != NULL &amp;&amp;
      !(objecthit-&gt;extendedflags &amp; EF_OWNATTACKHURTS))
  {
    if (object-&gt;currentattack == objecthit-&gt;info-&gt;rangeattack)
      return false;
    if (object-&gt;currentattack == objecthit-&gt;info-&gt;closecombat)
      return false;
  }

  // check for immunity against the attack
  if (object-&gt;currentattack &amp;&amp; BITSET_EMPTY ==
      (object-&gt;currentattack-&gt;attack_class &amp; ~objecthit-&gt;info-&gt;immunity))
  {
    return false;
  }

  if (!damage)
  {
#ifdef DEVELOPERS
    L_WriteDebug("%s's shoot/combat attack did zero damage.\n", 
      object-&gt;info-&gt;ddf.name);
#endif
    return false;
  }

  P_DamageMobj(objecthit, object, object, damage, damtype);
  return true;
}
</t>
<t tx="T1724">@ P_ActCreateSmokeTrail

Just spawns smoke behind an mobj: the smoke is
risen by giving it z momentum, in order to
prevent the smoke appearing uniform (which obviously
does not happen), the number of tics that the smoke
mobj has is "randomly" reduced, although the number
of tics never gets to zero or below.

-ACB- 1998/08/10 Written
-ACB- 1999/10/01 Check thing's current attack has a smoke projectile
@c

void P_ActCreateSmokeTrail(mobj_t * projectile)
{
  mobj_t *smoke;
  float_t z;
  const attacktype_t *attack;

  attack = projectile-&gt;currentattack;

  if (attack == NULL)
    return;

  if (attack-&gt;puff == NULL)
  {
    M_WarnError("P_ActCreateSmokeTrail: attack %s has no PUFF object\n",
        attack-&gt;ddf.name);
    return;
  }
  
  // -AJA- 1999/12/07: center puff vertically
  z = MO_MIDZ(projectile) - attack-&gt;puff-&gt;height/2;

  // spawn a puff of smoke behind the rocket
  smoke = P_MobjCreateObject(
      projectile-&gt;x - projectile-&gt;mom.x, 
      projectile-&gt;y - projectile-&gt;mom.y, z, attack-&gt;puff);

  smoke-&gt;mom.z = smoke-&gt;info-&gt;float_speed;
  smoke-&gt;tics -= M_Random() &amp; 3;

  if (smoke-&gt;tics &lt; 1)
    smoke-&gt;tics = 1;
}
</t>
<t tx="T1725">@ P_ActRandomHomingProjectile

This projectile will alter its course to intercept its
target, if is possible for this procedure to be called
and nothing results because of a chance that the
projectile will not chase its target.

As this code is based on the revenant tracer, it did use
a bit check on the current gametic - which was why every so
often a revenant fires a missile straight and not one that
homes in on its target: If the gametic has bits 1+2 on
(which boils down to 1 in every 4 tics), the trick in this
is that - in conjuntion with the tic count for the
tracing object's states - the tracing will always fail or
pass the check: if it passes first time, it will always
pass and vice versa. The problem with this was two fold:
demos will go out of sync if the starting gametic if different
from when the demo was recorded (which admittly is easily
fixable), the second is that for someone designing a new
tracing projectile it would be more than a bit confusing to
joe "dooming" public.

The new system that affects the original gameplay slightly is
to get a random chance of the projectile not homing in on its
target and working this out first time round, the test result
is recorded (in the form of the presence or lack of the
extended flag: EF_NOTRACE) and everytime this procedure is
called, it will check for the flag and act accordingly.

Chance calculated is in percentage terms. The procedure below
this one gives the original gameplay.

-ACB- 1998/08/10
@c

void P_ActRandomHomingProjectile(mobj_t * projectile)
{
  angle_t exact;
  float_t slope;
  mobj_t *destination;
  const attacktype_t *attack;

  attack = projectile-&gt;currentattack;

  if (attack == NULL)
    return;

  if (projectile-&gt;extendedflags &amp; EF_NOTRACE)
    return;

  if (projectile-&gt;extendedflags &amp; EF_FIRSTCHECK)
  {
    // if either value is zero, the projectile will trace
    if (P_RandomTest(attack-&gt;notracechance))
    {
      projectile-&gt;extendedflags |= EF_NOTRACE;
      return;
    }

    projectile-&gt;extendedflags &amp;= ~EF_FIRSTCHECK;
  }

  if (attack-&gt;flags &amp; AF_TraceSmoke)
    P_ActCreateSmokeTrail(projectile);

  destination = projectile-&gt;target;

  if (!destination || destination-&gt;health &lt;= 0)
    return;

  // change angle
  exact = R_PointToAngle(projectile-&gt;x, projectile-&gt;y,
      destination-&gt;x, destination-&gt;y);

  if (exact != projectile-&gt;angle)
  {
    if (exact - projectile-&gt;angle &gt; 0x80000000)
    {
      projectile-&gt;angle -= TRACEANGLE;

      if (exact - projectile-&gt;angle &lt; 0x80000000)
        projectile-&gt;angle = exact;
    }
    else
    {
      projectile-&gt;angle += TRACEANGLE;

      if (exact - projectile-&gt;angle &gt; 0x80000000)
        projectile-&gt;angle = exact;
    }
  }

  exact = projectile-&gt;angle;
  projectile-&gt;mom.x = projectile-&gt;speed * M_Cos(exact);
  projectile-&gt;mom.y = projectile-&gt;speed * M_Sin(exact);

  // change slope
  slope = P_ApproxSlope(destination-&gt;x - projectile-&gt;x,
      destination-&gt;y - projectile-&gt;y,
      MO_MIDZ(destination) - projectile-&gt;z);

  slope *= projectile-&gt;speed;

  if (slope &lt; projectile-&gt;mom.z)
    projectile-&gt;mom.z -= 0.125;
  else
    projectile-&gt;mom.z += 0.125;
}
</t>
<t tx="T1726">@ P_ActFixedHomingProjectile

This projectile will alter its course to intercept its
target, if is possible for this procedure to be called
and nothing results because of a chance that the
projectile will not chase its target.

Same as above, but more this is for purists; the above
procedure gives a random chance; the one here is based on
a modulas result from gametic (subtracting the levelstarttic
to make sure the results are the same when playing back the
demos: it is possible for gametic to be different when playing
a demo), the test result is recorded (in the form of the
presence or lack of the extended flag: EF_NOTRACE) and
everytime this procedure is called, it will check for the
flag and act accordingly. Although a Purist function, it does
allow a dual firing object thats launchs two tracer-types
in the same tic to generate either tracers or normal missiles.

-ACB- 1998/08/20
@c

void P_ActFixedHomingProjectile(mobj_t * projectile)
{
  angle_t exact;
  float_t slope;
  mobj_t *destination;
  const attacktype_t *attack;

  attack = projectile-&gt;currentattack;

  if (attack == NULL)
    return;

  if (projectile-&gt;extendedflags &amp; EF_NOTRACE)
    return;

  if (projectile-&gt;extendedflags &amp; EF_FIRSTCHECK)
  {
    projectile-&gt;extendedflags &amp;= ~EF_FIRSTCHECK;

    if (P_RandomTest(attack-&gt;notracechance))
    {
      projectile-&gt;extendedflags |= EF_NOTRACE;
      return;
    }
  }

  if (attack-&gt;flags &amp; AF_TraceSmoke)
    P_ActCreateSmokeTrail(projectile);

  destination = projectile-&gt;target;

  if (!destination || destination-&gt;health &lt;= 0)
    return;

  // change angle
  exact = R_PointToAngle(projectile-&gt;x, projectile-&gt;y,
      destination-&gt;x, destination-&gt;y);

  if (exact != projectile-&gt;angle)
  {
    if (exact - projectile-&gt;angle &gt; 0x80000000)
    {
      projectile-&gt;angle -= TRACEANGLE;

      if (exact - projectile-&gt;angle &lt; 0x80000000)
        projectile-&gt;angle = exact;
    }
    else
    {
      projectile-&gt;angle += TRACEANGLE;

      if (exact - projectile-&gt;angle &gt; 0x80000000)
        projectile-&gt;angle = exact;
    }
  }

  projectile-&gt;mom.x = projectile-&gt;speed * M_Cos(exact);
  projectile-&gt;mom.y = projectile-&gt;speed * M_Sin(exact);

  // change slope
  slope = P_ApproxSlope(destination-&gt;x - projectile-&gt;x,
      destination-&gt;y - projectile-&gt;y,
      MO_MIDZ(destination) - projectile-&gt;z);
  
  slope *= projectile-&gt;speed;

  if (slope &lt; projectile-&gt;mom.z)
    projectile-&gt;mom.z -= 0.125;
  else
    projectile-&gt;mom.z += 0.125;
}
</t>
<t tx="T1727">@ P_ActHomeToSpot

This projectile will alter its course to intercept its
target, or explode if it has reached it. Used by the bossbrain
cube.

-AJA- 1999/09/15: written.
@c

void P_ActHomeToSpot(mobj_t * projectile)
{
  float_t dx, dy, dz;
  float_t angle, slope;
  float_t ck_radius, ck_height;

  mobj_t *target = projectile-&gt;target;
  
  if (!target)
  {
    P_MobjExplodeMissile(projectile);
    return;
  }

  dx = target-&gt;x - projectile-&gt;x;
  dy = target-&gt;y - projectile-&gt;y;
  dz = target-&gt;z - projectile-&gt;z;

  ck_radius = target-&gt;radius + projectile-&gt;radius + 2;
  ck_height = target-&gt;height + projectile-&gt;height + 2;
  
  // reached target ?
  if (fabs(dx) &lt;= ck_radius &amp;&amp; fabs(dy) &lt;= ck_radius &amp;&amp; fabs(dz) &lt;= ck_height)
  {
    P_MobjExplodeMissile(projectile);
    return;
  }

  // calculate new angles
  angle = R_PointToAngle(0, 0, dx, dy);
  slope = P_ApproxSlope(dx, dy, dz);
  
  P_SetMobjDirAndSpeed(projectile, angle, slope, projectile-&gt;speed);
}
</t>
<t tx="T1728">@ P_ActLaunchOrderedSpread

Due to the unique way of handling that the mancubus fires, it is necessary
to write a single procedure to handle the firing. In real terms it amounts
to a glorified hack; The table holds the angle modifier and the choice of
whether the firing object or the projectile is affected. This procedure
should NOT be used for players as it will alter the player's mobj, bypassing
the normal player controls; The only reason for its existance is to maintain
the original mancubus behaviour. Although it is possible to make this generic,
the benefits of doing so are minimal. Purist function....

-ACB- 1998/08/15
@c

void P_ActLaunchOrderedSpread(mobj_t * object)
{
  // left side = angle modifier
  // right side = object or projectile (true for object).
  static int spreadorder[] =
  {
      (ANG90 / 8), true,
      (ANG90 / 8), false,
      -(ANG90 / 8), true,
      -(ANG90 / 4), false,
      -(ANG90 / 16), false,
      (ANG90 / 16), false
  };

  mobj_t *projectile;
  angle_t angle;
  int count;
  const attacktype_t *attack;

  attack = object-&gt;currentattack;

  if (attack == NULL)
    return;

  count = object-&gt;spreadcount;

  if (count &lt; 0 || count &gt; 12)
    count = object-&gt;spreadcount = 0;

  // object or projectile? - if true is the object, else it is the projectile
  if (spreadorder[count + 1])
  {
    object-&gt;angle += spreadorder[count];
    LaunchProjectile(object, object-&gt;target, attack-&gt;atk_mobj);
  }
  else
  {
    projectile = LaunchProjectile(object, object-&gt;target,
        attack-&gt;atk_mobj);

    if (projectile == NULL)
      return;

    projectile-&gt;angle += spreadorder[count];
    angle = projectile-&gt;angle;

    projectile-&gt;mom.x = projectile-&gt;speed * M_Cos(angle);
    projectile-&gt;mom.y = projectile-&gt;speed * M_Sin(angle);
  }

  object-&gt;spreadcount += 2;
}
</t>
<t tx="T1729">@ P_ActLaunchRandomSpread

This is a the generic function that should be used for a spreader like
mancubus, although its random nature would certainly be a change to the
ordered method used now. The random number is bit shifted to the right
and then the ANG90 is divided by it, the first bit of the RN is checked
to detemine if the angle is change is negative or not (approx 50% chance).
The result is the modifier for the projectile's angle.

-ACB- 1998/08/15
@c

void P_ActLaunchRandomSpread(mobj_t * object)
{
  mobj_t *projectile;
  angle_t spreadangle;
  angle_t angle;
  int i;

  if (object-&gt;currentattack == NULL)
    return;

  projectile = LaunchProjectile(object, object-&gt;target,
      object-&gt;currentattack-&gt;atk_mobj);

  if (projectile == NULL)
    return;

  i = P_Random() % 128;

  if (i &gt;&gt; 1)
  {
    spreadangle = (ANG90 / (i &gt;&gt; 1));

    if (i &amp; 1)
      spreadangle -= spreadangle &lt;&lt; 1;

    projectile-&gt;angle += spreadangle;
  }

  angle = projectile-&gt;angle;

  projectile-&gt;mom.x = projectile-&gt;speed * M_Cos(angle);
  projectile-&gt;mom.y = projectile-&gt;speed * M_Sin(angle);
}
</t>
<t tx="T1730">@ -------------------------------------------------------------------
-------------------LINEATTACK ATTACK ROUTINES-----------------------
-------------------------------------------------------------------
-KM- 1998/11/25 Added uncertainty to the z component of the line.
@c

static void ShotAttack(mobj_t * object)
{
  int i;
  int count;
  angle_t angle;
  angle_t objangle;
  float_t slope, objslope;
  float_t damage;
  const attacktype_t *attack;

  attack = object-&gt;currentattack;
  count = attack-&gt;count;

  if (! attack)
    return;

  // -ACB- 1998/09/05 Remember to use the object angle, fool!
  objangle = object-&gt;angle;
  if (object-&gt;player &amp;&amp; (! object-&gt;target || 
      (object-&gt;target-&gt;extendedflags &amp; EF_DUMMYMOBJ)))
    objslope = object-&gt;vertangle;
  else
    objslope = P_AimLineAttack(object, objangle, MISSILERANGE);

  if (attack-&gt;sound)
    S_StartSound(object, attack-&gt;sound);

  // -AJA- 1999/09/10: apply the attack's angle offsets.
  objangle -= attack-&gt;angle_offset;
  objslope += attack-&gt;slope_offset;
  
  for (i = 0; i &lt; count; i++)
  {
    angle = objangle;
    slope = objslope;

    // is the attack not accurate?
    if (!object-&gt;player || object-&gt;player-&gt;refire &gt; 0)
    {
      if (attack-&gt;accuracy_angle &gt; 0)
        angle += (attack-&gt;accuracy_angle &gt;&gt; 8) * P_RandomNegPos();
      if (attack-&gt;accuracy_slope &gt; 0)
        slope += attack-&gt;accuracy_slope * (P_RandomNegPos() / 255.0);
    }

    DAMAGE_COMPUTE(damage, &amp;attack-&gt;damage);

    P_LineAttack(object, angle, MISSILERANGE, slope, damage,
        &amp;attack-&gt;damage, attack-&gt;puff);
  }
}
</t>
<t tx="T1731">@ -KM- 1998/11/25 BFG Spray attack. Must be used from missiles.
Will do a BFG spray on every monster in sight.
@c

static void SprayAttack(mobj_t * mo)
{
  int i;
  angle_t an;
  const attacktype_t *attack;
  mobj_t *m;
  float_t damage;

  attack = mo-&gt;currentattack;

  if (! attack)
    return;

  // offset angles from its attack angle
  for (i = 0; i &lt; 40; i++)
  {
    an = mo-&gt;angle - ANG90 / 2 + (ANG90 / 40) * i;

    // mo-&gt;source is the originator (player)
    //  of the missile
    P_AimLineAttack(mo-&gt;source ? mo-&gt;source : mo, an, attack-&gt;range);

    if (!linetarget)
      continue;

    m = P_MobjCreateObject(linetarget-&gt;x, linetarget-&gt;y,
        linetarget-&gt;z + linetarget-&gt;height / 4,
        attack-&gt;atk_mobj);

    P_MobjSetTarget(m, mo-&gt;target);

    // check for immunity against the attack
    if (BITSET_EMPTY == (attack-&gt;attack_class &amp; ~linetarget-&gt;info-&gt;immunity))
    {
      return;
    }

    DAMAGE_COMPUTE(damage, &amp;attack-&gt;damage);

    if (damage)
      P_DamageMobj(linetarget, NULL, mo-&gt;source, damage, &amp;attack-&gt;damage);
  }
}
</t>
<t tx="T1732">@ -------------------------------------------------------------------
--------------------TRACKER HANDLING ROUTINES----------------------
-------------------------------------------------------------------

A Tracker is an object that follows its target, by being on top of
it. This is the attack style used by an Arch-Vile. The first routines
handle the tracker itself, the last two are called by the source of
the tracker.


P_ActTrackerFollow

Called by the tracker to follow its target.

-ACB- 1998/08/22
@c

void P_ActTrackerFollow(mobj_t * tracker)
{
  mobj_t *destination;
  angle_t angle;

  destination = tracker-&gt;target;

  if (!destination || !tracker-&gt;source)
    return;

  // check for dummy object
  if (destination-&gt;extendedflags &amp; EF_DUMMYMOBJ)
    return;

  // Can the source of the tracker, see the destination target?
  if (!P_CheckSight(tracker-&gt;source, destination))
    return;

  angle = destination-&gt;angle;

  P_ChangeThingPosition(tracker,
      destination-&gt;x + 24 * M_Cos(angle),
      destination-&gt;y + 24 * M_Sin(angle),
      destination-&gt;z);
}
</t>
<t tx="T1733">@ P_ActTrackerActive

Called by the tracker to make its active sound: also tracks

-ACB- 1998/08/22
@c

void P_ActTrackerActive(mobj_t * tracker)
{
  if (tracker-&gt;info-&gt;activesound)
    S_StartSound(tracker, tracker-&gt;info-&gt;activesound);

  P_ActTrackerFollow(tracker);
}
</t>
<t tx="T1734">@ P_ActTrackerStart

Called by the tracker to make its launch (see) sound: also tracks

-ACB- 1998/08/22
@c

void P_ActTrackerStart(mobj_t * tracker)
{
  if (tracker-&gt;info-&gt;seesound)
    S_StartSound(tracker, tracker-&gt;info-&gt;seesound);

  P_ActTrackerFollow(tracker);
}
</t>
<t tx="T1735">@ LaunchTracker

This procedure starts a tracking object off and links
the tracker and the object together.

-ACB- 1998/08/22
@c

static void LaunchTracker(mobj_t * object)
{
  mobj_t *tracker;
  mobj_t *target;
  const attacktype_t *attack;

  attack = object-&gt;currentattack;
  target = object-&gt;target;

  if (!attack || !target || (target-&gt;extendedflags &amp; EF_DUMMYMOBJ))
    return;

  tracker = P_MobjCreateObject(target-&gt;x, target-&gt;y, target-&gt;z,
      attack-&gt;atk_mobj);

  // link the tracker to the object
  P_MobjSetTracer(object, tracker);

  // tracker source is the object
  P_MobjSetRealSource(tracker, object);

  // tracker's target is the object's target
  P_MobjSetTarget(tracker, target);

  P_ActTrackerFollow(tracker);
}
</t>
<t tx="T1736">@ P_ActEffectTracker

Called by the object that launched the tracker to
cause damage to its target and a radius attack
(explosion) at the location of the tracker.

-ACB- 1998/08/22
@c

void P_ActEffectTracker(mobj_t * object)
{
  mobj_t *tracker;
  mobj_t *target;
  const attacktype_t *attack;
  angle_t angle;
  float_t damage;

  if (!object-&gt;target || !object-&gt;currentattack)
    return;

  attack = object-&gt;currentattack;
  target = object-&gt;target;

  if (attack-&gt;flags &amp; AF_FaceTarget)
    P_ActFaceTarget(object);

  if (attack-&gt;flags &amp; AF_NeedSight)
  {
    if (!P_CheckSight(object, target))
      return;
  }

  if (attack-&gt;sound)
    S_StartSound(object, attack-&gt;sound);

  angle = object-&gt;angle;
  tracker = object-&gt;tracer;

  DAMAGE_COMPUTE(damage, &amp;attack-&gt;damage);

  if (damage)
    P_DamageMobj(target, object, object, damage, &amp;attack-&gt;damage);
#ifdef DEVELOPERS
  else
    L_WriteDebug("%s + %s attack has zero damage\n",
        object-&gt;info-&gt;ddf.name, tracker-&gt;info-&gt;ddf.name);
#endif

  // -ACB- 2000/03/11 Check for zero mass
  if (target-&gt;info-&gt;mass)
    target-&gt;mom.z = 1000 / target-&gt;info-&gt;mass;
  else
    target-&gt;mom.z = 2000;

  if (!tracker)
    return;

  // move the tracker between the object and the object's target

  P_ChangeThingPosition(tracker,
      target-&gt;x - 24 * M_Cos(angle),
      target-&gt;y - 24 * M_Sin(angle),
      target-&gt;z);

#ifdef DEVELOPERS
  if (!tracker-&gt;info-&gt;damage.nominal)
    L_WriteDebug("%s + %s explosion has zero damage\n",
        object-&gt;info-&gt;ddf.name, tracker-&gt;info-&gt;ddf.name);
#endif

  DAMAGE_COMPUTE(damage, &amp;tracker-&gt;info-&gt;damage);

  P_RadiusAttack(tracker, object, damage, damage,
      &amp;tracker-&gt;info-&gt;damage, false);
}
</t>
<t tx="T1737">@ -----------------------------------------------------------------
--------------------BOSS HANDLING PROCEDURES---------------------
-----------------------------------------------------------------
@c

static void ShootToSpot(mobj_t * object)
{
  // Note: using a static int here for better randomness.
  static int current_spot = 0;

  if (! object-&gt;currentattack)
    return;

  if (brain_spots.number == 0)
  {
    if (! object-&gt;info-&gt;spitspot)
    {
      M_WarnError("Thing [%s] used SHOOT_TO_SPOT attack, but has no "
          "SPIT_SPOT\n", object-&gt;info-&gt;ddf.name);
      return;
    }

    P_LookForShootSpots(object-&gt;info-&gt;spitspot);
  }

  DEV_ASSERT2(brain_spots.targets);
  DEV_ASSERT2(brain_spots.number &gt; 0);

  current_spot += P_Random();
  current_spot %= brain_spots.number;
  
  LaunchProjectile(object, brain_spots.targets[current_spot],
      object-&gt;currentattack-&gt;atk_mobj);
}
</t>
<t tx="T1738">@ -------------------------------------------------------------------
-------------------OBJECT-SPAWN-OBJECT HANDLING--------------------
-------------------------------------------------------------------

P_ActObjectSpawning

An Object spawns another object and is spawned in the state specificed
by attack-&gt;objinitstate. The procedure is based on the A_PainShootSkull
which is the routine for shooting skulls from a pain elemental. In
this the object being created is decided in the attack. This
procedure also used the new blocking line check to see if
the object is spawned across a blocking line, if so the procedure
terminates.

-ACB- 1998/08/23
@c

static void ObjectSpawning(mobj_t * object, angle_t angle)
{
  float_t spawnx;
  float_t spawny;
  float_t spawnz;
  float_t slope;
  float_t prestep;
  const attacktype_t *attack;
  const mobjinfo_t *shoottype;
  mobj_t *newobject;

  attack = object-&gt;currentattack;
  if (! attack)
    return;

  shoottype = attack-&gt;spawnedobj;

  if (! shoottype)
    I_Error("Object [%s] uses spawning attack [%s], but no object "
        "specified.\n", object-&gt;info-&gt;ddf.name, attack-&gt;ddf.name);

  // -AJA- 1999/09/10: apply the angle offset of the attack.
  angle -= attack-&gt;angle_offset;
  slope = object-&gt;vertangle + attack-&gt;slope_offset;
  
  if (attack-&gt;flags &amp; AF_PrestepSpawn)
  {
    prestep = 4 + 1.5 * object-&gt;radius + shoottype-&gt;radius;
    spawnx = object-&gt;x + prestep * M_Cos(angle);
    spawny = object-&gt;y + prestep * M_Sin(angle);
  }
  else
  {
    spawnx = object-&gt;x;
    spawny = object-&gt;y;
  }

  spawnz = object-&gt;z + attack-&gt;height;

  newobject = P_MobjCreateObject(spawnx, spawny, spawnz, shoottype);

  // Blocking line detected between object and spawnpoint?
  if (P_MapCheckBlockingLine(object, newobject))
  {
    // -KM- 1999/01/31 Explode objects over remove them.
    // -AJA- 2000/02/01: Remove now the default.

    if (attack-&gt;flags &amp; AF_KillFailedSpawn)
      P_KillMobj(object, newobject, NULL);
    else
      P_RemoveMobj(newobject);

    return;
  }

  if (attack-&gt;sound)
    S_StartSound(object, attack-&gt;sound);

  // If the object cannot move from its position, remove it or kill it.
  if (!P_TryMove(newobject, newobject-&gt;x, newobject-&gt;y))
  {
    if (attack-&gt;flags &amp; AF_KillFailedSpawn)
      P_KillMobj(object, newobject, NULL);
    else
      P_RemoveMobj(newobject);

    return;
  }

  P_MobjSetTarget(newobject, object-&gt;target);
  P_MobjSetSupportObj(newobject, object);
  newobject-&gt;side = object-&gt;side;

  // -AJA- 1999/09/25: Set the initial direction &amp; momentum when
  //       the ANGLED_SPAWN attack special is used.
  if (attack-&gt;flags &amp; AF_AngledSpawn)
    P_SetMobjDirAndSpeed(newobject, angle, slope, attack-&gt;assault_speed);

  P_SetMobjStateDeferred(newobject, attack-&gt;objinitstate, 0);
}
</t>
<t tx="T1739">@ P_ActObjectTripleSpawn

Spawns three objects at 90, 180 and 270 degrees. This is essentially
another purist function to support the death sequence of the Pain
elemental. However it could be used as in conjunction with radius
triggers to generate a nice teleport spawn invasion.

-ACB- 1998/08/23 (I think....)
@c

static void ObjectTripleSpawn(mobj_t * object)
{
  ObjectSpawning(object, object-&gt;angle + ANG90);
  ObjectSpawning(object, object-&gt;angle + ANG180);
  ObjectSpawning(object, object-&gt;angle + ANG270);
}
</t>
<t tx="T1740">@ -------------------------------------------------------------------
-------------------SKULLFLY HANDLING ROUTINES----------------------
-------------------------------------------------------------------

P_ActSkullFlyAssault

This is the attack procedure for objects that launch themselves
at their target like a missile.

-ACB- 1998/08/16
@c

static void SkullFlyAttack(mobj_t * object)
{
  mobj_t *destination;
  float_t slope;
  float_t speed;
  sfx_t *sound;

  if (!object-&gt;currentattack)
    return;

  if (!object-&gt;target)
  {
    // -AJA- 2000/09/29: fix for the zombie lost soul bug
    // -AJA- 2000/10/22: monsters only !  Don't stuff up gibs/missiles.
    if (object-&gt;extendedflags &amp; EF_MONSTER)
      object-&gt;flags |= MF_SKULLFLY;
    return;
  }

  speed = object-&gt;currentattack-&gt;assault_speed;

  // -KM- 1999/01/31 Fix skulls in nightmare mode
  if (level_flags.fastparm)
    speed *= object-&gt;info-&gt;fast;

  destination = object-&gt;target;
  sound = object-&gt;currentattack-&gt;initsound;
  object-&gt;flags |= MF_SKULLFLY;

  if (sound)
    S_StartSound(object, sound);

  slope = P_ApproxSlope(destination-&gt;x - object-&gt;x,
      destination-&gt;y - object-&gt;y,
      MO_MIDZ(destination) - object-&gt;z);

  P_SetMobjDirAndSpeed(object, object-&gt;angle, slope, speed);
}
</t>
<t tx="T1741">@ P_ActSlammedIntoObject

Used when a flying object hammers into another object when on the
attack. Replaces the code in PIT_Checkthing.

-ACB- 1998/07/29: Written

-AJA- 1999/09/12: Now uses P_SetMobjStateDeferred, since this
routine can be called by TryMove/PIT_CheckRelThing.
@c

void P_ActSlammedIntoObject(mobj_t * object, mobj_t * objecthit)
{
  sfx_t *sound;
  float_t damage;

  if (object-&gt;currentattack)
  {
    if (objecthit != NULL)
    {
      // -KM- 1999/01/31 Only hurt shootable objects...
      if (objecthit-&gt;flags &amp; MF_SHOOTABLE)
      {
        DAMAGE_COMPUTE(damage, &amp;object-&gt;currentattack-&gt;damage);

        P_DamageMobj(objecthit, object, object, damage,
            &amp;object-&gt;currentattack-&gt;damage);
      }
    }

    sound = object-&gt;currentattack-&gt;sound;
    if (sound)
      S_StartSound(object, sound);
  }

  object-&gt;flags &amp;= ~MF_SKULLFLY;
  object-&gt;mom.x = object-&gt;mom.y = object-&gt;mom.z = 0;

  P_SetMobjStateDeferred(object, object-&gt;info-&gt;idle_state, 0);
}
</t>
<t tx="T1742">@ P_ActUseThing

Called when this thing is attempted to be used (i.e. by pressing
the spacebar near it) by the player. Returns true if successfully
used, or false if other things should be checked.

-AJA- 2000/02/17: written.
@c

boolean_t P_ActUseThing(mobj_t * user, mobj_t * thing, float_t open_bottom,
    float_t open_top)
{
  // item is disarmed ?
  if (!(thing-&gt;flags &amp; MF_TOUCHY))
    return false;
  
  // can be reached ?
  open_top    = MIN(open_top, thing-&gt;z + thing-&gt;height);
  open_bottom = MAX(open_bottom, thing-&gt;z);
  
  if (user-&gt;z &gt;= open_top || 
      (user-&gt;z + user-&gt;height + USE_Z_RANGE &lt; open_bottom))
    return false;
  
  // OK, disarm and put into touch states  
  DEV_ASSERT2(thing-&gt;info-&gt;touch_state &gt; 0);

  thing-&gt;flags &amp;= ~MF_TOUCHY;
  P_SetMobjStateDeferred(thing, thing-&gt;info-&gt;touch_state, 0);

  return true;
}
</t>
<t tx="T1743">@ P_ActTouchyContact

Used whenever a thing comes into contact with a TOUCHY object.

-AJA- 1999/08/21 written.
-AJA- 1999/09/12: Now uses P_SetMobjStateDeferred, since this
routine can be called by TryMove/PIT_CheckRelThing.
@c

void P_ActTouchyContact(mobj_t *touchy, mobj_t *victim)
{
  // dead thing touching. Can happen with a sliding player corpse.
  if (victim-&gt;health &lt;= 0)
    return;

  // don't harm the grenadier...
  if (touchy-&gt;source == victim)
    return;

  P_MobjSetTarget(touchy, victim);
  touchy-&gt;flags &amp;= ~MF_TOUCHY;  // disarm

  if (touchy-&gt;info-&gt;touch_state)
    P_SetMobjStateDeferred(touchy, touchy-&gt;info-&gt;touch_state, 0);
  else
    P_MobjExplodeMissile(touchy);
}
</t>
<t tx="T1744">@ P_ActTouchyRearm
P_ActTouchyDisarm

-AJA- 1999/08/22 written.
@c

void P_ActTouchyRearm(mobj_t * touchy)
{
  touchy-&gt;flags |= MF_TOUCHY;
}
</t>
<t tx="T1745">
void P_ActTouchyDisarm(mobj_t * touchy)
{
  touchy-&gt;flags &amp;= ~MF_TOUCHY;
}
</t>
<t tx="T1746">@ P_ActBounceRearm
P_ActBounceDisarm

-AJA- 1999/10/18 written.
@c

void P_ActBounceRearm(mobj_t * mo)
{
  mo-&gt;extendedflags &amp;= ~EF_JUSTBOUNCED;
}
</t>
<t tx="T1747">
void P_ActBounceDisarm(mobj_t * mo)
{
  mo-&gt;extendedflags |= EF_JUSTBOUNCED;
}
</t>
<t tx="T1748">@ P_ActDropItem

-AJA- 2000/10/20: added.
@c

void P_ActDropItem(mobj_t * mo)
{
  const mobjinfo_t *info = mo-&gt;info-&gt;dropitem;
  mobj_t *item;

  float_t dx, dy;

  if (mo-&gt;state &amp;&amp; mo-&gt;state-&gt;action_par)
    info = (const mobjinfo_t *) mo-&gt;state-&gt;action_par;

  if (! info)
  {
    M_WarnError("P_ActDropItem: %s specifies no item to drop.\n", 
        mo-&gt;info-&gt;ddf.name);
    return;
  }

  // unlike normal drops, these ones are displaced randomly

  dx = P_RandomNegPos() * mo-&gt;info-&gt;radius / 255.0;
  dy = P_RandomNegPos() * mo-&gt;info-&gt;radius / 255.0;

  item = P_MobjCreateObject(mo-&gt;x + dx, mo-&gt;y + dy, mo-&gt;floorz, info);

  // -ES- 1998/07/18 NULL check to prevent crashing
  if (item)
  {
    item-&gt;flags |= MF_DROPPED;
    item-&gt;flags &amp;= ~MF_SOLID;

    item-&gt;angle = mo-&gt;angle;

    // allow respawning
    item-&gt;spawnpoint.x = item-&gt;x;
    item-&gt;spawnpoint.y = item-&gt;y;
    item-&gt;spawnpoint.z = item-&gt;z;
    item-&gt;spawnpoint.angle = item-&gt;angle;
    item-&gt;spawnpoint.slope = item-&gt;vertangle;
    item-&gt;spawnpoint.info  = info;
    item-&gt;spawnpoint.flags = 0;
  }
}
</t>
<t tx="T1749">@ P_ActPathCheck

Checks if the creature is a path follower, and if so enters the
meander states.

-AJA- 2000/02/17: wrote this &amp; PathFollow.
@c

void P_ActPathCheck(mobj_t * mo)
{
  if (! mo-&gt;path_trigger || ! mo-&gt;info-&gt;meander_state)
    return;
 
  P_SetMobjStateDeferred(mo, mo-&gt;info-&gt;meander_state, 0);

  mo-&gt;movedir = mo-&gt;movecount = 0;
}
</t>
<t tx="T1750">@ P_ActPathFollow

For path-following creatures (spawned via RTS), makes the creature
follow the path by trying to get to the next node.
@c

void P_ActPathFollow(mobj_t * mo)
{
  float_t dx, dy;
  angle_t diff;

  if (! mo-&gt;path_trigger)
    return;

  if (RAD_CheckReachedTrigger(mo))
  {
    mo-&gt;movedir = 0;
    return;
  }

  // maybe reached the end ?
  if (! mo-&gt;path_trigger)
    return;

  dx = mo-&gt;path_trigger-&gt;x - mo-&gt;x;
  dy = mo-&gt;path_trigger-&gt;y - mo-&gt;y;

  diff = mo-&gt;angle - R_PointToAngle(0, 0, dx, dy);

  // movedir value: 
  //   0 for slow turning.
  //   1 for fast turning.
  //   2 for walking.
  //   3 for evasive maneouvres.
  
  if (mo-&gt;movedir &lt; 2)
  {
    angle_t step = (mo-&gt;movedir == 1) ? ANG1*30 : ANG1*7;
    
    // if not facing the path node, turn towards it
    if (diff &gt; ANG1*15 &amp;&amp; diff &lt; ANG180)
    {
      mo-&gt;angle -= P_Random() * (step &gt;&gt; 8);
      return;
    }
    else if (diff &gt;= ANG180 &amp;&amp; diff &lt; ANG1*345U)
    {
      mo-&gt;angle += P_Random() * (step &gt;&gt; 8);
      return;
    }

    mo-&gt;movedir = 2;
  }

  if (mo-&gt;movedir == 2)
  {
    if (diff &lt; ANG1*30)
      mo-&gt;angle -= ANG1;
    else if (diff &gt;= ANG1*330U)
      mo-&gt;angle += ANG1;
    else
      mo-&gt;movedir = 0;

    if (! P_Move(mo, true))
    {
      mo-&gt;movedir = 3;
      mo-&gt;angle = P_Random() &lt;&lt; (ANGLEBITS - 8);
      mo-&gt;movecount = 1 + (P_Random() &amp; 7);
    }
    return;
  }

  // make evasive maneouvres
  mo-&gt;movecount--;
  if (mo-&gt;movecount &lt;= 0)
  {
    mo-&gt;movedir = 1;
    return;
  }

  P_Move(mo, true);
}
</t>
<t tx="T1751">@ -------------------------------------------------------------------
--------------------ATTACK HANDLING PROCEDURES---------------------
-------------------------------------------------------------------

P_DoAttack

When an object goes on the attack, it current attack is handled here;
the attack type is discerned and the assault is launched.

-ACB- 1998/08/07
@c

void P_DoAttack(mobj_t * object)
{
  const attacktype_t *attack;
  mobj_t *target;
  float_t damage;

  attack = object-&gt;currentattack;
  target = object-&gt;target;

  DEV_ASSERT2(attack);

  switch (attack-&gt;attackstyle)
  {
    case ATK_CLOSECOMBAT:
    {
      // -KM- 1998/12/21 Use Line attack so bullet puffs are spawned.
      float_t slope;

      if (!DecideMeleeAttack(object, attack))
      {
        P_LineAttack(object, object-&gt;angle, attack-&gt;range, object-&gt;vertangle, 
            1, NULL, attack-&gt;puff);
        return;
      }

      if (attack-&gt;sound)
        S_StartSound(object, attack-&gt;sound);

      DAMAGE_COMPUTE(damage, &amp;attack-&gt;damage);

      // -KM- 1998/11/25 Berserk ability

      if (object-&gt;player &amp;&amp; object-&gt;player-&gt;powers[PW_Berserk] &gt; 0)
        damage *= 10.0;

      slope = P_AimLineAttack(object, object-&gt;angle, attack-&gt;range);

      P_LineAttack(object, object-&gt;angle, attack-&gt;range, slope,
          damage, &amp;attack-&gt;damage, attack-&gt;puff);
      break;
    }

    case ATK_PROJECTILE:
    {
      LaunchProjectile(object, target, attack-&gt;atk_mobj);
      break;
    }

    case ATK_SMARTPROJECTILE:
    {
      LaunchSmartProjectile(object, target, attack-&gt;atk_mobj);
      break;
    }

    case ATK_RANDOMSPREAD:
    {
      P_ActLaunchRandomSpread(object);
      break;
    }

    case ATK_SHOOTTOSPOT:
    {
      ShootToSpot(object);
      break;
    }

    case ATK_SHOT:
    {
      ShotAttack(object);
      break;
    }

    case ATK_SKULLFLY:
    {
      SkullFlyAttack(object);
      break;
    }

    case ATK_SPAWNER:
    {
      ObjectSpawning(object, object-&gt;angle);
      break;
    }

    case ATK_SPREADER:
    {
      P_ActLaunchOrderedSpread(object);
      break;
    }

    case ATK_TRACKER:
    {
      LaunchTracker(object);
      break;
    }

    case ATK_TRIPLESPAWNER:
    {
      ObjectTripleSpawn(object);
      break;
    }

    // -KM- 1998/11/25 Added spray attack
    case ATK_SPRAY:
    {
      SprayAttack(object);
      break;
    }

    default:  // THIS SHOULD NOT HAPPEN
    {
#ifdef DEVELOPERS
      I_Error("P_DoAttack: %s has an unknown attack type.\n", object-&gt;info-&gt;ddf.name);
#endif
      break;
    }
  }
}
</t>
<t tx="T1752">@ P_ActComboAttack

This is called at end of a set of states that can result in
either a closecombat or ranged attack. The procedure checks
to see if the target is within melee range and picks the
approiate attack.

-ACB- 1998/08/07
@c

void P_ActComboAttack(mobj_t * object)
{
  const attacktype_t *attack;

  if (!object-&gt;target)
    return;

  if (DecideMeleeAttack(object, object-&gt;info-&gt;closecombat))
    attack = object-&gt;info-&gt;closecombat;
  else
    attack = object-&gt;info-&gt;rangeattack;

  if (attack)
  {
    if (attack-&gt;flags &amp; AF_FaceTarget)
      P_ActFaceTarget(object);

    if (attack-&gt;flags &amp; AF_NeedSight)
    {
      if (!P_CheckSight(object, object-&gt;target))
        return;
    }

    object-&gt;currentattack = attack;
    P_DoAttack(object);
  }
#ifdef DEVELOPERS
  else
  {
    if (!object-&gt;info-&gt;closecombat)
      M_WarnError("%s hasn't got a close combat attack\n", object-&gt;info-&gt;ddf.name);
    else
      M_WarnError("%s hasn't got a range attack\n", object-&gt;info-&gt;ddf.name);
  }
#endif

}
</t>
<t tx="T1753">@ P_ActMeleeAttack

Setup a close combat assault

-ACB- 1998/08/07
@c

void P_ActMeleeAttack(mobj_t * object)
{
  const attacktype_t *attack;

  attack = object-&gt;info-&gt;closecombat;

  // -AJA- 1999/08/10: Multiple attack support.
  if (object-&gt;state &amp;&amp; object-&gt;state-&gt;action_par)
    attack = (const attacktype_t *) object-&gt;state-&gt;action_par;

  if (!attack)
  {
    M_WarnError("P_ActMeleeAttack: %s has no close combat attack.\n", 
        object-&gt;info-&gt;ddf.name);
    return;
  }

  if (attack-&gt;flags &amp; AF_FaceTarget)
    P_ActFaceTarget(object);

  if (attack-&gt;flags &amp; AF_NeedSight)
  {
    if (!object-&gt;target || !P_CheckSight(object, object-&gt;target))
      return;
  }

  object-&gt;currentattack = attack;
  P_DoAttack(object);
}
</t>
<t tx="T1754">@ P_ActRangeAttack

Setup an attack at range

-ACB- 1998/08/07
@c

void P_ActRangeAttack(mobj_t * object)
{
  const attacktype_t *attack;

  attack = object-&gt;info-&gt;rangeattack;

  // -AJA- 1999/08/10: Multiple attack support.
  if (object-&gt;state &amp;&amp; object-&gt;state-&gt;action_par)
    attack = (const attacktype_t *) object-&gt;state-&gt;action_par;

  if (!attack)
  {
    M_WarnError("P_ActRangeAttack: %s hasn't got a range attack.\n", 
        object-&gt;info-&gt;ddf.name);
    return;
  }

  if (attack-&gt;flags &amp; AF_FaceTarget)
    P_ActFaceTarget(object);

  if (attack-&gt;flags &amp; AF_NeedSight)
  {
    if (!object-&gt;target || !P_CheckSight(object, object-&gt;target))
      return;
  }

  object-&gt;currentattack = attack;
  P_DoAttack(object);
}
</t>
<t tx="T1755">@ P_ActSpareAttack

Setup an attack that is not defined as close or range. can be
used to act as a follow attack for close or range, if you want one to
add to the others.

-ACB- 1998/08/24
@c

void P_ActSpareAttack(mobj_t *object)
{
  const attacktype_t *attack;

  attack = object-&gt;info-&gt;spareattack;

  // -AJA- 1999/08/10: Multiple attack support.
  if (object-&gt;state &amp;&amp; object-&gt;state-&gt;action_par)
    attack = (const attacktype_t *) object-&gt;state-&gt;action_par;

  if (attack)
  {
    if ((attack-&gt;flags &amp; AF_FaceTarget) &amp;&amp; object-&gt;target)
      P_ActFaceTarget(object);

    if ((attack-&gt;flags &amp; AF_NeedSight) &amp;&amp; object-&gt;target)
    {
      if (!P_CheckSight(object, object-&gt;target))
        return;
    }

    object-&gt;currentattack = attack;
    P_DoAttack(object);
  }
#ifdef DEVELOPERS
  else
  {
    M_WarnError("P_ActSpareAttack: %s hasn't got a spare attack\n", object-&gt;info-&gt;ddf.name);
    return;
  }
#endif

}
</t>
<t tx="T1756">@ P_ActRefireCheck

This procedure will be called inbetween firing on an object
that will fire repeatly (Chaingunner/Arachontron etc...), the
purpose of this is to see if the object should refire and
performs checks to that effect, first there is a check to see
if the object will keep firing regardless and the others
check if the the target exists, is alive and within view. The
only other code here is a stealth check: a object with stealth
capabilitys will lose the ability while firing.

-ACB- 1998/08/10
@c

void P_ActRefireCheck(mobj_t * object)
{
  mobj_t *target;
  const attacktype_t *attack;

  attack = object-&gt;currentattack;

  if (! attack)
    return;

  if (attack-&gt;flags &amp; AF_FaceTarget)
    P_ActFaceTarget(object);

  // Random chance that object will keep firing regardless
  if (P_RandomTest(attack-&gt;keepfirechance))
    return;

  target = object-&gt;target;

  if (!target || (target-&gt;health &lt;= 0) || !P_CheckSight(object, target))
  {
    if (object-&gt;info-&gt;chase_state)
      P_SetMobjStateDeferred(object, object-&gt;info-&gt;chase_state, 0);
  }
  else if (object-&gt;flags &amp; MF_STEALTH)
  {
    object-&gt;vis_target = VISIBLE;
  }
}
</t>
<t tx="T1757">@ ---------------------------------------------
-----------LOOKING AND CHASING---------------
---------------------------------------------

SelectTarget

Search the things list for a target

-ACB- 2000/06/20 Re-written and Simplified
@c

static mobj_t *SelectTarget(boolean_t newlev)
{
  static mobj_t *targetobj;
  int count;

  // Setup target object
  if (newlev)
    targetobj = mobjlisthead;

  // Nothing?
  if (!targetobj)
    return NULL;

  // Find mobj in list 
  count = P_Random();
  while (count)
  {
    if (targetobj)
      targetobj = targetobj-&gt;next;
    else
      targetobj = mobjlisthead;

    count--;
  }

  // Found end of list
  if (!targetobj)
    return NULL;

  // Not a valid obj?
  if (!(targetobj-&gt;info-&gt;extendedflags&amp;EF_MONSTER) || targetobj-&gt;health&lt;=0)
    return NULL;

  return targetobj;
}
</t>
<t tx="T1758">@ CreateAggression

Sets an object up to target a previously stored object.

-ACB- 2000/06/20 Re-written and Simplified
@c

static boolean_t CreateAggression(mobj_t * object)
{
  static const mapstuff_t *mapcheck = NULL;
  static mobj_t *target = NULL;
  static int count = 0;
  const mobjinfo_t *targinfo;
  const mobjinfo_t *objinfo;

  count++;

  // New map of no map - setup the procedure for next time
  if (mapcheck == NULL || mapcheck != currentmap)
  {
    mapcheck = currentmap;
    target = SelectTarget(true);
    count = 0;
    return false;
  }

  // No target or target dead
  if (target == NULL)
  {
    target = SelectTarget(false);
    count = 0;
    return false;
  }

  if (!(target-&gt;info-&gt;extendedflags&amp;EF_MONSTER) || target-&gt;health &lt;= 0)
  {
    target = SelectTarget(false);
    count = 0;
    return false;
  }

  // Don't target self...
  if (object == target)
    return false;

  // This object has been checked too many times, try a another one.
  if (count &gt; 127)
  {
    target = SelectTarget(false);
    count = 0;
    return false;
  }

  objinfo = object-&gt;info;
  targinfo = target-&gt;info;

  if (!P_CheckSight(object, target))
    return false;

  if ((targinfo == objinfo) &amp;&amp; (!(objinfo-&gt;extendedflags &amp; EF_DISLOYALTYPE)))
    return false;

  // -ACB- 2000/07/20 Remove checking of attacks 
  if (!(objinfo-&gt;extendedflags &amp; EF_OWNATTACKHURTS))
  {
    // Type the same and it can't hurt own kind - not good.
    if (targinfo == objinfo)
      return false;
  }

  P_MobjSetTarget(object, target);

  if (object-&gt;info-&gt;chase_state)
    P_SetMobjStateDeferred(object, object-&gt;info-&gt;chase_state, 0);

  return true;
}
</t>
<t tx="T1759">@ P_ActStandardLook

Standard Lookout procedure

-ACB- 1998/08/22
@c

void P_ActStandardLook(mobj_t * object)
{
  int targ_pnum;
  mobj_t *targ = NULL;

  object-&gt;threshold = 0;  // any shot will wake up

  targ_pnum = object-&gt;subsector-&gt;sector-&gt;sound_player;

  if (targ_pnum &gt;= 0 &amp;&amp; targ_pnum &lt; MAXPLAYERS &amp;&amp; 
      playerlookup[targ_pnum])
  {
    targ = playerlookup[targ_pnum]-&gt;mo;
  }

  if (object-&gt;flags &amp; MF_STEALTH)
    object-&gt;vis_target = VISIBLE;

  if (infight)
  {
    if (CreateAggression(object))
      return;
  }

  if (targ &amp;&amp; (targ-&gt;flags &amp; MF_SHOOTABLE))
  {
    P_MobjSetTarget(object, targ);

    if (object-&gt;flags &amp; MF_AMBUSH)
    {
      if (!P_CheckSight(object, object-&gt;target) &amp;&amp; 
          !P_LookForPlayers(object, object-&gt;info-&gt;sight_angle))
        return;
    }
  }
  else
  {
    if (!P_LookForPlayers(object, object-&gt;info-&gt;sight_angle))
      return;
  }

  if (object-&gt;info-&gt;seesound)
  {
    if (object-&gt;info-&gt;extendedflags &amp; EF_BOSSMAN)
      S_StartSound(NULL, object-&gt;info-&gt;seesound);
    else
      S_StartSound(object, object-&gt;info-&gt;seesound);
  }

  if (object-&gt;info-&gt;chase_state)
    P_SetMobjStateDeferred(object, object-&gt;info-&gt;chase_state, 0);
}
</t>
<t tx="T1760">@ P_ActPlayerSupportLook

Player Support Lookout procedure

-ACB- 1998/09/05
@c

void P_ActPlayerSupportLook(mobj_t * object)
{
  object-&gt;threshold = 0;  // any shot will wake up

  if (object-&gt;flags &amp; MF_STEALTH)
    object-&gt;vis_target = VISIBLE;

  if (!object-&gt;supportobj)
  {
    if (! P_ActLookForTargets(object))
      return;

    if (object-&gt;info-&gt;seesound)
    {
      if (object-&gt;info-&gt;extendedflags &amp; EF_BOSSMAN)
        S_StartSound(NULL, object-&gt;info-&gt;seesound);
      else
        S_StartSound(object, object-&gt;info-&gt;seesound);
    }
  }

  if (object-&gt;info-&gt;meander_state)
    P_SetMobjStateDeferred(object, object-&gt;info-&gt;meander_state, 0);
}
</t>
<t tx="T1761">@ P_ActStandardMeander
@c

void P_ActStandardMeander(mobj_t * object)
{
  int delta;

  object-&gt;threshold = 0;  // any shot will wake up

  // move within supporting distance of player
  if (--object-&gt;movecount &lt; 0 || !P_Move(object, false))
    P_NewChaseDir(object);

  // turn towards movement direction if not there yet
  if (object-&gt;movedir &lt; 8)
  {
    object-&gt;angle &amp;= (7 &lt;&lt; 29);
    delta = object-&gt;angle - (object-&gt;movedir &lt;&lt; 29);

    if (delta &gt; 0)
      object-&gt;angle -= ANG45;
    else if (delta &lt; 0)
      object-&gt;angle += ANG45;
  }
}
</t>
<t tx="T1762">@ P_ActPlayerSupportMeander
@c

void P_ActPlayerSupportMeander(mobj_t * object)
{
  int delta;

  object-&gt;threshold = 0;  // any shot will wake up

  // move within supporting distance of player
  if (--object-&gt;movecount &lt; 0 || !P_Move(object, false))
    P_NewChaseDir(object);

  // turn towards movement direction if not there yet
  if (object-&gt;movedir &lt; 8)
  {
    object-&gt;angle &amp;= (7 &lt;&lt; 29);
    delta = object-&gt;angle - (object-&gt;movedir &lt;&lt; 29);

    if (delta &gt; 0)
      object-&gt;angle -= ANG45;
    else if (delta &lt; 0)
      object-&gt;angle += ANG45;
  }

  //
  // we have now meandered, now check for a support object, if we don't
  // look for one and return; else look for targets to take out, if we
  // find one, go for the chase.
  //
  /*  if (!object-&gt;supportobj)
     {
     P_ActPlayerSupportLook(object);
     return;
     } */

  P_ActLookForTargets(object);
}
</t>
<t tx="T1763">@ P_ActStandardChase

Standard AI Chase Procedure

-ACB- 1998/08/22 Procedure Written
-ACB- 1998/09/05 Added Support Object Check
@c

void P_ActStandardChase(mobj_t * object)
{
  int delta;
  sfx_t *sound;

  if (object-&gt;reactiontime)
    object-&gt;reactiontime--;

  // object has a pain threshold, while this is true, reduce it. while
  // the threshold is true, the object will remain intent on its target.
  if (object-&gt;threshold)
  {
    if (!object-&gt;target || object-&gt;target-&gt;health &lt;= 0)
      object-&gt;threshold = 0;
    else
      object-&gt;threshold--;
  }

  // A Chasing Stealth Creature becomes less visible
  if (object-&gt;flags &amp; MF_STEALTH)
    object-&gt;vis_target = INVISIBLE;

  // turn towards movement direction if not there yet
  if (object-&gt;movedir &lt; 8)
  {
    object-&gt;angle &amp;= (7 &lt;&lt; 29);
    delta = object-&gt;angle - (object-&gt;movedir &lt;&lt; 29);

    if (delta &gt; 0)
      object-&gt;angle -= ANG45;
    else if (delta &lt; 0)
      object-&gt;angle += ANG45;
  }

  if (!object-&gt;target || !(object-&gt;target-&gt;flags &amp; MF_SHOOTABLE))
  {
    if (P_ActLookForTargets(object))
      return;

    // -ACB- 1998/09/06 Target is not relevant: NULLify.
    P_MobjSetTarget(object, NULL);

    P_SetMobjStateDeferred(object, object-&gt;info-&gt;idle_state, 0);
    return;
  }

  // do not attack twice in a row
  if (object-&gt;flags &amp; MF_JUSTATTACKED)
  {
    object-&gt;flags &amp;= ~MF_JUSTATTACKED;

    // -KM- 1998/12/16 Nightmare mode set the fast parm.
    if (!level_flags.fastparm)
      P_NewChaseDir(object);

    return;
  }

  sound = object-&gt;info-&gt;attacksound;

  // check for melee attack
  if (object-&gt;info-&gt;melee_state &amp;&amp; DecideMeleeAttack(object, object-&gt;info-&gt;closecombat))
  {
    if (sound)
      S_StartSound(object, sound);

    if (object-&gt;info-&gt;melee_state)
      P_SetMobjStateDeferred(object, object-&gt;info-&gt;melee_state, 0);
    return;
  }

  // check for missile attack
  if (object-&gt;info-&gt;missile_state)
  {
    // -KM- 1998/12/16 Nightmare set the fastparm.
    if (!(!level_flags.fastparm &amp;&amp; object-&gt;movecount))
    {
      if (P_ActDecideRangeAttack(object))
      {
        if (object-&gt;info-&gt;missile_state)
          P_SetMobjStateDeferred(object, object-&gt;info-&gt;missile_state, 0);
        object-&gt;flags |= MF_JUSTATTACKED;
        return;
      }
    }
  }

  // possibly choose another target
  // -ACB- 1998/09/05 Object-&gt;support-&gt;object check, go for new targets
  if (!P_CheckSight(object, object-&gt;target) &amp;&amp; !object-&gt;threshold)
  {
    if (P_ActLookForTargets(object))
      return;
  }

  // chase towards player
  if (--object-&gt;movecount &lt; 0 || !P_Move(object, false))
    P_NewChaseDir(object);

  // make active sound
  if (object-&gt;info-&gt;activesound &amp;&amp; M_Random() &lt; 3)
    S_StartSound(object, object-&gt;info-&gt;activesound);
}
</t>
<t tx="T1764">@ P_ActResurrectChase

Before undertaking the standard chase procedure, the object
will check for a nearby corpse and raises one if it exists.

-ACB- 1998/08/22 Procedure written
-ACB- 1998/09/05 Support Check: Raised object supports raiser's supportobj
@c

void P_ActResurrectChase(mobj_t * object)
{
  mobj_t *corpse;

  corpse = P_MapFindCorpse(object);

  if (corpse)
  {
    object-&gt;angle = R_PointToAngle(object-&gt;x, object-&gt;y, corpse-&gt;x, corpse-&gt;y);
    if (object-&gt;info-&gt;res_state)
      P_SetMobjStateDeferred(object, object-&gt;info-&gt;res_state, 0);

    // corpses without raise states should be skipped
    DEV_ASSERT2(corpse-&gt;info-&gt;raise_state);

    P_BringCorpseToLife(corpse);

    // -ACB- 1998/09/05 Support Check: Res creatures to support that object
    if (object-&gt;supportobj)
    {
      P_MobjSetSupportObj(corpse, object-&gt;supportobj);
      P_MobjSetTarget(corpse, object-&gt;target);
    }
    else
    {
      P_MobjSetSupportObj(corpse, NULL);
      P_MobjSetTarget(corpse, NULL);
    }

    // -AJA- Resurrected creatures are on Archvile's side (like MBF)
    corpse-&gt;side = object-&gt;side;
    return;
  }

  P_ActStandardChase(object);
}
</t>
<t tx="T1765">@ P_ActWalkSoundChase

Make a sound and then chase...
@c

void P_ActWalkSoundChase(mobj_t * object)
{
  if (!object-&gt;info-&gt;walksound)
  {
    M_WarnError("WALKSOUND_CHASE: %s hasn't got a walksound.\n", 
        object-&gt;info-&gt;ddf.name);
    return;
  }

  S_StartSound(object, object-&gt;info-&gt;walksound);
  P_ActStandardChase(object);
}
</t>
<t tx="T1766">@ P_ActCheckBlood

-KM- 1999/01/31 Part of the extra blood option, makes blood stick around...
-AJA- 1999/10/02: ...but not indefinitely.
@c

void P_ActCheckBlood(mobj_t * mo)
{
  if (level_flags.more_blood &amp;&amp; mo-&gt;tics &gt;= 0)
  {
    int val = P_Random();

    // exponential formula
    mo-&gt;tics = ((val * val * val) &gt;&gt; 18) * TICRATE + TICRATE;
  }
}
</t>
<t tx="T1767">@ P_ActJump

Jumps to the given label, possibly randomly. Note: nothing to do
with monsters physically jumping.
@c

void P_ActJump(mobj_t * object)
{
  act_jump_info_t *jump;
  
  if (!object-&gt;state || !object-&gt;state-&gt;action_par)
  {
    M_WarnError("JUMP action used in [%s] without a label !\n",
        object-&gt;info-&gt;ddf.name);
    return;
  }

  jump = (act_jump_info_t *) object-&gt;state-&gt;action_par;

  DEV_ASSERT2(jump-&gt;chance &gt;= 0);
  DEV_ASSERT2(jump-&gt;chance &lt;= 1);

  if (P_RandomTest(jump-&gt;chance))
  {
    object-&gt;next_state = (object-&gt;state-&gt;jumpstate == S_NULL) ?
        NULL : (states + object-&gt;state-&gt;jumpstate);
  }
}
</t>
<t tx="T1768">@ P_ActPlayerAttack

-AJA- 1999/08/08: New attack flag FORCEAIM, which fixes chainsaw.
@c

void P_ActPlayerAttack(mobj_t * p_obj, const attacktype_t * attack)
{
  mobj_t *target;
  angle_t diff = ANG180 / 32;
  float_t range;

  DEV_ASSERT2(attack);

  range = (attack-&gt;range &gt; 0) ? attack-&gt;range : MISSILERANGE;
  p_obj-&gt;currentattack = attack;

  // see which target is to be aimed at
  target = P_MapTargetAutoAim(p_obj, p_obj-&gt;angle,
      range, attack-&gt;flags &amp; AF_ForceAim);
  P_MobjSetTarget(p_obj, target);

  if (leveltime &amp; 1)
    diff = 0 - diff;

  // -KM- 1998/12/16 If that is a miss, aim slightly right or slightly 
  //      left of the target.
  if (target-&gt;extendedflags &amp; EF_DUMMYMOBJ)
  {
    target = P_MapTargetAutoAim(p_obj, p_obj-&gt;angle + diff,
        range, attack-&gt;flags &amp; AF_ForceAim);
  }

  if (target-&gt;extendedflags &amp; EF_DUMMYMOBJ)
  {
    target = P_MapTargetAutoAim(p_obj, p_obj-&gt;angle - diff,
        range, attack-&gt;flags &amp; AF_ForceAim);
  }

  if (! (target-&gt;extendedflags &amp; EF_DUMMYMOBJ))
    P_MobjSetTarget(p_obj, target);

  if (attack-&gt;flags &amp; AF_FaceTarget)
    P_ActFaceTarget(p_obj);

  P_DoAttack(p_obj);
}
</t>
<t tx="T1769">@ignore
@language c

// Play Simulation Action routines: 'DeathBots'

&lt;&lt; p_bot #includes &gt;&gt;
&lt;&lt; p_bot declarations &gt;&gt;
@others
</t>
<t tx="T1770">#include "i_defs.h"
#include "p_bot.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "g_game.h"
#include "m_random.h"
#include "p_local.h"
#include "p_weapon.h"
#include "r_state.h"
#include "s_sound.h"
#include "w_wad.h"
#include "z_zone.h"
#include "p_action.h"
#include "rad_trig.h"
</t>
<t tx="T1771">
// Linked list of all bots.
static bot_t *bots = NULL;

static float_t bot_atkrange;
static mobj_t *bot_shooter = NULL;
</t>
<t tx="T1772">
static void NewBotChaseDir(bot_t * bot)
{
  // FIXME: This is not very intelligent...
  if (bot-&gt;target &amp;&amp; (M_Random() &amp; 1))
  {
    bot-&gt;angle = R_PointToAngle(bot-&gt;pl-&gt;mo-&gt;x, bot-&gt;pl-&gt;mo-&gt;y,
        bot-&gt;target-&gt;x, bot-&gt;target-&gt;y);
  }
  else
    bot-&gt;angle = M_Random() &lt;&lt; 24;
}
</t>
<t tx="T1773">
static void Confidence(bot_t * bot)
{
  const player_t *p = bot-&gt;pl;
  const mobj_t *mo = p-&gt;mo;

  if (p-&gt;powers[PW_Invulnerable])
    bot-&gt;confidence = 1;
  else if (mo-&gt;health &lt; mo-&gt;info-&gt;spawnhealth / 3)
    bot-&gt;confidence = -1;
  else if (mo-&gt;health &gt; 3 * mo-&gt;info-&gt;spawnhealth / 4 &amp;&amp; p-&gt;ready_wp &gt;= 0 &amp;&amp;
      p-&gt;weapons[p-&gt;ready_wp].info-&gt;ammo != AM_NoAmmo)
  {
    ammotype_t ammo = p-&gt;weapons[p-&gt;ready_wp].info-&gt;ammo;

    if (p-&gt;ammo[ammo].num &gt; p-&gt;ammo[ammo].max / 2)
      bot-&gt;confidence = 1;
  }
  bot-&gt;confidence = 0;
}
</t>
<t tx="T1774">
static int EvaluateWeapon(player_t *p, int w_num)
{
  playerweapon_t *wp = p-&gt;weapons + w_num;
  weaponinfo_t *weapon;
  attacktype_t *attack;
  float_t value;

  // Don't have this weapon
  if (! wp-&gt;owned)
    return INT_MIN;

  weapon = wp-&gt;info;
  DEV_ASSERT2(weapon);
  
  attack = weapon-&gt;attack;
 
  if (!attack)
    return INT_MIN;

  // Don't have enough ammo
  if (weapon-&gt;ammo != AM_NoAmmo)
  {
    if (p-&gt;ammo[weapon-&gt;ammo].num &lt; weapon-&gt;ammopershot)
      return INT_MIN;
  }

  value = 64 * attack-&gt;damage.nominal;

  switch (attack-&gt;attackstyle)
  {
    case ATK_CLOSECOMBAT:
      if (p-&gt;powers[PW_Berserk])
        value /= 10;
      else
        value /= 20;
      break;
    case ATK_SMARTPROJECTILE:
      value *= 2;
    case ATK_PROJECTILE:
      value += 256 * attack-&gt;atk_mobj-&gt;damage.nominal;
      value *= attack-&gt;atk_mobj-&gt;speed / 20;
      break;
    case ATK_SPAWNER:
      value *= 2;
      break;
    case ATK_TRIPLESPAWNER:
      value *= 6;
      break;
    case ATK_SHOT:
      value *= attack-&gt;count;
      break;

    default:  // do nothing ??
      break;
  }

//  value -= (attack-&gt;accuracy_angle + attack-&gt;x_accuracy_slope + 1) / 2;
  value -= weapon-&gt;ammopershot * 8;
  
  if (w_num == p-&gt;ready_wp)
    value += 2048;
    
  value += (M_Random() - 128) * 16;
  return value;
}
</t>
<t tx="T1775">@ P_RemoveBots

Done at level shutdown, right after all mobjs have been removed.
Erases anything level specific from the bot structs.
@c

void P_RemoveBots(void)
{
}
</t>
<t tx="T1776">
static bot_t *looking_bot;

static boolean_t PTR_BotLook(intercept_t * in)
{
  line_t *li;
  mobj_t *th;

  if (in-&gt;type == INCPT_Line)
  {
    li = in-&gt;d.line;

    if (!(li-&gt;flags &amp; ML_TwoSided))
      return false;  // stop

    // Crosses a two sided line.
    // A two sided line will restrict
    // the possible target ranges.
    // -AJA- 1999/07/19: Gaps are now stored in line_t.

    if (li-&gt;gap_num == 0)
      return false;  // stop

    if (li-&gt;frontsector-&gt;f_h != li-&gt;backsector-&gt;f_h)
    {
      if (abs(li-&gt;frontsector-&gt;f_h - li-&gt;backsector-&gt;f_h) &gt; 24.0)
        return false;
    }

    return true;  // shot continues

  }

  DEV_ASSERT2(in-&gt;type == INCPT_Thing);

  // shoot a thing
  th = in-&gt;d.thing;

  if (th == bot_shooter)
    return true;  // can't shoot self

  if (!(th-&gt;flags &amp; MF_SPECIAL))
    return true;  // has to be able to be shot

#if 0 //!!!! FIXME
  int ammotype;
  ammotype = th-&gt;info-&gt;benefitammo;
  switch (th-&gt;info-&gt;benefittype)
  {
      // -KM- 1998/11/25 New weapon handling
    case WEAPON:  // WEAPON

      if (!bot_shooter-&gt;player-&gt;weapons[th-&gt;info-&gt;benefitweapon].owned)
        break;
      ammotype = bot_shooter-&gt;player-&gt;weapons[th-&gt;info-&gt;benefitweapon].info-&gt;ammo;
    case AMMO_TYPE:
      if (bot_shooter-&gt;player-&gt;ammo[ammotype].num ==
          bot_shooter-&gt;player-&gt;ammo[ammotype].max)
        return true;
      break;
    case KEY_BLUECARD:
      if (bot_shooter-&gt;player-&gt;cards[KEY_BlueCard])
        return true;
      break;
    case KEY_REDCARD:
      if (bot_shooter-&gt;player-&gt;cards[KEY_RedCard])
        return true;
      break;
    case KEY_YELLOWCARD:
      if (bot_shooter-&gt;player-&gt;cards[KEY_YellowCard])
        return true;
      break;
    case KEY_BLUESKULL:
      if (bot_shooter-&gt;player-&gt;cards[KEY_BlueSkull])
        return true;
      break;
    case KEY_REDSKULL:
      if (bot_shooter-&gt;player-&gt;cards[KEY_RedSkull])
        return true;
      break;
    case KEY_YELLOWSKULL:
      if (bot_shooter-&gt;player-&gt;cards[KEY_YellowSkull])
        return true;
      break;
    case POWERUP_ACIDSUIT:
      if (bot_shooter-&gt;player-&gt;powers[PW_AcidSuit] &gt;= th-&gt;info-&gt;benefitamount * TICRATE / 3)
        return true;
      break;
    case POWERUP_ARMOUR:
      if (bot_shooter-&gt;player-&gt;armourpoints &gt;= th-&gt;info-&gt;limit)
        return true;
      break;
    case POWERUP_AUTOMAP:
      return true;
    case POWERUP_BACKPACK:
      break;
    case POWERUP_BERSERK:
      if (bot_shooter-&gt;player-&gt;powers[PW_Berserk])
        return true;
      break;

    case POWERUP_HEALTH:
      if (bot_shooter-&gt;health &gt;= th-&gt;info-&gt;limit)
        return true;
      break;

    case POWERUP_HEALTHARMOUR:
      if ((bot_shooter-&gt;health &gt;= th-&gt;info-&gt;limit) &amp;&amp;
          (bot_shooter-&gt;player-&gt;armourpoints &gt;= th-&gt;info-&gt;limit))
        return true;
      break;

    case POWERUP_INVULNERABLE:
      break;

    case POWERUP_JETPACK:
      if (bot_shooter-&gt;player-&gt;powers[PW_Jetpack] &gt;= th-&gt;info-&gt;benefitamount * TICRATE / 3)
        return true;
      break;

    case POWERUP_LIGHTGOGGLES:
      if (bot_shooter-&gt;player-&gt;powers[PW_Infrared] &gt;= th-&gt;info-&gt;benefitamount * TICRATE / 3)
        return true;
      break;

    case POWERUP_NIGHTVISION:
      if (bot_shooter-&gt;player-&gt;powers[PW_NightVision] &gt;= th-&gt;info-&gt;benefitamount * TICRATE / 3)
        return true;
      break;

    case POWERUP_PARTINVIS:
      if (bot_shooter-&gt;player-&gt;powers[PW_PartInvis] &gt;= th-&gt;info-&gt;benefitamount * TICRATE / 3)
        return true;
      break;

  }
#endif

  linetarget = th;

  return false;  // don't go any farther
}
</t>
<t tx="T1777">@ Finds items for the bot to get.
@c

static mobj_t *LookForStuff(bot_t *bot, angle_t angle)
{
  float_t x2;
  float_t y2;

  bot_shooter = bot-&gt;pl-&gt;mo;
  looking_bot = bot;

  x2 = bot-&gt;pl-&gt;mo-&gt;x + 1024 * M_Cos(angle);
  y2 = bot-&gt;pl-&gt;mo-&gt;y + 1024 * M_Sin(angle);

  linetarget = NULL;
  bot_atkrange = 1024.0;

  P_PathTraverse(bot-&gt;pl-&gt;mo-&gt;x, bot-&gt;pl-&gt;mo-&gt;y, x2, y2, 
      PT_ADDLINES | PT_ADDTHINGS, PTR_BotLook);

  looking_bot = NULL;

  return linetarget;
}
</t>
<t tx="T1778">
static void MoveBot(bot_t *bot, angle_t angle)
{
  bot-&gt;cmd.followtype = FOLLOW_DIR;
  bot-&gt;cmd.followobj.dir.angle = angle;
  bot-&gt;cmd.followobj.dir.distance = 1024;
}
</t>
<t tx="T1779">@ Based on P_LookForTargets from p_enemy.c
@c

static boolean_t LookForBotTargets(bot_t *bot)
{
  mobj_t *object = bot-&gt;pl-&gt;mo;
  mobj_t *currmobj;

  for (currmobj = mobjlisthead; currmobj; currmobj = currmobj-&gt;next)
  {
    if ((currmobj-&gt;side &amp; object-&gt;side) &amp;&amp; !object-&gt;supportobj)
    {
      if (currmobj-&gt;supportobj != object &amp;&amp; P_CheckSight(object, currmobj))
      {
        bot-&gt;supportobj = currmobj;
        return true;
      }
    }
    // The following must be true to justify that you attack a target:
    // 1. The target may not be yourself or your support obj.
    // 2. The target must either want to attack you, or be on a different side
    // 3. The target may not have the same supportobj as you.
    // 4. The target's type must be different from your, if you aren't disloyal.
    // 5. You must be able to see and shoot the target.
    if ((((currmobj-&gt;target == object-&gt;supportobj || currmobj-&gt;target == object)
                &amp;&amp; currmobj-&gt;target)
            || (object-&gt;side &amp;&amp; !(currmobj-&gt;side &amp; object-&gt;side)))
        &amp;&amp; ((currmobj != object) &amp;&amp;
            (currmobj != object-&gt;supportobj) &amp;&amp;
            (object-&gt;info != currmobj-&gt;info || (object-&gt;extendedflags &amp; EF_DISLOYALTYPE)) &amp;&amp;
            ((object-&gt;supportobj == NULL) || object-&gt;supportobj != currmobj-&gt;supportobj)))
    {
      if ((currmobj-&gt;flags &amp; MF_SHOOTABLE) &amp;&amp; P_CheckSight(object, currmobj))
      {
        bot-&gt;target = currmobj;
        return true;
      }
    }
  }

  return false;
}
</t>
<t tx="T1780">
static void BotThink(bot_t * bot)
{
  boolean_t move_ok;
  boolean_t seetarget = false;
  int best;
  int best_val = INT_MIN;
  unsigned int i, j;

  DEV_ASSERT2(bot-&gt;pl);
  DEV_ASSERT2(bot-&gt;pl-&gt;mo);

  bot-&gt;target = bot-&gt;pl-&gt;mo-&gt;target;

  best = bot-&gt;pl-&gt;ready_wp;
  
  move_ok = P_ApproxDistance(bot-&gt;pl-&gt;mo-&gt;mom.x, bot-&gt;pl-&gt;mo-&gt;mom.y) &gt; STOPSPEED;
  if (bot-&gt;pl-&gt;health &lt;= 0)
  {
    // Dead. Respawn.
    bot-&gt;cmd.use = true;
    return;
  }

  // Check if we can see the target
  if (bot-&gt;target)
    seetarget = P_CheckSight(bot-&gt;pl-&gt;mo, bot-&gt;target);

  bot-&gt;threshold--;
  bot-&gt;movecount--;

  // Select a suitable weapon
  if (bot-&gt;confidence &lt;= 0 &amp;&amp; (bot-&gt;threshold &lt; 0 || bot-&gt;movecount &lt; 0))
  {
    for (i=0; i &lt; MAXWEAPONS; i++)
    {
      j = EvaluateWeapon((player_t*)bot-&gt;pl, i);

      if (j &gt; (unsigned int)best_val)
      {
        best_val = (int)j;
        best = i;
      }
    }

    if (best != bot-&gt;pl-&gt;ready_wp)
      bot-&gt;cmd.new_weapon = best;
  }

  // Look for enemies
  // If we aren't confident gather more than hunt.
  if (!seetarget &amp;&amp; bot-&gt;confidence &gt;= 0)
  {
    if (bot-&gt;threshold &lt; 0)
    {
      LookForBotTargets(bot);
      if (bot-&gt;target)
        bot-&gt;threshold = M_Random() &amp; 31;
    }
  }

  // Can't see a target || don't have a suitable weapon to take it out with?
  if (!seetarget)
  {
    mobj_t *newtarget = NULL;

    if (bot-&gt;threshold &lt; 0)
    {
      angle_t search = ANG180;

      // If we are confident, hunt more than gather.
      if (bot-&gt;confidence == 0)
        search = ANG90;
      else if (bot-&gt;confidence &gt; 0)
        search = ANG45 / 2;

      // Find some stuff!
      for (i = (search / (5 * TICRATE)) * (leveltime % TICRATE); i &lt; search; i += search / 5)
      {
        newtarget = LookForStuff(bot, bot-&gt;angle + i);

        if (!newtarget)
          newtarget = LookForStuff(bot, bot-&gt;angle - i);

        if (newtarget)
        {
          bot-&gt;target = newtarget;
          P_MobjSetTarget(bot-&gt;pl-&gt;mo, newtarget); // Fixme
          bot-&gt;threshold = M_Random() &amp; 31;
          seetarget = true;
          break;
        }
      }
    }
  }

  Confidence(bot);

  if (bot-&gt;target)
  {
    // Got a special (item) target?
    if (bot-&gt;target-&gt;flags &amp; MF_SPECIAL)
    {
      if ((bot-&gt;pl-&gt;mo-&gt;flags &amp; MF_JUSTPICKEDUP))
      {
        // Just got the item.
        bot-&gt;target = NULL;
      }
      else if (bot-&gt;movecount &lt; 0)
      {
        // Move in the direction of the item.
        bot-&gt;angle = R_PointToAngle(bot-&gt;pl-&gt;mo-&gt;x, bot-&gt;pl-&gt;mo-&gt;y,
            bot-&gt;target-&gt;x, bot-&gt;target-&gt;y);

        bot-&gt;movecount = (M_Random() &amp; 15) * 16;
      }

      // If there is a wall or something in the way, pick a new direction.
      if (!move_ok)
        NewBotChaseDir(bot); // fixme: check out

      // Move the bot.
      MoveBot(bot, bot-&gt;angle);
      return;
    }

    // Target can be killed.
    if (bot-&gt;target-&gt;flags &amp; MF_SHOOTABLE)
    {
      // Can see a target,
      if (seetarget)
      {
        // So face it,
        bot-&gt;angle = R_PointToAngle(bot-&gt;pl-&gt;mo-&gt;x, bot-&gt;pl-&gt;mo-&gt;y,
            bot-&gt;target-&gt;x, bot-&gt;target-&gt;y);
        bot-&gt;cmd.facetype = FACE_MOBJ;
        bot-&gt;cmd.faceobj.mo = bot-&gt;target;
        // Shoot it,
        bot-&gt;cmd.attack = true;
        // strafe it.
        MoveBot(bot, bot-&gt;angle + (bot-&gt;strafedir ? ANG90 : -ANG90));
        if (bot-&gt;movecount &lt; 0)
        {
          bot-&gt;movecount = M_Random() &amp; 63;
          bot-&gt;strafedir = M_Random() &amp; 1;
        }
      }
      else
        MoveBot(bot, bot-&gt;angle);
  
      // chase towards player
      if (bot-&gt;movecount &lt; 0 || !move_ok)
      {
        NewBotChaseDir(bot);
        if (!move_ok)
          bot-&gt;strafedir = M_Random() &amp; 1;
      }
      return;
    }
  }

  // Wander around.
  MoveBot(bot, bot-&gt;angle);

  if (!move_ok || (bot-&gt;target &amp;&amp; bot-&gt;target-&gt;health &lt;= 0)
      || bot-&gt;movecount &lt; 0)
  {
    bot-&gt;target = NULL;
    P_MobjSetTarget(bot-&gt;pl-&gt;mo, NULL);
    NewBotChaseDir(bot);
    bot-&gt;strafedir = M_Random() &amp; 1;
  }
}
</t>
<t tx="T1781">
void BOT_DMSpawn(void)
{
#if 0
  int i, j;
  int selections;
  mobj_t *bot;
  const mobjinfo_t *info;

  selections = deathmatch_p - deathmatchstarts;
  if (selections &lt; 4)
    I_Warning("Only %i deathmatch spots, 4 required\n", selections);

  info = DDF_MobjLookupPlayer(-2);

  for (j = 0; j &lt; selections; j++)
  {
    i = M_Random() % selections;
    bot = P_MobjCreateObject(deathmatchstarts[i].x,
        deathmatchstarts[i].y, ONFLOORZ, info);

    if (P_CheckAbsPosition(bot, bot-&gt;x, bot-&gt;y, bot-&gt;z))
    {
      P_MobjCreateObject(bot-&gt;x, bot-&gt;y, bot-&gt;z, info-&gt;respawneffect);
      bot-&gt;side = M_Random() &amp; 31;
      bot-&gt;side = 1 &lt;&lt; bot-&gt;side;
      return;
    }
    P_RemoveMobj(bot);
  }
#endif
}
</t>
<t tx="T1782">@ P_BotCreate

Converts the player (which should be empty, i.e. neither a network
or console player) to a bot.
@c

void P_BotCreate(player_t *p)
{
  bot_t *bot;
  
  p-&gt;thinker = P_BotPlayerThinker;
  P_AddPlayerToGame(p);

  bot = Z_ClearNew(bot_t, 1);
  p-&gt;data = (void *)bot;

  bot-&gt;pl = p;

  bot-&gt;next = bots;
  bots = bot;
}
</t>
<t tx="T1783">@ Reads the botcmd_t, converts it to ticcmd_t and stores the result in dest.
@c

static void ConvertToTiccmd(bot_t *bot, ticcmd_t *dest, botcmd_t *src)
{
  float_t s,d,x,y;
  angle_t a, new_angle;

  dest-&gt;buttons = dest-&gt;extbuttons = 0;
  if (src-&gt;attack)
    dest-&gt;buttons |= BT_ATTACK;
  if (src-&gt;second_attack)
    dest-&gt;extbuttons |= EBT_SECONDATK;
  if (src-&gt;use)
    dest-&gt;buttons |= BT_USE;
  if (src-&gt;jump)
    dest-&gt;extbuttons |= EBT_JUMP;
  if (src-&gt;new_weapon != -1)
    dest-&gt;buttons |= (src-&gt;new_weapon &lt;&lt; BT_WEAPONSHIFT) &amp; BT_WEAPONMASK;

  switch (src-&gt;facetype)
  {
    case FACE_MOBJ:
      x = src-&gt;faceobj.mo-&gt;x - bot-&gt;pl-&gt;mo-&gt;x;
      y = src-&gt;faceobj.mo-&gt;y - bot-&gt;pl-&gt;mo-&gt;y;
      new_angle = R_PointToAngle(bot-&gt;pl-&gt;mo-&gt;x, bot-&gt;pl-&gt;mo-&gt;y, src-&gt;faceobj.mo-&gt;x, src-&gt;faceobj.mo-&gt;y);
      s = sqrt(x * x + y * y);
      if (s &lt; 0.1)
        s = 0.1;
      s = (src-&gt;faceobj.mo-&gt;z - bot-&gt;pl-&gt;mo-&gt;z) / s;
    break;
    case FACE_XYZ:
      x = src-&gt;faceobj.xyz.x - bot-&gt;pl-&gt;mo-&gt;x;
      y = src-&gt;faceobj.xyz.y - bot-&gt;pl-&gt;mo-&gt;y;
      new_angle = R_PointToAngle(bot-&gt;pl-&gt;mo-&gt;x, bot-&gt;pl-&gt;mo-&gt;y, src-&gt;faceobj.xyz.x, src-&gt;faceobj.xyz.y);
      s = sqrt(x * x + y * y);
      if (s &lt; 0.1)
        s = 0.1;
      s = (src-&gt;faceobj.xyz.z - bot-&gt;pl-&gt;mo-&gt;z) / s;
    break;
    case FACE_ANGLE:
      new_angle = src-&gt;faceobj.angle.angle;
      s = src-&gt;faceobj.angle.slope;
    default:
      s = 0;
      new_angle = bot-&gt;pl-&gt;mo-&gt;angle;
    break;
  }

  dest-&gt;angleturn = (new_angle - bot-&gt;pl-&gt;mo-&gt;angle) &gt;&gt; 16;
  dest-&gt;vertangle = (signed char) (s * 256);

  if (src-&gt;followtype == FOLLOW_NONE)
  {
    dest-&gt;sidemove = dest-&gt;forwardmove = 0;
  }
  else
  {
    // set a to the angle relative the player.
    switch (src-&gt;followtype)
    {
      case FOLLOW_MOBJ:
        x = src-&gt;followobj.mo-&gt;x - bot-&gt;pl-&gt;mo-&gt;x;
        y = src-&gt;followobj.mo-&gt;y - bot-&gt;pl-&gt;mo-&gt;y;
        d = x * x + y * y;
        a = R_PointToAngle(src-&gt;followobj.mo-&gt;x, src-&gt;followobj.mo-&gt;y,
            bot-&gt;pl-&gt;mo-&gt;x, bot-&gt;pl-&gt;mo-&gt;y) - new_angle;
      break;
      
      case FOLLOW_XY:
        x = src-&gt;followobj.xyz.x - bot-&gt;pl-&gt;mo-&gt;x;
        y = src-&gt;followobj.xyz.y - bot-&gt;pl-&gt;mo-&gt;y;
        d = x * x + y * y;
        a = R_PointToAngle(src-&gt;followobj.xyz.x, src-&gt;followobj.xyz.y,
            bot-&gt;pl-&gt;mo-&gt;x, bot-&gt;pl-&gt;mo-&gt;y) - new_angle;
      break;
      
      case FOLLOW_DIR:
        d = src-&gt;followobj.dir.distance;
        a = src-&gt;followobj.dir.angle - new_angle;
        d *= d;
      break;

      default:
        d = a = 0;
      break;
    }

    // -ES- Fixme: Improve this code. Take momx and momy into consideration.

    // d is squared distance. Don't move if we are very close.
    if (d &lt; 64)
    {
      dest-&gt;sidemove = dest-&gt;forwardmove = 0;
    }
    else
    {
      // if we don't have to face a specific object, diagonal strafe.
      if (src-&gt;facetype == FACE_NONE)
      {
        DEV_ASSERT2(dest-&gt;angleturn == 0);
        dest-&gt;angleturn = (a - ANG45) &gt;&gt; 16;
        a = ANG45;
      }

      // decide direction
      if ((a + ANG45) % ANG180 &lt; ANG90)
      {
        if (a + ANG45 &lt; ANG90)
        {
          // forward
          dest-&gt;forwardmove = 0x32;
        }
        else
        {
          // backward
          dest-&gt;forwardmove = -0x32;
        }
        dest-&gt;sidemove = dest-&gt;forwardmove * M_Tan(a);
      }
      else
      {
        if (a - ANG45 &lt; ANG90)
        {
          // left
          dest-&gt;sidemove = 0x32;
        }
        else
        {
          // right
          dest-&gt;sidemove = -0x32;
        }
        dest-&gt;forwardmove = dest-&gt;sidemove * M_Tan(a - ANG90);
      }
    }
  }

// L_WriteDebug("BOT %d  thr %d  mv %d  conf %d  ftype %d\n",
// bot-&gt;pl-&gt;pnum+1, bot-&gt;threshold, bot-&gt;movecount,
// bot-&gt;confidence, bot-&gt;cmd.followtype);

// L_WriteDebug("  CMD: fwd=%d side=%d\n", dest-&gt;forwardmove, dest-&gt;sidemove);
}
</t>
<t tx="T1784">
static void DoThink(bot_t *bot)
{
  BotThink(bot);
}
</t>
<t tx="T1785">
void P_BotPlayerThinker(const player_t *p, void *data, ticcmd_t *cmd)
{
  bot_t *bot = (bot_t *)data;

  if (gamestate != GS_LEVEL)
    return;

  // recalculate , but only if we have a new gametime
  if (bot-&gt;prev_gametime != gametime)
  {
    bot-&gt;prev_gametime = gametime;

    Z_Clear(&amp;bot-&gt;cmd, botcmd_t, 1);
    bot-&gt;cmd.new_weapon = -1;

    DoThink(bot);

    ConvertToTiccmd(bot, &amp;bot-&gt;prev_cmd, &amp;bot-&gt;cmd);
  }
  else
  {
    // Don't turn around more: If we decided to switch angle the first tic,
    // then that's the angle we prefer, and it's bad to turn around more.
    bot-&gt;prev_cmd.angleturn = 0;
    bot-&gt;prev_cmd.vertangle = 0;
  }
  
  *cmd = bot-&gt;prev_cmd;
}
</t>
<t tx="T1786">@ignore
@language c

// Creature Action Code

// -KM- 1998/09/27 Sounds.ddf stuff
//
// -AJA- 1999/07/21: Replaced some non-critical P_Randoms with M_Random,
//       and removed some X_Random()-X_Random() things.

&lt;&lt; p_enemy #includes &gt;&gt;
&lt;&lt; p_enemy declarations &gt;&gt;
@others
</t>
<t tx="T1787">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "g_game.h"
#include "m_random.h"
#include "p_action.h"
#include "p_local.h"
#include "r_state.h"
#include "rad_trig.h"
#include "s_sound.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1788">
dirtype_t opposite[] =
{
    DI_WEST,
    DI_SOUTHWEST,
    DI_SOUTH,
    DI_SOUTHEAST,
    DI_EAST,
    DI_NORTHEAST,
    DI_NORTH,
    DI_NORTHWEST,
    DI_NODIR
};

dirtype_t diags[] =
{
    DI_NORTHWEST,
    DI_NORTHEAST,
    DI_SOUTHWEST,
    DI_SOUTHEAST
};

// sqrt(2) / 2: The diagonal speed of creatures
#define SQ2 0.7071067812

float_t xspeed[8] = {1.0, SQ2, 0, -SQ2, -1.0, -SQ2, 0, SQ2};
float_t yspeed[8] = {0, SQ2, 1.0, SQ2, 0, -SQ2, -1.0, -SQ2};

#undef SQ2

//
//  ENEMY THINKING
//
// Enemies are allways spawned
// with targetplayer = -1, threshold = 0
// Most monsters are spawned unaware of all players,
// but some can be made preaware
//

//
// Called by P_NoiseAlert.
// Recursively traverse adjacent sectors,
// sound blocking lines cut off traversal.
//

static int noise_player;
</t>
<t tx="T1789">
static void RecursiveSound(sector_t * sec, int soundblocks)
{
  int i;
  line_t *check;
  sector_t *other;

  // has the sound flooded this sector
  if (sec-&gt;validcount == validcount &amp;&amp; sec-&gt;soundtraversed &lt;= soundblocks + 1)
    return;

  // wake up all monsters in this sector
  sec-&gt;validcount = validcount;
  sec-&gt;soundtraversed = soundblocks + 1;
  sec-&gt;sound_player = noise_player;

  for (i = 0; i &lt; sec-&gt;linecount; i++)
  {
    check = sec-&gt;lines[i];

    if (!(check-&gt;flags &amp; ML_TwoSided))
      continue;

    // -AJA- 1999/07/19: Gaps are now stored in line_t.
    if (check-&gt;gap_num == 0)
      continue;  // closed door

    // -AJA- 2001/11/11: handle closed Sliding doors
    if (check-&gt;special &amp;&amp; check-&gt;special-&gt;s.type != SLIDE_None &amp;&amp;
        ! check-&gt;special-&gt;s.see_through &amp;&amp; ! check-&gt;slider_move)
    {
      continue;
    }
    
    if (check-&gt;frontsector == sec)
      other = check-&gt;backsector;
    else
      other = check-&gt;frontsector;

    if (check-&gt;flags &amp; ML_SoundBlock)
    {
      if (!soundblocks)
        RecursiveSound(other, 1);
    }
    else
    {
      RecursiveSound(other, soundblocks);
    }
  }
}
</t>
<t tx="T1790">@ P_NoiseAlert
@c

void P_NoiseAlert(player_t *p)
{
  noise_player = p-&gt;pnum;
  validcount++;
  RecursiveSound(p-&gt;mo-&gt;subsector-&gt;sector, 0);
}
</t>
<t tx="T1791">@ P_CheckMeleeRange
@c

boolean_t P_CheckMeleeRange(mobj_t * actor)
{
  mobj_t *pl;
  float_t dist;

  if (!actor-&gt;target)
    return false;

  pl = actor-&gt;target;
  dist = P_ApproxDistance(pl-&gt;x - actor-&gt;x, pl-&gt;y - actor-&gt;y);

  if (dist &gt;= MELEERANGE - 20.0 + pl-&gt;info-&gt;radius)
    return false;

  if (!P_CheckSight(actor, actor-&gt;target))
    return false;

  return true;
}
</t>
<t tx="T1792">@ P_Move

Move in the current direction,
returns false if the move is blocked.
@c

boolean_t P_Move(mobj_t * actor, boolean_t path)
{
  float_t tryx;
  float_t tryy;

  //
  // warning: 'catch', 'throw', and 'try'
  // are all C++ reserved words
  //
  boolean_t try_ok;
  boolean_t any_used, block_used;

  if (path)
  {
    tryx = actor-&gt;x + actor-&gt;speed * M_Cos(actor-&gt;angle);
    tryy = actor-&gt;y + actor-&gt;speed * M_Sin(actor-&gt;angle);
  }
  else
  {
    if (actor-&gt;movedir == DI_NODIR)
      return false;

    if ((unsigned)actor-&gt;movedir &gt;= 8)
      I_Error("Weird actor-&gt;movedir!");

    tryx = actor-&gt;x + actor-&gt;speed * xspeed[actor-&gt;movedir];
    tryy = actor-&gt;y + actor-&gt;speed * yspeed[actor-&gt;movedir];
  }

  try_ok = P_TryMove(actor, tryx, tryy);

  if (!try_ok)
  {
    line_t **hits;
    int i;

    // open any specials
    if (actor-&gt;flags &amp; MF_FLOAT &amp;&amp; floatok)
    {
      // must adjust height
      if (actor-&gt;z &lt; float_destz)
        actor-&gt;z += actor-&gt;info-&gt;float_speed;
      else
        actor-&gt;z -= actor-&gt;info-&gt;float_speed;

      actor-&gt;flags |= MF_INFLOAT;
      return true;
    }

    if (!numspechit)
      return false;

    actor-&gt;movedir = DI_NODIR;

    // -AJA- 1999/09/10: As Lee Killough points out, this is where
    //       monsters can get stuck in doortracks.  We follow Lee's
    //       method: return true 90% of the time if the blocking line
    //       was the one activated, or false 90% of the time if there
    //       was some other line activated.
    
    any_used = block_used = false;

    // -ES- 2000/02/05 spechit could be changed inside the loop
    hits = I_TmpMalloc(numspechit * sizeof(line_t *));
    Z_MoveData(hits, spechit, line_t *, numspechit);
    i = numspechit;
    
    Z_SetArraySize(&amp;spechit_a, numspechit = 0);

    while (i)
    {
      line_t *ld = hits[--i];

      if (P_UseSpecialLine(actor, ld, 0, INT_MIN, INT_MAX))
      {
        any_used = true;

        if (ld == blockline)
          block_used = true;
      }
    }
    I_TmpFree(hits);

    return any_used &amp;&amp; (P_Random() &lt; 230 ? block_used : !block_used);
  }
  else
  {
    actor-&gt;flags &amp;= ~MF_INFLOAT;
  }

  if (!(actor-&gt;flags &amp; MF_FLOAT) &amp;&amp;
      !(actor-&gt;extendedflags &amp; EF_GRAVFALL))
    actor-&gt;z = actor-&gt;floorz;

  return true;
}
</t>
<t tx="T1793">@ TryWalk

Attempts to move actor on
in its current (ob-&gt;moveangle) direction.
If blocked by either a wall or an actor
returns FALSE
If move is either clear or blocked only by a door,
returns TRUE and sets...
If a door is in the way,
an OpenDoor call is made to start it opening.
@c

static boolean_t TryWalk(mobj_t * actor)
{
  if (!P_Move(actor, false))
    return false;

  actor-&gt;movecount = P_Random() &amp; 15;
  return true;
}
</t>
<t tx="T1794">@ -ACB- 1998/09/06 actor is now an object; different movement choices.
@c

void P_NewChaseDir(mobj_t * object)
{
  float_t deltax;
  float_t deltay;
  dirtype_t tdir;

  dirtype_t d[3];
  dirtype_t olddir;
  dirtype_t turnaround;

  olddir = object-&gt;movedir;
  turnaround = opposite[olddir];

  //
  // Movement choice: Previously this was calculation to find
  // the distance between object and target: if the object had
  // no target, a fatal error was returned. However it is now
  // possible to have movement without a target. if the object
  // has a target, go for that; else if it has a supporting
  // object aim to go within supporting distance of that; the
  // remaining option is to walk aimlessly: the target destination
  // is always 128 in the old movement direction, think
  // of it like the donkey and the carrot sketch: the donkey will
  // move towards the carrot, but since the carrot is always a
  // set distance away from the donkey, the rather stupid mammal
  // will spend eternity trying to get the carrot and will walk
  // forever.
  //
  // -ACB- 1998/09/06

  if (object-&gt;target)
  {
    deltax = object-&gt;target-&gt;x - object-&gt;x;
    deltay = object-&gt;target-&gt;y - object-&gt;y;
  }
  else if (object-&gt;supportobj)
  {
    // not too close
    deltax = (object-&gt;supportobj-&gt;x - object-&gt;x) - (object-&gt;supportobj-&gt;radius * 4);
    deltay = (object-&gt;supportobj-&gt;y - object-&gt;y) - (object-&gt;supportobj-&gt;radius * 4);
  }
  else
  {
    deltax = 128 * xspeed[olddir];
    deltay = 128 * yspeed[olddir];
  }

  if (deltax &gt; 10)
    d[1] = DI_EAST;
  else if (deltax &lt; -10)
    d[1] = DI_WEST;
  else
    d[1] = DI_NODIR;

  if (deltay &lt; -10)
    d[2] = DI_SOUTH;
  else if (deltay &gt; 10)
    d[2] = DI_NORTH;
  else
    d[2] = DI_NODIR;

  // try direct route
  if (d[1] != DI_NODIR &amp;&amp; d[2] != DI_NODIR)
  {
    object-&gt;movedir = diags[((deltay &lt; 0) &lt;&lt; 1) + (deltax &gt; 0)];
    if (object-&gt;movedir != turnaround &amp;&amp; TryWalk(object))
      return;
  }

  // try other directions
  if (P_Random() &gt; 200 || fabs(deltay) &gt; fabs(deltax))
  {
    tdir = d[1];
    d[1] = d[2];
    d[2] = tdir;
  }

  if (d[1] == turnaround)
    d[1] = DI_NODIR;

  if (d[2] == turnaround)
    d[2] = DI_NODIR;

  if (d[1] != DI_NODIR)
  {
    object-&gt;movedir = d[1];
    if (TryWalk(object))
    {
      // either moved forward or attacked
      return;
    }
  }

  if (d[2] != DI_NODIR)
  {
    object-&gt;movedir = d[2];

    if (TryWalk(object))
      return;
  }

  // there is no direct path to the player,
  // so pick another direction.
  if (olddir != DI_NODIR)
  {
    object-&gt;movedir = olddir;

    if (TryWalk(object))
      return;
  }

  // randomly determine direction of search
  if (P_Random() &amp; 1)
  {
    for (tdir = DI_EAST; tdir &lt;= DI_SOUTHEAST; tdir++)
    {
      if (tdir != turnaround)
      {
        object-&gt;movedir = tdir;

        if (TryWalk(object))
          return;
      }
    }
  }
  else
  {
    for (tdir = DI_SOUTHEAST; tdir != (dirtype_t)(DI_EAST - 1); tdir--)
    {
      if (tdir != turnaround)
      {
        object-&gt;movedir = tdir;

        if (TryWalk(object))
          return;
      }
    }
  }

  if (turnaround != DI_NODIR)
  {
    object-&gt;movedir = turnaround;
    if (TryWalk(object))
      return;
  }

  // cannot move
  object-&gt;movedir = DI_NODIR;
}
</t>
<t tx="T1795">@ P_LookForPlayers

Range is angle range on either side of eyes, 90 degrees for normal
view, 180 degrees for total sight in all dirs.

Returns true if a player is targeted.
@c

boolean_t P_LookForPlayers(mobj_t * actor, angle_t range)
{
  int c;
  int stop;
  player_t *player;
  angle_t an;
  float_t dist;

  c = 0;
  stop = (actor-&gt;lastlook - 1) % MAXPLAYERS;

  for (;; actor-&gt;lastlook = (actor-&gt;lastlook + 1) % MAXPLAYERS)
  {
    player = playerlookup[actor-&gt;lastlook];

    if (!player || !player-&gt;in_game)
      continue;

    // done looking ?
    if (c++ == 2 || actor-&gt;lastlook == stop)
      break;

    // dead ?
    if (player-&gt;health &lt;= 0)
      continue;

    // out of sight ?
    if (!P_CheckSight(actor, player-&gt;mo))
      continue;

    if (range &lt; ANG180)
    {
      an = R_PointToAngle(actor-&gt;x, actor-&gt;y, player-&gt;mo-&gt;x,
          player-&gt;mo-&gt;y) - actor-&gt;angle;

      if (range &lt;= an &amp;&amp; an &lt;= (range * -1))
      {
        // behind back.
        // if real close, react anyway
        dist = P_ApproxDistance(player-&gt;mo-&gt;x - actor-&gt;x,
            player-&gt;mo-&gt;y - actor-&gt;y);

        if (dist &gt; MELEERANGE)
          continue;
      }
    }

    P_MobjSetTarget(actor, player-&gt;mo);
    return true;
  }

  return false;
}
</t>
<t tx="T1796">@ BOSS-BRAIN HANDLING
@c

shoot_spot_info_t brain_spots = { 0, NULL };

//
// P_LookForShootSpots
//
// -AJA- Savegames: we assume that the spit-spot objects never
//       disappear, or new ones appear.  After all, they have to be
//       there to be the target of the cubes.  This means we don't
//       need to save anything: the set of shoot-spots will be
//       regenerated after the loadgame when the BrainShooter next
//       tries to shoot a cube.
// 
void P_LookForShootSpots(const mobjinfo_t *spot_type)
{
  int i;
  mobj_t *cur;

  brain_spots.number = 0;

  // count them
  for (cur=mobjlisthead; cur != NULL; cur=cur-&gt;next)
  {
    if (cur-&gt;info == spot_type)
      brain_spots.number++;
  }

  if (brain_spots.number == 0)
    I_Error("No [%s] objects found for BossBrain shooter.\n",
        spot_type-&gt;ddf.name);
   
  // create the spots
  brain_spots.targets = Z_New(mobj_t *, brain_spots.number);

  for (cur=mobjlisthead, i=0; cur != NULL; cur=cur-&gt;next)
  {
    if (cur-&gt;info == spot_type)
      brain_spots.targets[i++] = cur;
  }

  DEV_ASSERT(i == brain_spots.number, 
      ("P_LookForShootSpots miscount: %d != %d", i, brain_spots.number));
}
</t>
<t tx="T1797">@ P_FreeShootSpots
@c

void P_FreeShootSpots(void)
{
  if (brain_spots.number == 0)
    return;

  DEV_ASSERT2(brain_spots.targets);

  Z_Free(brain_spots.targets);

  brain_spots.number = 0;
  brain_spots.targets = NULL;
}
</t>
<t tx="T1798">@ SpawnDeathMissile

-AJA- 1999/09/14: written.
@c

static void SpawnDeathMissile(mobj_t *source, float_t x, float_t y, float_t z)
{
  const mobjinfo_t *info;
  mobj_t *th;

  info = DDF_MobjLookup("BRAIN DEATH MISSILE");

  th = P_MobjCreateObject(x, y, z, info);
  if (th-&gt;info-&gt;seesound)
    S_StartSound(th, th-&gt;info-&gt;seesound);

  P_MobjSetRealSource(th, source);

  th-&gt;mom.x = (x - source-&gt;x) / 50.0;
  th-&gt;mom.y = -0.25;
  th-&gt;mom.z = (z - source-&gt;z) / 50.0;

  th-&gt;tics -= M_Random() &amp; 7;

  if (th-&gt;tics &lt; 1)
    th-&gt;tics = 1;
}
</t>
<t tx="T1799">@ A_BrainScream: The brain and his pain...
@c

void A_BrainScream(mobj_t * bossbrain)
{
  float_t x, y, z;
  float_t min_x, max_x;

  min_x = bossbrain-&gt;x - 280.0;
  max_x = bossbrain-&gt;x + 280.0;

  for (x = min_x; x &lt; max_x; x += 4)
  {
    y = bossbrain-&gt;y - 320.0;
    z = bossbrain-&gt;z + (P_Random() - 180.0) * 2.0;

    SpawnDeathMissile(bossbrain, x, y, z);
  }

  if (bossbrain-&gt;info-&gt;deathsound)
    S_StartSound(NULL, bossbrain-&gt;info-&gt;deathsound);
}
</t>
<t tx="T1800">
void A_BrainMissileExplode(mobj_t * mo)
{
  float_t x, y, z;

  if (! mo-&gt;source)
    return;

  x = mo-&gt;source-&gt;x + (P_Random() - 128.0) * 4.0;
  y = mo-&gt;source-&gt;y - 320;
  z = mo-&gt;source-&gt;z + (P_Random() - 180.0) * 2.0;

  SpawnDeathMissile(mo-&gt;source, x, y, z);
}
</t>
<t tx="T1801">
void A_BrainDie(mobj_t * bossbrain)
{
  G_ExitLevel(TICRATE);
}
</t>
<t tx="T1802">
void A_BrainSpit(mobj_t * shooter)
{
  static int easy = 0;

  // when skill is easy, only fire every second cube.
  
  easy ^= 1;

  if (gameskill &lt;= sk_easy &amp;&amp; (!easy))
    return;

  // shoot out a cube
  P_ActRangeAttack(shooter);
}
</t>
<t tx="T1803">

void A_CubeSpawn(mobj_t * cube)
{
  mobj_t *targ;
  mobj_t *newmobj;
  const mobjinfo_t *type;
  int r;

  targ = cube-&gt;target;

  // Randomly select monster to spawn.
  r = P_Random();

  // Probability distribution (kind of :)),
  // decreasing likelihood.
  if (r &lt; 50)
    type = DDF_MobjLookup("IMP");
  else if (r &lt; 90)
    type = DDF_MobjLookup("DEMON");
  else if (r &lt; 120)
    type = DDF_MobjLookup("SPECTRE");
  else if (r &lt; 130)
    type = DDF_MobjLookup("PAIN ELEMENTAL");
  else if (r &lt; 160)
    type = DDF_MobjLookup("CACODEMON");
  else if (r &lt; 162)
    type = DDF_MobjLookup("ARCHVILE");
  else if (r &lt; 172)
    type = DDF_MobjLookup("REVENANT");
  else if (r &lt; 192)
    type = DDF_MobjLookup("ARACHNOTRON");
  else if (r &lt; 222)
    type = DDF_MobjLookup("MANCUBUS");
  else if (r &lt; 246)
    type = DDF_MobjLookup("HELL KNIGHT");
  else
    type = DDF_MobjLookup("BARON OF HELL");

  newmobj = P_MobjCreateObject(targ-&gt;x, targ-&gt;y, targ-&gt;z, type);

  if (P_LookForPlayers(newmobj, ANG180))
  {
    if (newmobj-&gt;info-&gt;chase_state)
      P_SetMobjState(newmobj, newmobj-&gt;info-&gt;chase_state);
    else
      P_SetMobjState(newmobj, newmobj-&gt;info-&gt;spawn_state);
  }

  // telefrag anything in this spot
  P_TeleportMove(newmobj, newmobj-&gt;x, newmobj-&gt;y, newmobj-&gt;z);
}
</t>
<t tx="T1804">
void A_PlayerScream(mobj_t * mo)
{
  sfx_t *sound;

  sound = mo-&gt;info-&gt;deathsound;

  if ((mo-&gt;health &lt; -50) &amp;&amp; (W_CheckNumForName("DSPDIEHI") &gt;= 0))
  {
    // if the player dies and unclipped health is &lt; -50%...

    sound = DDF_SfxLookupSound("PDIEHI");
  }

  S_StartSound(mo, sound);
}
</t>
<t tx="T1805">@ignore
@language c

// Interactions (picking up items etc..) Code

&lt;&lt; p_inter #includes &gt;&gt;
@others
</t>
<t tx="T1806">#include "i_defs.h"

#include "am_map.h"
#include "con_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "dstrings.h"
#include "m_random.h"
#include "p_local.h"
#include "s_sound.h"
#include "st_stuff.h"
#include "z_zone.h"
</t>
<t tx="T1807">
#define BONUS_ADD    6
#define BONUS_LIMIT  100

#define DAMAGE_ADD_MIN  3
#define DAMAGE_LIMIT  100

#define GRIN_TIME   (TICRATE * 2)


//
// P_GiveAmmo
//
// Returns false if the ammo can't be picked up at all
//
// -ACB- 1998/06/19 DDF Change: Number passed is the exact amount of ammo given.
// -KM- 1998/11/25 Handles weapon change from priority.
//
static boolean_t GiveAmmo(player_t * player, mobj_t * special,
    benefit_t *be, boolean_t lose_em)
{
  int dropped = (special &amp;&amp; (special-&gt;flags &amp; MF_DROPPED));

  int ammo  = be-&gt;subtype;  
  int num   = floor(be-&gt;amount) / (dropped ? 2 : 1);

  boolean_t change_weap;
  int priority = -100;

  if (ammo == AM_NoAmmo || num &lt;= 0)
    return false;

  if (ammo &lt; 0 || ammo &gt;= NUMAMMO)
    I_Error("GiveAmmo: bad type %i", ammo);

  if (lose_em)
  {
    player-&gt;ammo[ammo].num -= num;
    if (player-&gt;ammo[ammo].num &lt; 0)
      player-&gt;ammo[ammo].num = 0;
    return true;
  }
  
  if (player-&gt;ammo[ammo].num == player-&gt;ammo[ammo].max)
    return false;

  // In Nightmare you need the extra ammo, in "baby" you are given double
  if (special)
  {
    if ((gameskill == sk_baby) || (gameskill == sk_nightmare))
      num &lt;&lt;= 1;
  }

  // if there was some old ammo, we don't need to change weapons 
  change_weap = (player-&gt;ammo[ammo].num == 0);

  player-&gt;ammo[ammo].num += num;

  if (player-&gt;ammo[ammo].num &gt; player-&gt;ammo[ammo].max)
    player-&gt;ammo[ammo].num = player-&gt;ammo[ammo].max;

  if (! change_weap)
    return true;

  // We were down to zero, so select a new weapon.
  // Choose the next highest priority weapon than the current one.
  // Don't override any weapon change already underway.

  P_RefillClips(player);

  if (player-&gt;pending_wp != WPSEL_NoChange)
    return true;

  if (player-&gt;ready_wp &gt;= 0)
    priority = player-&gt;weapons[player-&gt;ready_wp].info-&gt;priority;

  P_SelectNewWeapon(player, priority, ammo);
  return true;
}
</t>
<t tx="T1808">@ GiveAmmoLimit
@c

static boolean_t GiveAmmoLimit(player_t * player, mobj_t * special,
    benefit_t *be, boolean_t lose_em)
{
  int ammo  = be-&gt;subtype;  
  int limit = floor(be-&gt;amount);

  if (ammo == AM_NoAmmo)
    return false;

  if (ammo &lt; 0 || ammo &gt;= NUMAMMO)
    I_Error("GiveAmmoLimit: bad type %i", ammo);

  if ((!lose_em &amp;&amp; limit &lt; player-&gt;ammo[ammo].max) ||
      (lose_em &amp;&amp; limit &gt; player-&gt;ammo[ammo].max))
  {
    return false;
  }

  player-&gt;ammo[ammo].max = limit;
  return true;
}
</t>
<t tx="T1809">@ GiveWeapon

The weapon thing may have a MF_DROPPED flag or'ed in.

-AJA- 2000/03/02: Reworked for new benefit_t stuff.
@c

static boolean_t GiveWeapon(player_t * player, mobj_t * special,
    benefit_t *be, boolean_t lose_em)
{
  weaponinfo_t *info = weaponinfo[be-&gt;subtype];
  int pw_index;

  if (lose_em)
    return P_RemoveWeapon(player, info);

  if (! P_AddWeapon(player, info, &amp;pw_index))
    return false;

  player-&gt;pending_wp = pw_index;

  // be cheeky... :-)
  player-&gt;grin_count = GRIN_TIME;

  return true;
}
</t>
<t tx="T1810">@ GiveHealth

Returns false if not health is not needed,

New Procedure: -ACB- 1998/06/21
@c

static boolean_t GiveHealth(player_t * player, mobj_t * special,
    benefit_t *be, boolean_t lose_em)
{
  if (lose_em)
  {
    P_DamageMobj(player-&gt;mo, special, NULL, be-&gt;amount, NULL);
    return true;
  }

  if (player-&gt;health &gt;= be-&gt;limit)
    return false;

  player-&gt;health += be-&gt;amount;

  if (player-&gt;health &gt; be-&gt;limit)
    player-&gt;health = be-&gt;limit;

  player-&gt;mo-&gt;health = player-&gt;health;

  return true;
}
</t>
<t tx="T1811">@ GiveArmour

Returns false if the new armour would not benefit

-ACB- 1998/06/21
@c

static boolean_t GiveArmour(player_t * player, mobj_t * special,
    benefit_t *be, boolean_t lose_em)
{
  armour_type_e a_class = be-&gt;subtype;
  
  DEV_ASSERT2(0 &lt;= a_class &amp;&amp; a_class &lt; NUMARMOUR);

  if (lose_em)
  {
    player-&gt;armours[a_class] -= be-&gt;amount;
    if (player-&gt;armours[a_class] &lt; 0)
      player-&gt;armours[a_class] = 0;
    return true;
  }

  if (player-&gt;armours[a_class] &gt;= be-&gt;limit)
    return false;

  player-&gt;armours[a_class] += be-&gt;amount;

  if (player-&gt;armours[a_class] &gt; be-&gt;limit)
    player-&gt;armours[a_class] = be-&gt;limit;

  return true;
}
</t>
<t tx="T1812">@ GiveKey
@c

static boolean_t GiveKey(player_t * player, mobj_t * special,
    benefit_t *be, boolean_t lose_em)
{
  keys_e key = be-&gt;subtype;
 
  if (lose_em)
  {
    if (! (player-&gt;cards &amp; key))
      return false;

    player-&gt;cards &amp;= ~key;
  }
  else
  {
    if (player-&gt;cards &amp; key)
      return false;

    player-&gt;cards |= key;
  }

  // -ACB- 1998/06/10 Force redraw of status bar, to update keys.
  stbar_update = true;

  return true;
}
</t>
<t tx="T1813">@ GivePower

DDF Change: duration is now passed as a parameter, for the berserker
the value is the health given, extendedflags also passed.

The code was changes to a switch instead of a series of if's, also
included is the use of limit, which gives a maxmium amount of protection
for this item. -ACB- 1998/06/20
@c

static boolean_t GivePower(player_t * player, mobj_t * special,
    benefit_t *be, boolean_t lose_em)
{ 
  int i;

  // -ACB- 1998/06/20 - calculate duration in seconds
  float_t duration = be-&gt;amount * TICRATE;
  float_t limit    = be-&gt;limit  * TICRATE;

  if (lose_em)
  {
    player-&gt;powers[be-&gt;subtype] -= duration;
    if (player-&gt;powers[be-&gt;subtype] &lt; 0)
      player-&gt;powers[be-&gt;subtype] = 0;
    return true;
  }
 
  if (player-&gt;powers[be-&gt;subtype] &gt;= limit)
    return false;

  player-&gt;powers[be-&gt;subtype] += duration;

  if (player-&gt;powers[be-&gt;subtype] &gt; limit)
    player-&gt;powers[be-&gt;subtype] = limit;

  // special handling for berserk...
  if (be-&gt;subtype == PW_Berserk)
  {
    for (i=0; i &lt; MAXWEAPONS; i++)
    {
      playerweapon_t *pw = &amp;player-&gt;weapons[i];

      // -AJA- FIXME: choose lowest priority close combat.
      if (pw-&gt;owned &amp;&amp; DDF_CompareName(pw-&gt;info-&gt;ddf.name, "FIST") == 0)
      {
        player-&gt;pending_wp = i;
        break;
      }
    }
  }

  // special handling for scuba...
  if (be-&gt;subtype == PW_Scuba)
  {
     player-&gt;air_in_lungs = player-&gt;mo-&gt;info-&gt;lung_capacity;
  }
  
  return true;
}
</t>
<t tx="T1814">@ P_GiveBenefitList

Give all the benefits in the list to the player. `special' is the
special object that all these benefits came from, or NULL if they
came from the initial_benefits list. When `lose_em' is true, the
benefits should be taken away instead. Returns true if _any_
benefit was picked up (or lost), or false if none of them were.
@c

boolean_t P_GiveBenefitList(player_t *player, mobj_t * special, 
    benefit_t *list, boolean_t lose_em)
{
  boolean_t pickup = false;
  // is it a weapon that will stay in old deathmatch?
  boolean_t dm_weapon = false;

  // leave placed weapons forever in old deathmatch mode
  // but only if we haven't already picked it up.
 
#if 0  // FIXME
  // is it a old deathmatch weapon that we have any use for?
  boolean_t dm_needweapon = false;
  if (!lose_em &amp;&amp; netgame &amp;&amp; deathmatch &lt;= 1)
  {
    benefit_t *b;
    for (b = list; b; b=b-&gt;next)
    {
      if (b-&gt;type == BENEFIT_Weapon &amp;&amp; (!(special &amp;&amp; (special-&gt;flags &amp; MF_DROPPED))))
      {
        // it is an "old dm" weapon.
        dm_weapon = true;
        // minor hack: give the weapon, and see if we needed it.
        // in that case, the benefit should be picked up
        if (GiveWeapon(player, special, b))
          dm_needweapon = true;
      }
    }
    if (dm_weapon &amp;&amp; !dm_needweapon)
      // it was a dm weapon, but we already have it, so don't pick it up again.
      return false;
  }
#endif

  for (; list; list=list-&gt;next)
  {
    if (list-&gt;type == BENEFIT_None || list-&gt;amount &lt;= 0.0)
      continue;
    
    switch (list-&gt;type)
    {
      case BENEFIT_Ammo:
        pickup |= GiveAmmo(player, special, list, lose_em);
        break;

      case BENEFIT_AmmoLimit:
        pickup |= GiveAmmoLimit(player, special, list, lose_em);
        break;

      case BENEFIT_Weapon:
        pickup |= GiveWeapon(player, special, list, lose_em);
        break;

      case BENEFIT_Key:
        pickup |= GiveKey(player, special, list, lose_em);
        break;

      case BENEFIT_Health:
        pickup |= GiveHealth(player, special, list, lose_em);
        break;

      case BENEFIT_Armour:
        pickup |= GiveArmour(player, special, list, lose_em);
        break;

      case BENEFIT_Powerup:
        pickup |= GivePower(player, special, list, lose_em);
        break;

      default:
        break;
    }
  }

  if (dm_weapon)
    pickup = false;

  return pickup;
}
</t>
<t tx="T1815">@ P_TouchSpecialThing

-KM- 1999/01/31 Things that give you item bonus are always
picked up. Picked up object is set to death frame instead
of removed so that effects can happen.
@c

void P_TouchSpecialThing(mobj_t * special, mobj_t * toucher)
{
  player_t *player;
  float_t delta;
  sfx_t *sound;
  boolean_t pickup = false;

  delta = special-&gt;z - toucher-&gt;z;

  // out of reach
  if (delta &gt; toucher-&gt;height || delta &lt; -special-&gt;height)
    return;

  player = toucher-&gt;player;

  DEV_ASSERT2(player);

  // Dead thing touching. Can happen with a sliding player corpse.
  if (toucher-&gt;health &lt;= 0)
    return;

  // -KM- 1998/09/27 Sounds.ddf
  sound = special-&gt;info-&gt;activesound;
  toucher-&gt;flags |= MF_JUSTPICKEDUP;

  // First check for lost benefits
  pickup |= P_GiveBenefitList(player, special, 
      special-&gt;info-&gt;lose_benefits, true);
  
  // Run through the list of all pickup benefits...
  pickup |= P_GiveBenefitList(player, special, 
      special-&gt;info-&gt;pickup_benefits, false);

  if (special-&gt;flags &amp; MF_COUNTITEM)
  {
    player-&gt;itemcount++;
    pickup = true;
  }

  if (pickup)
  {
    special-&gt;health = 0;
    P_KillMobj(player-&gt;mo, special, NULL);

    player-&gt;bonuscount += BONUS_ADD;
    if (player-&gt;bonuscount &gt; BONUS_LIMIT)
      player-&gt;bonuscount = BONUS_LIMIT;

    // -AJA- FIXME: OPTIMISE THIS!
    if (special-&gt;info-&gt;pickup_message &amp;&amp;
        DDF_LanguageValidRef(special-&gt;info-&gt;pickup_message))
    {
      CON_PlayerMessage(player, 
          DDF_LanguageLookup(special-&gt;info-&gt;pickup_message));
    }

    if (sound)
      S_StartSound(player-&gt;mo, sound);
  }
}
</t>
<t tx="T1816">@ P_KillMobj

Altered to reflect the fact that the dropped item is a pointer to
mobjinfo_t, uses new procedure: P_MobjCreateObject.

Note: Damtype can be NULL here.

-ACB- 1998/08/01

-AJA- 1999/09/12: Now uses P_SetMobjStateDeferred, since this
routine can be called by TryMove/PIT_CheckRelThing/etc.
@c

void P_KillMobj(mobj_t * source, mobj_t * target, const damage_t *damtype)
{
  const mobjinfo_t *item;
  statenum_t state;
  boolean_t overkill;

  target-&gt;flags &amp;= ~(MF_SPECIAL | MF_SHOOTABLE | MF_FLOAT | 
      MF_SKULLFLY | MF_TOUCHY);
  target-&gt;extendedflags &amp;= ~(EF_BOUNCE | EF_USABLE | EF_CLIMBABLE);

  if (!(target-&gt;extendedflags &amp; EF_NOGRAVKILL))
    target-&gt;flags &amp;= ~MF_NOGRAVITY;

  target-&gt;flags |= MF_CORPSE | MF_DROPOFF;
  target-&gt;height /= 4;

  if (source &amp;&amp; source-&gt;player)
  {
    // count for intermission
    if (target-&gt;flags &amp; MF_COUNTKILL)
      source-&gt;player-&gt;killcount++;

    if (target-&gt;player)
    {
      // Killed a team mate?
      if (target-&gt;side &amp; source-&gt;side)
      {
        source-&gt;player-&gt;frags--;
        source-&gt;player-&gt;totalfrags--;
      }
      else
      {
        source-&gt;player-&gt;frags++;
        source-&gt;player-&gt;totalfrags++;
      }
    }
  }
  else if (!netgame &amp;&amp; (target-&gt;flags &amp; MF_COUNTKILL))
  {
    // count all monster deaths,
    // even those caused by other monsters
    consoleplayer-&gt;killcount++;
  }

  if (target-&gt;player)
  {
    // count environment kills against you
    if (!source)
    {
      target-&gt;player-&gt;frags--;
      target-&gt;player-&gt;totalfrags--;
    }

    target-&gt;flags &amp;= ~MF_SOLID;
    target-&gt;player-&gt;playerstate = PST_DEAD;
    target-&gt;player-&gt;std_viewheight = MIN(DEATHVIEWHEIGHT,
        target-&gt;height / 3);

    P_DropWeapon(target-&gt;player);

    // don't die in auto map, switch view prior to dying
    if (target-&gt;player == consoleplayer &amp;&amp; automapactive)
      AM_Stop();
  }

  state = S_NULL;
  overkill = (target-&gt;health &lt; -target-&gt;info-&gt;spawnhealth);

  if (overkill &amp;&amp; damtype &amp;&amp; damtype-&gt;overkill.label)
  {
    state = P_MobjFindLabel(target, damtype-&gt;overkill.label);
    if (state != S_NULL)
      state += damtype-&gt;overkill.offset;
  }
  
  if (state == S_NULL &amp;&amp; overkill &amp;&amp; target-&gt;info-&gt;overkill_state)
    state = target-&gt;info-&gt;overkill_state;

  if (state == S_NULL &amp;&amp; damtype &amp;&amp; damtype-&gt;death.label)
  {
    state = P_MobjFindLabel(target, damtype-&gt;death.label);
    if (state != S_NULL)
      state += damtype-&gt;death.offset;
  }

  if (state == S_NULL)
    state = target-&gt;info-&gt;death_state;

  P_SetMobjStateDeferred(target, state, P_Random() &amp; 3);

  // Drop stuff. This determines the kind of object spawned
  // during the death frame of a thing.
  item = target-&gt;info-&gt;dropitem;

  if (item)
  {
    mobj_t *mo = P_MobjCreateObject(target-&gt;x, target-&gt;y,
        target-&gt;floorz, item);

    // -ES- 1998/07/18 NULL check to prevent crashing
    if (mo)
      mo-&gt;flags |= MF_DROPPED;
  }
}
</t>
<t tx="T1817">@ P_ThrustMobj

Like P_DamageMobj, but only pushes the target object around
(doesn't inflict any damage). Parameters are:

* target  - mobj to be thrust.
* source  - mobj doing the thrusting.
* thrust  - amount of thrust done (same values as damage). Can
be negative to "pull" instead of push.

-AJA- 1999/11/06: Wrote this routine.
@c

void P_ThrustMobj(mobj_t * target, mobj_t * source, float_t thrust)
{
  float_t dx, dy, dz;
  float_t push, slope;
  angle_t angle;

  dx = target-&gt;x - source-&gt;x;
  dy = target-&gt;y - source-&gt;y;
  dz = MO_MIDZ(target) - MO_MIDZ(source);
  
  angle = R_PointToAngle(0, 0, dx, dy);

  // -ACB- 2000/03/11 Div-by-zero check...
  CHECKVAL(target-&gt;info-&gt;mass);

  push = 12.0 * thrust / target-&gt;info-&gt;mass;

  target-&gt;mom.x += push * M_Cos(angle);
  target-&gt;mom.y += push * M_Sin(angle);

  if (level_flags.true3dgameplay)
  {
    slope = P_ApproxSlope(dx, dy, dz);
  
    target-&gt;mom.z += push * slope / 2;
  }
}
</t>
<t tx="T1818">@ P_DamageMobj

Damages both enemies and players, decreases the amount of health
an mobj has and "kills" an mobj in the event of health being 0 or
less, the parameters are:

* Target  - mobj to be damaged.
* Inflictor - mobj which is causing the damage.
* Source  - mobj who is responsible for doing the damage. Can be NULL
* Amount  - amount of damage done.
* Damtype  - type of damage (for override states). Can be NULL

Both source and inflictor can be NULL, slime damage and barrel
explosions etc....

-AJA- 1999/09/12: Now uses P_SetMobjStateDeferred, since this
routine can be called by TryMove/PIT_CheckRelThing/etc.
@c

void P_DamageMobj(mobj_t * target, mobj_t * inflictor, 
    mobj_t * source, float_t damage, const damage_t * damtype)
{
  player_t *player;
  statenum_t state;
  float_t saved = 0;
  int i;

  if (!(target-&gt;flags &amp; MF_SHOOTABLE))
    return;

  if (target-&gt;health &lt;= 0)
    return;

  // check for immunity against the attack
  if (inflictor &amp;&amp; inflictor-&gt;currentattack &amp;&amp; BITSET_EMPTY ==
      (inflictor-&gt;currentattack-&gt;attack_class &amp; ~target-&gt;info-&gt;immunity))
  {
    return;
  }

  // -ACB- 1998/07/12 Use Visibility Enum
  // A Damaged Stealth Creature becomes more visible
  if (target-&gt;flags &amp; MF_STEALTH)
    target-&gt;vis_target = VISIBLE;

  if (target-&gt;flags &amp; MF_SKULLFLY)
  {
    target-&gt;mom.x = target-&gt;mom.y = target-&gt;mom.z = 0;
    target-&gt;flags &amp;= ~MF_SKULLFLY;
  }

  player = target-&gt;player;

  // take half damage in trainer mode
  if (player &amp;&amp; gameskill == sk_baby)
    damage /= 2;

  // Some close combat weapons should not
  // inflict thrust and push the victim out of reach,
  // thus kick away unless using the chainsaw.

  if (inflictor &amp;&amp; !(target-&gt;flags &amp; MF_NOCLIP) &amp;&amp;
      !(source &amp;&amp; source-&gt;player &amp;&amp; source-&gt;player-&gt;ready_wp &gt;= 0 &amp;&amp;
        source-&gt;player-&gt;weapons[source-&gt;player-&gt;ready_wp].info-&gt;nothrust))
  {
    // make fall forwards sometimes
    if (damage &lt; 40 &amp;&amp; damage &gt; target-&gt;health &amp;&amp;
        target-&gt;z - inflictor-&gt;z &gt; 64 &amp;&amp; (P_Random() &amp; 1))
    {
      P_ThrustMobj(target, inflictor, -damage * 4);
    }
    else
      P_ThrustMobj(target, inflictor, damage);
  }

  // player specific
  if (player)
  {
    // Below certain threshold, ignore damage in GOD mode, or with INVUL power
    if (damage &lt; 1000 &amp;&amp;
        ((player-&gt;cheats &amp; CF_GODMODE) || player-&gt;powers[PW_Invulnerable]))
    {
      return;
    }

    // check which armour can take some damage
    for (i=ARMOUR_Red; i &gt;= ARMOUR_Green; i--)
    {
      if (damtype &amp;&amp; damtype-&gt;no_armour)
        continue;

      if (player-&gt;armours[i] &lt;= 0)
        continue;

      switch (i)
      {
        case ARMOUR_Green:  saved = damage * 0.33; break;
        case ARMOUR_Blue:   saved = damage * 0.50; break;
        case ARMOUR_Yellow: saved = damage * 0.75; break;
        case ARMOUR_Red:    saved = damage * 0.90; break;
        default: 
          I_Error("INTERNAL ERROR in P_DamageMobj: bad armour %d\n", i);
      }

      if (player-&gt;armours[i] &lt;= saved)
      {
        // armour is used up
        saved = player-&gt;armours[i];
      }

      player-&gt;armours[i] -= saved;
      damage -= saved;
    }

    // mirror mobj health here for Dave
    player-&gt;health -= damage;

    if (player-&gt;health &lt; 0)
      player-&gt;health = 0;

    player-&gt;attacker = source;

    // add damage after armour / invuln detection
    if (damage &gt; 0)
      player-&gt;damagecount += MAX(damage, DAMAGE_ADD_MIN);

    // teleport stomp does 10k points...
    if (player-&gt;damagecount &gt; DAMAGE_LIMIT)
      player-&gt;damagecount = DAMAGE_LIMIT;
  }

  // do the damage
  target-&gt;health -= damage;

  if (target-&gt;health &lt;= 0)
  {
    P_KillMobj(source, target, damtype);
    return;
  }

  // enter pain states
  if (!(target-&gt;flags &amp; MF_SKULLFLY) &amp;&amp; P_RandomTest(target-&gt;info-&gt;painchance))
  {
    // setup to hit back
    target-&gt;flags |= MF_JUSTHIT;

    state = S_NULL;

    if (damtype &amp;&amp; damtype-&gt;pain.label)
    {
      state = P_MobjFindLabel(target, damtype-&gt;pain.label);
      if (state != S_NULL)
        state += damtype-&gt;pain.offset;
    }

    if (state == S_NULL)
      state = target-&gt;info-&gt;pain_state;

    if (state != S_NULL)
      P_SetMobjStateDeferred(target, state, 0);
  }

  // we're awake now...
  target-&gt;reactiontime = 0;

  if ((!target-&gt;threshold || target-&gt;extendedflags &amp; EF_NOGRUDGE) &amp;&amp;
      source &amp;&amp; source != target &amp;&amp; (!(source-&gt;extendedflags &amp; EF_NEVERTARGET)))
  {
    // if not intent on another player, chase after this one
    P_MobjSetTarget(target, source);
    target-&gt;threshold = BASETHRESHOLD;

    if (target-&gt;state == &amp;states[target-&gt;info-&gt;idle_state] &amp;&amp;
        target-&gt;info-&gt;chase_state)
    {
      P_SetMobjStateDeferred(target, target-&gt;info-&gt;chase_state, 0);
    }
  }
}
</t>
<t tx="T1819">@ignore
@language c

// Sector Lighting Code

// -KM- 1998/09/27 Lights generalised for ddf

&lt;&lt; p_lights #includes &gt;&gt;
&lt;&lt; p_lights declarations &gt;&gt;
@others
</t>
<t tx="T1820">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_random.h"
#include "p_local.h"
#include "r_state.h"
#include "z_zone.h"
</t>
<t tx="T1821">
light_t *lights = NULL;
</t>
<t tx="T1822">@ GENERALISED LIGHT

-AJA- 2000/09/20: added FADE type.
@c

static void DoLight(light_t * light)
{
  const lighttype_t *type = light-&gt;type;

  if (type-&gt;type == LITE_None || --light-&gt;count)
    return;

  // Flashing lights
  switch (type-&gt;type)
  {
    case LITE_Set:
      {
        light-&gt;sector-&gt;props.lightlevel = light-&gt;maxlight;

        // count is 0, i.e. this light is now disabled
        return;
      }
     
    case LITE_Fade:
      {
        int diff = light-&gt;maxlight - light-&gt;minlight;
        
        if (ABS(diff) &lt; type-&gt;step)
        {
          light-&gt;sector-&gt;props.lightlevel = light-&gt;maxlight;

          // count is 0, i.e. this light is now disabled
          return;
        }
        
        // step towards the target light level
        if (diff &lt; 0)
          light-&gt;minlight -= type-&gt;step;
        else
          light-&gt;minlight += type-&gt;step;

        light-&gt;sector-&gt;props.lightlevel = light-&gt;minlight;
        light-&gt;count = type-&gt;brighttime;
        break;
      }
     
    case LITE_Flash:
      {
        // Dark
        if (M_RandomTest(type-&gt;chance))
        {
          light-&gt;sector-&gt;props.lightlevel = light-&gt;minlight;
          light-&gt;count = type-&gt;darktime;
        }
        else
        {
          light-&gt;sector-&gt;props.lightlevel = light-&gt;maxlight;
          light-&gt;count = type-&gt;brighttime;
        }
        break;
      }

    case LITE_Strobe:
      if (light-&gt;sector-&gt;props.lightlevel == light-&gt;maxlight)
      {
        // Go dark
        light-&gt;sector-&gt;props.lightlevel = light-&gt;minlight;
        light-&gt;count = type-&gt;darktime;
      }
      else
      {
        // Go Bright
        light-&gt;sector-&gt;props.lightlevel = light-&gt;maxlight;
        light-&gt;count = type-&gt;brighttime;
      }
      break;

    case LITE_Glow:
      if (light-&gt;direction == -1)
      {
        // Go dark
        light-&gt;sector-&gt;props.lightlevel -= type-&gt;step;
        if (light-&gt;sector-&gt;props.lightlevel &lt;= light-&gt;minlight)
        {
          light-&gt;sector-&gt;props.lightlevel = light-&gt;minlight;
          light-&gt;count = type-&gt;brighttime;
          light-&gt;direction = +1;
        }
        else
        {
          light-&gt;count = type-&gt;darktime;
        }
      }
      else
      {
        // Go Bright
        light-&gt;sector-&gt;props.lightlevel += type-&gt;step;
        if (light-&gt;sector-&gt;props.lightlevel &gt;= light-&gt;maxlight)
        {
          light-&gt;sector-&gt;props.lightlevel = light-&gt;maxlight;
          light-&gt;count = type-&gt;darktime;
          light-&gt;direction = -1;
        }
        else
        {
          light-&gt;count = type-&gt;brighttime;
        }
      }
      break;

    case LITE_FireFlicker:
      {
        // -ES- 2000/02/13 Changed this to original DOOM style flicker
        int amount = (M_Random() &amp; 7) * type-&gt;step;
  
        if (light-&gt;sector-&gt;props.lightlevel - amount &lt; light-&gt;minlight)
        {
          light-&gt;sector-&gt;props.lightlevel = light-&gt;minlight;
          light-&gt;count = type-&gt;darktime;
        }
        else
        {
          light-&gt;sector-&gt;props.lightlevel = light-&gt;maxlight - amount;
          light-&gt;count = type-&gt;brighttime;
        }
      }

    default:
      break;
  }
}
</t>
<t tx="T1823">@ TURN LINE'S TAG LIGHTS ON
@c

void EV_LightTurnOn(int tag, int bright)
{
  int i;
  int j;
  sector_t *sector;
  sector_t *temp;
  line_t *templine;

  sector = sectors;

  for (i = 0; i &lt; numsectors; i++, sector++)
  {
    if (sector-&gt;tag == tag)
    {
      // bright == 0 means to search for highest light level
      // surrounding sector
      if (!bright)
      {
        for (j = 0; j &lt; sector-&gt;linecount; j++)
        {
          templine = sector-&gt;lines[j];
          temp = P_GetNextSector(templine, sector);

          if (!temp)
            continue;

          if (temp-&gt;props.lightlevel &gt; bright)
            bright = temp-&gt;props.lightlevel;
        }
      }
      sector-&gt;props.lightlevel = bright;
    }
  }
}
</t>
<t tx="T1824">
#if 0 // Currently unused
//
// P_DestroyLight
//
// Unlink and destroy light.
void P_DestroyLight(light_t *light)
{
  if (light-&gt;next)
    light-&gt;next-&gt;prev = light-&gt;prev;
  if (light-&gt;prev)
    light-&gt;prev-&gt;next = light-&gt;next;
  else
    lights = light-&gt;next;
  Z_Free(light);
}
</t>
<t tx="T1825">#endif

//
// P_DestroyAllLights
//
void P_DestroyAllLights(void)
{
  light_t *l, *next;

  for (l = lights; l; l = next)
  {
    next = l-&gt;next;
    Z_Free(l);
  }
  lights = NULL;
}
</t>
<t tx="T1826">@ P_NewLight

Allocate and link in light.
@c

light_t *P_NewLight(void)
{
  light_t *light;

  light = Z_New(light_t, 1);
  light-&gt;next = lights;
  light-&gt;prev = NULL;
  if (lights)
    lights-&gt;prev = light;
  lights = light;

  return light;
}
</t>
<t tx="T1827">@ EV_Lights
@c

boolean_t EV_Lights(sector_t * sec, const lighttype_t * type)
{
  light_t *light;

  // check if a light effect already is running on this sector.
  for (light=lights; light; light=light-&gt;next)
  {
    if (light-&gt;count == 0 || light-&gt;sector == sec)
      break;
  }

  if (!light)
  {
    // didn't already exist, create a new one
    light = P_NewLight();
  }

  light-&gt;type = type;
  light-&gt;sector = sec;
  light-&gt;direction = -1;

  switch (type-&gt;type)
  {
    case LITE_Set:
    case LITE_Fade:
      {
        light-&gt;minlight = sec-&gt;props.lightlevel;
        light-&gt;maxlight = type-&gt;level;
        light-&gt;count = type-&gt;brighttime;
        break;
      }
    
    default:
      {
        light-&gt;minlight = P_FindMinSurroundingLight(sec, sec-&gt;props.lightlevel);
        light-&gt;maxlight = sec-&gt;props.lightlevel;
        light-&gt;count = type-&gt;sync ? (leveltime % type-&gt;sync) + 1 : 
            type-&gt;darktime;
        break;
      }
  }
  
  return true;
}
</t>
<t tx="T1828">@ P_RunLights

Executes all light effects of this tic
Lights are quite simple to handle, since they never destroy
themselves. Therefore, we do not need to bother about stuff like
removal queues
@c

void P_RunLights(void)
{
  light_t *l;

  for (l = lights; l; l = l-&gt;next)
  {
    if (l-&gt;count)
      DoLight(l);
  }
}
</t>
<t tx="T1829">@ignore
@language c

// Moving, Aiming, Shooting &amp; Collision code

// -MH- 1998/07/02 "shootupdown" --&gt; "true3dgameplay"
//
// -AJA- 1999/07/19: Removed P_LineOpening.  Gaps are now stored 
//       in line_t, and updated whenever sector heights change.
//
// -AJA- 1999/07/21: Replaced some non-critical P_Randoms with M_Random.
//
// -AJA- 1999/07/30: Big changes for extra floor handling. Split
//       P_CheckPosition into two new routines (one handling absolute
//       positions, the other handling relative positions). Split the
//       PIT_Check* routines similiarly.

&lt;&lt; p_map #includes &gt;&gt;
&lt;&lt; p_map declarations &gt;&gt;
@others
</t>
<t tx="T1830">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "m_bbox.h"
#include "m_random.h"
#include "p_local.h"
#include "r_state.h"
#include "s_sound.h"
#include "z_zone.h"
</t>
<t tx="T1831">
static float_t tmbbox[4];

typedef struct try_move_info_s
{
  // --- input --
  
  // thing trying to move
  mobj_t *mover;
  int flags, extflags;
  
  // attempted destination
  float_t x, y, z;

  // --- output ---

  subsector_t *sub;

  // vertical space over all contacted lines
  float_t floorz, ceilnz;
  float_t dropoff;

  // objects that end up above and below us
  mobj_t *above;
  mobj_t *below;

  // -AJA- FIXME: this is a "quick fix" (hack).  If only one line is
  // hit, and TryMove decides the move is impossible, then we know
  // this line must be the blocking line.  Real solution ?  Probably
  // to move most of the checks from TryMove into CheckRelLine.  It
  // definitely needs a lot of consideration.

  line_t *line_which;
  int line_count;
}
try_move_info_t;

static try_move_info_t tm_I;

boolean_t mobj_hit_sky;
line_t *blockline;

// If "floatok" true, move would be ok if at float_destz.
boolean_t floatok;
float_t float_destz;

// keep track of special lines as they are hit,
// but don't process them until the move is proven valid

stack_array_t spechit_a;
line_t **spechit = NULL;
int numspechit;

mobj_t *linetarget;  // who got hit (or NULL)

typedef struct shoot_trav_info_s
{
  mobj_t *source;
  float_t range;
  float_t start_z;
  float_t angle;
  float_t slope;
  float_t topslope;
  float_t bottomslope;

  float_t damage;
  const damage_t *damtype;
  const mobjinfo_t *puff;
  float_t prev_z;
}
shoot_trav_info_t;

static shoot_trav_info_t shoot_I;
static shoot_trav_info_t aim_I;
</t>
<t tx="T1832">@ convenience function
@c

static INLINE int PointOnLineSide(float_t x, float_t y, line_t *ld)
{
  divline_t div;

  div.x = ld-&gt;v1-&gt;x;
  div.y = ld-&gt;v1-&gt;y;
  div.dx = ld-&gt;dx;
  div.dy = ld-&gt;dy;

  return P_PointOnDivlineSide(x, y, &amp;div);
}
</t>
<t tx="T1833">@ TELEPORT MOVE


PIT_StompThing
@c

static boolean_t PIT_StompThing(mobj_t * thing)
{
  float_t blockdist;

  if (!(thing-&gt;flags &amp; MF_SHOOTABLE))
    return true;

  blockdist = thing-&gt;radius + tm_I.mover-&gt;radius;

  // check to see we hit it
  if (fabs(thing-&gt;x - tm_I.x) &gt;= blockdist || fabs(thing-&gt;y - tm_I.y) &gt;= blockdist)
    return true;  // no, we did not

  // check we aren't trying to stomp ourselves
  if (thing == tm_I.mover)
    return true;

  // -AJA- 1999/07/30: True 3d gameplay checks.
  if (level_flags.true3dgameplay)
  {
    if (tm_I.z &gt;= thing-&gt;z + thing-&gt;height)
    {
      // went over
      tm_I.floorz = MAX(tm_I.floorz, thing-&gt;z + thing-&gt;height);
      return true;
    }

    if (tm_I.z + tm_I.mover-&gt;height &lt;= thing-&gt;z)
    {
      // went under
      tm_I.ceilnz = MIN(tm_I.ceilnz, thing-&gt;z);
      return true;
    }
  }

  if (!tm_I.mover-&gt;player &amp;&amp; (currentmap-&gt;force_off &amp; MPF_Stomp))
    return false;

  P_DamageMobj(thing, tm_I.mover, tm_I.mover, 10000, NULL);
  return true;
}
</t>
<t tx="T1834">@ P_TeleportMove
@c

boolean_t P_TeleportMove(mobj_t * thing, float_t x, float_t y, float_t z)
{
  int xl, xh;
  int yl, yh;
  int bx, by;

  // kill anything occupying the position
  tm_I.mover = thing;
  tm_I.flags = thing-&gt;flags;
  tm_I.extflags = thing-&gt;extendedflags;

  tm_I.x = x;
  tm_I.y = y;
  tm_I.z = z;

  tmbbox[BOXTOP] = y + tm_I.mover-&gt;radius;
  tmbbox[BOXBOTTOM] = y - tm_I.mover-&gt;radius;
  tmbbox[BOXRIGHT] = x + tm_I.mover-&gt;radius;
  tmbbox[BOXLEFT] = x - tm_I.mover-&gt;radius;

  tm_I.sub = R_PointInSubsector(x, y);

  P_ComputeThingGap(thing, tm_I.sub-&gt;sector, z, &amp;tm_I.floorz, &amp;tm_I.ceilnz);

  // The base floor/ceiling is from the subsector that contains the point.
  // Any contacted lines the step closer together will adjust them.
  tm_I.dropoff = tm_I.floorz;
  tm_I.above = NULL;
  tm_I.below = NULL;

  validcount++;
  Z_SetArraySize(&amp;spechit_a, numspechit = 0);

  // stomp on any things contacted
  xl = (tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS) / MAPBLOCKUNITS;
  xh = (tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS) / MAPBLOCKUNITS;
  yl = (tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS) / MAPBLOCKUNITS;
  yh = (tmbbox[BOXTOP] - bmaporgy + MAXRADIUS) / MAPBLOCKUNITS;
  for (bx = xl; bx &lt;= xh; bx++)
    for (by = yl; by &lt;= yh; by++)
      if (!P_BlockThingsIterator(bx, by, PIT_StompThing))
        return false;

  // everything on the spot has been stomped,
  // so link the thing into its new position

  thing-&gt;floorz = tm_I.floorz;
  thing-&gt;ceilingz = tm_I.ceilnz;

  P_ChangeThingPosition(thing, x, y, z);

  return true;
}
</t>
<t tx="T1835">@ ABSOLUTE POSITION CLIPPING


PIT_CheckAbsLine
@c

static boolean_t PIT_CheckAbsLine(line_t * ld)
{
  int i;

  if (tmbbox[BOXRIGHT] &lt;= ld-&gt;bbox[BOXLEFT] ||
      tmbbox[BOXLEFT] &gt;= ld-&gt;bbox[BOXRIGHT] ||
      tmbbox[BOXTOP] &lt;= ld-&gt;bbox[BOXBOTTOM] ||
      tmbbox[BOXBOTTOM] &gt;= ld-&gt;bbox[BOXTOP])
  {
    // no intersection with line
    return true;
  }

  if (P_BoxOnLineSide(tmbbox, ld) != -1)
    return true;

  // The spawning thing's position touches the given line.
  // If this should not be allowed, return false.

  if (!ld-&gt;backsector || ld-&gt;gap_num == 0)
    return false;  // one sided line

  if (tm_I.extflags &amp; EF_CROSSLINES)
  {
    if ((ld-&gt;flags &amp; ML_ShootBlock) &amp;&amp; (tm_I.flags &amp; MF_MISSILE))
      return false;
  }
  else
  {
    // explicitly blocking everything ?
    if (ld-&gt;flags &amp; ML_Blocking)
      return false;

    // block monsters only ?
    if ((tm_I.extflags &amp; EF_MONSTER) &amp;&amp;
        (ld-&gt;flags &amp; ML_BlockMonsters))
    {
      return false;
    }
  }

  // does the thing fit in one of the line gaps ?
  for (i = 0; i &lt; ld-&gt;gap_num; i++)
  {
    if (ld-&gt;gaps[i].f &lt;= tm_I.z &amp;&amp;
        tm_I.z + tm_I.mover-&gt;height &lt;= ld-&gt;gaps[i].c)
      return true;
  }

  return false;
}
</t>
<t tx="T1836">@ PIT_CheckAbsThing
@c

static boolean_t PIT_CheckAbsThing(mobj_t * thing)
{
  float_t blockdist;
  boolean_t solid;

  if (thing == tm_I.mover)
    return true;

  if (!(thing-&gt;flags &amp; (MF_SOLID | MF_SHOOTABLE)))
    return true;

  blockdist = thing-&gt;radius + tm_I.mover-&gt;radius;

  // Check that we didn't hit it
  if (fabs(thing-&gt;x - tm_I.x) &gt;= blockdist || fabs(thing-&gt;y - tm_I.y) &gt;= blockdist)
    return true;  // no we missed this thing

  // -KM- 1998/9/19 True 3d gameplay checks.
  if ((tm_I.flags &amp; MF_MISSILE) || level_flags.true3dgameplay)
  {
    // overhead ?
    if (tm_I.z &gt;= thing-&gt;z + thing-&gt;height)
      return true;

    // underneath ?
    if (tm_I.z + tm_I.mover-&gt;height &lt;= thing-&gt;z)
      return true;
  }

  solid = (thing-&gt;flags &amp; MF_SOLID);

  // check for missiles making contact
  // -ACB- 1998/08/04 Procedure for missile contact

  if (tm_I.mover-&gt;source &amp;&amp; tm_I.mover-&gt;source == thing)
    return true;

  if (tm_I.flags &amp; MF_MISSILE)
  {
    // thing isn't shootable, return depending on if the thing is solid.
    if (!(thing-&gt;flags &amp; MF_SHOOTABLE))
      return !solid;

    // don't hurt the missile's shooter:
    if (tm_I.mover-&gt;source &amp;&amp; tm_I.mover-&gt;source == thing)
      return true;

    P_ActMissileContact(tm_I.mover, thing);
    return (tm_I.extflags &amp; EF_TUNNEL) ? true : false;
  }

  // -AJA- 2000/06/09: Follow MBF semantics: allow the non-solid
  // moving things to pass through solid things.
  return !solid || (thing-&gt;flags &amp; MF_NOCLIP) || !(tm_I.flags &amp; MF_SOLID);
}
</t>
<t tx="T1837">@ P_CheckAbsPosition

Check whether the thing can be placed at the absolute position
(x,y,z). Makes no assumptions about the thing's current position.

This is purely informative, nothing is modified, nothing is picked
up, no special lines are recorded, no special things are touched, and
no information (apart from true/false) is returned.

Only used for checking if an object can be spawned at a
particular location.
@c

boolean_t P_CheckAbsPosition(mobj_t * thing, float_t x, float_t y, float_t z)
{
  int xl, xh;
  int yl, yh;
  int bx, by;

  // can go anywhere
  if (tm_I.flags &amp; MF_NOCLIP)
    return true;

  tm_I.mover = thing;
  tm_I.flags = thing-&gt;flags;
  tm_I.extflags = thing-&gt;extendedflags;

  tm_I.x = x;
  tm_I.y = y;
  tm_I.z = z;

  tmbbox[BOXTOP] = y + tm_I.mover-&gt;radius;
  tmbbox[BOXBOTTOM] = y - tm_I.mover-&gt;radius;
  tmbbox[BOXRIGHT] = x + tm_I.mover-&gt;radius;
  tmbbox[BOXLEFT] = x - tm_I.mover-&gt;radius;

  tm_I.sub = R_PointInSubsector(x, y);

  validcount++;

  // Check things first.
  // The bounding box is extended by MAXRADIUS
  // because mobj_ts are grouped into mapblocks
  // based on their origin point, and can overlap
  // into adjacent blocks by up to MAXRADIUS units.

  xl = (tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS) / MAPBLOCKUNITS;
  xh = (tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS) / MAPBLOCKUNITS;
  yl = (tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS) / MAPBLOCKUNITS;
  yh = (tmbbox[BOXTOP] - bmaporgy + MAXRADIUS) / MAPBLOCKUNITS;

  for (bx = xl; bx &lt;= xh; bx++)
    for (by = yl; by &lt;= yh; by++)
      if (!P_BlockThingsIterator(bx, by, PIT_CheckAbsThing))
        return false;

  // check lines

  xl = (tmbbox[BOXLEFT] - bmaporgx) / MAPBLOCKUNITS;
  xh = (tmbbox[BOXRIGHT] - bmaporgx) / MAPBLOCKUNITS;
  yl = (tmbbox[BOXBOTTOM] - bmaporgy) / MAPBLOCKUNITS;
  yh = (tmbbox[BOXTOP] - bmaporgy) / MAPBLOCKUNITS;

  for (bx = xl; bx &lt;= xh; bx++)
    for (by = yl; by &lt;= yh; by++)
      if (!P_BlockLinesIterator(bx, by, PIT_CheckAbsLine))
        return false;

  return true;
}
</t>
<t tx="T1838">@ RELATIVE MOVEMENT CLIPPING


PIT_CheckRelLine

Adjusts tm_I.floorz &amp; tm_I.ceilnz as lines are contacted
@c

static boolean_t PIT_CheckRelLine(line_t * ld)
{
  int i;

  if (tmbbox[BOXRIGHT] &lt;= ld-&gt;bbox[BOXLEFT] ||
      tmbbox[BOXLEFT] &gt;= ld-&gt;bbox[BOXRIGHT] ||
      tmbbox[BOXTOP] &lt;= ld-&gt;bbox[BOXBOTTOM] ||
      tmbbox[BOXBOTTOM] &gt;= ld-&gt;bbox[BOXTOP])
  {
    // no intersection with line
    return true;
  }

  if (P_BoxOnLineSide(tmbbox, ld) != -1)
    return true;

  // A line has been hit

  // The moving thing's destination position will cross the given line.
  // If this should not be allowed, return false.
  // If the line is special, keep track of it
  // to process later if the move is proven ok.
  // NOTE: specials are NOT sorted by order,
  // so two special lines that are only 8 pixels apart
  // could be crossed in either order.

  if (!ld-&gt;backsector)
  {
    blockline = ld;

    // one sided line
    return false;
  }

  if (tm_I.extflags &amp; EF_CROSSLINES)
  {
    if ((ld-&gt;flags &amp; ML_ShootBlock) &amp;&amp; (tm_I.flags &amp; MF_MISSILE))
    {
      blockline = ld;
      return false;
    }
  }
  else
  {
    // explicitly blocking everything ?
    // or just blocking monsters ?

    if ((ld-&gt;flags &amp; ML_Blocking) ||
        ((ld-&gt;flags &amp; ML_BlockMonsters) &amp;&amp;
         (tm_I.extflags &amp; EF_MONSTER)))
    {
      blockline = ld;
      return false;
    }
  }

  // handle ladders (players only !)
  if (tm_I.mover-&gt;player &amp;&amp; ld-&gt;special &amp;&amp; 
      ld-&gt;special-&gt;ladder.height &gt; 0)
  {
    float_t z1, z2;
    float_t pz1, pz2;

    z1 = ld-&gt;frontsector-&gt;f_h + ld-&gt;side[0]-&gt;middle.offset.y;
    z2 = z1 + ld-&gt;special-&gt;ladder.height;
     
    pz1 = tm_I.mover-&gt;z;
    pz2 = tm_I.mover-&gt;z + tm_I.mover-&gt;height;

    do 
    {
      // can't reach the ladder ?
      if (pz1 &gt; z2 || pz2 &lt; z1)
        break;
      
      // FIXME: if more than one ladder, choose best one

      tm_I.mover-&gt;on_ladder = (ld - lines);
    }
    while (0);
  }

  // if contacted a special line, add it to the list
  if (ld-&gt;special)
  {
    Z_SetArraySize(&amp;spechit_a, ++numspechit);
    spechit[numspechit - 1] = ld;
  }

  // check for hitting a sky-hack line
  {
    float_t f1, c1;
    float_t f2, c2;

    f1 = ld-&gt;frontsector-&gt;f_h;
    c1 = ld-&gt;frontsector-&gt;c_h;
    f2 = ld-&gt;backsector-&gt;f_h;
    c2 = ld-&gt;backsector-&gt;c_h;
    
    if (c1 != c2 &amp;&amp; IS_SKY(ld-&gt;frontsector-&gt;ceil) &amp;&amp;
        IS_SKY(ld-&gt;backsector-&gt;ceil) &amp;&amp; tm_I.z &gt; MIN(c1, c2))
    {
      mobj_hit_sky = true;
    }

    if (f1 != f2 &amp;&amp; IS_SKY(ld-&gt;frontsector-&gt;floor) &amp;&amp;
        IS_SKY(ld-&gt;backsector-&gt;floor) &amp;&amp;
        tm_I.z+tm_I.mover-&gt;height &lt; MAX(f1, f2))
    {
      mobj_hit_sky = true;
    }
  }
  
  // CHOOSE GAP
  //
  // If this line borders a sector with multiple floors, then there will
  // be multiple gaps and we must choose one here, based on the thing's
  // current position (esp. Z).

  i = P_FindThingGap(ld-&gt;gaps, ld-&gt;gap_num, tm_I.z, tm_I.z +
      tm_I.mover-&gt;height);

  // gap has been chosen. apply it.

  if (i &gt;= 0)
  {
    if (ld-&gt;gaps[i].f &gt;= tm_I.floorz)
    {
      tm_I.floorz = ld-&gt;gaps[i].f;
      tm_I.below = NULL;
    }

    if (ld-&gt;gaps[i].c &lt; tm_I.ceilnz)
      tm_I.ceilnz = ld-&gt;gaps[i].c;

    if (ld-&gt;gaps[i].f &lt; tm_I.dropoff)
      tm_I.dropoff = ld-&gt;gaps[i].f;
  }
  else
  {
    tm_I.ceilnz = tm_I.floorz;
  }

  if (tm_I.ceilnz &lt; tm_I.floorz + tm_I.mover-&gt;height)
    blockline = ld;

  if (! blockline)
  {
    if (tm_I.line_count == 0)
      tm_I.line_which = ld;

    tm_I.line_count++;
  }

  return true;
}
</t>
<t tx="T1839">@ PIT_CheckRelThing
@c

static boolean_t PIT_CheckRelThing(mobj_t * thing)
{
  float_t blockdist;
  boolean_t solid;

  if (thing == tm_I.mover)
    return true;

  if (!(thing-&gt;flags &amp; (MF_SOLID | MF_SPECIAL | MF_SHOOTABLE | MF_TOUCHY)))
    return true;

  blockdist = thing-&gt;radius + tm_I.mover-&gt;radius;

  // Check that we didn't hit it
  if (fabs(thing-&gt;x - tm_I.x) &gt;= blockdist || fabs(thing-&gt;y - tm_I.y) &gt;= blockdist)
    return true;  // no we missed this thing

  // -KM- 1998/9/19 True 3d gameplay checks.
  if (level_flags.true3dgameplay &amp;&amp; !(thing-&gt;flags &amp; MF_SPECIAL))
  {
    float_t top_z = thing-&gt;z + thing-&gt;height;

    // see if we went over
    if (tm_I.z &gt;= top_z)
    {
      if (top_z &gt; tm_I.floorz &amp;&amp; !(thing-&gt;flags &amp; MF_MISSILE))
      {
        tm_I.floorz = top_z;
        tm_I.below = thing;
      }
      return true;
    }

    // see if we went underneath
    if (tm_I.z + tm_I.mover-&gt;height &lt;= thing-&gt;z)
    {
      if (thing-&gt;z &lt; tm_I.ceilnz &amp;&amp; !(thing-&gt;flags &amp; MF_MISSILE))
      {
        tm_I.ceilnz = thing-&gt;z;
      }
      return true;
    }

    // -AJA- 1999/07/21: allow climbing on top of things.

    if (top_z &gt; tm_I.floorz &amp;&amp;
        (thing-&gt;extendedflags &amp; EF_CLIMBABLE) &amp;&amp;
        (tm_I.mover-&gt;player || (tm_I.extflags &amp; EF_MONSTER)) &amp;&amp;
        ((tm_I.flags &amp; MF_DROPOFF) ||
         (tm_I.extflags &amp; EF_EDGEWALKER)) &amp;&amp;
        (tm_I.z + tm_I.mover-&gt;info-&gt;step_size &gt;= top_z))
    {
      tm_I.floorz = top_z;
      tm_I.below = thing;
      return true;
    }
  }

  // check for skulls slamming into things
  // -ACB- 1998/08/04 Use procedure
  // -KM- 1998/09/01 After I noticed Skulls slamming into boxes of rockets...

  solid = (thing-&gt;flags &amp; MF_SOLID);

  if ((tm_I.flags &amp; MF_SKULLFLY) &amp;&amp; solid)
  {
    P_ActSlammedIntoObject(tm_I.mover, thing);

    // stop moving
    return false;
  }

  // check for missiles making contact
  // -ACB- 1998/08/04 Procedure for missile contact

  if (tm_I.flags &amp; MF_MISSILE)
  {
    // see if it went over / under
    if (tm_I.z &gt; thing-&gt;z + thing-&gt;height)
      return true;  // overhead

    if (tm_I.z + tm_I.mover-&gt;height &lt; thing-&gt;z)
      return true;  // underneath

    // thing isn't shootable, return depending on if the thing is solid.
    if (!(thing-&gt;flags &amp; MF_SHOOTABLE))
      return !solid;

    // don't hurt the missile's shooter:
    if (tm_I.mover-&gt;source &amp;&amp; tm_I.mover-&gt;source == thing)
      return true;

    P_ActMissileContact(tm_I.mover, thing);
    return (tm_I.extflags &amp; EF_TUNNEL) ? true : false;
  }

  // check for special pickup
  if ((tm_I.flags &amp; MF_PICKUP) &amp;&amp; (thing-&gt;flags &amp; MF_SPECIAL))
  {
    // can remove thing
    P_TouchSpecialThing(thing, tm_I.mover);
  }

  // -AJA- 1999/08/21: check for touchy objects.
  if ((thing-&gt;flags &amp; MF_TOUCHY) &amp;&amp; (tm_I.flags &amp; MF_SOLID) &amp;&amp;
      !(thing-&gt;extendedflags &amp; EF_USABLE))
  {
    P_ActTouchyContact(thing, tm_I.mover);
    return !solid;
  }

  // -AJA- 2000/06/09: Follow MBF semantics: allow the non-solid
  // moving things to pass through solid things.
  return !solid || (thing-&gt;flags &amp; MF_NOCLIP) || !(tm_I.flags &amp; MF_SOLID);
}
</t>
<t tx="T1840">@ P_CheckRelPosition

Checks whether the thing can be moved to the position (x,y), which is
assumed to be relative to the thing's current position.

This is purely informative, nothing is modified
(except things picked up).

Only used by P_TryMove and P_ThingHeightClip.

in:
a mobj_t (can be valid or invalid)
a position to be checked

during:
special things are touched if MF_PICKUP
early out on solid lines?

out:
tm_I.sub
tm_I.floorz
tm_I.ceilnz
tm_I.dropoff
tm_I.above
tm_I.below
speciallines[]
numspeciallines
@c

static boolean_t P_CheckRelPosition(mobj_t * thing, float_t x, float_t y)
{
  int xl, xh;
  int yl, yh;
  int bx, by;

  mobj_hit_sky = false;
  blockline = NULL;

  tm_I.mover = thing;
  tm_I.flags = thing-&gt;flags;
  tm_I.extflags = thing-&gt;extendedflags;

  tm_I.x = x;
  tm_I.y = y;
  tm_I.z = thing-&gt;z;

  tmbbox[BOXTOP] = y + tm_I.mover-&gt;radius;
  tmbbox[BOXBOTTOM] = y - tm_I.mover-&gt;radius;
  tmbbox[BOXRIGHT] = x + tm_I.mover-&gt;radius;
  tmbbox[BOXLEFT] = x - tm_I.mover-&gt;radius;

  tm_I.sub = R_PointInSubsector(x, y);

  // The base floor / ceiling is from the sector that contains the
  // point.  Any contacted lines the step closer together will adjust them.
  // -AJA- 1999/07/19: Extra floor support.
  P_ComputeThingGap(thing, tm_I.sub-&gt;sector, tm_I.z, &amp;tm_I.floorz, &amp;tm_I.ceilnz);

  tm_I.dropoff = tm_I.floorz;
  tm_I.above = NULL;
  tm_I.below = NULL;
  tm_I.line_count = 0;

  // can go anywhere
  if (tm_I.flags &amp; MF_NOCLIP)
    return true;

  validcount++;
  Z_SetArraySize(&amp;spechit_a, numspechit = 0);

  // -KM- 1998/11/25 Corpses aren't supposed to hang in the air...
  if (!(tm_I.flags &amp; (MF_NOCLIP | MF_CORPSE)))
  {
    // Check things first, possibly picking things up.
    // The bounding box is extended by MAXRADIUS
    // because mobj_ts are grouped into mapblocks
    // based on their origin point, and can overlap
    // into adjacent blocks by up to MAXRADIUS units.

    xl = (tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS) / MAPBLOCKUNITS;
    xh = (tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS) / MAPBLOCKUNITS;
    yl = (tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS) / MAPBLOCKUNITS;
    yh = (tmbbox[BOXTOP] - bmaporgy + MAXRADIUS) / MAPBLOCKUNITS;

    for (bx = xl; bx &lt;= xh; bx++)
      for (by = yl; by &lt;= yh; by++)
        if (!P_BlockThingsIterator(bx, by, PIT_CheckRelThing))
          return false;
  }

  // check lines

  xl = (tmbbox[BOXLEFT] - bmaporgx) / MAPBLOCKUNITS;
  xh = (tmbbox[BOXRIGHT] - bmaporgx) / MAPBLOCKUNITS;
  yl = (tmbbox[BOXBOTTOM] - bmaporgy) / MAPBLOCKUNITS;
  yh = (tmbbox[BOXTOP] - bmaporgy) / MAPBLOCKUNITS;;

  thing-&gt;on_ladder = -1;
  
  for (bx = xl; bx &lt;= xh; bx++)
    for (by = yl; by &lt;= yh; by++)
      if (!P_BlockLinesIterator(bx, by, PIT_CheckRelLine))
        return false;

  return true;
}
</t>
<t tx="T1841">@ P_TryMove

Attempt to move to a new position,
crossing special lines unless MF_TELEPORT is set.
@c

boolean_t P_TryMove(mobj_t * thing, float_t x, float_t y)
{
  float_t oldx;
  float_t oldy;
  int side;
  int oldside;
  line_t *ld;
  boolean_t fell_off_thing;

  float_t z = thing-&gt;z;

  floatok = false;

  // solid wall or thing ?
  if (!P_CheckRelPosition(thing, x, y))
    return false;

  fell_off_thing = (thing-&gt;below_mo &amp;&amp; !tm_I.below);

  if (!(thing-&gt;flags &amp; MF_NOCLIP))
  {
    if (thing-&gt;height &gt; tm_I.ceilnz - tm_I.floorz)
    {
      // doesn't fit
      if (!blockline &amp;&amp; tm_I.line_count==1) blockline=tm_I.line_which;
      return false;
    }

    floatok = true;
    float_destz = tm_I.floorz;

    if (!(thing-&gt;flags &amp; MF_TELEPORT) &amp;&amp;
        (thing-&gt;z + thing-&gt;height &gt; tm_I.ceilnz))
    {
      // mobj must lower itself to fit.
      if (!blockline &amp;&amp; tm_I.line_count==1) blockline=tm_I.line_which;
      return false;
    }

    if (!(thing-&gt;flags &amp; MF_TELEPORT) &amp;&amp;
        (thing-&gt;z + thing-&gt;info-&gt;step_size) &lt; tm_I.floorz)
    {
      // too big a step up.
      if (!blockline &amp;&amp; tm_I.line_count==1) blockline=tm_I.line_which;
      return false;
    }

    if (!fell_off_thing &amp;&amp;
        !(thing-&gt;flags &amp; (MF_TELEPORT | MF_DROPOFF | MF_FLOAT)) &amp;&amp;
        (thing-&gt;z - thing-&gt;info-&gt;step_size) &gt; tm_I.floorz)
    {
      // too big a step down.
      return false;
    }

    if (!fell_off_thing &amp;&amp;
        !((thing-&gt;flags &amp; (MF_DROPOFF | MF_FLOAT)) ||
            (thing-&gt;extendedflags &amp; (EF_EDGEWALKER | EF_WATERWALKER))) &amp;&amp;
        (tm_I.floorz - tm_I.dropoff &gt; thing-&gt;info-&gt;step_size) &amp;&amp;
        (thing-&gt;floorz - thing-&gt;dropoffz &lt;= thing-&gt;info-&gt;step_size))
    {
      // don't stand over a dropoff.
      return false;
    }
  }

  // the move is ok, so link the thing into its new position

  oldx = thing-&gt;x;
  oldy = thing-&gt;y;
  thing-&gt;floorz = tm_I.floorz;
  thing-&gt;ceilingz = tm_I.ceilnz;
  thing-&gt;dropoffz = tm_I.dropoff;

  // -AJA- 1999/08/02: Improved MF_TELEPORT handling.
  if (thing-&gt;flags &amp; (MF_TELEPORT | MF_NOCLIP))
  {
    if (z &lt;= thing-&gt;floorz)
      z = thing-&gt;floorz;
    else if (z + thing-&gt;height &gt; thing-&gt;ceilingz)
      z = thing-&gt;ceilingz - thing-&gt;height;
  }

  P_ChangeThingPosition(thing, x, y, z);

  P_MobjSetAboveMo(thing, tm_I.above);
  P_MobjSetBelowMo(thing, tm_I.below);

  // if any special lines were hit, do the effect
  if (!(thing-&gt;flags &amp; (MF_TELEPORT | MF_NOCLIP)))
  {
    line_t **hits;
    int i;
    
    // -ES- 2000/02/05 spechit could be changed inside the loop
    hits = I_TmpMalloc(numspechit * sizeof(line_t *));
    Z_MoveData(hits, spechit, line_t *, numspechit);
    i = numspechit;
    Z_SetArraySize(&amp;spechit_a, numspechit = 0);
    
    for (i--; i &gt;= 0; i--)
    {
      // honour the NO_TRIGGER_LINES attack special
      if (! thing-&gt;player &amp;&amp;
          ! (thing-&gt;extendedflags &amp; EF_MONSTER) &amp;&amp;
          thing-&gt;currentattack &amp;&amp; 
          (thing-&gt;currentattack-&gt;flags &amp; AF_NoTriggerLines))
      {
        continue;
      }
       
      // see if the line was crossed
      ld = hits[i];
      side = PointOnLineSide(thing-&gt;x, thing-&gt;y, ld);
      oldside = PointOnLineSide(oldx, oldy, ld);

      if (side != oldside &amp;&amp; ld-&gt;special)
      {
        if (thing-&gt;flags &amp; MF_MISSILE)
          P_ShootSpecialLine(ld, oldside, thing-&gt;source);
        else
          P_CrossSpecialLine(ld, oldside, thing);
      }
    }
    I_TmpFree(hits);
  }

  return true;
}
</t>
<t tx="T1842">@ P_ThingHeightClip

Takes a valid thing and adjusts the thing-&gt;floorz, thing-&gt;ceilingz,
and possibly thing-&gt;z.

This is called for all nearby things whenever a sector changes height.

If the thing doesn't fit, the z will be set to the lowest value
and false will be returned.
@c

static boolean_t P_ThingHeightClip(mobj_t * thing)
{
  boolean_t onfloor = (fabs(thing-&gt;z - thing-&gt;floorz) &lt; 1);

  P_CheckRelPosition(thing, thing-&gt;x, thing-&gt;y);

  thing-&gt;floorz = tm_I.floorz;
  thing-&gt;ceilingz = tm_I.ceilnz;
  thing-&gt;dropoffz = tm_I.dropoff;

  P_MobjSetAboveMo(thing, tm_I.above);
  P_MobjSetBelowMo(thing, tm_I.below);

  if (onfloor)
  {
    // walking monsters rise and fall with the floor
    thing-&gt;z = thing-&gt;floorz;
  }
  else
  {
    // don't adjust a floating monster unless forced to
    if (thing-&gt;z + thing-&gt;height &gt; thing-&gt;ceilingz)
      thing-&gt;z = thing-&gt;ceilingz - thing-&gt;height;
  }

  if (thing-&gt;ceilingz - thing-&gt;floorz &lt; thing-&gt;height)
    return false;

  return true;
}
</t>
<t tx="T1843">@ SLIDE MOVE

Allows the player to slide along any angled walls.
@c

static float_t bestslidefrac;
static float_t secondslidefrac;

static line_t *bestslideline;
static line_t *secondslideline;

static float_t tmxmove;
static float_t tmymove;

mobj_t *slidemo;

//
// P_HitSlideLine
//
// Adjusts the xmove / ymove
// so that the next move will slide along the wall.
//
static void HitSlideLine(line_t * ld)
{
  int side;

  angle_t lineangle;
  angle_t moveangle;
  angle_t deltaangle;

  float_t movelen;
  float_t newlen;

  if (ld-&gt;slopetype == ST_HORIZONTAL)
  {
    tmymove = 0;
    return;
  }

  if (ld-&gt;slopetype == ST_VERTICAL)
  {
    tmxmove = 0;
    return;
  }

  side = PointOnLineSide(slidemo-&gt;x, slidemo-&gt;y, ld);

  lineangle = R_PointToAngle(0, 0, ld-&gt;dx, ld-&gt;dy);

  if (side == 1)
    lineangle += ANG180;

  moveangle = R_PointToAngle(0, 0, tmxmove, tmymove);
  deltaangle = moveangle - lineangle;

  if (deltaangle &gt; ANG180)
    deltaangle += ANG180;
  // I_Error ("SlideLine: ang&gt;ANG180");

  movelen = P_ApproxDistance(tmxmove, tmymove);
  newlen = movelen * M_Cos(deltaangle);

  tmxmove = newlen * M_Cos(lineangle);
  tmymove = newlen * M_Sin(lineangle);
}
</t>
<t tx="T1844">@ PTR_SlideTraverse
@c

static boolean_t PTR_SlideTraverse(intercept_t * in)
{
  line_t *li;
  int i;

  DEV_ASSERT(in-&gt;type == INCPT_Line,
      ("PTR_SlideTraverse: not a line?"));

  li = in-&gt;d.line;

  if (!(li-&gt;flags &amp; ML_TwoSided))
  {
    // hit the back side ?
    if (PointOnLineSide(slidemo-&gt;x, slidemo-&gt;y, li))
      return true;
  }

  // -AJA- 1999/07/19: Gaps are now stored in line_t.

  for (i = 0; i &lt; li-&gt;gap_num; i++)
  {
    // check if it can fit in the space
    if (slidemo-&gt;height &gt; li-&gt;gaps[i].c - li-&gt;gaps[i].f)
      continue;

    // check slide mobj is not too high
    if (slidemo-&gt;z + slidemo-&gt;height &gt; li-&gt;gaps[i].c)
      continue;

    // check slide mobj can step over
    if (slidemo-&gt;z + slidemo-&gt;info-&gt;step_size &lt; li-&gt;gaps[i].f)
      continue;

    return true;
  }

  // the line does block movement,
  // see if it is closer than best so far
  if (in-&gt;frac &lt; bestslidefrac)
  {
    secondslidefrac = bestslidefrac;
    secondslideline = bestslideline;
    bestslidefrac = in-&gt;frac;
    bestslideline = li;
  }

  // stop
  return false;
}
</t>
<t tx="T1845">@ P_SlideMove

The momx / momy move is bad, so try to slide along a wall.

Find the first line hit, move flush to it, and slide along it

-ACB- 1998/07/28 This is NO LONGER a kludgy mess; removed goto rubbish.
@c

void P_SlideMove(mobj_t * mo, float_t x, float_t y)
{
  float_t leadx;
  float_t leady;
  float_t trailx;
  float_t traily;
  float_t newx;
  float_t newy;
  float_t dx = x - mo-&gt;x;
  float_t dy = y - mo-&gt;y;
  int hitcount;
  boolean_t retry;

  slidemo = mo;
  hitcount = 0;
  retry = true;

  while (retry)
  {
    if (++hitcount == 3)
    {
      if (!P_TryMove(mo, mo-&gt;x, mo-&gt;y + dy))
        P_TryMove(mo, mo-&gt;x + dx, mo-&gt;y);
      return;
    }

    // trace along the three leading corners
    if (dx &gt; 0)
    {
      leadx = mo-&gt;x + mo-&gt;radius;
      trailx = mo-&gt;x - mo-&gt;radius;
    }
    else
    {
      leadx = mo-&gt;x - mo-&gt;radius;
      trailx = mo-&gt;x + mo-&gt;radius;
    }

    if (dy &gt; 0)
    {
      leady = mo-&gt;y + mo-&gt;radius;
      traily = mo-&gt;y - mo-&gt;radius;
    }
    else
    {
      leady = mo-&gt;y - mo-&gt;radius;
      traily = mo-&gt;y + mo-&gt;radius;
    }

    bestslidefrac = 1.0001;

    P_PathTraverse(leadx, leady, leadx + dx, leady + dy,
        PT_ADDLINES, PTR_SlideTraverse);
    P_PathTraverse(trailx, leady, trailx + dx, leady + dy,
        PT_ADDLINES, PTR_SlideTraverse);
    P_PathTraverse(leadx, traily, leadx + dx, traily + dy,
        PT_ADDLINES, PTR_SlideTraverse);

    // move up to the wall
    if (bestslidefrac == 1.0001)
    {
      // the move must have hit the middle, so stairstep
      if (!P_TryMove(mo, mo-&gt;x, mo-&gt;y + dy))
        P_TryMove(mo, mo-&gt;x + dx, mo-&gt;y);
      return;
    }

    // fudge a bit to make sure it doesn't hit
    bestslidefrac -= 0.01;
    if (bestslidefrac &gt; 0)
    {
      newx = dx * bestslidefrac;
      newy = dy * bestslidefrac;

      if (!P_TryMove(mo, mo-&gt;x + newx, mo-&gt;y + newy))
      {
        if (!P_TryMove(mo, mo-&gt;x, mo-&gt;y + dy))
          P_TryMove(mo, mo-&gt;x + dx, mo-&gt;y);
        return;
      }
    }

    // Now continue along the wall.
    // First calculate remainder.
    bestslidefrac = 1.0 - (bestslidefrac + 0.01);

    if (bestslidefrac &gt; 1.0)
      bestslidefrac = 1.0;

    if (bestslidefrac &lt;= 0)
      return;

    tmxmove = dx * bestslidefrac;
    tmymove = dy * bestslidefrac;

    HitSlideLine(bestslideline);  // clip the moves

    dx = tmxmove;
    dy = tmymove;

    if (P_TryMove(mo, mo-&gt;x + tmxmove, mo-&gt;y + tmymove))
      retry = false;
  }
}
</t>
<t tx="T1846">@ PTR_AimTraverse

Sets linetarget and slope when a target is aimed at.
@c

static boolean_t PTR_AimTraverse(intercept_t * in)
{
  line_t *li;
  mobj_t *th;
  float_t slope;
  float_t thingtopslope;
  float_t thingbottomslope;
  float_t dist;

  dist = aim_I.range * in-&gt;frac;

  if (dist &lt; 0.01)
    return true;

  if (in-&gt;type == INCPT_Line)
  {
    li = in-&gt;d.line;

    if (!(li-&gt;flags &amp; ML_TwoSided) || li-&gt;gap_num == 0)
      return false;  // stop

    // Crosses a two sided line.
    // A two sided line will restrict
    // the possible target ranges.
    //
    // -AJA- 1999/07/19: Gaps are now kept in line_t.

    if (li-&gt;frontsector-&gt;f_h != li-&gt;backsector-&gt;f_h)
    {
      float_t maxfloor = MAX(li-&gt;frontsector-&gt;f_h, li-&gt;backsector-&gt;f_h);

      slope = (maxfloor - aim_I.start_z) / dist;

      if (slope &gt; aim_I.bottomslope)
        aim_I.bottomslope = slope;
    }

    if (li-&gt;frontsector-&gt;c_h != li-&gt;backsector-&gt;c_h)
    {
      float_t minceil = MIN(li-&gt;frontsector-&gt;c_h, li-&gt;backsector-&gt;c_h);

      slope = (minceil - aim_I.start_z) / dist;
      
      if (slope &lt; aim_I.topslope)
        aim_I.topslope = slope;
    }

    if (aim_I.topslope &lt;= aim_I.bottomslope)
      return false;  // stop

    // shot continues
    return true;
  }

  DEV_ASSERT2(in-&gt;type == INCPT_Thing);

  // shoot a thing
  th = in-&gt;d.thing;

  if (th == aim_I.source)
    return true;  // can't shoot self

  if (!(th-&gt;flags &amp; MF_SHOOTABLE))
    return true;  // has to be able to be shot

  // check angles to see if the thing can be aimed at
  thingtopslope = (th-&gt;z + th-&gt;height - aim_I.start_z) / dist;

  if (thingtopslope &lt; aim_I.bottomslope)
    return true;  // shot over the thing

  thingbottomslope = (th-&gt;z - aim_I.start_z) / dist;

  if (thingbottomslope &gt; aim_I.topslope)
    return true;  // shot under the thing

  // this thing can be hit!
  if (thingtopslope &gt; aim_I.topslope)
    thingtopslope = aim_I.topslope;

  if (thingbottomslope &lt; aim_I.bottomslope)
    thingbottomslope = aim_I.bottomslope;

  aim_I.slope = (thingtopslope + thingbottomslope) / 2;
  linetarget = th;

  return false;  // don't go any farther
}
</t>
<t tx="T1847">@ ShootCheckGap

Returns true if successfully passed gap.
@c

static INLINE boolean_t ShootCheckGap(float_t z,
    float_t f_h, surface_t *floor, float_t c_h, surface_t *ceil)
{
  float_t x, y;
  float_t frac;

  // perfectly horizontal shots cannot hit planes
  if (shoot_I.slope == 0)
    return true;

  // check if hit the floor
  if (shoot_I.prev_z &gt; f_h &amp;&amp; z &lt; f_h)
  {
    /* nothing */
  }
  // check if hit the ceiling
  else if (shoot_I.prev_z &lt; c_h &amp;&amp; z &gt; c_h)
  {
    f_h = c_h;
    floor = ceil;
  }
  else
    return true;
 
  // don't shoot the sky!
  if (IS_SKY(floor[0]))
    return false;

  frac = (f_h - shoot_I.start_z) / (shoot_I.slope * shoot_I.range);

  x = trace.x + trace.dx * frac;
  y = trace.y + trace.dy * frac;
  z = (z &lt; shoot_I.prev_z) ? f_h + 2 : f_h - 2;

  // Spawn bullet puff
  if (shoot_I.puff)
    P_SpawnPuff(x, y, z, shoot_I.puff);

  // don't go any farther
  return false;
}
</t>
<t tx="T1848">@ PTR_ShootTraverse

-ACB- 1998/07/28 Cleaned up.
@c

static boolean_t PTR_ShootTraverse(intercept_t * in)
{
  float_t x, y, z;
  float_t frac;
  float_t dist;
  float_t thingtopslope;
  float_t thingbottomslope;
  int i, sidenum;

  line_t *li;
  mobj_t *th;
  side_t *side;
  boolean_t use_puff;

  dist = shoot_I.range * in-&gt;frac;

  if (dist &lt; 0.1)
    dist = 0.1;

  // Intercept is a line?
  if (in-&gt;type == INCPT_Line)
  {
    li = in-&gt;d.line;

    // determine coordinates of intersect
    frac = in-&gt;frac;
    x = trace.x + trace.dx * frac;
    y = trace.y + trace.dy * frac;
    z = shoot_I.start_z + frac * shoot_I.slope * shoot_I.range;

    sidenum = PointOnLineSide(trace.x, trace.y, li);
    side = li-&gt;side[sidenum];

    // Line is a special, Cause action....
    // -AJA- honour the NO_TRIGGER_LINES attack special too
    if (li-&gt;special &amp;&amp;
        (! shoot_I.source || ! shoot_I.source-&gt;currentattack ||
         ! (shoot_I.source-&gt;currentattack-&gt;flags &amp; AF_NoTriggerLines)))
    {
      P_ShootSpecialLine(li, sidenum, shoot_I.source);
    }

    // check if shot has hit a floor or ceiling...
    if (side)
    {
      extrafloor_t *ef;
      surface_t *floor_s = &amp;side-&gt;sector-&gt;floor;
      float_t floor_h = side-&gt;sector-&gt;f_h;

      // FIXME: must go in correct order
      for (ef=side-&gt;sector-&gt;bottom_ef; ef; ef=ef-&gt;higher)
      {
        if (! ShootCheckGap(z, floor_h, floor_s, ef-&gt;bottom_h, ef-&gt;bottom))
          return false;
         
        floor_s = ef-&gt;top;
        floor_h = ef-&gt;top_h;
      }

      if (! ShootCheckGap(z, floor_h, floor_s, 
            side-&gt;sector-&gt;c_h, &amp;side-&gt;sector-&gt;ceil))
      {
        return false;
      }
    }

    // shot doesn't go through a one-sided line, since one sided lines
    // do not have a sector on the other side.

    if ((li-&gt;flags &amp; ML_TwoSided) &amp;&amp; li-&gt;gap_num &gt; 0 &amp;&amp;
        !(li-&gt;flags &amp; ML_ShootBlock))
    {
      DEV_ASSERT2(li-&gt;backsector);

      // check all line gaps
      for (i=0; i &lt; li-&gt;gap_num; i++)
      {
        if (li-&gt;gaps[i].f &lt;= z &amp;&amp; z &lt;= li-&gt;gaps[i].c)
        {
          shoot_I.prev_z = z;
          return true;
        }
      }
    }
    
    // check if bullet hit a sky hack line...
    if (li-&gt;frontsector &amp;&amp; li-&gt;backsector)
    {
      if (IS_SKY(li-&gt;frontsector-&gt;ceil) &amp;&amp; IS_SKY(li-&gt;backsector-&gt;ceil))
      {
        float_t c1 = li-&gt;frontsector-&gt;c_h;
        float_t c2 = li-&gt;backsector-&gt;c_h;

        if (MIN(c1,c2) &lt;= z &amp;&amp; z &lt;= MAX(c1,c2))
          return false;
      }

      if (IS_SKY(li-&gt;frontsector-&gt;floor) &amp;&amp; IS_SKY(li-&gt;backsector-&gt;floor))
      {
        float_t f1 = li-&gt;frontsector-&gt;f_h;
        float_t f2 = li-&gt;backsector-&gt;f_h;

        if (MIN(f1,f2) &lt;= z &amp;&amp; z &lt;= MAX(f1,f2))
          return false;
      }
    }

    // position puff off the wall

    x -= trace.dx * 6.0 / shoot_I.range;
    y -= trace.dy * 6.0 / shoot_I.range;

    // Spawn bullet puffs.
    if (shoot_I.puff)
      P_SpawnPuff(x, y, z, shoot_I.puff);

    // don't go any farther
    return false;
  }

  DEV_ASSERT2(in-&gt;type == INCPT_Thing);

  // shoot a thing
  th = in-&gt;d.thing;

  // don't shoot self
  if (th == shoot_I.source)
    return true;

  // got to able to shoot it
  if (!(th-&gt;flags &amp; MF_SHOOTABLE) &amp;&amp; !(th-&gt;extendedflags &amp; EF_BLOCKSHOTS))
    return true;

  // check angles to see if the thing can be aimed at
  thingtopslope = (th-&gt;z + th-&gt;height - shoot_I.start_z) / dist;

  // shot over the thing ?
  if (thingtopslope &lt; shoot_I.slope)
    return true;

  thingbottomslope = (th-&gt;z - shoot_I.start_z) / dist;

  // shot under the thing ?
  if (thingbottomslope &gt; shoot_I.slope)
    return true;

  // hit thing
  // position a bit closer
  frac = in-&gt;frac - 10.0 / shoot_I.range;

  x = trace.x + trace.dx * frac;
  y = trace.y + trace.dy * frac;
  z = shoot_I.start_z + frac * shoot_I.slope * shoot_I.range;

  // Spawn bullet puffs or blood spots,
  // depending on target type.
  
  use_puff = !(th-&gt;flags &amp; MF_SHOOTABLE) || (th-&gt;flags &amp; MF_NOBLOOD);

  if (th-&gt;flags &amp; MF_SHOOTABLE)
  {
    if (! P_ActBulletContact(shoot_I.source, th, shoot_I.damage, shoot_I.damtype))
      use_puff = true;
  }

  if (use_puff &amp;&amp; shoot_I.puff)
    P_SpawnPuff(x, y, z, shoot_I.puff);
  else
    P_SpawnBlood(x, y, z, shoot_I.damage, shoot_I.angle, th-&gt;info-&gt;blood);

  // don't go any farther
  return false;
}
</t>
<t tx="T1849">@ P_AimLineAttack
@c

float_t P_AimLineAttack(mobj_t * t1, angle_t angle, float_t distance)
{
  float_t x2 = t1-&gt;x + distance * M_Cos(angle);
  float_t y2 = t1-&gt;y + distance * M_Sin(angle);

  if (t1-&gt;info)
    aim_I.start_z = t1-&gt;z + t1-&gt;height * PERCENT_2_FLOAT(t1-&gt;info-&gt;shotheight);
  else
    aim_I.start_z = t1-&gt;z + t1-&gt;height / 2 + 8;

  if (t1-&gt;player)
  {
    aim_I.topslope = (t1-&gt;vertangle * 256 + 100.0) / 160.0;
    aim_I.bottomslope = (t1-&gt;vertangle * 256 - 100.0) / 160.0;
  }
  else
  {
    aim_I.topslope = 100.0 / 160.0;
    aim_I.bottomslope = -100.0 / 160.0;
  }

  linetarget = NULL;

  aim_I.source = t1;
  aim_I.range = distance;
  aim_I.angle = angle;
  aim_I.slope = 0;

  P_PathTraverse(t1-&gt;x, t1-&gt;y, x2, y2, PT_ADDLINES | PT_ADDTHINGS, PTR_AimTraverse);

  if (linetarget)
    return aim_I.slope;

  return 0;
}
</t>
<t tx="T1850">@ P_LineAttack

Note: Damtype can be NULL.
@c

void P_LineAttack(mobj_t * t1, angle_t angle, float_t distance, 
    float_t slope, float_t damage, const damage_t * damtype,
    const mobjinfo_t *puff)
{
  float_t x2 = t1-&gt;x + distance * M_Cos(angle);
  float_t y2 = t1-&gt;y + distance * M_Sin(angle);

  if (t1-&gt;info)
    shoot_I.start_z = t1-&gt;z + t1-&gt;height * PERCENT_2_FLOAT(t1-&gt;info-&gt;shotheight);
  else
    shoot_I.start_z = t1-&gt;z + t1-&gt;height / 2 + 8;

  shoot_I.source = t1;
  shoot_I.range = distance;
  shoot_I.angle = angle;
  shoot_I.slope = slope;
  shoot_I.damage  = damage;
  shoot_I.damtype = damtype;
  shoot_I.prev_z = shoot_I.start_z;
  shoot_I.puff = puff;

  P_PathTraverse(t1-&gt;x, t1-&gt;y, x2, y2, PT_ADDLINES | PT_ADDTHINGS, 
      PTR_ShootTraverse);
}
</t>
<t tx="T1851">@ P_MapTargetTheory

Returns a dummy moving object for a target, used for mobjs
that don't have a specific target; but need to launch some sort
of projectile in the direction based upon the angle &amp; vertical
angle of the mobj.

-ACB- 1998/09/01
@c

mobj_t *P_MapTargetTheory(mobj_t * source)
{
  angle_t angle;
  float_t distance;
  float_t start_z;

  static mobj_t theorytarget;

  angle = source-&gt;angle;
  distance = MISSILERANGE;

  if (source-&gt;info)
    start_z = source-&gt;z + source-&gt;height * PERCENT_2_FLOAT(source-&gt;info-&gt;shotheight);
  else
    start_z = source-&gt;z + source-&gt;height / 2 + 8;

  Z_Clear(&amp;theorytarget, mobj_t, 1);

  theorytarget.x = source-&gt;x + distance * M_Cos(angle);
  theorytarget.y = source-&gt;y + distance * M_Sin(angle);
  theorytarget.z = start_z   + distance * source-&gt;vertangle;

  theorytarget.extendedflags |= EF_DUMMYMOBJ;
  theorytarget.radius = theorytarget.height = 1;

  return &amp;theorytarget;
}
</t>
<t tx="T1852">@ P_MapTargetAutoAim

Returns a moving object for a target; will search for a mobj to
lock onto, however a dummy target returned if no object cannot be
locked onto.

-ACB- 1998/09/01
-AJA- 1999/08/08: Added `force_aim' to fix chainsaw.
@c

mobj_t *P_MapTargetAutoAim(mobj_t * source, angle_t angle, float_t distance, boolean_t force_aim)
{
  float_t x2, y2;

  // -KM- 1999/01/31 Autoaim is an option.
  if (source-&gt;player &amp;&amp; !level_flags.autoaim &amp;&amp; !force_aim)
  {
    return P_MapTargetTheory(source);
  }

  aim_I.source = source;

  x2 = source-&gt;x + distance * M_Cos(angle);
  y2 = source-&gt;y + distance * M_Sin(angle);

  if (source-&gt;info)
    aim_I.start_z = source-&gt;z + source-&gt;height * PERCENT_2_FLOAT(source-&gt;info-&gt;shotheight);
  else
    aim_I.start_z = source-&gt;z + source-&gt;height / 2 + 8;

  if (source-&gt;player)
  {
    aim_I.topslope = (100 + source-&gt;vertangle * 256) / 160.0;
    aim_I.bottomslope = (-100 + source-&gt;vertangle * 256) / 160.0;
  }
  else
  {
    aim_I.topslope = 100.0 / 160.0;
    aim_I.bottomslope = -100.0 / 160.0;
  }

  aim_I.range = distance;
  linetarget = NULL;

  P_PathTraverse(source-&gt;x, source-&gt;y, x2, y2, PT_ADDLINES | PT_ADDTHINGS, 
        PTR_AimTraverse);

  if (! linetarget)
  {
    return P_MapTargetTheory(source);
  }

  // -KM- 1999/01/31 Look at the thing you aimed at.  Is sometimes
  //   useful, sometimes annoying :-)
  if (source-&gt;player &amp;&amp; level_flags.autoaim == AA_MLOOK)
  {
    source-&gt;vertangle = (linetarget-&gt;z - source-&gt;z) /
        P_ApproxDistance(source-&gt;x - linetarget-&gt;x, source-&gt;y - linetarget-&gt;y);
    if (source-&gt;vertangle &gt; LOOKUPLIMIT)
      source-&gt;vertangle = LOOKUPLIMIT;
    if (source-&gt;vertangle &lt; LOOKDOWNLIMIT)
      source-&gt;vertangle = LOOKDOWNLIMIT;
  }
  return linetarget;
}
</t>
<t tx="T1853">@ USE LINES
@c

static mobj_t *usething;
static float use_lower, use_upper;

static boolean_t PTR_UseTraverse(intercept_t * in)
{
  int sidenum;
  line_t *line;
  side_t *side;
  mobj_t *th;

  // intercept is a thing ?
  if (in-&gt;type == INCPT_Thing)
  {
    th = in-&gt;d.thing;

    // not a usable thing ?
    if (!(th-&gt;extendedflags &amp; EF_USABLE) || ! th-&gt;info-&gt;touch_state)
      return true;
    
    if (!P_ActUseThing(usething, th, use_lower, use_upper))
      return true;

    // don't go any farther (thing was usable)
    return false;
  }

  DEV_ASSERT2(in-&gt;type == INCPT_Line);

  line = in-&gt;d.line;

  sidenum = PointOnLineSide(usething-&gt;x, usething-&gt;y, line);
  sidenum = (sidenum == 1) ? 1 : 0;

  side = line-&gt;side[sidenum];

  // update open vertical range (extrafloors are NOT checked)
  if (side)
  {
    use_lower = MAX(use_lower, side-&gt;sector-&gt;f_h);
    use_upper = MIN(use_upper, side-&gt;sector-&gt;c_h);
  }

  if (!line-&gt;special)
  {
    if (line-&gt;gap_num == 0 || use_upper &lt;= use_lower)
    {
      // can't use through a wall
      S_StartSound(usething, usething-&gt;info-&gt;noway_sound);
      return false;
    }

    // not a special line, but keep checking
    return true;
  }

  P_UseSpecialLine(usething, line, sidenum, use_lower, use_upper);

  // can't use more than one special line in a row
  // -AJA- 1999/09/25: ...unless the line has the ML_PASSTHRU flag
  //       (Boom compatibility).

  return (line-&gt;flags &amp; ML_PassThru) ? true : false;
}
</t>
<t tx="T1854">@ P_UseLines

Looks for special lines in front of the player to activate.
@c

void P_UseLines(player_t * player)
{
  int angle;
  float_t x1;
  float_t y1;
  float_t x2;
  float_t y2;

  usething = player-&gt;mo;
  use_lower = INT_MIN;
  use_upper = INT_MAX;

  angle = player-&gt;mo-&gt;angle;

  x1 = player-&gt;mo-&gt;x;
  y1 = player-&gt;mo-&gt;y;
  x2 = x1 + USERANGE * M_Cos(angle);
  y2 = y1 + USERANGE * M_Sin(angle);

  P_PathTraverse(x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS, PTR_UseTraverse);
}
</t>
<t tx="T1855">@ RADIUS ATTACK
@c

typedef struct rds_atk_info_s
{
  float_t range;
  mobj_t *spot;
  mobj_t *source;
  float_t damage;
  const damage_t *damtype;
  boolean_t thrust;
}
rds_atk_info_t;

static rds_atk_info_t bomb_I;

//
// PIT_RadiusAttack
//
// "bombsource" is the creature that caused the explosion at "bombspot".
//
static boolean_t PIT_RadiusAttack(mobj_t * thing)
{
  float_t dx, dy;
  float_t dist;

  // ignore the bomb spot itself
  if (thing == bomb_I.spot)
    return true;

  if (! (thing-&gt;flags &amp; MF_SHOOTABLE))
    return true;

  // Boss types take no damage from concussion.
  // -ACB- 1998/06/14 Changed enum reference to extended flag check.
  if (thing-&gt;info-&gt;extendedflags &amp; EF_BOSSMAN)
    return true;

  dx = fabs(thing-&gt;x - bomb_I.spot-&gt;x);
  dy = fabs(thing-&gt;y - bomb_I.spot-&gt;y);

  // dist is the distance to the *edge* of the thing
  dist = MAX(dx, dy) - thing-&gt;radius;

  if (dist &lt; 0)
    dist = 0;

  if (dist &gt;= bomb_I.range)
    return true;  // out of range

  // recompute dist to be in range 0.0 (far away) to 1.0 (close)
  CHECKVAL(bomb_I.range);
  dist = (dist - bomb_I.range) / bomb_I.range;

  if (P_CheckSight(bomb_I.spot, thing))
  {
    // must be in direct path
    if (bomb_I.thrust)
      P_ThrustMobj(thing, bomb_I.spot, bomb_I.damage * dist);
    else
      P_DamageMobj(thing, bomb_I.spot, bomb_I.source, 
          bomb_I.damage * dist, bomb_I.damtype);
  }
  return true;
}
</t>
<t tx="T1856">@ PIT_SphereAttack

"bombsource" is the creature that caused the explosion at "bombspot".

-ACB- 1998/07/15 New procedure that differs for RadiusAttack -
it checks Height, therefore it is a sphere attack.

-KM- 1998/11/25 Fixed. Added z movement for rocket jumping.
@c

static boolean_t PIT_SphereAttack(mobj_t * thing)
{
  float_t dx, dy, dz;
  float_t dist;

  // ignore the bomb spot itself
  if (thing == bomb_I.spot)
    return true;

  if (!(thing-&gt;flags &amp; MF_SHOOTABLE))
    return true;

  //
  // Boss types take no damage from concussion.
  // -ACB- 1998/06/14 Changed enum reference to extended flag check.
  //
  if (thing-&gt;info-&gt;extendedflags &amp; EF_BOSSMAN)
    return true;

  // -KM- 1999/01/31 Use thing-&gt;height/2
  dx = fabs(thing-&gt;x - bomb_I.spot-&gt;x);
  dy = fabs(thing-&gt;y - bomb_I.spot-&gt;y);
  dz = fabs(MO_MIDZ(thing) - MO_MIDZ(bomb_I.spot));

  // dist is the distance to the *edge* of the thing
  dist = MAX(MAX(dx, dy) - thing-&gt;radius, dz - thing-&gt;height/2);

  if (dist &lt; 0)
    dist = 0;

  if (dist &gt;= bomb_I.range)
    return true;  // out of range

  // recompute dist to be in range 0.0 (far away) to 1.0 (close)
  CHECKVAL(bomb_I.range);
  dist = (bomb_I.range - dist) / bomb_I.range;

  if (P_CheckSight(bomb_I.spot, thing))
  {
    if (bomb_I.thrust)
      P_ThrustMobj(thing, bomb_I.spot, bomb_I.damage * dist);
    else
      P_DamageMobj(thing, bomb_I.spot, bomb_I.source, 
          bomb_I.damage * dist, bomb_I.damtype);
  }
  return true;
}
</t>
<t tx="T1857">@ P_RadiusAttack

Source is the creature that caused the explosion at spot.

Note: Damtype can be NULL.
@c

void P_RadiusAttack(mobj_t * spot, mobj_t * source, float_t radius,
    float_t damage, const damage_t * damtype, boolean_t thrust_only)
{
  int x, y;
  int xl, xh, yl, yh;

  yh = (int)(spot-&gt;y + radius - bmaporgy) / MAPBLOCKUNITS;
  yl = (int)(spot-&gt;y - radius - bmaporgy) / MAPBLOCKUNITS;
  xh = (int)(spot-&gt;x + radius - bmaporgx) / MAPBLOCKUNITS;
  xl = (int)(spot-&gt;x - radius - bmaporgx) / MAPBLOCKUNITS;

  bomb_I.range = radius;
  bomb_I.spot  = spot;
  bomb_I.source = source;
  bomb_I.damage = damage;
  bomb_I.damtype = damtype;
  bomb_I.thrust  = thrust_only;

  //
  // -ACB- 1998/07/15 This normally does damage to everything within
  //                  a radius regards of height, however true 3D uses
  //                  a sphere attack, which checks height.
  //
  if (level_flags.true3dgameplay)
  {
    for (y = yl; y &lt;= yh; y++)
      for (x = xl; x &lt;= xh; x++)
        P_BlockThingsIterator(x, y, PIT_SphereAttack);
  }
  else
  {
    for (y = yl; y &lt;= yh; y++)
      for (x = xl; x &lt;= xh; x++)
        P_BlockThingsIterator(x, y, PIT_RadiusAttack);
  }
}
</t>
<t tx="T1858">@ SECTOR HEIGHT CHANGING
@c

static boolean_t crushchange;
static boolean_t nofit;
static int crush_time;
static int crush_damage;


//
// PIT_ChangeSector
//
static boolean_t PIT_ChangeSector(mobj_t * thing)
{
  mobj_t *mo;

  if (P_ThingHeightClip(thing))
  {
    // keep checking
    return true;
  }

  // dropped items get removed by a falling ceiling
  if (thing-&gt;flags &amp; MF_DROPPED)
  {
    P_RemoveMobj(thing);
    return true;
  }

  // crunch bodies to giblets
  if (thing-&gt;health &lt;= 0)
  {
    if (thing-&gt;info-&gt;gib_state &amp;&amp; !(thing-&gt;extendedflags &amp; EF_GIBBED))
    {
      thing-&gt;extendedflags |= EF_GIBBED;
      P_SetMobjStateDeferred(thing, thing-&gt;info-&gt;gib_state, 0);
    }

    // just been crushed, isn't solid.
    thing-&gt;flags &amp;= ~MF_SOLID;

    thing-&gt;height = 0;
    thing-&gt;radius = 0;

    return true;
  }

  // if thing is not shootable, can't be crushed
  if (!(thing-&gt;flags &amp; MF_SHOOTABLE) || (thing-&gt;flags &amp; MF_NOCLIP))
    return true;

  nofit = true;

  if (crushchange &amp;&amp; !(leveltime % crush_time))
  {
    P_DamageMobj(thing, NULL, NULL, crush_damage, NULL);

    // spray blood in a random direction
    mo = P_MobjCreateObject(thing-&gt;x, thing-&gt;y, MO_MIDZ(thing),
        thing-&gt;info-&gt;blood);

    mo-&gt;mom.x = (M_Random() - 128) / 4.0;
    mo-&gt;mom.y = (M_Random() - 128) / 4.0;
  }

  // keep checking (crush other things) 
  return true;
}
</t>
<t tx="T1859">@ ChangeSectorHeights

Checks all things in the given sector which is changing height.
The original space is in f_h..c_h, and the f_dh, c_dh parameters
give the amount the space is closing.

Things will be moved vertically if they need to. When
"crushchange" is true, things that no longer fit will be crushed
(and will also set the "nofit" variable).

NOTE: the heights (f_h, c_h) currently broken.
@c

static void ChangeSectorHeights(sector_t *sec, float_t f_h,
    float_t c_h, float_t f_dh, float_t c_dh)
{
  touch_node_t *tn, *next;
  mobj_t *mo;

  crush_time   = 4;
  crush_damage = 10;

  for (tn=sec-&gt;touch_things; tn; tn=next)
  {
    // allow for thing removal
    next = tn-&gt;sec_next;
    
    mo = tn-&gt;mo;
    DEV_ASSERT2(mo);

#if 0
    bz = mo-&gt;z;
    tz = mo-&gt;z + mo-&gt;height;

    // ignore things that are not in the space (e.g. in another
    // extrafloor).
    //
    if (tz &lt; f_h-1 || bz &gt; c_h+1)
      continue;
#endif

    PIT_ChangeSector(mo);
  }
}
</t>
<t tx="T1860">@ P_CheckSolidSectorMove

Checks if the sector (and any attached extrafloors) can be moved.
Only checks againgst hitting other solid floors, things are NOT
considered here. Returns true if OK, otherwise false.
@c

boolean_t P_CheckSolidSectorMove(sector_t *sec, boolean_t is_ceiling,
    float_t dh)
{
  extrafloor_t *ef;

  if (dh == 0)
    return true;

  //
  // first check real sector
  //

  if (is_ceiling &amp;&amp; dh &lt; 0 &amp;&amp; sec-&gt;top_ef &amp;&amp;
      (sec-&gt;c_h - dh &lt; sec-&gt;top_ef-&gt;top_h))
  {
    return false;
  }
  
  if (!is_ceiling &amp;&amp; dh &gt; 0 &amp;&amp; sec-&gt;bottom_ef &amp;&amp;
      (sec-&gt;f_h + dh &gt; sec-&gt;bottom_ef-&gt;bottom_h))
  {
    return false;
  }

  // don't allow a dummy sector to go FUBAR
  if (sec-&gt;control_floors)
  {
    if (is_ceiling &amp;&amp; (sec-&gt;c_h + dh &lt; sec-&gt;f_h))
      return false;

    if (!is_ceiling &amp;&amp; (sec-&gt;f_h + dh &gt; sec-&gt;c_h))
      return false;
  }

  //
  // second, check attached extrafloors
  //
 
  for (ef = sec-&gt;control_floors; ef; ef = ef-&gt;ctrl_next)
  {
    // liquids can go anywhere, anytime
    if (ef-&gt;ef_info-&gt;type &amp; EXFL_Liquid)
      continue;
 
    // moving a thin extrafloor ?
    if (!is_ceiling &amp;&amp; ! (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick))
    {
      float_t new_h = ef-&gt;top_h + dh;

      if (dh &gt; 0 &amp;&amp; new_h &gt; (ef-&gt;higher ? ef-&gt;higher-&gt;bottom_h :
            ef-&gt;sector-&gt;c_h))
      {
        return false;
      }

      if (dh &lt; 0 &amp;&amp; new_h &lt; (ef-&gt;lower ? ef-&gt;lower-&gt;top_h :
            ef-&gt;sector-&gt;f_h))
      {
        return false;
      }
      continue;
    }

    // moving the top of a thick extrafloor ?
    if (is_ceiling &amp;&amp; (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick))
    {
      float_t new_h = ef-&gt;top_h + dh;

      if (dh &lt; 0 &amp;&amp; new_h &lt; ef-&gt;bottom_h)
        return false;
       
      if (dh &gt; 0 &amp;&amp; new_h &gt; (ef-&gt;higher ? ef-&gt;higher-&gt;bottom_h :
            ef-&gt;sector-&gt;c_h))
      {
        return false;
      }
      continue;
    }
    
    // moving the bottom of a thick extrafloor ?
    if (!is_ceiling &amp;&amp; (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick))
    {
      float_t new_h = ef-&gt;bottom_h + dh;

      if (dh &gt; 0 &amp;&amp; new_h &gt; ef-&gt;top_h)
        return false;
       
      if (dh &lt; 0 &amp;&amp; new_h &lt; (ef-&gt;lower ? ef-&gt;lower-&gt;top_h :
            ef-&gt;sector-&gt;f_h))
      {
        return false;
      }
      continue;
    }
  }

  return true;
}
</t>
<t tx="T1861">@ P_SolidSectorMove

Moves the sector and any attached extrafloors. You MUST call
P_CheckSolidSectorMove() first to check if move is possible.

Things are checked here, and will be moved if they overlap the
move. If they no longer fit and the "crush" parameter is true,
they will take damage. Returns true if at least one thing no
longers fits, otherwise false.
@c

boolean_t P_SolidSectorMove(sector_t *sec, boolean_t is_ceiling,
    float_t dh, boolean_t crush, boolean_t nocarething)
{
  extrafloor_t *ef;

  if (dh == 0)
    return false;

  crushchange = crush;
  nofit = false;

  //
  // first update real sector
  //

  if (is_ceiling)
    sec-&gt;c_h += dh;
  else
    sec-&gt;f_h += dh;

  P_RecomputeGapsAroundSector(sec);
  P_RecomputeTilesInSector(sec);
  P_FloodExtraFloors(sec);

  if (! nocarething)
  {
    if (is_ceiling)
    {
      float_t h = sec-&gt;top_ef ? sec-&gt;top_ef-&gt;top_h : sec-&gt;f_h;
      ChangeSectorHeights(sec, h, sec-&gt;c_h, 0, -dh);
    }
    else 
    {
      float_t h = sec-&gt;bottom_ef ? sec-&gt;bottom_ef-&gt;bottom_h : sec-&gt;c_h;
      ChangeSectorHeights(sec, sec-&gt;f_h, h, dh, 0);
    }
  }

  //
  // second, update attached extrafloors
  //
 
  for (ef = sec-&gt;control_floors; ef; ef = ef-&gt;ctrl_next)
  {
    if (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick)
    {
      ef-&gt;top_h = sec-&gt;c_h;
      ef-&gt;bottom_h = sec-&gt;f_h;
    }
    else
    {
      ef-&gt;top_h = ef-&gt;bottom_h = sec-&gt;f_h;
    }

    P_RecomputeGapsAroundSector(ef-&gt;sector);
    P_RecomputeTilesInSector(ef-&gt;sector);
    P_FloodExtraFloors(ef-&gt;sector);
  }

  if (! nocarething)
  {
    for (ef = sec-&gt;control_floors; ef; ef = ef-&gt;ctrl_next)
    {
      // liquids can go anywhere, anytime
      if (ef-&gt;ef_info-&gt;type &amp; EXFL_Liquid)
        continue;
   
      // moving a thin extrafloor ?
      if (!is_ceiling &amp;&amp; ! (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick))
      {
        if (dh &gt; 0)
        {
          float_t h = ef-&gt;higher ? ef-&gt;higher-&gt;bottom_h : ef-&gt;sector-&gt;c_h;
          ChangeSectorHeights(ef-&gt;sector, ef-&gt;top_h, h, dh, 0);
        }
        else if (dh &lt; 0)
        {
          float_t h = ef-&gt;lower ? ef-&gt;lower-&gt;top_h : ef-&gt;sector-&gt;f_h;
          ChangeSectorHeights(ef-&gt;sector, h, ef-&gt;top_h, 0, -dh);
        }
        continue;
      }

      // moving the top of a thick extrafloor ?
      if (is_ceiling &amp;&amp; (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick))
      {
        float_t h = ef-&gt;higher ? ef-&gt;higher-&gt;bottom_h : ef-&gt;sector-&gt;c_h;
        ChangeSectorHeights(ef-&gt;sector, ef-&gt;top_h, h, dh, 0);
        continue;
      }
      
      // moving the bottom of a thick extrafloor ?
      if (!is_ceiling &amp;&amp; (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick))
      {
        float_t h = ef-&gt;lower ? ef-&gt;lower-&gt;top_h : ef-&gt;sector-&gt;f_h;
        ChangeSectorHeights(ef-&gt;sector, h, ef-&gt;bottom_h, 0, -dh);
        continue;
      }
    }
  }

  return nofit;
}
</t>
<t tx="T1862">@ P_ChangeThingSize

Readjust things in the sector when something changes size. The
object must be currently linked into the map.
@c

void P_ChangeThingSize(mobj_t *mo)
{
  touch_node_t *tn, *next;
  sector_t *sec = mo-&gt;subsector-&gt;sector;

  for (tn=sec-&gt;touch_things; tn; tn=next)
  {
    next = tn-&gt;sec_next;
    
    DEV_ASSERT2(tn-&gt;mo);

    P_ThingHeightClip(tn-&gt;mo);
  }
}
</t>
<t tx="T1863">@ PIT_CorpseCheck

Detect a corpse that could be raised.

Based upon PIT_VileCheck: checks for any corpse within thing's radius.

-ACB- 1998/08/22
@c

static mobj_t *corpsehit;
static mobj_t *raiserobj;
static float_t raisertryx;
static float_t raisertryy;

static boolean_t PIT_CorpseCheck(mobj_t * thing)
{
  float_t maxdist;
  float_t oldradius;
  float_t oldheight;
  boolean_t check;

  if (!(thing-&gt;flags &amp; MF_CORPSE))
    return true;  // not a corpse

  if (thing-&gt;tics != -1)
    return true;  // not lying still yet

  if (thing-&gt;info-&gt;raise_state == S_NULL)
    return true;  // monster doesn't have a raise state

  // -KM- 1998/12/21 Monster can't be resurrected.
  if (thing-&gt;info-&gt;extendedflags &amp; EF_NORESURRECT)
    return true;

  // -ACB- 1998/08/06 Use raiserobj for radius info
  maxdist = thing-&gt;info-&gt;radius + raiserobj-&gt;info-&gt;radius;

  if (fabs(thing-&gt;x - raisertryx)&gt;maxdist || fabs(thing-&gt;y - raisertryy) &gt; maxdist)
    return true;  // not actually touching

  // -AJA- don't raise corpses blocked by extrafloors
  if (! P_CheckSightApproxVert(raiserobj, thing))
    return true;

  // -AJA- don't raise players unless on their side
  if (thing-&gt;player &amp;&amp; (raiserobj-&gt;info-&gt;side &amp; thing-&gt;info-&gt;side) == 0)
    return true;

  corpsehit = thing;
  corpsehit-&gt;mom.x = corpsehit-&gt;mom.y = 0;

  oldradius = corpsehit-&gt;radius;
  oldheight = corpsehit-&gt;height;

  // -ACB- 1998/08/22 Check making sure with have the correct radius &amp; height.
  corpsehit-&gt;radius = corpsehit-&gt;info-&gt;radius;
  corpsehit-&gt;height = corpsehit-&gt;info-&gt;height;

  check = P_CheckAbsPosition(corpsehit, corpsehit-&gt;x, corpsehit-&gt;y, corpsehit-&gt;z);

  // -ACB- 1998/08/22 Restore radius &amp; height: we are only checking.
  corpsehit-&gt;radius = oldradius;
  corpsehit-&gt;height = oldheight;

  if (!check)
    return true;  // doesn't fit here

  // got one, so stop checking
  return false;
}
</t>
<t tx="T1864">@ P_MapFindCorpse

Used to detect corpses that have a raise state and therefore can be
raised. Arch-Viles (Raisers in-general) use this procedure to pick
their corpse. NULL is returned if no corpse is found, if one is
found it is returned.

-ACB- 1998/08/22
@c

mobj_t *P_MapFindCorpse(mobj_t * thing)
{
  int xlow, xhigh, xcount, ylow, yhigh, ycount;

  if (thing-&gt;movedir != DI_NODIR)
  {
    raiserobj = thing;

    // check for corpses to raise
    raisertryx = thing-&gt;x + thing-&gt;speed * xspeed[thing-&gt;movedir];
    raisertryy = thing-&gt;y + thing-&gt;speed * yspeed[thing-&gt;movedir];

    xlow = (raisertryx - bmaporgx - MAXRADIUS * 2) / MAPBLOCKUNITS;
    xhigh = (raisertryx - bmaporgx + MAXRADIUS * 2) / MAPBLOCKUNITS;
    ylow = (raisertryy - bmaporgy - MAXRADIUS * 2) / MAPBLOCKUNITS;
    yhigh = (raisertryy - bmaporgy + MAXRADIUS * 2) / MAPBLOCKUNITS;

    for (xcount = xlow; xcount &lt;= xhigh; xcount++)
      for (ycount = ylow; ycount &lt;= yhigh; ycount++)
        if (!P_BlockThingsIterator(xcount, ycount, PIT_CorpseCheck))
          return corpsehit;  // got one - return it
  }

  return NULL;
}
</t>
<t tx="T1865">@ PIT_CheckBlockingLine

Used for checking that any movement between one set of coordinates does not cross
blocking lines. If the line is twosided and has no restrictions, the move is
allowed; the next check is to check the respective bounding boxes, see if any
contact is made and the check is made to see if the objects are on different
sides of the line.

-ACB- 1998/08/23

-AJA- 1999/09/30: Updated for extra floors.
@c

static boolean_t crosser;

// Moving Object x,y cordinates
// for object one and object two.

static float_t mx1;
static float_t my1;
static float_t mx2;
static float_t my2;

// spawn object base
static float_t mb2;

// spawn object top
static float_t mt2;

static boolean_t PIT_CheckBlockingLine(line_t * line)
{
  int i;

  // -KM- 1999/01/31 Changed &amp;&amp;s to ||s.  This condition actually does something
  //  now.
  if (tmbbox[BOXRIGHT] &lt;= line-&gt;bbox[BOXLEFT] ||
      tmbbox[BOXLEFT] &gt;= line-&gt;bbox[BOXRIGHT] ||
      tmbbox[BOXTOP] &lt;= line-&gt;bbox[BOXBOTTOM] ||
      tmbbox[BOXBOTTOM] &gt;= line-&gt;bbox[BOXTOP])
  {
    // no possible contact made between the respective bounding boxes.
    return true;
  }

  // if the result is the same, we haven't crossed the line.
  if (PointOnLineSide(mx1, my1, line) == PointOnLineSide(mx2, my2, line))
    return true;

  // -KM- 1999/01/31 Save ceilingline for bounce.
  if ((crosser &amp;&amp; (line-&gt;flags &amp; ML_ShootBlock)) || 
      (!crosser &amp;&amp; (line-&gt;flags &amp; (ML_Blocking | ML_BlockMonsters))))
  {
    blockline = line;
    return false;
  }

  if (!(line-&gt;flags &amp; ML_TwoSided) || line-&gt;gap_num == 0)
  {
    blockline = line;
    return false;
  }

  for (i = 0; i &lt; line-&gt;gap_num; i++)
  {
    // gap with no restriction ?
    if (line-&gt;gaps[i].f &lt;= mb2 &amp;&amp; mt2 &lt;= line-&gt;gaps[i].c)
      return true;
  }

  // stop checking, objects are on different sides of a blocking line
  blockline = line;
  return false;
}
</t>
<t tx="T1866">@ P_MapCheckBlockingLine

Checks for a blocking line between thing and the spawnthing coordinates
given. Return true if there is a line; crossable indicates whether or not
whether the ML_BLOCKING &amp; ML_BLOCKMONSTERS should be ignored or not.

-ACB- 1998/08/23
@c

boolean_t P_MapCheckBlockingLine(mobj_t * thing, mobj_t * spawnthing)
{
  int xlow, xhigh, xcount, ylow, yhigh, ycount;

  mx1 = thing-&gt;x;
  my1 = thing-&gt;y;
  mx2 = spawnthing-&gt;x;
  my2 = spawnthing-&gt;y;
  mb2 = spawnthing-&gt;z;
  mt2 = spawnthing-&gt;z + spawnthing-&gt;height;

  crosser = (spawnthing-&gt;extendedflags &amp; EF_CROSSLINES);

  tmbbox[BOXLEFT] = mx1 &lt; mx2 ? mx1 : mx2;
  tmbbox[BOXRIGHT] = mx1 &gt; mx2 ? mx1 : mx2;
  tmbbox[BOXBOTTOM] = my1 &lt; my2 ? my1 : my2;
  tmbbox[BOXTOP] = my1 &gt; my2 ? my1 : my2;

  xlow = (tmbbox[BOXLEFT] - bmaporgx) / MAPBLOCKUNITS;
  xhigh = (tmbbox[BOXRIGHT] - bmaporgx) / MAPBLOCKUNITS;
  ylow = (tmbbox[BOXBOTTOM] - bmaporgy) / MAPBLOCKUNITS;
  yhigh = (tmbbox[BOXTOP] - bmaporgy) / MAPBLOCKUNITS;

  validcount++;

  mobj_hit_sky = false;
  blockline = NULL;

  for (xcount = xlow; xcount &lt;= xhigh; xcount++)
    for (ycount = ylow; ycount &lt;= yhigh; ycount++)
      if (!P_BlockLinesIterator(xcount, ycount, PIT_CheckBlockingLine))
        return true;

  return false;
}
</t>
<t tx="T1867">@ P_MapInit
@c

boolean_t P_MapInit(void)
{
  Z_InitStackArray(&amp;spechit_a, (void***)&amp;spechit, sizeof(line_t *), -8);

  return true;
}
</t>
<t tx="T1868">@ignore
@language c

// Movement, Collision &amp; Blockmap utility functions

// DESCRIPTION:
//   Movement/collision utility functions,
//   as used by function in p_map.c. 
//   BLOCKMAP Iterator functions,
//   and some PIT_* functions to use for iteration.
//   Gap/extrafloor utility functions.
//   Touch Node code.

// TODO HERE:
//   + make gap routines I_Error if overflow limit.

&lt;&lt; p_maputl #includes &gt;&gt;
&lt;&lt; p_maputl declarations &gt;&gt;
@others
</t>
<t tx="T1869">#include "i_defs.h"

#include "m_bbox.h"
#include "dm_defs.h"
#include "p_local.h"
#include "p_spec.h"

#include "z_zone.h"
</t>
<t tx="T1870">
// State.
#include "r_state.h"

// stats
#ifdef DEVELOPERS
int touchstat_moves;
int touchstat_hit;
int touchstat_miss;
int touchstat_alloc;
int touchstat_free;
#endif

// quick-alloc list
// FIXME: incorporate into FlushCaches
touch_node_t *free_touch_nodes;
</t>
<t tx="T1871">@ P_ApproxDistance

Gives an estimation of distance (not exact)
@c

float_t P_ApproxDistance(float_t dx, float_t dy)
{
  dx = fabs(dx);
  dy = fabs(dy);

  if (dx &lt; dy)
    return dx / 2 + dy;

  return dx + dy / 2;
}
</t>
<t tx="T1872">@ P_ApproxSlope

Gives an estimation of slope (not exact)

-AJA- 1999/09/11: written.
@c

float_t P_ApproxSlope(float_t dx, float_t dy, float_t dz)
{
  float_t dist = P_ApproxDistance(dx, dy);

  // kludge to prevent overflow or division by zero.
  if (dist &lt; 1.0 / 32)
    dist = 1.0 / 32;

  return dz / dist;
}
</t>
<t tx="T1873">@ P_PointOnDivlineSide

Tests which side of the line the given point lies on.
Returns 0 (front/right) or 1 (back/left). If the point lies
directly on the line, result is undefined (either 0 or 1).
@c

int P_PointOnDivlineSide(float_t x, float_t y, divline_t *div)
{
  float_t dx, dy;
  float_t left, right;

  if (div-&gt;dx == 0)
    return ((x &lt;= div-&gt;x) ^ (div-&gt;dy &gt; 0)) ? 0 : 1;

  if (div-&gt;dy == 0)
    return ((y &lt;= div-&gt;y) ^ (div-&gt;dx &lt; 0)) ? 0 : 1;

  dx = x - div-&gt;x;
  dy = y - div-&gt;y;

  // try to quickly decide by looking at sign bits
  if ((div-&gt;dy &lt; 0) ^ (div-&gt;dx &lt; 0) ^ (dx &lt; 0) ^ (dy &lt; 0))
  {
    // left is negative
    if ((div-&gt;dy &lt; 0) ^ (dx &lt; 0))
      return 1;

    return 0;
  }

  left  = dx * div-&gt;dy;
  right = dy * div-&gt;dx;

  return (right &lt; left) ? 0 : 1;
}
</t>
<t tx="T1874">@ P_PointOnDivlineThick

Tests which side of the line the given point is on.  The thickness
parameter determines when the point is considered "on" the line.
Returns 0 (front/right), 1 (back/left), or 2 (on).
@c

int P_PointOnDivlineThick(float_t x, float_t y, divline_t *div,
    float_t div_len, float_t thickness)
{
  float_t dx, dy;
  float_t left, right;

  if (div-&gt;dx == 0)
  {
    if (fabs(x - div-&gt;x) &lt;= thickness)
      return 2;

    return ((x &lt; div-&gt;x) ^ (div-&gt;dy &gt; 0)) ? 0 : 1;
  }

  if (div-&gt;dy == 0)
  {
    if (fabs(y - div-&gt;y) &lt;= thickness)
      return 2;

    return ((y &lt; div-&gt;y) ^ (div-&gt;dx &lt; 0)) ? 0 : 1;
  }

  dx = x - div-&gt;x;
  dy = y - div-&gt;y;

  // need divline's length here to compute proper distances
  left  = (dx * div-&gt;dy) / div_len;
  right = (dy * div-&gt;dx) / div_len;

  if (fabs(left - right) &lt; thickness)
    return 2;

  return (right &lt; left) ? 0 : 1;
}
</t>
<t tx="T1875">@ P_BoxOnLineSide

Considers the line to be infinite
Returns side 0 or 1, -1 if box crosses the line.
@c

int P_BoxOnLineSide(float_t * tmbox, line_t * ld)
{
  int p1 = 0;
  int p2 = 0;

  divline_t div;
  
  div.x = ld-&gt;v1-&gt;x;
  div.y = ld-&gt;v1-&gt;y;
  div.dx = ld-&gt;dx;
  div.dy = ld-&gt;dy;

  switch (ld-&gt;slopetype)
  {
    case ST_HORIZONTAL:
      p1 = tmbox[BOXTOP] &gt; ld-&gt;v1-&gt;y;
      p2 = tmbox[BOXBOTTOM] &gt; ld-&gt;v1-&gt;y;
      if (ld-&gt;dx &lt; 0)
      {
        p1 ^= 1;
        p2 ^= 1;
      }
      break;

    case ST_VERTICAL:
      p1 = tmbox[BOXRIGHT] &lt; ld-&gt;v1-&gt;x;
      p2 = tmbox[BOXLEFT] &lt; ld-&gt;v1-&gt;x;
      if (ld-&gt;dy &lt; 0)
      {
        p1 ^= 1;
        p2 ^= 1;
      }
      break;

    case ST_POSITIVE:
      p1 = P_PointOnDivlineSide(tmbox[BOXLEFT], tmbox[BOXTOP], &amp;div);
      p2 = P_PointOnDivlineSide(tmbox[BOXRIGHT], tmbox[BOXBOTTOM], &amp;div);
      break;

    case ST_NEGATIVE:
      p1 = P_PointOnDivlineSide(tmbox[BOXRIGHT], tmbox[BOXTOP], &amp;div);
      p2 = P_PointOnDivlineSide(tmbox[BOXLEFT], tmbox[BOXBOTTOM], &amp;div);
      break;
  }

  if (p1 == p2)
    return p1;

  return -1;
}
</t>
<t tx="T1876">@ P_BoxOnDivLineSide

Considers the line to be infinite
Returns side 0 or 1, -1 if box crosses the line.
@c

static int P_BoxOnDivLineSide(float_t * tmbox, divline_t *div)
{
  int p1 = 0;
  int p2 = 0;

  if (div-&gt;dy == 0)
  {
    p1 = tmbox[BOXTOP] &gt; div-&gt;y;
    p2 = tmbox[BOXBOTTOM] &gt; div-&gt;y;

    if (div-&gt;dx &lt; 0)
    {
      p1 ^= 1;
      p2 ^= 1;
    }
  }
  else if (div-&gt;dx == 0)
  {
    p1 = tmbox[BOXRIGHT] &lt; div-&gt;x;
    p2 = tmbox[BOXLEFT] &lt; div-&gt;x;

    if (div-&gt;dy &lt; 0)
    {
      p1 ^= 1;
      p2 ^= 1;
    }
  }
  else if (div-&gt;dy / div-&gt;dx &gt; 0)  // optimise ?
  {
    p1 = P_PointOnDivlineSide(tmbox[BOXLEFT], tmbox[BOXTOP], div);
    p2 = P_PointOnDivlineSide(tmbox[BOXRIGHT], tmbox[BOXBOTTOM], div);
  }
  else
  {
    p1 = P_PointOnDivlineSide(tmbox[BOXRIGHT], tmbox[BOXTOP], div);
    p2 = P_PointOnDivlineSide(tmbox[BOXLEFT], tmbox[BOXBOTTOM], div);
  }

  if (p1 == p2)
    return p1;

  return -1;
}
</t>
<t tx="T1877">@ P_InterceptVector

Returns the fractional intercept point along the first divline.
This is only called by the addthings and addlines traversers.
@c

float_t P_InterceptVector(divline_t * v2, divline_t * v1)
{
  float_t frac;
  float_t num;
  float_t den;
  float_t v1x;
  float_t v1y;
  float_t v1dx;
  float_t v1dy;
  float_t v2x;
  float_t v2y;
  float_t v2dx;
  float_t v2dy;

  v1x = v1-&gt;x;
  v1y = v1-&gt;y;
  v1dx = v1-&gt;dx;
  v1dy = v1-&gt;dy;
  v2x = v2-&gt;x;
  v2y = v2-&gt;y;
  v2dx = v2-&gt;dx;
  v2dy = v2-&gt;dy;

  den = v1dy * v2dx - v1dx * v2dy;

  if (den == 0)
    return 0;  // parallel

  num = (v1x - v2x) * v1dy + (v2y - v1y) * v1dx;
  frac = num / den;

  return frac;
}
</t>
<t tx="T1878">@ GAP UTILITY FUNCTIONS
@c

static int GAP_RemoveSolid(vgap_t * dest, int d_num, float_t z1, float_t z2)
{
  int d;
  int new_num = 0;
  vgap_t new_gaps[100];

#ifdef DEVELOPERS
  if (z1 &gt; z2)
    I_Error("RemoveSolid: z1 &gt; z2");
#endif

  for (d = 0; d &lt; d_num; d++)
  {
    if (dest[d].c &lt;= dest[d].f)
      continue;  // ignore empty gaps.

    if (z1 &lt;= dest[d].f &amp;&amp; z2 &gt;= dest[d].c)
      continue;  // completely blocks it.

    if (z1 &gt;= dest[d].c || z2 &lt;= dest[d].f)
    {
      // no intersection.

      new_gaps[new_num].f = dest[d].f;
      new_gaps[new_num].c = dest[d].c;
      new_num++;
      continue;
    }

    // partial intersections.

    if (z1 &gt; dest[d].f)
    {
      new_gaps[new_num].f = dest[d].f;
      new_gaps[new_num].c = z1;
      new_num++;
    }

    if (z2 &lt; dest[d].c)
    {
      new_gaps[new_num].f = z2;
      new_gaps[new_num].c = dest[d].c;
      new_num++;
    }
  }

  Z_MoveData(dest, new_gaps, vgap_t, new_num);

  return new_num;
}
</t>
<t tx="T1879">
static int GAP_Construct(vgap_t * gaps, sector_t * sec, mobj_t * thing)
{
  extrafloor_t * ef;

  int num = 1;

  // early out for FUBAR sectors
  if (sec-&gt;f_h &gt;= sec-&gt;c_h)
    return 0;

  gaps[0].f = sec-&gt;f_h;
  gaps[0].c = sec-&gt;c_h;

  for (ef = sec-&gt;bottom_ef; ef; ef = ef-&gt;higher)
  {
    num = GAP_RemoveSolid(gaps, num, ef-&gt;bottom_h, ef-&gt;top_h);
  }

  // -- handle WATER WALKERS --

  if (!thing || !(thing-&gt;extendedflags &amp; EF_WATERWALKER))
    return num;
  
  for (ef = sec-&gt;bottom_liq; ef; ef = ef-&gt;higher)
  {
    if (ef-&gt;ef_info &amp;&amp; (ef-&gt;ef_info-&gt;type &amp; EXFL_Water))
    {
      num = GAP_RemoveSolid(gaps, num, ef-&gt;bottom_h, ef-&gt;top_h);
    }
  }
  
  return num;
}
</t>
<t tx="T1880">
static int GAP_SightConstruct(vgap_t * gaps, sector_t * sec)
{
  extrafloor_t * ef;

  int num = 1;

  // early out for closed or FUBAR sectors
  if (sec-&gt;c_h &lt;= sec-&gt;f_h)
    return 0;

  gaps[0].f = sec-&gt;f_h;
  gaps[0].c = sec-&gt;c_h;

  for (ef = sec-&gt;bottom_ef; ef; ef = ef-&gt;higher)
  {
    if (!ef-&gt;ef_info || !(ef-&gt;ef_info-&gt;type &amp; EXFL_SeeThrough))
      num = GAP_RemoveSolid(gaps, num, ef-&gt;bottom_h, ef-&gt;top_h);
  }

  for (ef = sec-&gt;bottom_liq; ef; ef = ef-&gt;higher)
  {
    if (!ef-&gt;ef_info || !(ef-&gt;ef_info-&gt;type &amp; EXFL_SeeThrough))
      num = GAP_RemoveSolid(gaps, num, ef-&gt;bottom_h, ef-&gt;top_h);
  }
  
  return num;
}
</t>
<t tx="T1881">
static int GAP_Restrict(vgap_t * dest, int d_num, vgap_t * src, int s_num)
{
  int d, s;
  float_t f, c;

  int new_num = 0;
  vgap_t new_gaps[32];

  for (s = 0; s &lt; s_num; s++)
  {
    // ignore empty gaps.
    if (src[s].c &lt;= src[s].f)
      continue;

    for (d = 0; d &lt; d_num; d++)
    {
      // ignore empty gaps.
      if (dest[d].c &lt;= dest[d].f)
        continue;

      f = MAX(src[s].f, dest[d].f);
      c = MIN(src[s].c, dest[d].c);

      if (f &lt; c)
      {
        new_gaps[new_num].c = c;
        new_gaps[new_num].f = f;
        new_num++;
      }
    }
  }

  Z_MoveData(dest, new_gaps, vgap_t, new_num);

  return new_num;
}
</t>
<t tx="T1882">
#ifdef DEVELOPERS
static void GAP_Dump(vgap_t *gaps, int num)
{
  int j;

  for (j=0; j &lt; num; j++)
    L_WriteDebug("  GAP %d/%d  %1.1f .. %1.1f\n", j+1, num,
        gaps[j].f, gaps[j].c);
}
</t>
<t tx="T1883">#endif

//
// P_FindThingGap
//
// Find the best gap that the thing could fit in, given a certain Z
// position (z1 is foot, z2 is head).  Assuming at least two gaps exist,
// the best gap is chosen as follows:
//
// 1. if the thing fits in one of the gaps without moving vertically,
//    then choose that gap.
//
// 2. if there is only *one* gap which the thing could fit in, then
//    choose that gap.
//
// 3. if there is multiple gaps which the thing could fit in, choose
//    the gap whose floor is closest to the thing's current Z.
//
// 4. if there is no gaps which the thing could fit in, do the same.
//
// Returns the gap number, or -1 if there are no gaps at all.
//
int P_FindThingGap(vgap_t * gaps, int gap_num, float_t z1, float_t z2)
{
  int i;
  float_t dist;

  int fit_num = 0;
  int fit_last = -1;

  int fit_closest = -1;
  float_t fit_mindist = INT_MAX;

  int nofit_closest = -1;
  float_t nofit_mindist = INT_MAX;

  // check for trivial gaps...

  if (gap_num == 0)
  {
    return -1;
  }
  else if (gap_num == 1)
  {
    return 0;
  }

  // There are 2 or more gaps.  Now it gets interesting :-)

  for (i = 0; i &lt; gap_num; i++)
  {
    if (z1 &gt;= gaps[i].f &amp;&amp; z2 &lt;= gaps[i].c)
    { // [1]
      return i;
    }

    dist = ABS(z1 - gaps[i].f);

    if (z2 - z1 &lt;= gaps[i].c - gaps[i].f)
    { // [2]
      fit_num++;

      fit_last = i;
      if (dist &lt; fit_mindist)
      { // [3]
        fit_mindist = dist;
        fit_closest = i;
      }
    }
    else
    {
      if (dist &lt; nofit_mindist)
      { // [4]
        nofit_mindist = dist;
        nofit_closest = i;
      }
    }
  }

  if (fit_num == 1)
    return fit_last;
  else if (fit_num &gt; 1)
    return fit_closest;
  else
    return nofit_closest;
}
</t>
<t tx="T1884">@ P_ComputeThingGap

Determine the initial floorz and ceilingz that a thing placed at a
particular Z would have. Returns the nominal Z height. Some special
values of Z are recognised: ONFLOORZ &amp; ONCEILINGZ.
@c

float_t P_ComputeThingGap(mobj_t * thing, sector_t * sec, float_t z,
    float_t * f, float_t * c)
{
  vgap_t temp_gaps[100];
  int temp_num;

  temp_num = GAP_Construct(temp_gaps, sec, thing);

  if (z == ONFLOORZ)
    z = sec-&gt;f_h;

  if (z == ONCEILINGZ)
    z = sec-&gt;c_h - thing-&gt;height;

  temp_num = P_FindThingGap(temp_gaps, temp_num, z, z + thing-&gt;height);

  if (temp_num &lt; 0)
  {
    // thing is stuck in a closed door.
    *f = *c = sec-&gt;f_h;
    return *f;
  }

  *f = temp_gaps[temp_num].f;
  *c = temp_gaps[temp_num].c;

  return z;
}
</t>
<t tx="T1885">@ P_ComputeGaps

Determine the gaps between the front &amp; back sectors of the line,
taking into account any extra floors.

-AJA- 1999/07/19: This replaces P_LineOpening.
@c

void P_ComputeGaps(line_t * ld)
{
  sector_t *front = ld-&gt;frontsector;
  sector_t *back  = ld-&gt;backsector;

  int temp_num;
  vgap_t temp_gaps[100];

  ld-&gt;blocked = true;
  ld-&gt;gap_num = 0;

  if (!front || !back)
  {
    // single sided line
    return;
  }

  if (MAX(front-&gt;f_h, back-&gt;f_h) &gt;= MIN(front-&gt;c_h, back-&gt;c_h))
  {
    // closed door.
    return;
  }
  
  // FIXME: strictly speaking this is not correct, as the front or
  // back sector may be filled up with thick opaque extrafloors.
  //
  ld-&gt;blocked = false;

  // handle horizontal sliders
  if (ld-&gt;special &amp;&amp; ld-&gt;special-&gt;s.type != SLIDE_None)
  {
    slider_move_t *smov = ld-&gt;slider_move;

    if (! smov)
      return;
    
    // these semantics copied from XDoom
    if (smov-&gt;direction &gt; 0 &amp;&amp; smov-&gt;opening &lt; smov-&gt;target * 0.5)
      return;

    if (smov-&gt;direction &lt; 0 &amp;&amp; smov-&gt;opening &lt; smov-&gt;target * 0.75)
      return;
  }
 
  // handle normal gaps ("movement" gaps)
  
  ld-&gt;gap_num = GAP_Construct(ld-&gt;gaps, front, NULL);
  temp_num = GAP_Construct(temp_gaps, back, NULL);

  ld-&gt;gap_num = GAP_Restrict(ld-&gt;gaps, ld-&gt;gap_num, temp_gaps, temp_num);
}
</t>
<t tx="T1886">@ P_DumpExtraFloors
@c

#ifdef DEVELOPERS
void P_DumpExtraFloors(const sector_t *sec)
{
  const extrafloor_t *ef;

  L_WriteDebug("EXTRAFLOORS IN Sector %d  (%d used, %d max)\n",
      sec - sectors, sec-&gt;exfloor_used, sec-&gt;exfloor_max);

  L_WriteDebug("  Basic height: %1.1f .. %1.1f\n", sec-&gt;f_h, sec-&gt;c_h);

  for (ef = sec-&gt;bottom_ef; ef; ef = ef-&gt;higher)
  {
    L_WriteDebug("  Solid %s: %1.1f .. %1.1f\n",
        (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick) ? "Thick" : "Thin",
        ef-&gt;bottom_h, ef-&gt;top_h);
  }

  for (ef = sec-&gt;bottom_liq; ef; ef = ef-&gt;higher)
  {
    L_WriteDebug("  Liquid %s: %1.1f .. %1.1f\n",
        (ef-&gt;ef_info-&gt;type &amp; EXFL_Thick) ? "Thick" : "Thin",
        ef-&gt;bottom_h, ef-&gt;top_h);
  }
}
</t>
<t tx="T1887">#endif

//
// P_ExtraFloorFits
//
// Check if a solid extrafloor fits.
//
exfloor_fit_e P_ExtraFloorFits(sector_t *sec, float_t z1, float_t z2)
{
  extrafloor_t *ef;

  if (z2 &gt; sec-&gt;c_h)
    return EXFIT_StuckInCeiling;

  if (z1 &lt; sec-&gt;f_h)
    return EXFIT_StuckInFloor;

  for (ef=sec-&gt;bottom_ef; ef &amp;&amp; ef-&gt;higher; ef=ef-&gt;higher)
  {
    float_t bottom = ef-&gt;bottom_h;
    float_t top = ef-&gt;top_h;

    DEV_ASSERT2(top &gt;= bottom);

    // here is another solid extrafloor, check for overlap
    if (z2 &gt; bottom &amp;&amp; z1 &lt; top)
      return EXFIT_StuckInExtraFloor;
  }

  return EXFIT_Ok;
}
</t>
<t tx="T1888">@ P_AddExtraFloor
@c

void P_AddExtraFloor(sector_t *sec, line_t *line)
{
  sector_t *ctrl = line-&gt;frontsector;
  const extrafloor_info_t *ef_info;

  surface_t *top, *bottom;
  extrafloor_t *newbie, *cur;

  boolean_t liquid;
  exfloor_fit_e errcode;

  DEV_ASSERT2(line-&gt;special);
  DEV_ASSERT2(line-&gt;special-&gt;ef.type &amp; EXFL_Present);

  ef_info = &amp;line-&gt;special-&gt;ef;

  //
  // -- create new extrafloor --
  // 
  
  DEV_ASSERT2(sec-&gt;exfloor_used &lt;= sec-&gt;exfloor_max);
  
  if (sec-&gt;exfloor_used == sec-&gt;exfloor_max)
    I_Error("INTERNAL ERROR: extrafloor overflow in sector %d\n",
        (int)(sec - sectors));

  newbie = sec-&gt;exfloor_first + sec-&gt;exfloor_used;
  sec-&gt;exfloor_used++;

  Z_Clear(newbie, extrafloor_t, 1);

  bottom = &amp;ctrl-&gt;floor;
  top = (ef_info-&gt;type &amp; EXFL_Thick) ? &amp;ctrl-&gt;ceil : bottom;

  newbie-&gt;bottom_h = ctrl-&gt;f_h;
  newbie-&gt;top_h = (ef_info-&gt;type &amp; EXFL_Thick) ? ctrl-&gt;c_h : newbie-&gt;bottom_h;

  if (newbie-&gt;top_h &lt; newbie-&gt;bottom_h)
    I_Error("Bad Extrafloor in sector #%d: "
        "z range is %1.0f / %1.0f\n", (int)(sec - sectors),
        newbie-&gt;bottom_h, newbie-&gt;top_h);

  newbie-&gt;sector = sec;
  newbie-&gt;top = top;
  newbie-&gt;bottom = bottom;

  newbie-&gt;p = &amp;ctrl-&gt;props;
  newbie-&gt;ef_info = ef_info;
  newbie-&gt;ef_line = line;

  // Insert into the dummy's linked list
  newbie-&gt;ctrl_next = ctrl-&gt;control_floors;
  ctrl-&gt;control_floors = newbie;

  //
  // -- handle liquid extrafloors --
  //

  liquid = (ef_info-&gt;type &amp; EXFL_Liquid);

  if (liquid)
  {
    // find place to link into.  cur will be the next higher liquid,
    // or NULL if this is the highest.

    for (cur=sec-&gt;bottom_liq; cur; cur=cur-&gt;higher)
    {
      if (cur-&gt;bottom_h &gt; newbie-&gt;bottom_h)
        break;
    }

    newbie-&gt;higher = cur;
    newbie-&gt;lower = cur ? cur-&gt;lower : sec-&gt;top_liq;
    
    if (newbie-&gt;higher)
      newbie-&gt;higher-&gt;lower = newbie;
    else
      sec-&gt;top_liq = newbie;

    if (newbie-&gt;lower)
      newbie-&gt;lower-&gt;higher = newbie;
    else
      sec-&gt;bottom_liq = newbie;

    return;
  }
    
  //
  // -- handle solid extrafloors --
  //
  
  // check if fits
  errcode = P_ExtraFloorFits(sec, newbie-&gt;bottom_h, newbie-&gt;top_h);

  switch (errcode)
  {
    case EXFIT_Ok:
      break;

    case EXFIT_StuckInCeiling:
      I_Error("Extrafloor with z range of %1.0f / %1.0f is stuck "
              "in sector #%d's ceiling.\n",
               newbie-&gt;bottom_h, newbie-&gt;top_h, (int)(sec - sectors));
   
    case EXFIT_StuckInFloor:
      I_Error("Extrafloor with z range of %1.0f / %1.0f is stuck "
              "in sector #%d's floor.\n",
               newbie-&gt;bottom_h, newbie-&gt;top_h, (int)(sec - sectors));

    default:
      I_Error("Extrafloor with z range of %1.0f / %1.0f is stuck "
              "in sector #%d in another extrafloor.\n",
               newbie-&gt;bottom_h, newbie-&gt;top_h, (int)(sec - sectors));
  }

  // find place to link into.  cur will be the next higher extrafloor,
  // or NULL if this is the highest.

  for (cur=sec-&gt;bottom_ef; cur; cur=cur-&gt;higher)
  {
    if (cur-&gt;bottom_h &gt; newbie-&gt;bottom_h)
      break;
  }

  newbie-&gt;higher = cur;
  newbie-&gt;lower = cur ? cur-&gt;lower : sec-&gt;top_ef;
 
  if (newbie-&gt;higher)
    newbie-&gt;higher-&gt;lower = newbie;
  else
    sec-&gt;top_ef = newbie;

  if (newbie-&gt;lower)
    newbie-&gt;lower-&gt;higher = newbie;
  else
    sec-&gt;bottom_ef = newbie;
}
</t>
<t tx="T1889">@ P_FloodExtraFloors
@c

void P_FloodExtraFloors(sector_t *sector)
{
  extrafloor_t *S, *L, *C;

  region_properties_t *props;
  region_properties_t *flood_p = NULL, *last_p = NULL;

  sector-&gt;p = &amp;sector-&gt;props;

  // traverse downwards, stagger both lists
  S = sector-&gt;top_ef;
  L = sector-&gt;top_liq;

  while (S || L)
  {
    if (!L || (S &amp;&amp; S-&gt;bottom_h &gt; L-&gt;bottom_h))
    {
      C = S;  S = S-&gt;lower;
    }
    else
    {
      C = L;  L = L-&gt;lower;
    }

    DEV_ASSERT2(C);

    props = &amp;C-&gt;ef_line-&gt;frontsector-&gt;props;

    if (C-&gt;ef_info-&gt;type &amp; EXFL_Flooder)
    {
      C-&gt;p = last_p = flood_p = props;

      if ((C-&gt;ef_info-&gt;type &amp; EXFL_Liquid) &amp;&amp; C-&gt;bottom_h &gt;= sector-&gt;c_h)
        sector-&gt;p = flood_p;

      continue;
    }

    if (C-&gt;ef_info-&gt;type &amp; EXFL_NoShade)
    {
      if (! last_p)
        last_p = props;

      C-&gt;p = last_p;
      continue;
    }

    C-&gt;p = last_p = flood_p ? flood_p : props;
  }
}
</t>
<t tx="T1890">

static INLINE void AddWallTile(side_t *sd, float_t z1, float_t z2,
    float_t tex_z, surface_t *surface, int flags)
{
  wall_tile_t *wt;
    
  if (! surface-&gt;image)
    return;
   
  if (sd-&gt;tile_used &gt;= sd-&gt;tile_max)
    return;

  wt = sd-&gt;tiles + sd-&gt;tile_used;
  sd-&gt;tile_used++;

  wt-&gt;z1 = z1;
  wt-&gt;z2 = z2;
  wt-&gt;tex_z = tex_z;
  wt-&gt;surface = surface;
  wt-&gt;flags = flags;
}
</t>
<t tx="T1891">@ P_ComputeWallTiles
@c

void P_ComputeWallTiles(line_t *ld, int sidenum)
{
  side_t *sd = ld-&gt;side[sidenum];
  sector_t *sec, *other;
  surface_t *surf;

  extrafloor_t *S, *L, *C;
  float_t floor_h;
  float_t tex_z;

  boolean_t lower_invis = false;
  boolean_t upper_invis = false;


  if (! sd)
    return;

  sec = sd-&gt;sector;
  other = sidenum ? ld-&gt;frontsector : ld-&gt;backsector;

  // clear existing tiles
  sd-&gt;tile_used = 0;

  if (! other)
  {
    if (! sd-&gt;middle.image)
      return;

    AddWallTile(sd, sec-&gt;f_h, sec-&gt;c_h, 
        (ld-&gt;flags &amp; ML_LowerUnpegged) ? 
        sec-&gt;f_h + IM_HEIGHT(sd-&gt;middle.image) : sec-&gt;c_h,
        &amp;sd-&gt;middle, 0);
    return;
  }

  // handle lower, upper and mid-masker
 
  if (sec-&gt;f_h &lt; other-&gt;f_h)
  {
    if (sd-&gt;bottom.image)
      AddWallTile(sd, sec-&gt;f_h, other-&gt;f_h, 
          (ld-&gt;flags &amp; ML_LowerUnpegged) ? sec-&gt;c_h : other-&gt;f_h,
          &amp;sd-&gt;bottom, 0);
    else
      lower_invis = true;
  }

  if (sec-&gt;c_h &gt; other-&gt;c_h &amp;&amp;
      ! (IS_SKY(sec-&gt;ceil) &amp;&amp; IS_SKY(other-&gt;ceil)))
  {
    if (sd-&gt;top.image)
      AddWallTile(sd, other-&gt;c_h, sec-&gt;c_h, 
          (ld-&gt;flags &amp; ML_UpperUnpegged) ? sec-&gt;c_h : 
          other-&gt;c_h + IM_HEIGHT(sd-&gt;top.image), &amp;sd-&gt;top, 0);
    else
      upper_invis = true;
  }

  if (sd-&gt;middle.image)
  {
    float_t f1 = MAX(sec-&gt;f_h, other-&gt;f_h);
    float_t c1 = MIN(sec-&gt;c_h, other-&gt;c_h);

    float_t f2, c2;

    if (ld-&gt;flags &amp; ML_LowerUnpegged)
    {
      f2 = f1 + sd-&gt;midmask_offset;
      c2 = f2 + IM_HEIGHT(sd-&gt;middle.image);
    }
    else
    {
      c2 = c1 + sd-&gt;midmask_offset;
      f2 = c2 - IM_HEIGHT(sd-&gt;middle.image);
    }

    tex_z = c2;
 
    // hack for transparent doors
    {
      if (lower_invis) f1 = sec-&gt;f_h;
      if (upper_invis) c1 = sec-&gt;c_h;
    }

    f2 = MAX(f2, f1);
    c2 = MIN(c2, c1);

    if (c2 &gt; f2)
    {
      AddWallTile(sd, f2, c2, tex_z, &amp;sd-&gt;middle, WTILF_MidMask);
    }
  }
   
  // -- thick extrafloor sides --
  
  // -AJA- Don't bother drawing extrafloor sides if the front/back
  //       sectors have the same tag (and thus the same extrafloors).
  //
  if (other-&gt;tag == sec-&gt;tag)
    return;
 
  floor_h = other-&gt;f_h;

  S = other-&gt;bottom_ef;
  L = other-&gt;bottom_liq;

  while (S || L)
  {
    if (!L || (S &amp;&amp; S-&gt;bottom_h &lt; L-&gt;bottom_h))
    {
      C = S;  S = S-&gt;higher;
    }
    else
    {
      C = L;  L = L-&gt;higher;
    }

    DEV_ASSERT2(C);

    // ignore liquids in the middle of THICK solids, or below real
    // floor or above real ceiling
    //
    if (C-&gt;bottom_h &lt; floor_h || C-&gt;bottom_h &gt; other-&gt;c_h)
      continue;
    
    if (C-&gt;ef_info-&gt;type &amp; EXFL_Thick)
    {
      // -AJA- 1999/09/25: Better DDF control of side texture.
      if (C-&gt;ef_info-&gt;type &amp; EXFL_SideUpper)
        surf = &amp;sd-&gt;top;
      else if (C-&gt;ef_info-&gt;type &amp; EXFL_SideLower)
        surf = &amp;sd-&gt;bottom;
      else
        surf = &amp;C-&gt;ef_line-&gt;side[0]-&gt;middle;

      tex_z = (C-&gt;ef_line-&gt;flags &amp; ML_LowerUnpegged) ?
          C-&gt;bottom_h + IM_HEIGHT(surf-&gt;image) : C-&gt;top_h;

      AddWallTile(sd, C-&gt;bottom_h, C-&gt;top_h, tex_z, surf, WTILF_Extra);
    }

    floor_h = C-&gt;top_h;
  }
}
</t>
<t tx="T1892">@ P_RecomputeGapsAroundSector
@c

void P_RecomputeGapsAroundSector(sector_t *sec)
{
  int i;

  for (i=0; i &lt; sec-&gt;linecount; i++)
  {
    P_ComputeGaps(sec-&gt;lines[i]);
  }

  // now do the sight gaps...
  
  if (sec-&gt;c_h &lt;= sec-&gt;f_h)
  {
    sec-&gt;sight_gap_num = 0;
    return;
  }

  sec-&gt;sight_gap_num = GAP_SightConstruct(sec-&gt;sight_gaps, sec);
}
</t>
<t tx="T1893">
void P_RecomputeTilesInSector(sector_t *sec)
{
  int i;

  for (i=0; i &lt; sec-&gt;linecount; i++)
  {
    P_ComputeWallTiles(sec-&gt;lines[i], 0);
    P_ComputeWallTiles(sec-&gt;lines[i], 1);
  }
}
</t>
<t tx="T1894">@ --------------------------------------------------------------------------

THING POSITION SETTING
@c

static INLINE touch_node_t *TouchNodeAlloc(void)
{
  touch_node_t *tn;
  
#ifdef DEVELOPERS
  touchstat_alloc++;
#endif

  if (free_touch_nodes)
  {
    tn = free_touch_nodes;
    free_touch_nodes = tn-&gt;mo_next;
  }
  else
  {
    tn = Z_New(touch_node_t, 1);
  }

  return tn;
}
</t>
<t tx="T1895">
static INLINE void TouchNodeFree(touch_node_t *tn)
{
#ifdef DEVELOPERS
  touchstat_free++;
#endif

  // PREV field is ignored in quick-alloc list
  tn-&gt;mo_next = free_touch_nodes;
  free_touch_nodes = tn;
}
</t>
<t tx="T1896">
static INLINE void TouchNodeLinkIntoSector(touch_node_t *tn, sector_t *sec)
{
  tn-&gt;sec = sec;
  
  tn-&gt;sec_next = sec-&gt;touch_things;
  tn-&gt;sec_prev = NULL;
  
  if (tn-&gt;sec_next)
    tn-&gt;sec_next-&gt;sec_prev = tn;

  sec-&gt;touch_things = tn;
}
</t>
<t tx="T1897">
static INLINE void TouchNodeLinkIntoThing(touch_node_t *tn, mobj_t *mo)
{
  tn-&gt;mo = mo;
  
  tn-&gt;mo_next = mo-&gt;touch_sectors;
  tn-&gt;mo_prev = NULL;
  
  if (tn-&gt;mo_next)
    tn-&gt;mo_next-&gt;mo_prev = tn;

  mo-&gt;touch_sectors = tn;
}
</t>
<t tx="T1898">
static INLINE void TouchNodeUnlinkFromSector(touch_node_t *tn)
{
  if (tn-&gt;sec_next)
    tn-&gt;sec_next-&gt;sec_prev = tn-&gt;sec_prev;

  if (tn-&gt;sec_prev)
    tn-&gt;sec_prev-&gt;sec_next = tn-&gt;sec_next;
  else
    tn-&gt;sec-&gt;touch_things = tn-&gt;sec_next;
}
</t>
<t tx="T1899">
static INLINE void TouchNodeUnlinkFromThing(touch_node_t *tn)
{
  if (tn-&gt;mo_next)
    tn-&gt;mo_next-&gt;mo_prev = tn-&gt;mo_prev;

  if (tn-&gt;mo_prev)
    tn-&gt;mo_prev-&gt;mo_next = tn-&gt;mo_next;
  else
    tn-&gt;mo-&gt;touch_sectors = tn-&gt;mo_next;
}
</t>
<t tx="T1900">
typedef struct setposbsp_s
{
  mobj_t *thing;

  float_t bbox[4];
}
setposbsp_t;

//
// SetPositionBSP
//
static void SetPositionBSP(setposbsp_t *info, int nodenum)
{
  touch_node_t *tn;
  sector_t *sec;
  subsector_t *sub;
  seg_t *seg;

  while (! (nodenum &amp; NF_SUBSECTOR))
  {
    node_t *nd = nodes + nodenum;

    int side = P_BoxOnDivLineSide(info-&gt;bbox, &amp;nd-&gt;div);

    // if box touches partition line, we must traverse both sides
    if (side == -1)
    {
      SetPositionBSP(info, nd-&gt;children[0]);
      side = 1;
    }

    DEV_ASSERT2(side == 0 || side == 1);

    nodenum = nd-&gt;children[side];
  }
    
  // reached a leaf of the BSP.  Need to check BBOX against all
  // linedef segs.  This is because we can get false positives, since
  // we don't actually split the thing's BBOX when it intersects with
  // a partition line.

  sub = subsectors + (nodenum &amp; ~NF_SUBSECTOR);

  for (seg=sub-&gt;segs; seg; seg=seg-&gt;sub_next)
  {
    divline_t div;
    
    if (seg-&gt;miniseg)
      continue;

    div.x = seg-&gt;v1-&gt;x;
    div.y = seg-&gt;v1-&gt;y;
    div.dx = seg-&gt;v2-&gt;x - div.x;
    div.dy = seg-&gt;v2-&gt;y - div.y;

    if (P_BoxOnDivLineSide(info-&gt;bbox, &amp;div) == 1)
      return;
  }

  // Perform linkage...

  sec = sub-&gt;sector;

#ifdef DEVELOPERS
  touchstat_miss++;
#endif

  for (tn = info-&gt;thing-&gt;touch_sectors; tn; tn = tn-&gt;mo_next)
  {
    if (! tn-&gt;mo)
    {
      // found unused touch node.  We reuse it.
      tn-&gt;mo = info-&gt;thing;

      if (tn-&gt;sec != sec)
      {
        TouchNodeUnlinkFromSector(tn);
        TouchNodeLinkIntoSector(tn, sec);
      }
#ifdef DEVELOPERS
      else
      {
        touchstat_miss--;
        touchstat_hit++;
      }
#endif
      
      return;
    }

    DEV_ASSERT2(tn-&gt;mo == info-&gt;thing);

    // sector already present ?
    if (tn-&gt;sec == sec)
      return;
  }

  // need to allocate a new touch node
  tn = TouchNodeAlloc();

  TouchNodeLinkIntoThing(tn, info-&gt;thing);
  TouchNodeLinkIntoSector(tn, sec);
}
</t>
<t tx="T1901">@ P_UnsetThingPosition

Unlinks a thing from block map and subsector.
On each position change, BLOCKMAP and other
lookups maintaining lists ot things inside
these structures need to be updated.

-ES- 1999/12/04 Better error checking: Clear prev/next fields.
This catches errors which can occur if the position is unset twice.
@c

static void P_UnsetThingPosition(mobj_t * thing)
{
  int blockx;
  int blocky;
  int bnum;

  touch_node_t *tn;

  // unlink from subsector
  if (!(thing-&gt;flags &amp; MF_NOSECTOR))
  {
    // (inert things don't need to be in subsector list)

    if (thing-&gt;snext)
    {
#ifdef DEVELOPERS
      if (thing-&gt;snext-&gt;sprev != thing)
        I_Error("INTERNAL ERROR: Bad subsector NEXT link in thing.\n");
#endif
      thing-&gt;snext-&gt;sprev = thing-&gt;sprev;
    }

    if (thing-&gt;sprev)
    {
#ifdef DEVELOPERS
      if (thing-&gt;sprev-&gt;snext != thing)
        I_Error("INTERNAL ERROR: Bad subsector PREV link in thing.\n");
#endif
      thing-&gt;sprev-&gt;snext = thing-&gt;snext;
    }
    else
    {
#ifdef DEVELOPERS
      if (thing-&gt;subsector-&gt;thinglist != thing)
        I_Error("INTERNAL ERROR: Bad subsector link (HEAD) in thing, possibly double P_UnsetThingPosition call.\n");
#endif
      thing-&gt;subsector-&gt;thinglist = thing-&gt;snext;
    }

    thing-&gt;snext = NULL;
    thing-&gt;sprev = NULL;
  }

  // unlink from touching list.
  // NOTE: lazy unlinking -- see notes in r_defs.h
  //
  for (tn = thing-&gt;touch_sectors; tn; tn = tn-&gt;mo_next)
  {
    tn-&gt;mo = NULL;
  }

  // unlink from blockmap
  if (!(thing-&gt;flags &amp; MF_NOBLOCKMAP))
  {
    // inert things don't need to be in blockmap
    if (thing-&gt;bnext)
    {
#ifdef DEVELOPERS
      if (thing-&gt;bnext-&gt;bprev != thing)
        I_Error("INTERNAL ERROR: Bad block NEXT link in thing.\n");
#endif
      thing-&gt;bnext-&gt;bprev = thing-&gt;bprev;
    }

    if (thing-&gt;bprev)
    {
#ifdef DEVELOPERS
      if (thing-&gt;bprev-&gt;bnext != thing)
        I_Error("INTERNAL ERROR: Bad block PREV link in thing.\n");
#endif
      thing-&gt;bprev-&gt;bnext = thing-&gt;bnext;
    }
    else
    {
      blockx = (thing-&gt;x - bmaporgx) / MAPBLOCKUNITS;
      blocky = (thing-&gt;y - bmaporgy) / MAPBLOCKUNITS;

      if (blockx &gt;= 0 &amp;&amp; blockx &lt; bmapwidth &amp;&amp;
          blocky &gt;= 0 &amp;&amp; blocky &lt; bmapheight)
      {
        bnum = blocky * bmapwidth + blockx;
#ifdef DEVELOPERS
        if (blocklinks[bnum] != thing)
          I_Error("INTERNAL ERROR: Bad block link (HEAD) in thing.\n");
#endif
        blocklinks[bnum] = thing-&gt;bnext;
      }
    }

    thing-&gt;bprev = NULL;
    thing-&gt;bnext = NULL;
  }

  // unlink from dynamic light blockmap
  if (thing-&gt;extendedflags &amp; EF_DLIGHT)
  {
    if (thing-&gt;dlnext)
    {
      DEV_ASSERT2(thing-&gt;dlnext-&gt;dlprev == thing);
      thing-&gt;dlnext-&gt;dlprev = thing-&gt;dlprev;
    }

    if (thing-&gt;dlprev)
    {
      DEV_ASSERT2(thing-&gt;dlprev-&gt;dlnext == thing);
      thing-&gt;dlprev-&gt;dlnext = thing-&gt;dlnext;
    }
    else
    {
      blockx = (thing-&gt;x - bmaporgx) / MAPBLOCKUNITS;
      blocky = (thing-&gt;y - bmaporgy) / MAPBLOCKUNITS;

      if (blockx &gt;= 0 &amp;&amp; blockx &lt; bmapwidth &amp;&amp;
          blocky &gt;= 0 &amp;&amp; blocky &lt; bmapheight)
      {
        bnum = blocky * bmapwidth + blockx;

        DEV_ASSERT2(blocklights[bnum] == thing);
        blocklights[bnum] = thing-&gt;dlnext;
      }
    }

    thing-&gt;dlprev = thing-&gt;dlnext = NULL;
  }
}
</t>
<t tx="T1902">@ P_UnsetThingFinally

Call when the thing is about to be removed for good.
@c

void P_UnsetThingFinally(mobj_t * thing)
{
  touch_node_t *tn;
  
  P_UnsetThingPosition(thing);

  // clear out touch nodes
  
  while (thing-&gt;touch_sectors)
  {
    tn = thing-&gt;touch_sectors;
    thing-&gt;touch_sectors = tn-&gt;mo_next;

    TouchNodeUnlinkFromSector(tn);
    TouchNodeFree(tn);
  }
}
</t>
<t tx="T1903">@ P_SetThingPosition

Links a thing into both a block and a subsector
based on it's x y.
@c

void P_SetThingPosition(mobj_t * thing)
{
  subsector_t *ss;
  int blockx;
  int blocky;
  int bnum;

  setposbsp_t pos;
  touch_node_t *tn;

  // -ES- 1999/12/04 The position must be unset before it's set again.
#ifdef DEVELOPERS
  if (thing-&gt;snext || thing-&gt;sprev || thing-&gt;bnext || thing-&gt;bprev)
    I_Error("INTERNAL ERROR: Double P_SetThingPosition call.");

  DEV_ASSERT2(! (thing-&gt;dlnext || thing-&gt;dlprev));
#endif  // DEVELOPERS

  // link into subsector
  ss = R_PointInSubsector(thing-&gt;x, thing-&gt;y);
  thing-&gt;subsector = ss;

  // determine properties
  thing-&gt;props = R_PointGetProps(ss, thing-&gt;z + thing-&gt;height/2);

  if (! (thing-&gt;flags &amp; MF_NOSECTOR))
  {
    thing-&gt;snext = ss-&gt;thinglist;
    thing-&gt;sprev = NULL;

    if (ss-&gt;thinglist)
      ss-&gt;thinglist-&gt;sprev = thing;

    ss-&gt;thinglist = thing;
  }

  // link into touching list
  
#ifdef DEVELOPERS
  touchstat_moves++;
#endif

  pos.thing = thing;
  pos.bbox[BOXLEFT]   = thing-&gt;x - thing-&gt;radius;
  pos.bbox[BOXRIGHT]  = thing-&gt;x + thing-&gt;radius;
  pos.bbox[BOXBOTTOM] = thing-&gt;y - thing-&gt;radius;
  pos.bbox[BOXTOP]    = thing-&gt;y + thing-&gt;radius;

  SetPositionBSP(&amp;pos, root_node);

  // handle any left-over unused touch nodes

  for (tn = thing-&gt;touch_sectors; tn &amp;&amp; tn-&gt;mo; tn = tn-&gt;mo_next)
  { /* nothing here */ }
  
  if (tn)
  {
    if (tn-&gt;mo_prev)
      tn-&gt;mo_prev-&gt;mo_next = NULL;
    else
      thing-&gt;touch_sectors = NULL;

    while (tn)
    {
      touch_node_t *cur = tn;
      tn = tn-&gt;mo_next;

      DEV_ASSERT2(! cur-&gt;mo);

      TouchNodeUnlinkFromSector(cur);
      TouchNodeFree(cur);
    }
  }

#if 0  // PROFILING
  {
    static int last_time = 0;

    if ((leveltime - last_time) &gt; 5*TICRATE)
    {
      L_WriteDebug("TOUCHSTATS: Mv=%d Ht=%d Ms=%d Al=%d Fr=%d\n",
          touchstat_moves, touchstat_hit, touchstat_miss,
          touchstat_alloc, touchstat_free);

      touchstat_moves = touchstat_hit = touchstat_miss =
      touchstat_alloc = touchstat_free = 0;

      last_time = leveltime;
    }
  }
#endif
 
  // link into blockmap
  if (!(thing-&gt;flags &amp; MF_NOBLOCKMAP))
  {
    blockx = (thing-&gt;x - bmaporgx) / MAPBLOCKUNITS;
    blocky = (thing-&gt;y - bmaporgy) / MAPBLOCKUNITS;

    if (blockx &gt;= 0 &amp;&amp; blockx &lt; bmapwidth &amp;&amp;
        blocky &gt;= 0 &amp;&amp; blocky &lt; bmapheight)
    {
      bnum = blocky * bmapwidth + blockx;

      thing-&gt;bprev = NULL;
      thing-&gt;bnext = blocklinks[bnum];

      if (blocklinks[bnum])
        (blocklinks[bnum])-&gt;bprev = thing;

      blocklinks[bnum] = thing;
    }
    else
    {
      // thing is off the map
      thing-&gt;bnext = thing-&gt;bprev = NULL;
    }
  }

  // link into dynamic light blockmap
  if (thing-&gt;extendedflags &amp; EF_DLIGHT)
  {
    blockx = (thing-&gt;x - bmaporgx) / MAPBLOCKUNITS;
    blocky = (thing-&gt;y - bmaporgy) / MAPBLOCKUNITS;

    if (blockx &gt;= 0 &amp;&amp; blockx &lt; bmapwidth &amp;&amp;
        blocky &gt;= 0 &amp;&amp; blocky &lt; bmapheight)
    {
      bnum = blocky * bmapwidth + blockx;

      thing-&gt;dlprev = NULL;
      thing-&gt;dlnext = blocklights[bnum];

      if (blocklights[bnum])
        (blocklights[bnum])-&gt;dlprev = thing;

      blocklights[bnum] = thing;
    }
    else
    {
      // thing is off the map
      thing-&gt;dlnext = thing-&gt;dlprev = NULL;
    }
  }
}
</t>
<t tx="T1904">@ P_ChangeThingPosition

New routine to "atomicly" move a thing. Apart from object
construction and destruction, this routine should always be called
when moving a thing, rather than fiddling with the coordinates
directly (or even P_UnsetThingPos/P_SetThingPos pairs).
@c

void P_ChangeThingPosition(mobj_t * thing, float_t x, float_t y, float_t z)
{
  P_UnsetThingPosition(thing);

  thing-&gt;x = x;
  thing-&gt;y = y;
  thing-&gt;z = z;

  P_SetThingPosition(thing);
}
</t>
<t tx="T1905">@ P_FreeSectorTouchNodes
@c

void P_FreeSectorTouchNodes(sector_t *sec)
{
  touch_node_t *tn;
  
  for (tn = sec-&gt;touch_things; tn; tn = tn-&gt;sec_next)
    TouchNodeFree(tn);
}
</t>
<t tx="T1906">@ --------------------------------------------------------------------------

BLOCK MAP ITERATORS

For each line/thing in the given mapblock,
call the passed PIT_* function.
If the function returns false,
exit with false without checking anything else.


P_BlockLinesIterator

The validcount flags are used to avoid checking lines
that are marked in multiple mapblocks,
so increment validcount before the first call
to P_BlockLinesIterator, then make one or more calls
to it.

23-6-98 KM Changed to reflect blockmap is now int* not short*
-AJA- 2000/07/31: line data changed back to shorts.
@c

boolean_t P_BlockLinesIterator (int x, int y, boolean_t(*func) (line_t *))
{
  unsigned short *list;
  line_t *ld;

  if (x &lt; 0 || y &lt; 0 || x &gt;= bmapwidth || y &gt;= bmapheight)
    return true;

  list = bmap_pointers[y * bmapwidth + x];

  for (; *list != BMAP_END; list++)
  {
    ld = &amp;lines[*list];

    // has line already been checked ?
    if (ld-&gt;validcount == validcount)
      continue;

    ld-&gt;validcount = validcount;

    if (!func(ld))
      return false;
  }

  // everything was checked
  return true;
}
</t>
<t tx="T1907">@ P_BlockThingsIterator
@c

boolean_t P_BlockThingsIterator(int x, int y, boolean_t(*func) (mobj_t *))
{
  mobj_t *mobj;

  if (x &lt; 0 || y &lt; 0 || x &gt;= bmapwidth || y &gt;= bmapheight)
  {
    return true;
  }

  for (mobj = blocklinks[y * bmapwidth + x]; mobj; mobj = mobj-&gt;bnext)
  {
    if (!func(mobj))
      return false;
  }

  return true;
}
</t>
<t tx="T1908">@ INTERCEPT ROUTINES
@c

stack_array_t intercept_a;
intercept_t **intercepts = NULL;
int intercept_p;

divline_t trace;
boolean_t earlyout;
int ptflags;

//
// PIT_AddLineIntercepts.
//
// Looks for lines in the given block
// that intercept the given trace
// to add to the intercepts list.
//
// A line is crossed if its endpoints
// are on opposite sides of the trace.
// Returns true if earlyout and a solid line hit.
//
static boolean_t PIT_AddLineIntercepts(line_t * ld)
{
  int s1;
  int s2;
  float_t frac;
  divline_t div;

  div.x = ld-&gt;v1-&gt;x;
  div.y = ld-&gt;v1-&gt;y;
  div.dx = ld-&gt;dx;
  div.dy = ld-&gt;dy;

  // avoid precision problems with two routines
  if (trace.dx &gt; 16 || trace.dy &gt; 16 || trace.dx &lt; -16 || trace.dy &lt; -16)
  {
    s1 = P_PointOnDivlineSide(ld-&gt;v1-&gt;x, ld-&gt;v1-&gt;y, &amp;trace);
    s2 = P_PointOnDivlineSide(ld-&gt;v2-&gt;x, ld-&gt;v2-&gt;y, &amp;trace);
  }
  else
  {
    s1 = P_PointOnDivlineSide(trace.x, trace.y, &amp;div);
    s2 = P_PointOnDivlineSide(trace.x + trace.dx, trace.y + trace.dy, &amp;div);
  }

  if (s1 == s2)
    return true;  // line isn't crossed

  // hit the line

  frac = P_InterceptVector(&amp;trace, &amp;div);

  if (frac &lt; 0)
    return true;  // behind source

  // try to early out the check
  if (earlyout &amp;&amp; frac &lt; 1.0 &amp;&amp; !ld-&gt;backsector)
    return false;  // stop checking

  Z_SetArraySize(&amp;intercept_a, intercept_p + 1);

  intercepts[intercept_p]-&gt;frac = frac;
  intercepts[intercept_p]-&gt;type = INCPT_Line;
  intercepts[intercept_p]-&gt;d.line = ld;
  intercept_p++;

  return true;  // continue

}
</t>
<t tx="T1909">@ PIT_AddThingIntercepts
@c

static boolean_t PIT_AddThingIntercepts(mobj_t * thing)
{
  float_t x1;
  float_t y1;
  float_t x2;
  float_t y2;

  int s1;
  int s2;

  boolean_t tracepositive;

  divline_t div;

  float_t frac;

  tracepositive = (trace.dx &gt;= 0) == (trace.dy &gt;= 0);

  // check a corner to corner crossection for hit
  if (tracepositive)
  {
    x1 = thing-&gt;x - thing-&gt;radius;
    y1 = thing-&gt;y + thing-&gt;radius;

    x2 = thing-&gt;x + thing-&gt;radius;
    y2 = thing-&gt;y - thing-&gt;radius;
  }
  else
  {
    x1 = thing-&gt;x - thing-&gt;radius;
    y1 = thing-&gt;y - thing-&gt;radius;

    x2 = thing-&gt;x + thing-&gt;radius;
    y2 = thing-&gt;y + thing-&gt;radius;
  }

  s1 = P_PointOnDivlineSide(x1, y1, &amp;trace);
  s2 = P_PointOnDivlineSide(x2, y2, &amp;trace);

  // line isn't crossed ?
  if (s1 == s2)
    return true;

  div.x = x1;
  div.y = y1;
  div.dx = x2 - x1;
  div.dy = y2 - y1;

  frac = P_InterceptVector(&amp;trace, &amp;div);

  // behind source ?
  if (frac &lt; 0)
    return true;

  Z_SetArraySize(&amp;intercept_a, intercept_p + 1);

  intercepts[intercept_p]-&gt;frac = frac;
  intercepts[intercept_p]-&gt;type = INCPT_Thing;
  intercepts[intercept_p]-&gt;d.thing = thing;
  intercept_p++;

  // keep going
  return true;
}
</t>
<t tx="T1910">@ TraverseIntercepts

Returns true if the traverser function returns true
for all lines.
@c

static boolean_t TraverseIntercepts(traverser_t func, float_t maxfrac)
{
  int count;
  float_t dist;
  int scan;
  intercept_t *in = NULL;

  count = intercept_p;

  while (count--)
  {
    dist = INT_MAX;
    for (scan = 0; scan &lt; intercept_p; scan++)
    {
      if (intercepts[scan]-&gt;frac &lt; dist)
      {
        dist = intercepts[scan]-&gt;frac;
        in = intercepts[scan];
      }
    }

    if (dist &gt; maxfrac)
    {
      // checked everything in range  
      return true;
    }
#if 0  // UNUSED
    {
      // don't check these yet, there may be others inserted
      in = scan = intercepts;
      for (scan = intercepts; scan &lt; &amp;intercepts[intercept_p]; scan++)
        if (scan-&gt;frac &gt; maxfrac)
          *in++ = *scan;
      intercept_p = in;
      return false;
    }
#endif

    if (!func(in))
    {
      // don't bother going farther
      return false;
    }

    in-&gt;frac = INT_MAX;
  }

  // everything was traversed
  return true;
}
</t>
<t tx="T1911">@ P_PathTraverse

Traces a line from x1,y1 to x2,y2,
calling the traverser function for each.
Returns true if the traverser function returns true
for all lines.
@c

boolean_t P_PathTraverse(float_t x1, float_t y1, float_t x2, float_t y2, 
    int flags, traverser_t trav)
{
  static boolean_t firsttime = true;

  int xt1;
  int yt1;
  int xt2;
  int yt2;

  float_t xstep;
  float_t ystep;

  float_t partial;

  float_t xintercept;
  float_t yintercept;

  double tmp;

  int mapx;
  int mapy;

  int mapxstep;
  int mapystep;

  int count;

  earlyout = flags &amp; PT_EARLYOUT;

  validcount++;
  
  if (firsttime)
  {
    Z_InitStackArray(&amp;intercept_a, (void ***)&amp;intercepts, sizeof(intercept_t), 0);
    firsttime = false;
  }

  intercept_p = 0;

  if (fmod(x1 - bmaporgx, MAPBLOCKUNITS) == 0)
  {
    // don't side exactly on a line
    x1 += 1.0;
  }

  if (fmod(y1 - bmaporgy, MAPBLOCKUNITS) == 0)
  {
    // don't side exactly on a line
    y1 += 1.0;
  }

  trace.x = x1;
  trace.y = y1;
  trace.dx = x2 - x1;
  trace.dy = y2 - y1;

  x1 -= bmaporgx;
  y1 -= bmaporgy;
  x2 -= bmaporgx;
  y2 -= bmaporgy;

  // -AJA- use floor() here, for more precise behaviour.
  // FIXME: is this correct though ?
 
  xt1 = floor(x1 / MAPBLOCKUNITS);
  yt1 = floor(y1 / MAPBLOCKUNITS);
  xt2 = floor(x2 / MAPBLOCKUNITS);
  yt2 = floor(y2 / MAPBLOCKUNITS);

  if (xt2 &gt; xt1)
  {
    mapxstep = 1;
    partial = 1.0 - modf(x1 / MAPBLOCKUNITS, &amp;tmp);

    // -ACB- 2000/03/11 Div-by-zero check...
    CHECKVAL(x2-x1);

    ystep = (y2 - y1) / fabs(x2 - x1);
  }
  else if (xt2 &lt; xt1)
  {
    mapxstep = -1;
    partial = modf(x1 / MAPBLOCKUNITS, &amp;tmp);

    // -ACB- 2000/03/11 Div-by-zero check...
    CHECKVAL(x2-x1);

    ystep = (y2 - y1) / fabs(x2 - x1);
  }
  else
  {
    mapxstep = 0;
    partial = 1.0;
    ystep = 256.0;
  }

  yintercept = y1 / MAPBLOCKUNITS + partial * ystep;

  if (yt2 &gt; yt1)
  {
    mapystep = 1;
    partial = 1.0 - modf(y1 / MAPBLOCKUNITS, &amp;tmp);

    // -ACB- 2000/03/11 Div-by-zero check...
    CHECKVAL(y2-y1);

    xstep = (x2 - x1) / fabs(y2 - y1);
  }
  else if (yt2 &lt; yt1)
  {
    mapystep = -1;
    partial = modf(y1 / MAPBLOCKUNITS, &amp;tmp);

    // -ACB- 2000/03/11 Div-by-zero check...
    CHECKVAL(y2-y1);

    xstep = (x2 - x1) / fabs(y2 - y1);
  }
  else
  {
    mapystep = 0;
    partial = 1.0;
    xstep = 256.0;
  }
  xintercept = x1 / MAPBLOCKUNITS + partial * xstep;

  // Step through map blocks.
  // Count is present to prevent a round off error
  // from skipping the break.
  mapx = xt1;
  mapy = yt1;

  for (count = 0; count &lt; 64; count++)
  {
    if (flags &amp; PT_ADDLINES)
    {
      if (!P_BlockLinesIterator(mapx, mapy, PIT_AddLineIntercepts))
        return false;
    }

    if (flags &amp; PT_ADDTHINGS)
    {
      if (!P_BlockThingsIterator(mapx, mapy, PIT_AddThingIntercepts))
        return false;
    }

    if (mapx == xt2 &amp;&amp; mapy == yt2)
      break;

    if (mapy == (int)yintercept)
    {
      yintercept += ystep;
      mapx += mapxstep;
    }
    else if (mapx == (int)xintercept)
    {
      xintercept += xstep;
      mapy += mapystep;
    }
  }

  // go through the sorted list
  return TraverseIntercepts(trav, 1.0);
}
</t>
<t tx="T1912">
static INLINE boolean_t PST_CheckBBox(float_t *bspcoord, float_t *test)
{
  return (test[BOXRIGHT]  &lt; bspcoord[BOXLEFT] ||
          test[BOXLEFT]   &gt; bspcoord[BOXRIGHT] ||
          test[BOXTOP]    &lt; bspcoord[BOXBOTTOM] ||
          test[BOXBOTTOM] &gt; bspcoord[BOXTOP]) ? false : true;
}
</t>
<t tx="T1913">
static boolean_t TraverseSubsec(int bspnum, float_t *bbox,
    boolean_t (*func)(mobj_t *mo))
{
  subsector_t *sub;
  node_t *node;
  mobj_t *obj;

  // just a normal node ?
  if (! (bspnum &amp; NF_SUBSECTOR))
  {
    node = nodes + bspnum;
    
    // recursively check the children nodes
    // OPTIMISE: check against partition lines instead of bboxes.

    if (PST_CheckBBox(node-&gt;bbox[0], bbox))
    {
      if (! TraverseSubsec(node-&gt;children[0], bbox, func))
        return false;
    }

    if (PST_CheckBBox(node-&gt;bbox[1], bbox))
    {
      if (! TraverseSubsec(node-&gt;children[1], bbox, func))
        return false;
    }

    return true;
  }

  // the sharp end: check all things in the subsector

  sub = subsectors + (bspnum &amp; ~NF_SUBSECTOR);

  for (obj=sub-&gt;thinglist; obj; obj=obj-&gt;snext)
  {
    if (! (* func)(obj))
      return false;
  }

  return true;
}
</t>
<t tx="T1914">@ P_SubsecThingIterator

Iterate over all things that touch a certain rectangle on the map,
using the BSP tree.

If any function returns false, then this routine returns false and
nothing else is checked. Otherwise true is returned.
@c

boolean_t P_SubsecThingIterator(float_t *bbox,
    boolean_t (*func)(mobj_t *mo))
{
  return TraverseSubsec(root_node, bbox, func);
}
</t>
<t tx="T1915">
static float_t checkempty_bbox[4];
static line_t *checkempty_line;

static boolean_t PST_CheckThingArea(mobj_t *mo)
{
  if (mo-&gt;x + mo-&gt;radius &lt; checkempty_bbox[BOXLEFT] ||
      mo-&gt;x - mo-&gt;radius &gt; checkempty_bbox[BOXRIGHT] ||
      mo-&gt;y + mo-&gt;radius &lt; checkempty_bbox[BOXBOTTOM] ||
      mo-&gt;y - mo-&gt;radius &gt; checkempty_bbox[BOXTOP])
  {
    // keep looking
    return true;
  }

  // ignore corpses and pickup items
  if (! (mo-&gt;flags &amp; MF_SOLID) &amp;&amp; (mo-&gt;flags &amp; MF_CORPSE))
    return true;

  if (mo-&gt;flags &amp; MF_SPECIAL)
    return true;

  // we've found a thing in that area: we can stop now
  return false;
}
</t>
<t tx="T1916">
static boolean_t PST_CheckThingLine(mobj_t *mo)
{
  float_t bbox[4];
  int side;

  bbox[BOXLEFT]   = mo-&gt;x - mo-&gt;radius;
  bbox[BOXRIGHT]  = mo-&gt;x + mo-&gt;radius;
  bbox[BOXBOTTOM] = mo-&gt;y - mo-&gt;radius;
  bbox[BOXTOP]    = mo-&gt;y + mo-&gt;radius;

  // found a thing on the line ?
  side = P_BoxOnLineSide(bbox, checkempty_line);

  if (side != -1)
    return true;

  // ignore corpses and pickup items
  if (! (mo-&gt;flags &amp; MF_SOLID) &amp;&amp; (mo-&gt;flags &amp; MF_CORPSE))
    return true;

  if (mo-&gt;flags &amp; MF_SPECIAL)
    return true;

  return false;
}
</t>
<t tx="T1917">@ P_ThingsInArea

Checks if there are any things contained within the given rectangle
on the 2D map.
@c

boolean_t P_ThingsInArea(float_t *bbox)
{
  checkempty_bbox[BOXLEFT]   = bbox[BOXLEFT];
  checkempty_bbox[BOXRIGHT]  = bbox[BOXRIGHT];
  checkempty_bbox[BOXBOTTOM] = bbox[BOXBOTTOM];
  checkempty_bbox[BOXTOP]    = bbox[BOXTOP];

  return ! P_SubsecThingIterator(bbox, PST_CheckThingArea);
}
</t>
<t tx="T1918">@ P_ThingsOnLine

Checks if there are any things touching the given line.
@c

boolean_t P_ThingsOnLine(line_t *ld)
{
  checkempty_line = ld;

  return ! P_SubsecThingIterator(ld-&gt;bbox, PST_CheckThingLine);
}
</t>
<t tx="T1919">@ignore
@language c

// Moving Object Handling Code

// -MH- 1998/07/02  "shootupdown" --&gt; "true3dgameplay"
//
// -ACB- 1998/07/30 Took an axe to the item respawn code: now uses a
//                  double-linked list to store to individual items;
//                  limit removed; P_MobjItemRespawn replaces P_RespawnSpecials
//                  as the procedure that handles respawning of items.
//
//                  P_NightmareRespawnOld -&gt; P_TeleportRespawn
//                  P_NightmareRespawnNew -&gt; P_ResurrectRespawn
//
// -ACB- 1998/07/31 Use new procedure to handle flying missiles that hammer
//                  into sky-hack walls &amp; ceilings. Also don't explode the
//                  missile if it hits sky-hack ceiling or floor.
//
// -ACB- 1998/08/06 Implemented limitless mobjinfo list, altered/removed all
//                  mobjinfo[] references.
//
// -AJA- 1999/07/21: Replaced some non-critical P_Randoms with M_Random.
//
// -AJA- 1999/07/30: Removed redundant code from P_SpawnMobj (it was
//                   virtually identical to P_MobjCreateObject).
//
// -AJA- 1999/09/15: Removed P_SpawnMobj itself :-).

&lt;&lt; p_mobj #includes &gt;&gt;
&lt;&lt; p_mobj declarations &gt;&gt;
@others
#endif

</t>
<t tx="T1920">#include "i_defs.h"
#include "p_mobj.h"

#include "con_main.h"
#include "con_cvar.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "g_game.h"
#include "hu_stuff.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_random.h"
#include "p_local.h"
#include "r_main.h"
#include "r2_defs.h"
#include "s_sound.h"
#include "st_stuff.h"
#include "z_zone.h"
</t>
<t tx="T1921">

#define DEBUG_MOBJ  0

//
// Holds the players real Z location, so the missile when teleported to
// a different height sector stay relative to it.
//
float_t realplayerz = 0;  //-jc-

// List of all objects in map.
mobj_t *mobjlisthead;

// Where objects go to die...
iteminque_t *itemquehead;

// The Object Removal Que
static mobj_t **removeque = NULL;
static int removeque_size = 0;
</t>
<t tx="T1922">@ =========================== INTERNALS ===========================
convenience function
-AJA- FIXME: duplicate code from p_map.c
@c

static INLINE int PointOnLineSide(float_t x, float_t y, line_t *ld)
{
  divline_t div;

  div.x = ld-&gt;v1-&gt;x;
  div.y = ld-&gt;v1-&gt;y;
  div.dx = ld-&gt;dx;
  div.dy = ld-&gt;dy;

  return P_PointOnDivlineSide(x, y, &amp;div);
}
</t>
<t tx="T1923">@ EnterBounceStates

-AJA- 1999/10/18: written.
@c

static void EnterBounceStates(mobj_t * mo)
{
  if (! mo-&gt;info-&gt;bounce_state)
    return;

  // ignore if disarmed
  if (mo-&gt;extendedflags &amp; EF_JUSTBOUNCED)
    return;

  // give deferred states a higher priority
  if (!mo-&gt;state || !mo-&gt;next_state ||
      (mo-&gt;next_state - states) != mo-&gt;state-&gt;nextstate)
  {
    return;
  }

  mo-&gt;extendedflags |= EF_JUSTBOUNCED;
  P_SetMobjState(mo, mo-&gt;info-&gt;bounce_state);
}
</t>
<t tx="T1924">@ BounceOffWall

-AJA- 1999/08/22: written.
@c

static void BounceOffWall(mobj_t * mo, line_t * wall)
{
  angle_t angle;
  angle_t wall_angle;
  angle_t diff;

  divline_t div;
  float_t dest_x, dest_y;

  angle = R_PointToAngle(0, 0, mo-&gt;mom.x, mo-&gt;mom.y);
  wall_angle = R_PointToAngle(0, 0, wall-&gt;dx, wall-&gt;dy);

  diff = wall_angle - angle;

  if (diff &gt; ANG90 &amp;&amp; diff &lt; ANG270)
    diff -= ANG180;

  // -AJA- Prevent getting stuck at some walls...

  dest_x = mo-&gt;x + M_Cos(angle) * (mo-&gt;speed + mo-&gt;info-&gt;radius) * 4.0f;
  dest_y = mo-&gt;y + M_Sin(angle) * (mo-&gt;speed + mo-&gt;info-&gt;radius) * 4.0f;

  div.x = wall-&gt;v1-&gt;x;
  div.y = wall-&gt;v1-&gt;y;
  div.dx = wall-&gt;dx;
  div.dy = wall-&gt;dy;

  if (P_PointOnDivlineSide(mo-&gt;x, mo-&gt;y, &amp;div) ==
      P_PointOnDivlineSide(dest_x, dest_y, &amp;div))
  {
    // Result is the same, thus we haven't crossed the line.  Choose a
    // random angle to bounce away.  And don't attenuate the speed (so
    // we can get far enough away).

    angle = P_Random() &lt;&lt; (ANGLEBITS - 8);
  }
  else
  {
    angle += diff &lt;&lt; 1;
  }

  // calculate new momentum

  mo-&gt;speed *= mo-&gt;info-&gt;bounce_speed;

  mo-&gt;mom.x = M_Cos(angle) * mo-&gt;speed;
  mo-&gt;mom.y = M_Sin(angle) * mo-&gt;speed;
  mo-&gt;angle = angle;

  EnterBounceStates(mo);
}
</t>
<t tx="T1925">@ BounceOffPlane

-AJA- 1999/10/18: written.
@c

static void BounceOffPlane(mobj_t * mo, float_t dir)
{
  // calculate new momentum

  mo-&gt;speed *= mo-&gt;info-&gt;bounce_speed;

  mo-&gt;mom.x = (float_t)(M_Cos(mo-&gt;angle) * mo-&gt;speed);
  mo-&gt;mom.y = (float_t)(M_Sin(mo-&gt;angle) * mo-&gt;speed);
  mo-&gt;mom.z = (float_t)(dir * mo-&gt;speed * mo-&gt;info-&gt;bounce_up);

  EnterBounceStates(mo);
}
</t>
<t tx="T1926">@ MissileHitSpecialLine

-AJA- 1999/08/22: written.

-AJA- Seems this is called to handle this situation: P_TryMove is
called, but fails because missile would hit solid line. BUT
missile did pass over some special lines. These special lines were
not activated in P_TryMove since it failed. Ugh !
@c

static void MissileHitSpecialLine(mobj_t * mo)
{
  line_t **hits;
  int i;
    
  // -ES- 2000/02/05 spechit could be changed inside the loop
  hits = I_TmpMalloc(numspechit * sizeof(line_t *));
  Z_MoveData(hits, spechit, line_t *, numspechit);
  i = numspechit;
  Z_SetArraySize(&amp;spechit_a, numspechit = 0);
  
  while (i)
  {
    line_t *ld = hits[--i];
    P_ShootSpecialLine(ld, PointOnLineSide(mo-&gt;x, mo-&gt;y, ld), mo-&gt;source);
  }
 
  I_TmpFree(hits);
}
</t>
<t tx="T1927">@ CorpseShouldSlide

-AJA- 1999/09/25: written.
@c

static boolean_t CorpseShouldSlide(mobj_t * mo)
{
  float_t floor, ceil;
  
  if (-0.25 &lt; mo-&gt;mom.x &amp;&amp; mo-&gt;mom.x &lt; 0.25 &amp;&amp;
      -0.25 &lt; mo-&gt;mom.y &amp;&amp; mo-&gt;mom.y &lt; 0.25)
  {
    return false;
  }
 
  P_ComputeThingGap(mo, mo-&gt;subsector-&gt;sector, mo-&gt;z, &amp;floor, &amp;ceil);

  return (mo-&gt;floorz != floor);
}
</t>
<t tx="T1928">@ TeleportRespawn
@c

static void TeleportRespawn(mobj_t * mobj)
{
  float_t x, y, z;
  const mobjinfo_t *info = mobj-&gt;spawnpoint.info;
  mobj_t *new_mo;

  if (!info)
    return;

  x = mobj-&gt;spawnpoint.x;
  y = mobj-&gt;spawnpoint.y;
  z = mobj-&gt;spawnpoint.z;

  // something is occupying it's position?
  
  mobj-&gt;radius = mobj-&gt;spawnpoint.info-&gt;radius;
  mobj-&gt;height = mobj-&gt;spawnpoint.info-&gt;height;

  if (!P_CheckAbsPosition(mobj, x, y, z))
    return;

  // spawn a teleport fog at old spot
  // because of removal of the body?

  // temp fix for teleport flash...
  if (info-&gt;respawneffect)
    P_MobjCreateObject(mobj-&gt;x, mobj-&gt;y, mobj-&gt;z, info-&gt;respawneffect);

  // spawn a teleport fog at the new spot
  // temp fix for teleport flash...
  if (info-&gt;respawneffect)
    P_MobjCreateObject(x, y, z, info-&gt;respawneffect);

  // spawn it, inheriting attributes from deceased one
  // -ACB- 1998/08/06 Create Object
  new_mo = P_MobjCreateObject(x, y, z, info);

  new_mo-&gt;spawnpoint = mobj-&gt;spawnpoint;
  new_mo-&gt;angle = mobj-&gt;spawnpoint.angle;
  new_mo-&gt;vertangle = mobj-&gt;spawnpoint.slope;

  if (mobj-&gt;spawnpoint.flags &amp; MF_AMBUSH)
    new_mo-&gt;flags |= MF_AMBUSH;

  new_mo-&gt;reactiontime = RESPAWN_DELAY;

  // remove the old monster.
  P_RemoveMobj(mobj);
}
</t>
<t tx="T1929">@ ResurrectRespawn

-ACB- 1998/07/29 Prevented respawning of ghosts
Make monster deaf, if originally deaf
Given a reaction time, delays monster starting up immediately.
Given Invisibility level.
Doesn't try to raise an object with no raisestate
@c

static void ResurrectRespawn(mobj_t * mobj)
{
  float_t x, y, z;
  const mobjinfo_t *info;

  x = mobj-&gt;x;
  y = mobj-&gt;y;
  z = mobj-&gt;z;

  info = mobj-&gt;info;

  // cannot raise the unraisable
  if (!info-&gt;raise_state)
    return;

  // something is occupying it's position?
  // restore original height is position occupied
  if (!P_CheckAbsPosition(mobj, x, y, z))
    return;

  // don't respawn gibs
  if (mobj-&gt;extendedflags &amp; EF_GIBBED)
    return;

  // restore object's original size
  mobj-&gt;radius = info-&gt;radius;
  mobj-&gt;height = info-&gt;height;

  // Resurrect monster
   
  if (info-&gt;overkill_sound)
    S_StartSound(mobj, info-&gt;overkill_sound);

  P_SetMobjState(mobj, info-&gt;raise_state);

  mobj-&gt;flags = info-&gt;flags;
  mobj-&gt;extendedflags = info-&gt;extendedflags;
  mobj-&gt;health = info-&gt;spawnhealth;
  
  mobj-&gt;visibility = PERCENT_2_FLOAT(info-&gt;translucency);
  mobj-&gt;movecount = 0;  // -ACB- 1998/08/03 Don't head off in any direction

  P_MobjSetSource(mobj, NULL);
  P_MobjSetTarget(mobj, NULL);

  if (mobj-&gt;spawnpoint.flags &amp; MF_AMBUSH)
    mobj-&gt;flags |= MF_AMBUSH;

  mobj-&gt;reactiontime = RESPAWN_DELAY;
}
</t>
<t tx="T1930">@ DoRemoveMobj

Remove the map object. This routine common to P_RemoveMobj and
P_MobjRemoveMissile.

-AJA- 1999/09/15: written.
@c

static void DoRemoveMobj(mobj_t * mo)
{
#if (DEBUG_MOBJ &gt; 0)
  L_WriteDebug("tics=%05d  REMOVE %p [%s]\n", leveltime, mo, 
  mo-&gt;info ? mo-&gt;info-&gt;ddf.name : "???");
#endif

  // -------------------------------------------------------------------
  // -ACB- 1998/08/27 Mobj Linked-List Removal
  //
  // A useful way of cycling through the current things without
  // having to deref and search everything using thinkers.
  //

  // unlink from sector and block lists
  P_UnsetThingFinally(mo);

  if (mo-&gt;prev == NULL)  // no previous, must be first item
  {
    DEV_ASSERT2(mobjlisthead == mo);
    mobjlisthead = mo-&gt;next;

    if (mobjlisthead != NULL)
    {
      DEV_ASSERT2(mobjlisthead-&gt;prev == mo);
      mobjlisthead-&gt;prev = NULL;
    }
  }
  else
  {
    DEV_ASSERT2(mo-&gt;prev-&gt;next == mo);
    mo-&gt;prev-&gt;next = mo-&gt;next;

    if (mo-&gt;next != NULL)
    {
      DEV_ASSERT2(mo-&gt;next-&gt;prev == mo);
      mo-&gt;next-&gt;prev = mo-&gt;prev;
    }
  }

  // Clear all references to other mobjs
  P_MobjSetTracer(mo, NULL);
  P_MobjSetSource(mo, NULL);
  P_MobjSetTarget(mo, NULL);
  P_MobjSetSupportObj(mo, NULL);
  P_MobjSetAboveMo(mo, NULL);
  P_MobjSetBelowMo(mo, NULL);

  // clear all references FROM other mobjs. A bit more tricky: We have to
  // search through the reference list for links to this mobj. Luckily
  // we have the refcount that tells us how many occurances we have to find.
  if (mo-&gt;refcount)
  {
    mobj_t *ref;

    #define CHECK_REF(field)\
    if (ref-&gt;field == mo)\
    {\
      *((mobj_t**) &amp;ref-&gt;field) = NULL;\
      mo-&gt;refcount--;\
    }

    for (ref = mobjlisthead; ref &amp;&amp; mo-&gt;refcount; ref = ref-&gt;next)
    {
      CHECK_REF(tracer);
      CHECK_REF(source);
      CHECK_REF(target);
      CHECK_REF(supportobj);
      CHECK_REF(above_mo);
      CHECK_REF(below_mo);
    }
    #undef CHECK_REF

#ifdef DEVELOPERS
    // someone forgot to clear a reference after use
    if (mo-&gt;refcount != 0)
      I_Error("INTERNAL ERROR: Reference count %d", mo-&gt;refcount);
#endif
  }

  // Sound might still be playing, so use indirect Z_Free.
  S_AddToFreeQueue(mo, mo);
}
</t>
<t tx="T1931">@ AddMobjToRemoveQue

Queues a mobj to the removal queue. It will be removed at the end of the
frame.

-ES- 1999/10/24 Written.
@c

static void AddMobjToRemoveQue(mobj_t *mo)
{
  int i;

  // we don't have to add the mobj if it's already there.
  for (i = 0; i &lt; removeque_size; i++)
    if (removeque[i] == mo)
      return;

  Z_Resize(removeque, mobj_t *, ++removeque_size);
  removeque[removeque_size-1] = mo;
}
</t>
<t tx="T1932">@ ======================== END OF INTERNALS ========================
Use these functions to set mobj entries. Never modify the entries directly.
@c

#define CREATE_FUNCTION(name, field)\
void name(mobj_t *mo, mobj_t *target)\
{\
  if (mo-&gt;field)\
    mo-&gt;field-&gt;refcount--;\
  mo-&gt;field = target;\
  if (target)\
    target-&gt;refcount++;\
}

CREATE_FUNCTION(P_MobjSetTracer, tracer)
CREATE_FUNCTION(P_MobjSetSource, source)
CREATE_FUNCTION(P_MobjSetTarget, target)
CREATE_FUNCTION(P_MobjSetSupportObj, supportobj)
CREATE_FUNCTION(P_MobjSetAboveMo, above_mo)
CREATE_FUNCTION(P_MobjSetBelowMo, below_mo)

#undef CREATE_FUNCTION

//
// P_MobjSetRealSource
//
// -AJA- This is for missiles that spawn other missiles -- what we
//       really want to know is who spawned the original missile
//       (the "instigator" of all the mayhem :-).
//
void P_MobjSetRealSource(mobj_t *mo, mobj_t *source)
{
  while (source &amp;&amp; source-&gt;source &amp;&amp; (source-&gt;flags &amp; MF_MISSILE))
    source = source-&gt;source;

  P_MobjSetSource(mo, source);
}
</t>
<t tx="T1933">@ P_SetMobjState

Returns true if the mobj is still present.
@c

boolean_t P_SetMobjState(mobj_t * mobj, statenum_t state)
{
  state_t *st;

  // ignore removed objects
  if (! mobj-&gt;state)
    return false;
  
  if (state == S_NULL)
  {
    mobj-&gt;state = mobj-&gt;next_state = NULL;
    P_RemoveMobj(mobj);
    return false;
  }

  st = &amp;states[state];

  mobj-&gt;state  = st;
  mobj-&gt;tics   = st-&gt;tics;
  mobj-&gt;sprite = st-&gt;sprite;
  mobj-&gt;frame  = st-&gt;frame;
  mobj-&gt;bright = st-&gt;bright;
  mobj-&gt;next_state = (st-&gt;nextstate == S_NULL) ? NULL :
      (states + st-&gt;nextstate);

  if (st-&gt;action)
    (* st-&gt;action)(mobj);

  return true;
}
</t>
<t tx="T1934">@ P_SetMobjStateDeferred

Similiar to P_SetMobjState, but no actions are performed yet.
The new state will entered when the P_MobjThinker code reaches it,
which may happen in the current tick, or at worst the next tick.

Prevents re-entrancy into code like P_CheckRelPosition which is
inherently non re-entrant.

-AJA- 1999/09/12: written.
@c

boolean_t P_SetMobjStateDeferred(mobj_t * mo, statenum_t stnum, int tic_skip)
{
  // ignore removed objects
  if (!mo-&gt;state || !mo-&gt;next_state)
    return false;
 
  if (stnum == S_NULL)
  {
    mo-&gt;state = mo-&gt;next_state = NULL;
    P_RemoveMobj(mo);
    return false;
  }

  mo-&gt;next_state = (stnum == S_NULL) ? NULL : (states + stnum);

  mo-&gt;tics = 0;
  mo-&gt;tic_skip = tic_skip;

  return true;
}
</t>
<t tx="T1935">@ P_MobjFindLabel

Look for the given label in the mobj's states. Returns the state
number if found, otherwise S_NULL.
@c

statenum_t P_MobjFindLabel(mobj_t * mobj, const char *label)
{
  int i;

  for (i=mobj-&gt;info-&gt;first_state; i &lt;= mobj-&gt;info-&gt;last_state; i++)
  {
    if (! states[i].label)
      continue;

    if (DDF_CompareName(states[i].label, label) == 0)
      return i;
  }

  return S_NULL;
}
</t>
<t tx="T1936">@ P_SetMobjDirAndSpeed

-AJA- 1999/09/11: written.
@c

void P_SetMobjDirAndSpeed(mobj_t * mo, angle_t angle, float_t slope, float_t speed)
{
  mo-&gt;angle = angle;
  mo-&gt;vertangle = slope;

  mo-&gt;mom.x = M_Cos(angle) * speed;
  mo-&gt;mom.y = M_Sin(angle) * speed;
  mo-&gt;mom.z = slope * speed;
}
</t>
<t tx="T1937">@ P_MobjExplodeMissile

-AJA- 1999/09/12: Now uses P_SetMobjStateDeferred, since this
routine can be called by TryMove/PIT_CheckRelThing.
@c

void P_MobjExplodeMissile(mobj_t * mo)
{
  mo-&gt;mom.x = mo-&gt;mom.y = mo-&gt;mom.z = 0;

  mo-&gt;flags &amp;= ~(MF_MISSILE | MF_TOUCHY);
  mo-&gt;extendedflags &amp;= ~(EF_BOUNCE | EF_USABLE);

  if (mo-&gt;info-&gt;deathsound)
    S_StartSound(mo, mo-&gt;info-&gt;deathsound);

  // mobjinfo used -ACB- 1998/08/06
  P_SetMobjStateDeferred(mo, mo-&gt;info-&gt;death_state, P_Random() &amp; 3);
}
</t>
<t tx="T1938">

static INLINE void AddRegionProperties(const mobj_t *mo,
    float_t bz, float_t tz, region_properties_t *new_p, 
    float_t f_h, float_t c_h, const region_properties_t *p)
{
  int flags = p-&gt;special ? p-&gt;special-&gt;special_flags : 
      SECSP_PushConstant;

  float_t factor = 1.0;
  float_t push_mul;

  DEV_ASSERT2(tz &gt; bz);

  if (tz &gt; c_h)
    factor -= factor * (tz - c_h) / (tz-bz);

  if (bz &lt; f_h)
    factor -= factor * (f_h - bz) / (tz-bz);

  if (factor &lt;= 0)
    return;

  new_p-&gt;gravity   += factor * p-&gt;gravity;
  new_p-&gt;viscosity += factor * p-&gt;viscosity;
  new_p-&gt;drag      += factor * p-&gt;drag;

  // handle push sectors
 
  if (! (flags &amp; SECSP_WholeRegion) &amp;&amp; bz &gt; f_h + 1)
    return;

  push_mul = 1.0;
  
  if (! (flags &amp; SECSP_PushConstant))
  {
    DEV_ASSERT2(mo-&gt;info-&gt;mass &gt; 0);
    push_mul = 100.0 / mo-&gt;info-&gt;mass;
  }

  if (flags &amp; SECSP_Proportional)
    push_mul *= factor;

  new_p-&gt;push.x += push_mul * p-&gt;push.x;
  new_p-&gt;push.y += push_mul * p-&gt;push.y;
  new_p-&gt;push.z += push_mul * p-&gt;push.z;
}
</t>
<t tx="T1939">@ P_CalcFullProperties

Calculates the properties (gravity etc..) acting on an object,
especially when the object is in multiple extrafloors with
different props.

Only used for players for now (too expensive to be used by
everything).
@c

void P_CalcFullProperties(const mobj_t *mo, region_properties_t *new_p)
{
  sector_t *sector = mo-&gt;subsector-&gt;sector;

  extrafloor_t *S, *L, *C;
  float_t floor_h;

  float_t bz = mo-&gt;z;
  float_t tz = bz + mo-&gt;height;


  new_p-&gt;gravity = 0;
  new_p-&gt;viscosity = 0;
  new_p-&gt;drag = 0;

  new_p-&gt;push.x = new_p-&gt;push.y = new_p-&gt;push.z = 0;

  // Note: friction not averaged: comes from region foot is in
  new_p-&gt;friction = sector-&gt;p-&gt;friction;

  floor_h = sector-&gt;f_h;

  S = sector-&gt;bottom_ef;
  L = sector-&gt;bottom_liq;

  while (S || L)
  {
    if (!L || (S &amp;&amp; S-&gt;bottom_h &lt; L-&gt;bottom_h))
    {
      C = S;  S = S-&gt;higher;
    }
    else
    {
      C = L;  L = L-&gt;higher;
    }

    DEV_ASSERT2(C);

    // ignore "hidden" liquids
    if (C-&gt;bottom_h &lt; floor_h || C-&gt;bottom_h &gt; sector-&gt;c_h)
      continue;
    
    if (bz &lt; C-&gt;bottom_h)
      new_p-&gt;friction = C-&gt;p-&gt;friction;
     
    AddRegionProperties(mo, bz, tz, new_p, floor_h, C-&gt;top_h, C-&gt;p);

    floor_h = C-&gt;top_h;
  }

  AddRegionProperties(mo, bz, tz, new_p, floor_h, sector-&gt;c_h, sector-&gt;p);
}
</t>
<t tx="T1940">@ P_XYMovement
@c

static void P_XYMovement(mobj_t * mo, const region_properties_t *props)
{
  player_t *player;

  float_t ptryx;
  float_t ptryy;
  float_t xmove;
  float_t ymove;
  float_t xstep;
  float_t ystep;
  float_t absx,absy;
  float_t maxstep;

  int did_move;

  player = mo-&gt;player;

  if (mo-&gt;mom.x &gt; MAXMOVE)
    mo-&gt;mom.x = MAXMOVE;
  else if (mo-&gt;mom.x &lt; -MAXMOVE)
    mo-&gt;mom.x = -MAXMOVE;

  if (mo-&gt;mom.y &gt; MAXMOVE)
    mo-&gt;mom.y = MAXMOVE;
  else if (mo-&gt;mom.y &lt; -MAXMOVE)
    mo-&gt;mom.y = -MAXMOVE;

  xmove = mo-&gt;mom.x;
  ymove = mo-&gt;mom.y;

  // -AJA- 1999/07/31: Ride that rawhide :-&gt;
#if 1
  if (mo-&gt;above_mo &amp;&amp; !(mo-&gt;above_mo-&gt;flags &amp; MF_FLOAT) &amp;&amp;
      mo-&gt;above_mo-&gt;floorz &lt; (mo-&gt;z + mo-&gt;height + 1))
  {
    mo-&gt;above_mo-&gt;mom.x += xmove * mo-&gt;info-&gt;ride_friction;
    mo-&gt;above_mo-&gt;mom.y += ymove * mo-&gt;info-&gt;ride_friction;
  }
#else
  if (mo-&gt;ride_em &amp;&amp; (mo-&gt;z == mo-&gt;floorz))
  {
    xmove += (mo-&gt;ride_em-&gt;x + mo-&gt;ride_dx - mo-&gt;x) *
        mo-&gt;ride_em-&gt;info-&gt;ride_friction;
    ymove += (mo-&gt;ride_em-&gt;y + mo-&gt;ride_dy - mo-&gt;y) *
        mo-&gt;ride_em-&gt;info-&gt;ride_friction;
  }
#endif

  // -AJA- 1999/10/09: Reworked viscosity.
  xmove *= 1.0f - props-&gt;viscosity;
  ymove *= 1.0f - props-&gt;viscosity;

  // -ES- 1999/10/16 For fast mobjs, break down
  //  the move into steps of max half radius for collision purposes.

  // Use half radius as max step, if not exceptionally small.
  if (mo-&gt;radius &gt; STEPMOVE)
    maxstep = mo-&gt;radius / 2;
  else
    maxstep = STEPMOVE / 2;

  // precalculate these two, they are used frequently
  absx = (float_t)fabs(xmove);
  absy = (float_t)fabs(ymove);

  if (absx &gt; maxstep || absy &gt; maxstep)
  {
    // Do it in the most number of steps.
    if (absx &gt; absy)
    {
      xstep = (xmove &gt; 0) ? maxstep : -maxstep;

      // almost orthogonal movements are rounded to orthogonal, to prevent
      // an infinite loop in some extreme cases.
      if (absy * 256 &lt; absx)
        ystep = ymove = 0;
      else
        ystep = ymove * xstep / xmove;
    }
    else
    {
      ystep = (ymove &gt; 0) ? maxstep : -maxstep;

      if (absx * 256 &lt; absy)
        xstep = xmove = 0;
      else
        xstep = xmove * ystep / ymove;
    }
  }
  else
  {
    // Step is less than half radius, so one iteration is enough.
    xstep = xmove;
    ystep = ymove;
  }

  // Keep attempting moves until object has lost all momentum.
  do
  {
    // if movement is more than half that of the maximum, attempt the move
    // in two halves or move.
    if (fabs(xmove) &gt; fabs(xstep))
    {
      ptryx = mo-&gt;x + xstep;
      xmove -= xstep;
    }
    else
    {
      ptryx = mo-&gt;x + xmove;
      xmove = 0;
    }

    if (fabs(ymove) &gt; fabs(ystep))
    {
      ptryy = mo-&gt;y + ystep;
      ymove -= ystep;
    }
    else
    {
      ptryy = mo-&gt;y + ymove;
      ymove = 0;
    }

    did_move = P_TryMove(mo, ptryx, ptryy);

    // unable to complete desired move ?
    if (!did_move)
    { 
      // check for missiles hitting shootable lines
      // NOTE: this is for solid lines.  The "pass over" case is
      // handled in P_TryMove().

      if ((mo-&gt;flags &amp; MF_MISSILE) &amp;&amp; 
          (! mo-&gt;currentattack ||
           ! (mo-&gt;currentattack-&gt;flags &amp; AF_NoTriggerLines)))
      {
        if (numspechit &gt; 0)
          MissileHitSpecialLine(mo);

        if (blockline &amp;&amp; blockline-&gt;special)
          P_ShootSpecialLine(blockline, 
              PointOnLineSide(mo-&gt;x, mo-&gt;y, blockline), mo-&gt;source);
      }

      if (mo-&gt;info-&gt;flags &amp; MF_SLIDE)
      {
        P_SlideMove(mo, ptryx, ptryy);
      }
      else if (mo-&gt;extendedflags &amp; EF_BOUNCE)
      {
        // -KM- 1999/01/31 Bouncy objects (grenades)
        // -AJA- 1999/07/30: Moved up here.

        if (! blockline)
        {
          if (mobj_hit_sky)
            P_MobjRemoveMissile(mo);
          else
            P_MobjExplodeMissile(mo);
          
          return;
        }

        BounceOffWall(mo, blockline);
        xmove = ymove = 0;
      }
      else if (mo-&gt;flags &amp; MF_MISSILE)
      {
        if (mobj_hit_sky)
          P_MobjRemoveMissile(mo);  // New Procedure -ACB- 1998/07/30
        else
          P_MobjExplodeMissile(mo);

        return;
      }
      else
      {
        xmove = ymove = 0;
        mo-&gt;mom.x = mo-&gt;mom.y = 0;
      }
    }
  }
  while (xmove || ymove);

  if ((mo-&gt;extendedflags &amp; EF_NOFRICTION) || (mo-&gt;flags &amp; MF_SKULLFLY))
    return;

  if (mo-&gt;flags &amp; MF_CORPSE)
  {
    // do not stop sliding if halfway off a step with some momentum
    if (CorpseShouldSlide(mo))
      return;
  }

  //
  // -MH- 1998/08/18 - make mid-air movement normal when using the jetpack
  //      When in mid-air there's no friction so you slide about
  //      uncontrollably. This is realistic but makes the game
  //      difficult to control to the extent that for normal people,
  //      it's not worth playing - a bit like having auto-aim
  //      permanently off (as most real people are not crack-shots!)
  //
  if ((mo-&gt;z &gt; mo-&gt;floorz) &amp;&amp;
      !(level_flags.true3dgameplay &amp;&amp; mo-&gt;player &amp;&amp; 
        mo-&gt;player-&gt;powers[PW_Jetpack]) &amp;&amp;
      !(mo-&gt;on_ladder &gt;= 0))
  {
    // apply drag when airborne
    mo-&gt;mom.x *= props-&gt;drag;
    mo-&gt;mom.y *= props-&gt;drag;
  }
  else
  {
    mo-&gt;mom.x *= props-&gt;friction;
    mo-&gt;mom.y *= props-&gt;friction;
  }

  if (mo-&gt;player)
  {
    if (fabs(mo-&gt;mom.x) &lt; STOPSPEED &amp;&amp; fabs(mo-&gt;mom.y) &lt; STOPSPEED &amp;&amp;
        mo-&gt;player-&gt;cmd.forwardmove == 0 &amp;&amp; 
        mo-&gt;player-&gt;cmd.sidemove == 0)
    {
      mo-&gt;mom.x = mo-&gt;mom.y = 0;
    }
  }
}
</t>
<t tx="T1941">@ P_ZMovement
@c

static void P_ZMovement(mobj_t * mo, const region_properties_t *props)
{
  float_t dist;
  float_t delta;
  float_t zmove;

  // -KM- 1998/11/25 Gravity is now not precalculated so that
  //  menu changes affect instantly.
  float_t gravity = props-&gt;gravity / 8.0 * 
      (float_t)level_flags.menu_grav / (float_t)MENU_GRAV_NORMAL;
  
  // check for smooth step up
  if (mo-&gt;player &amp;&amp; mo-&gt;player-&gt;mo == mo &amp;&amp; mo-&gt;z &lt; mo-&gt;floorz)
  {
    mo-&gt;player-&gt;viewheight -= mo-&gt;floorz - mo-&gt;z;
    mo-&gt;player-&gt;deltaviewheight = (mo-&gt;player-&gt;std_viewheight - 
        mo-&gt;player-&gt;viewheight) / 8.0f;
  }

  zmove = mo-&gt;mom.z * (1.0f - props-&gt;viscosity);

  // adjust height
  mo-&gt;z += zmove;

  if (mo-&gt;flags &amp; MF_FLOAT &amp;&amp; mo-&gt;target)
  {
    // float down towards target if too close
    if (!(mo-&gt;flags &amp; MF_SKULLFLY) &amp;&amp; !(mo-&gt;flags &amp; MF_INFLOAT))
    {
      dist = P_ApproxDistance(mo-&gt;x - mo-&gt;target-&gt;x, mo-&gt;y - mo-&gt;target-&gt;y);
      delta = mo-&gt;target-&gt;z + (mo-&gt;height / 2) - mo-&gt;z;

      if (delta &lt; 0 &amp;&amp; dist &lt; -(delta * 3))
        mo-&gt;z -= mo-&gt;info-&gt;float_speed;
      else if (delta &gt; 0 &amp;&amp; dist &lt; (delta * 3))
        mo-&gt;z += mo-&gt;info-&gt;float_speed;
    }
  }
  
  //
  //  HIT FLOOR ?
  //

  if (mo-&gt;z &lt;= mo-&gt;floorz)
  {
    if (mo-&gt;flags &amp; MF_SKULLFLY)
      mo-&gt;mom.z = -mo-&gt;mom.z;

    if (mo-&gt;mom.z &lt; 0)
    {
      float_t hurt_momz = gravity * mo-&gt;info-&gt;maxfall;

      if (mo-&gt;player &amp;&amp; gravity &gt; 0 &amp;&amp; -zmove &gt; OOF_SPEED)
      {
        // Squat down. Decrease viewheight for a moment after hitting the
        // ground (hard), and utter appropriate sound.
        mo-&gt;player-&gt;deltaviewheight = zmove / 8.0;
        S_StartSound(mo, mo-&gt;info-&gt;oof_sound);
      }
      // -KM- 1998/12/16 If bigger than max fall, take damage.
      if (mo-&gt;info-&gt;maxfall &amp;&amp; gravity &gt; 0 &amp;&amp; -mo-&gt;mom.z &gt; hurt_momz)
      {
        P_DamageMobj(mo, NULL, NULL, (-mo-&gt;mom.z - hurt_momz), NULL);
      }

      // -KM- 1999/01/31 Bouncy bouncy...
      if (mo-&gt;extendedflags &amp; EF_BOUNCE)
      {
        BounceOffPlane(mo, +1.0);

        // don't bounce forever on the floor
        if (! (mo-&gt;flags &amp; MF_NOGRAVITY) &amp;&amp;
            fabs(mo-&gt;mom.z) &lt; STOPSPEED + fabs(gravity))
        {
          mo-&gt;mom.x = mo-&gt;mom.y = mo-&gt;mom.z = 0;
        }
      }
      else
        mo-&gt;mom.z = 0;
    }

    mo-&gt;z = mo-&gt;floorz;

    if ((mo-&gt;flags &amp; MF_MISSILE) &amp;&amp; !(mo-&gt;flags &amp; MF_NOCLIP))
    {
      // if the floor is sky, don't explode missile -ACB- 1998/07/31
      if (IS_SKY(mo-&gt;subsector-&gt;sector-&gt;floor) &amp;&amp;
          mo-&gt;subsector-&gt;sector-&gt;f_h &gt;= mo-&gt;floorz)
      {
        P_MobjRemoveMissile(mo);
      }
      else
      {
        if (! (mo-&gt;extendedflags &amp; EF_BOUNCE))
          P_MobjExplodeMissile(mo);
      }
      return;
    }
  }
  else if (gravity &gt; 0.0)
  {
    // thing is above the ground, therefore apply gravity

    // -MH- 1998/08/18 - Disable gravity while player has jetpack
    //                   (nearly forgot this one:-)

    if (!(mo-&gt;flags &amp; MF_NOGRAVITY) &amp;&amp;
        !(level_flags.true3dgameplay &amp;&amp; mo-&gt;player &amp;&amp; 
         mo-&gt;player-&gt;powers[PW_Jetpack]) &amp;&amp;
        !(mo-&gt;on_ladder &gt;= 0))
    {
      mo-&gt;mom.z -= gravity;
    }
  }

  //
  //  HIT CEILING ?
  //

  if (mo-&gt;z + mo-&gt;height &gt; mo-&gt;ceilingz)
  {
    if (mo-&gt;flags &amp; MF_SKULLFLY)
      mo-&gt;mom.z = -mo-&gt;mom.z;  // the skull slammed into something

    // hit the ceiling
    if (mo-&gt;mom.z &gt; 0)
    {
      float_t hurt_momz = gravity * mo-&gt;info-&gt;maxfall;

      if (mo-&gt;player &amp;&amp; gravity &lt; 0 &amp;&amp; zmove &gt; OOF_SPEED)
      {
        mo-&gt;player-&gt;deltaviewheight = zmove / 8.0;
        S_StartSound(mo, mo-&gt;info-&gt;oof_sound);
      }
      if (mo-&gt;info-&gt;maxfall &amp;&amp; gravity &lt; 0 &amp;&amp; mo-&gt;mom.z &gt; hurt_momz)
      {
        P_DamageMobj(mo, NULL, NULL, (mo-&gt;mom.z - hurt_momz), NULL);
      }

      // -KM- 1999/01/31 More bouncing.
      if (mo-&gt;extendedflags &amp; EF_BOUNCE)
      {
        BounceOffPlane(mo, -1.0);
        
        // don't bounce forever on the ceiling
        if (! (mo-&gt;flags &amp; MF_NOGRAVITY) &amp;&amp;
            fabs(mo-&gt;mom.z) &lt; STOPSPEED + fabs(gravity))
        {
          mo-&gt;mom.x = mo-&gt;mom.y = mo-&gt;mom.z = 0;
        }
      }
      else
        mo-&gt;mom.z = 0;
    }

    mo-&gt;z = mo-&gt;ceilingz - mo-&gt;height;

    if ((mo-&gt;flags &amp; MF_MISSILE) &amp;&amp; !(mo-&gt;flags &amp; MF_NOCLIP))
    {
      // if the ceiling is sky, don't explode missile -ACB- 1998/07/31
      if (IS_SKY(mo-&gt;subsector-&gt;sector-&gt;ceil) &amp;&amp;
          mo-&gt;subsector-&gt;sector-&gt;c_h &lt;= mo-&gt;ceilingz)
      {
        P_MobjRemoveMissile(mo);
      }
      else
      {
        if (! (mo-&gt;extendedflags &amp; EF_BOUNCE))
          P_MobjExplodeMissile(mo);
      }
      return;
    }
  }
  else if (gravity &lt; 0.0)
  {
    // thing is below ceiling, therefore apply any negative gravity

    // -MH- 1998/08/18 - Disable gravity while player has jetpack
    //                   (nearly forgot this one:-)

    if (!(mo-&gt;flags &amp; MF_NOGRAVITY) &amp;&amp;
        !(level_flags.true3dgameplay &amp;&amp; mo-&gt;player &amp;&amp; 
         mo-&gt;player-&gt;powers[PW_Jetpack]) &amp;&amp;
        !(mo-&gt;on_ladder &gt;= 0))
    {
      mo-&gt;mom.z += -gravity;
    }
  }

  // update the object's vertical region
  P_TryMove(mo, mo-&gt;x, mo-&gt;y);

  // ladders have friction
  if (mo-&gt;on_ladder &gt;= 0)
    mo-&gt;mom.z *= LADDER_FRICTION;

  // apply drag -- but not to frictionless things
  if ((mo-&gt;extendedflags &amp; EF_NOFRICTION) || (mo-&gt;flags &amp; MF_SKULLFLY))
    return;

  mo-&gt;mom.z *= props-&gt;drag;

  if (mo-&gt;player)
  {
    if (fabs(mo-&gt;mom.z) &lt; STOPSPEED &amp;&amp;
        mo-&gt;player-&gt;cmd.upwardmove == 0)
    {
      mo-&gt;mom.z = 0;
    }
  }
}
</t>
<t tx="T1942">@ P_MobjThinker
@c

#define MAX_THINK_LOOP  8

static void P_MobjThinker(mobj_t * mobj)
{
  int loop_count = 0;

  const region_properties_t *props;
  region_properties_t player_props;

  DEV_ASSERT(-1 != (int)mobj-&gt;next, 
      ("P_MobjThinker INTERNAL ERROR: mobj has been Z_Freed"));

  // ignore removed objects
  if (! mobj-&gt;state)
    return;

  mobj-&gt;visibility = (15 * mobj-&gt;visibility + mobj-&gt;vis_target) / 16;
  mobj-&gt;dlight_qty = (15 * mobj-&gt;dlight_qty + mobj-&gt;dlight_target) / 16;

  // handle SKULLFLY attacks
  if ((mobj-&gt;flags &amp; MF_SKULLFLY) &amp;&amp; mobj-&gt;mom.x == 0 &amp;&amp; mobj-&gt;mom.y == 0)
  {
    // the skull slammed into something
    mobj-&gt;flags &amp;= ~MF_SKULLFLY;
    mobj-&gt;mom.x = mobj-&gt;mom.y = mobj-&gt;mom.z = 0;

    P_SetMobjState(mobj, mobj-&gt;info-&gt;idle_state);
  }

  // determine properties, &amp; handle push sectors

  DEV_ASSERT2(mobj-&gt;props);

  if (mobj-&gt;player)
  {
    P_CalcFullProperties(mobj, &amp;player_props);
    
    mobj-&gt;mom.x += player_props.push.x;
    mobj-&gt;mom.y += player_props.push.y;
    mobj-&gt;mom.z += player_props.push.z;

    props = &amp;player_props;
  }
  else
  {
    props = mobj-&gt;props;

    if (props-&gt;push.x || props-&gt;push.y || props-&gt;push.z)
    {
      sector_flag_e flags = props-&gt;special ?
          props-&gt;special-&gt;special_flags : SECSP_PushConstant;

      if (!((mobj-&gt;flags &amp; MF_NOGRAVITY) || (flags &amp; SECSP_PushAll))  &amp;&amp;
          (mobj-&gt;z &lt;= mobj-&gt;floorz + 1.0 || (flags &amp; SECSP_WholeRegion)))
      {
        float_t push_mul = 1.0;

        DEV_ASSERT2(mobj-&gt;info-&gt;mass &gt; 0);
        if (! (flags &amp; SECSP_PushConstant))
          push_mul = 100.0 / mobj-&gt;info-&gt;mass;

        mobj-&gt;mom.x += push_mul * props-&gt;push.x;
        mobj-&gt;mom.y += push_mul * props-&gt;push.y;
        mobj-&gt;mom.z += push_mul * props-&gt;push.z;
      }
    }
  }
 
  // momentum movement
  if (mobj-&gt;mom.x != 0 || mobj-&gt;mom.y != 0) //  || mobj-&gt;ride_em)
  {
    P_XYMovement(mobj, props);
  }

  if ((mobj-&gt;z != mobj-&gt;floorz) || mobj-&gt;mom.z != 0) //  || mobj-&gt;ride_em)
  {
    P_ZMovement(mobj, props);
  }

  if (mobj-&gt;fuse &gt;= 0)
  {
    if (!--mobj-&gt;fuse)
      P_MobjExplodeMissile(mobj);
  }

  if (mobj-&gt;tics &lt; 0)
  {
    // check for nightmare respawn
    if (!(mobj-&gt;extendedflags &amp; EF_MONSTER))
      return;

    // replaced respawnmonsters &amp; newnmrespawn with respawnsetting
    // -ACB- 1998/07/30
    if (!level_flags.respawn)
      return;

    mobj-&gt;movecount++;

    //
    // Uses movecount as a timer, when movecount hits 12*TICRATE the
    // object will try to respawn. So after 12 seconds the object will
    // try to respawn.
    //
    if (mobj-&gt;movecount &lt; mobj-&gt;info-&gt;respawntime)
      return;

    // if the first 5 bits of leveltime are on, don't respawn now...ok?
    if (leveltime &amp; 31)
      return;

    // give a limited "random" chance that respawn don't respawn now
    if (P_Random() &gt; 32)
      return;

    // replaced respawnmonsters &amp; newnmrespawn with respawnsetting
    // -ACB- 1998/07/30
    if (level_flags.res_respawn)
      ResurrectRespawn(mobj);
    else
      TeleportRespawn(mobj);

    return;
  }

  // this can only happen if one of the above movement routines caused
  // the mobj to be removed (e.g. exploded missile).
  if (! mobj-&gt;state)
    return;

  // Cycle through states, calling action functions at transitions.
  // -AJA- 1999/09/12: reworked for deferred states.
  // -AJA- 2000/10/17: reworked again.
  
  for (loop_count=0; loop_count &lt; MAX_THINK_LOOP; loop_count++)
  {
    mobj-&gt;tics -= (1 + mobj-&gt;tic_skip);
    mobj-&gt;tic_skip = 0;

    if (mobj-&gt;tics &gt;= 1)
      break;

    // You can cycle through multiple states in a tic.
    // NOTE: returns false if object freed itself.

    if (! P_SetMobjState(mobj, mobj-&gt;next_state ?
        (mobj-&gt;next_state - states) : S_NULL))
    {
      return;
    }

    if (mobj-&gt;tics != 0)
      break;
  }
}
</t>
<t tx="T1943">@ P_RunMobjThinkers

Cycle through all mobjs and let them think.
@c

void P_RunMobjThinkers(void)
{
  mobj_t *mo;

  for (mo = mobjlisthead; mo; mo = mo-&gt;next)
  {
    P_MobjThinker(mo);
  }

  P_RemoveQueuedMobjs();
}
</t>
<t tx="T1944">@ P_RemoveQueuedMobjs

Removes all the mobjs in the removeque list.

-ES- 1999/10/24 Written.
@c

void P_RemoveQueuedMobjs(void)
{
  int i;

  for (i = 0; i &lt; removeque_size; i++)
    DoRemoveMobj(removeque[i]);

  removeque_size = 0;
}
</t>
<t tx="T1945">@ P_RemoveMobj

Removes the object from the play simulation: no longer thinks, if
the mobj is MF_SPECIAL: i.e. item can be picked up, it is added to
the item-respawn-que, so it gets respawned if needed; The respawning
only happens if itemrespawn is set or the deathmatch mode is
version 2.0: altdeath.
@c

void P_RemoveMobj(mobj_t *mo)
{
  if ((deathmatch &gt;= 2 || level_flags.itemrespawn) &amp;&amp;
      (mo-&gt;info-&gt;flags &amp; MF_SPECIAL) &amp;&amp; 
      !(mo-&gt;extendedflags &amp; EF_NORESPAWN) &amp;&amp;
      !(mo-&gt;flags &amp; MF_DROPPED))
  {
    iteminque_t *newbie = Z_New(iteminque_t, 1);

    newbie-&gt;spawnpoint = mo-&gt;spawnpoint;
    newbie-&gt;time = mo-&gt;info-&gt;respawntime;

    if (itemquehead == NULL)
    {
      newbie-&gt;next = newbie-&gt;prev = NULL;
      itemquehead = newbie;
    }
    else
    {
      iteminque_t *tail;

      for (tail = itemquehead; tail-&gt;next; tail = tail-&gt;next)
      { /* nothing */ }

      newbie-&gt;next = NULL;
      newbie-&gt;prev = tail;

      tail-&gt;next = newbie;
    }
  }

  AddMobjToRemoveQue(mo);
}
</t>
<t tx="T1946">@ P_SpawnPlayer

Called when a player is spawned on the level.
Most of the player structure stays unchanged between levels.

-KM- 1998/12/21 Cleaned this up a bit.
-KM- 1999/01/31 Removed all those nasty cases for doomednum (1/4001)
@c

void P_SpawnPlayer(player_t *p, const spawnpoint_t *point)
{
  float_t x, y, z;

  mobj_t *mobj;
  const mobjinfo_t *objtype;

  int i;

  // -ES- FIXME: Move these checks higher up.
  if (!p)
    return;

  // -jc- not playing?
  if (!p-&gt;in_game)
    return;

  // -KM- 1998/11/25 This is in preparation for skins.  The creatures.ddf
  //   will hold player start objects, sprite will be taken for skin.
  objtype = DDF_MobjLookupPlayer(p-&gt;pnum+1);

  if (p-&gt;playerstate == PST_REBORN)
  {
    G_PlayerReborn(p);
  }

  x = point-&gt;x;
  y = point-&gt;y;
  z = point-&gt;z;

  mobj = P_MobjCreateObject(x, y, z, objtype);

  mobj-&gt;angle = point-&gt;angle;
  mobj-&gt;vertangle = point-&gt;slope;
  mobj-&gt;player = p;
  mobj-&gt;health = p-&gt;health;

  p-&gt;mo = mobj;
  p-&gt;playerstate = PST_LIVE;
  p-&gt;refire = 0;
  p-&gt;damagecount = 0;
  p-&gt;bonuscount = 0;
  p-&gt;extralight = 0;
  p-&gt;effect_colourmap = NULL;
  p-&gt;std_viewheight = mobj-&gt;height * PERCENT_2_FLOAT(objtype-&gt;viewheight);
  p-&gt;viewheight = p-&gt;std_viewheight;
  p-&gt;jumpwait = 0;

  // setup gun psprite
  P_SetupPsprites(p);

  // give all cards in death match mode
  if (deathmatch)
    p-&gt;cards = KF_MASK;

  // -AJA- in COOP, all players are on the same side
  if (netgame &amp;&amp; !deathmatch)
    mobj-&gt;side = 0x7FFFFFFF;

  // -AJA- FIXME: surely this belongs elsewhere.
  if (p == consoleplayer)
  {
    char buffer[16];

    // wake up the status bar
    ST_Start();

    // wake up the heads up text
    HU_Start();

    CON_DeleteCVar("health");
    CON_CreateCVarReal("health", cf_read | cf_delete, &amp;mobj-&gt;health);
    CON_DeleteCVar("frags");
    CON_CreateCVarInt("frags", cf_read | cf_delete, &amp;p-&gt;frags);
    CON_DeleteCVar("totalfrags");
    CON_CreateCVarInt("totalfrags", cf_read | cf_delete, &amp;p-&gt;totalfrags);

    for (i = 0; i &lt; NUMAMMO; i++)
    {
      sprintf(buffer, "ammo%d", i);
      CON_DeleteCVar(buffer);
      CON_CreateCVarInt(buffer, cf_read | cf_delete, &amp;p-&gt;ammo[i].num);

      sprintf(buffer, "maxammo%d", i);
      CON_DeleteCVar(buffer);
      CON_CreateCVarInt(buffer, cf_read | cf_delete, &amp;p-&gt;ammo[i].max);
    }

#if 0  // FIXME:
    for (i = num_disabled_weapons; i &lt; numweapons; i++)
    {
      sprintf(buffer, "weapon%d", i);
      CON_DeleteCVar(buffer);
      CON_CreateCVarBool(buffer, cf_read | cf_delete, &amp;p-&gt;weapons[i].owned);
    }
#endif

    for (i = 0; i &lt; NUMARMOUR; i++)
    {
      sprintf(buffer, "armour%d", i);
      CON_DeleteCVar(buffer);
      CON_CreateCVarReal(buffer, cf_read | cf_delete, &amp;p-&gt;armours[i]);
    }

#if 0  // FIXME:
    for (i = 0; i &lt; NUMCARDS; i++)
    {
      sprintf(buffer, "key%d", i);
      CON_DeleteCVar(buffer);
      CON_CreateCVarBool(buffer, cf_read | cf_delete, &amp;p-&gt;cards[i]);
    }
#endif

    for (i = 0; i &lt; NUMPOWERS; i++)
    {
      sprintf(buffer, "power%d", i);
      CON_DeleteCVar(buffer);
      CON_CreateCVarReal(buffer, cf_read | cf_delete, &amp;p-&gt;powers[i]);
    }
  }

  // Heh, make a drone player invisible and no clip
  if (doomcom-&gt;drone &amp; (1 &lt;&lt; p-&gt;pnum))
  {
    mobj-&gt;vis_target = mobj-&gt;visibility = INVISIBLE;
    mobj-&gt;flags |= MF_NOCLIP;
    mobj-&gt;flags &amp;= ~(MF_SHOOTABLE | MF_SOLID);
  }

  // Don't get stuck spawned in things: telefrag them.
  if (deathmatch &gt;= 3)
    P_TeleportMove(mobj, mobj-&gt;x, mobj-&gt;y, mobj-&gt;z);
}
</t>
<t tx="T1947">@ GAME SPAWN FUNCTIONS


P_SpawnPuff
@c

void P_SpawnPuff(float_t x, float_t y, float_t z, const mobjinfo_t * puff)
{
  mobj_t *th;

  z += (float_t) P_RandomNegPos() / 80.0f;

  // -ACB- 1998/08/06 Specials table for non-negotiables....
  th = P_MobjCreateObject(x, y, z, puff);

  // -AJA- 1999/07/14: DDF-itised.
  th-&gt;mom.z = puff-&gt;float_speed;

  th-&gt;tics -= P_Random() &amp; 3;

  if (th-&gt;tics &lt; 1)
    th-&gt;tics = 1;
}
</t>
<t tx="T1948">@ P_SpawnBlood

-KM- 1998/11/25 Made more violent. :-)
-KM- 1999/01/31 Different blood objects for different mobjs.
@c

void P_SpawnBlood(float_t x, float_t y, float_t z, float_t damage,
    angle_t angle, const mobjinfo_t * blood)
{
  int num;
  mobj_t *th;

  angle += ANG180;

  num = (int) (!level_flags.more_blood ? 1.0f : (M_Random() % 7) + 
      (float_t)((MAX(damage / 4.0f, 7.0f))));

  while (num--)
  {
    z += (float_t)(P_RandomNegPos() / 64.0f);

    angle += (angle_t) (P_RandomNegPos() * (int)(ANG1 / 2));

    th = P_MobjCreateObject(x, y, z, blood);

    P_SetMobjDirAndSpeed(th, angle, ((float_t)num + 12.0f) / 6.0f, 
        (float_t)num / 4.0f);

    th-&gt;tics -= P_Random() &amp; 3;

    if (th-&gt;tics &lt; 1)
      th-&gt;tics = 1;

    if (damage &lt;= 12 &amp;&amp; th-&gt;state &amp;&amp; th-&gt;next_state)
      P_SetMobjState(th, th-&gt;next_state - states);

    if (damage &lt;= 8 &amp;&amp; th-&gt;state &amp;&amp; th-&gt;next_state)
      P_SetMobjState(th, th-&gt;next_state - states);
  }
}
</t>
<t tx="T1949">@ P_MobjItemRespawn

Replacement procedure for P_RespawnSpecials, uses a linked list to go through
the item-respawn-que. The time until respawn (in tics) is decremented every tic,
when the item-in-the-que has a time of zero is it respawned.

-ACB- 1998/07/30 Procedure written.
-KM- 1999/01/31 Custom respawn fog.
@c

void P_MobjItemRespawn(void)
{
  float_t x, y, z;
  mobj_t *mo;
  const mobjinfo_t *objtype;

  iteminque_t *cur, *next;

  // only respawn items in deathmatch or if itemrespawn
  if (! (deathmatch &gt;= 2 || level_flags.itemrespawn))
    return;

  // No item-respawn-que exists, so nothing to process.
  if (itemquehead == NULL)
    return;

  // lets start from the beginning....
  for (cur = itemquehead; cur; cur = next)
  {
    next = cur-&gt;next;

    cur-&gt;time--;

    if (cur-&gt;time &gt; 0)
      continue;

    // no time left, so respawn object

    x = cur-&gt;spawnpoint.x;
    y = cur-&gt;spawnpoint.y;
    z = cur-&gt;spawnpoint.z;

    objtype = cur-&gt;spawnpoint.info;

    if (objtype == NULL)
    {
      I_Error("P_MobjItemRespawn: No such item type!");
      return;  // shouldn't happen.
    }

    // spawn a teleport fog at the new spot
    DEV_ASSERT2(objtype-&gt;respawneffect);
    P_MobjCreateObject(x, y, z, objtype-&gt;respawneffect);

    // -ACB- 1998/08/06 Use MobjCreateObject
    mo = P_MobjCreateObject(x, y, z, objtype);

    mo-&gt;angle = cur-&gt;spawnpoint.angle;
    mo-&gt;vertangle = cur-&gt;spawnpoint.slope;
    mo-&gt;spawnpoint = cur-&gt;spawnpoint;

    // Taking this item-in-que out of the que, remove
    // any references by the previous and next items to
    // the current one.....

    if (next)
      next-&gt;prev = cur-&gt;prev;

    if (cur-&gt;prev)
      cur-&gt;prev-&gt;next = next;
    else
      itemquehead = next;

    Z_Free(cur);
  }
}
</t>
<t tx="T1950">@ P_MobjRemoveMissile

This procedure only is used when a flying missile is removed because
it "hit" a wall or ceiling that in the simulation acts as a sky. The
only major differences with P_RemoveMobj are that now item respawn check
is not done (not needed) and any sound will continue playing despite
the fact the missile has been removed: This is only done due to the
fact that a missile in reality would continue flying through a sky and
you should still be able to hear it.

-ACB- 1998/07/31 Procedure written.
-AJA- 1999/09/15: Functionality subsumed by DoRemoveMobj.
-ES- 1999/10/24 Removal Queue.
@c

void P_MobjRemoveMissile(mobj_t * missile)
{
  missile-&gt;mom.x = missile-&gt;mom.y = missile-&gt;mom.z = 0;

  missile-&gt;flags &amp;= ~(MF_MISSILE | MF_TOUCHY);
  missile-&gt;extendedflags &amp;= ~(EF_BOUNCE);

  AddMobjToRemoveQue(missile);
}
</t>
<t tx="T1951">@ P_MobjCreateObject

Creates a Map Object (MOBJ) at the specified location, with the
specified type (given by DDF). The special z values ONFLOORZ and
ONCEILINGZ are recognised and handled appropriately.

-ACB- 1998/08/02 Procedure written.
@c

mobj_t *P_MobjCreateObject(float_t x, float_t y, float_t z, const mobjinfo_t *type)
{
  mobj_t *mobj;
  state_t *st;
  sector_t *sec;

  mobj = Z_ClearNew(mobj_t, 1);

#if (DEBUG_MOBJ &gt; 0)
  L_WriteDebug("tics=%05d  CREATE %p [%s]  AT %1.0f,%1.0f,%1.0f\n", 
      leveltime, mobj, type-&gt;ddf.name, x, y, z);
#endif

  mobj-&gt;info = type;
  mobj-&gt;x = x;
  mobj-&gt;y = y;
  mobj-&gt;radius = type-&gt;radius;
  mobj-&gt;height = type-&gt;height;
  mobj-&gt;flags = type-&gt;flags;
  mobj-&gt;health = type-&gt;spawnhealth;
  mobj-&gt;speed = type-&gt;speed;
  mobj-&gt;fuse = type-&gt;fuse;
  mobj-&gt;side = type-&gt;side;
  mobj-&gt;on_ladder = -1;

  if (level_flags.fastparm)
    mobj-&gt;speed *= type-&gt;fast;

  // -ACB- 1998/06/25 new mobj Stuff (1998/07/11 - invisibility added)
  mobj-&gt;extendedflags = type-&gt;extendedflags;
  mobj-&gt;vis_target = mobj-&gt;visibility = PERCENT_2_FLOAT(type-&gt;translucency);
  mobj-&gt;currentattack = NULL;

  if (gameskill != sk_nightmare)
    mobj-&gt;reactiontime = type-&gt;reactiontime;

  mobj-&gt;lastlook = P_Random() % MAXPLAYERS;

  //
  // Do not set the state with P_SetMobjState,
  // because action routines can not be called yet
  //
  // if we have a spawnstate use that; else try the meanderstate
  // -ACB- 1998/09/06
  //
  // -AJA- So that the first action gets executed, the `next_state'
  //       is set to the first state and `tics' set to 0.
  //
  if (type-&gt;spawn_state)
    st = &amp;states[type-&gt;spawn_state];
  else if (type-&gt;meander_state)
    st = &amp;states[type-&gt;meander_state];
  else
    st = &amp;states[type-&gt;idle_state];
 
  mobj-&gt;state  = st;
  mobj-&gt;tics   = 0;
  mobj-&gt;sprite = st-&gt;sprite;
  mobj-&gt;frame  = st-&gt;frame;
  mobj-&gt;bright = st-&gt;bright;
  mobj-&gt;next_state = st;

  // enable usable items
  if (mobj-&gt;extendedflags &amp; EF_USABLE)
    mobj-&gt;flags |= MF_TOUCHY;
  
  // handle dynamic lights
  if (blocklights &amp;&amp; type-&gt;dlight.type != DLITE_None)
  {
    mobj-&gt;extendedflags |= EF_DLIGHT;
    mobj-&gt;dlight_qty = mobj-&gt;dlight_target = type-&gt;dlight.intensity;
  }

  // set subsector and/or block links
  P_SetThingPosition(mobj);

  // -AJA- 1999/07/30: Updated for extra floors.

  sec = mobj-&gt;subsector-&gt;sector;

  mobj-&gt;z = P_ComputeThingGap(mobj, sec, z, &amp;mobj-&gt;floorz, &amp;mobj-&gt;ceilingz);

  // Find the real players height (TELEPORT WEAPONS).
  mobj-&gt;origheight = z - realplayerz;  //-jc-

  // update totals for countable items.  Doing it here means that
  // things spawned dynamically can be counted as well.  Whilst this
  // has its dangers, at least it is consistent (more than can be said
  // when RTS comes into play -- trying to second guess which
  // spawnthings should not be counted just doesn't work).

  if (mobj-&gt;flags &amp; MF_COUNTKILL)
    totalkills++;
  if (mobj-&gt;flags &amp; MF_COUNTITEM)
    totalitems++;

  //
  // -ACB- 1998/08/27 Mobj Linked-List Addition
  //
  // A useful way of cycling through the current things without
  // having to deref everything using thinkers.
  //
  // -AJA- 1999/09/15: now adds to _head_ of list (for speed).
  //
  mobj-&gt;prev = NULL;
  mobj-&gt;next = mobjlisthead;

  if (mobjlisthead != NULL)
    mobjlisthead-&gt;prev = mobj;

  mobjlisthead = mobj;

  return mobj;
}
</t>
<t tx="T1952">

#if 0  // DEBUGGING
void P_DumpMobjs(void)
{
  mobj_t *mo;
  int index;
  
  L_WriteDebug("MOBJs:\n");
  
  for (mo=mobjlisthead,index=0; mo; mo=mo-&gt;next, index++)
  {
    L_WriteDebug("  %3d: [%s] at (%d,%d,%d) states=%d &gt; %d tics=%d\n",
        index, mo-&gt;info-&gt;ddf.name,
        (int)mo-&gt;x, (int)mo-&gt;y, (int)mo-&gt;z,
        mo-&gt;state ? mo-&gt;state - states : -1,
        mo-&gt;next_state ? mo-&gt;next_state - states : -1,
        mo-&gt;tics);
  }

  L_WriteDebug("END OF MOBJs\n");
}
</t>
<t tx="T1953">@ignore
@language c

// Floor/Elevator/Teleport Action Code

// -KM-  1998/09/01 Changed for DDF.
// -ACB- 1998/09/13 Moved the teleport procedure here

&lt;&lt; p_plane #includes &gt;&gt;
&lt;&lt; p_plane declarations &gt;&gt;
@others
</t>
<t tx="T1954">#include "i_defs.h"

#include "z_zone.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "m_random.h"
#include "p_local.h"
#include "r_state.h"
#include "s_sound.h"
</t>
<t tx="T1955">
#define DIRECTION_UP      1
#define DIRECTION_WAIT    0
#define DIRECTION_DOWN   -1
#define DIRECTION_STASIS -2

typedef enum
{
  RES_Ok,
  RES_Crushed,
  RES_PastDest,
  RES_Impossible
}
move_result_e;

// Linked list of moving parts.
gen_move_t *active_movparts = NULL;

static boolean_t P_StasifySector(sector_t * sec);
static boolean_t P_ActivateInStasis(int tag);

static elev_move_t *P_SetupElevatorAction(sector_t * sector, 
    const elevator_sector_t * type, sector_t * model);

static void MoveElevator(elev_move_t *elev);
static void MovePlane(plane_move_t *plane);
static void MoveSlider(slider_move_t *smov);
</t>
<t tx="T1956">@ -AJA- Perhaps using a pointer to `plane_info_t' would be better
than f**king about with the floorOrCeiling stuff all the
time.
@c

static float_t HEIGHT(sector_t * sec, boolean_t is_ceiling)
{
  if (is_ceiling)
    return sec-&gt;c_h;

  return sec-&gt;f_h;
}
</t>
<t tx="T1957">
static const image_t * SECPIC(sector_t * sec, boolean_t is_ceiling,
    const image_t *new_image)
{
  if (new_image)
  {
    if (is_ceiling) 
      sec-&gt;ceil.image = new_image;
    else
      sec-&gt;floor.image = new_image;
  }

  return is_ceiling ? sec-&gt;ceil.image : sec-&gt;floor.image;
}
</t>
<t tx="T1958">@ Get


GetSecHeightReference

Finds a sector height, using the reference provided; will select
the approriate method of obtaining this value, if it cannot
get it directly.

-KM- 1998/09/01 Wrote Procedure.
-ACB- 1998/09/06 Remarked and Reformatted.
-ACB- 2001/02/04 Move to p_plane.c
@c

static float_t GetSecHeightReference(heightref_e ref, sector_t * sec)
{
  switch (ref &amp; REF_MASK)
  {
    case REF_Absolute:
      return 0;

    case REF_Current:
      return (ref &amp; REF_CEILING) ? sec-&gt;c_h : sec-&gt;f_h;

    case REF_Surrounding:
      return P_FindSurroundingHeight(ref, sec);

    case REF_LowestLoTexture:
      return P_FindRaiseToTexture(sec);

    default:
      I_Error("GetSecHeightReference: undefined reference %d\n", ref);
  }

  return 0;
}
</t>
<t tx="T1959">@ GetElevatorHeightReference

This is essentially the same as above, but used for elevator
calculations. The reason behind this is that elevators have to
work as dummy sectors.

-ACB- 2001/02/04 Written
@c

static float_t GetElevatorHeightReference(heightref_e ref, sector_t * sec)
{
  return -1;
}
</t>
<t tx="T1960">@ P_AddActivePart

Adds to the tail of the list.
@c

void P_AddActivePart(gen_move_t *movpart)
{
  gen_move_t *tmp;

  movpart-&gt;next = NULL;
  
  if (!active_movparts)
  {
    movpart-&gt;prev = NULL;
    active_movparts = movpart;
    return;
  }
  
  for(tmp = active_movparts; tmp-&gt;next; tmp = tmp-&gt;next)
  { /* Do Nothing */ };

  movpart-&gt;prev = tmp;
  tmp-&gt;next = movpart;
}
</t>
<t tx="T1961">@ P_RemoveActivePart
@c

static void P_RemoveActivePart(gen_move_t *movpart)
{
  elev_move_t *elev;
  plane_move_t *plane;
  slider_move_t *slider;

  switch(movpart-&gt;whatiam)
  {
    case MDT_ELEVATOR:
      elev = (elev_move_t*)movpart;
      elev-&gt;sector-&gt;ceil_move = NULL;
      elev-&gt;sector-&gt;floor_move = NULL;
      break;

    case MDT_PLANE:
      plane = (plane_move_t*)movpart;
      if (plane-&gt;is_ceiling)
        plane-&gt;sector-&gt;ceil_move = NULL;
      else
        plane-&gt;sector-&gt;floor_move = NULL;
      break;

    case MDT_SLIDER:
      slider = (slider_move_t*)movpart;
      slider-&gt;line-&gt;slider_move = NULL;
      break;

    default:
      break;
  }

  if (movpart-&gt;prev)
    movpart-&gt;prev-&gt;next = movpart-&gt;next;
  else
    active_movparts = movpart-&gt;next;

  if (movpart-&gt;next)
    movpart-&gt;next-&gt;prev = movpart-&gt;prev;
    
  Z_Free(movpart);
}
</t>
<t tx="T1962">@ P_RemoveAllActiveParts
@c

void P_RemoveAllActiveParts(void)
{
  gen_move_t *movpart, *next;

  for (movpart = active_movparts; movpart; movpart = next)
  {
    next = movpart-&gt;next;
    Z_Free(movpart);            // P_RemoveActivePart() ??
  }
  
  active_movparts = NULL;
}
</t>
<t tx="T1963">@ FLOORS


AttemptMovePlane

Move a plane (floor or ceiling) and check for crushing

Returns:
RES_Ok - the move was completely successful.

RES_Impossible - the move was not possible due to another solid
surface (e.g. an extrafloor) getting in the way. The plane will
remain at its current height.

RES_PastDest - the destination height has been reached. The
actual height in the sector may not be the target height, which
means some objects got in the way (whether crushed or not).

RES_Crushed - some objects got in the way. When `crush'
parameter is true, those object will have been crushed (take
damage) and the plane height will be the new height, otherwise
the plane height will remain at its current height.
@c

static move_result_e AttemptMovePlane(sector_t * sector, 
    float_t speed, float_t dest, boolean_t crush, 
    int is_ceiling, int direction)
{
  boolean_t past = false;
  boolean_t nofit;

  //
  // check whether we have gone past the destination height
  //
  if (direction == DIRECTION_UP &amp;&amp; 
      HEIGHT(sector, is_ceiling) + speed &gt; dest)
  {
    past = true;
    speed = dest - HEIGHT(sector, is_ceiling);
  }
  else if (direction == DIRECTION_DOWN &amp;&amp; 
           HEIGHT(sector, is_ceiling) - speed &lt; dest)
  {
    past = true;
    speed = HEIGHT(sector, is_ceiling) - dest;
  }
 
  if (speed &lt;= 0)
    return RES_PastDest;

  if (direction == DIRECTION_DOWN)
    speed = -speed;

  // check if even possible
  if (! P_CheckSolidSectorMove(sector, is_ceiling, speed))
  {
    return RES_Impossible;
  }
   
  //
  // move the actual sector, including all things in it
  //
  nofit = P_SolidSectorMove(sector, is_ceiling, speed, crush, false);
    
  if (! nofit)
    return past ? RES_PastDest : RES_Ok;

  // bugger, something got in our way !
 
  if (! crush)
  {
    // undo the change
    P_SolidSectorMove(sector, is_ceiling, -speed, false, false);
  }

  return past ? RES_PastDest : RES_Crushed;
}
</t>
<t tx="T1964">@ MovePlane

Move a floor to it's destination (up or down).
@c

static void MovePlane(plane_move_t *plane)
{
  move_result_e res;

  switch (plane-&gt;direction)
  {
    case DIRECTION_STASIS:
      plane-&gt;sfxstarted = false;
      break;

    case DIRECTION_DOWN:
      res = AttemptMovePlane(plane-&gt;sector, plane-&gt;speed,
          MIN(plane-&gt;startheight, plane-&gt;destheight),
          plane-&gt;crush &amp;&amp; plane-&gt;is_ceiling,
          plane-&gt;is_ceiling, plane-&gt;direction);

      if (!plane-&gt;sfxstarted)
      {
        S_StartSound((mobj_t *) &amp;plane-&gt;sector-&gt;soundorg, 
            plane-&gt;type-&gt;sfxdown);
        plane-&gt;sfxstarted = true;
      }

      if (res == RES_PastDest)
      {
        S_StartSound((mobj_t *) &amp;plane-&gt;sector-&gt;soundorg, 
            plane-&gt;type-&gt;sfxstop);
        plane-&gt;speed = plane-&gt;type-&gt;speed_up;

        if (plane-&gt;newspecial != -1)
        {
          plane-&gt;sector-&gt;props.special = (plane-&gt;newspecial &lt;= 0) ? NULL :
              DDF_SectorLookupNum(plane-&gt;newspecial);
        }

        SECPIC(plane-&gt;sector, plane-&gt;is_ceiling, plane-&gt;new_image);

        switch (plane-&gt;type-&gt;type)
        {
          case mov_Plat:
          case mov_Continuous:
            plane-&gt;direction = DIRECTION_WAIT;
            plane-&gt;waited = plane-&gt;type-&gt;wait;
            plane-&gt;speed = plane-&gt;type-&gt;speed_up;
            break;

          case mov_MoveWaitReturn:
            if (HEIGHT(plane-&gt;sector, plane-&gt;is_ceiling) == plane-&gt;startheight)
            {
              P_RemoveActivePart((gen_move_t*)plane);
            }
            else  // assume we reached the destination
            {
              plane-&gt;direction = DIRECTION_WAIT;
              plane-&gt;waited = plane-&gt;type-&gt;wait;
              plane-&gt;speed = plane-&gt;type-&gt;speed_up;
            }
            break;

          default:
          case mov_Stairs:
          case mov_Once:
            P_RemoveActivePart((gen_move_t*)plane);
            break;
        }
      }
      else if (res == RES_Crushed || res == RES_Impossible)
      {
        if (plane-&gt;crush)
        {
          plane-&gt;speed = plane-&gt;type-&gt;speed_down / 8;
        }
        else if (plane-&gt;type-&gt;type == mov_MoveWaitReturn)  // Go back up
        {
          plane-&gt;direction = 1;
          plane-&gt;sfxstarted = false;
          plane-&gt;waited = 0;
          plane-&gt;speed = plane-&gt;type-&gt;speed_up;
        }
      }

      break;

    case DIRECTION_WAIT:
      if (--plane-&gt;waited &lt;= 0)
      {
        int dir;
        float_t dest;

        if (HEIGHT(plane-&gt;sector, plane-&gt;is_ceiling) == plane-&gt;destheight)
          dest = plane-&gt;startheight;
        else
          dest = plane-&gt;destheight;

        if (HEIGHT(plane-&gt;sector, plane-&gt;is_ceiling) &gt; dest)
        {
          dir = -1;
          plane-&gt;speed = plane-&gt;type-&gt;speed_down;
        }
        else
        {
          dir = 1;
          plane-&gt;speed = plane-&gt;type-&gt;speed_up;
        }

        if (dir)
        {
          S_StartSound((mobj_t *) &amp;plane-&gt;sector-&gt;soundorg,
              plane-&gt;type-&gt;sfxstart);
        }

        plane-&gt;direction = dir;  // time to go back
        plane-&gt;sfxstarted = false;
      }
      break;

    case DIRECTION_UP:
      res = AttemptMovePlane(plane-&gt;sector, plane-&gt;speed,
          MAX(plane-&gt;startheight, plane-&gt;destheight),
          plane-&gt;crush &amp;&amp; !plane-&gt;is_ceiling,
          plane-&gt;is_ceiling, plane-&gt;direction);

      if (!plane-&gt;sfxstarted)
      {
        S_StartSound((mobj_t *) &amp;plane-&gt;sector-&gt;soundorg, 
            plane-&gt;type-&gt;sfxup);
        plane-&gt;sfxstarted = true;
      }

      if (res == RES_PastDest)
      {
        S_StartSound((mobj_t *) &amp;plane-&gt;sector-&gt;soundorg, 
            plane-&gt;type-&gt;sfxstop);

        if (plane-&gt;newspecial != -1)
        {
          plane-&gt;sector-&gt;props.special = (plane-&gt;newspecial &lt;= 0) ? NULL :
            DDF_SectorLookupNum(plane-&gt;newspecial);
        }

        SECPIC(plane-&gt;sector, plane-&gt;is_ceiling, plane-&gt;new_image);

        switch (plane-&gt;type-&gt;type)
        {
          case mov_Plat:
          case mov_Continuous:
            plane-&gt;direction = 0;
            plane-&gt;waited = plane-&gt;type-&gt;wait;
            plane-&gt;speed = plane-&gt;type-&gt;speed_down;
            break;

          case mov_MoveWaitReturn:
            if (HEIGHT(plane-&gt;sector, plane-&gt;is_ceiling) == plane-&gt;startheight)
            {
              P_RemoveActivePart((gen_move_t*)plane);
            }
            else  // assume we reached the destination
            {
              plane-&gt;direction = 0;
              plane-&gt;speed = plane-&gt;type-&gt;speed_down;
              plane-&gt;waited = plane-&gt;type-&gt;wait;
            }
            break;

          default:
          case mov_Once:
          case mov_Stairs:
            P_RemoveActivePart((gen_move_t*)plane);
            break;
        }

      }
      else if (res == RES_Crushed || res == RES_Impossible)
      {
        if (plane-&gt;crush)
        {
          plane-&gt;speed = plane-&gt;type-&gt;speed_up / 8;
        }
        else if (plane-&gt;type-&gt;type == mov_MoveWaitReturn)  // Go back down
        {
          plane-&gt;direction = -1;
          plane-&gt;sfxstarted = false;
          plane-&gt;waited = 0;
          plane-&gt;speed = plane-&gt;type-&gt;speed_down;
        }
      }
      break;

    default:
      I_Error("MovePlane: Unknown direction %d", plane-&gt;direction);
  }
}
</t>
<t tx="T1965">@ P_RunActiveSectors

Executes one tic's plane_move_t thinking.
Active sectors can destroy themselves, but not each other.
We do not have to bother about a removal queue, but we can not rely on
sec still being in memory after MovePlane.

-AJA- 2000/08/06 Now handles horizontal sliding doors too.
-ACB- 2001/01/14 Now handles elevators too.
-ACB- 2001/02/08 Now generic routine with gen_move_t;
@c

void P_RunActiveSectors(void)
{
  gen_move_t *part, *part_next;

  for (part = active_movparts; part; part = part_next)
  {
    part_next = part-&gt;next;

    switch (part-&gt;whatiam)
    {
      case MDT_ELEVATOR:
        MoveElevator((elev_move_t*)part);
        break;

      case MDT_PLANE:
        MovePlane((plane_move_t*)part);
        break;

      case MDT_SLIDER:
        MoveSlider((slider_move_t*)part);
        break;

      default:
        break;
    }
  }
}
</t>
<t tx="T1966">@ P_GSS
@c

static sector_t *P_GSS(sector_t * sec, float_t dest, boolean_t forc)
{
  int i;
  int secnum = sec - sectors;
  sector_t *sector;

  for (i = sec-&gt;linecount-1; i; i--)
  {
    if (P_TwoSided(secnum, i))
    {
      if (P_GetSide(secnum, i, 0)-&gt;sector - sectors == secnum)
      {
        sector = P_GetSector(secnum, i, 1);

        if (SECPIC(sector, forc, NULL) != SECPIC(sec, forc, NULL)
            &amp;&amp; HEIGHT(sector, forc) == dest)
        {
          return sector;
        }

      }
      else
      {
        sector = P_GetSector(secnum, i, 0);
        
        if (SECPIC(sector, forc, NULL) != SECPIC(sec, forc, NULL)
            &amp;&amp; HEIGHT(sector, forc) == dest)
        {
          return sector;
        }
      }
    }
  }

  for (i = sec-&gt;linecount; i--;)
  {
    if (P_TwoSided(secnum, i))
    {
      if (P_GetSide(secnum, i, 0)-&gt;sector - sectors == secnum)
      {
        sector = P_GetSector(secnum, i, 1);
      }
      else
      {
        sector = P_GetSector(secnum, i, 0);
      }
      if (sector-&gt;validcount != validcount)
      {
        sector-&gt;validcount = validcount;
        sector = P_GSS(sector, dest, forc);
        if (sector)
          return sector;
      }
    }
  }

  return NULL;
}
</t>
<t tx="T1967">@ P_GetSectorSurrounding
@c

static sector_t *P_GetSectorSurrounding(sector_t * sec, float_t dest, boolean_t forc)
{
  validcount++;
  sec-&gt;validcount = validcount;
  return P_GSS(sec, dest, forc);
}
</t>
<t tx="T1968">@ P_SetupSectorAction

Setup the Floor Action, depending on the linedeftype trigger and the
sector info.
@c

static plane_move_t *P_SetupSectorAction(sector_t * sector, const moving_plane_t * type, sector_t * model)
{
  plane_move_t *plane;
  float_t start, dest;

  // new door thinker
  plane = Z_New(plane_move_t, 1);

  if (type-&gt;is_ceiling)
    sector-&gt;ceil_move = (void*)plane;
  else
    sector-&gt;floor_move = (void*)plane;

  plane-&gt;whatiam = MDT_PLANE;
  plane-&gt;sector = sector;
  plane-&gt;crush = type-&gt;crush;
  plane-&gt;sfxstarted = false;
  start = HEIGHT(sector, type-&gt;is_ceiling);

  dest = GetSecHeightReference(type-&gt;destref, sector);
  dest += type-&gt;dest;

  if (type-&gt;type == mov_Plat || type-&gt;type == mov_Continuous)
  {
    start = GetSecHeightReference(type-&gt;otherref, sector);
    start += type-&gt;other;
  }

#if 0  // DEBUG
  L_WriteDebug("SEC_ACT: %d type %d %s start %1.0f dest %1.0f\n",
      sector - sectors, type-&gt;type, type-&gt;is_ceiling ? "CEIL" : "FLOOR", 
      start, dest);
#endif

  //--------------------------------------------------------------------------
  // Floor Speed Notes:
  //
  //   Floor speed setup; -M_PI is the default speed, This is used to simulate
  //   the use of an instant movement. i.e. a floor that raises or falls to
  //   its destination height in one tic: This is also implemented for WAD's
  //   that use odd linedef requests to achieve the instant effect.
  //
  //   If someone would want a speed close to -3.1, the probability that
  //   he would use -M_PI accidentally is really low, so we do not care about
  //   it. I can't think of any situation where there is a point in setting
  //   the speed to exactly pi.
  //
  //   Therefore a speed of -M_PI, is translated to the distance between the
  //   start and destination: instant movement; otherwise the speed is taken
  //   from the linedef type.
  //
  //--------------------------------------------------------------------------
  if (type-&gt;prewait)
  {
    plane-&gt;direction = DIRECTION_WAIT;
    plane-&gt;waited = type-&gt;prewait;
  }
  else if (type-&gt;type == mov_Continuous)
  {
    plane-&gt;direction = (P_Random() &amp; 1) ? DIRECTION_UP : DIRECTION_DOWN;

    if (plane-&gt;direction == DIRECTION_UP)
      plane-&gt;speed = type-&gt;speed_up;
    else
      plane-&gt;speed = type-&gt;speed_down;
  }
  else if (dest &gt; start)
  {
    plane-&gt;direction = DIRECTION_UP;

    // -ACB- 1998/09/09 See floor speed notes...
    if (type-&gt;speed_up &gt;= 0)
      plane-&gt;speed = type-&gt;speed_up;
    else
      plane-&gt;speed = dest - start;
  }
  else if (start &gt; dest)
  {
    plane-&gt;direction = DIRECTION_DOWN;

    // -ACB- 1998/09/09 See floor speed notes...
    if (type-&gt;speed_down &gt;= 0)
      plane-&gt;speed = type-&gt;speed_down;
    else
      plane-&gt;speed = start - dest;
  }
  else
  {
    if (type-&gt;is_ceiling)
      sector-&gt;ceil_move = NULL;
    else
      sector-&gt;floor_move = NULL;

    Z_Free(plane);
    return NULL;
  }

  plane-&gt;destheight = dest;
  plane-&gt;startheight = start;
  plane-&gt;tag = sector-&gt;tag;
  plane-&gt;type = type;
  plane-&gt;new_image = SECPIC(sector, type-&gt;is_ceiling, NULL);
  plane-&gt;newspecial = -1;
  plane-&gt;is_ceiling = type-&gt;is_ceiling;

  // -ACB- 10/01/2001 Trigger starting sfx
  S_StopLoopingSound((mobj_t *) &amp; sector-&gt;soundorg);
  if (type-&gt;sfxstart)
    S_StartSound((mobj_t *) &amp; sector-&gt;soundorg, type-&gt;sfxstart);

  // change to surrounding
  if (type-&gt;tex[0] == '-')
  {
    model = P_GetSectorSurrounding(sector, plane-&gt;destheight, type-&gt;is_ceiling);
    if (model)
    {
      plane-&gt;new_image = SECPIC(model, type-&gt;is_ceiling, NULL);

      plane-&gt;newspecial = model-&gt;props.special ?
          model-&gt;props.special-&gt;ddf.number : 0;
    }
    if (plane-&gt;direction == (type-&gt;is_ceiling ? -1 : 1))
    {
      SECPIC(sector, type-&gt;is_ceiling, plane-&gt;new_image);
      if (plane-&gt;newspecial != -1)
      {
        sector-&gt;props.special = (plane-&gt;newspecial &lt;= 0) ? NULL :
          DDF_SectorLookupNum(plane-&gt;newspecial);
      }
    }
  }
  else if (type-&gt;tex[0] == '+')
  {
    if (model)
    {
      if (SECPIC(model,  type-&gt;is_ceiling, NULL) == 
          SECPIC(sector, type-&gt;is_ceiling, NULL))
      {
        model = P_GetSectorSurrounding(model, plane-&gt;destheight,
          type-&gt;is_ceiling);
      }
    }

    if (model)
    {
      plane-&gt;new_image = SECPIC(model, type-&gt;is_ceiling, NULL);
      plane-&gt;newspecial = model-&gt;props.special ?
          model-&gt;props.special-&gt;ddf.number : 0;

      if (plane-&gt;direction == (type-&gt;is_ceiling ? -1 : 1))
      {
        SECPIC(sector, type-&gt;is_ceiling, plane-&gt;new_image);

        if (plane-&gt;newspecial != -1)
        {
          sector-&gt;props.special = (plane-&gt;newspecial &lt;= 0) ? NULL :
            DDF_SectorLookupNum(plane-&gt;newspecial);
        }
      }
    }
  }
  else if (type-&gt;tex[0])
  {
    plane-&gt;new_image = W_ImageFromFlat(type-&gt;tex);
  }

  P_AddActivePart((gen_move_t*)plane);
  return plane;
}
</t>
<t tx="T1969">@ EV_Teleport

Teleportation is an effect which is simulated by searching for the first
special[MOBJ_TELEPOS] in a sector with the same tag as the activation line,
moving an object from one sector to another upon the MOBJ_TELEPOS found, and
possibly spawning an effect object (i.e teleport flash) at either the entry &amp;
exit points or both.

-KM- 1998/09/01 Added stuff for lines.ddf (mostly sounds)

-ACB- 1998/09/11 Reformatted and cleaned up.

-ACB- 1998/09/12 Teleport delay setting from linedef.

-ACB- 1998/09/13 used effect objects: the objects themselves make any sound and
the in effect object can be different to the out object.

-ACB- 1998/09/13 Removed the missile checks: no need since this would have been
Checked at the linedef stage.

-KM- 1998/11/25 Changed Erik's code a bit, Teleport flash still appears.
if def faded_teleportation == 1, doesn't if faded_teleportation == 2

-ES- 1998/11/28 Changed Kester's code a bit :-) Teleport method can now be
toggled in the menu. (That is the way it should be. -KM)

-KM- 1999/01/31 Search only the target sector, not the entire map.

-AJA- 1999/07/12: Support for TELEPORT_SPECIAL in lines.ddf.
-AJA- 1999/07/30: Updated for extra floor support.
-AJA- 1999/10/21: Allow line to be NULL, and added `tag' param.
@c

boolean_t EV_Teleport
(
  line_t* line,
  int tag, 
  int side,
  mobj_t* thing,
  int delay,
  int special,
  const mobjinfo_t* ineffectobj,
  const mobjinfo_t * outeffectobj
)
{
  int i;
  angle_t an;
  mobj_t *currmobj;
  float_t oldx;
  float_t oldy;
  float_t oldz;
  float_t centre_x, centre_y;
  float_t new_x, new_y, new_z;
  mobj_t *fog;

  if (!thing)
    return false;

  for (i = 0; i &lt; numsubsectors; i++)
  {
    if (subsectors[i].sector-&gt;tag != tag)
      continue;

    currmobj = subsectors[i].thinglist;

    while (currmobj)
    {
      // not a teleportman
      if (currmobj-&gt;info != outeffectobj)
      {
        currmobj = currmobj-&gt;snext;
        continue;
      }

      oldx = thing-&gt;x;
      oldy = thing-&gt;y;
      oldz = thing-&gt;z;

      new_x = currmobj-&gt;x;
      new_y = currmobj-&gt;y;
      new_z = currmobj-&gt;z;

      if (line &amp;&amp; (special &amp; TELSP_SameOffset))
      {
        centre_x = (line-&gt;v1-&gt;x + line-&gt;v2-&gt;x) / 2;
        centre_y = (line-&gt;v1-&gt;y + line-&gt;v2-&gt;y) / 2;

        new_x += thing-&gt;x - centre_x;
        new_y += thing-&gt;y - centre_y;
      }

      if (special &amp; TELSP_SameHeight)
        new_z += (thing-&gt;z - thing-&gt;floorz);
      else if (thing-&gt;flags &amp; MF_MISSILE)
        new_z += thing-&gt;origheight;

      if (!P_TeleportMove(thing, new_x, new_y, new_z))
        return false;

      if (thing-&gt;player)
        thing-&gt;player-&gt;viewz = thing-&gt;z + thing-&gt;player-&gt;viewheight;

      // spawn teleport fog at source and destination
      if (ineffectobj)
      {
        fog = P_MobjCreateObject(oldx, oldy, oldz, ineffectobj);

        if (fog-&gt;info-&gt;chase_state)
          P_SetMobjState(fog, fog-&gt;info-&gt;chase_state);
      }

      an = currmobj-&gt;angle;

      //
      // -ACB- 1998/09/06 Switched 40 to 20. This by my records is
      //                  the original setting.
      //
      // -ES- 1998/10/29 When fading, we don't want to see the fog.
      //
      fog = P_MobjCreateObject(currmobj-&gt;x + 20 * M_Cos(an),
          currmobj-&gt;y + 20 * M_Sin(an),
          currmobj-&gt;z, outeffectobj);

      if (fog-&gt;info-&gt;chase_state)
        P_SetMobjState(fog, fog-&gt;info-&gt;chase_state);

      if (thing-&gt;player &amp;&amp; !telept_flash)
        fog-&gt;vis_target = fog-&gt;visibility = INVISIBLE;

      // don't move for a bit
      if (thing-&gt;player &amp;&amp; !(special &amp; TELSP_SameSpeed))
      {
        thing-&gt;reactiontime = delay;
        // -ES- 1998/10/29 Start the fading
        if (telept_effect &amp;&amp; thing-&gt;player == displayplayer)
          R_StartFading(0, (delay * 5) / 2);
        thing-&gt;mom.x = thing-&gt;mom.y = thing-&gt;mom.z = 0;
      }

      if (special &amp; TELSP_Rotate)
      {
        thing-&gt;angle += currmobj-&gt;angle;
      }
      else if (!(special &amp; TELSP_SameDir))
      {
        thing-&gt;angle = currmobj-&gt;angle;
        thing-&gt;vertangle = currmobj-&gt;vertangle;
      }

      if (thing-&gt;flags &amp; MF_MISSILE)
      {
        thing-&gt;mom.x = thing-&gt;speed * M_Cos(thing-&gt;angle);
        thing-&gt;mom.y = thing-&gt;speed * M_Sin(thing-&gt;angle);
      }

      return true;

    }  // while (currmobj)

  }  // for (subsector) loop

  return false;
}
</t>
<t tx="T1970">@ EV_BuildOneStair

BUILD A STAIRCASE!

-AJA- 1999/07/04: Fixed the problem on MAP20. The next stair's
dest height should be relative to the previous stair's dest height
(and not just the current height).

-AJA- 1999/07/29: Split into two functions. The old code could do bad
things (e.g. skip a whole staircase) when 2 or more stair sectors
were tagged.
@c

static boolean_t EV_BuildOneStair(sector_t * sec, const moving_plane_t * type)
{
  int i;
  float_t next_height;
  boolean_t more;
  boolean_t rtn;

  plane_move_t *stairs;
  sector_t *tsec;
  float_t stairsize = type-&gt;dest;

  const image_t *image = sec-&gt;floor.image;

  // new floor thinker

  stairs = P_SetupSectorAction(sec, type, sec);
  rtn = stairs ? true : false;
  next_height = stairs-&gt;destheight + stairsize;

  do
  {
    more = false;

    // Find next sector to raise
    //
    // 1. Find 2-sided line with same sector side[0]
    // 2. Other side is the next sector to raise
    //
    for (i = 0; i &lt; sec-&gt;linecount; i++)
    {
      if (!(sec-&gt;lines[i]-&gt;flags &amp; ML_TwoSided))
        continue;

      if (sec != sec-&gt;lines[i]-&gt;frontsector)
        continue;

      tsec = sec-&gt;lines[i]-&gt;backsector;

      if (tsec-&gt;floor.image != image)
        continue;

      if (type-&gt;is_ceiling &amp;&amp; tsec-&gt;ceil_move)
        continue;

      if (!type-&gt;is_ceiling &amp;&amp; tsec-&gt;floor_move)
        continue;

      stairs = P_SetupSectorAction(tsec, type, tsec);

      if (stairs)
      {
        stairs-&gt;destheight = next_height;
        next_height += stairsize;
        sec = tsec;
        more = true;
      }

      break;
    }
  }
  while (more);

  return rtn;
}
</t>
<t tx="T1971">@ EV_BuildStairs
@c

static boolean_t EV_BuildStairs(sector_t * sec, const moving_plane_t * type)
{
  boolean_t rtn = false;

  while (sec-&gt;tag_prev)
    sec = sec-&gt;tag_prev;

  for (; sec; sec = sec-&gt;tag_next)
  {
    // Already moving?  If so, keep going...
    if (sec-&gt;ceil_move &amp;&amp; type-&gt;is_ceiling)
      continue;

    // Already moving?  If so, keep going...
    if (sec-&gt;floor_move &amp;&amp; !type-&gt;is_ceiling)
      continue;

    if (EV_BuildOneStair(sec, type))
      rtn = true;
  }

  return rtn;
}
</t>
<t tx="T1972">@ EV_DoPlane

Do Platforms/Floors/Stairs/Ceilings/Doors
@c

boolean_t EV_DoPlane(sector_t * sec, const moving_plane_t * type, sector_t * model)
{
  // Activate all &lt;type&gt; plats that are in_stasis
  switch (type-&gt;type)
  {
    case mov_Plat:
    case mov_Continuous:
      if (P_ActivateInStasis(sec-&gt;tag))
        return true;
      break;

    case mov_Stairs:
      return EV_BuildStairs(sec, type);

    case mov_Stop:
      return P_StasifySector(sec);

    default:
      break;
  }

  if (type-&gt;is_ceiling)
  {
    if (sec-&gt;ceil_move)
      return false;
  }
  else
  {
    if (sec-&gt;floor_move)
      return false;
  }

  // Do Floor action
  return P_SetupSectorAction(sec, type, model) ? true : false;
}
</t>
<t tx="T1973">@ EV_ManualPlane
@c

boolean_t EV_ManualPlane(line_t * line, mobj_t * thing, const moving_plane_t * type)
{
  sector_t *sec;
  plane_move_t *msec;
  int side;
  int dir = 1;
  int olddir = 1;

  side = 0;  // only front sides can be used

  // if the sector has an active thinker, use it
  sec = side ? line-&gt;frontsector : line-&gt;backsector;
  if (!sec)
    return false;

  if (type-&gt;is_ceiling)
    msec = (plane_move_t *)sec-&gt;ceil_move;
  else
    msec = (plane_move_t *)sec-&gt;floor_move;

  if (msec &amp;&amp; thing)
  {
    switch (type-&gt;type)
    {
      case mov_MoveWaitReturn:
        olddir = msec-&gt;direction;

        // Only players close doors
        if ((msec-&gt;direction != -1) &amp;&amp; thing-&gt;player)
          dir = msec-&gt;direction = -1;
        else
          dir = msec-&gt;direction = 1;
        break;
        
      default:
        break;
    }

    if (dir != olddir)
    {
      S_StartSound((mobj_t *) &amp; sec-&gt;soundorg, type-&gt;sfxstart);
      msec-&gt;sfxstarted = !(thing-&gt;player);
      return true;
    }

    return false;
  }

  return EV_DoPlane(sec, type, sec);
}
</t>
<t tx="T1974">@ P_ActivateInStasis
@c

static boolean_t P_ActivateInStasis(int tag)
{
  boolean_t rtn;
  gen_move_t *movpart;
  plane_move_t *plane;

  rtn = false;
  for (movpart = active_movparts; movpart; movpart = movpart-&gt;next)
  {
    if (movpart-&gt;whatiam == MDT_PLANE)
    {
      plane = (plane_move_t*)movpart;
      if(plane-&gt;direction == -2 &amp;&amp; plane-&gt;tag == tag)
      {
        plane-&gt;direction = plane-&gt;olddirection;
        rtn = true;
      }
    }
  }

  return rtn;
}
</t>
<t tx="T1975">@ P_StasifySector
@c

static boolean_t P_StasifySector(sector_t * sec)
{
  boolean_t rtn;
  gen_move_t *movpart;
  plane_move_t *plane;

  rtn = false;
  for (movpart = active_movparts; movpart; movpart = movpart-&gt;next)
  {
    if (movpart-&gt;whatiam == MDT_PLANE)
    {
      plane = (plane_move_t*)movpart;
      if(plane-&gt;direction != -2 &amp;&amp; plane-&gt;tag == sec-&gt;tag)
      {
        plane-&gt;olddirection = plane-&gt;direction;
        plane-&gt;direction = -2;
        rtn = true;
      }
    }
  }

  return rtn;
}
</t>
<t tx="T1976">@ -AJA- 1999/12/07: cleaned up this donut stuff
@c

linedeftype_t donut[2];
static int donut_setup = 0;

//
// EV_DoDonut
//
// Special Stuff that can not be categorized
// Mmmmmmm....  Donuts....
//
boolean_t EV_DoDonut(sector_t * s1, sfx_t *sfx[4])
{
  sector_t *s2;
  sector_t *s3;
  boolean_t result = false;
  int i;
  plane_move_t *sec;

  if (! donut_setup)
  {
    donut[0] = template_line;
    donut[0].count = 1;
    donut[0].specialtype = 0;
    donut[0].f = donut_floor;
    strcpy(donut[0].f.tex, "-");

    donut[1] = template_line;
    donut[1].count = 1;
    donut[1].f = donut_floor;
    donut[1].f.dest = INT_MIN;

    donut_setup++;
  }
  
  // ALREADY MOVING?  IF SO, KEEP GOING...
  if (s1-&gt;floor_move)
    return false;

  s2 = P_GetNextSector(s1-&gt;lines[0], s1);

  for (i = 0; i &lt; s2-&gt;linecount; i++)
  {
    if ((!s2-&gt;lines[i]-&gt;flags &amp; ML_TwoSided) || (s2-&gt;lines[i]-&gt;backsector == s1))
      continue;

    s3 = s2-&gt;lines[i]-&gt;backsector;

    result = true;

    // Spawn rising slime
    donut[0].f.sfxup = sfx[0];
    donut[0].f.sfxstop = sfx[1];
    
    sec = P_SetupSectorAction(s2, &amp;donut[0].f, s3);

    if (sec)
    {
      sec-&gt;destheight = s3-&gt;f_h;
      s2-&gt;floor.image = sec-&gt;new_image = s3-&gt;floor.image;
      s2-&gt;props.special = s3-&gt;props.special;
    }

    // Spawn lowering donut-hole
    donut[1].f.sfxup = sfx[2];
    donut[1].f.sfxstop = sfx[3];

    sec = P_SetupSectorAction(s1, &amp;donut[1].f, s1);

    if (sec)
      sec-&gt;destheight = s3-&gt;f_h;
    break;
  }

  return result;
}
</t>
<t tx="T1977">@ SliderCanClose
@c

static INLINE boolean_t SliderCanClose(line_t *line)
{
  return ! P_ThingsOnLine(line);
}
</t>
<t tx="T1978">@ MoveSlider
@c

static void MoveSlider(slider_move_t *smov)
{
  sector_t *sec = smov-&gt;line-&gt;frontsector;

  switch (smov-&gt;direction)
  {
    // WAITING
    case 0:
      if (--smov-&gt;waited &lt;= 0)
      {
        if (SliderCanClose(smov-&gt;line))
        {
          S_StartSound((mobj_t *) &amp; sec-&gt;soundorg, smov-&gt;info-&gt;sfx_start);
          smov-&gt;sfxstarted = false;
          smov-&gt;direction = -1;
        }
        else
        {
          // try again soon
          smov-&gt;waited = TICRATE / 3;
        }
      }
      break;

    // OPENING
    case 1:
      if (! smov-&gt;sfxstarted)
      {
        S_StartSound((mobj_t *) &amp; sec-&gt;soundorg, smov-&gt;info-&gt;sfx_open);
        smov-&gt;sfxstarted = true;
      }

      smov-&gt;opening += smov-&gt;info-&gt;speed;

      // mark line as non-blocking (at some point)
      P_ComputeGaps(smov-&gt;line);

      if (smov-&gt;opening &gt;= smov-&gt;target)
      {
        S_StartSound((mobj_t *) &amp; sec-&gt;soundorg, smov-&gt;info-&gt;sfx_stop);
        smov-&gt;opening = smov-&gt;target;
        smov-&gt;direction = 0;
        smov-&gt;waited = smov-&gt;info-&gt;wait;

        if (smov-&gt;final_open)
        {
          line_t *ld = smov-&gt;line;

          // clear line special
          ld-&gt;special = NULL;

          P_RemoveActivePart((gen_move_t*)smov);

          // clear the side textures
          ld-&gt;side[0]-&gt;middle.image = NULL;
          ld-&gt;side[1]-&gt;middle.image = NULL;

          P_ComputeWallTiles(ld, 0);
          P_ComputeWallTiles(ld, 1);

          return;
        }
      }
      break;

    // CLOSING
    case -1:
      if (! smov-&gt;sfxstarted)
      {
        S_StartSound((mobj_t *) &amp; sec-&gt;soundorg, smov-&gt;info-&gt;sfx_close);
        smov-&gt;sfxstarted = true;
      }

      smov-&gt;opening -= smov-&gt;info-&gt;speed;

      // mark line as blocking (at some point)
      P_ComputeGaps(smov-&gt;line);

      if (smov-&gt;opening &lt;= 0.0)
      {
        S_StartSound((mobj_t *) &amp; sec-&gt;soundorg, smov-&gt;info-&gt;sfx_stop);
        P_RemoveActivePart((gen_move_t*)smov);
        return;
      }
      break;

    default:
      I_Error("MoveSlider: Unknown direction %d", smov-&gt;direction);
  }
}
</t>
<t tx="T1979">@ EV_DoSlider

Handle thin horizontal sliding doors.
@c

void EV_DoSlider(line_t * line, mobj_t * thing, const sliding_door_t * s)
{
  sector_t *sec = line-&gt;frontsector;
  slider_move_t *smov;

  if (! thing || ! sec || ! line-&gt;side[0] || ! line-&gt;side[1])
    return;

  // if the line has an active thinker, use it
  if (line-&gt;slider_move)
  {
    smov = line-&gt;slider_move;

    // only players close doors
    if (smov-&gt;direction == 0 &amp;&amp; thing-&gt;player)
    {
      smov-&gt;waited = 0;
    }
    return;
  }

  // new sliding door thinker
  smov = Z_New(slider_move_t, 1);

  smov-&gt;whatiam = MDT_SLIDER;
  smov-&gt;info = &amp;line-&gt;special-&gt;s;
  smov-&gt;line = line;
  smov-&gt;opening = 0.0;
  smov-&gt;line_len = R_PointToDist(0, 0, line-&gt;dx, line-&gt;dy);
  smov-&gt;target = smov-&gt;line_len * PERCENT_2_FLOAT(smov-&gt;info-&gt;distance);

  smov-&gt;direction = 1;
  smov-&gt;sfxstarted = ! thing-&gt;player;
  smov-&gt;final_open = (line-&gt;count == 1);

  line-&gt;slider_move = smov;

  P_AddActivePart((gen_move_t*)smov);

  S_StartSound((mobj_t *) &amp; sec-&gt;soundorg, s-&gt;sfx_start);

  // Must handle line count here, since the normal code in p_spec.c
  // will clear the line-&gt;special pointer, confusing various bits of
  // code that deal with sliding doors (--&gt; crash).
  // 
  if (line-&gt;count &gt; 0)
    line-&gt;count--;
}
</t>
<t tx="T1980">@ AttemptMoveElevator
@c

static move_result_e AttemptMoveElevator(sector_t *sec, float_t speed, 
    float_t dest, int direction)
{
#if 0  // -AJA- FIXME: exfloorlist[] removed
  move_result_e res;
  boolean_t didnotfit;
  float_t currdest;
  float_t lastfh;
  float_t lastch;
  float_t diff;
  sector_t *parentsec;
  int i;

  res = RES_Ok;

  currdest = 0.0f;

  if (direction == DIRECTION_UP)
    currdest = sec-&gt;c_h + speed;
  else if (direction == DIRECTION_DOWN)
    currdest = sec-&gt;f_h - speed;

  for (i=0; i&lt;sec-&gt;exfloornum; i++)
  {
    parentsec = sec-&gt;exfloorlist[i];

    if (direction == DIRECTION_UP)
    {
      if (currdest &gt; dest)
      {
        lastch = sec-&gt;c_h;
        lastfh = sec-&gt;f_h;

        diff = lastch - dest;

        sec-&gt;c_h = dest;
        sec-&gt;f_h -= diff;
        didnotfit = P_ChangeSector(sec, false);
        if (didnotfit)
        {
          sec-&gt;c_h = lastch;
          sec-&gt;f_h = lastfh;
          P_ChangeSector(sec, false);
        }
        res = RES_PastDest;
      } 
      else
      {
        lastch = sec-&gt;c_h;
        lastfh = sec-&gt;f_h;

        diff = lastch - currdest;

        sec-&gt;c_h = currdest;
        sec-&gt;f_h -= diff;
        didnotfit = P_ChangeSector(sec, false);
        if (didnotfit)
        {
          sec-&gt;c_h = lastch;
          sec-&gt;f_h = lastfh;
          P_ChangeSector(sec, false);
          res = RES_PastDest;
        }
      }
    }
    else if (direction == DIRECTION_DOWN)
    {
      if (currdest &lt; dest)
      {
        lastch = sec-&gt;c_h;
        lastfh = sec-&gt;f_h;

        diff = lastfh - dest;

        sec-&gt;c_h -= diff;
        sec-&gt;f_h = dest;
        didnotfit = P_ChangeSector(sec, false);
        if (didnotfit)
        {
          sec-&gt;c_h = lastch;
          sec-&gt;f_h = lastfh;
          P_ChangeSector(sec, false);
        }
        res = RES_PastDest;
      } 
      else
      {
        lastch = sec-&gt;c_h;
        lastfh = sec-&gt;f_h;

        diff = lastfh - currdest;

        sec-&gt;c_h -= diff;
        sec-&gt;f_h = currdest;
        didnotfit = P_ChangeSector(sec, false);
        if (didnotfit)
        {
          sec-&gt;c_h = lastch;
          sec-&gt;f_h = lastfh;
          P_ChangeSector(sec, false);
          res = RES_PastDest;
        }
      }
    }
  }
  return res;
#endif

  return RES_Ok;
}
</t>
<t tx="T1981">@ MoveElevator
@c

static void MoveElevator(elev_move_t *elev)
{
  move_result_e res;
  float_t num;

  switch (elev-&gt;direction)
  {
    case DIRECTION_DOWN:
      res = AttemptMoveElevator(elev-&gt;sector,
                                elev-&gt;speed,
                                elev-&gt;destheight,
                                elev-&gt;direction);

      if (!elev-&gt;sfxstarted)
      {
        S_StartSound((mobj_t *) &amp; elev-&gt;sector-&gt;soundorg, elev-&gt;type-&gt;sfxdown);
        elev-&gt;sfxstarted = true;
      }

      if (res == RES_PastDest || res == RES_Impossible)
      {
        S_StartSound((mobj_t *) &amp; elev-&gt;sector-&gt;soundorg, elev-&gt;type-&gt;sfxstop);
        elev-&gt;speed = elev-&gt;type-&gt;speed_up;

// ---&gt; ACB 2001/03/25 Quick hack to get continous movement
//        P_RemoveActivePart((gen_move_t*)elev);
        elev-&gt;direction = DIRECTION_UP;

        num = elev-&gt;destheight;
        elev-&gt;destheight = elev-&gt;startheight;
        elev-&gt;startheight = num;
// ---&gt; ACB 2001/03/25 Quick hack to get continous movement
      }
      break;
      
    case DIRECTION_WAIT:
      break;
      
    case DIRECTION_UP:
      res = AttemptMoveElevator(elev-&gt;sector,
                                elev-&gt;speed,
                                elev-&gt;destheight,
                                elev-&gt;direction);

      if (!elev-&gt;sfxstarted)
      {
        S_StartSound((mobj_t *) &amp; elev-&gt;sector-&gt;soundorg, elev-&gt;type-&gt;sfxdown);
        elev-&gt;sfxstarted = true;
      }

      if (res == RES_PastDest || res == RES_Impossible)
      {
        S_StartSound((mobj_t *) &amp; elev-&gt;sector-&gt;soundorg, elev-&gt;type-&gt;sfxstop);
        elev-&gt;speed = elev-&gt;type-&gt;speed_down;

// ---&gt; ACB 2001/03/25 Quick hack to get continous movement
//        P_RemoveActivePart((gen_move_t*)elev);

        elev-&gt;direction = DIRECTION_DOWN; 
        num = elev-&gt;destheight;
        elev-&gt;destheight = elev-&gt;startheight;
        elev-&gt;startheight = num;
// ---&gt; ACB 2001/03/25 Quick hack to get continous movement

      }
      break;
      
    default:
      break;
  }

  return;
}
</t>
<t tx="T1982">@ EV_DoElevator

Do Elevators
@c

boolean_t EV_DoElevator(sector_t * sec, const elevator_sector_t * type, sector_t * model)
{
#if 0
  if (!sec-&gt;controller)
    return false;
#endif

  if (sec-&gt;ceil_move || sec-&gt;floor_move)
    return false;

  // Do Elevator action
  return P_SetupElevatorAction(sec, type, model) ? true : false;
}
</t>
<t tx="T1983">@ EV_ManualElevator
@c

boolean_t EV_ManualElevator(line_t * line, mobj_t * thing,  const elevator_sector_t * type)
{
  return false;
}
</t>
<t tx="T1984">@ P_SetupElevatorAction
@c

static elev_move_t *P_SetupElevatorAction(sector_t * sector,
                        const elevator_sector_t * type, sector_t * model)
{
  elev_move_t *elev;
  float_t start, dest;

  // new door thinker
  elev = Z_New(elev_move_t, 1);

  sector-&gt;ceil_move = (void*)elev;
  sector-&gt;floor_move = (void*)elev;

  elev-&gt;whatiam = MDT_ELEVATOR;
  elev-&gt;sector = sector;
  elev-&gt;sfxstarted = false;

// -ACB- BEGINNING OF THE HACKED TO FUCK BIT (START)

  start = sector-&gt;c_h;
  dest  = 192.0f;

// -ACB- FINISH OF THE HACKED TO FUCK BIT (END)

  if (dest &gt; start)
  {
    elev-&gt;direction = DIRECTION_UP;

    if (type-&gt;speed_up &gt;= 0)
      elev-&gt;speed = type-&gt;speed_up;
    else
      elev-&gt;speed = dest - start;
  }
  else if (start &gt; dest)
  {
    elev-&gt;direction = DIRECTION_DOWN;

    if (type-&gt;speed_down &gt;= 0)
      elev-&gt;speed = type-&gt;speed_down;
    else
      elev-&gt;speed = start - dest;
  }
  else
  {
    sector-&gt;ceil_move = NULL;
    sector-&gt;floor_move = NULL;

    Z_Free(elev);
    return NULL;
  }

  elev-&gt;destheight = dest;
  elev-&gt;startheight = start;
  elev-&gt;tag = sector-&gt;tag;
  elev-&gt;type = type;

  // -ACB- 10/01/2001 Trigger starting sfx
  S_StopLoopingSound((mobj_t *) &amp; sector-&gt;soundorg);
  if (type-&gt;sfxstart)
    S_StartSound((mobj_t *) &amp; sector-&gt;soundorg, type-&gt;sfxstart);

  P_AddActivePart((gen_move_t*)elev);
  return elev;
}
</t>
<t tx="T1985">@ignore
@language c

// Level Loading/Setup Code

&lt;&lt; p_setup #includes &gt;&gt;
&lt;&lt; p_setup declarations &gt;&gt;
@others
</t>
<t tx="T1986">#include "i_defs.h"
#include "p_setup.h"

#include "ddf_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "g_game.h"
#include "l_glbsp.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_swap.h"
#include "m_bbox.h"
#include "m_fixed.h"
#include "m_misc.h"
#include "m_random.h"
#include "p_local.h"
#include "p_bot.h"
#include "r2_defs.h"
#include "r_sky.h"
#include "s_sound.h"
#include "w_image.h"
#include "w_textur.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T1987">

// debugging aide:
#define FORCE_LOCATION  0
#define FORCE_LOC_X     12766
#define FORCE_LOC_Y     4600
#define FORCE_LOC_ANG   0


//
// MAP related Lookup tables.
// Store VERTEXES, LINEDEFS, SIDEDEFS, etc.
//
int numvertexes;
vertex_t *vertexes;

int num_gl_vertexes;
vertex_t *gl_vertexes;

int numsegs;
seg_t *segs;

int numsectors;
sector_t *sectors;

int numsubsectors;
subsector_t *subsectors;

int numextrafloors;
extrafloor_t *extrafloors;

int numnodes;
node_t *nodes;

int numlines;
line_t *lines;

int numsides;
side_t *sides;

int numwalltiles;
wall_tile_t *walltiles;

int numvertgaps;
vgap_t *vertgaps;

// BLOCKMAP
//
// Created from axis aligned bounding box
// of the map, a rectangular array of
// blocks of size ...
// Used to speed up collision detection
// by spatial subdivision in 2D.
//
// Blockmap size.
// 23-6-98 KM Promotion of short * to int *
int bmapwidth;
int bmapheight;  // size in mapblocks

unsigned short *bmap_lines = NULL; 
unsigned short ** bmap_pointers = NULL;

// offsets in blockmap are from here
int *blockmaplump = NULL;

// origin of block map
float_t bmaporgx;
float_t bmaporgy;

// for thing chains
mobj_t **blocklinks = NULL;

// for dynamic lights
mobj_t **blocklights = NULL;

// bbox used 
static float_t dummy_bbox[4];

unsigned long mapsector_CRC;
unsigned long mapline_CRC;
unsigned long mapthing_CRC;
int mapthing_NUM;

// REJECT
//
// For fast sight rejection.
// Speeds up enemy AI by skipping detailed
//  LineOf Sight calculation.
// Without special effect, this could be
//  used as a PVS lookup as well.
// Can be NULL.
//
const byte *rejectmatrix;

// Maintain single and multi player starting spots.
int max_deathmatch_starts = 10;
spawnpoint_t *deathmatchstarts;
spawnpoint_t *deathmatch_p;

spawnpoint_t *playerstarts;

static boolean_t hexen_level;

// When "GL Nodes v2.0" vertices are found, then our segs are "exact"
// (have fixed-point granularity) and we don't need to fudge the
// vertex positions.
// 
static boolean_t remove_slime_trails;

// a place to store sidedef numbers of the loaded linedefs.
// There is two values for every line: side0 and side1.
static int *temp_line_sides;
</t>
<t tx="T1988">@ LoadVertexes
@c

static void LoadVertexes(int lump)
{
  const void *data;
  int i;
  const mapvertex_t *ml;
  vertex_t *li;

  if (! W_VerifyLumpName(lump, "VERTEXES"))
    I_Error("Bad WAD: level %s missing VERTEXES.\n", currentmap-&gt;lump);

  // Determine number of lumps:
  //  total lump length / vertex record length.
  numvertexes = W_LumpLength(lump) / sizeof(mapvertex_t);

  if (numvertexes == 0)
    I_Error("Bad WAD: level %s contains 0 vertexes.\n", currentmap-&gt;lump);

  // Allocate zone memory for buffer.  Must be zeroed.
  vertexes = Z_ClearNew(vertex_t, numvertexes);

  // Load data into cache.
  data = W_CacheLumpNum(lump);

  ml = (const mapvertex_t *) data;
  li = vertexes;

  // Copy and convert vertex coordinates,
  // internal representation as fixed.
  for (i = 0; i &lt; numvertexes; i++, li++, ml++)
  {
    li-&gt;x = SHORT(ml-&gt;x);
    li-&gt;y = SHORT(ml-&gt;y);
  }

  // Free buffer memory.
  W_DoneWithLump(data);
}
</t>
<t tx="T1989">@ LoadGLVertexes
@c

static void LoadGLVertexes(int lump)
{
  const byte *data;
  int i;
  const mapvertex_t *ml;
  vertex_t *vert;

  if (!W_VerifyLumpName(lump, "GL_VERT"))
    I_Error("Bad WAD: level %s missing GL_VERT.\n", currentmap-&gt;lump);

  // Load data into cache.
  data = (byte *) W_CacheLumpNum(lump);
  
  // Handle v2.0 of "GL Node" specs (fixed point vertices)
 
  if (W_LumpLength(lump) &gt;= 4 &amp;&amp;
      data[0] == 'g' &amp;&amp; data[1] == 'N' &amp;&amp;
      data[2] == 'd' &amp;&amp; data[3] == '2')
  {
    const map_gl2vertex_t *ml2;

    num_gl_vertexes = (W_LumpLength(lump) - 4) / sizeof(map_gl2vertex_t);
    gl_vertexes = Z_ClearNew(vertex_t, num_gl_vertexes);

    ml2 = (const map_gl2vertex_t *) (data + 4);
    vert = gl_vertexes;

    // Copy and convert vertex coordinates,
    for (i = 0; i &lt; num_gl_vertexes; i++, vert++, ml2++)
    {
      vert-&gt;x = M_FixedToFloat((fixed_t) LONG(ml2-&gt;x));
      vert-&gt;y = M_FixedToFloat((fixed_t) LONG(ml2-&gt;y));
    }

    W_DoneWithLump(data);

    // these vertices are good -- don't mess with 'em...
    remove_slime_trails = false;
    return;
  }

  // Determine number of vertices:
  //  total lump length / vertex record length.
  num_gl_vertexes = W_LumpLength(lump) / sizeof(mapvertex_t);

  gl_vertexes = Z_ClearNew(vertex_t, num_gl_vertexes);

  ml = (const mapvertex_t *) data;
  vert = gl_vertexes;

  // Copy and convert vertex coordinates,
  // Internal representation is float.
  for (i = 0; i &lt; num_gl_vertexes; i++, vert++, ml++)
  {
    vert-&gt;x = SHORT(ml-&gt;x);
    vert-&gt;y = SHORT(ml-&gt;y);
  }

  // Free buffer memory.
  W_DoneWithLump(data);
}
</t>
<t tx="T1990">@ LoadGLSegs
@c

static void LoadGLSegs(int lump)
{
  const void *data;
  int i;
  const map_glseg_t *ml;
  seg_t *seg;
  int linedef;
  int side;
  int partner;

  if (! W_VerifyLumpName(lump, "GL_SEGS"))
    I_Error("Bad WAD: level %s missing GL_SEGS.\n", currentmap-&gt;lump);

  numsegs = W_LumpLength(lump) / sizeof(map_glseg_t);

  if (numsegs == 0)
    I_Error("Bad WAD: level %s contains 0 gl-segs.\n", currentmap-&gt;lump);

  segs = Z_ClearNew(seg_t, numsegs);
  data = W_CacheLumpNum(lump);

  ml = (const map_glseg_t *) data;
  seg = segs;
  
  for (i = 0; i &lt; numsegs; i++, seg++, ml++)
  {
    int v1num = USHORT(ml-&gt;v1);
    int v2num = USHORT(ml-&gt;v2);

    if (v1num &amp; SF_GL_VERTEX)
      seg-&gt;v1 = &amp;gl_vertexes[v1num &amp; ~SF_GL_VERTEX];
    else
      seg-&gt;v1 = &amp;vertexes[v1num];

    if (v2num &amp; SF_GL_VERTEX)
      seg-&gt;v2 = &amp;gl_vertexes[v2num &amp; ~SF_GL_VERTEX];
    else
      seg-&gt;v2 = &amp;vertexes[v2num];

    seg-&gt;angle  = R_PointToAngle(seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y,
        seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y);
    
    seg-&gt;length = R_PointToDist(seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y,
        seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y);

    linedef = USHORT(ml-&gt;linedef);
    side = USHORT(ml-&gt;side);

    seg-&gt;frontsector = seg-&gt;backsector = NULL;

    if (linedef == 0xFFFF)
      seg-&gt;miniseg = 1;
    else
    {
      float_t sx, sy;

      seg-&gt;miniseg = 0;
      seg-&gt;linedef = &amp;lines[linedef];

      sx = side ? seg-&gt;linedef-&gt;v2-&gt;x : seg-&gt;linedef-&gt;v1-&gt;x;
      sy = side ? seg-&gt;linedef-&gt;v2-&gt;y : seg-&gt;linedef-&gt;v1-&gt;y;

      seg-&gt;offset = R_PointToDist(sx, sy, seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y);

      seg-&gt;sidedef = seg-&gt;linedef-&gt;side[side];
      seg-&gt;frontsector = seg-&gt;sidedef-&gt;sector;

      if (seg-&gt;linedef-&gt;flags &amp; ML_TwoSided)
        seg-&gt;backsector = seg-&gt;linedef-&gt;side[side^1]-&gt;sector;
    }

    partner = USHORT(ml-&gt;partner);

    if (partner == 0xFFFF)
      seg-&gt;partner = NULL;
    else
      seg-&gt;partner = &amp;segs[partner];

    // The following fields are filled out elsewhere:
    //     sub_next, front_sub, back_sub, frontsector, backsector.

    seg-&gt;sub_next = (void *) -3;
    seg-&gt;front_sub = seg-&gt;back_sub = (void *) -3;
  }

  W_DoneWithLump(data);
}
</t>
<t tx="T1991">@ LoadSubsectors
@c

static void LoadSubsectors(int lump, const char *name)
{
  int i, j;
  const void *data;
  const mapsubsector_t *ms;
  subsector_t *ss;

  if (! W_VerifyLumpName(lump, name))
    I_Error("Bad WAD: level %s missing %s.\n", currentmap-&gt;lump, name);

  numsubsectors = W_LumpLength(lump) / sizeof(mapsubsector_t);

  if (numsubsectors == 0)
    I_Error("Bad WAD: level %s contains 0 ssectors.\n", currentmap-&gt;lump);

  subsectors = Z_ClearNew(subsector_t, numsubsectors);

  data = W_CacheLumpNum(lump);
  ms = (const mapsubsector_t *) data;
  ss = subsectors;

  for (i = 0; i &lt; numsubsectors; i++, ss++, ms++)
  {
    int countsegs = USHORT(ms-&gt;numsegs);
    int firstseg = USHORT(ms-&gt;firstseg);

    // -AJA- 1999/09/23: New linked list for the segs of a subsector
    //       (part of true bsp rendering).
    seg_t **prevptr = &amp;ss-&gt;segs;

    if (countsegs == 0 || firstseg == 0xFFFF || firstseg+countsegs &gt; numsegs)
      I_Error("Bad WAD: level %s has invalid SSECTORS.\n", currentmap-&gt;lump);
     
    ss-&gt;sector = NULL;
    ss-&gt;thinglist = NULL;

    // this is updated when the nodes are loaded
    ss-&gt;bbox = dummy_bbox;

    for (j = 0; j &lt; countsegs; j++)
    {
      seg_t *cur = &amp;segs[firstseg + j];

      *prevptr = cur;
       prevptr = &amp;cur-&gt;sub_next;

      cur-&gt;front_sub = ss;
      cur-&gt;back_sub = NULL;

      if (!ss-&gt;sector &amp;&amp; !cur-&gt;miniseg)
        ss-&gt;sector = cur-&gt;sidedef-&gt;sector;
    }

    if (ss-&gt;sector == NULL)
      I_Error("Bad WAD: level %s has crazy SSECTORS.\n", currentmap-&gt;lump);

    *prevptr = NULL;

    // link subsector into parent sector's list.
    // order is not important, so add it to the head of the list.
    
    ss-&gt;sec_next = ss-&gt;sector-&gt;subsectors;
    ss-&gt;sector-&gt;subsectors = ss;
  }

  W_DoneWithLump(data);
}
</t>
<t tx="T1992">@ GroupSectorTags

Called during P_LoadSectors to set the tag_next &amp; tag_prev fields of
each sector_t, which keep all sectors with the same tag in a linked
list for faster handling.

-AJA- 1999/07/29: written.
@c

static void GroupSectorTags(sector_t * dest, sector_t * seclist, int numsecs)
{
  // NOTE: `numsecs' does not include the current sector.

  dest-&gt;tag_next = dest-&gt;tag_prev = NULL;

  for (; numsecs &gt; 0; numsecs--)
  {
    sector_t *src = &amp;seclist[numsecs - 1];

    if (src-&gt;tag == dest-&gt;tag)
    {
      src-&gt;tag_next = dest;
      dest-&gt;tag_prev = src;
      return;
    }
  }
}
</t>
<t tx="T1993">@ LoadSectors
@c

static void LoadSectors(int lump)
{
  const void *data;
  int i;
  const mapsector_t *ms;
  sector_t *ss;

  if (! W_VerifyLumpName(lump, "SECTORS"))
    I_Error("Bad WAD: level %s missing SECTORS.\n", currentmap-&gt;lump);

  numsectors = W_LumpLength(lump) / sizeof(mapsector_t);

  if (numsectors == 0)
    I_Error("Bad WAD: level %s contains 0 sectors.\n", currentmap-&gt;lump);
    
  sectors = Z_ClearNew(sector_t, numsectors);

  data = W_CacheLumpNum(lump);
  CRC32_ProcessBlock(&amp;mapsector_CRC, data, W_LumpLength(lump));
  
  ms = (const mapsector_t *) data;
  ss = sectors;
  for (i = 0; i &lt; numsectors; i++, ss++, ms++)
  {
    char buffer[10];

    ss-&gt;f_h = SHORT(ms-&gt;floorheight);
    ss-&gt;c_h = SHORT(ms-&gt;ceilingheight);

    ss-&gt;floor.translucency = VISIBLE;
    ss-&gt;floor.x_mat.x = 1;  ss-&gt;floor.x_mat.y = 0;
    ss-&gt;floor.y_mat.x = 0;  ss-&gt;floor.y_mat.y = 1;

    ss-&gt;ceil = ss-&gt;floor;

    Z_StrNCpy(buffer, ms-&gt;floorpic, 8);
    ss-&gt;floor.image = W_ImageFromFlat(buffer);

    Z_StrNCpy(buffer, ms-&gt;ceilingpic, 8);
    ss-&gt;ceil.image = W_ImageFromFlat(buffer);

    // convert negative tags to zero
    ss-&gt;tag = MAX(0, SHORT(ms-&gt;tag));

    ss-&gt;props.lightlevel = SHORT(ms-&gt;lightlevel);
    ss-&gt;props.special = (SHORT(ms-&gt;special) &lt;= 0) ? NULL :
      DDF_SectorLookupNum(SHORT(ms-&gt;special));

    ss-&gt;exfloor_max = 0;

    // -AJA- 1999/07/10: Updated for colmap.ddf.
    ss-&gt;props.colourmap = DDF_ColmapLookup("NORMAL");
    ss-&gt;props.gravity   = GRAVITY;
    ss-&gt;props.friction  = FRICTION;
    ss-&gt;props.viscosity = VISCOSITY;
    ss-&gt;props.drag      = DRAG;
    
    ss-&gt;p = &amp;ss-&gt;props;

    ss-&gt;sound_player = -1;

    // -AJA- 1999/07/29: Keep sectors with same tag in a list.
    GroupSectorTags(ss, sectors, i);
  }

  W_DoneWithLump(data);
}
</t>
<t tx="T1994">@ LoadNodes
@c

static void LoadNodes(int lump, char *name)
{
  const void *data;
  int i, j, k;
  const mapnode_t *mn;
  node_t *nd;
  seg_t *seg;

  if (! W_VerifyLumpName(lump, name))
    I_Error("Bad WAD: level %s missing %s.\n", currentmap-&gt;lump, name);

  // Note: zero numnodes is valid.
  numnodes = W_LumpLength(lump) / sizeof(mapnode_t);
  nodes = Z_ClearNew(node_t, numnodes);
  data = W_CacheLumpNum(lump);

  mn = (const mapnode_t *) data;
  nd = nodes;

  for (i = 0; i &lt; numnodes; i++, nd++, mn++)
  {
    nd-&gt;div.x = SHORT(mn-&gt;x);
    nd-&gt;div.y = SHORT(mn-&gt;y);
    nd-&gt;div.dx = SHORT(mn-&gt;dx);
    nd-&gt;div.dy = SHORT(mn-&gt;dy);

    nd-&gt;div_len = R_PointToDist(0, 0, nd-&gt;div.dx, nd-&gt;div.dy);

    for (j = 0; j &lt; 2; j++)
    {
      nd-&gt;children[j] = USHORT(mn-&gt;children[j]);

      for (k = 0; k &lt; 4; k++)
        nd-&gt;bbox[j][k] = (float_t) SHORT(mn-&gt;bbox[j][k]);
      
      // update bbox pointers in subsector
      if (nd-&gt;children[j] &amp; NF_SUBSECTOR)
      {
        subsector_t *ss = subsectors + (nd-&gt;children[j] &amp; ~NF_SUBSECTOR);

        ss-&gt;bbox = &amp;nd-&gt;bbox[j][0];
      }
    }
  }

  W_DoneWithLump(data);

  if (numnodes &gt; 0)
    root_node = numnodes - 1;
  else
  {
    root_node = NF_SUBSECTOR | 0;

    // compute bbox for the single subsector
    M_ClearBox(dummy_bbox);
    
    for (i=0, seg=segs; i &lt; numsegs; i++, seg++)
    {
      M_AddToBox(dummy_bbox, seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y);
      M_AddToBox(dummy_bbox, seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y);
    }
  }
}
</t>
<t tx="T1995">@ SpawnMapThing
@c

static void SpawnMapThing(const mobjinfo_t *info,
    float_t x, float_t y, float_t z, angle_t angle, int options)
{
  int bit;
  mobj_t *mobj;
  spawnpoint_t point;

  point.x = x;
  point.y = y;
  point.z = z;
  point.angle = angle;
  point.slope = 0;
  point.info = info;
  point.flags = 0;

  // -KM- 1999/01/31 Use playernum property.
  // count deathmatch start positions
  if (info-&gt;playernum &lt; 0)
  {
    if (deathmatch_p == &amp;deathmatchstarts[max_deathmatch_starts])
    {
      int length = deathmatch_p - deathmatchstarts;

      Z_Resize(deathmatchstarts, spawnpoint_t, ++max_deathmatch_starts);

      deathmatch_p = deathmatchstarts + length;
    }
    *deathmatch_p = point;
    deathmatch_p++;
    return;
  }

  // check for players specially -jc-
  if (info-&gt;playernum &gt; 0)
  {
    // save spots for respawning in network games
    playerstarts[info-&gt;playernum - 1] = point;

    if (!deathmatch)
      P_SpawnPlayer(playerlookup[info-&gt;playernum - 1], &amp;point);

    return;
  }

  // check for apropriate skill level
  // -ES- 1999/04/13 Implemented Kester's Bugfix.
  // -AJA- 1999/10/21: Reworked again.
  if (!netgame &amp;&amp; !deathmatch &amp;&amp; (options &amp; MTF_NOT_SINGLE))
    return;

  // -AJA- 1999/09/22: Boom compatibility flags.
  if (netgame &amp;&amp; !deathmatch &amp;&amp; (options &amp; MTF_NOT_COOP))
    return;

  if (deathmatch &amp;&amp; (options &amp; MTF_NOT_DM))
    return;

  if (gameskill == sk_baby)
    bit = 1;
  else if (gameskill == sk_nightmare)
    bit = 4;
  else
    bit = 1 &lt;&lt; (gameskill - 1);

  if ((options &amp; bit) == 0)
    return;

  // don't spawn keycards and players in deathmatch
  if (deathmatch &amp;&amp; info-&gt;flags &amp; MF_NOTDMATCH)
    return;

  // don't spawn any monsters if -nomonsters
  if (level_flags.nomonsters &amp;&amp; (info-&gt;extendedflags &amp; EF_MONSTER))
    return;

  // -AJA- 1999/10/07: don't spawn extra things if -noextra.
  if (!level_flags.have_extra &amp;&amp; (info-&gt;extendedflags &amp; EF_EXTRA))
    return;

  // spawn it now !
  // Use MobjCreateObject -ACB- 1998/08/06
  mobj = P_MobjCreateObject(x, y, z, info);

  mobj-&gt;angle = angle;
  mobj-&gt;spawnpoint = point;

  if (mobj-&gt;state &amp;&amp; mobj-&gt;state-&gt;tics &gt; 0)
    mobj-&gt;tics = 1 + (P_Random() % mobj-&gt;state-&gt;tics);

  if (options &amp; MTF_AMBUSH)
  {
    mobj-&gt;flags |= MF_AMBUSH;
    mobj-&gt;spawnpoint.flags |= MF_AMBUSH;
  }

  // -AJA- 2000/09/22: MBF compatibility flag
  if (options &amp; MTF_FRIEND)
    mobj-&gt;side = 0x7FFFFFFF;
}
</t>
<t tx="T1996">@ LoadThings
@c

static void LoadThings(int lump)
{
  float_t x, y, z;
  angle_t angle;
  int options, typenum;
  int i;

  const void *data;
  const mapthing_t *mt;
  const mobjinfo_t *objtype;
  int numthings;

  if (!W_VerifyLumpName(lump, "THINGS"))
    I_Error("Bad WAD: level %s missing THINGS.\n", currentmap-&gt;lump);

  numthings = W_LumpLength(lump) / sizeof(mapthing_t);

  if (numthings == 0)
    I_Error("Bad WAD: level %s contains 0 things.\n", currentmap-&gt;lump);

  data = W_CacheLumpNum(lump);
  CRC32_ProcessBlock(&amp;mapthing_CRC, data, W_LumpLength(lump));
  mapthing_NUM = numthings;

  mt = (const mapthing_t *) data;
  for (i = 0; i &lt; numthings; i++, mt++)
  {
    x = (float_t) SHORT(mt-&gt;x);
    y = (float_t) SHORT(mt-&gt;y);
    angle = FLOAT_2_ANG((float_t) SHORT(mt-&gt;angle));
    typenum = USHORT(mt-&gt;type);
    options = USHORT(mt-&gt;options);

#if (FORCE_LOCATION)
    if (typenum == 1)
    {
      x = FORCE_LOC_X;
      y = FORCE_LOC_Y;
      angle = FORCE_LOC_ANG;
    }
#endif

    objtype = DDF_MobjLookupNum(typenum);

    // MOBJTYPE not found, don't crash out: JDS Compliance.
    // -ACB- 1998/07/21
    if (objtype == NULL)
    {
      if (!no_warnings)
        I_Warning("Unknown thing type %i at (%1.0f, %1.0f)\n", typenum, x, y);
      continue;
    }

    z = (objtype-&gt;flags &amp; MF_SPAWNCEILING) ? ONCEILINGZ : ONFLOORZ;

    SpawnMapThing(objtype, x, y, z, angle, options);
  }

  W_DoneWithLump(data);
}
</t>
<t tx="T1997">@ LoadHexenThings

-AJA- 2001/08/04: wrote this, based on the Hexen specs.
@c

static void LoadHexenThings(int lump)
{
  float_t x, y, z;
  angle_t angle;
  int options, typenum;
  int i;

  const void *data;
  const maphexenthing_t *mt;
  const mobjinfo_t *objtype;
  int numthings;

  if (!W_VerifyLumpName(lump, "THINGS"))
    I_Error("Bad WAD: level %s missing THINGS.\n", currentmap-&gt;lump);

  numthings = W_LumpLength(lump) / sizeof(maphexenthing_t);

  if (numthings == 0)
    I_Error("Bad WAD: level %s contains 0 things.\n", currentmap-&gt;lump);

  data = W_CacheLumpNum(lump);
  CRC32_ProcessBlock(&amp;mapthing_CRC, data, W_LumpLength(lump));
  mapthing_NUM = numthings;

  mt = (const maphexenthing_t *) data;
  for (i = 0; i &lt; numthings; i++, mt++)
  {
    x = (float_t) SHORT(mt-&gt;x);
    y = (float_t) SHORT(mt-&gt;y);
    z = (float_t) SHORT(mt-&gt;z);
    angle = FLOAT_2_ANG((float_t) SHORT(mt-&gt;angle));
    typenum = USHORT(mt-&gt;type);
    options = USHORT(mt-&gt;options) &amp; 0x000F;

    objtype = DDF_MobjLookupNum(typenum);

    // MOBJTYPE not found, don't crash out: JDS Compliance.
    // -ACB- 1998/07/21
    if (objtype == NULL)
    {
      if (!no_warnings)
        I_Warning("Unknown thing type %i at (%1.0f, %1.0f)\n", typenum, x, y);
      continue;
    }

    z += R_PointInSubsector(x, y)-&gt;sector-&gt;f_h;

    SpawnMapThing(objtype, x, y, z, angle, options);
  }

  W_DoneWithLump(data);
}
</t>
<t tx="T1998">
static INLINE void ComputeLinedefData(line_t *ld, int side0, int side1)
{
  vertex_t *v1 = ld-&gt;v1;
  vertex_t *v2 = ld-&gt;v2;

  ld-&gt;dx = v2-&gt;x - v1-&gt;x;
  ld-&gt;dy = v2-&gt;y - v1-&gt;y;

  if (ld-&gt;dx == 0)
    ld-&gt;slopetype = ST_VERTICAL;
  else if (ld-&gt;dy == 0)
    ld-&gt;slopetype = ST_HORIZONTAL;
  else if (ld-&gt;dy / ld-&gt;dx &gt; 0)
    ld-&gt;slopetype = ST_POSITIVE;
  else
    ld-&gt;slopetype = ST_NEGATIVE;

  ld-&gt;length = R_PointToDist(0, 0, ld-&gt;dx, ld-&gt;dy);

  if (v1-&gt;x &lt; v2-&gt;x)
  {
    ld-&gt;bbox[BOXLEFT] = v1-&gt;x;
    ld-&gt;bbox[BOXRIGHT] = v2-&gt;x;
  }
  else
  {
    ld-&gt;bbox[BOXLEFT] = v2-&gt;x;
    ld-&gt;bbox[BOXRIGHT] = v1-&gt;x;
  }

  if (v1-&gt;y &lt; v2-&gt;y)
  {
    ld-&gt;bbox[BOXBOTTOM] = v1-&gt;y;
    ld-&gt;bbox[BOXTOP] = v2-&gt;y;
  }
  else
  {
    ld-&gt;bbox[BOXBOTTOM] = v2-&gt;y;
    ld-&gt;bbox[BOXTOP] = v1-&gt;y;
  }

  if (side0 == 0xFFFF) side0 = -1;
  if (side1 == 0xFFFF) side1 = -1;

  // handle missing RIGHT sidedef (idea taken from MBF)
  if (side0 == -1)
  {
    I_Warning("Bad WAD: level %s linedef #%d is missing RIGHT side\n",
        currentmap-&gt;lump, ld - lines);
    side0 = 0;
  }

  if ((ld-&gt;flags &amp; ML_TwoSided) &amp;&amp; ((side0 == -1) || (side1 == -1)))
  {
    I_Warning("Bad WAD: level %s has linedef #%d marked TWOSIDED, "
        "but it has only one side.\n", currentmap-&gt;lump, ld - lines);

    ld-&gt;flags &amp;= ~ML_TwoSided;
  }
  
  temp_line_sides[(ld-lines)*2 + 0] = side0;
  temp_line_sides[(ld-lines)*2 + 1] = side1;

  numsides += (side1 == -1) ? 1 : 2;
}
</t>
<t tx="T1999">@ LoadLineDefs

-AJA- New handling for sidedefs. Since sidedefs can be "packed" in
a wad (i.e. shared by several linedefs) we need to unpack
them. This is to prevent potential problems with scrollers,
the CHANGE_TEX command in RTS, etc, and also to implement
"wall tiles" properly.
@c

static void LoadLineDefs(int lump)
{
  const void *data;
  const maplinedef_t *mld;
  line_t *ld;
  int side0, side1;
  int i;

  if (! W_VerifyLumpName(lump, "LINEDEFS"))
    I_Error("Bad WAD: level %s missing LINEDEFS.\n", currentmap-&gt;lump);

  numlines = W_LumpLength(lump) / sizeof(maplinedef_t);

  if (numlines == 0)
    I_Error("Bad WAD: level %s contains 0 linedefs.\n", currentmap-&gt;lump);
    
  lines = Z_ClearNew(line_t, numlines);
  temp_line_sides = Z_ClearNew(int, numlines * 2);

  data = W_CacheLumpNum(lump);
  CRC32_ProcessBlock(&amp;mapline_CRC, data, W_LumpLength(lump));

  mld = (const maplinedef_t *) data;
  ld = lines;
  for (i = 0; i &lt; numlines; i++, mld++, ld++)
  {
    ld-&gt;flags = USHORT(mld-&gt;flags);
    ld-&gt;tag = MAX(0, SHORT(mld-&gt;tag));
    ld-&gt;v1 = &amp;vertexes[USHORT(mld-&gt;v1)];
    ld-&gt;v2 = &amp;vertexes[USHORT(mld-&gt;v2)];

    ld-&gt;special = (SHORT(mld-&gt;special) &lt;= 0) ? NULL :
        DDF_LineLookupNum(SHORT(mld-&gt;special));
    
    side0 = USHORT(mld-&gt;sidenum[0]);
    side1 = USHORT(mld-&gt;sidenum[1]);

    ComputeLinedefData(ld, side0, side1);

    // check for possible extrafloors, updating the exfloor_max count
    // for the sectors in question.

    if (ld-&gt;tag &amp;&amp; ld-&gt;special &amp;&amp; ld-&gt;special-&gt;ef.type)
    {
      int j;
      for (j=0; j &lt; numsectors; j++)
      {
        if (sectors[j].tag != ld-&gt;tag)
          continue;

        sectors[j].exfloor_max++;
        numextrafloors++;
      }
    }
  }

  W_DoneWithLump(data);
}
</t>
<t tx="T2000">@ LoadHexenLineDefs

-AJA- 2001/08/04: wrote this, based on the Hexen specs.
@c

static void LoadHexenLineDefs(int lump)
{
  const void *data;
  const maphexenlinedef_t *mld;
  line_t *ld;
  int side0, side1;
  int i;

  if (! W_VerifyLumpName(lump, "LINEDEFS"))
    I_Error("Bad WAD: level %s missing LINEDEFS.\n", currentmap-&gt;lump);

  numlines = W_LumpLength(lump) / sizeof(maphexenlinedef_t);

  if (numlines == 0)
    I_Error("Bad WAD: level %s contains 0 linedefs.\n", currentmap-&gt;lump);
    
  lines = Z_ClearNew(line_t, numlines);
  temp_line_sides = Z_ClearNew(int, numlines * 2);

  data = W_CacheLumpNum(lump);
  CRC32_ProcessBlock(&amp;mapline_CRC, data, W_LumpLength(lump));

  mld = (const maphexenlinedef_t *) data;
  ld = lines;
  for (i = 0; i &lt; numlines; i++, mld++, ld++)
  {
    ld-&gt;flags = USHORT(mld-&gt;flags) &amp; 0x00FF;
    ld-&gt;tag = 0;
    ld-&gt;v1 = &amp;vertexes[USHORT(mld-&gt;v1)];
    ld-&gt;v2 = &amp;vertexes[USHORT(mld-&gt;v2)];

    // this ignores the activation bits -- oh well
    ld-&gt;special = (mld-&gt;special[0] == 0) ? NULL :
        DDF_LineLookupNum(1000 + mld-&gt;special[0]);

    side0 = USHORT(mld-&gt;sidenum[0]);
    side1 = USHORT(mld-&gt;sidenum[1]);

    ComputeLinedefData(ld, side0, side1);
  }

  W_DoneWithLump(data);
}
</t>
<t tx="T2001">
static void TransferMapSideDef(const mapsidedef_t *msd, side_t *sd,
    boolean_t two_sided)
{
  char buffer[10];

  int sec_num = SHORT(msd-&gt;sector);

  sd-&gt;top.translucency = VISIBLE;
  sd-&gt;top.offset.x = SHORT(msd-&gt;textureoffset);
  sd-&gt;top.offset.y = SHORT(msd-&gt;rowoffset);
  sd-&gt;top.x_mat.x = 1;  sd-&gt;top.x_mat.y = 0;
  sd-&gt;top.y_mat.x = 0;  sd-&gt;top.y_mat.y = 1;

  sd-&gt;middle = sd-&gt;top;
  sd-&gt;bottom = sd-&gt;top;

  if (sec_num &lt; 0)
  {
    I_Warning("Level %s has sidedef with bad sector ref (%d)\n",
        currentmap-&gt;lump, sec_num);
    sec_num = 0;
  }
  sd-&gt;sector = &amp;sectors[sec_num];

  Z_StrNCpy(buffer, msd-&gt;toptexture, 8);
  sd-&gt;top.image = W_ImageFromTexture(buffer);

  Z_StrNCpy(buffer, msd-&gt;midtexture, 8);
  sd-&gt;middle.image = W_ImageFromTexture(buffer);

  Z_StrNCpy(buffer, msd-&gt;bottomtexture, 8);
  sd-&gt;bottom.image = W_ImageFromTexture(buffer);

  if (sd-&gt;middle.image &amp;&amp; two_sided)
  {
    sd-&gt;midmask_offset = sd-&gt;middle.offset.y;
    sd-&gt;middle.offset.y = 0;
  }
}
</t>
<t tx="T2002">@ LoadSideDefs
@c

static void LoadSideDefs(int lump)
{
  int i;
  const void *data;
  const mapsidedef_t *msd;
  side_t *sd;

  int nummapsides;

  if (! W_VerifyLumpName(lump, "SIDEDEFS"))
    I_Error("Bad WAD: level %s missing SIDEDEFS.\n", currentmap-&gt;lump);

  nummapsides = W_LumpLength(lump) / sizeof(mapsidedef_t);

  if (nummapsides == 0)
    I_Error("Bad WAD: level %s contains 0 sidedefs.\n", currentmap-&gt;lump);
    
  sides = Z_ClearNew(side_t, numsides);

  data = W_CacheLumpNum(lump);
  msd = (const mapsidedef_t *) data;

  sd = sides;

  DEV_ASSERT2(temp_line_sides);

  for (i = 0; i &lt; numlines; i++)
  {
    line_t *ld = lines + i;
    
    int side0 = temp_line_sides[i*2 + 0];
    int side1 = temp_line_sides[i*2 + 1];

    DEV_ASSERT2(side0 != -1);

    if (side0 &gt;= nummapsides)
    {
      I_Warning("Bad WAD: level %s linedef #%d has bad RIGHT side.\n",
          currentmap-&gt;lump, i);
      side0 = nummapsides-1;
    }

    if (side1 != -1 &amp;&amp; side1 &gt;= nummapsides)
    {
      I_Warning("Bad WAD: level %s linedef #%d has bad LEFT side.\n",
          currentmap-&gt;lump, i);
      side1 = nummapsides-1;
    }

    ld-&gt;side[0] = sd;
    TransferMapSideDef(msd + side0, sd, (side1 != -1));
    ld-&gt;frontsector = sd-&gt;sector;
    sd++;

    if (side1 != -1)
    {
      ld-&gt;side[1] = sd;
      TransferMapSideDef(msd + side1, sd, true);
      ld-&gt;backsector = sd-&gt;sector;
      sd++;
    }

    DEV_ASSERT2(sd &lt;= sides + numsides);

  }

  DEV_ASSERT2(sd == sides + numsides);

  W_DoneWithLump(data);

}
</t>
<t tx="T2003">@ SetupExtrafloors

This is done after loading sectors (which sets exfloor_max to 0)
and after loading linedefs (which increases it for each new
extrafloor). So now we know the maximum number of extrafloors
that can ever be needed.

Note: this routine doesn't create any extrafloors (this is done
later when their linetypes are activated).
@c

static void SetupExtrafloors(void)
{
  int i, ef_index = 0;
  sector_t *ss;

  if (numextrafloors == 0)
    return;

  extrafloors = Z_ClearNew(extrafloor_t, numextrafloors);

  for (i=0, ss=sectors; i &lt; numsectors; i++, ss++)
  {
    ss-&gt;exfloor_first = extrafloors + ef_index;

    ef_index += ss-&gt;exfloor_max;

    DEV_ASSERT2(ef_index &lt;= numextrafloors);
  }

  DEV_ASSERT2(ef_index == numextrafloors);
}
</t>
<t tx="T2004">@ SetupWallTiles

Computes how many wall tiles we'll need. The tiles themselves are
created elsewhere.
@c

static void SetupWallTiles(void)
{
  int i, wt_index;
  int num_0, num_1;

  for (i=0; i &lt; numlines; i++)
  {
    line_t *ld = lines + i;
    
    if (! ld-&gt;backsector)
    {
      num_0 = 1;
      num_1 = 0;
    }
    else if (ld-&gt;frontsector == ld-&gt;backsector)
    {
      num_0 = 1;
      num_1 = 1;
    }
    else if (ld-&gt;frontsector-&gt;tag == ld-&gt;backsector-&gt;tag)
    {
      DEV_ASSERT2(ld-&gt;frontsector-&gt;exfloor_max ==
          ld-&gt;backsector-&gt;exfloor_max);

      num_0 = 3;
      num_1 = 3;
    }
    else
    {
      // FIXME: only count THICK sides for second part.
      
      num_0 = 3 + ld-&gt;backsector-&gt;exfloor_max;
      num_1 = 3 + ld-&gt;frontsector-&gt;exfloor_max;
    }

    ld-&gt;side[0]-&gt;tile_max = num_0;

    if (ld-&gt;side[1])
      ld-&gt;side[1]-&gt;tile_max = num_1;
    
    numwalltiles += num_0 + num_1;
  }

/// I_Printf("%dK used for wall tiles.\n", (numwalltiles *
///    sizeof(wall_tile_t) + 1023) / 1024);

  DEV_ASSERT2(numwalltiles &gt; 0);

  walltiles = Z_ClearNew(wall_tile_t, numwalltiles);
  
  for (i=0, wt_index=0; i &lt; numlines; i++)
  {
    line_t *ld = lines + i;

    ld-&gt;side[0]-&gt;tiles = walltiles + wt_index;
    wt_index += ld-&gt;side[0]-&gt;tile_max;

    if (ld-&gt;side[1])
    {
      ld-&gt;side[1]-&gt;tiles = walltiles + wt_index;
      wt_index += ld-&gt;side[1]-&gt;tile_max;
    }

    DEV_ASSERT2(wt_index &lt;= numwalltiles);
  }

  DEV_ASSERT2(wt_index == numwalltiles);
}
</t>
<t tx="T2005">@ SetupVertGaps

Computes how many vertical gaps we'll need.
@c

static void SetupVertGaps(void)
{
  int i;
  int line_gaps = 0;
  int sect_sight_gaps = 0;
  
  vgap_t *cur_gap;

  for (i=0; i &lt; numlines; i++)
  {
    line_t *ld = lines + i;
    
    ld-&gt;max_gaps = ld-&gt;backsector ? 1 : 0;
 
    // factor in extrafloors
    ld-&gt;max_gaps += ld-&gt;frontsector-&gt;exfloor_max;

    if (ld-&gt;backsector)
      ld-&gt;max_gaps += ld-&gt;backsector-&gt;exfloor_max;

    line_gaps += ld-&gt;max_gaps;
  }

  for (i=0; i &lt; numsectors; i++)
  {
    sector_t *sec = sectors + i;
    
    sec-&gt;max_gaps = sec-&gt;exfloor_max + 1;
 
    sect_sight_gaps += sec-&gt;max_gaps;
  }

  numvertgaps = line_gaps + sect_sight_gaps;

/// I_Printf("%dK used for vert gaps.\n", (numvertgaps *
///    sizeof(vgap_t) + 1023) / 1024);

  // zero is now impossible
  DEV_ASSERT2(numvertgaps &gt; 0);

  vertgaps = Z_ClearNew(vgap_t, numvertgaps);
  
  for (i=0, cur_gap=vertgaps; i &lt; numlines; i++)
  {
    line_t *ld = lines + i;

    if (ld-&gt;max_gaps == 0)
      continue;

    ld-&gt;gaps = cur_gap;
    cur_gap += ld-&gt;max_gaps;
  }

  DEV_ASSERT2(cur_gap == (vertgaps + line_gaps));

  for (i=0; i &lt; numsectors; i++)
  {
    sector_t *sec = sectors + i;

    if (sec-&gt;max_gaps == 0)
      continue;

    sec-&gt;sight_gaps = cur_gap;
    cur_gap += sec-&gt;max_gaps;
  }

  DEV_ASSERT2(cur_gap == (vertgaps + numvertgaps));
}
</t>
<t tx="T2006">@ LoadBlockMap

23-6-98 KM Brand Spanking New Blockmap code:

-AJA- 2000/07/31: Heavy reworking.
@c

static void LoadBlockMap(int lump)
{
  int i;
  int num_lines, num_ofs;

  const short *data;
  const short *dat_pos;

  data = W_CacheLumpNum(lump);
  num_lines = W_LumpLength(lump) / sizeof(short);

  if (num_lines &lt;= 4)
    I_Error("Bad WAD: level %s missing BLOCKMAP.  Build the nodes !\n", 
        currentmap-&gt;lump);

  bmaporgx = (float_t)SHORT(data[0]);
  bmaporgy = (float_t)SHORT(data[1]);
  bmapwidth  = SHORT(data[2]);
  bmapheight = SHORT(data[3]);

  // skip header
  dat_pos = data + 4;

  num_ofs = bmapwidth * bmapheight;
  num_lines -= (num_ofs + 4);

  bmap_pointers = Z_New(unsigned short *, num_ofs);
  bmap_lines = Z_New(unsigned short, num_lines);

  // Note: there is potential to skip the ever-present initial zero in
  // the linedef list (which means that linedef #0 always gets checked
  // for everything -- inefficient).  But I'm assuming that some wads
  // (or even editors / blockmap builders) may rely on this behaviour.
 
  for (i=0; i &lt; num_ofs; i++)
    bmap_pointers[i] = bmap_lines +
      ((int)USHORT(dat_pos[i]) - num_ofs - 4);

  // skip offsets
  dat_pos += num_ofs;

  for (i=0; i &lt; num_lines; i++)
    bmap_lines[i] = USHORT(dat_pos[i]);

  W_DoneWithLump(data);
}
</t>
<t tx="T2007">@ Variables for GenerateBlockMap
fixed array of dynamic array
@c

static unsigned short ** blk_cur_lines = NULL;
static int blk_total_lines;

#define BCUR_SIZE   0
#define BCUR_MAX    1
#define BCUR_FIRST  2

static void BlockAdd(int bnum, unsigned short line_num)
{
  unsigned short *cur = blk_cur_lines[bnum];

  DEV_ASSERT2(bnum &gt;= 0);
  DEV_ASSERT2(bnum &lt; (bmapwidth * bmapheight));

  if (! cur)
  {
    // create initial block

    blk_cur_lines[bnum] = cur = Z_New(unsigned short, BCUR_FIRST + 16);
    cur[BCUR_SIZE] = 0;
    cur[BCUR_MAX]  = 16;
  }

  if (cur[BCUR_SIZE] == cur[BCUR_MAX])
  {
    // need to grow this block
 
    cur = blk_cur_lines[bnum];
    cur[BCUR_MAX] += 16;
    Z_Resize(blk_cur_lines[bnum], unsigned short,
        BCUR_FIRST + cur[BCUR_MAX]);
    cur = blk_cur_lines[bnum];
  }

  DEV_ASSERT2(cur);
  DEV_ASSERT2(cur[BCUR_SIZE] &lt; cur[BCUR_MAX]);

  cur[BCUR_FIRST + cur[BCUR_SIZE]] = line_num;
  cur[BCUR_SIZE] += 1;

  blk_total_lines++;
}
</t>
<t tx="T2008">
static void BlockAddLine(int line_num)
{
  int i, j;
  int x0, y0;
  int x1, y1;

  line_t *ld = lines + line_num;

  int blocknum;

  int y_sign;
  int x_dist, y_dist;

  float_t slope;

  x0 = ld-&gt;v1-&gt;x - bmaporgx;
  y0 = ld-&gt;v1-&gt;y - bmaporgy;
  x1 = ld-&gt;v2-&gt;x - bmaporgx;
  y1 = ld-&gt;v2-&gt;y - bmaporgy;

  // swap endpoints if horizontally backward
  if (x1 &lt; x0)
  {
    int temp;

    temp = x0; x0 = x1; x1 = temp;
    temp = y0; y0 = y1; y1 = temp;
  }

  DEV_ASSERT2(0 &lt;= x0 &amp;&amp; (x0 / 128) &lt; bmapwidth);
  DEV_ASSERT2(0 &lt;= y0 &amp;&amp; (y0 / 128) &lt; bmapheight);
  DEV_ASSERT2(0 &lt;= x1 &amp;&amp; (x1 / 128) &lt; bmapwidth);
  DEV_ASSERT2(0 &lt;= y1 &amp;&amp; (y1 / 128) &lt; bmapheight);

  // check if this line spans multiple blocks.

  x_dist = ABS((x1 / 128) - (x0 / 128));
  y_dist = ABS((y1 / 128) - (y0 / 128));

  y_sign = (y1 &gt;= y0) ? 1 : -1;

  // handle the simple cases: same column or same row

  blocknum = (y0 / 128) * bmapwidth + (x0 / 128);

  if (y_dist == 0)
  {
    for (i=0; i &lt;= x_dist; i++, blocknum++)
      BlockAdd(blocknum, line_num);

    return;
  }

  if (x_dist == 0)
  {
    for (i=0; i &lt;= y_dist; i++, blocknum += y_sign * bmapwidth)
      BlockAdd(blocknum, line_num);

    return;
  }

  // -AJA- 2000/12/09: rewrote the general case

  DEV_ASSERT2(x1 &gt; x0);

  slope = (float_t)(y1 - y0) / (float_t)(x1 - x0);

  // handle each column of blocks in turn
  for (i=0; i &lt;= x_dist; i++)
  {
    // compute intersection of column with line
    int sx = (i==0)      ? x0 : (128 * (x0 / 128 + i));
    int ex = (i==x_dist) ? x1 : (128 * (x0 / 128 + i) + 127);

    int sy = y0 + (int)(slope * (sx - x0));
    int ey = y0 + (int)(slope * (ex - x0));

    DEV_ASSERT2(sx &lt;= ex);

    y_dist = ABS((ey / 128) - (sy / 128));

    for (j=0; j &lt;= y_dist; j++)
    {
      blocknum = (sy / 128 + j * y_sign) * bmapwidth + (sx / 128);

      BlockAdd(blocknum, line_num);
    }
  }
}
</t>
<t tx="T2009">
void GenerateBlockMap(int min_x, int min_y, int max_x, int max_y)
{
  int i;
  int bnum, btotal;
  unsigned short *b_pos;

  bmaporgx = min_x - 8;
  bmaporgy = min_y - 8;
  bmapwidth  = (max_x - bmaporgx) / 128 + 1;
  bmapheight = (max_y - bmaporgy) / 128 + 1;

  btotal = bmapwidth * bmapheight;

  L_WriteDebug("GenerateBlockmap: MAP (%d,%d) -&gt; (%d,%d)\n",
      min_x, min_y, max_x, max_y);
  L_WriteDebug("GenerateBlockmap: BLOCKS %d x %d  TOTAL %d\n",
      bmapwidth, bmapheight, btotal);

  // setup blk_cur_lines array.  Initially all pointers are NULL, when
  // any lines get added then the dynamic array is created.

  blk_cur_lines = Z_ClearNew(unsigned short *, btotal);
  
  // initial # of line values ("0, -1" for each block)
  blk_total_lines = 2 * btotal;

  // process each linedef of the map
  for (i=0; i &lt; numlines; i++)
    BlockAddLine(i);

  L_WriteDebug("GenerateBlockmap: TOTAL DATA=%d\n", blk_total_lines);

  // convert dynamic arrays to single array and free memory

  bmap_pointers = Z_New(unsigned short *, btotal);
  bmap_lines = b_pos = Z_New(unsigned short, blk_total_lines);

  for (bnum=0; bnum &lt; btotal; bnum++)
  {
    DEV_ASSERT2(b_pos - bmap_lines &lt; blk_total_lines);

    bmap_pointers[bnum] = b_pos;

    *b_pos++ = 0;

    if (blk_cur_lines[bnum])
    {
      // transfer the line values
      for (i=blk_cur_lines[bnum][BCUR_SIZE] - 1; i &gt;= 0; i--)
        *b_pos++ = blk_cur_lines[bnum][BCUR_FIRST + i];
 
      Z_Free(blk_cur_lines[bnum]);
    }

    *b_pos++ = BMAP_END;
  }

  if (b_pos - bmap_lines != blk_total_lines)
    I_Error("GenerateBlockMap: miscounted !\n");

  Z_Free(blk_cur_lines);
  blk_cur_lines = NULL;
}
</t>
<t tx="T2010">
static void DoBlockMap(int lump)
{
  int i;
  int map_width, map_height;

  int min_x = vertexes[0].x, min_y = vertexes[0].y;
  int max_x = vertexes[0].x, max_y = vertexes[0].y;

  for (i=1; i &lt; numvertexes; i++)
  {
    vertex_t *v = vertexes + i;
    
    min_x = MIN(v-&gt;x, min_x);
    min_y = MIN(v-&gt;y, min_y);
    max_x = MAX(v-&gt;x, max_x);
    max_y = MAX(v-&gt;y, max_y);
  }

  map_width  = max_x - min_x;
  map_height = max_y - min_y;

  if (! W_VerifyLumpName(lump, "BLOCKMAP"))
    I_Error("Bad WAD: level %s missing BLOCKMAP.  Build the nodes !\n", 
        currentmap-&gt;lump);

  if (M_CheckParm("-blockmap") &gt; 0 ||
      W_LumpLength(lump) &gt; (128 * 1024) ||
      map_width &gt;= 16000 || map_height &gt;= 16000)
    GenerateBlockMap(min_x, min_y, max_x, max_y);
  else
    LoadBlockMap(lump);

  // clear out mobj chains
  blocklinks  = Z_ClearNew(mobj_t *, bmapwidth * bmapheight);

  if (use_dlights)
    blocklights = Z_ClearNew(mobj_t *, bmapwidth * bmapheight);
}
</t>
<t tx="T2011">@ all sectors' line tables
@c

static line_t **linebuffer;

//
// GroupLines
//
// Builds sector line lists and subsector sector numbers.
// Finds block bounding boxes for sectors.
//
void GroupLines(void)
{
  int i;
  int j;
  int total;
  line_t *li;
  sector_t *sector;
  seg_t *seg;
  float_t bbox[4];
  int block;
  line_t **line_p;

  // setup remaining seg information
  for (i=0, seg=segs; i &lt; numsegs; i++, seg++)
  {
    if (seg-&gt;partner)
      seg-&gt;back_sub = seg-&gt;partner-&gt;front_sub;
    
    if (!seg-&gt;frontsector)
      seg-&gt;frontsector = seg-&gt;front_sub-&gt;sector;

    if (!seg-&gt;backsector &amp;&amp; seg-&gt;back_sub)
      seg-&gt;backsector = seg-&gt;back_sub-&gt;sector;
  }
  
  // count number of lines in each sector
  li = lines;
  total = 0;
  for (i = 0; i &lt; numlines; i++, li++)
  {
    total++;
    li-&gt;frontsector-&gt;linecount++;

    if (li-&gt;backsector &amp;&amp; li-&gt;backsector != li-&gt;frontsector)
    {
      li-&gt;backsector-&gt;linecount++;
      total++;
    }
  }

  // build line tables for each sector 
  line_p = linebuffer = Z_New(line_t *, total);
  sector = sectors;
  for (i = 0; i &lt; numsectors; i++, sector++)
  {
    M_ClearBox(bbox);
    sector-&gt;lines = line_p;
    li = lines;
    for (j = 0; j &lt; numlines; j++, li++)
    {
      if (li-&gt;frontsector == sector || li-&gt;backsector == sector)
      {
        *line_p++ = li;
        M_AddToBox(bbox, li-&gt;v1-&gt;x, li-&gt;v1-&gt;y);
        M_AddToBox(bbox, li-&gt;v2-&gt;x, li-&gt;v2-&gt;y);
      }
    }
    if (line_p - sector-&gt;lines != sector-&gt;linecount)
      I_Error("GroupLines: miscounted");

    // set the degenmobj_t to the middle of the bounding box
    sector-&gt;soundorg.x = (bbox[BOXRIGHT] + bbox[BOXLEFT]) / 2;
    sector-&gt;soundorg.y = (bbox[BOXTOP] + bbox[BOXBOTTOM]) / 2;
    sector-&gt;soundorg.z = (sector-&gt;f_h + sector-&gt;c_h) / 2;

    // adjust bounding box to map blocks
    block = (bbox[BOXTOP] - bmaporgy + MAXRADIUS) / MAPBLOCKUNITS;
    block = block &gt;= bmapheight ? bmapheight - 1 : block;
    sector-&gt;blockbox[BOXTOP] = block;

    block = (bbox[BOXBOTTOM] - bmaporgy - MAXRADIUS) / MAPBLOCKUNITS;
    block = block &lt; 0 ? 0 : block;
    sector-&gt;blockbox[BOXBOTTOM] = block;

    block = (bbox[BOXRIGHT] - bmaporgx + MAXRADIUS) / MAPBLOCKUNITS;
    block = block &gt;= bmapwidth ? bmapwidth - 1 : block;
    sector-&gt;blockbox[BOXRIGHT] = block;

    block = (bbox[BOXLEFT] - bmaporgx - MAXRADIUS) / MAPBLOCKUNITS;
    block = block &lt; 0 ? 0 : block;
    sector-&gt;blockbox[BOXLEFT] = block;
  }
}
</t>
<t tx="T2012">@ LoadReject
@c

static void LoadReject(int lump)
{
  int req_length;
  
  if (! W_VerifyLumpName(lump, "REJECT"))
    I_Error("Bad WAD: level %s missing REJECT.  Build the nodes !\n", 
        currentmap-&gt;lump);

  if (W_LumpLength(lump) == 0)
    I_Error("Bad WAD: level %s missing REJECT.  Build the nodes !\n", 
        currentmap-&gt;lump);

  req_length = (numsectors * numsectors + 7) / 8;

  if (W_LumpLength(lump) &lt; req_length)
  {
    M_WarnError("Level %s has invalid REJECT info !\n", currentmap-&gt;lump);
    rejectmatrix = NULL;
    return;
  }

  rejectmatrix = W_CacheLumpNum(lump);
}
</t>
<t tx="T2013">@ P_RemoveMobjs
@c

void P_RemoveMobjs(void)
{
  mobj_t *mo;

  for (mo = mobjlisthead; mo; mo = mo-&gt;next)
    P_RemoveMobj(mo);

  P_RemoveQueuedMobjs();
  P_RemoveBots();
}
</t>
<t tx="T2014">@ P_RemoveItemsInQue
@c

void P_RemoveItemsInQue(void)
{
  while (itemquehead)
  {
    iteminque_t *tmp = itemquehead;
    itemquehead = itemquehead-&gt;next;
    Z_Free(tmp);
  }
}
</t>
<t tx="T2015">@ P_RemoveSectors
@c

void P_RemoveSectors(void)
{
  int i;

  for (i = 0; i &lt; numsectors; i++)
  {
    P_FreeSectorTouchNodes(sectors + i);

    // Might still be playing a sound.
    S_StopSound((mobj_t *)&amp;sectors[i].soundorg);
  }

  Z_Free(sectors);
}
</t>
<t tx="T2016">
static boolean_t level_active = false;

//
// P_ShutdownLevel
//
// Destroys everything on the level.
//
static void ShutdownLevel(void)
{
#ifdef DEVELOPERS
  if (!level_active)
    I_Error("ShutdownLevel: no level to shut down!");
#endif

  P_RemoveMobjs();
  P_RemoveItemsInQue();

  if (gl_vertexes)
  {
    Z_Free(gl_vertexes);
    gl_vertexes = NULL;
  }
  Z_Free(segs);
  Z_Free(nodes);
  Z_Free(vertexes);
  Z_Free(sides);
  Z_Free(lines);
  Z_Free(subsectors);

  if (extrafloors)
    Z_Free(extrafloors);

  if (vertgaps)
    Z_Free(vertgaps);

  P_RemoveSectors();

  Z_Free(linebuffer);
  Z_Free(blocklinks);
  if (blocklights)
  {
    Z_Free(blocklights);
    blocklights = NULL;
  }
  Z_Free(bmap_lines); bmap_lines = NULL;
  Z_Free(bmap_pointers); bmap_pointers = NULL;

  P_DestroyAllLights();
  P_RemoveAllActiveParts();
  P_DestroyAllSectorSFX();
  P_FreeShootSpots();

  if (rejectmatrix)
    W_DoneWithLump(rejectmatrix);

  R2_TileSkyClear();

  DDF_LineClearGeneralised();
  DDF_SectorClearGeneralised();
 
  level_active = false;
}
</t>
<t tx="T2017">@ P_SetupLevel

Sets up the current level using the skill passed and the
information in currentmap.

-ACB- 1998/08/09 Use currentmap to ref lump and par time
-KM- 1998/11/25 Added autotag.
@c

void P_SetupLevel(skill_t skill, int autotag)
{
  int j;
  int lumpnum;
  int gl_lumpnum;
  player_t *p;
  char gl_lumpname[16];

  if (level_active)
    ShutdownLevel();

  // -AJA- this don't belong here, but startup is too screwed ATM
  // (no way should level load precede graphics init).
  R2_TileSkyClear();
  
  totalkills = totalitems = totalsecret = wminfo.maxfrags = 0;

  wminfo.partime = currentmap-&gt;partime;

  for (p = players; p; p = p-&gt;next)
  {
    p-&gt;killcount = p-&gt;secretcount = p-&gt;itemcount = 0;
    p-&gt;mo = NULL;
  }

  // Initial height of PointOfView
  // will be set by player think.
  consoleplayer-&gt;viewz = M_PI;

  lumpnum = W_GetNumForName(currentmap-&gt;lump);

  leveltime = 0;

  // -AJA- 1999/12/20: Support for "GL-Friendly Nodes".
  sprintf(gl_lumpname, "GL_%s", currentmap-&gt;lump);
  gl_lumpnum = W_CheckNumForName(gl_lumpname);

  // ignore GL info if the level marker occurs _before_ the normal
  // level marker.
  if (gl_lumpnum &gt;= 0 &amp;&amp; gl_lumpnum &lt; lumpnum)
    gl_lumpnum = -1;
 
  // -- GLBSP PLUGIN CODE --

  if (gl_lumpnum &lt; 0)
  {
    if (GB_BuildNodes(lumpnum))
      gl_lumpnum = W_CheckNumForName(gl_lumpname);

    if (gl_lumpnum &lt; 0)
      I_Error("Failed to build GL-Nodes !\n");
  }

  // clear CRC values
  CRC32_Init(&amp;mapsector_CRC);
  CRC32_Init(&amp;mapline_CRC);
  CRC32_Init(&amp;mapthing_CRC);

#ifdef DEVELOPERS

#define SHOWLUMPNAME(outstr, ln) \
  L_WriteDebug(outstr, W_GetLumpName(ln));

  SHOWLUMPNAME("MAP            : %s\n", lumpnum);
  SHOWLUMPNAME("MAP VERTEXES   : %s\n", lumpnum + ML_VERTEXES);
  SHOWLUMPNAME("MAP SECTORS    : %s\n", lumpnum + ML_SECTORS);
  SHOWLUMPNAME("MAP SIDEDEFS   : %s\n", lumpnum + ML_SIDEDEFS);
  SHOWLUMPNAME("MAP LINEDEFS   : %s\n", lumpnum + ML_LINEDEFS);
  SHOWLUMPNAME("MAP BLOCKMAP   : %s\n", lumpnum + ML_BLOCKMAP);

  if (gl_lumpnum &gt;= 0)
  {
    SHOWLUMPNAME("MAP GL         : %s\n", gl_lumpnum);
    SHOWLUMPNAME("MAP GL VERTEXES: %s\n", gl_lumpnum + ML_GL_VERT);
    SHOWLUMPNAME("MAP GL SEGS    : %s\n", gl_lumpnum + ML_GL_SEGS);
    SHOWLUMPNAME("MAP GL SSECTORS: %s\n", gl_lumpnum + ML_GL_SSECT);
    SHOWLUMPNAME("MAP GL NODES   : %s\n", gl_lumpnum + ML_GL_NODES);
  }
  else
  {
    SHOWLUMPNAME("MAP SEGS       : %s\n", lumpnum + ML_SEGS);
    SHOWLUMPNAME("MAP SSECTORS   : %s\n", lumpnum + ML_SSECTORS);
    SHOWLUMPNAME("MAP NODES      : %s\n", lumpnum + ML_NODES);
  }

  SHOWLUMPNAME("MAP REJECT     : %s\n", lumpnum + ML_REJECT);

#undef SHOWLUMPNAME
#endif

  // -ACB- 1998/08/27 NULL the head pointers for the linked lists....
  itemquehead = NULL;
  mobjlisthead = NULL;

  remove_slime_trails = true;

  // check if the level is for Hexen
  hexen_level = false;

  if (lumpnum + ML_BEHAVIOR &lt; numlumps &amp;&amp;
      W_VerifyLumpName(lumpnum + ML_BEHAVIOR, "BEHAVIOR"))
  {
    L_WriteDebug("Detected Hexen level.\n");
    hexen_level = true;
  }

  // note: most of this ordering is important
  // 23-6-98 KM, eg, Sectors must be loaded before sidedefs,
  // Vertexes must be loaded before LineDefs,
  // LineDefs + Vertexes must be loaded before BlockMap,
  // Sectors must be loaded before Segs

  numsides = 0;
  numextrafloors = 0;
  numwalltiles = 0;
  numvertgaps = 0;

  LoadVertexes(lumpnum + ML_VERTEXES);
  LoadSectors(lumpnum + ML_SECTORS);
  if (hexen_level)
    LoadHexenLineDefs(lumpnum + ML_LINEDEFS);
  else
    LoadLineDefs(lumpnum + ML_LINEDEFS);
  LoadSideDefs(lumpnum + ML_SIDEDEFS);
  
  SetupExtrafloors();
  SetupWallTiles();
  SetupVertGaps();

  Z_Free(temp_line_sides);
  temp_line_sides = NULL;

  DoBlockMap(lumpnum + ML_BLOCKMAP);

  DEV_ASSERT2(gl_lumpnum &gt;= 0);

  LoadGLVertexes(gl_lumpnum + ML_GL_VERT);
  LoadGLSegs(gl_lumpnum + ML_GL_SEGS);
  LoadSubsectors(gl_lumpnum + ML_GL_SSECT, "GL_SSECT");
  LoadNodes(gl_lumpnum + ML_GL_NODES, "GL_NODES");
  LoadReject(lumpnum + ML_REJECT);

  GroupLines();

  {
    int j;
    for (j=0; j &lt; numsectors; j++)
      P_RecomputeTilesInSector(sectors + j);
  }

#ifdef USE_GL
  R_ComputeSkyHeights();
#endif
  
  // compute sector and line gaps
  for (j=0; j &lt; numsectors; j++)
    P_RecomputeGapsAroundSector(sectors + j);

  bodyqueslot = 0;
  deathmatch_p = deathmatchstarts;

  // -AJA- 1999/10/21: Clear out playerstarts.
  Z_Clear(playerstarts, spawnpoint_t, MAXPLAYERS);

  if (hexen_level)
    LoadHexenThings(lumpnum + ML_THINGS);
  else
    LoadThings(lumpnum + ML_THINGS);

  // OK, finish off the computed CRCs
  CRC32_Done(&amp;mapsector_CRC);
  CRC32_Done(&amp;mapline_CRC);
  CRC32_Done(&amp;mapthing_CRC);

#ifdef DEVELOPERS
  L_WriteDebug("MAP CRCS: S=%08lx L=%08lx T=%08lx\n",
      mapsector_CRC, mapline_CRC, mapthing_CRC);
#endif

  // if deathmatch, randomly spawn the active players
  if (deathmatch)
  {
    for (p = players; p; p = p-&gt;next)
    {
      p-&gt;mo = NULL;
      G_DeathMatchSpawnPlayer(p);
      if (p-&gt;level_init)
        p-&gt;level_init(p, p-&gt;data);
    }
  }

  // -AJA- 1999/10/21: if not netgame/deathmatch, then check for
  //       missing player start.  NOTE: temp fix, player handling
  //       desperately needs a massive overhaul.
  if (!(netgame || deathmatch) &amp;&amp; consoleplayer-&gt;mo == NULL)
    I_Error("Missing player start !\n");

  // set up world state
  P_SpawnSpecials(autotag);

  // preload graphics
  if (precache)
    R_PrecacheLevel();

  S_SoundLevelInit(); // Clear out the playing sounds
  S_ChangeMusic(currentmap-&gt;music, true); // start level music

  level_active = true;
}
</t>
<t tx="T2018">@ P_Init
@c

boolean_t P_Init(void)
{
  deathmatchstarts = Z_New(spawnpoint_t, max_deathmatch_starts);
  playerstarts = Z_New(spawnpoint_t, MAXPLAYERS);

  return true;
}
</t>
<t tx="T2019">@ignore
@language c

// Sight Code

//  -AJA- 2001/07/24: New sight code.
//
//  Works like this: First we do what the original DOOM source did,
//  traverse the BSP to find lines that intersecting the LOS ray.  We
//  keep the top/bottom slope optimisation too.
//
//  The difference is that we remember where abouts the intercepts
//  occur, and if the basic LOS check succeeds (e.g. no one-sided
//  lines blocking view) then we use the intercept list to check for
//  extrafloors that block the view.

&lt;&lt; p_sight #includes &gt;&gt;
&lt;&lt; p_sight declarations &gt;&gt;
@others
</t>
<t tx="T2020">#include "i_defs.h"

#include "dm_defs.h"
#include "m_bbox.h"
#include "p_local.h"
#include "r_state.h"
</t>
<t tx="T2021">

#define DEBUG_SIGHT  0


typedef struct sight_info_s
{
  // source position (dx/dy is vector to dest)
  divline_t src;
  float_t src_z;
  subsector_t *src_sub;

  // dest position
  vec2_t dest;
  float_t dest_z;
  subsector_t *dest_sub;

  // angle from src-&gt;dest, for fast seg check
  angle_t angle;

  // slopes from source to top/bottom of destination.  They will be
  // updated when one or two-sided lines are encountered.  If they
  // close up completely, then no other heights need to be checked.
  // 
  // NOTE: the values are not real slopes, the distance from src to
  //       dest is the implied denominator.
  // 
  float_t top_slope;
  float_t bottom_slope;

  // bounding box on LOS line (idea pinched from PrBOOM).
  float_t bbox[4];

  // true if one of the sectors contained extrafloors
  boolean_t exfloors;
}
sight_info_t;

static sight_info_t sight_I;


// intercepts found during first pass

typedef struct wall_intercept_s
{
  // fractional distance, 0.0 -&gt; 1.0
  float_t frac;

  // sector that faces the source from this intercept point
  sector_t *sector;
}
wall_intercept_t;
</t>
<t tx="T2022">@ intercept array
@c

static Z_Bunch(wall_intercept_t) wall_icpts;

// for profiling...
#ifdef DEVELOPERS
int sight_rej_hit;
int sight_rej_miss;
#endif


static INLINE void AddSightIntercept(float_t frac, sector_t *sec)
{
  wall_icpts.num++;
  Z_BunchNewSize(wall_icpts, wall_intercept_t);

  wall_icpts.arr[wall_icpts.num - 1].frac  = frac;
  wall_icpts.arr[wall_icpts.num - 1].sector = sec;
}
</t>
<t tx="T2023">@ CrossSubsector

Returns false if LOS is blocked by the given subsector, otherwise
true. Note: extrafloors are not checked here.
@c

static boolean_t CrossSubsector(subsector_t *sub)
{
  seg_t *seg;
  line_t *ld;

  int s1, s2;

  sector_t *front;
  sector_t *back;
  divline_t divl;

  float_t frac;
  float_t slope;

  // check lines
  for (seg = sub-&gt;segs; seg != NULL; seg = seg-&gt;sub_next)
  {
    if (seg-&gt;miniseg)
      continue;

    // ignore segs that face away from the source.  We only want to
    // process linedefs on the _far_ side of each subsector.
    //
    if ((angle_t)(seg-&gt;angle - sight_I.angle) &lt; ANG180)
      continue;
    
    ld = seg-&gt;linedef;

    // line already checked ? (e.g. multiple segs on it)
    if (ld-&gt;validcount == validcount)
      continue;

    ld-&gt;validcount = validcount;

    // line outside of bbox ?
    if (ld-&gt;bbox[BOXLEFT] &gt; sight_I.bbox[BOXRIGHT] ||
        ld-&gt;bbox[BOXRIGHT] &lt; sight_I.bbox[BOXLEFT] ||
        ld-&gt;bbox[BOXBOTTOM] &gt; sight_I.bbox[BOXTOP] ||
        ld-&gt;bbox[BOXTOP] &lt; sight_I.bbox[BOXBOTTOM])
      continue;

    // does linedef cross LOS ?
    s1 = P_PointOnDivlineSide(ld-&gt;v1-&gt;x, ld-&gt;v1-&gt;y, &amp;sight_I.src);
    s2 = P_PointOnDivlineSide(ld-&gt;v2-&gt;x, ld-&gt;v2-&gt;y, &amp;sight_I.src);

    if (s1 == s2)
      continue;

    // linedef crosses LOS (extended to infinity), now check if the
    // cross point lies within the finite LOS range.
    // 
    divl.x  = ld-&gt;v1-&gt;x;
    divl.y  = ld-&gt;v1-&gt;y;
    divl.dx = ld-&gt;dx;
    divl.dy = ld-&gt;dy;

    s1 = P_PointOnDivlineSide(sight_I.src.x, sight_I.src.y, &amp;divl);
    s2 = P_PointOnDivlineSide(sight_I.dest.x, sight_I.dest.y, &amp;divl);

    if (s1 == s2)
      continue;

    // stop because it is not two sided anyway
    if (!(ld-&gt;flags &amp; ML_TwoSided) || ld-&gt;blocked)
    {
      return false;
    }

    // line explicitly blocks sight ?  (XDoom compatibility)
    if (ld-&gt;flags &amp; ML_SightBlock)
      return false;

    // -AJA- 2001/11/11: closed Sliding door ?
    if (ld-&gt;special &amp;&amp; ld-&gt;special-&gt;s.type != SLIDE_None &amp;&amp;
        ! ld-&gt;special-&gt;s.see_through &amp;&amp; ! ld-&gt;slider_move)
    {
      return false;
    }
    
    front = seg-&gt;frontsector;
    back = seg-&gt;backsector;

    DEV_ASSERT2(back);

    // compute intercept vector (fraction from 0 to 1)
    {
      float_t num, den;

      den = divl.dy * sight_I.src.dx - divl.dx * sight_I.src.dy;

      // parallel ?  
      // -AJA- probably can't happen due to the above Divline checks
      if (fabs(den) &lt; 0.0001)
        continue;

      num = (divl.x - sight_I.src.x) * divl.dy + 
            (sight_I.src.y - divl.y) * divl.dx;

      frac = num / den;

      // too close to source ?
      if (frac &lt; 0.0001)
        continue;
    }

    if (front-&gt;f_h != back-&gt;f_h)
    {
      float_t openbottom = MAX(ld-&gt;frontsector-&gt;f_h, ld-&gt;backsector-&gt;f_h);
      slope = (openbottom - sight_I.src_z) / frac;
      if (slope &gt; sight_I.bottom_slope)
        sight_I.bottom_slope = slope;
    }

    if (front-&gt;c_h != back-&gt;c_h)
    {
      float_t opentop = MIN(ld-&gt;frontsector-&gt;c_h, ld-&gt;backsector-&gt;c_h);
      slope = (opentop - sight_I.src_z) / frac;
      if (slope &lt; sight_I.top_slope)
        sight_I.top_slope = slope;
    }

    // did our slope range close up ?
    if (sight_I.top_slope &lt;= sight_I.bottom_slope)
      return false;

    // shouldn't be any more matching linedefs
    AddSightIntercept(frac, front);
    return true;
  }

  // LOS ray went completely passed the subsector
  return true;
}
</t>
<t tx="T2024">@ CheckSightBSP

Returns false if LOS is blocked by the given node, otherwise true.
Note: extrafloors are not checked here.
@c

static boolean_t CheckSightBSP(int bspnum)
{
  DEV_ASSERT2(bspnum &gt;= 0);

  while (! (bspnum &amp; NF_SUBSECTOR))
  {
    node_t *node = nodes + bspnum;
    int s1, s2;

#if (DEBUG_SIGHT &gt;= 2)
    L_WriteDebug("CheckSightBSP: node %d (%1.1f,%1.1f) + (%1.1f,%1.1f)\n",
      bspnum, node-&gt;div.x, node-&gt;div.y, node-&gt;div.dx, node-&gt;div.dy);
#endif

    // decide which side the src and dest points are on
    s1 = P_PointOnDivlineSide(sight_I.src.x, sight_I.src.y, &amp;node-&gt;div);
    s2 = P_PointOnDivlineSide(sight_I.dest.x, sight_I.dest.y, &amp;node-&gt;div);

#if (DEBUG_SIGHT &gt;= 2)
    L_WriteDebug("  Sides: %d %d\n", s1, s2);
#endif
    
    // If sides are different, we must recursively check both.
    // NOTE WELL: we do the source side first, so that subsectors are
    // visited in the correct order (closest -&gt; furthest away).

    if (s1 != s2)
    {
      if (! CheckSightBSP(node-&gt;children[s1]))
        return false;
    }

    bspnum = node-&gt;children[s2];
  }

  bspnum &amp;= ~NF_SUBSECTOR;

  DEV_ASSERT((0 &lt;= bspnum &amp;&amp; bspnum &lt; numsubsectors),
      ("CrossSubsector: sub %i with numsub = %i", bspnum, numsubsectors));

  {
    subsector_t *sub = subsectors + bspnum;

#if (DEBUG_SIGHT &gt;= 2)
    L_WriteDebug("  Subsec %d  SEC %d\n", bspnum, sub-&gt;sector - sectors);
#endif
      
    if (sub-&gt;sector-&gt;exfloor_used &gt; 0)
      sight_I.exfloors = true;

    // when target subsector is reached, there are no more lines to
    // check, since we only check lines on the _far_ side of the
    // subsector and the target object is inside its subsector.

    if (sub != sight_I.dest_sub)
      return CrossSubsector(sub);

    AddSightIntercept(1.0, sub-&gt;sector);
  }

  return true;
}
</t>
<t tx="T2025">@ CheckSightIntercepts

Returns false if LOS is blocked by extrafloors, otherwise true.
@c

static boolean_t CheckSightIntercepts(float_t slope)
{
  int i, j;
  sector_t *sec;

  float_t last_h = sight_I.src_z;
  float_t cur_h;

#if (DEBUG_SIGHT &gt;= 1)
  L_WriteDebug("INTERCEPTS  slope %1.0f\n", slope);
#endif

  for (i=0; i &lt; wall_icpts.num; i++, last_h = cur_h)
  {
    boolean_t blocked = true;

    cur_h = sight_I.src_z + slope * wall_icpts.arr[i].frac;

#if (DEBUG_SIGHT &gt;= 1)
    L_WriteDebug("  %d/%d  FRAC %1.4f  SEC %d  H=%1.4f/%1.4f\n", i+1,
        wall_icpts.num, wall_icpts.arr[i].frac, 
        wall_icpts.arr[i].sector - sectors, last_h, cur_h);
#endif

    // check all the sight gaps.
    sec = wall_icpts.arr[i].sector;

    for (j=0; j &lt; sec-&gt;sight_gap_num; j++)
    {
      float_t z1 = sec-&gt;sight_gaps[j].f;
      float_t z2 = sec-&gt;sight_gaps[j].c;

#if (DEBUG_SIGHT &gt;= 3)
      L_WriteDebug("    SIGHT GAP [%d] = %1.1f .. %1.1f\n", j, z1, z2);
#endif

      if (z1 &lt;= last_h &amp;&amp; last_h &lt;= z2 &amp;&amp;
          z1 &lt;= cur_h &amp;&amp; cur_h &lt;= z2)
      {
        blocked = false;
        break;
      }
    }

    if (blocked)
      return false;
  }
  
  return true;
}
</t>
<t tx="T2026">@ CheckSightSameSubsector

When the subsector is the same, we only need to check whether a
non-SeeThrough extrafloor gets in the way.
@c

static boolean_t CheckSightSameSubsector(mobj_t *src, mobj_t *dest)
{
  int j;
  sector_t *sec;

  float_t lower_z;
  float_t upper_z;

  if (sight_I.src_z &lt; dest-&gt;z)
  {
    lower_z = sight_I.src_z;
    upper_z = dest-&gt;z;
  }
  else if (sight_I.src_z &gt; dest-&gt;z + dest-&gt;height)
  {
    lower_z = dest-&gt;z + dest-&gt;height;
    upper_z = sight_I.src_z;
  }
  else
  {
    return true;
  }

  // check all the sight gaps.
  sec = src-&gt;subsector-&gt;sector;

  for (j=0; j &lt; sec-&gt;sight_gap_num; j++)
  {
    float_t z1 = sec-&gt;sight_gaps[j].f;
    float_t z2 = sec-&gt;sight_gaps[j].c;

    if (z1 &lt;= lower_z &amp;&amp; upper_z &lt;= z2)
      return true;
  }

  return false;
}
</t>
<t tx="T2027">@ P_CheckSight

Returns true if a straight line between t1 and t2 is unobstructed.
Uses the REJECT info.
@c

boolean_t P_CheckSight(mobj_t * src, mobj_t * dest)
{
  int n, num_div;

  float_t dest_heights[5];
  float_t dist_a;

  // First check for trivial rejection.

  // -ACB- 1998/07/20 t2 is Invisible, t1 cannot possibly see it.
  if (dest-&gt;visibility == INVISIBLE)
    return false;

  DEV_ASSERT2(src-&gt;subsector);
  DEV_ASSERT2(dest-&gt;subsector);

#if 0  // PROFILING
  {
    static int lasttime = 0;
    
    if (leveltime - lasttime &gt; 5*TICRATE)
    {
      L_WriteDebug("REJECT  HIT %d  MISS %d\n", sight_rej_hit,
          sight_rej_miss);

      sight_rej_hit = sight_rej_miss = 0;
      lasttime = leveltime;
    }
  }
#endif

  // Determine subsector entries in REJECT table.
  if (rejectmatrix)
  {
    int s1 = (src-&gt;subsector-&gt;sector - sectors);
    int s2 = (dest-&gt;subsector-&gt;sector - sectors);
    int pnum = s1 * numsectors + s2;
    int bytenum = pnum &gt;&gt; 3;
    int bitnum = 1 &lt;&lt; (pnum &amp; 7);

    if (rejectmatrix[bytenum] &amp; bitnum)
    {
#ifdef DEVELOPERS
      sight_rej_hit++;
#endif
      // can't possibly be connected
      return false;
    }
  }

#ifdef DEVELOPERS
  sight_rej_miss++;
#endif

  // An unobstructed LOS is possible.
  // Now look from eyes of t1 to any part of t2.

  validcount++;

  // The "eyes" of a thing is 75% of its height.
  DEV_ASSERT2(src-&gt;info);
  sight_I.src_z = src-&gt;z + src-&gt;height * 
      PERCENT_2_FLOAT(src-&gt;info-&gt;viewheight);

  sight_I.src.x = src-&gt;x;
  sight_I.src.y = src-&gt;y;
  sight_I.src.dx = dest-&gt;x - src-&gt;x;
  sight_I.src.dy = dest-&gt;y - src-&gt;y;
  sight_I.src_sub = src-&gt;subsector;

  sight_I.dest.x = dest-&gt;x;
  sight_I.dest.y = dest-&gt;y;
  sight_I.dest_sub = dest-&gt;subsector;

  sight_I.bottom_slope = dest-&gt;z - sight_I.src_z;
  sight_I.top_slope = sight_I.bottom_slope + dest-&gt;height;
  
  // destination out of object's DDF slope range ?
  dist_a = P_ApproxDistance(sight_I.src.dx, sight_I.src.dy);

#if (DEBUG_SIGHT &gt;= 1)
  L_WriteDebug("\n");
  L_WriteDebug("P_CheckSight:\n");
  L_WriteDebug("  Src: [%s] @ (%1.0f,%1.0f) in sub %d SEC %d\n", 
      src-&gt;info-&gt;ddf.name, sight_I.src.x, sight_I.src.y,
      sight_I.src_sub - subsectors, sight_I.src_sub-&gt;sector - sectors);
  L_WriteDebug("  Dest: [%s] @ (%1.0f,%1.0f) in sub %d SEC %d\n", 
      dest-&gt;info-&gt;ddf.name, sight_I.dest.x, sight_I.dest.y,
      sight_I.dest_sub - subsectors, sight_I.dest_sub-&gt;sector - sectors);
  L_WriteDebug("  Angle: %1.0f\n", ANG_2_FLOAT(sight_I.angle));
#endif

  if (sight_I.top_slope &lt; dist_a * -src-&gt;info-&gt;sight_slope)
    return false;

  if (sight_I.bottom_slope &gt; dist_a * src-&gt;info-&gt;sight_slope)
    return false;

  // -AJA- handle the case where no linedefs are crossed
  if (src-&gt;subsector == dest-&gt;subsector)
  {
    return CheckSightSameSubsector(src, dest);
  }

  sight_I.angle = R_PointToAngle(sight_I.src.x, sight_I.src.y,
      sight_I.dest.x, sight_I.dest.y);
   
  sight_I.bbox[BOXLEFT]   = MIN(sight_I.src.x, sight_I.dest.x);
  sight_I.bbox[BOXRIGHT]  = MAX(sight_I.src.x, sight_I.dest.x);
  sight_I.bbox[BOXBOTTOM] = MIN(sight_I.src.y, sight_I.dest.y);
  sight_I.bbox[BOXTOP]    = MAX(sight_I.src.y, sight_I.dest.y);

  wall_icpts.num = 0;
  Z_BunchNewSize(wall_icpts, wall_intercept_t);

  sight_I.exfloors = false;
  
  // initial pass -- check for basic blockage &amp; create intercepts
  if (! CheckSightBSP(root_node))
    return false;

  // no extrafloors encountered ?  Then the checks made by
  // CheckSightBSP are sufficient.  (-AJA- double check this)
  //
#if 1
  if (! sight_I.exfloors)
    return true;
#endif
 
  // Enter the HackMan...  The new sight code only tests LOS to one
  // destination height.  (The old code kept track of angles -- but
  // this approach is not well suited for extrafloors).  The number of
  // points we test depends on the destination: 5 for players, 3 for
  // monsters, 1 for everything else.
 
  if (dest-&gt;player)
  {
    num_div = 5;
    dest_heights[0] = dest-&gt;z;
    dest_heights[1] = dest-&gt;z + dest-&gt;height * 0.25;
    dest_heights[2] = dest-&gt;z + dest-&gt;height * 0.50;
    dest_heights[3] = dest-&gt;z + dest-&gt;height * 0.75;
    dest_heights[4] = dest-&gt;z + dest-&gt;height;
  }
  else if (dest-&gt;extendedflags &amp; EF_MONSTER)
  {
    num_div = 3;
    dest_heights[0] = dest-&gt;z;
    dest_heights[1] = dest-&gt;z + dest-&gt;height * 0.5;
    dest_heights[2] = dest-&gt;z + dest-&gt;height;
  }
  else
  {
    num_div = 1;
    dest_heights[0] = dest-&gt;z + dest-&gt;height * 0.5;
  }
 
  // use intercepts to check extrafloor heights
  // 
  for (n=0; n &lt; num_div; n++)
  {
    float_t slope = dest_heights[n] - sight_I.src_z;

    if (slope &gt; sight_I.top_slope || slope &lt; sight_I.bottom_slope)
      continue;

    if (CheckSightIntercepts(slope))
      return true;
  }
 
  return false;
}
</t>
<t tx="T2028">@ P_CheckSightApproxVert

Quickly check that object t1 can vertically see object t2. Only
takes extrafloors into account. Mainly used so that archviles
don't resurrect monsters that are completely out of view in another
vertical region. Returns true if sight possible, false otherwise.
@c

boolean_t P_CheckSightApproxVert(mobj_t * src, mobj_t * dest)
{
  DEV_ASSERT2(src-&gt;info);

  sight_I.src_z = src-&gt;z + src-&gt;height * 
      PERCENT_2_FLOAT(src-&gt;info-&gt;viewheight);

  return CheckSightSameSubsector(src, dest);
}
</t>
<t tx="T2029">@ignore
@language c

// Specials Lines &amp; Floor Code

// -KM- 1998/09/01 Lines.ddf

&lt;&lt; p_spec #includes &gt;&gt;
&lt;&lt; p_spec declarations &gt;&gt;
@others
</t>
<t tx="T2030">#include "i_defs.h"
#include "p_spec.h"

#include "con_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "g_game.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_random.h"
#include "p_local.h"
#include "r_local.h"
#include "r_state.h"
#include "r2_defs.h"
#include "rad_trig.h"
#include "s_sound.h"
#include "v_colour.h"
#include "w_textur.h"
#include "w_wad.h"
#include "z_zone.h"

#include "ddf_main.h"  // -KM- 1998/07/31 Need animation definitions
</t>
<t tx="T2031">
// Level exit timer
static boolean_t levelTimer;
static int levelTimeCount;

// -AJA- temp structure for BOOM water (compatibility)
static const image_t ** sp_new_floors;

//
// Animating line and sector specials
//
line_t * line_speciallist;
sector_t * sect_speciallist;

typedef struct sectorsfx_s
{
  sector_t *sector;
  sfx_t *sfx;
  boolean_t sfxstarted;

  // tics to go before next update
  int count;

  // link in list
  struct sectorsfx_s *next;
}
sectorsfx_t;

#define SECSFX_TIME  7  // every 7 tics (i.e. 5 times per second)

static sectorsfx_t *sectorsfx_list;

static boolean_t P_DoSectorsFromTag(int tag, const void *p1, void *p2,
    boolean_t(*func) (sector_t *, const void *, void *));
</t>
<t tx="T2032">@ DoElevator_wrapper

-ACB- 2001/01/14 Added
@c

static boolean_t DoElevator_wrapper(sector_t *s, const void *p1, void *p2) 
{
  return EV_DoElevator(s, p1, p2);
}
</t>
<t tx="T2033">@ DoPlane_wrapper
@c

static boolean_t DoPlane_wrapper(sector_t *s, const void *p1, void *p2)
{
  return EV_DoPlane(s, p1, p2);
}
</t>
<t tx="T2034">@ DoLights_wrapper
@c

static boolean_t DoLights_wrapper(sector_t *s, const void *p1, void *p2)
{
  return EV_Lights(s, p1);
}
</t>
<t tx="T2035">@ DoDonut_wrapper
@c

static boolean_t DoDonut_wrapper(sector_t *s, const void *p1, void *p2)
{
  return EV_DoDonut(s, p2);
}
</t>
<t tx="T2036">@ Creates a sector sfx and adds it to the list.
@c

static sectorsfx_t *NewSectorSFX(void)
{
  sectorsfx_t *sfx;

  sfx = Z_New(sectorsfx_t, 1);

  sfx-&gt;next = sectorsfx_list;
  sectorsfx_list = sfx;
  
  return sfx;
}
</t>
<t tx="T2037">@ P_DestroyAllSectorSFX
@c

void P_DestroyAllSectorSFX(void)
{
  sectorsfx_t *sfx, *next;

  for (sfx = sectorsfx_list; sfx; sfx = next)
  {
    next = sfx-&gt;next;
    Z_Free(sfx);
  }
  sectorsfx_list = NULL;
}
</t>
<t tx="T2038">@ DoSectorSFX

-KM- 1998/09/27

This function is called every so often to keep a sector's ambient
sound going. The sound should be looped.
@c

static void DoSectorSFX(sectorsfx_t *sec)
{
  if (--sec-&gt;count)
    return;

  sec-&gt;count = SECSFX_TIME;

  if (!sec-&gt;sfxstarted)
  {
    if (P_ApproxDistance(displayplayer-&gt;mo-&gt;x - sec-&gt;sector-&gt;soundorg.x,
            displayplayer-&gt;mo-&gt;y - sec-&gt;sector-&gt;soundorg.y)
        &lt; S_CLIPPING_DIST)
    {
      int channel = S_StartSound((mobj_t *) &amp; sec-&gt;sector-&gt;soundorg,
          sec-&gt;sfx);

      if (channel &gt;= 0)
        sec-&gt;sfxstarted = true;
    }
  }
  else
  {
    if (P_ApproxDistance(displayplayer-&gt;mo-&gt;x - sec-&gt;sector-&gt;soundorg.x,
            displayplayer-&gt;mo-&gt;y - sec-&gt;sector-&gt;soundorg.y)
        &gt; S_CLIPPING_DIST)
    {
      S_StopSound((mobj_t *) &amp;sec-&gt;sector-&gt;soundorg);
      sec-&gt;sfxstarted = false;
    }
  }
}
</t>
<t tx="T2039">@ P_RunSectorSFX
@c

void P_RunSectorSFX(void)
{
  // -AJA- FIXME: 

  sectorsfx_t *sfx;

  for (sfx = sectorsfx_list; sfx; sfx = sfx-&gt;next)
  {
    DoSectorSFX(sfx);
  }
}
</t>
<t tx="T2040">@ UTILITIES


P_GetSide

Will return a side_t * given the number of the current sector,
the line number, and the side (0/1) that you want.
@c

side_t *P_GetSide(int currentSector, int line, int side)
{
  line_t *linedef = sectors[currentSector].lines[line];

  return linedef-&gt;side[side];
}
</t>
<t tx="T2041">@ P_GetSector

Will return a sector_t*
given the number of the current sector,
the line number and the side (0/1) that you want.
@c

sector_t *P_GetSector(int currentSector, int line, int side)
{
  line_t *linedef = sectors[currentSector].lines[line];

  return side ? linedef-&gt;backsector : linedef-&gt;frontsector;
}
</t>
<t tx="T2042">@ P_TwoSided

Given the sector number and the line number, it will tell you whether the
line is two-sided or not.
@c

int P_TwoSided(int sector, int line)
{
  return (sectors[sector].lines[line])-&gt;flags &amp; ML_TwoSided;
}
</t>
<t tx="T2043">@ P_GetNextSector

Return sector_t * of sector next to current; NULL if not two-sided line
@c

sector_t *P_GetNextSector(const line_t * line, const sector_t * sec)
{
  if (!(line-&gt;flags &amp; ML_TwoSided))
    return NULL;

  if (line-&gt;frontsector == sec)
    return line-&gt;backsector;

  return line-&gt;frontsector;
}
</t>
<t tx="T2044">@ P_FindSurroundingHeight

-AJA- 2001/05/29: this is an amalgamation of the previous bunch of
routines, using the new REF_* flag names. Now there's just
this one big routine -- the compiler's optimiser had better
kick in !
@c

#define F_C_HEIGHT(sector)  \
((ref &amp; REF_CEILING) ? (sector)-&gt;c_h : (sector)-&gt;f_h)

float_t P_FindSurroundingHeight(const heightref_e ref, const sector_t *sec)
{
int i, count;
float_t height;
float_t base = F_C_HEIGHT(sec);

if (ref &amp; REF_INCLUDE)
height = base;
else if (ref &amp; REF_HIGHEST)
height = -32000.0;  // BOOM compatible value
else
height = +32000.0;

for (i = count = 0; i &lt; sec-&gt;linecount; i++)
{
sector_t *other = P_GetNextSector(sec-&gt;lines[i], sec);
boolean_t satisfy;
float_t other_h;

if (!other)
  continue;

other_h = F_C_HEIGHT(other);

if (ref &amp; REF_NEXT)
{
  // this may seem reversed, but is OK (see note in ddf_sect.c)
  if (ref &amp; REF_HIGHEST)
    satisfy = (other_h &lt; base);  // next lowest
  else
    satisfy = (other_h &gt; base);  // next highest

  if (! satisfy)
    continue;
}

count++;

if (ref &amp; REF_HIGHEST)
  height = MAX(height, other_h);
else
  height = MIN(height, other_h);
}

if ((ref &amp; REF_NEXT) &amp;&amp; count == 0)
return base;

return height;
}
</t>
<t tx="T2045">@ P_FindRaiseToTexture

FIND THE SHORTEST BOTTOM TEXTURE SURROUNDING sec
AND RETURN IT'S TOP HEIGHT

-KM- 1998/09/01 Lines.ddf; used to be inlined in p_floors
@c

float_t P_FindRaiseToTexture(sector_t * sec)
{
  int i;
  side_t *side;
  float_t minsize = INT_MAX;
  int secnum = sec - sectors;

  for (i = 0; i &lt; sec-&gt;linecount; i++)
  {
    if (P_TwoSided(secnum, i))
    {
      side = P_GetSide(secnum, i, 0);

      if (side-&gt;bottom.image)
      {
        if (IM_HEIGHT(side-&gt;bottom.image) &lt; minsize)
          minsize = IM_HEIGHT(side-&gt;bottom.image);
      }

      side = P_GetSide(secnum, i, 1);

      if (side-&gt;bottom.image)
      {
        if (IM_HEIGHT(side-&gt;bottom.image) &lt; minsize)
          minsize = IM_HEIGHT(side-&gt;bottom.image);
      }
    }
  }

  return sec-&gt;f_h + minsize;
}
</t>
<t tx="T2046">@ P_FindSectorFromTag

Returns the FIRST sector that tag refers to.

-KM- 1998/09/27 Doesn't need a line.
-AJA- 1999/09/29: Now returns a sector_t, and has no start.
@c

sector_t *P_FindSectorFromTag(int tag)
{
  int i;

  for (i = 0; i &lt; numsectors; i++)
  {
    if (sectors[i].tag == tag)
      return sectors + i;
  }

  return NULL;
}
</t>
<t tx="T2047">@ P_FindMinSurroundingLight

Find minimum light from an adjacent sector
@c

int P_FindMinSurroundingLight(sector_t * sector, int max)
{
  int i;
  int min;
  line_t *line;
  sector_t *check;

  min = max;
  for (i = 0; i &lt; sector-&gt;linecount; i++)
  {
    line = sector-&gt;lines[i];
    check = P_GetNextSector(line, sector);

    if (!check)
      continue;

    if (check-&gt;props.lightlevel &lt; min)
      min = check-&gt;props.lightlevel;
  }
  return min;
}
</t>
<t tx="T2048">@ P_AddSpecialLine

UTILITY FUNCS FOR SPECIAL LIST
@c

void P_AddSpecialLine(line_t *ld)
{
  line_t *check;

  // check if already linked
  for (check=line_speciallist; check; check=check-&gt;animate_next)
  {
    if (check == ld)
      return;
  }

  ld-&gt;animate_next = line_speciallist;
  line_speciallist = ld;
}
</t>
<t tx="T2049">@ P_AddSpecialSector
@c

void P_AddSpecialSector(sector_t *sec)
{
  sector_t *check;

  // check if already linked
  for (check=sect_speciallist; check; check=check-&gt;animate_next)
  {
    if (check == sec)
      return;
  }

  sec-&gt;animate_next = sect_speciallist;
  sect_speciallist = sec;
}
</t>
<t tx="T2050">
static void AdjustScrollParts(side_t *side, boolean_t left,
    scroll_part_e parts, float_t x_speed, float_t y_speed)
{
  float_t xmul = (left &amp;&amp; (parts &amp; SCPT_LeftRevX)) ? -1 : 1;
  float_t ymul = (left &amp;&amp; (parts &amp; SCPT_LeftRevY)) ? -1 : 1;

  if (! side)
    return;

  if (parts == 0)
    parts = SCPT_RIGHT;

  if (parts &amp; (left ? SCPT_LeftUpper : SCPT_RightUpper))
  {
    side-&gt;top.scroll.x += x_speed * xmul;
    side-&gt;top.scroll.y += y_speed * ymul;
  }
  if (parts &amp; (left ? SCPT_LeftMiddle : SCPT_RightMiddle))
  {
    side-&gt;middle.scroll.x += x_speed * xmul;
    side-&gt;middle.scroll.y += y_speed * ymul;
  }
  if (parts &amp; (left ? SCPT_LeftLower : SCPT_RightLower))
  {
    side-&gt;bottom.scroll.x += x_speed * xmul;
    side-&gt;bottom.scroll.y += y_speed * ymul;
  }
}
</t>
<t tx="T2051">
static void AdjustScaleParts(side_t *side, boolean_t left,
    scroll_part_e parts, float_t scale)
{
  if (! side)
    return;

  if (parts == 0)
    parts = SCPT_LEFT | SCPT_RIGHT;
    
  if (parts &amp; (left ? SCPT_LeftUpper : SCPT_RightUpper))
    side-&gt;top.x_mat.x = side-&gt;top.y_mat.y = scale;

  if (parts &amp; (left ? SCPT_LeftMiddle : SCPT_RightMiddle))
    side-&gt;middle.x_mat.x = side-&gt;middle.y_mat.y = scale;

  if (parts &amp; (left ? SCPT_LeftLower : SCPT_RightLower))
    side-&gt;bottom.x_mat.x = side-&gt;bottom.y_mat.y = scale;
}
</t>
<t tx="T2052">
static void AdjustSkewParts(side_t *side, boolean_t left,
    scroll_part_e parts, float_t skew)
{
  if (! side)
    return;

  if (parts == 0)
    parts = SCPT_LEFT | SCPT_RIGHT;
   
  if (parts &amp; (left ? SCPT_LeftUpper : SCPT_RightUpper))
    side-&gt;top.y_mat.x = skew * side-&gt;top.y_mat.y;

  if (parts &amp; (left ? SCPT_LeftMiddle : SCPT_RightMiddle))
    side-&gt;middle.y_mat.x = skew * side-&gt;middle.y_mat.y;

  if (parts &amp; (left ? SCPT_LeftLower : SCPT_RightLower))
    side-&gt;bottom.y_mat.x = skew * side-&gt;bottom.y_mat.y;
}
</t>
<t tx="T2053">
static void AdjustLightParts(side_t *side, boolean_t left,
    scroll_part_e parts, region_properties_t *p)
{
  if (! side)
    return;

  if (parts == 0)
    parts = SCPT_LEFT | SCPT_RIGHT;
   
  if (parts &amp; (left ? SCPT_LeftUpper : SCPT_RightUpper))
    side-&gt;top.override_p = p;

  if (parts &amp; (left ? SCPT_LeftMiddle : SCPT_RightMiddle))
    side-&gt;middle.override_p = p;

  if (parts &amp; (left ? SCPT_LeftLower : SCPT_RightLower))
    side-&gt;bottom.override_p = p;
}
</t>
<t tx="T2054">@ P_EFTransferTrans
@c

static void P_EFTransferTrans(sector_t *ctrl, sector_t *sec, line_t *line, 
    const extrafloor_info_t *ef, float_t trans)
{
  int i;

  // floor and ceiling

  if (ctrl-&gt;floor.translucency &gt; trans)
    ctrl-&gt;floor.translucency = trans;

  if (ctrl-&gt;ceil.translucency &gt; trans)
    ctrl-&gt;ceil.translucency = trans;

  // sides

  if (! (ef-&gt;type &amp; EXFL_Thick))
    return;

  if (ef-&gt;type &amp; (EXFL_SideUpper | EXFL_SideLower))
  {
    for (i=0; i &lt; sec-&gt;linecount; i++)
    {
      line_t *L = sec-&gt;lines[i];
      side_t *S = NULL;

      if (L-&gt;frontsector == sec)
        S = L-&gt;side[1];
      else if (L-&gt;backsector == sec)
        S = L-&gt;side[0];

      if (! S)
        continue;

      if (ef-&gt;type &amp; EXFL_SideUpper)
        S-&gt;top.translucency = trans;
      else  // EXFL_SideLower
        S-&gt;bottom.translucency = trans;
    }

    return;
  }

  line-&gt;side[0]-&gt;middle.translucency = trans;
}
</t>
<t tx="T2055">@ P_LineEffect

Handles BOOM's line -&gt; tagged line transfers.
@c

static void P_LineEffect(line_t *target, line_t *source,
    const linedeftype_t *special)
{
  float_t length = R_PointToDist(0, 0, source-&gt;dx, source-&gt;dy);

  if ((special-&gt;line_effect &amp; LINEFX_Translucency) &amp;&amp;
      (target-&gt;flags &amp; ML_TwoSided))
  {
    target-&gt;side[0]-&gt;middle.translucency = 0.5;
    target-&gt;side[1]-&gt;middle.translucency = 0.5;
  }

  if (special-&gt;line_effect &amp; LINEFX_VectorScroll)
  {
    // -AJA- Note: these values are the same as in BOOM, which doesn't
    //       exactly match the description given in boomref.txt, which
    //       suggests that the horizontal speed is proportional to the
    //       tagging line's length.

    float_t xspeed = source-&gt;dx / 32.0;
    float_t yspeed = source-&gt;dy / 32.0;

    AdjustScrollParts(target-&gt;side[0], 0, special-&gt;line_parts,
        xspeed, yspeed);

    AdjustScrollParts(target-&gt;side[1], 1, special-&gt;line_parts,
        xspeed, yspeed);

    P_AddSpecialLine(target);
  }

  if ((special-&gt;line_effect &amp; LINEFX_OffsetScroll) &amp;&amp; target-&gt;side[0])
  {
    float_t xspeed = -target-&gt;side[0]-&gt;middle.offset.x;
    float_t yspeed =  target-&gt;side[0]-&gt;middle.offset.y;

    AdjustScrollParts(target-&gt;side[0], 0, special-&gt;line_parts,
        xspeed, yspeed);

    P_AddSpecialLine(target);
  }

  // experimental: unblock line(s)
  if (special-&gt;line_effect &amp; LINEFX_UnblockThings)
  {
    if (target-&gt;side[0] &amp;&amp; target-&gt;side[1] &amp;&amp; (target != source))
      target-&gt;flags &amp;= ~(ML_Blocking | ML_BlockMonsters);
  }

  // experimental: block bullets/missiles
  if (special-&gt;line_effect &amp; LINEFX_BlockShots)
  {
    if (target-&gt;side[0] &amp;&amp; target-&gt;side[1])
      target-&gt;flags |= ML_ShootBlock;
  }

  // experimental: block monster sight
  if (special-&gt;line_effect &amp; LINEFX_BlockSight)
  {
    if (target-&gt;side[0] &amp;&amp; target-&gt;side[1])
      target-&gt;flags |= ML_SightBlock;
  }

  // experimental: scale wall texture(s) by line length
  if (special-&gt;line_effect &amp; LINEFX_Scale)
  {
    AdjustScaleParts(target-&gt;side[0], 0, special-&gt;line_parts, length/128);
    AdjustScaleParts(target-&gt;side[1], 1, special-&gt;line_parts, length/128);
  }

  // experimental: skew wall texture(s) by sidedef Y offset
  if ((special-&gt;line_effect &amp; LINEFX_Skew) &amp;&amp; source-&gt;side[0])
  {
    float_t skew = source-&gt;side[0]-&gt;top.offset.x / 128.0;

    AdjustSkewParts(target-&gt;side[0], 0, special-&gt;line_parts, skew);
    AdjustSkewParts(target-&gt;side[1], 1, special-&gt;line_parts, skew);

    if (target == source)
    {
      source-&gt;side[0]-&gt;middle.offset.x = 0;
      source-&gt;side[0]-&gt;bottom.offset.x = 0;
    }
  }

  // experimental: transfer lighting to wall parts
  if (special-&gt;line_effect &amp; LINEFX_LightWall)
  {
    AdjustLightParts(target-&gt;side[0], 0, special-&gt;line_parts,
        &amp;source-&gt;frontsector-&gt;props);
    AdjustLightParts(target-&gt;side[1], 1, special-&gt;line_parts,
        &amp;source-&gt;frontsector-&gt;props);
  }
}
</t>
<t tx="T2056">@ P_SectorEffect

Handles BOOM's line -&gt; tagged sector transfers.
@c

static void P_SectorEffect(sector_t *target, line_t *source,
    const linedeftype_t *special)
{
  float_t length = R_PointToDist(0, 0, source-&gt;dx, source-&gt;dy);
  float_t angle = R_PointToAngle(0, 0, source-&gt;dx, source-&gt;dy);

  if (special-&gt;sector_effect &amp; SECTFX_LightFloor)
    target-&gt;floor.override_p = &amp;source-&gt;frontsector-&gt;props;

  if (special-&gt;sector_effect &amp; SECTFX_LightCeiling)
    target-&gt;ceil.override_p = &amp;source-&gt;frontsector-&gt;props;

  if (special-&gt;sector_effect &amp; SECTFX_ScrollFloor)
  {
    target-&gt;floor.scroll.x -= source-&gt;dx / 32.0;
    target-&gt;floor.scroll.y -= source-&gt;dy / 32.0;

    P_AddSpecialSector(target);
  }
  if (special-&gt;sector_effect &amp; SECTFX_ScrollCeiling)
  {
    target-&gt;ceil.scroll.x -= source-&gt;dx / 32.0;
    target-&gt;ceil.scroll.y -= source-&gt;dy / 32.0;

    P_AddSpecialSector(target);
  }

  if (special-&gt;sector_effect &amp; SECTFX_PushThings)
  {
    target-&gt;props.push.x += source-&gt;dx / 320.0;
    target-&gt;props.push.y += source-&gt;dy / 320.0;
  }

  if (special-&gt;sector_effect &amp; SECTFX_ResetFloor)
  {
    target-&gt;floor.override_p = NULL;
    target-&gt;floor.scroll.x = target-&gt;floor.scroll.y = 0;
    target-&gt;props.push.x = target-&gt;props.push.y = target-&gt;props.push.z = 0;
  }
  if (special-&gt;sector_effect &amp; SECTFX_ResetCeiling)
  {
    target-&gt;ceil.override_p = NULL;
    target-&gt;ceil.scroll.x = target-&gt;ceil.scroll.y = 0;
  }

  // experimental: set texture scale
  if (special-&gt;sector_effect &amp; SECTFX_ScaleFloor)
    target-&gt;floor.x_mat.x = target-&gt;floor.y_mat.y = length;

  if (special-&gt;sector_effect &amp; SECTFX_ScaleCeiling)
    target-&gt;ceil.x_mat.x = target-&gt;ceil.y_mat.y = length;

  // experimental: set texture alignment
  if (special-&gt;sector_effect &amp; SECTFX_AlignFloor)
  {
    target-&gt;floor.offset.x = -source-&gt;v1-&gt;x;
    target-&gt;floor.offset.y = -source-&gt;v1-&gt;y;

    M_Angle2Matrix(angle, &amp;target-&gt;floor.x_mat, &amp;target-&gt;floor.y_mat);
  }
  if (special-&gt;sector_effect &amp; SECTFX_AlignCeiling)
  {
    target-&gt;ceil.offset.x = -source-&gt;v1-&gt;x;
    target-&gt;ceil.offset.y = -source-&gt;v1-&gt;y;

    M_Angle2Matrix(angle, &amp;target-&gt;ceil.x_mat, &amp;target-&gt;ceil.y_mat);
  }
}
</t>
<t tx="T2057">@ EVENTS

Events are operations triggered by using, crossing,
or shooting special lines, or by timed thinkers.


P_ActivateSpecialLine

Called when a special line is activated.

line is the line to be activated, side is the side activated from,
(as lines can only be activated from the right), thing is the thing
activating, to check for player/monster only lines trig is how it
was activated, ie shot/crossed/pushed. `line' can be NULL for
non-line activations.

-KM- 1998/09/01 Procedure Written.

-ACB- 1998/09/11 Return Success or Failure.

-AJA- 1999/09/29: Updated for new tagged sector links.

-AJA- 1999/10/21: Allow non-line activation (line == NULL), and
added `typenum' and `tag' parameter.

-AJA- 2000/01/02: New trigger method `line_Any'.

-ACB- 2001/01/14: Added Elevator Sector Type
@c

static boolean_t P_ActivateSpecialLine(line_t * line,
    const linedeftype_t * special, int tag, int side, mobj_t * thing,
    trigger_e trig, int can_reach, int no_care_who)
{
  boolean_t texSwitch = false;
  boolean_t failedsecurity;  // -ACB- 1998/09/11 Security pass/fail check
  boolean_t playedSound = false;
  sfx_t *sfx[4];
  sector_t *tsec;

  int i;

#ifdef DEVELOPERS
  if (!special)
  {
    if (line == NULL)
      I_Error("P_ActivateSpecialLine: Special type is 0\n");
    else
      I_Error("P_ActivateSpecialLine: Line %d is not Special\n", 
          (int)(line - lines));
  }
#endif

  if (!G_CheckWhenAppear(special-&gt;appear))
  {
    if (line)
      line-&gt;special = NULL;

    return true;
  }

  if (trig != line_Any &amp;&amp; special-&gt;type != trig &amp;&amp;
      !(special-&gt;type == line_manual &amp;&amp; trig == line_pushable))
    return false;

  // Check for use once.
  if (line &amp;&amp; line-&gt;count == 0)
    return false;

  // Single sided line
  if (trig != line_Any &amp;&amp; special-&gt;singlesided &amp;&amp; side == 1)
    return false;

  // -AJA- 1999/12/07: Height checking.
  if (line &amp;&amp; thing &amp;&amp; thing-&gt;player &amp;&amp; (special-&gt;special_flags &amp; LINSP_MustReach) &amp;&amp; !can_reach)
  {
    S_StartSound(thing, thing-&gt;info-&gt;noway_sound);
    return false;
  }
  
  // Check this type of thing can trigger
  if (!no_care_who)
  {
    if (thing &amp;&amp; thing-&gt;player)
    {
      // Players can only trigger if the trig_player is set
      if (!(special-&gt;obj &amp; trig_player))
        return false;
    }
    else if (thing &amp;&amp; (thing-&gt;info-&gt;extendedflags &amp; EF_MONSTER))
    {
      // Monsters can only trigger if the trig_monster flag is set
      if (!(special-&gt;obj &amp; trig_monster))
        return false;
      
      // Monsters don't trigger secrets
      if (line &amp;&amp; (line-&gt;flags &amp; ML_Secret))
        return false;
    }
    else
    {
      // Other stuff can only trigger if trig_other is set
      if (!(special-&gt;obj &amp; trig_other))
        return false;

      // Other stuff doesn't trigger secrets
      if (line &amp;&amp; (line-&gt;flags &amp; ML_Secret))
        return false;
    }
  }

  if (thing &amp;&amp; !no_care_who)
  {
    // Check for keys
    // -ACB- 1998/09/11 Key possibilites extended
    if (special-&gt;keys != KF_NONE)
    {
      keys_e req = special-&gt;keys &amp; KF_MASK;
      keys_e cards;

      // Monsters/Missiles have no keys
      if (!thing-&gt;player)
        return false;

      //
      // New Security Checks, allows for any combination of keys in
      // an AND or OR function. Therefore it extends the possibilities
      // of security above 3 possible combinations..
      //
      // -AJA- Reworked this for the 10 new keys.
      //
      cards = thing-&gt;player-&gt;cards;
      failedsecurity = false;

      if (special-&gt;keys &amp; KF_BOOM_SKCK)
      {
        // Boom compatibility: treat card and skull types the same
        cards = EXPAND_KEYS(cards);
      }

      if (special-&gt;keys &amp; KF_STRICTLY_ALL)
      {
        if ((cards &amp; req) != req)
          failedsecurity = true;
      }
      else
      {
        if ((cards &amp; req) == 0)
          failedsecurity = true;
      }

      if (failedsecurity)
      {
        if (special-&gt;failedmessage)
          CON_PlayerMessageLDF(thing-&gt;player, special-&gt;failedmessage);

        return false;
      }
    }
  }

  // Check if button already pressed
  if (line &amp;&amp; P_ButtonCheckPressed(line))
    return false;
  
  // Do lights
  // -KM- 1998/09/27 Generalised light types.
  switch (special-&gt;l.type)
  {
    case LITE_Set:
      EV_LightTurnOn(tag, special-&gt;l.level);
      texSwitch = true;
      break;

    case LITE_None:
      break;

    default:
      texSwitch = P_DoSectorsFromTag(tag, &amp;special-&gt;l, NULL, DoLights_wrapper);
      break;
  }

  // -ACB- 1998/09/13 Use teleport define..
  if (special-&gt;t.teleport)
  {
    texSwitch = EV_Teleport(line, tag, 1, thing, special-&gt;t.delay, 
        special-&gt;t.special, special-&gt;t.inspawnobj, special-&gt;t.outspawnobj);
  }

  if (special-&gt;e_exit == EXIT_Normal)
  {
    G_ExitLevel(5);
    texSwitch = true;
  }
  else if (special-&gt;e_exit == EXIT_Secret)
  {
    G_SecretExitLevel(5);
    texSwitch = true;
  }

  if (special-&gt;d.dodonut)
  {
    // Proper ANSI C++ Init
    sfx[0] = special-&gt;d.d_sfxout;
    sfx[1] = special-&gt;d.d_sfxoutstop;
    sfx[2] = special-&gt;d.d_sfxin;
    sfx[3] = special-&gt;d.d_sfxinstop;

    texSwitch = P_DoSectorsFromTag(tag, NULL, sfx, DoDonut_wrapper);
  }

  //
  // - Plats/Floors -
  //
  if (special-&gt;f.type != mov_undefined)
  {
    if (!tag || trig == line_manual)
    {
      if (line)
        texSwitch = EV_ManualPlane(line, thing, &amp;special-&gt;f);
    }
    else
    {
      texSwitch = P_DoSectorsFromTag(tag, &amp;special-&gt;f, 
          line ? line-&gt;frontsector : NULL, DoPlane_wrapper);
    }
  }

  //
  // - Doors/Ceilings -
  //
  if (special-&gt;c.type != mov_undefined)
  {
    if (!tag || trig == line_manual)
    {
      if (line)
        texSwitch = EV_ManualPlane(line, thing, &amp;special-&gt;c);
    }
    else
    {
      texSwitch = P_DoSectorsFromTag(tag, &amp;special-&gt;c,
          line ? line-&gt;frontsector : NULL, DoPlane_wrapper);
    }
  }

#if 0  // -AJA- DISABLED (Unfinished)
  //
  // - Elevators -
  //
  // -ACB- 2001/01/14 Added
  //
  if (special-&gt;e.type != mov_undefined)
  {
    if (!tag || trig == line_manual)
    {
      if (line)
        texSwitch = EV_ManualElevator(line, thing, &amp;special-&gt;e);
    }
    else
    {
      texSwitch = P_DoSectorsFromTag(tag, &amp;special-&gt;e,
          line ? line-&gt;frontsector : NULL, DoElevator_wrapper);
    }
  }
#endif

  if (special-&gt;use_colourmap &amp;&amp; tag &gt; 0)
  {
    for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
    {
      tsec-&gt;props.colourmap = special-&gt;use_colourmap;
      texSwitch = true;
    }
  }

  // Note: M_PI means "not changed" for gravity, friction and
  // viscosity and drag.

  if (special-&gt;gravity != (float_t)M_PI &amp;&amp; tag &gt; 0)
  {
    for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
    {
      tsec-&gt;props.gravity = special-&gt;gravity;
      texSwitch = true;
    }
  }

  if (special-&gt;friction != (float_t)M_PI &amp;&amp; tag &gt; 0)
  {
    for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
    {
      tsec-&gt;props.friction = special-&gt;friction;
      texSwitch = true;
    }
  }

  if (special-&gt;viscosity != (float_t)M_PI &amp;&amp; tag &gt; 0)
  {
    for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
    {
      tsec-&gt;props.viscosity = special-&gt;viscosity;
      texSwitch = true;
    }
  }

  if (special-&gt;drag != (float_t)M_PI &amp;&amp; tag &gt; 0)
  {
    for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
    {
      tsec-&gt;props.drag = special-&gt;drag;
      texSwitch = true;
    }
  }

  // Extrafloor transfers
  if (line &amp;&amp; special-&gt;ef.type &amp;&amp; tag &gt; 0)
  {
    sector_t *ctrl = line-&gt;frontsector;

    for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
    {
      P_AddExtraFloor(tsec, line);

      // Handle the BOOMTEX flag (Boom compatibility)
      if ((special-&gt;ef.type &amp; EXFL_BoomTex) &amp;&amp; sp_new_floors)
      {
        if (! sp_new_floors[ctrl - sectors])
          sp_new_floors[ctrl - sectors] = tsec-&gt;floor.image;
        
        if (! sp_new_floors[tsec - sectors])
          sp_new_floors[tsec - sectors] = ctrl-&gt;floor.image;
      }

      // transfer any translucency
      if (PERCENT_2_FLOAT(special-&gt;translucency) &lt;= 0.99)
      {
        P_EFTransferTrans(ctrl, tsec, line, &amp;special-&gt;ef,
            PERCENT_2_FLOAT(special-&gt;translucency));
      }

      // update the line gaps &amp; things:
      P_RecomputeTilesInSector(tsec);
      P_RecomputeGapsAroundSector(tsec);

      // FIXME: tele-frag any things in the way

      P_FloodExtraFloors(tsec);

      texSwitch = true;
    }
  }

  // Tagged line effects
  if (line &amp;&amp; special-&gt;line_effect)
  {
    if (!tag)
    {
      P_LineEffect(line, line, special);
      texSwitch = true;
    }
    else
    {
      for (i=0; i &lt; numlines; i++)
      {
        if (lines[i].tag == tag)
        {
          P_LineEffect(lines + i, line, special);
          texSwitch = true;
        }
      }
    }
  }

  // Tagged sector effects
  if (line &amp;&amp; special-&gt;sector_effect &amp;&amp; tag &gt; 0)
  {
    for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
    {
      P_SectorEffect(tsec, line, special);
      texSwitch = true;
    }
  }

  if (special-&gt;trigger_effect &amp;&amp; tag &gt; 0)
  {
    RAD_EnableByTag(thing, tag, special-&gt;trigger_effect &lt; 0);
    texSwitch = true;
  }

  if (special-&gt;ambient_sfx &amp;&amp; tag &gt; 0)
  {
    for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
    {
      sectorsfx_t *sfx = NewSectorSFX();

      sfx-&gt;count = SECSFX_TIME;
      sfx-&gt;sector = tsec;
      sfx-&gt;sfx = special-&gt;ambient_sfx;
      sfx-&gt;sfxstarted = false;

      texSwitch = true;
    }
  }

  if (special-&gt;music)
  {
    S_ChangeMusic(special-&gt;music, true);
    texSwitch = true;
  }

  if (special-&gt;activate_sfx)
  {
    if (line)
      S_StartSound((mobj_t *) &amp;line-&gt;frontsector-&gt;soundorg, 
          special-&gt;activate_sfx);
    else if (thing)
      S_StartSound(thing, special-&gt;activate_sfx);
    
    playedSound = true;
  }

  if (special-&gt;s.type != SLIDE_None &amp;&amp; line)
  {
    EV_DoSlider(line, thing, &amp;special-&gt;s);
    
    // Note: sliders need special treatment
    return true;
  }

  // reduce count &amp; clear special if necessary
  if (line &amp;&amp; texSwitch)
  {
    if (line-&gt;count != -1)
    {
      line-&gt;count--;

      if (!line-&gt;count)
        line-&gt;special = NULL;
    }
    // -KM- 1998/09/27 Reversable linedefs.
    if (line-&gt;special &amp;&amp; special-&gt;newtrignum)
      line-&gt;special = (special-&gt;newtrignum &lt;= 0) ? NULL :
        DDF_LineLookupNum(special-&gt;newtrignum);

    P_ChangeSwitchTexture(line, line-&gt;special &amp;&amp; (special-&gt;newtrignum == 0),
        special-&gt;special_flags, playedSound);
  }

  return true;
}
</t>
<t tx="T2058">@ P_CrossSpecialLine - TRIGGER

Called every time a thing origin is about
to cross a line with a non 0 special.

-KM- 1998/09/01 Now much simpler
-ACB- 1998/09/12 Return success/failure
@c

boolean_t P_CrossSpecialLine(line_t *ld, int side, mobj_t * thing)
{
  return P_ActivateSpecialLine(ld, ld-&gt;special, ld-&gt;tag, 
      side, thing, line_walkable, 1, 0);
}
</t>
<t tx="T2059">@ P_ShootSpecialLine - IMPACT SPECIALS

Called when a thing shoots a special line.
@c

void P_ShootSpecialLine(line_t * ld, int side, mobj_t * thing)
{
  P_ActivateSpecialLine(ld, ld-&gt;special, ld-&gt;tag, 
      side, thing, line_shootable, 1, 0);
}
</t>
<t tx="T2060">@ P_UseSpecialLine

Called when a thing uses a special line.
Only the front sides of lines are usable.

-KM- 1998/09/01 Uses new lines.ddf code in p_spec.c

-ACB- 1998/09/07 Uses the return value to discern if a move if possible.

-AJA- 1999/12/07: New parameters `open_bottom' and `open_top',
which give a vertical range through which the linedef is
accessible. Could be used for smarter switches, like one on
a lower wall-part which is out of reach (e.g. MAP02).
@c

boolean_t P_UseSpecialLine(mobj_t * thing, line_t * line, int side,
    float_t open_bottom, float_t open_top)
{
  int can_reach = (thing-&gt;z &lt; open_top) &amp;&amp;
      (thing-&gt;z + thing-&gt;height + USE_Z_RANGE &gt;= open_bottom);

  return P_ActivateSpecialLine(line, line-&gt;special, line-&gt;tag, side,
      thing, line_pushable, can_reach, 0);
}
</t>
<t tx="T2061">@ P_RemoteActivation

Called by the RTS `ACTIVATE_LINETYPE' primitive, and also the code
pointer in things.ddf of the same name. Thing can be NULL.

-AJA- 1999/10/21: written.
@c

void P_RemoteActivation(mobj_t * thing, int typenum, int tag, 
    int side, trigger_e method)
{
  const linedeftype_t *spec = DDF_LineLookupNum(typenum);

  P_ActivateSpecialLine(NULL, spec, tag, side, thing, method, 1,
      (thing == NULL));
}
</t>
<t tx="T2062">

static INLINE void PlayerInProperties(player_t *player,
    float_t bz, float_t tz, float_t f_h, float_t c_h,
    region_properties_t *props)
{
  const specialsector_t *special = props-&gt;special;
  float_t damage, factor;

  if (!special || c_h &lt; f_h)
    return;

  if (!G_CheckWhenAppear(special-&gt;appear))
  {
    props-&gt;special = NULL;
    return;
  }

  // breathing support
  // (Mouth is where the eye is !)
  //
  if ((special-&gt;special_flags &amp; SECSP_AirLess) &amp;&amp;
      player-&gt;viewz &gt;= f_h &amp;&amp; player-&gt;viewz &lt;= c_h &amp;&amp;
      player-&gt;powers[PW_Scuba] &lt;= 0)
  {
    player-&gt;air_in_lungs--;
    player-&gt;underwater = true;

    if (player-&gt;air_in_lungs &lt;= 0 &amp;&amp;
        (leveltime % (1 + player-&gt;mo-&gt;info-&gt;choke_damage.delay)) == 0)
    {
      DAMAGE_COMPUTE(damage, &amp;player-&gt;mo-&gt;info-&gt;choke_damage);

      if (damage)
        P_DamageMobj(player-&gt;mo, NULL, NULL, damage,
            &amp;player-&gt;mo-&gt;info-&gt;choke_damage);
    }
  }

  if ((special-&gt;special_flags &amp; SECSP_Swimming) &amp;&amp;
      player-&gt;viewz &gt;= f_h &amp;&amp; player-&gt;viewz &lt;= c_h)
  {
    player-&gt;swimming = true;
  }

  factor = 1.0;

  if (special-&gt;special_flags &amp; SECSP_WholeRegion)
  {
    if (special-&gt;special_flags &amp; SECSP_Proportional)
    {
      // only partially in region -- mitigate damage

      if (tz &gt; c_h)
        factor -= factor * (tz - c_h) / (tz-bz);
    
      if (bz &lt; f_h)
        factor -= factor * (f_h - bz) / (tz-bz);
    }
    else
    {
      if (bz &gt; c_h || tz &lt; f_h)
        factor = 0;
    }
  }
  else
  {

    // Not touching the floor ?
    if (player-&gt;mo-&gt;z &gt; f_h + 2.0)
      return;
  }

  if (player-&gt;powers[PW_AcidSuit])
    factor = 0;
  
  if (factor &gt; 0 &amp;&amp;
      (leveltime % (1 + special-&gt;damage.delay)) == 0)
  {
    DAMAGE_COMPUTE(damage, &amp;special-&gt;damage);

    if (damage)
      P_DamageMobj(player-&gt;mo, NULL, NULL, damage * factor,
          &amp;special-&gt;damage);
  }

  if (special-&gt;secret)
  {
    player-&gt;secretcount++;
    props-&gt;special = NULL;
  }

  if (special-&gt;e_exit == EXIT_Normal)
  {
    player-&gt;cheats &amp;= ~CF_GODMODE;
    if (player-&gt;health &lt;= special-&gt;damage.nominal)
    {
      S_StartSound(player-&gt;mo, player-&gt;mo-&gt;info-&gt;deathsound);
      
      // -KM- 1998/12/16 We don't want to alter the special type,
      //   modify the sector's attributes instead.
      props-&gt;special = NULL;
      G_ExitLevel(1);
      return;
    }
  }
  else if (special-&gt;e_exit == EXIT_Secret)
  {
    player-&gt;cheats &amp;= ~CF_GODMODE;
    if (player-&gt;health &lt;= special-&gt;damage.nominal)
    {
      S_StartSound(player-&gt;mo, player-&gt;mo-&gt;info-&gt;deathsound);

      props-&gt;special = NULL;
      G_SecretExitLevel(1);
      return;
    }
  }
}
</t>
<t tx="T2063">@ P_PlayerInSpecialSector

Called every tic frame that the player origin is in a special sector

-KM- 1998/09/27 Generalised for sectors.ddf
-AJA- 1999/10/09: Updated for new sector handling.
@c

void P_PlayerInSpecialSector(player_t * player, sector_t * sec)
{
  extrafloor_t *S, *L, *C;
  float_t floor_h;

  float_t bz = player-&gt;mo-&gt;z;
  float_t tz = player-&gt;mo-&gt;z + player-&gt;mo-&gt;height;

  boolean_t was_underwater = player-&gt;underwater;

  player-&gt;swimming = false;
  player-&gt;underwater = false;

  // traverse extrafloor list
  floor_h = sec-&gt;f_h;

  S = sec-&gt;bottom_ef;
  L = sec-&gt;bottom_liq;

  while (S || L)
  {
    if (!L || (S &amp;&amp; S-&gt;bottom_h &lt; L-&gt;bottom_h))
    {
      C = S;  S = S-&gt;higher;
    }
    else
    {
      C = L;  L = L-&gt;higher;
    }

    DEV_ASSERT2(C);

    // ignore "hidden" liquids
    if (C-&gt;bottom_h &lt; floor_h || C-&gt;bottom_h &gt; sec-&gt;c_h)
      continue;
    
    PlayerInProperties(player, bz, tz, floor_h, C-&gt;top_h, C-&gt;p);

    floor_h = C-&gt;top_h;
  }

  PlayerInProperties(player, bz, tz, floor_h, sec-&gt;c_h, sec-&gt;p);

  // breathing support: handle gasping when leaving the water
  if (was_underwater &amp;&amp; !player-&gt;underwater)
  {
    if (player-&gt;air_in_lungs &lt;=
        (player-&gt;mo-&gt;info-&gt;lung_capacity - player-&gt;mo-&gt;info-&gt;gasp_start))
    {
      if (player-&gt;mo-&gt;info-&gt;gasp_sound)
        S_StartSound(player-&gt;mo, player-&gt;mo-&gt;info-&gt;gasp_sound);
    }

    player-&gt;air_in_lungs = player-&gt;mo-&gt;info-&gt;lung_capacity;
  } 
}
</t>
<t tx="T2064">@ P_UpdateSpecials

Animate planes, scroll walls, etc.
@c

void P_UpdateSpecials(void)
{
  int i;
  line_t *line;
  sector_t *sec;
  const linedeftype_t *special;

  // LEVEL TIMER
  if (levelTimer == true)
  {
    levelTimeCount--;

    if (!levelTimeCount)
      G_ExitLevel(1);
  }

  // ANIMATE FLATS AND TEXTURES GLOBALLY

  W_UpdateImageAnims();

  // ANIMATE LINE SPECIALS
  // -KM- 1998/09/01 Lines.ddf
  for (line = line_speciallist; line; line = line-&gt;animate_next)
  {
    special = line-&gt;special;

    // -KM- 1999/01/31 Use new method.
    // -AJA- 1999/07/01: Handle both sidedefs.
    if (line-&gt;side[0])
    {
      Vec2Add(line-&gt;side[0]-&gt;top.offset,    line-&gt;side[0]-&gt;top.scroll);
      Vec2Add(line-&gt;side[0]-&gt;middle.offset, line-&gt;side[0]-&gt;middle.scroll);
      Vec2Add(line-&gt;side[0]-&gt;bottom.offset, line-&gt;side[0]-&gt;bottom.scroll);
    }

    if (line-&gt;side[1])
    {
      Vec2Add(line-&gt;side[1]-&gt;top.offset,    line-&gt;side[1]-&gt;top.scroll);
      Vec2Add(line-&gt;side[1]-&gt;middle.offset, line-&gt;side[1]-&gt;middle.scroll);
      Vec2Add(line-&gt;side[1]-&gt;bottom.offset, line-&gt;side[1]-&gt;bottom.scroll);
    }
  }

  // ANIMATE SECTOR SPECIALS
  for (sec = sect_speciallist; sec; sec = sec-&gt;animate_next)
  {
    Vec2Add(sec-&gt;floor.offset, sec-&gt;floor.scroll);
    Vec2Add(sec-&gt;ceil.offset,  sec-&gt;ceil.scroll);
  }

  // DO BUTTONS
  for (i = 0; i &lt; maxbuttons; i++)
  {
    if (buttonlist[i].btimer == 0)
      continue;

    buttonlist[i].btimer--;

    if (buttonlist[i].btimer != 0)
      continue;

    switch (buttonlist[i].where)
    {
      case BWH_Top:
        buttonlist[i].line-&gt;side[0]-&gt;top.image = buttonlist[i].bimage;
        break;

      case BWH_Middle:
        buttonlist[i].line-&gt;side[0]-&gt;middle.image = buttonlist[i].bimage;
        break;

      case BWH_Bottom:
        buttonlist[i].line-&gt;side[0]-&gt;bottom.image = buttonlist[i].bimage;
        break;

      case BWH_None:
        I_Error("INTERNAL ERROR: bwhere is BWH_None !\n");
    }

    if (buttonlist[i].off_sound)
      S_StartSound((mobj_t *) &amp;buttonlist[i].line-&gt;frontsector-&gt;soundorg,
        buttonlist[i].off_sound);

    Z_Clear(&amp;buttonlist[i], button_t, 1);
  }
}
</t>
<t tx="T2065">@ SPECIAL SPAWNING


P_SpawnSpecials

This function is called at the start of every level. It parses command line
parameters for level timer, spawns passive special sectors, (ie sectors that
act even when a player is not in them, and counts total secrets) spawns
passive lines, (ie scrollers) and resets floor/ceiling movement.

-KM- 1998/09/27 Generalised for sectors.ddf
-KM- 1998/11/25 Lines with auto tag are automatically triggered.
@c

void P_SpawnSpecials(int autotag)
{
  sector_t *sector;
  const specialsector_t *secSpecial;
  const linedeftype_t *special;
  const char *s;

  int i;

  // See if -TIMER needs to be used.
  levelTimer = false;

  i = M_CheckParm("-avg");
  if (i &amp;&amp; deathmatch)
  {
    levelTimer = true;
    levelTimeCount = 20 * 60 * TICRATE;
  }

  s = M_GetParm("-timer");
  if (s &amp;&amp; deathmatch)
  {
    int time;

    time = atoi(s) * 60 * TICRATE;
    levelTimer = true;
    levelTimeCount = time;
  }

  for (i = 0; i &lt; maxbuttons; i++)
    Z_Clear(&amp;buttonlist[i], button_t, 1);

  sp_new_floors = Z_ClearNew(const image_t *, numsectors);

  //
  // Init special SECTORs.
  //
  sect_speciallist = NULL;

  sector = sectors;
  for (i = 0; i &lt; numsectors; i++, sector++)
  {
    if (!sector-&gt;props.special)
      continue;

    secSpecial = sector-&gt;props.special;

    if (! G_CheckWhenAppear(secSpecial-&gt;appear))
    {
      sector-&gt;props.special = NULL;
      continue;
    }

    if (secSpecial-&gt;l.type != LITE_None)
      EV_Lights(sector, &amp;secSpecial-&gt;l);

    if (secSpecial-&gt;secret)
      totalsecret++;

    if (secSpecial-&gt;use_colourmap)
      sector-&gt;props.colourmap = secSpecial-&gt;use_colourmap;

    if (secSpecial-&gt;ambient_sfx)
    {
      sectorsfx_t *sfx = NewSectorSFX();

      sfx-&gt;count = SECSFX_TIME;
      sfx-&gt;sector = sector;
      sfx-&gt;sfx = secSpecial-&gt;ambient_sfx;
      sfx-&gt;sfxstarted = false;
    }

    // - Plats/Floors -
    if (secSpecial-&gt;f.type != mov_undefined)
      EV_DoPlane(sector, &amp;secSpecial-&gt;f, sector);

    // - Doors/Ceilings -
    if (secSpecial-&gt;c.type != mov_undefined)
      EV_DoPlane(sector, &amp;secSpecial-&gt;c, sector);

    sector-&gt;props.gravity   = secSpecial-&gt;gravity;
    sector-&gt;props.friction  = secSpecial-&gt;friction;
    sector-&gt;props.viscosity = secSpecial-&gt;viscosity;
    sector-&gt;props.drag      = secSpecial-&gt;drag;

    // compute pushing force
    if (secSpecial-&gt;push_speed &gt; 0 || secSpecial-&gt;push_zspeed &gt; 0)
    {
      float_t mul = secSpecial-&gt;push_speed / 100.0;

      sector-&gt;props.push.x += M_Cos(secSpecial-&gt;push_angle) * mul;
      sector-&gt;props.push.y += M_Sin(secSpecial-&gt;push_angle) * mul;
      sector-&gt;props.push.z += secSpecial-&gt;push_zspeed / 100.0;
    }

    // Scrollers
    if (secSpecial-&gt;f.scroll_speed &gt; 0)
    {
      float_t dx = M_Cos(secSpecial-&gt;f.scroll_angle);
      float_t dy = M_Sin(secSpecial-&gt;f.scroll_angle);
        
      sector-&gt;floor.scroll.x -= dx * secSpecial-&gt;f.scroll_speed / 32.0;
      sector-&gt;floor.scroll.y -= dy * secSpecial-&gt;f.scroll_speed / 32.0;
  
      P_AddSpecialSector(sector);
    }
    if (secSpecial-&gt;c.scroll_speed &gt; 0)
    {
      float_t dx = M_Cos(secSpecial-&gt;c.scroll_angle);
      float_t dy = M_Sin(secSpecial-&gt;c.scroll_angle);
      
      sector-&gt;ceil.scroll.x -= dx * secSpecial-&gt;c.scroll_speed / 32.0;
      sector-&gt;ceil.scroll.y -= dy * secSpecial-&gt;c.scroll_speed / 32.0;

      P_AddSpecialSector(sector);
    }
  }

  //
  // Init special LINEs.
  //
  // -ACB- &amp; -JC- 1998/06/10 Implemented additional scroll effects
  //
  // -ACB- Added the code
  // -JC-  Designed and contributed code
  // -KM-  Removed Limit
  // -KM- 1998/09/01 Added lines.ddf support
  //
  line_speciallist = NULL;

  for (i = 0; i &lt; numlines; i++)
  {
    special = lines[i].special;

    if (! special)
    {
      lines[i].count = 0;
      continue;
    }

    // -AJA- 1999/10/23: weed out non-appearing lines.
    if (! G_CheckWhenAppear(special-&gt;appear))
    {
      lines[i].special = NULL;
      continue;
    }

    lines[i].count = special-&gt;count;

    if (special-&gt;s_xspeed || special-&gt;s_yspeed)
    {
      AdjustScrollParts(lines[i].side[0], 0, special-&gt;scroll_parts,
          special-&gt;s_xspeed, special-&gt;s_yspeed);

      AdjustScrollParts(lines[i].side[1], 1, special-&gt;scroll_parts,
          special-&gt;s_xspeed, special-&gt;s_yspeed);

      P_AddSpecialLine(lines + i);
    }

    // -AJA- 1999/06/30: Translucency effect.
    if (PERCENT_2_FLOAT(special-&gt;translucency) &lt;= 0.99 &amp;&amp; lines[i].side[0])
      lines[i].side[0]-&gt;middle.translucency = PERCENT_2_FLOAT(special-&gt;translucency);

    if (PERCENT_2_FLOAT(special-&gt;translucency) &lt;= 0.99 &amp;&amp; lines[i].side[1])
      lines[i].side[1]-&gt;middle.translucency = PERCENT_2_FLOAT(special-&gt;translucency);

    // -AJA- 2001/01/23: Tiling sky support.
    if (special-&gt;sky.type != TILESKY_None)
    {
      R2_TileSkyAdd(&amp;special-&gt;sky, lines + i);
    }

    if (special-&gt;autoline)
    {
      P_ActivateSpecialLine(&amp;lines[i], lines[i].special,
        lines[i].tag, 0, NULL, line_Any, 1, 1);
    }

    // -KM- 1998/11/25 This line should be pushed automatically
    if (autotag &amp;&amp; lines[i].special &amp;&amp; lines[i].tag == autotag)
    {
      P_ActivateSpecialLine(&amp;lines[i], lines[i].special,
        lines[i].tag, 0, NULL, line_pushable, 1, 1);
    }
  }

  for (i=0; i &lt; numsectors; i++)
  {
    if (sp_new_floors[i])
      sectors[i].floor.image = sp_new_floors[i];
  }

  Z_Free(sp_new_floors);
  sp_new_floors = NULL;
}
</t>
<t tx="T2066">@ P_DoSectorsFromTag

-KM- 1998/09/27 This helper function is used to do stuff to all the
sectors with the specified line's tag.

-AJA- 1999/09/29: Updated for new tagged sector links.
@c

static boolean_t P_DoSectorsFromTag(int tag, const void *p1, void *p2,
    boolean_t(*func) (sector_t *, const void *, void *))
{
  sector_t *tsec;
  boolean_t rtn = false;

  for (tsec = P_FindSectorFromTag(tag); tsec; tsec = tsec-&gt;tag_next)
  {
    if ((*func) (tsec, p1, p2))
      rtn = true;
  }

  return rtn;
}
</t>
<t tx="T2067">@ignore
@language c

// Thinker &amp; Ticker Code

// -ACB- 1998/09/14 Removed P_AllocateThinker: UNUSED
//
// -AJA- 1999/11/06: Changed from ring (thinkercap) to list.
//
// -ES- 2000/02/14: Removed thinker system.

&lt;&lt; p_tick #includes &gt;&gt;
&lt;&lt; p_tick declarations &gt;&gt;
@others
</t>
<t tx="T2068">#include "i_defs.h"
#include "p_tick.h"

#include "dm_state.h"
#include "p_local.h"
#include "z_zone.h"
</t>
<t tx="T2069">
int leveltime;
</t>
<t tx="T2070">@ P_Ticker
@c

void P_Ticker(void)
{
  player_t *p;

  if (paused)
    return;

  // pause if in menu and at least one tic has been run
  if (!netgame &amp;&amp; menuactive &amp;&amp; !demoplayback &amp;&amp; 
      consoleplayer-&gt;viewz != M_PI)
  {
    return;
  }

  for (p = players; p; p = p-&gt;next)
    P_PlayerThink(p);

  P_RunMobjThinkers();
  P_RunLights();
  P_RunActiveSectors();
  P_RunSectorSFX();
  P_UpdateSpecials();
  P_MobjItemRespawn();

  // for par times
  leveltime++;
}
</t>
<t tx="T2071">@ignore
@language c

// Switch Handling Code

&lt;&lt; p_switch #includes &gt;&gt;
&lt;&lt; p_switch declarations &gt;&gt;
@others

#undef CHECK_SW
#undef SET_SW
#undef OLD_SW

</t>
<t tx="T2072">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "ddf_main.h"
#include "g_game.h"
#include "p_local.h"
#include "r_state.h"
#include "s_sound.h"
#include "w_textur.h"
#include "z_zone.h"
</t>
<t tx="T2073">
//
// CHANGE THE TEXTURE OF A WALL SWITCH TO ITS OPPOSITE
//
// -KM- 98/07/31 Move to DDF

int maxbuttons = 0;
button_t *buttonlist = NULL;
</t>
<t tx="T2074">@ P_InitSwitchList

Only called at game initialization.
@c

boolean_t P_InitSwitchList(void)
{
  int i;

  for (i=0; i &lt; num_alph_switches; i++)
  {
    switchlist_t *sw = alph_switches[i];

    // -AJA- FIXME: allow NULL textures, to prevent spurious warning
    //       when using DOOM 1.
    sw-&gt;cache.image[0] = W_ImageFromTexture(sw-&gt;name1);
    sw-&gt;cache.image[1] = W_ImageFromTexture(sw-&gt;name2);
  }

  return true;
}
</t>
<t tx="T2075">
boolean_t P_ButtonCheckPressed(line_t * line)
{
  int i;

  for (i = 0; i &lt; maxbuttons; i++)
  {
    if (buttonlist[i].btimer &amp;&amp; buttonlist[i].line == line)
      return true;
  }

  return false;
}
</t>
<t tx="T2076">@ Start a button counting down till it turns off.
@c

static void StartButton(switchlist_t *sw, line_t *line, bwhere_e w,
    const image_t *image)
{
  int index;

  // See if button is already pressed
  if (P_ButtonCheckPressed(line))
    return;

  for (index = 0; index &lt; maxbuttons; index++)
  {
    if (!buttonlist[index].btimer)
      break;
  }

  if (index == maxbuttons)
  {
    // grow the button list
    Z_Resize(buttonlist, button_t, ++maxbuttons);
  }

  DEV_ASSERT2(index &lt; maxbuttons);

  buttonlist[index].line = line;
  buttonlist[index].where = w;
  buttonlist[index].btimer = sw-&gt;time;
  buttonlist[index].off_sound = sw-&gt;off_sfx;
  buttonlist[index].bimage = image;
}
</t>
<t tx="T2077">@ Function that changes wall texture.
Tell it if switch is ok to use again.

-KM- 1998/09/01 All switches referencing a certain tag are switched
@c

void P_ChangeSwitchTexture(line_t * line, boolean_t useAgain,
    line_special_e specials, boolean_t noSound)
{
  int i, j, k;
  int tag = line-&gt;tag;
  const linedeftype_t *type = line-&gt;special;
  mobj_t *soundorg;
  side_t *side;
  bwhere_e pos;

  for (j=0; j &lt; numlines; j++)
  {
    if (line != &amp;lines[j])
    {
      if (tag == 0 || (lines[j].tag != tag) || 
          (specials &amp; LINSP_SwitchSeparate) ||
          (type != lines[j].special &amp;&amp; type &amp;&amp; 
           lines[j].special &amp;&amp; useAgain))
      {
        continue;
      }
    }

    side = lines[j].side[0];
    soundorg = (mobj_t *) &amp;lines[j].frontsector-&gt;soundorg;

    pos = BWH_None;

    for (i=0; (i &lt; num_alph_switches) &amp;&amp; (pos == BWH_None); i++)
    {
      switchlist_t *sw = alph_switches[i];

      if (!sw-&gt;cache.image[0] &amp;&amp; !sw-&gt;cache.image[1])
        continue;

      // some like it both ways...
      for (k=0; k &lt; 2; k++)
      {
#define CHECK_SW(PART)  (sw-&gt;cache.image[k] == side-&gt;PART.image)
#define SET_SW(PART)    side-&gt;PART.image = sw-&gt;cache.image[k^1] 
#define OLD_SW          sw-&gt;cache.image[k]

        if (CHECK_SW(top))
        {
          SET_SW(top);
          pos = BWH_Top;
          break;
        }
        else if (CHECK_SW(middle))
        {
          SET_SW(middle);
          pos = BWH_Middle;
          break;
        }
        else if (CHECK_SW(bottom))
        {
          SET_SW(bottom);
          pos = BWH_Bottom;
          break;
        }
      }   // k &lt; 2

      if (pos != BWH_None)
      {
        // -KM- 98/07/31 Implement sounds
        if (! noSound &amp;&amp; sw-&gt;on_sfx)
        {
          S_StartSound(soundorg, sw-&gt;on_sfx);
          noSound = true;
        }

        if (useAgain)
          StartButton(sw, &amp;lines[j], pos, OLD_SW);

        break;
      }
    }   // i &lt; num_alph_switches
  }   // j &lt; numlines
}
</t>
<t tx="T2078">@language c</t>
<t tx="T2079">@ignore
@language c

// Automap Functions

&lt;&lt; am_map #includes &gt;&gt;
&lt;&lt; am_map declarations &gt;&gt;
@others
</t>
<t tx="T2080">#include "i_defs.h"
#include "am_map.h"

#include "con_cvar.h"
#include "con_main.h"
#include "dm_defs.h"
#include "dm_state.h"
#include "dstrings.h"
#include "m_argv.h"
#include "m_bbox.h"
#include "m_cheat.h"
#include "m_misc.h"
#include "p_local.h"
#include "r_state.h"
#include "rgl_defs.h"
#include "st_stuff.h"
#include "v_ctx.h"
#include "v_res.h"
#include "v_colour.h"
#include "w_image.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T2081">
#define DEBUG_TRUEBSP  0

// Automap colours

#define BACK_COL    (BLACK)
#define YOUR_COL    (WHITE)
#define WALL_COL    (RED)
#define FLOOR_COL   (BROWN + BROWN_LEN/2)
#define CEIL_COL    (YELLOW)
#define REGION_COL  (BEIGE)
#define TELE_COL    (RED + RED_LEN/2)
#define SECRET_COL  (CYAN + CYAN_LEN/4)
#define GRID_COL    (GRAY + GRAY_LEN*3/4)
#define XHAIR_COL   (GRAY + GRAY_LEN/3)
#define ALLMAP_COL  (GRAY + GRAY_LEN/2)
#define MINI_COL    (BLUE + BLUE_LEN/2)

#define THING_COL   (BROWN + BROWN_LEN*2/3)
#define MONST_COL   (GREEN + 2)
#define DEAD_COL    (RED + 2)
#define MISSL_COL   (ORANGE)
#define ITEM_COL    (BLUE+1)

// Automap keys
// Ideally these would be configurable...

#define AM_PANDOWNKEY KEYD_DOWNARROW
#define AM_PANUPKEY   KEYD_UPARROW
#define AM_PANRIGHTKEY    KEYD_RIGHTARROW
#define AM_PANLEFTKEY     KEYD_LEFTARROW
#define AM_ZOOMINKEY  '='
#define AM_ZOOMOUTKEY '-'
#define AM_STARTKEY   key_map
#define AM_ENDKEY     key_map
#define AM_GOBIGKEY   '0'
#define AM_FOLLOWKEY  'f'
#define AM_GRIDKEY    'g'
#define AM_MARKKEY    'm'
#define AM_CLEARMARKKEY    'c'

#define AM_NUMMARKPOINTS 10

#define PLAYERRADIUS 16.0

//
// NOTE:
//   `F' in the names here means `Framebuffer', i.e. on-screen coords.
//   `M' in the names means `Map', i.e. coordinates in the level.
//

// scale on entry
#define INITSCALEMTOF (0.2)
// how much the automap moves window per tic in frame-buffer coordinates
// moves 140 pixels in 1 second
#define F_PANINC 4
// how much zoom-in per tic
// goes to 2x in 1 second
#define M_ZOOMIN (1.02)
// how much zoom-out per tic
// pulls out to 0.5x in 1 second
#define M_ZOOMOUT (1/M_ZOOMIN)

// translates between frame-buffer and map distances - moved down with rest of functions
#define FTOM(x) ((float_t)((x) * scale_ftom))
#define MTOF(x) ((int)((x) * scale_mtof))

// translates between frame-buffer and map coordinates
#define CXMTOF(x)  (f_x + MTOF((x) - m_x))
#define CYMTOF(y)  (f_y + f_h - MTOF((y) - m_y))

#define CXFTOM(x)  (m_x + FTOM((x) - f_x))
#define CYFTOM(y)  (m_y + FTOM(f_y + f_h - (y)))

//
// The vector graphics for the automap.
//
// A line drawing of the player pointing right, starting from the
// middle.

static mline_t player_arrow[] =
{
  {{-0.875, 0}, {1.0, 0}},   // -----
    
  {{1.0, 0}, {0.5,  0.25}},  // -----&gt;
  {{1.0, 0}, {0.5, -0.25}},
     
  {{-0.875, 0}, {-1.125,  0.25}},  // &gt;----&gt;
  {{-0.875, 0}, {-1.125, -0.25}},
     
  {{-0.625, 0}, {-0.875,  0.25}},  // &gt;&gt;---&gt;
  {{-0.625, 0}, {-0.875, -0.25}}
};

#define NUMPLYRLINES (sizeof(player_arrow)/sizeof(mline_t))

static mline_t cheat_player_arrow[] =
{
  {{-0.875, 0}, {1.0, 0}},    // -----
  
  {{1.0, 0}, {0.5,  0.167}},  // -----&gt;
  {{1.0, 0}, {0.5, -0.167}},
  
  {{-0.875, 0}, {-1.125,  0.167}},  // &gt;-----&gt;
  {{-0.875, 0}, {-1.125, -0.167}},
  
  {{-0.625, 0}, {-0.875,  0.167}},  // &gt;&gt;-----&gt;
  {{-0.625, 0}, {-0.875, -0.167}},
  
  {{-0.5, 0}, {-0.5, -0.167}},      // &gt;&gt;-d---&gt;
  {{-0.5, -0.167}, {-0.5 + 0.167, -0.167}},
  {{-0.5 + 0.167, -0.167}, {-0.5 + 0.167, 0.25}},
  
  {{-0.167, 0}, {-0.167, -0.167}},  // &gt;&gt;-dd--&gt;
  {{-0.167, -0.167}, {0, -0.167}},
  {{0, -0.167}, {0, 0.25}},

  {{0.167, 0.25}, {0.167, -0.143}},  // &gt;&gt;-ddt-&gt;
  {{0.167, -0.143}, {0.167 + 0.031, -0.143 - 0.031}},
  {{0.167 + 0.031, -0.143 - 0.031}, {0.167 + 0.1, -0.143}}
};

#define NUMCHEATPLYRLINES (sizeof(cheat_player_arrow)/sizeof(mline_t))

#if 0
// -ES- 1999/10/16 Cos(60) and Sin(60)
#define C (0.5)
#define S (0.8660254038)

static mline_t triangle_guy[] =
{
  {{-S, -C}, {S, -C}},
  {{S, -C}, {0, 1.0}},
  {{0, 1.0}, {-S, -C}}
};

#undef C
#undef S
#define NUMTRIANGLEGUYLINES (sizeof(triangle_guy)/sizeof(mline_t))
#endif

static mline_t thintriangle_guy[] =
{
  {{-0.5, -0.7}, {1.0, 0}},
  {{1.0, 0}, {-0.5, 0.7}},
  {{-0.5, 0.7}, {-0.5, -0.7}}
};

#define NUMTHINTRIANGLEGUYLINES (sizeof(thintriangle_guy)/sizeof(mline_t))

static int cheating = 0;
static int grid = 0;

static int leveljuststarted = 1;  // kludge until LevelInit() is called

int automapactive = 0;
static int finit_width;
static int finit_height;

// location and size of window on screen
static int f_x, f_y;
static int f_w, f_h;

static mpoint_t m_paninc;  // how far the window pans each tic (map coords)

static float_t mtof_zoommul;  // how far the window zooms in each tic (map coords)
static float_t ftom_zoommul;  // how far the window zooms in each tic (fb coords)

static float_t m_x, m_y;  // LL x,y where the window is on the map (map coords)
static float_t m_x2, m_y2;  // UR x,y where the window is on the map (map coords)

//
// width/height of window on map (map coords)
//
static float_t m_w;
static float_t m_h;

// based on level size
static float_t min_x;
static float_t min_y;
static float_t max_x;
static float_t max_y;

static float_t max_w;  // max_x-min_x,
static float_t max_h;  // max_y-min_y

// based on player size
static float_t min_w;
static float_t min_h;

static float_t min_scale_mtof;  // used to tell when to stop zooming out
static float_t max_scale_mtof;  // used to tell when to stop zooming in

// old stuff for recovery later
static float_t old_m_w, old_m_h;
static float_t old_m_x, old_m_y;

// old location used by the Follower routine
static mpoint_t f_oldloc;

// used by MTOF to scale from map-to-frame-buffer coords
static float_t scale_mtof = INITSCALEMTOF;

// used by FTOM to scale from frame-buffer-to-map coords (=1/scale_mtof)
static float_t scale_ftom;

// numbers used for marking by the automap
static const image_t *marknums[10];

// where the points are
static mpoint_t markpoints[AM_NUMMARKPOINTS];

// next point to be assigned
static int markpointnum = 0;

// specifies whether to follow the player around
static int followplayer = 1;

cheatseq_t cheat_amap = {0, 0};

static boolean_t stopped = true;

boolean_t newhud = false;

// current am colourmap
static const byte *am_colmap = NULL;
</t>
<t tx="T2082">static void ActivateNewScale(void)
{
  m_x += m_w / 2;
  m_y += m_h / 2;
  m_w = FTOM(f_w);
  m_h = FTOM(f_h);
  m_x -= m_w / 2;
  m_y -= m_h / 2;
  m_x2 = m_x + m_w;
  m_y2 = m_y + m_h;
}
</t>
<t tx="T2083">static void SaveScaleAndLoc(void)
{
  old_m_x = m_x;
  old_m_y = m_y;
  old_m_w = m_w;
  old_m_h = m_h;
}
</t>
<t tx="T2084">static void RestoreScaleAndLoc(void)
{
  m_w = old_m_w;
  m_h = old_m_h;

  if (!followplayer)
  {
    m_x = old_m_x;
    m_y = old_m_y;
  }
  else
  {
    m_x = consoleplayer-&gt;mo-&gt;x - m_w / 2;
    m_y = consoleplayer-&gt;mo-&gt;y - m_h / 2;
  }
  m_x2 = m_x + m_w;
  m_y2 = m_y + m_h;

  // Change the scaling multipliers
  scale_mtof = (float_t)f_w / m_w;
  scale_ftom = 1 / scale_mtof;
}
</t>
<t tx="T2085">@ adds a marker at the current location
@c

static void AddMark(void)
{
  markpoints[markpointnum].x = m_x + m_w / 2;
  markpoints[markpointnum].y = m_y + m_h / 2;
  markpointnum = (markpointnum + 1) % AM_NUMMARKPOINTS;
}
</t>
<t tx="T2086">@ Determines bounding box of all vertices,
sets global variables controlling zoom range.
@c

static void FindMinMaxBoundaries(void)
{
  int i;
  float_t a;
  float_t b;

  min_x = min_y = INT_MAX;
  max_x = max_y = INT_MIN;

  for (i = 0; i &lt; numvertexes; i++)
  {
    if (vertexes[i].x &lt; min_x)
      min_x = vertexes[i].x;
    else if (vertexes[i].x &gt; max_x)
      max_x = vertexes[i].x;

    if (vertexes[i].y &lt; min_y)
      min_y = vertexes[i].y;
    else if (vertexes[i].y &gt; max_y)
      max_y = vertexes[i].y;
  }

  max_w = max_x - min_x;
  max_h = max_y - min_y;

  min_w = 2 * PLAYERRADIUS;  // const? never changed?

  min_h = 2 * PLAYERRADIUS;

  a = (float_t)f_w / max_w;
  b = (float_t)f_h / max_h;

  min_scale_mtof = a &lt; b ? a : b;
  max_scale_mtof = (float_t)f_h / (2 * PLAYERRADIUS);
}
</t>
<t tx="T2087">static void ChangeWindowLoc(void)
{
  if (m_paninc.x != 0 || m_paninc.y != 0)
  {
    followplayer = 0;
    f_oldloc.x = INT_MAX;
  }

  m_x += m_paninc.x;
  m_y += m_paninc.y;

  if (m_x + m_w / 2 &gt; max_x)
    m_x = max_x - m_w / 2;
  else if (m_x + m_w / 2 &lt; min_x)
    m_x = min_x - m_w / 2;

  if (m_y + m_h / 2 &gt; max_y)
    m_y = max_y - m_h / 2;
  else if (m_y + m_h / 2 &lt; min_y)
    m_y = min_y - m_h / 2;

  m_x2 = m_x + m_w;
  m_y2 = m_y + m_h;
}
</t>
<t tx="T2088">static void InitVariables(void)
{
  DEV_ASSERT2(consoleplayer);

  if (newhud == true)
    automapactive = 1;
  else
    automapactive = 2;

  f_oldloc.x = INT_MAX;

  m_paninc.x = m_paninc.y = 0;
  ftom_zoommul = 1.0;
  mtof_zoommul = 1.0;

  m_w = FTOM(f_w);
  m_h = FTOM(f_h);

  m_x = consoleplayer-&gt;mo-&gt;x - m_w / 2;
  m_y = consoleplayer-&gt;mo-&gt;y - m_h / 2;

  ChangeWindowLoc();

  // for saving &amp; restoring
  old_m_x = m_x;
  old_m_y = m_y;
  old_m_w = m_w;
  old_m_h = m_h;

  // inform the status bar of the change
  stbar_update = true;
}
</t>
<t tx="T2089">static void LoadPics(void)
{
  int i;
  char namebuf[9];

  for (i = 0; i &lt; 10; i++)
  {
    sprintf(namebuf, "AMMNUM%d", i);
    marknums[i] = W_ImageFromPatch(namebuf);
  }
}
</t>
<t tx="T2090">static void ClearMarks(void)
{
  int i;

  for (i = 0; i &lt; AM_NUMMARKPOINTS; i++)
    markpoints[i].x = -1;  // means empty

  markpointnum = 0;
}
</t>
<t tx="T2091">@ should be called at the start of every level
right now, i figure it out myself
@c

static void LevelInit(void)
{
  if (!cheat_amap.sequence)
    cheat_amap.sequence = DDF_LanguageLookup("iddt");

  leveljuststarted = 0;

  f_x = f_y = 0;
  f_w = finit_width;
  f_h = finit_height;

  ClearMarks();

  FindMinMaxBoundaries();

  scale_mtof = min_scale_mtof * (10.0/7);

  if (scale_mtof &gt; max_scale_mtof)
    scale_mtof = min_scale_mtof;

  scale_ftom = 1 / scale_mtof;
}
</t>
<t tx="T2092">void AM_Stop(void)
{
  automapactive = 0;
  stopped = true;
}
</t>
<t tx="T2093">static void StartAM(void)
{
  // static int lastlevel = -1, lastepisode = -1;

  if (!stopped)
    AM_Stop();

  LevelInit();

  InitVariables();
  LoadPics();

  stopped = false;
}
</t>
<t tx="T2094">void AM_InitResolution(void)
{
  finit_width  = SCREENWIDTH;
  finit_height = SCREENHEIGHT - FROM_200(ST_HEIGHT);

  LevelInit();  // -ES- 1998/08/20

  CON_CreateCVarBool("newhud", cf_normal, &amp;newhud);

  if (M_CheckParm("-newmap"))
    newhud = true;
}
</t>
<t tx="T2095">@ Hides the map.
@c

static void AM_Hide(void)
{
  automapactive = 0;
  viewactive = true;
}
</t>
<t tx="T2096">static void AM_Show(void)
{
  if (stopped)
    StartAM();

  if (newhud == true)
    automapactive = 1;
  else
    automapactive = 2;

  viewactive = false;
}
</t>
<t tx="T2097">@ set the window scale to the maximum size
@c

static void MinOutWindowScale(void)
{
  scale_mtof = min_scale_mtof;
  scale_ftom = 1 / scale_mtof;
  ActivateNewScale();
}
</t>
<t tx="T2098">@ set the window scale to the minimum size
@c

static void MaxOutWindowScale(void)
{
  scale_mtof = max_scale_mtof;
  scale_ftom = 1 / scale_mtof;
  ActivateNewScale();
}
</t>
<t tx="T2099">@ Handle events (user inputs) in automap mode
@c

boolean_t AM_Responder(event_t * ev)
{
  int rc;
  static int bigstate = 0;

  rc = false;

  if (!automapactive)
  {
    if (ev-&gt;type == ev_keydown &amp;&amp; ((ev-&gt;value.key == (AM_STARTKEY &gt;&gt; 16)) || (ev-&gt;value.key == (AM_STARTKEY &amp; 0xffff))))
    {
      AM_Show();
      rc = true;
    }
  }
  else if (ev-&gt;type == ev_keydown)
  {

    rc = true;
    switch (ev-&gt;value.key)
    {
      case AM_PANRIGHTKEY:
        // pan right
        if (!followplayer)
          m_paninc.x = FTOM(F_PANINC);
        else
          rc = false;
        break;
        
      case AM_PANLEFTKEY:
        // pan left
        if (!followplayer)
          m_paninc.x = -FTOM(F_PANINC);
        else
          rc = false;
        break;
        
      case AM_PANUPKEY:
        // pan up
        if (!followplayer)
          m_paninc.y = FTOM(F_PANINC);
        else
          rc = false;
        break;
        
      case AM_PANDOWNKEY:
        // pan down
        if (!followplayer)
          m_paninc.y = -FTOM(F_PANINC);
        else
          rc = false;
        break;
        
      case AM_ZOOMOUTKEY:
        // zoom out
        mtof_zoommul = M_ZOOMOUT;
        ftom_zoommul = M_ZOOMIN;
        break;
        
      case AM_ZOOMINKEY:
        // zoom in
        mtof_zoommul = M_ZOOMIN;
        ftom_zoommul = M_ZOOMOUT;
        break;
        
      case AM_GOBIGKEY:
        bigstate = !bigstate;
        if (bigstate)
        {
          SaveScaleAndLoc();
          MinOutWindowScale();
        }
        else
          RestoreScaleAndLoc();
        break;
        
      case AM_FOLLOWKEY:
        followplayer = !followplayer;
        f_oldloc.x = INT_MAX;
        // -ACB- 1998/08/10 Use DDF Lang Reference
        if (followplayer)
          CON_PlayerMessageLDF(consoleplayer, "AutoMapFollowOn");
        else
          CON_PlayerMessageLDF(consoleplayer, "AutoMapFollowOff");
        break;
        
      case AM_GRIDKEY:
        grid = !grid;
        // -ACB- 1998/08/10 Use DDF Lang Reference
        if (grid)
          CON_PlayerMessageLDF(consoleplayer, "AutoMapGridOn");
        else
          CON_PlayerMessageLDF(consoleplayer, "AutoMapGridOff");
        break;
        
      case AM_MARKKEY:
        // -ACB- 1998/08/10 Use DDF Lang Reference
        CON_PlayerMessage(consoleplayer, "%s %d",
            DDF_LanguageLookup("AutoMapMarkedSpot"),
            markpointnum);
        AddMark();
        break;
        
      case AM_CLEARMARKKEY:
        ClearMarks();
        // -ACB- 1998/08/10 Use DDF Lang Reference
        CON_PlayerMessageLDF(consoleplayer, "AutoMapMarksClear");
        break;
        
      default:
        if (ev-&gt;value.key == (AM_ENDKEY &gt;&gt; 16) || 
            ev-&gt;value.key == (AM_ENDKEY &amp; 0xffff))
        {
          if (automapactive == 1)
          {
            stbar_update = true;
            automapactive = 2;
          }
          else
          {
            bigstate = 0;
            viewactive = true;
            AM_Hide();
          }
        }
        else
        {
          rc = false;
        }
    }
    // -ACB- 1999/09/28 Proper casting
    if (!deathmatch &amp;&amp; M_CheckCheat(&amp;cheat_amap, (char)ev-&gt;value.key))
    {
      rc = false;
      cheating = (cheating + 1) % 3;
    }
  }

  else if (ev-&gt;type == ev_keyup)
  {
    rc = false;
    switch (ev-&gt;value.key)
    {
      case AM_PANRIGHTKEY:
        if (!followplayer)
          m_paninc.x = 0;
        break;
        
      case AM_PANLEFTKEY:
        if (!followplayer)
          m_paninc.x = 0;
        break;
        
      case AM_PANUPKEY:
        if (!followplayer)
          m_paninc.y = 0;
        break;
        
      case AM_PANDOWNKEY:
        if (!followplayer)
          m_paninc.y = 0;
        break;

      case AM_ZOOMOUTKEY:
      case AM_ZOOMINKEY:
        mtof_zoommul = 1.0;
        ftom_zoommul = 1.0;
        break;
    }
  }

  return rc;

}
</t>
<t tx="T2100">@ Zooming
@c

static void ChangeWindowScale(void)
{
  // Change the scaling multipliers
  scale_mtof *= mtof_zoommul;
  scale_ftom = 1.0 / scale_mtof;

  if (scale_mtof &lt; min_scale_mtof)
    MinOutWindowScale();
  else if (scale_mtof &gt; max_scale_mtof)
    MaxOutWindowScale();
  else
    ActivateNewScale();
}
</t>
<t tx="T2101">static void DoFollowPlayer(void)
{
  if (f_oldloc.x != consoleplayer-&gt;mo-&gt;x || 
      f_oldloc.y != consoleplayer-&gt;mo-&gt;y)
  {
    m_x = FTOM(MTOF(consoleplayer-&gt;mo-&gt;x)) - m_w / 2;
    m_y = FTOM(MTOF(consoleplayer-&gt;mo-&gt;y)) - m_h / 2;
    m_x2 = m_x + m_w;
    m_y2 = m_y + m_h;
    f_oldloc.x = consoleplayer-&gt;mo-&gt;x;
    f_oldloc.y = consoleplayer-&gt;mo-&gt;y;
  }
}
</t>
<t tx="T2102">@ Updates on Game Tick
@c

void AM_Ticker(void)
{
  if (!automapactive)
    return;

  if (followplayer)
    DoFollowPlayer();

  // Change the zoom if necessary
  if (ftom_zoommul != 1.0)
    ChangeWindowScale();

  // Change x,y location
  if (m_paninc.x != 0 || m_paninc.y != 0)
    ChangeWindowLoc();
}
</t>
<t tx="T2103">@ Rotation in 2D.
Used to rotate player arrow line character.
@c

static INLINE void Rotate(float_t * x, float_t * y, angle_t a)
{
  float_t tmpx;

  tmpx = *x * M_Cos(a) - *y * M_Sin(a);

  *y = *x * M_Sin(a) + *y * M_Cos(a);

  *x = tmpx;
}
</t>
<t tx="T2104">static INLINE void GetRotatedCoords(float_t sx, float_t sy,
    float_t *dx, float_t *dy)
{
  *dx = sx;
  *dy = sy;

  if (rotatemap)
  {
    // rotate coordinates so they are on the map correctly
    *dx -= consoleplayer-&gt;mo-&gt;x;
    *dy -= consoleplayer-&gt;mo-&gt;y;
    
    Rotate(dx, dy, ANG90 - consoleplayer-&gt;mo-&gt;angle);
    
    *dx += consoleplayer-&gt;mo-&gt;x;
    *dy += consoleplayer-&gt;mo-&gt;y;
  }
}
</t>
<t tx="T2105">static INLINE angle_t GetRotatedAngle(angle_t src)
{
  if (rotatemap)
    return src + ANG90 - consoleplayer-&gt;mo-&gt;angle;

  return src;
}
</t>
<t tx="T2106">@ Draw visible parts of lines.
@c

static void DrawMline(mline_t * ml, int colour)
{
  int x1, y1, x2, y2;
  int f_x2 = f_x + f_w - 1;
  int f_y2 = f_y + f_h - 1;

  DEV_ASSERT2(am_colmap);
  DEV_ASSERT2(0 &lt;= colour &amp;&amp; colour &lt;= 255);

  // transform to frame-buffer coordinates.
  x1 = CXMTOF(ml-&gt;a.x);
  y1 = CYMTOF(ml-&gt;a.y);
  x2 = CXMTOF(ml-&gt;b.x);
  y2 = CYMTOF(ml-&gt;b.y);

  // trivial rejects
  if ((x1 &lt; f_x &amp;&amp; x2 &lt; f_x) || (x1 &gt; f_x2 &amp;&amp; x2 &gt; f_x2) ||
      (y1 &lt; f_y &amp;&amp; y2 &lt; f_y) || (y1 &gt; f_y2 &amp;&amp; y2 &gt; f_y2))
  {
    return;
  }
  
  vctx.SolidLine(x1, y1, x2, y2, colour);
}
</t>
<t tx="T2107">@ Draws flat (floor/ceiling tile) aligned grid lines.
@c

static void DrawGrid(int colour)
{
  float_t x, y;
  float_t start, end;
  mline_t ml;

  // Figure out start of vertical gridlines
  start = m_x + fmod(MAPBLOCKUNITS - (m_x - bmaporgx), MAPBLOCKUNITS);
  end = m_x + m_w;

  // draw vertical gridlines
  ml.a.y = m_y;
  ml.b.y = m_y + m_h;
  for (x = start; x &lt; end; x += MAPBLOCKUNITS)
  {
    ml.a.x = x;
    ml.b.x = x;
    DrawMline(&amp;ml, colour);
  }

  // Figure out start of horizontal gridlines
  start = m_y + fmod(MAPBLOCKUNITS - (m_y - bmaporgy), MAPBLOCKUNITS);
  end = m_y + m_h;

  // draw horizontal gridlines
  ml.a.x = m_x;
  ml.b.x = m_x + m_w;
  for (y = start; y &lt; end; y += MAPBLOCKUNITS)
  {
    ml.a.y = y;
    ml.b.y = y;
    DrawMline(&amp;ml, colour);
  }
}
</t>
<t tx="T2108">@ CheckSimiliarRegions

Checks whether the two sectors' regions are similiar. If they are
different enough, a line will be drawn on the automap.

-AJA- 1999/12/07: written.
@c

static boolean_t CheckSimiliarRegions(sector_t *front, sector_t *back)
{
  extrafloor_t *F, *B;

  if (front-&gt;tag == back-&gt;tag)
    return true;

  // Note: doesn't worry about liquids

  F = front-&gt;bottom_ef;
  B = back-&gt;bottom_ef;

  while (F &amp;&amp; B)
  {
    if (F-&gt;top_h != B-&gt;top_h)
      return false;
    
    if (F-&gt;bottom_h != B-&gt;bottom_h)
      return false;
    
    F = F-&gt;higher;
    B = B-&gt;higher;
  }

  return (F || B) ? false : true;
}
</t>
<t tx="T2109">@ Determines visible lines, draws them.

-AJA- This is now *lineseg* based, not linedef.
@c

static void AM_WalkSeg(seg_t *seg)
{
  mline_t l;
  line_t *line;

  sector_t *front = seg-&gt;frontsector;
  sector_t *back  = seg-&gt;backsector;

  if (seg-&gt;miniseg)
  {
#if (DEBUG_TRUEBSP == 1)
    if (seg-&gt;partner &amp;&amp; seg &gt; seg-&gt;partner)
      return;
#endif

#if (DEBUG_TRUEBSP &gt; 0)
    GetRotatedCoords(seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y, &amp;l.a.x, &amp;l.a.y);
    GetRotatedCoords(seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y, &amp;l.b.x, &amp;l.b.y);

    DrawMline(&amp;l, MINI_COL);
#endif

    return;
  }
  
  line = seg-&gt;linedef;
  DEV_ASSERT2(line);

  // only draw segs on the _right_ side of linedefs
#if (DEBUG_TRUEBSP &lt; 2)
  if (line-&gt;side[1] == seg-&gt;sidedef)
    return;
#endif

  GetRotatedCoords(seg-&gt;v1-&gt;x, seg-&gt;v1-&gt;y, &amp;l.a.x, &amp;l.a.y);
  GetRotatedCoords(seg-&gt;v2-&gt;x, seg-&gt;v2-&gt;y, &amp;l.b.x, &amp;l.b.y);

  if (cheating || (line-&gt;flags &amp; ML_Mapped))
  {
    if ((line-&gt;flags &amp; ML_DontDraw) &amp;&amp; !cheating)
      return;

    if (!front || !back)
    {
      DrawMline(&amp;l, WALL_COL);
    }
    else
    {
      if (line-&gt;special &amp;&amp; line-&gt;special-&gt;singlesided)
      {  
        // teleporters
        DrawMline(&amp;l, TELE_COL);
      }
      else if (line-&gt;flags &amp; ML_Secret)
      {  
        // secret door
        if (cheating)
          DrawMline(&amp;l, SECRET_COL);
        else
          DrawMline(&amp;l, WALL_COL);
      }
      else if (back-&gt;f_h != front-&gt;f_h)
      {
        // floor level change
        DrawMline(&amp;l, FLOOR_COL);
      }
      else if (back-&gt;c_h != front-&gt;c_h)
      {
        // ceiling level change
        DrawMline(&amp;l, CEIL_COL);
      }
      else if ((front-&gt;exfloor_used &gt; 0 || back-&gt;exfloor_used &gt; 0) &amp;&amp;
               (front-&gt;exfloor_used != back-&gt;exfloor_used ||
                ! CheckSimiliarRegions(front, back)))
      {
        // -AJA- 1999/10/09: extra floor change.
        DrawMline(&amp;l, REGION_COL);
      }
      else if (cheating || (DEBUG_TRUEBSP &gt; 1))
      {
        DrawMline(&amp;l, ALLMAP_COL);
      }
    }
  }
  else if (consoleplayer-&gt;powers[PW_AllMap])
  {
    if (! (line-&gt;flags &amp; ML_DontDraw))
      DrawMline(&amp;l, ALLMAP_COL);
  }
}
</t>
<t tx="T2110">@ -AJA- for debugging
@c

#if (DEBUG_TRUEBSP == 4)
static void DEBUG_ShowSubSecs(void)
{
  int x, y;

  for (y=0;     y &lt; f_h; y += 3)
  for (x=(y&amp;1); x &lt; f_w; x += 3)
  {
    float_t mx = CXFTOM(x);
    float_t my = CYFTOM(y);

    int subsec = R_PointInSubsector(mx, my) - subsectors;

    V_DrawPixel(main_scr, x, y, subsec * 17 + (subsec/256) * 11);
  }
}

#endif</t>
<t tx="T2111">static void DrawLineCharacter(mline_t *lineguy, int lineguylines, 
    float_t radius, angle_t angle, int colour, float_t x, float_t y)
{
  int i;
  mline_t l;
  float_t ch_x, ch_y;

  if (radius &lt; 2)
    radius = 2;

  GetRotatedCoords(x, y, &amp;ch_x, &amp;ch_y);
  angle = GetRotatedAngle(angle);
  
  for (i = 0; i &lt; lineguylines; i++)
  {
    l.a.x = lineguy[i].a.x * radius;
    l.a.y = lineguy[i].a.y * radius;

    if (angle)
      Rotate(&amp;l.a.x, &amp;l.a.y, angle);

    l.a.x += ch_x;
    l.a.y += ch_y;

    l.b.x = lineguy[i].b.x * radius;
    l.b.y = lineguy[i].b.y * radius;

    if (angle)
      Rotate(&amp;l.b.x, &amp;l.b.y, angle);

    l.b.x += ch_x;
    l.b.y += ch_y;

    DrawMline(&amp;l, colour);
  }
}
</t>
<t tx="T2112">static int player_colours[8] =
{ GREEN,  GRAY + GRAY_LEN*2/3, BROWN, RED + RED_LEN/2, 
  ORANGE, GRAY + GRAY_LEN*1/3, RED, PINK };

static void AM_DrawPlayer(mobj_t *mo)
{
  int colour;
  
  DEV_ASSERT2(mo-&gt;player-&gt;in_game);

  if (!netgame)
  {
    if (cheating)
      DrawLineCharacter(cheat_player_arrow, NUMCHEATPLYRLINES, 
          mo-&gt;radius, mo-&gt;angle, YOUR_COL, mo-&gt;x, mo-&gt;y);
    else
      DrawLineCharacter(player_arrow, NUMPLYRLINES, 
          mo-&gt;radius, mo-&gt;angle, YOUR_COL, mo-&gt;x, mo-&gt;y);

    return;
  }

  if ((deathmatch &amp;&amp; !singledemo) &amp;&amp; mo-&gt;player != consoleplayer)
    return;

  if (mo-&gt;player-&gt;powers[PW_PartInvis])
    colour = (DBLUE + DBLUE_LEN - 1);  // *close* to black
  else
    colour = player_colours[mo-&gt;player-&gt;pnum &amp; 0x07];

  DrawLineCharacter(player_arrow, NUMPLYRLINES, 
      mo-&gt;radius, mo-&gt;angle, colour, mo-&gt;x, mo-&gt;y);
}
</t>
<t tx="T2113">static void AM_WalkThing(mobj_t *mo)
{
  int colour = THING_COL;

  if (mo-&gt;player)
  {
    AM_DrawPlayer(mo);
    return;
  }

  if (cheating != 2)
    return;

  // -AJA- more colourful things
  if (mo-&gt;flags &amp; MF_SPECIAL)
    colour = ITEM_COL;
  else if (mo-&gt;flags &amp; MF_MISSILE)
    colour = MISSL_COL;
  else if (mo-&gt;extendedflags &amp; EF_MONSTER &amp;&amp; mo-&gt;health &lt;= 0)
    colour = DEAD_COL;
  else if (mo-&gt;extendedflags &amp; EF_MONSTER)
    colour = MONST_COL;
  
  DrawLineCharacter(thintriangle_guy, NUMTHINTRIANGLEGUYLINES,
      mo-&gt;radius, mo-&gt;angle, colour, mo-&gt;x, mo-&gt;y);
}
</t>
<t tx="T2114">@ AM_WalkSubsector

Visit a subsector and draw everything.
@c

static void AM_WalkSubsector(int num)
{
  subsector_t *sub = &amp;subsectors[num];

  seg_t *seg;
  mobj_t *thing;

  // handle each seg
  for (seg=sub-&gt;segs; seg; seg=seg-&gt;sub_next)
  {
    AM_WalkSeg(seg);
  }

  // handle each thing
  for (thing=sub-&gt;thinglist; thing; thing=thing-&gt;snext)
  {
    AM_WalkThing(thing);
  }
}
</t>
<t tx="T2115">@ AM_CheckBBox

Checks BSP node/subtree bounding box.
Returns true if some part of the bbox might be visible.
@c

static boolean_t AM_CheckBBox(float_t *bspcoord)
{
  float_t xl = bspcoord[BOXLEFT];
  float_t yt = bspcoord[BOXTOP];
  float_t xr = bspcoord[BOXRIGHT];
  float_t yb = bspcoord[BOXBOTTOM];

  if (xr &lt; m_x || xl &gt; m_x2 || yt &lt; m_y || yb &gt; m_y2)
    return false;

  return true;
}
</t>
<t tx="T2116">@ AM_WalkBSPNode

Walks all subsectors below a given node, traversing subtree
recursively. Just call with BSP root.
@c

static void AM_WalkBSPNode(int bspnum)
{
  node_t *node;
  int side;

  // Found a subsector?
  if (bspnum &amp; NF_SUBSECTOR)
  {
    AM_WalkSubsector(bspnum &amp; (~NF_SUBSECTOR));
    return;
  }

  node = &amp;nodes[bspnum];
  side = 0;

#if (DEBUG_TRUEBSP == 2 || DEBUG_TRUEBSP == 3)
  side = P_PointOnDivlineSide(consoleplayer-&gt;mo-&gt;x, consoleplayer-&gt;mo-&gt;y, &amp;node-&gt;div);
#endif

  // Recursively divide right space
  if (AM_CheckBBox(node-&gt;bbox[0]))
    AM_WalkBSPNode(node-&gt;children[side]);

#if (DEBUG_TRUEBSP == 2)
  return;
#elif (DEBUG_TRUEBSP == 3)
  {
    mline_t l;

    float_t x1 = node-&gt;div.x - node-&gt;div.dx * 2;
    float_t y1 = node-&gt;div.y - node-&gt;div.dy * 2;
    float_t x2 = node-&gt;div.x + node-&gt;div.dx * 2;
    float_t y2 = node-&gt;div.y + node-&gt;div.dy * 2;

    GetRotatedCoords(x1+3, y1+3, &amp;l.a.x, &amp;l.a.y);
    GetRotatedCoords(x2+3, y2+3, &amp;l.b.x, &amp;l.b.y);

    DrawMline(&amp;l, GREEN+GREEN_LEN*4/5);
    return;
  }
#endif

  // Recursively divide back space
  if (AM_CheckBBox(node-&gt;bbox[side ^ 1]))
    AM_WalkBSPNode(node-&gt;children[side ^ 1]);
}
</t>
<t tx="T2117">static void DrawMarks(void)
{
  int i, sx, sy;

  for (i = 0; i &lt; AM_NUMMARKPOINTS; i++)
  {
    if (markpoints[i].x != -1)
    {
      sx = CXMTOF(markpoints[i].x);
      sy = CYMTOF(markpoints[i].y);

      VCTX_ImageEasy(sx, sy, marknums[i]);
    }
  }
}
</t>
<t tx="T2118">static void DrawCrosshair(int colour)
{
#if 0  // FIXME !
  // -AJA- 1999/07/04: now uses V_DrawPixel().

  V_DrawPixel(main_scr, f_w / 2, f_h / 2, colour);  // single point for now
#endif
}
</t>
<t tx="T2119">static void AM_RenderScene(void)
{
  // walk the bsp tree
  AM_WalkBSPNode(root_node);
}
</t>
<t tx="T2120">void AM_Drawer(void)
{
  if (!automapactive)
    return;

  if (automapactive == 1)
    am_colmap = am_overlay_colmap;

  if (automapactive == 2)
  {
    am_colmap = am_normal_colmap;

    // clear the framebuffer
    vctx.SolidBox(f_x, f_y, f_w, f_h, BACK_COL, 1.0);
  }

  if (grid &amp;&amp; !rotatemap)
    DrawGrid(GRID_COL);

  AM_RenderScene();

  DrawCrosshair(XHAIR_COL);
  DrawMarks();

#ifdef DEVELOPERS
  am_colmap = NULL;
#endif
}
</t>
<t tx="T2121">@ignore
@language c

// Console Interface code.

&lt;&lt; con_con #includes &gt;&gt;
&lt;&lt; con_con declarations &gt;&gt;
@others
</t>
<t tx="T2122">#include "i_defs.h"
#include "con_defs.h"

#include "dm_defs.h"
#include "dm_state.h"
#include "gui_gui.h"
#include "gui_ctls.h"
#include "hu_stuff.h"
#include "hu_lib.h"
#include "m_argv.h"
#include "m_menu.h"
#include "v_colour.h"
#include "v_ctx.h"
#include "v_res.h"
#include "w_wad.h"
#include "wp_main.h"
#include "z_zone.h"
</t>
<t tx="T2123">typedef struct coninfo_s coninfo_t;
struct coninfo_s
{
  visible_t visible;
  int cursor;
//   char s[SCREENROWS][SCREENCOLS];
  //   char input[BACKBUFFER+1][SCREENCOLS];
  int x, y, pos;
  int backbuffer;
  int page;
  boolean_t echo;
}
con_info;

gui_t console =
{   0,
    &amp;CON_Ticker,
    &amp;CON_Responder,
    &amp;CON_Drawer,
    (void *)&amp;con_info,
    0, 0, 0, 0, 0, 0, 0
};

// stores the console toggle effect
wipeinfo_t *conwipe = NULL;
int conwipeactive = 0;
int conwipestart = 0;
int conwipemethod = WIPE_Crossfade;
boolean_t conwipereverse = 0;
int conwipeduration = 10;

#define KEYREPEATDELAY ((250 * TICRATE) / 1000)
#define KEYREPEATRATE  (TICRATE / 15)

// the console's screen
screen_t *conscreen;
char consolebackg[9] = "FWATER1";
static const image_t *console_bg_image = NULL;

// the console background. Used to clear conscreen.
screen_t *conback_scr;

typedef struct consoleline_s
{
  char *s;  // The String

  int len;  // the length of the string, not counting terminating 0.

}
consoleline_t;

// All the output lines of the console (not only those currently visible).
// A line can be of any length. If the screen is too narrow for it, the line
// will be split up on screen, but it will remain intact in this array.
static consoleline_t *linebuffer = NULL;
static int linebufferpos = 0;  // shows the index after the last one

static int linebuffersize = 0;  // shows the size

// lastline: The last output text line. This is different from the others
// because it is growable, you can print twice without newline.
char *lastline = NULL;  // the last text line of the console.

int lastlinesize = 0;
int lastlinepos = 0;
int lastlineend = 0;

// Properly split up last line.
// s: array of string start pointers, l: array of string lengths,
// n: number of strings.
char **vislastline_s = NULL;
int *vislastline_l = NULL;
int vislastline_n = 0;

// Command Line
char *cmdline = NULL;
int cmdlinesize = 0;
int cmdlinepos = 0;
int cmdlineend = 0;

// Properly split up command line.
char **viscmdline_s = NULL;
int *viscmdline_l = NULL;
int viscmdline_n = 0;

// Command line backup: If you press UPARROW when you've written something
// at the command line, it will be backuped here, and it's possible to restore
// it by pressing DOWNARROW before you've executed another command.
char *cmdlinebkp = NULL;
int cmdlinebkpsize = 0;

// Command Line History. All the written commands.
consoleline_t *cmdhistory = NULL;
int cmdhistoryend = 0;
int cmdhistorysize = 0;

// when browsing the cmdhistory, this shows the current index. Otherwise it's -1.
int cmdhistorypos = -1;

// Tells whether the console text needs to be updated.
boolean_t updateconsoleneeded = false;

// The text of the console, with lines split up properly for the current
// resolution.
char **curlines = NULL;

// the length of each of curlines
int *curlinelengths = NULL;

// the number of allocated rows in curlines and curlinelengths.
int curlinesize = 0;

// number of visible console lines (curlines+vislastline+viscmdline).
int numvislines = 0;

// width of console. Measured in characters if in text mode, and in pixels
// if in graphics mode.
int conwidth;
int conheight;
int conrows;

// the console row that is displayed at the bottom of screen, -1 if cmdline
// is the bottom one.
int bottomrow = -1;

// if true, nothing will be displayed in the console, and there will be no
// command history.
boolean_t no_con_history = 0;

// always type ev_keydown
guievent_t RepeatEvent;
int RepeatCountdown;

// tells whether shift is pressed, and pgup/dn should scroll to top/bottom of linebuffer.
boolean_t KeysShifted;

boolean_t TabbedLast;

boolean_t CON_HandleKey(guievent_t * ev);

void UpdateConback(cvar_t *var, void *user);

typedef enum
{
  NOSCROLL,
  SCROLLUP,
  SCROLLDN
}
scrollstate_e;

scrollstate_e scroll_state;

static int (*MaxTextLen) (char *s);
</t>
<t tx="T2124">static int MaxTextLen_gfx(char *s)
{
  return HL_TextMaxLen(conwidth, s);
}
</t>
<t tx="T2125">static int MaxTextLen_text(char *s)
{
  int len = strlen(s);

  if (len &gt; conwidth)
    return conwidth;
  else
    return len;
}
</t>
<t tx="T2126">@ Adds a line of text to either cmdhistory or linebuffer
@c

static void AddLine(consoleline_t ** line, int *pos, int *size, char *s)
{
  consoleline_t *l;

  // we always have two free lines at the end, these can be used temporarily
  // for easier lastline and cmdline handling
  if (*pos &gt;= *size - 2)
    Z_Resize(*line, consoleline_t, *size += 8);

  l = &amp;(*line)[*pos];
  l-&gt;len = strlen(s);
  l-&gt;s = Z_New(char, l-&gt;len + 1);
  Z_MoveData(l-&gt;s, s, char, l-&gt;len + 1);

  (*pos)++;
}
</t>
<t tx="T2127">@ GrowLine

helper function for use with cmdline and lastline. Verifies that
*line can contain newlen characters
@c

static void GrowLine(char **line, int *len, int newlen)
{
  if (newlen &lt;= *len)
    return;  // don't need to do anything

  // always grow 128 byte at a time
  newlen = (newlen + 127) &amp; ~127;

  Z_Resize(*line, char, newlen);
  if (!*line)
    I_Error("GrowLine: Out of memory!");

  *len = newlen;
}
</t>
<t tx="T2128">@ splits up s in conwidth wide chunks, and stores pointers to the start of
each line at the end of the *lines array.
@c

static void AddSplitRow(char ***lines, int **lengths, int *size, char *s)
{
  int len;

  do
  {
    (*size)++;
    Z_Resize(*lines, char *, *size);
    Z_Resize(*lengths, int, *size);

    len = MaxTextLen(s);
    (*lines)[(*size) - 1] = s;
    (*lengths)[(*size) - 1] = len;
    s += len;
  }
  while (*s);
}
</t>
<t tx="T2129">static void UpdateNumvislines(void)
{
  numvislines = curlinesize + vislastline_n + viscmdline_n;
}
</t>
<t tx="T2130">static void AddConsoleLine(char *s)
{
  if (no_con_history)
    return;

  AddLine(&amp;linebuffer, &amp;linebufferpos, &amp;linebuffersize, s);
  AddSplitRow(&amp;curlines, &amp;curlinelengths, &amp;curlinesize, linebuffer[linebufferpos - 1].s);
  UpdateNumvislines();
}
</t>
<t tx="T2131">@ updates cmdline after it has been changed.
@c

static void UpdateCmdLine(void)
{
  viscmdline_n = 0;
  if (cmdlinepos == cmdlineend)
  {  // the cursor is at the end of the command line, allocate space for it too.

    GrowLine(&amp;cmdline, &amp;cmdlinesize, cmdlineend + 2);
    cmdline[cmdlineend] = '_';
    cmdline[cmdlineend + 1] = 0;
  }
  AddSplitRow(&amp;viscmdline_s, &amp;viscmdline_l, &amp;viscmdline_n, cmdline);
  cmdline[cmdlineend] = 0;
  // the cursor should not blink when you're writing.
  con_info.cursor = 0;
  UpdateNumvislines();
}
</t>
<t tx="T2132">static void UpdateLastLine(void)
{
  vislastline_n = 0;
  AddSplitRow(&amp;vislastline_s, &amp;vislastline_l, &amp;vislastline_n, lastline);
  UpdateNumvislines();
}
</t>
<t tx="T2133">static void AddCommandToHistory(char *s)
{
  // Don't add the string if it's the same as the previous one in history.
  // Add it if history is empty, though.
  if (no_con_history)
    return;
  if (!cmdhistory || strcmp(cmdhistory[cmdhistoryend - 1].s, s))
    AddLine(&amp;cmdhistory, &amp;cmdhistoryend, &amp;cmdhistorysize, s);
}
</t>
<t tx="T2134">static void UpdateConsole(void)
{
  int i;

  curlinesize = 0;

  for (i = 0; i &lt; linebufferpos; i++)
  {
    AddSplitRow(&amp;curlines, &amp;curlinelengths, &amp;curlinesize, linebuffer[i].s);
  }

  bottomrow = -1;

  UpdateLastLine();
  UpdateCmdLine();
}
</t>
<t tx="T2135">@ Call this whenever the console changes, otherwise it might not be rendered
@c

static void NeedConsoleUpdate(void)
{
  updateconsoleneeded = true;
}
</t>
<t tx="T2136">@ CON_InitConsole

Initialises the console with the given dimensions, in characters.
gfxmode tells whether it should be initialised to work in graphics mode.
@c

void CON_InitConsole(int width, int height, int gfxmode)
{
  conwidth = width;
  conheight = height;

  if (gfxmode)
  {
    MaxTextLen = MaxTextLen_gfx;
    conrows = (height * 200 / SCREENHEIGHT) / 8;

    conscreen = V_ResizeScreen(conscreen, conwidth, conheight, BPP);
    conback_scr = V_ResizeScreen(conback_scr, conwidth, conheight, BPP);
    UpdateConback(CON_CVarPtrFromName("conback"), NULL);
  }
  else
  {
    MaxTextLen = MaxTextLen_text;
    conrows = height;
  }

  if (lastline == NULL)
  {
    // First time. Init lastline and cmdline and cmdhistory, and add dummy
    // elements
    GrowLine(&amp;lastline, &amp;lastlinesize, 128);
    lastline[0] = 0;
    GrowLine(&amp;cmdline, &amp;cmdlinesize, 128);
    cmdline[0] = '&gt;';
    cmdline[1] = 0;
    cmdlinepos = 1;
    cmdlineend = 1;
    AddCommandToHistory(cmdline);
    AddConsoleLine("");
    no_con_history = M_CheckParm("-noconhistory");
  }

  UpdateConsole();
}
</t>
<t tx="T2137">void CON_SetVisible(visible_t v)
{
  if (con_info.visible == v)
    return;

  con_info.visible = v;
  if (v == vs_maximal)
  {
    GUI_SetFocus(console.gui, &amp;console);
    cmdhistorypos = -1;
    TabbedLast = false;

#if 0  //###
    conwipe = WIPE_InitWipe(main_scr, 0, 0,
        main_scr, 0, 0, 0,
        conscreen, 0, 0, 0,
        conwidth, conheight, conwipe,
        conwipeduration, conwipereverse, conwipemethod);

    // if already wiping, continue where we started.
    if (conwipeactive &lt; 0)
      conwipestart = gametic - conwipeduration + gametic - conwipestart;
    else
      conwipestart = gametic;

    conwipeactive = 1;
#endif //###
  }
  else
  {
#if 0 //###
    conwipe = WIPE_InitWipe(main_scr, 0, 0,
        conscreen, 0, 0, 1,
        main_scr, 0, 0, 0,
        conwidth, conheight, conwipe,
        conwipeduration, !conwipereverse, conwipemethod);

    // if already wiping, continue where we started.
    if (conwipeactive &gt; 0)
      conwipestart = gametic - conwipeduration + gametic - conwipestart;
    else
      conwipestart = gametic;

    conwipeactive = -1;
#endif //###
  }
}
</t>
<t tx="T2138">static void PrintString(const char *s)
{
  const char *src;

  for (src = s; *src; src++)
  {
    if (*src == '\n')
    {  // new line, add it to the console history.

      lastline[lastlineend] = 0;
      AddConsoleLine(lastline);
      lastlinepos = lastlineend = 0;
      continue;
    }

    if (*src == '\r')
    {
      lastlinepos = 0;
      continue;
    }

    if (*src == '\x8' &amp;&amp; lastlinepos &gt; 0)
    {  // backspace
      lastlinepos--;
      continue;
    }

    lastline[lastlinepos] = *src;
    lastlinepos++;

    if (lastlinepos &gt; lastlineend)
      lastlineend = lastlinepos;

    // verify that lastline is big enough to contain the final \0
    GrowLine(&amp;lastline, &amp;lastlinesize, lastlineend + 1);
  }

  lastline[lastlineend] = 0;

  // string is already printed if !graphicsmode.
  if (graphicsmode)
    NeedConsoleUpdate();

  UpdateLastLine();
}
</t>
<t tx="T2139">void CON_Printf(const char *message,...)
{
  va_list argptr;
  char buffer[1024];

  va_start(argptr, message);

  // Print the message into a text string
  vsprintf(buffer, message, argptr);

  PrintString(buffer);

  va_end(argptr);
}
</t>
<t tx="T2140">void CON_MessageLDF(const char *lookup,...)
{
  va_list argptr;
  char buffer[1024];

  va_start(argptr, lookup);

  // Print the message into a text string
  vsprintf(buffer, DDF_LanguageLookup(lookup), argptr);

  HU_StartMessage(buffer);

  strcat(buffer, "\n");

  PrintString(buffer);

  va_end(argptr);
}
</t>
<t tx="T2141">void CON_Message(const char *message,...)
{
  va_list argptr;
  char buffer[1024];

  va_start(argptr, message);

  // Print the message into a text string
  vsprintf(buffer, message, argptr);

  HU_StartMessage(buffer);

  strcat(buffer, "\n");

  PrintString(buffer);

  va_end(argptr);
}
</t>
<t tx="T2142">void CON_Ticker(gui_t * gui)
{
  coninfo_t *info = gui-&gt;process;
  static int lasttic = 0;

  info-&gt;cursor = (info-&gt;cursor + 1) &amp; 31;

  if (lasttic == 0)
    lasttic = gametic - 1;

  if (info-&gt;visible != vs_notvisible)
  {
    // Handle repeating keys
    switch (scroll_state)
    {
      case SCROLLUP:
        if (bottomrow &gt; 0)
          bottomrow--;
        if (bottomrow == -1)
          bottomrow = numvislines - 2;  // numvislines-1 (commandline) is the last line

        NeedConsoleUpdate();
        break;

      case SCROLLDN:
        if (bottomrow == -1)
          break;  // already at bottom. Can't scroll down.

        if (bottomrow &lt; numvislines - 2)
          bottomrow++;
        else
          bottomrow = -1;
        NeedConsoleUpdate();
        break;

      default:
        if (RepeatCountdown)
        {
          RepeatCountdown -= gametic - lasttic;
          while (RepeatCountdown &lt;= 0)
          {
            RepeatCountdown += KEYREPEATRATE;
            CON_HandleKey(&amp;RepeatEvent);
          }
        }
        break;
    }
  }

  lasttic = gametic;
}
</t>
<t tx="T2143">@ writes the text on coords (x,y) of the console
@c

static void WriteText(int x, int y, char *s, int len, int col)
{
  char buffer[1024];

  if (len &gt; 1020)
    len = 1020;

  Z_StrNCpy(buffer, s, len);

  HL_WriteTextTrans(x, y, col ? text_red_map : text_white_map, buffer);
}
</t>
<t tx="T2144">@ CON_Drawer

Draws the console in graphics mode.
@c

void CON_Drawer(gui_t * gui)
{
  coninfo_t *info = gui-&gt;process;
  int i;
  int y;
  int bottom;
  int len, c;

  if (info-&gt;visible == vs_notvisible)
  {  // Console is inactive.
    // Continue fading out console if it isn't already outfaded.
#if 0  //###
    if (conwipeactive &lt; 0)
    {  // console fades out

      if (WIPE_DoWipe(main_scr, conscreen, main_scr, gametic - conwipestart, conwipe))
        conwipeactive = 0;
    }
#endif
    return;
  }

// OPTIMISE: Only update what we need to update (eg. nothing in most cases...)
//###  V_CopyScreen(conscreen, conback_scr);

  // -AJA- Temp fix for image system:
  vctx.DrawImage(0, 0, conwidth, conheight, console_bg_image,
      0.0, 0.0, IM_RIGHT(console_bg_image) * 5.0, 
      IM_BOTTOM(console_bg_image) * 5.0, NULL, 1.0);
 
  if (bottomrow == -1)
    bottom = numvislines;
  else
    bottom = bottomrow;

  y = 0;
  i = bottom - conrows;
  if (i &lt; 0)
  {  // leave some blank lines before the top

    y -= i;
    i = 0;
  }

  for (; i &lt; curlinesize &amp;&amp; y &lt; conrows; i++, y++)
  {
    WriteText(0, y * 8, curlines[i], curlinelengths[i], 0);
  }
  i -= curlinesize;
  for (; i &lt; vislastline_n &amp;&amp; y &lt; conrows; i++, y++)
  {
    WriteText(0, y * 8, vislastline_s[i], vislastline_l[i], 0);
  }
  i -= vislastline_n;
  for (; i &lt; viscmdline_n &amp;&amp; y &lt; conrows; i++, y++)
  {
    WriteText(0, y * 8, viscmdline_s[i], viscmdline_l[i], 1);
  }

  // draw the cursor on the right place of the command line.
  if (info-&gt;cursor &lt; 16 &amp;&amp; bottomrow == -1)
  {
    // the command line can be more than one row high, so we must first search
    // for the line containing the cursor.
    i = viscmdline_n;
    y = conrows;
    // if the cursor is alone, we must add an extra char for it
    len = cmdlineend;  //==cmdlinepos?cmdlineend+1:cmdlineend;

    do
    {
      i--;
      y--;
      len -= viscmdline_l[i];
    }
    while (len &gt; cmdlinepos &amp;&amp; i &gt; 0);
    // now draw the cursor on the right x position of the right line.
    // But only draw it if it's on the screen
    if (len &lt;= cmdlinepos)
    {
      len = cmdlinepos - len;
      c = viscmdline_s[i][len];
      // temporarily truncate the cmdline to the cursor position.
      viscmdline_s[i][len] = 0;
      WriteText(HL_StringWidth(viscmdline_s[i]), y * 8, "_", 1, 1);
      viscmdline_s[i][len] = c;
    }
  }

#if 0 //###
  if (conwipeactive &gt; 0)
  {  // console fades in

    if (WIPE_DoWipe(main_scr, main_scr, conscreen, gametic - conwipestart, conwipe))
      conwipeactive = 0;
  }
  else
  {  // fading complete

    V_CopyRect(main_scr, conscreen, 0, 0, conwidth, conheight, 0, 0);
  }
#endif //###
}
</t>
<t tx="T2145">static void ToggleConsole(void)
{
  if (con_info.visible == vs_notvisible)
  {
    CON_SetVisible(vs_maximal);
  }
  else
  {
    CON_SetVisible(vs_notvisible);
  }
}
</t>
<t tx="T2146">
#if 0
static void TabComplete(void)
{  // -ES- fixme - implement these

}
</t>
<t tx="T2147">static void AddTabCommand(char *name)
{
}
</t>
<t tx="T2148">static void RemoveTabCommand(char *name)
{
}
</t>
<t tx="T2149">#endif

boolean_t CON_HandleKey(guievent_t * ev)
{
  switch (ev-&gt;data1)
  {
#if 0  // -ES- fixme - implement tab stuff (need commands first, though)
    case KEYD_TAB:
      // Try to do tab-completion
      TabComplete();
      break;
#endif

    case KEYD_PGUP:
      if (KeysShifted)
        // Move to top of console buffer
        bottomrow = 0;
      else
        // Start scrolling console buffer up
        scroll_state = SCROLLUP;
      break;

    case KEYD_PGDN:
      if (KeysShifted)
        // Move to bottom of console buffer
        bottomrow = -1;
      else
        // Start scrolling console buffer down
        scroll_state = SCROLLDN;
      break;

    case KEYD_HOME:
      // Move cursor to start of line
      cmdlinepos = 1;
      break;

    case KEYD_END:
      // Move cursor to end of line
      cmdlinepos = cmdlineend;
      break;

    case KEYD_LEFTARROW:
      // Move cursor left one character

      if (cmdlinepos &gt; 1)
        cmdlinepos--;
      break;

    case KEYD_RIGHTARROW:
      // Move cursor right one character

      if (cmdlinepos &lt; cmdlineend)
        cmdlinepos++;
      break;

    case KEYD_BACKSPACE:
      // Erase character to left of cursor

      if (cmdlinepos &gt; 1)
      {
        char *c, *e;

        e = &amp;cmdline[cmdlineend];
        c = &amp;cmdline[cmdlinepos];

        for (; c &lt;= e; c++)
          *(c - 1) = *c;

        cmdlineend--;
        cmdlinepos--;
      }

      TabbedLast = false;
      break;

    case KEYD_DELETE:
      // Erase charater under cursor

      if (cmdlinepos &lt; cmdlineend)
      {
        char *c, *e;

        e = &amp;cmdline[cmdlineend];
        c = &amp;cmdline[cmdlinepos + 1];

        for (; c &lt;= e; c++)
          *(c - 1) = *c;

        cmdlineend--;
      }

      TabbedLast = false;
      break;

    case KEYD_RALT:
    case KEYD_RCTRL:
      // Do nothing
      break;

    case KEYD_RSHIFT:
      // SHIFT was pressed
      KeysShifted = true;
      break;

    case KEYD_UPARROW:
      // Move to previous entry in the command history
      if (cmdhistorypos == -1)
      {
        cmdhistorypos = cmdhistoryend - 1;
        // backup cmdline temporarily: It can be recovered until the next
        // command you execute. another command.
        GrowLine(&amp;cmdlinebkp, &amp;cmdlinebkpsize, cmdlineend + 1);
        Z_MoveData(cmdlinebkp, cmdline, char, cmdlineend + 1);

        // add to history unofficially, so that it will be overwritten.
        cmdhistory[cmdhistoryend].s = cmdlinebkp;
        cmdhistory[cmdhistoryend].len = strlen(cmdlinebkp);
      }
      else if (cmdhistorypos)
      {
        cmdhistorypos--;
      }

      // set command line to the history index.
      cmdlineend = cmdlinepos = cmdhistory[cmdhistorypos].len;
      GrowLine(&amp;cmdline, &amp;cmdlinesize, cmdlineend + 1);
      Z_MoveData(cmdline, cmdhistory[cmdhistorypos].s, char, cmdlineend + 1);

      TabbedLast = false;
      break;

    case KEYD_DOWNARROW:
      // Move to next entry in the command history

      if (cmdhistorypos != -1 &amp;&amp; cmdhistorypos &lt; cmdhistoryend)
      {
        cmdhistorypos++;
        // set command line to the history item.
        cmdlineend = cmdlinepos = cmdhistory[cmdhistorypos].len;
        GrowLine(&amp;cmdline, &amp;cmdlinesize, cmdlineend + 1);
        Z_MoveData(cmdline, cmdhistory[cmdhistorypos].s, char, cmdlineend + 1);

        if (cmdhistorypos == cmdhistoryend)
        {  // we just restored the cmdline backup, now we aren't browsing history anymore.

          cmdhistorypos = -1;
        }

        TabbedLast = false;
      }
      break;
    case KEYD_ENTER:

      // Execute command line (ENTER)

      // Add it to history &amp; draw it
      AddCommandToHistory(cmdline);
      CON_Printf("\n%s\n", cmdline);

      // Run it!
      CON_TryCommand(cmdline + 1);

      // clear cmdline
      cmdline[1] = 0;
      cmdlinepos = 1;
      cmdlineend = 1;
      cmdhistorypos = -1;
      TabbedLast = false;
      break;

    case KEYD_TILDE:
    case KEYD_ESCAPE:
      // Close console, clear command line, but if we're in the
      // fullscreen console mode, there's nothing to fall back on
      // if it's closed.
      cmdline[1] = 0;
      cmdlinepos = 1;
      cmdlineend = 1;
      cmdhistorypos = -1;

      TabbedLast = false;
      UpdateCmdLine();

      CON_SetVisible(vs_notvisible);
      break;

    default:
      if (ev-&gt;data1 &lt; 32 || ev-&gt;data1 &gt; 126)
      {
        // Do nothing
      }
      else
      {
        // Add keypress to command line
        char data = ev-&gt;data1;
        char *c, *e;

        GrowLine(&amp;cmdline, &amp;cmdlinesize, cmdlineend + 2);

        // move everything after the cursor, including the 0, one step to the right
        e = &amp;cmdline[cmdlineend];
        c = &amp;cmdline[cmdlinepos];

        for (; e &gt;= c; e--)
        {
          *(e + 1) = *e;
        }

        // insert the character
        *c = data;

        cmdlinepos++;
        cmdlineend++;
      }
      TabbedLast = false;

      break;

  }
  // something in the console has probably changed, so we update it
  UpdateCmdLine();
  NeedConsoleUpdate();
  return true;
}
</t>
<t tx="T2150">boolean_t CON_Responder(gui_t * gui, guievent_t * event)
{
  coninfo_t *info = gui-&gt;process;

  if (info-&gt;visible == vs_notvisible)
  {
    if (event-&gt;type == gev_keydown &amp;&amp; event-&gt;data1 == KEYD_TILDE)
    {
      ToggleConsole();
      return true;
    }
    return false;
  }

  if (event-&gt;type == gev_keyup)
  {
    if (event-&gt;data1 == RepeatEvent.data1)
      RepeatCountdown = 0;

    switch (event-&gt;data1)
    {
      case KEYD_PGUP:
      case KEYD_PGDN:
        scroll_state = NOSCROLL;
        break;
      case KEYD_RSHIFT:
        KeysShifted = false;
        break;
      default:
        return false;
    }
  }
  else if (event-&gt;type == gev_keydown)
  {
    // Okay, fine. Most keys don't repeat
    switch (event-&gt;data1)
    {
      case KEYD_RIGHTARROW:
      case KEYD_LEFTARROW:
      case KEYD_UPARROW:
      case KEYD_DOWNARROW:
      case KEYD_SPACE:
      case KEYD_BACKSPACE:
      case KEYD_DELETE:
        RepeatCountdown = KEYREPEATDELAY;
        break;
      default:
        RepeatCountdown = 0;
        break;
    }

    RepeatEvent = *event;
    if (CON_HandleKey(event))
    {
      NeedConsoleUpdate();
      return true;
    }
  }

  return false;
}
</t>
<t tx="T2151">void CON_InitResolution(void)
{
  CON_InitConsole(SCREENWIDTH, (SCREENHEIGHT * 3 / 4) &amp; ~7, true);
}
</t>
<t tx="T2152">void UpdateConback(cvar_t *var, void *user GCCATTR(unused))
{
  const char *flat;

  flat = CON_CVarGetValue(var);

  console_bg_image = W_ImageFromFlat(flat);
}
</t>
<t tx="T2153">void CON_Start(gui_t ** gui)
{
  GUI_Start(gui, &amp;console);
  CON_CreateCVarEnum("constate", cf_normal, &amp;con_info.visible, "notvisible/visible", NUMVIS);
  CON_CreateCVarStr("conback", cf_normal, consolebackg, 8);
  CON_AddCVarCallback(CON_CVarPtrFromName("conback"), UpdateConback, NULL, NULL);

  CON_CreateCVarEnum("conwipemethod", cf_normal, &amp;conwipemethod, WIPE_EnumStr, WIPE_NUMWIPES);
  CON_CreateCVarInt("conwipeduration", cf_normal, &amp;conwipeduration);
  CON_CreateCVarBool("conwipereverse", cf_normal, &amp;conwipereverse);
}
</t>
<t tx="T2154">@ignore
@language c

// Console Variable Code

&lt;&lt; con_cvar #includes &gt;&gt;
&lt;&lt; con_cvar declarations &gt;&gt;
@others
</t>
<t tx="T2155">#include "i_defs.h"
#include "con_cvar.h"

#include "con_defs.h"
#include "z_zone.h"
</t>
<t tx="T2156">
cvar_t **cvars = NULL;
int num_cvars = 0;
</t>
<t tx="T2157">@ ** Common **
These are shared between the basic types int, bool and real.
@c

static void GetValue_Val(const void *val, const void **dest)
{
  *dest = val;
}
</t>
<t tx="T2158">
static void KillValue_Val(cvar_t * cvar)
{
  if (cvar-&gt;flags &amp; cf_mem)
    Z_Free(cvar-&gt;value);
}
</t>
<t tx="T2159">@ ** Enumeration **
@c

typedef struct cvar_enum_s
{
  int  *value;
  // the name of the enum type (e.g. "enum (foo,bar)"
  // it's called typenam just because "typename" is a keyword in GCC.
  char *typenam;
  // list of the names of the values.
  char **names;
  // number of values
  int  num;
}
cvar_enum_t;

static void GetValueStr_Enum(void *val, char s[1024])
{
  cvar_enum_t *v = val;

  strcpy(s, v-&gt;names[*(v-&gt;value)]);
}
</t>
<t tx="T2160">
static void GetValue_Enum(const void *val, const void **dest)
{
  const cvar_enum_t *v = val;

  *dest = v-&gt;value;
}
</t>
<t tx="T2161">
static boolean_t SetValue_Enum(cvar_t * cvar, int argc GCCATTR(unused), const char **argv)
{
  cvar_enum_t *v = cvar-&gt;value;
  long n;
  int i;
  char *end;

  for (i = 0; i &lt; v-&gt;num; i++)
    if (0 == stricmp(argv[0], v-&gt;names[i]))
    {
      *(v-&gt;value) = i;
      return true;
    }

  // Check if the argument can be treated as an int
  n = strtol(argv[0], &amp;end, 10);
  if (*end == 0 &amp;&amp;  // it was a valid number
       (n &gt;= 0 &amp;&amp; n &lt; v-&gt;num))  // it was in a valid range.

  {
    *(v-&gt;value) = i;
    return true;
  }

  return false;
}
</t>
<t tx="T2162">
static void KillValue_Enum(cvar_t * cvar)
{
  cvar_enum_t *v = cvar-&gt;value;
  int i;

  if (cvar-&gt;flags &amp; cf_mem)
    Z_Free(cvar-&gt;value);

  for (i = 0; i &lt; v-&gt;num; i++)
    Z_Free(v-&gt;names[i]);

  Z_Free(v-&gt;names);
  Z_Free(v-&gt;typenam);
  Z_Free(v);
}
</t>
<t tx="T2163">
static const char *GetType_Enum(cvar_t * cvar)
{
  cvar_enum_t *v = cvar-&gt;value;

  return v-&gt;typenam;
}
</t>
<t tx="T2164">@ Adds a possible value to an enum type
@c

static int CON_AddValueToEnum(cvar_enum_t *e, const char *name)
{
  int oldlen = strlen(e-&gt;typenam);
  int newlen = oldlen + strlen(name);

  // Change the type name
  // Alloc two extra chars: One for the terminating 0, and one for the '/'.
  Z_Resize(e-&gt;typenam, char, newlen + 2);
  e-&gt;typenam[oldlen - 1] = '/';
  // Copy the name.
  Z_MoveData(e-&gt;typenam + oldlen, name, char, newlen-oldlen);
  // finish the string
  e-&gt;typenam[newlen] = ')';
  e-&gt;typenam[newlen + 1] = 0;

  // add the name to the value list
  Z_Resize(e-&gt;names, char *, ++e-&gt;num);
  e-&gt;names[e-&gt;num - 1] = Z_StrDup(name);

  return e-&gt;num - 1;
}
</t>
<t tx="T2165">@ ** funclist_t type **
** boolean_t type **
@c

static void GetValueStr_Bool(void *val, char s[1024])
{
  boolean_t *v = val;

  if (*v)
    strcpy(s, "true");
  else
    strcpy(s, "false");
}
</t>
<t tx="T2166">
static boolean_t SetValue_Bool(cvar_t * cvar, int argc GCCATTR(unused), const char **argv)
{
  if (0 == stricmp(argv[0], "true") || 0 == stricmp(argv[0], "yes") ||
      0 == strcmp(argv[0], "1"))
    *(boolean_t *) (cvar-&gt;value) = true;
  else if (0 == stricmp(argv[0], "false") || 0 == stricmp(argv[0], "no") ||
      0 == strcmp(argv[0], "0"))
    *(boolean_t *) (cvar-&gt;value) = false;
  else
    return false;
  return true;
}
</t>
<t tx="T2167">
static const char *GetType_Bool(cvar_t * cvar GCCATTR(unused))
{
  return "Boolean";
}
</t>
<t tx="T2168">@ ** Real type **
@c

static void GetValueStr_Real(void *val, char s[1024])
{
  float_t *v = val;

  sprintf(s, "%f", (double)*v);
}
</t>
<t tx="T2169">
static boolean_t SetValue_Real(cvar_t * cvar, int argc GCCATTR(unused), const char **argv)
{
  float_t *v = cvar-&gt;value;
  double f;

  if (1 != sscanf(argv[0], "%lf", &amp;f))
    return false;

  *v = (float_t)f;

  return true;
}
</t>
<t tx="T2170">
static const char *GetType_Real(cvar_t * cvar GCCATTR(unused))
{
  return "Real Number";
}
</t>
<t tx="T2171">@ ** String type **
@c

typedef struct
{
  int maxlen;
  char *val;
}
cvar_str_t;

static void GetValueStr_Str(void *val, char s[1024])
{
  cvar_str_t *v = val;

  Z_StrNCpy(s, v-&gt;val, v-&gt;maxlen);
}
</t>
<t tx="T2172">
static void GetValue_Str(const void *val, const void **dest)
{
  const cvar_str_t *v = val;

  *dest = v-&gt;val;
}
</t>
<t tx="T2173">
static boolean_t SetValue_Str(cvar_t * cvar, int argc, const char **argv)
{
  cvar_str_t *v = cvar-&gt;value;
  char *s;
  int len = -1;
  int curlen;
  int i;

  if (v-&gt;maxlen &lt; 0)
  {  // dynamically reallocate value

    for (i = 0; i &lt; argc; i++)
      len += strlen(argv[i]);
    Z_Resize(v-&gt;val, char, len + 1);
    s = v-&gt;val;
    for (i = 0; i &lt; argc; i++)
    {
      curlen = strlen(argv[i]);
      Z_MoveData(s, argv[i], char, curlen);
      s += curlen;
      *s++ = ' ';
    }
    s[-1] = 0;
    return true;
  }

  s = v-&gt;val;

  for (i = 0; i &lt; argc; i++)
  {
    curlen = strlen(argv[i]);
    len += curlen + 1;
    if (len &gt; v-&gt;maxlen || i == argc - 1)
    {  // last time
      Z_StrNCpy(s, argv[i], v-&gt;maxlen - len + curlen + 1);
      break;
    }
    sprintf(s, "%s ", argv[i]);
    s += curlen + 1;
  }

  return true;
}
</t>
<t tx="T2174">
static void KillValue_Str(cvar_t * cvar)
{
  cvar_str_t *v = cvar-&gt;value;

  if (cvar-&gt;flags &amp; cf_mem)
    Z_Free(v-&gt;val);
  Z_Free(v);
}
</t>
<t tx="T2175">
static const char *GetType_Str(cvar_t * cvar GCCATTR(unused))
{
  return "String";
}
</t>
<t tx="T2176">@ ** Integer type **
@c

static void GetValueStr_Int(void *val, char s[1024])
{
  int *v = val;

  sprintf(s, "%d", *v);
}
</t>
<t tx="T2177">
static boolean_t SetValue_Int(cvar_t * cvar, int argc GCCATTR(unused), const char **argv)
{
  int *v = cvar-&gt;value;

  if (1 != sscanf(argv[0], "%d", v))
    return false;

  return true;
}
</t>
<t tx="T2178">
static const char *GetType_Int(cvar_t * cvar GCCATTR(unused))
{
  return "Integer";
}
</t>
<t tx="T2179">@ ** Callbacks **
stores the old values
@c

typedef struct cvar_callback_s
{
  const cvartype_t *type;
  void *value;
  void (*callback) (cvar_t * var, void *user);
  // user data
  void *user;
  // destructor for user data
  void (*kill_user)(void *);
}
cvar_callback_t;

static const char *GetType_Callback(cvar_t * cvar)
{
  const char *s;
  cvar_callback_t *v = cvar-&gt;value;
  const cvartype_t *type = cvar-&gt;type;

  cvar-&gt;value = v-&gt;value;
  cvar-&gt;type = v-&gt;type;
  s = cvar-&gt;type-&gt;get_name(cvar);
  cvar-&gt;value = v;
  cvar-&gt;type = type;
  return s;
}
</t>
<t tx="T2180">
static void GetValueStr_Callback(void *val, char s[1024])
{
  cvar_callback_t *v = val;

  v-&gt;type-&gt;get_value_str(v-&gt;value, s);
}
</t>
<t tx="T2181">
static void GetValue_Callback(const void *val, const void **dest)
{
  const cvar_callback_t *v = val;

  v-&gt;type-&gt;get_value(v-&gt;value, dest);
}
</t>
<t tx="T2182">
static boolean_t SetValue_Callback(cvar_t * cvar, int argc, const char **argv)
{
  boolean_t ok;
  cvar_callback_t *v = cvar-&gt;value;
  const cvartype_t *type = cvar-&gt;type;

  cvar-&gt;value = v-&gt;value;
  cvar-&gt;type = v-&gt;type;
  ok = cvar-&gt;type-&gt;set_value(cvar, argc, argv);
  if (ok)
  {
    v-&gt;callback(cvar, v-&gt;user);
  }
  v-&gt;value = cvar-&gt;value;
  v-&gt;type = cvar-&gt;type;
  cvar-&gt;value = v;
  cvar-&gt;type = type;
  return ok;
}
</t>
<t tx="T2183">
static void KillValue_Callback(cvar_t * cvar)
{
  cvar_callback_t *v = cvar-&gt;value;

  cvar-&gt;value = v-&gt;value;
  cvar-&gt;type = v-&gt;type;
  cvar-&gt;type-&gt;kill_value(cvar);

  if (v-&gt;kill_user)
    v-&gt;kill_user(v-&gt;user);

  Z_Free(v);
}
</t>
<t tx="T2184">
cvartype_t cvar_bool = {GetType_Bool, GetValueStr_Bool, GetValue_Val, SetValue_Bool, KillValue_Val};
cvartype_t cvar_int = {GetType_Int, GetValueStr_Int, GetValue_Val, SetValue_Int, KillValue_Val};
cvartype_t cvar_real = {GetType_Real, GetValueStr_Real, GetValue_Val, SetValue_Real, KillValue_Val};
cvartype_t cvar_str = {GetType_Str, GetValueStr_Str, GetValue_Str, SetValue_Str, KillValue_Str};
cvartype_t cvar_enum = {GetType_Enum, GetValueStr_Enum, GetValue_Enum, SetValue_Enum, KillValue_Enum};
cvartype_t cvar_callback = {GetType_Callback, GetValueStr_Callback, GetValue_Callback, SetValue_Callback, KillValue_Callback};

//
// CON_CVarFromName
//
// Returns a pointer to the console variable with the given name, or -1
// if it doesn't exist.
// -ES- 1999/07/25 Added this.
// 
static int CON_CVarIndexFromName(const char *name)
{
  int i;

  for (i = 0; i &lt; num_cvars; i++)
    if (!stricmp(name, cvars[i]-&gt;name))
      return i;

  return -1;
}
</t>
<t tx="T2185">@ CON_CVarFromName

Returns a pointer to the console variable with the given name, or NULL if
it doesn't exist.
-ES- 1999/07/25 Added this.
@c

cvar_t *CON_CVarPtrFromName(const char *name)
{
  int i;

  for (i = 0; i &lt; num_cvars; i++)
    if (!stricmp(name, cvars[i]-&gt;name))
      return cvars[i];

  return NULL;
}
</t>
<t tx="T2186">
const void *CON_CVarGetValue(const cvar_t * var)
{
  const void *ret;

  var-&gt;type-&gt;get_value(var-&gt;value, &amp;ret);

  return ret;
}
</t>
<t tx="T2187">
boolean_t CON_GetCVar(const char *name, const void **value)
{
  cvar_t *var;

  var = CON_CVarPtrFromName(name);

  if (!var || !(var-&gt;flags &amp; cf_read))
  {
    *value = NULL;
    return false;
  }

  *value = CON_CVarGetValue(var);

  return true;
}
</t>
<t tx="T2188">
boolean_t CON_CreateCVar(const char *name, cflag_t flags, const cvartype_t * type, void *value)
{
  cvar_t *var = CON_CVarPtrFromName(name);

  if (var)
  {
    // the variable already existed, check if we can redefine it
    if (!(var-&gt;flags &amp; cf_write))
      return false;

    Z_Free(var-&gt;name);
  }
  else
  {
    // it didn't already exist, so we create a new one
    Z_Resize(cvars, cvar_t *, ++num_cvars);
    var = cvars[num_cvars - 1] = Z_New(cvar_t, 1);
  }

  var-&gt;name = Z_StrDup(name);

  var-&gt;flags = flags;
  var-&gt;value = value;
  var-&gt;type = type;

  return true;
}
</t>
<t tx="T2189">
boolean_t CON_SetCVar(const char *name, const char *value)
{
  cvar_t *var;

  var = CON_CVarPtrFromName(name);
  if (!var)
    return false;

  if (var-&gt;flags &amp; cf_write)
  {
    return var-&gt;type-&gt;set_value(var, 1, &amp;value);
  }

  return false;
}
</t>
<t tx="T2190">
boolean_t CON_DeleteCVar(const char *name)
{
  int i = CON_CVarIndexFromName(name);

  if (i == -1 || !(cvars[i]-&gt;flags &amp; cf_delete))
    return false;

  cvars[i]-&gt;type-&gt;kill_value(cvars[i]);

  if (cvars[i]-&gt;flags &amp; cf_mem)
    Z_Free(cvars[i]-&gt;value);

  Z_Free(cvars[i]-&gt;name);
  Z_Free(cvars[i]);

  Z_MoveData(&amp;cvars[i], &amp;cvars[i + 1], cvar_t *, --num_cvars - i);

  return true;
}
</t>
<t tx="T2191">
boolean_t CON_CreateCVarBool(const char *name, cflag_t flags, boolean_t * value)
{
  if (!value)
  {
    value = Z_New(boolean_t, 1);
    flags |= cf_mem;
    *value = false;
  }

  return CON_CreateCVar(name, flags, &amp;cvar_bool, value);
}
</t>
<t tx="T2192">
boolean_t CON_CreateCVarInt(const char *name, cflag_t flags, int *value)
{
  if (!value)
  {
    value = Z_New(int, 1);

    flags |= cf_mem;
    *value = 0;
  }

  return CON_CreateCVar(name, flags, &amp;cvar_int, value);
}
</t>
<t tx="T2193">
boolean_t CON_CreateCVarReal(const char *name, cflag_t flags, float_t * value)
{
  if (!value)
  {
    value = Z_New(float_t, 1);
    *value = 0;
    flags |= cf_mem;
  }

  return CON_CreateCVar(name, flags, &amp;cvar_real, value);
}
</t>
<t tx="T2194">@ CON_CreateCVarStr

maxlen shows the maximum string length of value. At least maxlen+1
characters must be allocated.
@c

boolean_t CON_CreateCVarStr(const char *name, cflag_t flags, char *value, int maxlen)
{
  cvar_str_t *v;

  v = Z_New(cvar_str_t, 1);

  if (value)
  {
    v-&gt;maxlen = maxlen;
    v-&gt;val = value;
  }
  else
  {
    flags |= cf_mem;
    v-&gt;maxlen = -1;
    v-&gt;val = Z_New(char, 16);
    v-&gt;val[0] = 0;
  }

  return CON_CreateCVar(name, flags, &amp;cvar_str, v);
}
</t>
<t tx="T2195">@ CON_CreateCVarEnum

Names: comma-separated list of names for the enum values.
Num: Number of possible enum values.

For example: If the enum direction_e would be defined like
typedef enum {left,right,forward,backward,NUM_DIRECTIONS} direction_e;
then names would be "left,right,forward,backward" and num would be
NUM_DIRECTIONS.

-ACB- 1999/09/23 Removed alloca() references (not portable).
Replaced with malloc with Z_New. Don't waste mem.
@c

boolean_t CON_CreateCVarEnum(const char *name, cflag_t flags, void *value, const char *names, int num)
{
  cvar_enum_t *v;
  int i;
  char *s;
  char *n;
  
  n = Z_StrDup(names);

  v = Z_New(cvar_enum_t, 1);

  v-&gt;typenam = Z_New(char, strlen(names) + 8);
  sprintf(v-&gt;typenam, "enum (%s)", names);

  v-&gt;num = num;
  v-&gt;names = Z_New(char *, num);

  for (i = 0, s = strtok(n, "/"); s; s = strtok(NULL, "/"), i++)
  {
    if (i &gt;= num)
      I_Error("CON_CreateCVarEnum: %s has more than %d elements!", v-&gt;typenam, num);
    
    v-&gt;names[i] = Z_StrDup(s);
  }
  if (i &lt; num)
    I_Error("CON_CreateCVarEnum: %s has less than %d elements!", v-&gt;typenam, num);

  if (value)
    v-&gt;value = (int *)value;
  else
  {
    v-&gt;value = Z_New(int, 1);

    *(v-&gt;value) = 0;
    flags |= cf_mem;
  }

  // free mem after use
  // FIXME: use heap as much as possible. strtok functions to be rewritten
  Z_Free(n);

  return CON_CreateCVar(name, flags, &amp;cvar_enum, v);
}
</t>
<t tx="T2196">@ CON_AddCVarCallback
@c

void CON_AddCVarCallback(cvar_t * var, void (*callback) (cvar_t * var, void *user), void *user, void (*kill_user) (void *))
{
  cvar_callback_t *data;

  data = Z_New(cvar_callback_t, 1);
  data-&gt;type = var-&gt;type;
  data-&gt;value = var-&gt;value;
  data-&gt;callback = callback;

  data-&gt;user = user;
  data-&gt;kill_user = kill_user;

  var-&gt;type = &amp;cvar_callback;
  var-&gt;value = data;
}
</t>
<t tx="T2197">@ Function list:
This is used for handling functions which there can be different versions
of to choose between. The typical example is the 8-bit column renderers
(R_DrawColumn8_*), which there both are different C versions and different
Assembler optimised versions of. This is an attempt to a general way of
handling such functions.
There are restrictions on the function: It should not have any parameters,
and it should not return anything. That should instead be done via global
variables.
The function list will mostly be stored in a cvar, which will be an
extendable enum, with an extra callback hooked in.
@c

static void UpdateFunctionList(cvar_t *cvar GCCATTR(unused), void *data)
{
  funclist_t *fl = data;
  function_t *f = fl-&gt;funcs[fl-&gt;current];

  if (fl-&gt;dest)
    *(fl-&gt;dest) = f-&gt;func;

  if (f-&gt;onchange)
    f-&gt;onchange(fl);
}
</t>
<t tx="T2198">@ CON_ChooseFunctionFromList

Sets the list's active function to the one named funcname.
@c

void CON_ChooseFunctionFromList(funclist_t *fl, const char *funcname)
{
  int i;

  if (fl-&gt;cvar)
  {
    // this will update the cvar, but also choose the right function through
    // a callback
    CON_SetCVar(fl-&gt;cvar-&gt;name, funcname);
  }
  else
  {
    // search for it
    for (i = 0; stricmp(fl-&gt;funcs[i]-&gt;name, funcname); i++)
      if (i &gt;= fl-&gt;num)
        I_Error("CON_ChooseFunctionFromList: No function called \"%s\"", funcname);

    fl-&gt;current = i;
    UpdateFunctionList(NULL, fl);
  }
}
</t>
<t tx="T2199">@ CON_InitFunctionList

Initialises a newly allocated function list fl, so it can be used.
There must be at least one function, which also is the default one.
This is typically the simplest C version of the routine, e.g.
R_DrawColumn8_CVersion.
If cvarname is not NULL, a cvar with that name will be created, as an
enum with all the function names.
@c

void CON_InitFunctionList(funclist_t * fl, const char *cvarname, void (*default_func) (void), void (*onchange) (funclist_t *))
{
  function_t *f;

  fl-&gt;funcs = Z_New(function_t *, 1);
  f = Z_New(function_t, 1);
  f-&gt;func = default_func;
  f-&gt;onchange = onchange;
  f-&gt;name = Z_StrDup("default");
  f-&gt;description = Z_StrDup("The default routine");
  fl-&gt;funcs[0] = f;
  // start without destination ptr
  fl-&gt;dest = NULL;
  fl-&gt;num = 1;
  // start with the default function.
  fl-&gt;current = 0;

  if (cvarname &amp;&amp; CON_CreateCVarEnum(cvarname, cf_normal, &amp;fl-&gt;current, "default", 1))
  {
    fl-&gt;cvar = CON_CVarPtrFromName(cvarname);
    fl-&gt;donttouch = fl-&gt;cvar-&gt;value;
    CON_AddCVarCallback(fl-&gt;cvar, UpdateFunctionList, fl, NULL);
  }
  else
  {
    fl-&gt;cvar = NULL;
    fl-&gt;donttouch = NULL;
  }
}
</t>
<t tx="T2200">@ CON_SetFunclistDest

Sets the destination pointer, which always will be updated to
the active function. If NULL is passed, no funcion pointer will be updated.
@c

void CON_SetFunclistDest(funclist_t * fl, void (**dest) (void))
{
  fl-&gt;dest = dest;
  UpdateFunctionList(NULL, fl);
}
</t>
<t tx="T2201">@ CON_AddFunctionToList

Adds a func to the list fl. It will be referenced as the passed name.
@c

void CON_AddFunctionToList(funclist_t * fl, const char *name, const char *description, void (*func) (void), void (*onchange) (funclist_t *))
{
  function_t *f;

#ifdef DEVELOPERS
  int i;

  // check if it already exists in the list
  for (i = 0; i &lt; fl-&gt;num; i++)
  {
    if (!stricmp(fl-&gt;funcs[i]-&gt;name, name))
      I_Error("CON_AddFunctionToList: %s already exists!",fl-&gt;funcs[i]-&gt;name);
  }
#endif

  Z_Resize(fl-&gt;funcs, function_t *, ++fl-&gt;num);
  f = Z_New(function_t, 1);
  f-&gt;func = func;
  f-&gt;onchange = onchange;
  f-&gt;name = Z_StrDup(name);
  f-&gt;description = Z_StrDup(description);

  fl-&gt;funcs[fl-&gt;num - 1] = f;

  if (fl-&gt;cvar)
  {
    // here's the only place we may touch 'donttouch'
    CON_AddValueToEnum(fl-&gt;donttouch, name);
  }
}
</t>
<t tx="T2202">@ignore
@language c

// Console Main

&lt;&lt; con_main #includes &gt;&gt;
&lt;&lt; con_main declarations &gt;&gt;
@others
</t>
<t tx="T2203">#include "i_defs.h"
#include "con_main.h"

#include "con_defs.h"
#include "dm_state.h"
#include "dm_defs.h"
#include "gui_gui.h"
#include "gui_ctls.h"
#include "s_sound.h"
#include "v_res.h"
#include "w_wad.h"
#include "z_zone.h"
#include "m_menu.h"
</t>
<t tx="T2204">
#define SCREENROWS 100
#define SCREENCOLS 80
#define BACKBUFFER 10

typedef struct
{
  char *name;
  int flags;
  int (*cmd) (const char *arg);
}
con_cmd_t;

int CON_CMDToggleMouse(const char *args);
int CON_CMDHelloWorld(const char *args);
int CON_CMDEat(const char *args);
int CON_CMDExec(const char *args);
int CON_CMDArgText(const char *args);
int CON_CMDType(const char *args);
int CON_CMDTypeOf(const char *args);
int CON_CMDSet(const char *args);
int CON_CMDWatch(const char *args);
int CON_CMDQuitEDGE(const char *args);
#ifdef LEAK_HUNT
int CON_CMDLeakInfo(const char *args);
#endif
int CON_CMDCrc(const char *args);
int CON_CMDPlaySound(const char *args);

boolean_t CON_CMDHelloWorldResponder(gui_t * gui, guievent_t * ev);

// Current console commands.  Needs extending badly.
// 'Builtin' commands should be added here
// TODO: add another file (i_exec.c) that can load in
//   'external' commands.  On a real operating system,
//   these 'external' commands could be loaded in using
//   dynamic linking, on DOS they must be linked statically.
con_cmd_t consolecommands[] =
{
    {"args", 0, CON_CMDArgText},
    {"crc", 0, CON_CMDCrc},
    {"playsound", 0, CON_CMDPlaySound},
    {"eat", 0, CON_CMDEat},
    {"exec", 0, CON_CMDExec},
#ifdef LEAK_HUNT
    {"leakinfo", 0, CON_CMDLeakInfo},
#endif
    {"mouse", 0, CON_CMDToggleMouse},
    {"set", 0, CON_CMDSet},
    {"test", 0, CON_CMDHelloWorld},
    {"type", 0, CON_CMDType},
    {"typeof", 0, CON_CMDTypeOf},
    {"quit", 0, CON_CMDQuitEDGE},
    {"watch", 0, CON_CMDWatch},
};
</t>
<t tx="T2205">
static int GetArgs(const char *args, int argc, char **argv)
{
  int i, j, k = 0, m;
  const int len = strlen(args);
  char *s;
  int quote;

  // skip any leading spaces
  for (i = 0; args[i] == ' '; i++)
    ;

  for (; i &lt; len; i = j)
  {
    // find end of arg
    if (args[i] == '\"')
    {
      quote = 1;
      i++;
      for (j = i; args[j] != '\"' &amp;&amp; j &lt; len; j++)
        ;
    } else
    {
      quote = 0;
      for (j = i; args[j] != ' ' &amp;&amp; j &lt; len; j++)
        ;
    }

    s = Z_New(char, j - i + 1);
    for (m = 0; m &lt; j - i; m++)
    {
      // -ES- 1999/07/25 Convert to lowercase, to avoid case sensitivity
      s[m] = tolower(args[i + m]);
    }
    s[j - i] = '\0';

    argv[k] = s;

    if (++k == argc)
      break;

    if (quote)
      // skip the ending quote
      j++;

    // skip whitespace until the next arg
    while (args[j] == ' ' &amp;&amp; j &lt; len)
      j++;
  }

  return k;
}
</t>
<t tx="T2206">
static void KillArgs(int argc, char *(argv[]))
{
  int i;

  for (i = 0; i &lt; argc; i++)
    Z_Free(argv[i]);
}
</t>
<t tx="T2207">void CON_TryCommand(const char *cmd)
{
  int i, j, e;
  char *s;
  const char *c;

  while (isspace(*cmd))
    cmd++;

  if (strlen(cmd) == 0)
    return;
  
  for (i = sizeof(consolecommands) / sizeof(consolecommands[0]); i--;)
  {
    s = consolecommands[i].name;
    c = cmd;
    for (j = strlen(consolecommands[i].name); j--; s++, c++)
      if (*s != *c)
        break;
    if (j == -1 &amp;&amp; (!*c || *c == ' '))
    {
      e = consolecommands[i].cmd(cmd);
      if (e)
        CON_Printf("Error %d\n", e);
      return;
    }
  }
  CON_Printf("Bad Command.\n");
}
</t>
<t tx="T2208">
int CON_CMDToggleMouse(const char *args GCCATTR(unused))
{
  boolean_t vis = !GUI_MainGetMouseVisibility();

  GUI_MainSetMouseVisibility(vis);
  CON_Printf("Mouse: %s\n", vis ? "on" : "off");
  return 0;
}
</t>
<t tx="T2209">
boolean_t CON_CMDHelloWorldResponder(gui_t * gui, guievent_t * ev)
{
  switch (ev-&gt;type)
  {
    case 112:
      GUI_Destroy(gui);
      return true;
    default:
      return false;
  }
}
</t>
<t tx="T2210">
int CON_CMDHelloWorld(const char *args GCCATTR(unused))
{
  gui_t *gui = Z_ClearNew(gui_t, 1);
  gui-&gt;Responder = &amp;CON_CMDHelloWorldResponder;
  GUI_Start(GUI_NULL(), gui);
  gui-&gt;process = GUI_MSGStart(GUI_NULL(), gui, 112, 0, "Hello World");
  return 0;
}
</t>
<t tx="T2211">
int CON_CMDExec(const char *args)
{
  FILE *script;
  int argc;
  char *argv[2];
  char buffer[SCREENCOLS];

  argc = GetArgs(args, 2, argv);

  if (!argc)
    return 1;

  if (argc != 2)
  {
    CON_Printf("Usage: exec &lt;script name.cfg&gt;\n");
    KillArgs(argc, argv);
    return 1;
  }

  script = fopen(argv[1], "rb");
  if (!script)
  {
    CON_Printf("Unable to open \'%s\'!\n", argv[1]);
    KillArgs(argc, argv);
    return 1;
  }
  while (fgets(buffer, SCREENCOLS - 1, script))
  {
    CON_TryCommand(buffer);
  }
  fclose(script);
  KillArgs(argc, argv);
  return 0;
}
</t>
<t tx="T2212">
int CON_CMDType(const char *args)
{
  FILE *script;
  int argc;
  char *argv[2];
  char buffer[SCREENCOLS];

  argc = GetArgs(args, 2, argv);

  if (!argc)
    return 1;

  if (argc != 2)
  {
    CON_Printf("Usage: type &lt;file name.txt&gt;\n");
    KillArgs(argc, argv);
    return 2;
  }

  script = fopen(argv[1], "r");
  if (!script)
  {
    CON_Printf("Unable to open \'%s\'!\n", argv[1]);
    KillArgs(argc, argv);
    return 3;
  }
  while (fgets(buffer, SCREENCOLS - 1, script))
  {
    CON_Printf(buffer);
  }
  fclose(script);
  KillArgs(argc, argv);
  return 0;
}
</t>
<t tx="T2213">
int CON_CMDArgText(const char *args)
{
  int argc;
  int i;
  char *(argv[10]);

  argc = GetArgs(args, 10, argv);

  for (i = 0; i &lt; argc; i++)
    CON_Printf("%d:(%d) \"%s\"\n", i, (int)strlen(argv[i]), argv[i]);

  KillArgs(argc, argv);
  return 0;
}
</t>
<t tx="T2214">@ Eats memory.
@c

int CON_CMDEat(const char *args)
{
  int argc;
  char *argv[2];
  int bytes;
  static char *p = NULL;

  argc = GetArgs(args, 2, argv);
  if (!argc)
    return 1;

  if (argc != 2 || 1 != sscanf(argv[1], "%d", &amp;bytes))
  {
    CON_Printf("Eat memory. Usage: eat &lt;size&gt;\n");
    KillArgs(argc, argv);
    return 2;
  }

  if (!bytes)
  {
    Z_Free(p);
    p = NULL;
  }
  else
    Z_Resize(p, char, bytes);

  return 0;
}
</t>
<t tx="T2215">
#ifdef LEAK_HUNT
int CON_CMDLeakInfo(const char *args)
{
  int argc;
  char *argv[2];
  int level;

  argc = GetArgs(args, 2, argv);
  if (!argc)
    return 1;
  if (argc != 2 || 1 != sscanf(argv[1], "%d", &amp;level))
  {
    CON_Printf("Usage: leakinfo &lt;level&gt;\n");
    KillArgs(argc, argv);
    return 2;
  }

  Z_DumpLeakInfo(level);
  I_Printf("Memory leak info written to file 'leakinfo'\n");
  KillArgs(argc, argv);
  return 0;
}
</t>
<t tx="T2216">#endif

int CON_CMDSet(const char *args)
{
  int argc;
  cvar_t *var;
  // temp argv: Just to handle 'const' keyword properly
  char *tmpargv[3];
  const char *argv[3];
  int i;
  int e = 0;
  char buf[1025];

  argc = GetArgs(args, 3, tmpargv);

  for (i = 0; i &lt; argc; i++)
    argv[i] = tmpargv[i];

  switch (argc)
  {
    case 2:
    case 1:
      for (i = 0; i &lt; num_cvars; i++)
      {
        if (argc == 2)
          if (stricmp(argv[1], cvars[i]-&gt;name))
            continue;
        if (cvars[i]-&gt;flags &amp; cf_read)
        {
          cvars[i]-&gt;type-&gt;get_value_str(cvars[i]-&gt;value, buf);
          CON_Printf("%s = %s\n", cvars[i]-&gt;name, buf);
        }
        else
          CON_Printf("%s (Write Only)\n", cvars[i]-&gt;name);
        if (argc == 2)
          break;
      }
      if (i == num_cvars &amp;&amp; argc == 2)
      {  // not found

        CON_Printf("No cvar '%s'!\n", argv[1]);
        e = 3;
      }
      break;
    default:
      var = CON_CVarPtrFromName(argv[1]);
      if (var)
      {
        if (!strlen(argv[2]) &amp;&amp; var-&gt;flags &amp; cf_delete)
          CON_DeleteCVar(argv[1]);
        else
        {
          if (var-&gt;flags &amp; cf_write)
          {
            if (!var-&gt;type-&gt;set_value(var, argc - 2, &amp;argv[2]))
              e = 1, CON_Printf("\"%s\" is not a valid value for type %s\n", argv[2], var-&gt;type-&gt;get_name(var));
          }
          else
            e = 2, CON_Printf("\"%s\" is read only\n", var-&gt;name);
        }
      }
      else
      {
        if (argv[2][0] &gt;= '0' &amp;&amp; argv[2][0] &lt;= '9')
        {
          int *x = Z_New(int, 1);

          *x = strtol(argv[2], NULL, 0);
          CON_CreateCVarInt(argv[1], cf_delete | cf_mem | cf_normal, x);
        }
        else if (!strcmp(argv[2], "true") || !strcmp(argv[2], "false"))
        {
          boolean_t *b = Z_New(boolean_t, 1);

          *b = !strcmp(argv[2], "true");
          CON_CreateCVarBool(argv[1], cf_delete | cf_mem | cf_normal, b);
        }
        else
        {
          char *s = Z_New(char, 256);

          strcpy(s, argv[2]);
          CON_CreateCVarStr(argv[1], cf_delete | cf_mem | cf_normal, s, 255);
        }
      }
      break;
  }

  KillArgs(argc, tmpargv);
  return e;
}
</t>
<t tx="T2217">
int CON_CMDTypeOf(const char *args)
{
  cvar_t *v;
  char *argv[2];
  int argc;
  int e;

  argc = GetArgs(args, 2, argv);

  if (argc &lt; 2)
  {
    CON_Printf("Usage: Typeof &lt;cvar&gt;\n");
    e = 1;
  }
  else
  {
    v = CON_CVarPtrFromName(argv[1]);

    if (v)
    {
      CON_Printf("The type of \"%s\" is \"%s\"\n", v-&gt;name, v-&gt;type-&gt;get_name(v));
      e = 0;
    }
    else
    {
      CON_Printf("No console variable called \"%s\"!\n", args);
      e = 2;
    }
  }

  KillArgs(argc, argv);

  return e;
}
</t>
<t tx="T2218">
int CON_CMDWatch(const char *args)
{
  int argc;
  char *argv[3];

  argc = GetArgs(args, 3, argv);

  if (argc != 3)
  {
    CON_Printf("Usage: watch &lt;cvar&gt; &lt;max&gt;\n");
    return 1;
  }

  GUI_BARStart(GUI_NULL(), argv[1], strtol(argv[2], NULL, 0));

  KillArgs(argc, argv);
  return 0;
}
</t>
<t tx="T2219">
int CON_CMDQuitEDGE(const char *args GCCATTR(unused))
{
  M_QuitEDGE(0);

  return 0;
}
</t>
<t tx="T2220">
int CON_CMDCrc(const char *args)
{
  int argc;
  char *argv[3];

  int lump, length;
  const byte *data;

  unsigned long crc;
  
  argc = GetArgs(args, 2, argv);

  if (argc != 2)
  {
    CON_Printf("Usage: crc &lt;lump&gt;\n");
    return 1;
  }

  lump = W_CheckNumForName(argv[1]);

  if (lump == -1)
  {
    CON_Printf("No such lump: %s\n", argv[1]);
  }
  else
  {
    data = W_CacheLumpNum(lump);
    length = W_LumpLength(lump);

    CRC32_Init(&amp;crc);
    CRC32_ProcessBlock(&amp;crc, data, length);
    CRC32_Done(&amp;crc);

    W_DoneWithLump(data);

    CON_Printf("  %s  %d bytes  crc = %08lx\n", argv[1], length, crc);
  }

  KillArgs(argc, argv);
  return 0;
}
</t>
<t tx="T2221">
int CON_CMDPlaySound(const char *args)
{
  int argc;
  char *argv[3];

  sfx_t *sfx;

  argc = GetArgs(args, 2, argv);

  if (argc != 2)
  {
    CON_Printf("Usage: playsound &lt;name&gt;\n");
    return 1;
  }

  sfx = DDF_SfxLookupSound(argv[1]);

  if (! sfx)
  {
    CON_Printf("No such sound: %s\n", argv[1]);
  }
  else
  {
    S_StartSound(NULL, sfx);
  }

  KillArgs(argc, argv);
  return 0;
}
</t>
<t tx="T2222">@ CON_PlayerMessage

-ACB- 1999/09/22 Console Player Message Only. Changed from
#define to procedure because of compiler
differences.
@c

void CON_PlayerMessage(player_t *plyr, const char *message, ...)
{
  va_list argptr;
  char buffer[256];

  if (consoleplayer != plyr)
    return;

  Z_Clear(buffer, char, 256);

  va_start(argptr, message);
  vsprintf(buffer, message, argptr);
  va_end(argptr);
  
  CON_Message("%s", buffer);
}
</t>
<t tx="T2223">@ CON_PlayerMessageLDF

-ACB- 1999/09/22 Console Player Message Only. Changed from
#define to procedure because of compiler
differences.
@c

void CON_PlayerMessageLDF(player_t *plyr, const char *lookup, ...)
{
  va_list argptr;
  char buffer[256];

  if (consoleplayer != plyr)
    return;

  Z_Clear(buffer, char, 256);

  va_start(argptr, lookup);
  vsprintf(buffer, DDF_LanguageLookup(lookup), argptr);
  va_end(argptr);
  
  CON_Message("%s", buffer);
}
</t>
<t tx="T2224">@ignore
@language c

// Data Definition File Code (Animated textures)

// Animated Texture/Flat Setup and Parser Code

&lt;&lt; ddf_anim #includes &gt;&gt;
&lt;&lt; ddf_anim declarations &gt;&gt;
@others
</t>
<t tx="T2225">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "p_spec.h"
#include "r_local.h"
#include "z_zone.h"
</t>
<t tx="T2226">
#undef  DF
#define DF  DDF_CMD

static animdef_t buffer_anim;
static animdef_t *dynamic_anim;

static const animdef_t template_anim =
{
  DDF_BASE_NIL,  // ddf

  true,  // istexture
  "",    // endname
  "",    // startname
  8,     // speed
};

static void DDF_AnimGetType(const char *info, void *storage);

// -ACB- 1998/08/10 Use DDF_MainGetLumpName for getting the..lump name.
// -KM- 1998/09/27 Use DDF_MainGetTime for getting tics

#define DDF_CMD_BASE  buffer_anim

static const commandlist_t anim_commands[] =
{
  DF("TYPE",   istexture, DDF_AnimGetType),
  DF("SPEED",  speed,     DDF_MainGetTime),
  DF("FIRST",  startname, DDF_MainGetInlineStr10),
  DF("LAST",   endname,   DDF_MainGetInlineStr10),

  DDF_CMD_END
};

// Floor/ceiling animation sequences, defined by first and last frame,
// i.e. the flat (64x64 tile) name or texture name to be used.
//
// The full animation sequence is given using all the flats between
// the start and end entry, in the order found in the WAD file.

animdef_t ** animdefs = NULL;
int numanimdefs = 0;

static stack_array_t animdefs_a;
</t>
<t tx="T2227">@ DDF PARSE ROUTINES
@c

static boolean_t AnimStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=0; i &lt; numanimdefs; i++)
    {
      if (DDF_CompareName(animdefs[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_anim = animdefs[i];
        replaces = true;
        break;
      }
    }
    
    // if found, adjust pointer array to keep newest entries at end
    if (replaces &amp;&amp; i &lt; (numanimdefs-1))
    {
      Z_MoveData(animdefs + i, animdefs + i + 1, animdef_t *,
          numanimdefs - i);
      animdefs[numanimdefs - 1] = dynamic_anim;
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;animdefs_a, ++numanimdefs);

    dynamic_anim = animdefs[numanimdefs - 1];
    dynamic_anim-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_ANIM", numanimdefs);
  }

  dynamic_anim-&gt;ddf.number = 0;

  // instantiate the static entry
  buffer_anim = template_anim;

  return replaces;
}
</t>
<t tx="T2228">
static void AnimParseField(const char *field, const char *contents,
    int index GCCATTR(unused), boolean_t is_last GCCATTR(unused))
{
#if (DEBUG_DDF)  
  L_WriteDebug("ANIM_PARSE: %s = %s;\n", field, contents);
#endif

  if (! DDF_MainParseField(anim_commands, field, contents))
    DDF_WarnError("Unknown anims.ddf command: %s\n", field);
}
</t>
<t tx="T2229">
static void AnimFinishEntry(void)
{
  ddf_base_t base;
  
  if (buffer_anim.speed &lt;= 0)
  {
    DDF_WarnError("Bad TICS value for anim: %d\n", buffer_anim.speed);
    buffer_anim.speed = 8;
  }
  
  if (!buffer_anim.startname || !buffer_anim.startname[0])
    DDF_Error("Missing first name for anim.\n");

  if (!buffer_anim.startname || !buffer_anim.startname[0])
    DDF_Error("Missing last name for anim.\n");
  
  // transfer static entry to dynamic entry
  
  base = dynamic_anim-&gt;ddf;
  dynamic_anim[0] = buffer_anim;
  dynamic_anim-&gt;ddf = base;

  // Compute CRC.  In this case, there is no need, since animations
  // have zero impact on the game simulation.
  dynamic_anim-&gt;ddf.crc = 0;
}
</t>
<t tx="T2230">
static void AnimClearAll(void)
{
  // safe to just delete all animations

  numanimdefs = 0;
  Z_SetArraySize(&amp;animdefs_a, numanimdefs);
}
</t>
<t tx="T2231">

void DDF_ReadAnims(void *data, int size)
{
  readinfo_t anims;

  anims.memfile = data;
  anims.memsize = size;
  anims.tag = "ANIMATIONS";
  anims.entries_per_dot = 2;

  if (anims.memfile)
  {
    anims.message = NULL;
    anims.filename = NULL;
    anims.lumpname = "DDFANIM";
  }
  else
  {
    anims.message = "DDF_InitAnimations";
    anims.filename = "anims.ddf";
    anims.lumpname = NULL;
  }

  anims.start_entry  = AnimStartEntry;
  anims.parse_field  = AnimParseField;
  anims.finish_entry = AnimFinishEntry;
  anims.clear_all    = AnimClearAll;

  DDF_MainReadFile(&amp;anims);
}
</t>
<t tx="T2232">
void DDF_AnimInit(void)
{
  Z_InitStackArray(&amp;animdefs_a, (void ***)&amp;animdefs, sizeof(animdef_t), 0);
}
</t>
<t tx="T2233">
void DDF_AnimCleanUp(void)
{
  /* nothing to do */
}
</t>
<t tx="T2234">@ DDF_AnimGetType
@c

static void DDF_AnimGetType(const char *info, void *storage)
{
  boolean_t *is_tex = (boolean_t *) storage;
  
  DEV_ASSERT2(storage);

  if (DDF_CompareName(info, "FLAT") == 0)
    (*is_tex) = false;
  else if (DDF_CompareName(info, "TEXTURE") == 0)
    (*is_tex) = true;
  else
  {
    DDF_WarnError("Unknown animation type: %s\n", info);
    (*is_tex) = false;
  }
}
</t>
<t tx="T2235">@ignore
@language c

// Data Definition File Code (Attack Types)

// Attacks Setup and Parser Code

// 1998/10/29 -KM- Finalisation of sound code.  SmartProjectile.

&lt;&lt; ddf_atk #includes &gt;&gt;
&lt;&lt; ddf_atk declarations &gt;&gt;
@others
</t>
<t tx="T2236">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "m_fixed.h"
#include "m_math.h"
#include "p_mobj.h"
#include "z_zone.h"
</t>
<t tx="T2237">
#undef  DF
#define DF  DDF_CMD

static attacktype_t buffer_atk;
static attacktype_t *dynamic_atk;

// this (and buffer_mobj) logically belongs with buffer_atk:
static boolean_t attack_has_mobj;
static float_t a_damage_range;
static float_t a_damage_multi;

static const attacktype_t template_atk =
{
  DDF_BASE_NIL,  // ddf

  0,        // attackstyle
  0,        // flags
  NULL,     // initsound
  NULL,     // sound
  0,        // accuracy slope
  0,        // accuracy angle
  0,        // xoffset
  0,        // yoffset
  0,        // angle_offset
  0,        // slope_offset
  0,        // assault_speed
  0,        // height
  0,        // range
  0,        // count
  0,        // tooclose

  // damage info
  {
    0,      // nominal
    -1,     // linear_max
    -1,     // error
    0,      // delay
    NULL_LABEL, NULL_LABEL, NULL_LABEL,  // override labels
    false   // no_armour
  },

  BITSET_EMPTY, // attack_class
  0,        // objinitstate
  NULL,     // objinitstate_ref
  PERCENT_MAKE(0), // notracechance
  PERCENT_MAKE(0), // keepfirechance
  NULL,     // atk_mobj
  NULL,     // spawnedobj
  NULL,     // spawnedobj_ref
  NULL,     // puff
  NULL      // puff_ref
};

attacktype_t ** ddf_attacks = NULL;
int num_ddf_attacks = 0;
int num_disabled_attacks = 0;

static stack_array_t ddf_attacks_a;


static void DDF_AtkGetType(const char *info, void *storage);
static void DDF_AtkGetSpecial(const char *info, void *storage);
static void DDF_AtkGetLabel(const char *info, void *storage);

static damage_t dummy_damage;

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_damage

const commandlist_t damage_commands[] =
{
  DDF_CMD_SUB("VAL", nominal,    DDF_MainGetFloat),
  DDF_CMD_SUB("MAX", linear_max, DDF_MainGetFloat),
  DDF_CMD_SUB("ERROR", error, DDF_MainGetFloat),
  DDF_CMD_SUB("DELAY", delay, DDF_MainGetTime),

  DDF_CMD_SUB("PAIN STATE", pain, DDF_AtkGetLabel),
  DDF_CMD_SUB("DEATH STATE", death, DDF_AtkGetLabel),
  DDF_CMD_SUB("OVERKILL STATE", overkill, DDF_AtkGetLabel),

  DDF_CMD_END
};

// -KM- 1998/09/27 Major changes to sound handling
// -KM- 1998/11/25 Accuracy + Translucency are now fraction.  Added a spare attack for BFG.
// -KM- 1999/01/29 Merged in thing commands, so there is one list of
//  thing commands for all types of things (scenery, items, creatures + projectiles)

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_atk

static const commandlist_t attack_commands[] =
{
  // sub-commands
  DDF_SUB_LIST("DAMAGE", damage, damage_commands),

  DF("ATTACKTYPE", ddf, DDF_AtkGetType),
  DF("ATTACK SPECIAL", ddf, DDF_AtkGetSpecial),
  DF("ACCURACY SLOPE", accuracy_slope, DDF_MainGetSlope),
  DF("ACCURACY ANGLE", accuracy_angle, DDF_MainGetAngle),
  DF("ATTACK HEIGHT", height, DDF_MainGetFloat),
  DF("SHOTCOUNT", count, DDF_MainGetNumeric),
  DF("X OFFSET", xoffset, DDF_MainGetFloat),
  DF("Y OFFSET", yoffset, DDF_MainGetFloat),
  DF("ANGLE OFFSET", angle_offset, DDF_MainGetAngle),
  DF("SLOPE OFFSET", slope_offset, DDF_MainGetSlope),
  DF("ATTACKRANGE", range, DDF_MainGetFloat),
  DF("TOO CLOSE RANGE", tooclose, DDF_MainGetNumeric),
  DF("NO TRACE CHANCE", notracechance, DDF_MainGetPercent),
  DF("KEEP FIRING CHANCE", keepfirechance, DDF_MainGetPercent),
  DF("ASSAULT SPEED", assault_speed, DDF_MainGetFloat),
  DF("ATTEMPT SOUND", initsound, DDF_MainLookupSound),
  DF("ENGAGED SOUND", sound, DDF_MainLookupSound),
  DF("SPAWNED OBJECT", spawnedobj_ref, DDF_MainGetString),
  DF("SPAWN OBJECT STATE", objinitstate_ref, DDF_MainGetString),
  DF("PUFF", puff_ref, DDF_MainGetString),
  DF("ATTACK CLASS", attack_class, DDF_MainGetBitSet),

  // -AJA- backward compatibility cruft...
  DF("!DAMAGE", damage.nominal, DDF_MainGetFloat),
  {"!DAMAGE RANGE", DDF_MainGetFloat, &amp;a_damage_range, NULL},
  {"!DAMAGE MULTI", DDF_MainGetFloat, &amp;a_damage_multi, NULL},

  DDF_CMD_END
};
</t>
<t tx="T2238">@ DDF PARSE ROUTINES
@c

static boolean_t AttackStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=num_disabled_attacks; i &lt; num_ddf_attacks; i++)
    {
      if (DDF_CompareName(ddf_attacks[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_atk = ddf_attacks[i];
        replaces = true;
        break;
      }
    }
    
    // if found, adjust pointer array to keep newest entries at end
    if (replaces &amp;&amp; i &lt; (num_ddf_attacks-1))
    {
      Z_MoveData(ddf_attacks + i, ddf_attacks + i + 1, attacktype_t *,
          num_ddf_attacks - i);
      ddf_attacks[num_ddf_attacks - 1] = dynamic_atk;
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;ddf_attacks_a, ++num_ddf_attacks);
    
    dynamic_atk = ddf_attacks[num_ddf_attacks - 1];
    dynamic_atk-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_ATTACK", num_ddf_attacks);
  }

  dynamic_atk-&gt;ddf.number = 0;

  attack_has_mobj = false;
  a_damage_range = -1;
  a_damage_multi = -1;

  // instantiate the static entries
  buffer_atk  = template_atk;
  buffer_mobj = template_mobj;

  return replaces;
}
</t>
<t tx="T2239">
static void AttackParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("ATTACK_PARSE: %s = %s;\n", field, contents);
#endif

  // first, check attack commands
  if (DDF_MainParseField(attack_commands, field, contents))
    return;

  // we need to create an MOBJ for this attack
  attack_has_mobj = true;

  ThingParseField(field, contents, index, is_last);
}
</t>
<t tx="T2240">
static void AttackFinishEntry(void)
{
  ddf_base_t base;
  
  // FIXME: check stuff...

  // handle attacks that have mobjs
  if (attack_has_mobj)
  {
    if (buffer_mobj.first_state)
      DDF_StateFinishStates(buffer_mobj.first_state, 
          buffer_mobj.last_state);

    buffer_atk.atk_mobj = DDF_MobjMakeAttackObj(&amp;buffer_mobj,
      dynamic_atk-&gt;ddf.name);
  }
  else
    buffer_atk.atk_mobj = NULL;
  
  // compute an attack class, if none specified
  if (buffer_atk.attack_class == BITSET_EMPTY)
  {
    buffer_atk.attack_class = attack_has_mobj ? BITSET_MAKE('M') : 
        (buffer_atk.attackstyle == ATK_CLOSECOMBAT ||
         buffer_atk.attackstyle == ATK_SKULLFLY) ? 
        BITSET_MAKE('C') : BITSET_MAKE('B');
  }

  // -AJA- 2001/01/27: Backwards compatibility
  if (a_damage_range &gt; 0)
  {
    buffer_atk.damage.nominal = a_damage_range;

    if (a_damage_multi &gt; 0)
      buffer_atk.damage.linear_max = a_damage_range * a_damage_multi;
  }

  // transfer static entry to dynamic entry
  
  base = dynamic_atk-&gt;ddf;
  dynamic_atk[0] = buffer_atk;
  dynamic_atk-&gt;ddf = base;

  // compute CRC...
  CRC32_Init(&amp;dynamic_atk-&gt;ddf.crc);

  // FIXME: add more stuff...

  CRC32_Done(&amp;dynamic_atk-&gt;ddf.crc);
}
</t>
<t tx="T2241">
static void AttackClearAll(void)
{
  // not safe to delete attacks -- mark as disabled
  
  num_disabled_attacks = num_ddf_attacks;
}
</t>
<t tx="T2242">

void DDF_ReadAtks(void *data, int size)
{
  readinfo_t attacks;

  attacks.memfile = data;
  attacks.memsize = size;
  attacks.tag = "ATTACKS";
  attacks.entries_per_dot = 2;

  if (attacks.memfile)
  {
    attacks.message = NULL;
    attacks.filename = NULL;
    attacks.lumpname = "DDFATK";
  }
  else
  {
    attacks.message = "DDF_InitAttacks";
    attacks.filename = "attacks.ddf";
    attacks.lumpname = NULL;
  }

  attacks.start_entry  = AttackStartEntry;
  attacks.parse_field  = AttackParseField;
  attacks.finish_entry = AttackFinishEntry;
  attacks.clear_all    = AttackClearAll;

  DDF_MainReadFile(&amp;attacks);
}
</t>
<t tx="T2243">
void DDF_AttackInit(void)
{
  Z_InitStackArray(&amp;ddf_attacks_a, (void ***)&amp;ddf_attacks, sizeof(attacktype_t), 0);
}
</t>
<t tx="T2244">
void DDF_AttackCleanUp(void)
{
  int i;
  attacktype_t *atk;

  for (i=num_disabled_attacks; i &lt; num_ddf_attacks; i++)
  {
    atk = ddf_attacks[i];
    
    DDF_ErrorSetEntryName("[%s]  (attacks.ddf)", atk-&gt;ddf.name);

    // lookup thing references

    atk-&gt;puff = atk-&gt;puff_ref ? DDF_MobjLookup(atk-&gt;puff_ref) : NULL;

    atk-&gt;spawnedobj = atk-&gt;spawnedobj_ref ? 
        DDF_MobjLookup(atk-&gt;spawnedobj_ref) : NULL;
      
    if (atk-&gt;spawnedobj)
    {
      if (atk-&gt;objinitstate_ref)
        atk-&gt;objinitstate = DDF_MainLookupDirector(
            atk-&gt;spawnedobj, atk-&gt;objinitstate_ref);
      else
        atk-&gt;objinitstate = atk-&gt;spawnedobj-&gt;spawn_state;
    }

    DDF_ErrorClearEntryName();
  }
}
</t>
<t tx="T2245">
static const specflags_t attack_specials[] =
{
    {"SMOKING TRACER", AF_TraceSmoke, 0},
    {"KILL FAILED SPAWN", AF_KillFailedSpawn, 0},
    {"REMOVE FAILED SPAWN", AF_KillFailedSpawn, 1},
    {"PRESTEP SPAWN", AF_PrestepSpawn, 0},
    {"SPAWN TELEFRAGS", AF_SpawnTelefrags, 0},
    {"NEED SIGHT", AF_NeedSight, 0},
    {"FACE TARGET", AF_FaceTarget, 0},
    {"FORCE AIM", AF_ForceAim, 0},
    {"ANGLED SPAWN", AF_AngledSpawn, 0},
    {"PLAYER ATTACK", AF_Player, 0},
    {"TRIGGER LINES", AF_NoTriggerLines, 1},

    // -AJA- backwards compatibility cruft...
    {"!NOAMMO", 0, 0},
    {NULL, 0, 0}
};

static void DDF_AtkGetSpecial(const char *info, void *storage)
{
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, attack_specials, &amp;flag_value,
      true, false))
  {
    case CHKF_Positive:
      buffer_atk.flags |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_atk.flags &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("DDF_AtkGetSpecials: Unknown Attack Special: %s", info);
      break;
  }
}
</t>
<t tx="T2246">@ -KM- 1998/11/25 Added new attack type for BFG: Spray
@c

static const char *attack_class[NUMATKCLASS] =
{
    "PROJECTILE",
    "SPAWNER",
    "TRIPLE SPAWNER",
    "FIXED SPREADER",
    "RANDOM SPREADER",
    "SHOT",
    "TRACKER",
    "CLOSECOMBAT",
    "SHOOTTOSPOT",
    "SKULLFLY",
    "SMARTPROJECTILE",
    "SPRAY"
};

static void DDF_AtkGetType(const char *info, void *storage)
{
  int i;

  i = 0;

  while (i != NUMATKCLASS &amp;&amp; DDF_CompareName(info, attack_class[i]))
    i++;

  if (i == NUMATKCLASS)
  {
    DDF_WarnError("DDF_AtkGetType: No such attack type '%s'\n", info);
    buffer_atk.attackstyle = ATK_SHOT;
    return;
  }
  
  buffer_atk.attackstyle = i;
}
</t>
<t tx="T2247">@ DDF_AtkGetLabel
@c

static void DDF_AtkGetLabel(const char *info, void *storage)
{
  struct label_offset_s *lab = (struct label_offset_s *)storage;

  // check for `:' in string
  const char *div = strchr(info, DIVIDE);

  int i = div ? (div - info) : strlen(info);

  if (i &lt;= 0)
    DDF_Error("Bad State `%s'.\n", info);

  lab-&gt;label = Z_New(const char, i + 1);
  Z_StrNCpy((char *)lab-&gt;label, info, i);

  lab-&gt;offset = div ? MAX(0, atoi(div+1) - 1) : 0;
}
</t>
<t tx="T2248">@ DDF_AttackLookup
@c

attacktype_t *DDF_AttackLookup(const char *name)
{
  int i;

  if (!name || !name[0])
    DDF_Error("Missing attack name !\n");

  for (i=num_disabled_attacks; i &lt; num_ddf_attacks; i++)
  {
    if (DDF_CompareName(ddf_attacks[i]-&gt;ddf.name, name) == 0)
      return ddf_attacks[i];
  }

  DDF_WarnError("Unknown Attack: %s\n", name);
  return NULL;
}
</t>
<t tx="T2249">@ignore
@language c

// Data Definition File Code (BOOM Compatibility)

&lt;&lt; ddf_boom #includes &gt;&gt;
@others
</t>
<t tx="T2250">#include "i_defs.h"

#include "ddf_main.h"

#include "e_search.h"
#include "ddf_locl.h"
#include "dm_state.h"
#include "dstrings.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_math.h"
#include "m_misc.h"
#include "p_action.h"
#include "p_mobj.h"
#include "r_things.h"
#include "z_zone.h"
</t>
<t tx="T2251">@ DDF_BoomMakeGenSector

Decodes the BOOM generalised sector number and fills in the DDF
sector type `sec' (which has already been instantiated with default
values).

NOTE: This code based on "Section 15" of BOOMREF.TXT.

-AJA- 2001/06/22: written.
@c

void DDF_BoomMakeGenSector(specialsector_t *sec, int number)
{
  // handle lower 5 bits: Lighting
  switch (number &amp; 0x1F)
  {
    case 0: // normal
      break;

    case 1: // random off
      sec-&gt;l.type = LITE_Flash;
      sec-&gt;l.chance = PERCENT_MAKE(10);
      sec-&gt;l.darktime = 8;
      sec-&gt;l.brighttime = 8;
      break;

    case 2:
    case 4: // blink 0.5 second
      sec-&gt;l.type = LITE_Strobe;
      sec-&gt;l.darktime = 15;
      sec-&gt;l.brighttime = 5;
      break;

    case 3: // blink 1.0 second
      sec-&gt;l.type = LITE_Strobe;
      sec-&gt;l.darktime = 35;
      sec-&gt;l.brighttime = 5;
      break;

    case 8: // oscillates
      sec-&gt;l.type = LITE_Glow;
      sec-&gt;l.darktime = 1;
      sec-&gt;l.brighttime = 1;
      break;

    case 12: // blink 0.5 second, sync
      sec-&gt;l.type = LITE_Strobe;
      sec-&gt;l.darktime = 15;
      sec-&gt;l.brighttime = 5;
      sec-&gt;l.sync = 20;
      break;

    case 13: // blink 1.0 second, sync
      sec-&gt;l.type = LITE_Strobe;
      sec-&gt;l.darktime = 35;
      sec-&gt;l.brighttime = 5;
      sec-&gt;l.sync = 40;
      break;

    case 17: // flickers
      sec-&gt;l.type = LITE_FireFlicker;
      sec-&gt;l.darktime = 4;
      sec-&gt;l.brighttime = 4;
      break;
  }

  // handle bits 5-6: Damage
  switch ((number &gt;&gt; 5) &amp; 0x3)
  {
    case 0: // no damage
      break;

    case 1: // 5 units
      sec-&gt;damage.nominal = 5;
      sec-&gt;damage.delay = 32;
      break;
    
    case 2: // 10 units
      sec-&gt;damage.nominal = 10;
      sec-&gt;damage.delay = 32;
      break;
      
    case 3: // 20 units
      sec-&gt;damage.nominal = 20;
      sec-&gt;damage.delay = 32;
      break;
  }
  
  // handle bit 7: Secret
  if ((number &gt;&gt; 7) &amp; 1)
    sec-&gt;secret = true;

  // ignoring bit 8: Ice/Mud effect
  
  // ignoring bit 9: Wind effect
}
</t>
<t tx="T2252">@ ----------------------------------------------------------------------------
@c

static void HandleLineTrigger(linedeftype_t *line, int trigger)
{
  if ((trigger &amp; 0x1) == 0)
    line-&gt;count = 1;
  else
    line-&gt;count = -1;

  switch (trigger &amp; 0x6)
  {
    case 0:  // W1 and WR
      line-&gt;type = line_walkable; 
      break;

    case 2:  // S1 and SR
      line-&gt;type = line_pushable; 
      break;

    case 4:  // G1 and GR
      line-&gt;type = line_shootable; 
      break;

    case 6:  // D1 and DR
      line-&gt;type = line_manual;
      break;
  }
}
</t>
<t tx="T2253">
static void MakeBoomFloor(linedeftype_t *line, int number)
{
  int speed   = (number &gt;&gt; 3) &amp; 0x3;
  int model   = (number &gt;&gt; 5) &amp; 0x1;
  int dir     = (number &gt;&gt; 6) &amp; 0x1;
  int target  = (number &gt;&gt; 7) &amp; 0x7;
  int change  = (number &gt;&gt; 10) &amp; 0x3;
  int crush   = (number &gt;&gt; 12) &amp; 0x1;

  line-&gt;obj = trig_player | ((change == 0 &amp;&amp; model) ? trig_monster : 0);

  line-&gt;f.type = mov_Once;
  line-&gt;f.dest = 0;

  if (crush)
    line-&gt;f.crush = true;

  switch (target)
  {
    case 0:  // HnF (Highest neighbour Floor)
      line-&gt;f.destref = REF_Surrounding | REF_HIGHEST;
      break;

    case 1:  // LnF (Lowest neighbour Floor)
      line-&gt;f.destref = REF_Surrounding;
      break;

    case 2:  // NnF (Next neighbour Floor)
      line-&gt;f.destref = REF_Surrounding | REF_NEXT;

      // guesswork here:
      if (dir == 0)
        line-&gt;f.destref |= REF_HIGHEST;
      break;

    case 3:  // LnC (Lowest neighbour Ceiling)
      line-&gt;f.destref = REF_Surrounding | REF_CEILING;
      break;

    case 4:  // ceiling
      line-&gt;f.destref = REF_Current | REF_CEILING;
      break;

    case 5:  // shorted texture
      line-&gt;f.destref = REF_LowestLoTexture;
      break;

    case 6:  // 24
      line-&gt;f.destref = REF_Current;  // FLOOR
      line-&gt;f.dest = 24;  // maybe this: "dir ? 24 : -24"
      break;

    case 7:  // 32
      line-&gt;f.destref = REF_Current;  // FLOOR
      line-&gt;f.dest = 32;
      break;
  }

  switch (dir)
  {
    case 0:  // Down
      line-&gt;f.speed_down = 1 &lt;&lt; speed;
      line-&gt;f.sfxdown = DDF_SfxLookupSound("STNMOV");
      break;

    case 1:  // Up;
      line-&gt;f.speed_up = 1 &lt;&lt; speed;
      line-&gt;f.sfxup = DDF_SfxLookupSound("STNMOV");
      break;
  }

  // handle change + model (pretty dodgy this bit)
  if (change &gt; 0)
  {
    strcpy(line-&gt;f.tex, model ? "+" : "-");
  }
}
</t>
<t tx="T2254">
static void MakeBoomCeiling(linedeftype_t *line, int number)
{
  int speed   = (number &gt;&gt; 3) &amp; 0x3;
  int model   = (number &gt;&gt; 5) &amp; 0x1;
  int dir     = (number &gt;&gt; 6) &amp; 0x1;
  int target  = (number &gt;&gt; 7) &amp; 0x7;
  int change  = (number &gt;&gt; 10) &amp; 0x3;
  int crush   = (number &gt;&gt; 12) &amp; 0x1;
  
  line-&gt;obj = trig_player | ((change == 0 &amp;&amp; model) ? trig_monster : 0);

  line-&gt;c.type = mov_Once;
  line-&gt;c.dest = 0;

  if (crush)
    line-&gt;c.crush = true;

  switch (target)
  {
    case 0:  // HnC (Highest neighbour Ceiling)
      line-&gt;c.destref = REF_Surrounding | REF_CEILING | REF_HIGHEST;
      break;

    case 1:  // LnC (Lowest neighbour Ceiling)
      line-&gt;c.destref = REF_Surrounding | REF_CEILING;
      break;

    case 2:  // NnC (Next neighbour Ceiling)
      line-&gt;c.destref = REF_Surrounding | REF_CEILING | REF_NEXT;

      // guesswork here:
      if (dir == 0)
        line-&gt;c.destref |= REF_HIGHEST;
      break;

    case 3:  // HnF (Highest neighbour Floor)
      line-&gt;c.destref = REF_Surrounding | REF_HIGHEST;
      break;

    case 4:  // floor
      line-&gt;c.destref = REF_Current;  // FLOOR
      break;

    case 5:  // shorted texture
      line-&gt;c.destref = REF_LowestLoTexture;
      break;

    case 6:  // 24
      line-&gt;c.destref = REF_Current | REF_CEILING;
      line-&gt;c.dest = 24;  // maybe this: "dir ? 24 : -24"
      break;

    case 7:  // 32
      line-&gt;c.destref = REF_Current | REF_CEILING;
      line-&gt;c.dest = 32;
      break;
  }

  switch (dir)
  {
    case 0:  // Down
      line-&gt;c.speed_down = 1 &lt;&lt; speed;
      line-&gt;c.sfxdown = DDF_SfxLookupSound("STNMOV");
      break;

    case 1:  // Up;
      line-&gt;c.speed_up = 1 &lt;&lt; speed;
      line-&gt;c.sfxup = DDF_SfxLookupSound("STNMOV");
      break;
  }

  // handle change + model (this logic is pretty dodgy)
  if (change &gt; 0)
  {
    strcpy(line-&gt;c.tex, model ? "+" : "-");
  }
}
</t>
<t tx="T2255">
static void MakeBoomDoor(linedeftype_t *line, int number)
{
  int speed   = (number &gt;&gt; 3) &amp; 0x3;
  int kind    = (number &gt;&gt; 5) &amp; 0x3;
  int monster = (number &gt;&gt; 7) &amp; 0x1;
  int delay   = (number &gt;&gt; 8) &amp; 0x3;

  line-&gt;obj = trig_player | (monster ? trig_monster : 0);

  line-&gt;c.type = (kind &amp; 1) ? mov_Once : mov_MoveWaitReturn;

  line-&gt;c.speed_up = 2 &lt;&lt; speed;
  line-&gt;c.speed_down = line-&gt;c.speed_up;
  line-&gt;c.sfxup = DDF_SfxLookupSound("DOROPN");
  line-&gt;c.sfxdown = DDF_SfxLookupSound("DORCLS");

  switch (kind &amp; 2)
  {
    case 0: // open types (odc and o)
      line-&gt;c.destref = REF_Surrounding | REF_CEILING;  // LnC
      line-&gt;c.dest = -4;
      break;

    case 2: // close types (cdo and c)
      line-&gt;c.destref = REF_Current;  // FLOOR
      line-&gt;c.dest = 0;
      break;
  }

  switch (delay)
  {
    case 0: line-&gt;c.wait = 35;   break;
    case 1: line-&gt;c.wait = 150;  break;
    case 2: line-&gt;c.wait = 300;  break;
    case 3: line-&gt;c.wait = 1050; break;
  }
}
</t>
<t tx="T2256">
static void MakeBoomLockedDoor(linedeftype_t *line, int number)
{
  int speed = (number &gt;&gt; 3) &amp; 0x3;
  int kind  = (number &gt;&gt; 5) &amp; 0x1;
  int lock  = (number &gt;&gt; 6) &amp; 0x7;
  int sk_ck = (number &gt;&gt; 9) &amp; 0x1;

  line-&gt;obj = trig_player;  // never allow monsters

  line-&gt;c.type = kind ? mov_Once : mov_MoveWaitReturn;
  line-&gt;c.destref = REF_Surrounding | REF_CEILING;  // LnC
  line-&gt;c.dest = -4;

  line-&gt;c.speed_up = 2 &lt;&lt; speed;
  line-&gt;c.speed_down = line-&gt;c.speed_up;
  line-&gt;c.sfxup = DDF_SfxLookupSound("DOROPN");
  line-&gt;c.sfxdown = DDF_SfxLookupSound("DORCLS");
  line-&gt;c.wait = 150;

  // handle keys

  switch (lock)
  {
    case 0:  // ANY
      line-&gt;keys = KF_RedCard | KF_BlueCard | KF_YellowCard |
          KF_RedSkull | KF_BlueSkull | KF_YellowSkull;
      line-&gt;failedmessage = Z_StrDup("NeedAnyForDoor");
      break;

    case 1:  // Red Card
      line-&gt;keys = KF_RedCard | (sk_ck ? KF_RedSkull : 0);
      line-&gt;failedmessage = Z_StrDup("NeedRedForDoor");
      break;

    case 2:  // Blue Card
      line-&gt;keys = KF_BlueCard | (sk_ck ? KF_BlueSkull : 0);
      line-&gt;failedmessage = Z_StrDup("NeedBlueForDoor");
      break;

    case 3:  // Yellow Card
      line-&gt;keys = KF_YellowCard | (sk_ck ? KF_YellowSkull : 0);
      line-&gt;failedmessage = Z_StrDup("NeedYellowForDoor");
      break;

    case 4:  // Red Skull
      line-&gt;keys = KF_RedSkull | (sk_ck ? KF_RedCard : 0);
      line-&gt;failedmessage = Z_StrDup("NeedRedForDoor");
      break;

    case 5:  // Blue Skull
      line-&gt;keys = KF_BlueSkull | (sk_ck ? KF_BlueCard : 0);
      line-&gt;failedmessage = Z_StrDup("NeedBlueForDoor");
      break;

    case 6:  // Yellow Skull
      line-&gt;keys = KF_YellowSkull | (sk_ck ? KF_YellowCard : 0);
      line-&gt;failedmessage = Z_StrDup("NeedYellowForDoor");
      break;

    case 7:  // ALL  
      line-&gt;keys = (sk_ck ? KF_BOOM_SKCK : 0) | KF_STRICTLY_ALL |
          (KF_RedCard | KF_BlueCard | KF_YellowCard |
           KF_RedSkull | KF_BlueSkull | KF_YellowSkull);
      line-&gt;failedmessage = Z_StrDup("NeedAllForDoor");
      break;
  }
}
</t>
<t tx="T2257">
static void MakeBoomLift(linedeftype_t *line, int number)
{
  int speed   = (number &gt;&gt; 3) &amp; 0x3;
  int monster = (number &gt;&gt; 5) &amp; 0x1;
  int delay   = (number &gt;&gt; 6) &amp; 0x3;
  int target  = (number &gt;&gt; 8) &amp; 0x3;

  line-&gt;obj = trig_player | (monster ? trig_monster : 0);

  line-&gt;f.type = mov_MoveWaitReturn;
  line-&gt;f.dest = 0;
  line-&gt;f.other = 0;

  line-&gt;f.speed_up = 1 &lt;&lt; speed;
  line-&gt;f.speed_down = line-&gt;f.speed_up;
  line-&gt;f.sfxstart = DDF_SfxLookupSound("PSTART");
  line-&gt;f.sfxstop  = DDF_SfxLookupSound("PSTOP");

  switch (target)
  {
    case 0:  // LnF (Lowest neighbour Floor)
      line-&gt;f.destref = REF_Surrounding | REF_INCLUDE;
      break;

    case 1:  // NnF (Next lowest neighbour Floor)
      line-&gt;f.destref = REF_Surrounding | REF_NEXT | REF_HIGHEST;
      break;

    case 2:  // LnC (Lowest neighbour Ceiling)
      line-&gt;f.destref = REF_Surrounding | REF_CEILING | REF_INCLUDE;
      break;

    case 3:  // Perpetual lift LnF&lt;-&gt;HnF
      line-&gt;f.type = mov_Continuous;
      line-&gt;f.destref  = REF_Surrounding | REF_INCLUDE;
      line-&gt;f.otherref = REF_Surrounding | REF_HIGHEST | REF_INCLUDE;
      break;
  }

  switch (delay)
  {
    case 0: line-&gt;f.wait = 35;  break;
    case 1: line-&gt;f.wait = 105; break;
    case 2: line-&gt;f.wait = 165; break;
    case 3: line-&gt;f.wait = 350; break;
  }
}
</t>
<t tx="T2258">
static void MakeBoomStair(linedeftype_t *line, int number)
{
  int speed   = (number &gt;&gt; 3) &amp; 0x3;
  int monster = (number &gt;&gt; 5) &amp; 0x1;
  int step    = (number &gt;&gt; 6) &amp; 0x3;
  int dir     = (number &gt;&gt; 8) &amp; 0x1;
  int igntxt  = (number &gt;&gt; 9) &amp; 0x1;

  line-&gt;obj = trig_player | (monster ? trig_monster : 0);

  line-&gt;f.type = mov_Stairs;
  line-&gt;f.destref = REF_Current;  // FLOOR

  // speed values are 0.25, 0.5, 2.0, 4.0 (but no 1.0)
  if (speed &gt;= 2)
    speed++;

  switch (dir)
  {
    case 0:  // Down
      line-&gt;f.dest = -(4 &lt;&lt; step);
      line-&gt;f.speed_down = (1 &lt;&lt; speed) / 4.0;
      line-&gt;f.sfxdown = DDF_SfxLookupSound("STNMOV");
      break;

    case 1:  // Up
      line-&gt;f.dest = 4 &lt;&lt; step;
      line-&gt;f.speed_up = (1 &lt;&lt; speed) / 4.0;
      line-&gt;f.sfxup = DDF_SfxLookupSound("STNMOV");
      break;
  }

  // Not here: 
  //   - igntxt (ignoring textures on the floor)
  //   - retriggable stairs alternate between build directions

  (void) igntxt;
}
</t>
<t tx="T2259">
static void MakeBoomCrusher(linedeftype_t *line, int number)
{
  int speed   = (number &gt;&gt; 3) &amp; 0x3;
  int monster = (number &gt;&gt; 5) &amp; 0x1;
  int silent  = (number &gt;&gt; 6) &amp; 0x1;

  line-&gt;obj = trig_player | (monster ? trig_monster : 0);
  line-&gt;crush = true;

  line-&gt;c.type = mov_Continuous;
  line-&gt;c.destref = REF_Current;  // FLOOR
  line-&gt;c.dest = 8;

  line-&gt;c.speed_up = 1 &lt;&lt; speed;
  line-&gt;c.speed_down = line-&gt;c.speed_up;

  if (! silent)
  {
    line-&gt;c.sfxup = DDF_SfxLookupSound("STNMOV");
    line-&gt;c.sfxdown = line-&gt;c.sfxup;
  }
}
</t>
<t tx="T2260">@ DDF_BoomMakeGenLine

Decodes the BOOM generalised linedef number and fills in the DDF
linedef type `line' (which has already been instantiated with
default values).

NOTE: This code based on "Section 13" of BOOMREF.TXT.

-AJA- 2001/06/22: began work on this.
@c

void DDF_BoomMakeGenLine(linedeftype_t *line, int number)
{
  // trigger values are the same for all ranges
  HandleLineTrigger(line, number &amp; 0x7);
   
  if (number &gt;= 0x6000)
    MakeBoomFloor(line, number);
  
  else if (number &gt;= 0x4000)
    MakeBoomCeiling(line, number);
  
  else if (number &gt;= 0x3c00)
    MakeBoomDoor(line, number);
  
  else if (number &gt;= 0x3800)
    MakeBoomLockedDoor(line, number);
  
  else if (number &gt;= 0x3400)
    MakeBoomLift(line, number);
  
  else if (number &gt;= 0x3000)
    MakeBoomStair(line, number);
  
  else if (number &gt;= 0x2F80)
    MakeBoomCrusher(line, number);
}
</t>
<t tx="T2261">@ignore
@language c

// Data Definition File Code (Colourmaps)

// Colourmap handling.

&lt;&lt; ddf_colm #includes &gt;&gt;
&lt;&lt; ddf_colm declarations &gt;&gt;
@others
</t>
<t tx="T2262">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_type.h"
#include "ddf_locl.h"
#include "m_random.h"
#include "z_zone.h"
</t>
<t tx="T2263">
#undef  DF
#define DF  DDF_CMD

static colourmap_t buffer_colmap;
static colourmap_t *dynamic_colmap;

static const colourmap_t template_colmap =
{
  DDF_BASE_NIL,  // ddf
  "",            // lump name
  0,             // start
  1,             // length
  0,             // special
  {NULL, NULL, -1, 0, 0xFFFFFF}  // cache
};

void DDF_ColmapGetSpecial(const char *info, void *storage);

#define DDF_CMD_BASE  buffer_colmap

static const commandlist_t colmap_commands[] =
{
  DF("LUMP",    lump_name, DDF_MainGetInlineStr10),
  DF("START",   start,     DDF_MainGetNumeric),
  DF("LENGTH",  length,    DDF_MainGetNumeric),
  DF("SPECIAL", special,   DDF_ColmapGetSpecial),

  // -AJA- backwards compatibility cruft...
  DF("!PRIORITY", ddf, DDF_DummyFunction),

  DDF_CMD_END
};

colourmap_t ** ddf_colmaps;
int num_ddf_colmaps = 0;
int num_disabled_colmaps = 0;

static stack_array_t ddf_colmaps_a;
</t>
<t tx="T2264">@ DDF PARSE ROUTINES
@c

static boolean_t ColmapStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=num_disabled_colmaps; i &lt; num_ddf_colmaps; i++)
    {
      if (DDF_CompareName(ddf_colmaps[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_colmap = ddf_colmaps[i];
        replaces = true;
        break;
      }
    }
    
    // if found, adjust pointer array to keep newest entries at end
    if (replaces &amp;&amp; i &lt; (num_ddf_colmaps-1))
    {
      Z_MoveData(ddf_colmaps + i, ddf_colmaps + i + 1, colourmap_t *,
          num_ddf_colmaps - i);
      ddf_colmaps[num_ddf_colmaps - 1] = dynamic_colmap;
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;ddf_colmaps_a, ++num_ddf_colmaps);

    dynamic_colmap = ddf_colmaps[num_ddf_colmaps-1];
    dynamic_colmap-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_COLMAP", num_ddf_colmaps);
  }

  dynamic_colmap-&gt;ddf.number = 0;

  // instantiate the static entry
  buffer_colmap = template_colmap;

  return replaces;
}
</t>
<t tx="T2265">
static void ColmapParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("COLMAP_PARSE: %s = %s;\n", field, contents);
#endif

  if (DDF_MainParseField(colmap_commands, field, contents))
    return;

  // handle properties
  if (index == 0 &amp;&amp; DDF_CompareName(contents, "TRUE") == 0)
  {
    DDF_ColmapGetSpecial(field, NULL);  // FIXME FOR OFFSETS
    return;
  }

  DDF_WarnError("Unknown colmap.ddf command: %s\n", field);
}
</t>
<t tx="T2266">
static void ColmapFinishEntry(void)
{
  ddf_base_t base;
  
  if (buffer_colmap.start &lt; 0)
  {
    DDF_WarnError("Bad START value for colmap: %d\n", buffer_colmap.start);
    buffer_colmap.start = 0;
  }
  
  if (buffer_colmap.length &lt;= 0)
  {
    DDF_WarnError("Bad LENGTH value for colmap: %d\n", buffer_colmap.length);
    buffer_colmap.length = 1;
  }
  
  if (!buffer_colmap.lump_name || !buffer_colmap.lump_name[0])
    DDF_Error("Missing LUMP name for colmap.\n");

  // transfer static entry to dynamic entry
  
  base = dynamic_colmap-&gt;ddf;
  dynamic_colmap[0] = buffer_colmap;
  dynamic_colmap-&gt;ddf = base;

  // Compute CRC.  In this case, there is no need, since colourmaps
  // only affect rendering, they have zero effect on the game
  // simulation itself.
  dynamic_colmap-&gt;ddf.crc = 0;
}
</t>
<t tx="T2267">
static void ColmapClearAll(void)
{
  // not safe to delete colourmaps -- disable them

  num_disabled_colmaps = num_ddf_colmaps;
}
</t>
<t tx="T2268">

void DDF_ReadColourMaps(void *data, int size)
{
  readinfo_t colm_r;

  colm_r.memfile = data;
  colm_r.memsize = size;
  colm_r.tag = "COLOURMAPS";
  colm_r.entries_per_dot = 2;

  if (colm_r.memfile)
  {
    colm_r.message = NULL;
    colm_r.filename = NULL;
    colm_r.lumpname = "DDFCOLM";
  }
  else
  {
    colm_r.message = "DDF_InitColourMaps";
    colm_r.filename = "colmap.ddf";
    colm_r.lumpname = NULL;
  }

  colm_r.start_entry  = ColmapStartEntry;
  colm_r.parse_field  = ColmapParseField;
  colm_r.finish_entry = ColmapFinishEntry;
  colm_r.clear_all    = ColmapClearAll;

  DDF_MainReadFile(&amp;colm_r);
}
</t>
<t tx="T2269">
void DDF_ColmapInit(void)
{
  Z_InitStackArray(&amp;ddf_colmaps_a, (void ***)&amp;ddf_colmaps, sizeof(colourmap_t), 0);
}
</t>
<t tx="T2270">
void DDF_ColmapCleanUp(void)
{
  /* nothing to do */
}
</t>
<t tx="T2271">
const colourmap_t *DDF_ColmapLookup(const char *name)
{
  int i;

  for (i = num_disabled_colmaps; i &lt; num_ddf_colmaps; i++)
  {
    if (DDF_CompareName(ddf_colmaps[i]-&gt;ddf.name, name) == 0)
      return ddf_colmaps[i];
  }

  if (lax_errors)
    return ddf_colmaps[0];

  DDF_Error("DDF_ColmapLookup: No such colourmap '%s'\n", name);
  return NULL;
}
</t>
<t tx="T2272">
specflags_t colmap_specials[] =
{
    {"FLASH",  COLSP_NoFlash,  1},

    // -AJA- backwards compatibility cruft...
    {"!SKY",   0, 0},
    {NULL, 0, 0}
};

//
// DDF_ColmapGetSpecial
//
// Gets the colourmap specials.
//
void DDF_ColmapGetSpecial(const char *info, void *storage)
{
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, colmap_specials, &amp;flag_value,
      true, false))
  {
    case CHKF_Positive:
      buffer_colmap.special |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_colmap.special &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("DDF_ColmapGetSpecial: Unknown Special: %s", info);
      break;
  }
}
</t>
<t tx="T2273">@ignore
@language c

// Data Definition File Code (Game settings)

// Overall Game Setup and Parser Code.

&lt;&lt; ddf_game #includes &gt;&gt;
&lt;&lt; ddf_game declarations &gt;&gt;
@others
</t>
<t tx="T2274">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "m_fixed.h"
#include "m_math.h"
#include "p_mobj.h"
#include "z_zone.h"
</t>
<t tx="T2275">
#undef  DF
#define DF  DDF_CMD

static wi_map_t buffer_wi;
static wi_map_t *dynamic_wi;

static const wi_map_t template_wi =
{
  DDF_BASE_NIL,  // ddf

  NULL,    // anims
  0,       // numanims
  NULL,    // mappos
  NULL,    // mapdone
  0,       // nummaps

  "",      // background
  "",      // splatpic
  {"",""}, // yah[2]
  "",      // bg_camera
  0,       // music

  sfx_None, // percent
  sfx_None, // done
  sfx_None, // endmap
  sfx_None, // nextmap
  sfx_None, // accel_snd
  sfx_None, // frag_snd

  "",      // firstmap
  "",      // namegraphic
  NULL,    // titlepics
  0,       // numtitlepics
  0,       // titlemusic;
  TICRATE * 4  // titletics;
};

static void DDF_GameGetPic(const char *info, void *storage);
static void DDF_GameGetFrames(const char *info, void *storage);
static void DDF_GameGetMap(const char *info, void *storage);

wi_map_t ** wi_maps = NULL;
int num_wi_maps = 0;

static stack_array_t wi_maps_a;

static wi_anim_t  buffer_anim;
static wi_frame_t buffer_frame;

#define DDF_CMD_BASE  buffer_wi

static const commandlist_t wi_commands[] =
{
  DF("INTERMISSION GRAPHIC", background, DDF_MainGetInlineStr10),
  DF("INTERMISSION CAMERA", bg_camera, DDF_MainGetInlineStr32),
  DF("INTERMISSION MUSIC", music, DDF_MainGetNumeric),
  DF("SPLAT GRAPHIC", splatpic, DDF_MainGetInlineStr10),
  DF("YAH1 GRAPHIC", yah[0], DDF_MainGetInlineStr10),
  DF("YAH2 GRAPHIC", yah[1], DDF_MainGetInlineStr10),
  DF("PERCENT SOUND", percent, DDF_MainLookupSound),
  DF("DONE SOUND", done, DDF_MainLookupSound),
  DF("ENDMAP SOUND", endmap, DDF_MainLookupSound),
  DF("NEXTMAP SOUND", nextmap, DDF_MainLookupSound),
  DF("ACCEL SOUND", accel_snd, DDF_MainLookupSound),
  DF("FRAG SOUND", frag_snd, DDF_MainLookupSound),
  DF("FIRSTMAP", firstmap, DDF_MainGetInlineStr10),
  DF("NAME GRAPHIC", namegraphic, DDF_MainGetInlineStr10),
  DF("TITLE MUSIC", titlemusic, DDF_MainGetNumeric),
  DF("TITLE TIME", titletics, DDF_MainGetTime),

  // these don't quite fit in yet
  DF("TITLE GRAPHIC", ddf, DDF_GameGetPic),
  DF("MAP", ddf, DDF_GameGetMap),
  {"ANIM", DDF_GameGetFrames, &amp;buffer_frame, NULL},

  DDF_CMD_END
};
</t>
<t tx="T2276">@ DDF PARSE ROUTINES
@c

static boolean_t GameStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=0; i &lt; num_wi_maps; i++)
    {
      if (DDF_CompareName(wi_maps[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_wi = wi_maps[i];
        replaces = true;
        break;
      }
    }
    
    // if found, adjust pointer array to keep newest entries at end
    if (replaces &amp;&amp; i &lt; (num_wi_maps-1))
    {
      Z_MoveData(wi_maps + i, wi_maps + i + 1, wi_map_t *,
          num_wi_maps - i);
      wi_maps[num_wi_maps - 1] = dynamic_wi;
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;wi_maps_a, ++num_wi_maps);
    
    dynamic_wi = wi_maps[num_wi_maps - 1];
    dynamic_wi-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_WI_MAP", num_wi_maps);
  }

  dynamic_wi-&gt;ddf.number = 0;

  Z_Clear(&amp;buffer_anim,  wi_anim_t, 1);
  Z_Clear(&amp;buffer_frame, wi_frame_t, 1);

  // instantiate the static entry
  buffer_wi = template_wi;
    
  return replaces;
}
</t>
<t tx="T2277">
static void GameParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("GAME_PARSE: %s = %s;\n", field, contents);
#endif

  if (! DDF_MainParseField(wi_commands, field, contents))
    DDF_WarnError("Unknown games.ddf command: %s\n", field);
}
</t>
<t tx="T2278">
static void GameFinishEntry(void)
{
  ddf_base_t base;
  
  // FIXME: check stuff...
  
  // transfer static entry to dynamic entry
  
  base = dynamic_wi-&gt;ddf;
  dynamic_wi[0] = buffer_wi;
  dynamic_wi-&gt;ddf = base;

  // compute CRC...
  CRC32_Init(&amp;dynamic_wi-&gt;ddf.crc);

  // FIXME: more stuff...
  
  CRC32_Done(&amp;dynamic_wi-&gt;ddf.crc);
}
</t>
<t tx="T2279">
static void GameClearAll(void)
{
  // safe to delete game entries

  num_wi_maps = 0;
  Z_SetArraySize(&amp;wi_maps_a, num_wi_maps);
}
</t>
<t tx="T2280">

void DDF_ReadGames(void *data, int size)
{
  readinfo_t games;

  games.memfile = data;
  games.memsize = size;
  games.tag = "GAMES";
  games.entries_per_dot = 1;

  if (games.memfile)
  {
    games.message = NULL;
    games.filename = NULL;
    games.lumpname = "DDFGAME";
  }
  else
  {
    games.message = "DDF_InitGames";
    games.filename = "games.ddf";
    games.lumpname = NULL;
  }

  games.start_entry  = GameStartEntry;
  games.parse_field  = GameParseField;
  games.finish_entry = GameFinishEntry;
  games.clear_all    = GameClearAll;

  DDF_MainReadFile(&amp;games);
}
</t>
<t tx="T2281">
void DDF_GameInit(void)
{
  Z_InitStackArray(&amp;wi_maps_a, (void ***)&amp;wi_maps, sizeof(wi_map_t), 0);
}
</t>
<t tx="T2282">
void DDF_GameCleanUp(void)
{
  if (num_wi_maps == 0)
    I_Error("There are no games defined in DDF !\n");
}
</t>
<t tx="T2283">

static void DDF_GameAddFrame(void)
{
  Z_Resize(buffer_anim.frames, wi_frame_t, buffer_anim.numframes + 1);
  buffer_anim.frames[buffer_anim.numframes++] = buffer_frame;
  memset(&amp;buffer_frame, 0, sizeof(wi_frame_t));
}
</t>
<t tx="T2284">
static void DDF_GameAddAnim(void)
{
  Z_Resize(buffer_wi.anims, wi_anim_t, buffer_wi.numanims + 1);
  if (buffer_anim.level[0])
    buffer_anim.type = WI_LEVEL;
  else
    buffer_anim.type = WI_NORMAL;
  buffer_wi.anims[buffer_wi.numanims++] = buffer_anim;
  memset(&amp;buffer_anim, 0, sizeof(wi_anim_t));
}
</t>
<t tx="T2285">
static void DDF_GameGetFrames(const char *info, void *storage)
{
  char *s = Z_StrDup(info);
  char *tok;

  wi_frame_t *f = (wi_frame_t *)storage;
  
  int i;

  struct
  {
    int type;
    void *dest;
  }
  f_dest[4];

  f_dest[0].type = 1;
  f_dest[0].dest = f-&gt;pic;
  f_dest[1].type = 0;
  f_dest[1].dest = &amp;f-&gt;tics;
  f_dest[2].type = 0;
  f_dest[2].dest = &amp;f-&gt;pos.x;
  f_dest[3].type = 2;
  f_dest[3].dest = &amp;f-&gt;pos.y;
  
  tok = strtok(s, ":");

  if (tok[0] == '#')
  {
    if (!buffer_anim.numframes)
    {
      Z_StrNCpy(buffer_anim.level, tok + 1, 8);
      tok = strtok(NULL, ":");
    }
    else if (!strncmp(tok, "#END", 4))
    {
      DDF_GameAddAnim();
      Z_Free(s);
      return;
    }
    else
      DDF_Error("Invalid # command '%s'\n", tok);
  }

  for (i = 0; tok &amp;&amp; i &lt; 4; tok = strtok(NULL, ":"), i++)
  {
    if (f_dest[i].type &amp; 1)
      Z_StrNCpy((char *)f_dest[i].dest, tok, 8);
    else
      *(int *)f_dest[i].dest = atoi(tok);

    if (f_dest[i].type &amp; 2)
    {
      DDF_GameAddFrame();
      Z_Free(s);
      return;
    }
  }
  DDF_Error("Bad Frame command '%s'\n", info);
}
</t>
<t tx="T2286">
static void DDF_GameGetMap(const char *info, void *storage)
{
  char *s = Z_StrDup(info);
  char *tok;
  struct
  {
    int type;
    void *dest;
  }
  dest[3];
  int i;

  Z_Resize(buffer_wi.mappos, mappos_t, buffer_wi.nummaps + 1);
  Z_Resize(buffer_wi.mapdone, boolean_t, buffer_wi.nummaps + 1);

  dest[0].type = 1;
  dest[0].dest = buffer_wi.mappos[buffer_wi.nummaps].name;
  dest[1].type = 0;
  dest[1].dest = &amp;buffer_wi.mappos[buffer_wi.nummaps].pos.x;
  dest[2].type = 2;
  dest[2].dest = &amp;buffer_wi.mappos[buffer_wi.nummaps++].pos.y;
  for (tok = strtok(s, ":"), i = 0;
      tok &amp;&amp; i &lt; 3;
      tok = strtok(NULL, ":"), i++)
  {
    if (dest[i].type &amp; 1)
      Z_StrNCpy((char *)dest[i].dest, tok, 8);
    else
      *(int *)dest[i].dest = atoi(tok);
    if (dest[i].type &amp; 2)
    {
      Z_Free(s);
      return;
    }
  }
  DDF_Error("Bad Map command '%s'\n", info);
}
</t>
<t tx="T2287">
static void DDF_GameGetPic(const char *info, void *storage)
{
  Z_Resize(buffer_wi.titlepics, char *, buffer_wi.numtitlepics + 1);

  buffer_wi.titlepics[buffer_wi.numtitlepics] = Z_StrDup(info);
  buffer_wi.numtitlepics++;
}
</t>
<t tx="T2288">
const wi_map_t *DDF_GameLookup(const char *name)
{
  int i;

  for (i = 0; i &lt; num_wi_maps; i++)
  {
    if (DDF_CompareName(name, wi_maps[i]-&gt;ddf.name) == 0)
      return wi_maps[i];
  }

  DDF_Error("Unknown game name: %s\n", name);
  return NULL;
}
</t>
<t tx="T2289">@ignore
@language c

// Data Definition File Code (Language handling settings)

@
Language handling Setup and Parser Code

// 1998/10/29 -KM- Allow cmd line selection of language.

// This is somewhat different to most DDF reading files. In order to read the
// language specific strings, it uses the format:

// &lt;RefName&gt;=&lt;String&gt;;

// as opposed to the normal entry, which should be:

// [&lt;Refname&gt;]
// STRING=&lt;string&gt;;
//
// also the file suffix is LDF (Language Def File), this is to avoid confusion with
// the oridnary DDF files. The default file is DEFAULT.LDF, which can be subbed by
// using -lang &lt;NameOfLangFile&gt;.
@c

&lt;&lt; ddf_lang #includes &gt;&gt;
&lt;&lt; ddf_lang declarations &gt;&gt;
@others
</t>
<t tx="T2290">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "m_argv.h"
#include "p_spec.h"
#include "r_local.h"
#include "z_zone.h"
</t>
<t tx="T2291">
static language_t *dynamic_lang;

static const language_t template_lang =
{
  DDF_BASE_NIL,  // ddf
  NULL,  // refs
};

static const char *want_language;
int cur_lang_index = -1;

static boolean_t read_languages = false;


// array of languages

language_t ** languages = NULL;
int num_languages = 0;

static stack_array_t languages_a;


static void DDF_LanguageAddRef(language_t *lang, const char *ref, 
    const char *text);


//
// Hardcoded entries.
//
// These are _only_ needed for strings that are used before the
// LANGUAGE.LDF file or DDFLANG lump(s) have been read in.

static langref_t hardcoded_ldfs[] =
{
  { "DefaultLoad", "M_LoadDefaults: Loaded system defaults.\n", NULL },
  { "DevelopmentMode", "Development Mode is enabled.\n", NULL },
  { "TurboScale",  "Turbo scale: %i%%\n", NULL },
  { "WadFileInit", "W_Init: Init WADfiles.\n", NULL },

  { NULL, NULL, NULL }
};
</t>
<t tx="T2292">@ DDF PARSING ROUTINES
@c

static boolean_t LanguageStartEntry(const char *name)
{
  int i, index = -1;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=0; i &lt; num_languages; i++)
    {
      if (DDF_CompareName(languages[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_lang = languages[i];
        index = i;
        replaces = true;
        break;
      }
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    index = num_languages;

    Z_SetArraySize(&amp;languages_a, ++num_languages);

    dynamic_lang = languages[index];
    
    // initialise the new entry
    dynamic_lang[0] = template_lang;

    dynamic_lang-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_LANGUAGE", num_languages);
  }

  if (DDF_CompareName(name, want_language) == 0)
  {
    cur_lang_index = index;
  }

  return replaces;
}
</t>
<t tx="T2293">
static void LanguageParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("LANGUAGE_PARSE: %s = %s;\n", field, contents);
#endif

  if (! is_last)
  {
    DDF_WarnError("Unexpected comma `,' in LANGUAGE.LDF\n");
    return;
  }
    
  DDF_LanguageAddRef(dynamic_lang, field, contents);
}
</t>
<t tx="T2294">
static void LanguageFinishEntry(void)
{
  // Compute CRC.  Not needed for languages.
  dynamic_lang-&gt;ddf.crc = 0;
}
</t>
<t tx="T2295">
static void LanguageClearAll(void)
{
  // safe to delete all language entries

  num_languages = 0;
  Z_SetArraySize(&amp;languages_a, num_languages);
}
</t>
<t tx="T2296">

void DDF_ReadLangs(void *data, int size)
{
  readinfo_t language;

  language.memfile = data;
  language.memsize = size;
  language.tag = "LANGUAGES";
  language.entries_per_dot = 1;
  
  if (language.memfile)
  {
    language.message = NULL;
    language.filename = NULL;
    language.lumpname = "DDFLANG";
  }
  else
  {
    language.message = "DDF_InitLanguage";
    language.filename = "language.ldf";
    language.lumpname = NULL;
  }

  language.start_entry  = LanguageStartEntry;
  language.parse_field  = LanguageParseField;
  language.finish_entry = LanguageFinishEntry;
  language.clear_all    = LanguageClearAll;

  DDF_MainReadFile(&amp;language);

  read_languages = true;
}
</t>
<t tx="T2297">
void DDF_LanguageInit(void)
{
  want_language = M_GetParm("-lang");
  cur_lang_index = -1;

  if (!want_language)
  {
    // -AJA- FIXME: should be config-file-selectable
    want_language = "ENGLISH";
  }

  Z_InitStackArray(&amp;languages_a, (void ***)&amp;languages, sizeof(language_t), 0);
}
</t>
<t tx="T2298">
void DDF_LanguageCleanUp(void)
{
   if (cur_lang_index &lt; 0)
     I_Error("Unknown language: %s\n", want_language);
}
</t>
<t tx="T2299">
static langref_t *FindLanguageRef(const char *refname)
{
  int i;
  char *tmpname;
  langref_t *entry;

  if (cur_lang_index &lt; 0)
    return NULL;

  DEV_ASSERT2(cur_lang_index &lt; num_languages);

  // convert to uppercase

  tmpname = I_TmpMalloc(strlen(refname) + 1);
  for (i = 0; refname[i]; i++)
  {
    tmpname[i] = toupper(refname[i]);
  }
  tmpname[i] = 0;

  // when a reference cannot be found in the current language, we look
  // for it in the other languages.

  for (i=cur_lang_index; i &lt; cur_lang_index+num_languages; i++)
  {
    language_t *lang = languages[i % num_languages];

    entry = lang-&gt;refs;

    // -ES- 2000/02/04 Optimisation: replaced stricmp with strcmp
    while (entry != NULL &amp;&amp; strcmp(tmpname, entry-&gt;refname))
      entry = entry-&gt;next;
    
    if (entry)
    {
      I_TmpFree(tmpname);
      return entry;
    }
  }

  // not found !
  I_TmpFree(tmpname);
  return NULL;
}
</t>
<t tx="T2300">@ DDF_LanguageLookup

Globally Visibile to all files that directly or indirectly include ddf_main.h;
This compares the ref name given with the refnames in the language lookup
table. If one compares with the other, a pointer to the string is returned. If
one is not found than an error is generated.
@c

const char *DDF_LanguageLookup(const char *refname)
{
  int i;
  langref_t *entry;

  // -AJA- Due to the new "DDF lumps in EDGE.WAD" thing, certain
  //       messages need to be looked up before any LDF entries have
  //       been read in (from EDGE.WAD).  These entries must be
  //       hardcoded in this file.  
  if (! read_languages)
  {
    for (i=0; hardcoded_ldfs[i].refname; i++)
    {
      if (DDF_CompareName(refname, hardcoded_ldfs[i].refname) == 0)
        return hardcoded_ldfs[i].string;
    }
  }
  else
  {
    entry = FindLanguageRef(refname);
  
    if (entry != NULL)
      return entry-&gt;string;
  }
  
  if (strict_errors)
    DDF_Error("DDF_LanguageLookup: Unknown String Ref: %s\n", refname);
  
  return refname;
}
</t>
<t tx="T2301">@ DDF_LanguageValidRef

Returns whether the given ref is valid.
-ES- 2000/02/04 Added
@c

boolean_t DDF_LanguageValidRef(const char *refname)
{
  langref_t *entry = FindLanguageRef(refname);
 
  return (entry == NULL) ? false : true;
}
</t>
<t tx="T2302">@ DDF_LanguageAddRef

Puts the string into the buffer entry and adds it to the linked list.
@c

static void DDF_LanguageAddRef(language_t *lang, const char *ref, 
    const char *text)
{
  langref_t *entry;

  // look for entry with same name

  for (entry=lang-&gt;refs; entry; entry=entry-&gt;next)
  {
    if (DDF_CompareName(entry-&gt;refname, ref) == 0)
      break;
  }

  if (entry)
  {
    // replace existing entry

    // -ES- INTENTIONAL CONST OVERRIDE
    Z_Free((char*) entry-&gt;string);

    entry-&gt;string = Z_StrDup(text);
    return;
  }

  // create new entry
  
  entry = Z_New(langref_t, 1);

  entry-&gt;refname = Z_StrDup(ref);
  entry-&gt;string  = Z_StrDup(text);

  // link it in
  entry-&gt;next = lang-&gt;refs;
  lang-&gt;refs = entry;
}
</t>
<t tx="T2303">@ignore
@language c

// Data Definition File Code (Level Defines)

// Level Setup and Parser Code

&lt;&lt; ddf_levl #includes &gt;&gt;
&lt;&lt; ddf_levl declarations &gt;&gt;
@others
</t>
<t tx="T2304">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "m_fixed.h"
#include "m_math.h"
#include "p_mobj.h"
#include "w_wad.h"
#include "z_zone.h"
</t>
<t tx="T2305">
#undef  DF
#define DF  DDF_CMD

static mapstuff_t buffer_map;
static mapstuff_t *dynamic_map;

static const mapstuff_t template_map =
{
  DDF_BASE_NIL,  // ddf

  NULL,  // next
  NULL,  // description
  "",    // namegraphic
  "",    // lump
  "",    // sky
  "",    // surround
  0,     // music

  0,     // partime
  NULL,  // episode_name
  0,     // force_on
  0,     // force_off
  "",    // nextmapname
  "",    // secretmapname
  0,     // autotag
  LMODEL_Doom,  // lighting
  WISTYLE_Doom, // wistyle

  {
    // finale[0]
    {
      NULL,  // text
      "",    // text_back
      "",    // text_flat
      3,     // text_speed
      150,   // text_wait
      0,     // numpics
      0,     // picwait
      NULL,  // pics
      false, // docast
      false, // dobunny
      0      // music
    },

    // finale[1]
    {
      NULL,  // text
      "",    // text_back
      "",    // text_flat
      3,     // text_speed
      150,   // text_wait
      0,     // numpics
      0,     // picwait
      NULL,  // pics
      false, // docast
      false, // dobunny
      0      // music
    }
  }
};

mapstuff_t ** level_maps = NULL;
int num_level_maps = 0;

static stack_array_t level_maps_a;


static void DDF_LevelGetSpecials(const char *info, void *storage);
static void DDF_LevelGetPic(const char *info, void *storage);
static void DDF_LevelGetLighting(const char *info, void *storage);
static void DDF_LevelGetWistyle(const char *info, void *storage);

static finale_t dummy_finale;

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_finale

static const commandlist_t finale_commands[] =
{
  DDF_CMD_SUB("TEXT", text, DDF_MainGetString),
  DDF_CMD_SUB("TEXT GRAPHIC", text_back, DDF_MainGetInlineStr10),
  DDF_CMD_SUB("TEXT FLAT", text_flat, DDF_MainGetInlineStr10),
  DDF_CMD_SUB("TEXT SPEED", text_speed, DDF_MainGetFloat),
  DDF_CMD_SUB("TEXT WAIT", text_wait, DDF_MainGetNumeric),
  DDF_CMD_SUB("GRAPHIC", text, DDF_LevelGetPic),
  DDF_CMD_SUB("GRAPHIC WAIT", picwait, DDF_MainGetTime),
  DDF_CMD_SUB("CAST", docast, DDF_MainGetBoolean),
  DDF_CMD_SUB("BUNNY", dobunny, DDF_MainGetBoolean),
  DDF_CMD_SUB("MUSIC", music, DDF_MainGetNumeric),

  DDF_CMD_END
};

// -KM- 1998/11/25 Finales are all go.

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_map

static const commandlist_t level_commands[] =
{
  // sub-commands
  DDF_SUB_LIST("END", f[0], finale_commands),
  DDF_SUB_LIST("PRE", f[1], finale_commands),

  DF("LUMPNAME", lump, DDF_MainGetInlineStr10),
  DF("DESCRIPTION", description, DDF_MainGetString),
  DF("NAME GRAPHIC", namegraphic, DDF_MainGetInlineStr10),
  DF("SKY TEXTURE", sky, DDF_MainGetInlineStr10),
  DF("MUSIC ENTRY", music, DDF_MainGetNumeric),
  DF("SURROUND FLAT", surround, DDF_MainGetInlineStr10),
  DF("NEXT MAP", nextmapname, DDF_MainGetInlineStr10),
  DF("SECRET MAP", secretmapname, DDF_MainGetInlineStr10),
  DF("AUTOTAG", autotag, DDF_MainGetNumeric),
  DF("PARTIME", partime, DDF_MainGetTime),
  DF("EPISODE", episode_name, DDF_MainGetString),
  DF("LIGHTING", lighting, DDF_LevelGetLighting),
  DF("STATS", wistyle, DDF_LevelGetWistyle),
  DF("SPECIAL", ddf, DDF_LevelGetSpecials),

  DDF_CMD_END
};

static specflags_t map_specials[] =
{
    {"JUMPING", MPF_Jumping, 0},
    {"MLOOK", MPF_Mlook, 0},
    {"FREELOOK", MPF_Mlook, 0},  // -AJA- backwards compat.
    {"TRANSLUCENCY", MPF_Translucency, 0},
    {"CHEATS", MPF_Cheats, 0},
    {"ITEM RESPAWN", MPF_ItemRespawn, 0},
    {"FAST MONSTERS", MPF_FastParm, 0},
    {"RESURRECT RESPAWN", MPF_ResRespawn, 0},
    {"TELEPORT RESPAWN", MPF_ResRespawn, 1},
    {"STRETCH SKY", MPF_StretchSky, 0},
    {"NORMAL SKY", MPF_StretchSky, 1},
    {"TRUE3D", MPF_True3D, 0},
    {"ENEMY STOMP", MPF_Stomp, 0},
    {"MORE BLOOD", MPF_MoreBlood, 0},
    {"NORMAL BLOOD", MPF_MoreBlood, 1},
    {"RESPAWN", MPF_Respawn, 0},
    {"AUTOAIM", MPF_AutoAim, 0},
    {"AA MLOOK", MPF_AutoAimMlook, 0},
    {"EXTRAS", MPF_Extras, 0},
    {"RESET PLAYER", MPF_ResetPlayer, 0},
    {"LIMIT ZOOM", MPF_LimitZoom, 0},
    {"SHADOWS", MPF_Shadows, 0},
    {"HALOS", MPF_Halos, 0},
    {"CROUCHING", MPF_Crouching, 0},
    {"WEAPON KICK", MPF_Kicking, 0},
    {"BOOM COMPAT", MPF_BoomCompat, 0},
    {NULL, 0, 0}
};
</t>
<t tx="T2306">@ DDF PARSE ROUTINES
@c

static boolean_t LevelStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=0; i &lt; num_level_maps; i++)
    {
      if (DDF_CompareName(level_maps[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_map = level_maps[i];
        replaces = true;
        break;
      }
    }
    
    // if found, adjust pointer array to keep newest entries at end
    if (replaces &amp;&amp; i &lt; (num_level_maps-1))
    {
      Z_MoveData(level_maps + i, level_maps + i + 1, mapstuff_t *,
          num_level_maps - i);
      level_maps[num_level_maps - 1] = dynamic_map;
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;level_maps_a, ++num_level_maps);
    
    dynamic_map = level_maps[num_level_maps - 1];
    dynamic_map-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_LEVEL_MAP", num_level_maps);
  }

  dynamic_map-&gt;ddf.number = 0;

  // instantiate the static entry
  buffer_map = template_map;

  return replaces;
}
</t>
<t tx="T2307">
static void LevelParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("LEVEL_PARSE: %s = %s;\n", field, contents);
#endif

  if (! DDF_MainParseField(level_commands, field, contents))
    DDF_WarnError("Unknown levels.ddf command: %s\n", field);
}
</t>
<t tx="T2308">
static void LevelFinishEntry(void)
{
  ddf_base_t base;
  
  // check stuff
  
  if (buffer_map.episode_name == NULL)
    DDF_Error("Level entry must have an EPISODE name !\n");

  // FIXME: check more stuff here...
  
  // transfer static entry to dynamic entry
  
  base = dynamic_map-&gt;ddf;
  dynamic_map[0] = buffer_map;
  dynamic_map-&gt;ddf = base;

  // compute CRC...
  CRC32_Init(&amp;dynamic_map-&gt;ddf.crc);

  // FIXME: add stuff...
  
  CRC32_Done(&amp;dynamic_map-&gt;ddf.crc);

  // Initial Hack
  currentmap = dynamic_map;
}
</t>
<t tx="T2309">
static void LevelClearAll(void)
{
  // safe to delete the level entries -- no refs

  num_level_maps = 0;
  Z_SetArraySize(&amp;level_maps_a, num_level_maps);
}
</t>
<t tx="T2310">

void DDF_ReadLevels(void *data, int size)
{
  readinfo_t levels;

  levels.memfile = data;
  levels.memsize = size;
  levels.tag = "LEVELS";
  levels.entries_per_dot = 2;

  if (levels.memfile)
  {
    levels.message = NULL;
    levels.filename = NULL;
    levels.lumpname = "DDFLEVL";
  }
  else
  {
    levels.message = "DDF_InitLevels";
    levels.filename = "levels.ddf";
    levels.lumpname = NULL;
  }

  levels.start_entry  = LevelStartEntry;
  levels.parse_field  = LevelParseField;
  levels.finish_entry = LevelFinishEntry;
  levels.clear_all    = LevelClearAll;

  DDF_MainReadFile(&amp;levels);
}
</t>
<t tx="T2311">
void DDF_LevelInit(void)
{
  Z_InitStackArray(&amp;level_maps_a, (void ***)&amp;level_maps, sizeof(mapstuff_t), 0);
}
</t>
<t tx="T2312">
void DDF_LevelCleanUp(void)
{
  if (num_level_maps == 0)
    I_Error("There are no levels defined in DDF !\n");
}
</t>
<t tx="T2313">@ DDF_LevelMapLookup

Changes the current map: this is globally visible to all those who ref
ddf_main.h. It will check there is an map with that entry name exists
and the map lump name also exists. Returns map if it exists.
@c

const mapstuff_t *DDF_LevelMapLookup(const char *refname)
{
  int i;

  if (!refname)
    return NULL;

  for (i=num_level_maps-1; i &gt;= 0; i--)
  {
    if (DDF_CompareName(level_maps[i]-&gt;ddf.name, refname) != 0)
      continue;

    if (W_CheckNumForName(level_maps[i]-&gt;lump) == -1)
      continue;
    
    return level_maps[i];
  }

  return NULL;
}
</t>
<t tx="T2314">@ DDF_LevelGetPic

Adds finale pictures to the level's list.
@c

void DDF_LevelGetPic(const char *info, void *storage)
{
  finale_t *f = (finale_t *)storage;

  Z_Resize(f-&gt;pics, char, 9 * (f-&gt;numpics + 1));
  Z_StrNCpy(f-&gt;pics + f-&gt;numpics * 9, info, 8);
  f-&gt;numpics++;
}
</t>
<t tx="T2315">
void DDF_LevelGetSpecials(const char *info, void *storage)
{
  // -AJA- 2000/02/02: reworked this for new system.

  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, map_specials, &amp;flag_value,
      true, true))
  {
    case CHKF_Positive:
      buffer_map.force_on  |=  flag_value;
      buffer_map.force_off &amp;= ~flag_value;
      break;
    
    case CHKF_Negative:
      buffer_map.force_on  &amp;= ~flag_value;
      buffer_map.force_off |=  flag_value;
      break;

    case CHKF_User:
      buffer_map.force_on  &amp;= ~flag_value;
      buffer_map.force_off &amp;= ~flag_value;
      break;
    
    case CHKF_Unknown:
      DDF_WarnError("DDF_LevelGetSpecials: Unknown level special: %s", info);
      break;
  }
}
</t>
<t tx="T2316">
static specflags_t lighting_names[] =
{
    {"DOOM",    LMODEL_Doom, 0},
    {"DOOMISH", LMODEL_Doomish, 0},
    {"FLAT",    LMODEL_Flat, 0},
    {"VERTEX",  LMODEL_Vertex, 0},
    {NULL, 0, 0}
};

static specflags_t wistyle_names[] =
{
    {"DOOM", WISTYLE_Doom, 0},
    {"NONE", WISTYLE_None, 0},
    {NULL, 0, 0}
};

void DDF_LevelGetLighting(const char *info, void *storage)
{
  int flag_value;

  if (CHKF_Positive != DDF_MainCheckSpecialFlag(info, 
      lighting_names, &amp;flag_value, false, false))
  {
    DDF_WarnError("DDF_LevelGetLighting: Unknown model: %s", info);
    return;
  }

  ((lighting_model_e *)storage)[0] = flag_value;
}
</t>
<t tx="T2317">
void DDF_LevelGetWistyle(const char *info, void *storage)
{
  int flag_value;

  if (CHKF_Positive != DDF_MainCheckSpecialFlag(info, 
      wistyle_names, &amp;flag_value, false, false))
  {
    DDF_WarnError("DDF_LevelGetWistyle: Unknown stats: %s", info);
    return;
  }

  ((intermission_style_e *)storage)[0] = flag_value;
}
</t>
<t tx="T2318">@ignore
@language c

// Data Definition File Code (Linedefs)

@
Line Definitions Setup and Parser Code
//
// -KM- 1998/09/01 Written.
// -ACB- 1998/09/06 Beautification: cleaned up so I can read it :).
// -KM- 1998/10/29 New types of linedefs added: colourmap, sound, friction, gravity
//                  auto, singlesided, music, lumpcheck
//                  Removed sector movement to ddf_main.c, so can be accesed by
//                  ddf_sect.c
//
// -ACB- 2001/02/04 DDF_GetSecHeightReference moved to p_plane.c
@c

&lt;&lt; ddf_line #includes &gt;&gt;
&lt;&lt; ddf_line declarations &gt;&gt;
@others
</t>
<t tx="T2319">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "m_fixed.h"
#include "p_mobj.h"
#include "p_local.h"
#include "z_zone.h"

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</t>
<t tx="T2320">
#undef  DF
#define DF  DDF_CMD

#define DDF_LineHashFunc(x)  (((x) + 211) % 211)

// -KM- 1999/01/29 Improved scrolling.
// Scrolling
typedef enum
{
  dir_none = 0,
  dir_vert = 1,
  dir_up = 2,
  dir_horiz = 4,
  dir_left = 8
}
scrolldirs_e;

static linedeftype_t buffer_line;
static linedeftype_t *dynamic_line;

// these bits logically belong with buffer_line:
static float_t s_speed;
static scrolldirs_e s_dir;

const linedeftype_t template_line =
{
  DDF_BASE_NIL,  // ddf

  0,        // newtrignum
  0,        // how triggered (walk/switch/shoot)
  0,        // things that can trigger it
  KF_NONE,  // keys needed
  -1,       // can be activated repeatedly
  -1,       // special type: don't change.
  false,    // crushing

  // Floor
  {
    mov_undefined,  // type
    false,          // is_ceiling
    false,          // crush
    -1, -1,         // speed up/down
    REF_Absolute,   // dest ref
    0,              // dest
    REF_Surrounding + REF_HIGHEST + REF_INCLUDE,  // other ref
    0,              // other
    "",             // texture
    0, 0,           // wait, prewait
    sfx_None, sfx_None, sfx_None, sfx_None,  // SFX start/up/down/stop
    0, 0.0          // scroll_angle, scroll_speed
  },

  // Ceiling
  {
    mov_undefined,  // type
    true,           // is_ceiling
    false,          // crush
    -1, -1,         // speed up/down
    REF_Absolute,   // dest ref
    0,              // dest
    REF_Current + REF_CEILING,  // other ref
    0,              // other
    "",             // texture
    0, 0,           // wait, prewait
    sfx_None, sfx_None, sfx_None, sfx_None,  // SFX start/up/down/stop
    0, 0.0          // scroll_angle, scroll_speed
  },

  // Elevator
  {
    mov_undefined,  // type
    -1,             // speed up
    -1,             // speed down
    0,              // wait
    0,              // prewait
    sfx_None,       // SFX start
    sfx_None,       // SFX up
    sfx_None,       // SFX down
    sfx_None        // SFX stop
  },

  // Donut
  {
    false,  //  dodonut
    sfx_None, sfx_None,  // SFX down/stop inner circle
    sfx_None, sfx_None   // SFX up/stop outer loop
  },

  // Sliding Door
  {
    SLIDE_None,   // sliding type
    4.0,          // speed (distance per tic)
    150,          // wait time
    false,        // see through ?
    PERCENT_MAKE(90), // distance
    sfx_None,     // sfx_start
    sfx_None,     // sfx_open
    sfx_None,     // sfx_close
    sfx_None      // sfx_stop
  },

  // Tile Skies
  {
    TILESKY_None,  // type
    1,             // layer
    10,            // number
    1.2,           // squish
    -0.9,          // offset
  },
 
  // Ladders
  {
    0    // height
  },
 
  // Teleport
  {
    false,    // is a teleporter
    NULL,     // effect in object
    NULL,     // in object's name
    NULL,     // effect out object
    NULL,     // out object's name
    0,        // delay
    0         // special
  },

  // Lights
  {
    LITE_None, //  lights action
    64,        //  set light to this level
    PERCENT_MAKE(50), //  chance value
    0,0,0,     //  dark/bright time, sync
    8          //  step value
  },

  EXIT_None,   // exit type
  0, 0,        // scrolling X/Y
  0,           // scroll parts
  NULL,        // security message
  NULL,        // colourmap
  M_PI,        // gravity     \ 
  M_PI,        // friction     M_PI means "not changed"
  M_PI,        // viscosity    /
  M_PI,        // drag        /
  sfx_None,    // ambient_sfx
  sfx_None,    // activate_sfx
  0,           // music
  false,       // automatic line
  false,       // single sided

  // Extra floor:
  {
    0,           // type
    EFCTL_None   // control
  },

  PERCENT_MAKE(100), // translucency
  DEFAULT_APPEAR,  // appear
  0,    // special_flags
  0,    // trigger_effect
  0,    // line_effect
  0,    // line_parts
  0     // sector_effect
};

const moving_plane_t donut_floor =
{
  mov_Once,        //  Type
  false,           //  is_ceiling
  false,           //  crush
  FLOORSPEED / 2,  //  speed up
  FLOORSPEED / 2,  //  speed down
  REF_Absolute,    //  dest ref
  (float_t)INT_MAX,//  dest
  REF_Absolute,    //  other ref
  (float_t)INT_MAX,//  other
  "",              //  texture
  0, 0,            //  wait, prewait
  0, 0, 0, 0,      //  SFX start/up/down/stop
  0, 0             //  Scroll angle/speed
};

linedeftype_t ** ddf_linetypes;
int num_ddf_linetypes;

static stack_array_t ddf_linetypes_a;
static const linedeftype_t *line_lookup_cache[211];

// BOOM generalised linetype support
static linedeftype_t ** ddf_gen_lines;
int num_ddf_gen_lines;
static stack_array_t ddf_gen_lines_a;

static void DDF_LineGetTrigType(const char *info, void *storage);
static void DDF_LineGetActivators(const char *info, void *storage);
static void DDF_LineGetSecurity(const char *info, void *storage);
static void DDF_LineGetScroller(const char *info, void *storage);
static void DDF_LineGetScrollPart(const char *info, void *storage);
static void DDF_LineGetExtraFloor(const char *info, void *storage);
static void DDF_LineGetEFControl(const char *info, void *storage);
static void DDF_LineGetTeleportSpecial(const char *info, void *storage);
static void DDF_LineGetRadTrig(const char *info, void *storage);
static void DDF_LineGetSpecialFlags(const char *info, void *storage);
static void DDF_LineGetSlideType(const char *info, void *storage);
static void DDF_LineGetSkyType(const char *info, void *storage);
static void DDF_LineGetLineEffect(const char *info, void *storage);
static void DDF_LineGetSectorEffect(const char *info, void *storage);

static moving_plane_t dummy_floor;
static elevator_sector_t dummy_movsec;
static sliding_door_t dummy_slider;
static tilesky_info_t dummy_tilesky;
static ladder_info_t dummy_ladder;

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_floor

const commandlist_t floor_commands[] =
{
  DDF_CMD_SUB("TYPE", type, DDF_SectGetMType),
  DDF_CMD_SUB("SPEED UP",   speed_up,   DDF_MainGetFloat),
  DDF_CMD_SUB("SPEED DOWN", speed_down, DDF_MainGetFloat),
  DDF_CMD_SUB("DEST REF",   destref,    DDF_SectGetDestRef),
  DDF_CMD_SUB("DEST OFFSET", dest, DDF_MainGetFloat),
  DDF_CMD_SUB("OTHER REF",   otherref,  DDF_SectGetDestRef),
  DDF_CMD_SUB("OTHER OFFSET", other, DDF_MainGetFloat),
  DDF_CMD_SUB("TEXTURE", tex, DDF_MainGetInlineStr10),
  DDF_CMD_SUB("PAUSE TIME", wait,  DDF_MainGetTime),
  DDF_CMD_SUB("WAIT TIME", prewait,  DDF_MainGetTime),
  DDF_CMD_SUB("SFX START", sfxstart, DDF_MainLookupSound),
  DDF_CMD_SUB("SFX UP",    sfxup,    DDF_MainLookupSound),
  DDF_CMD_SUB("SFX DOWN",  sfxdown,  DDF_MainLookupSound),
  DDF_CMD_SUB("SFX STOP",  sfxstop,  DDF_MainLookupSound),
  DDF_CMD_SUB("SCROLL ANGLE", scroll_angle,DDF_MainGetAngle),
  DDF_CMD_SUB("SCROLL SPEED", scroll_speed,DDF_MainGetFloat),

  DDF_CMD_END
};

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_movsec

const commandlist_t elevator_commands[] =
{
  DDF_CMD_SUB("TYPE", type, DDF_SectGetMType),
  DDF_CMD_SUB("SPEED UP",   speed_up,   DDF_MainGetFloat),
  DDF_CMD_SUB("SPEED DOWN", speed_down, DDF_MainGetFloat),
  DDF_CMD_SUB("PAUSE TIME", wait, DDF_MainGetTime),
  DDF_CMD_SUB("WAIT TIME", prewait,   DDF_MainGetTime),
  DDF_CMD_SUB("SFX START", sfxstart,  DDF_MainLookupSound),
  DDF_CMD_SUB("SFX UP",    sfxup,     DDF_MainLookupSound),
  DDF_CMD_SUB("SFX DOWN",  sfxdown,   DDF_MainLookupSound),
  DDF_CMD_SUB("SFX STOP",  sfxstop,   DDF_MainLookupSound),

  DDF_CMD_END
};

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_tilesky

const commandlist_t tilesky_commands[] =
{
  DDF_CMD_SUB("TYPE",   type,   DDF_LineGetSkyType),
  DDF_CMD_SUB("LAYER",  layer,  DDF_MainGetNumeric),
  DDF_CMD_SUB("NUMBER", number, DDF_MainGetNumeric),
  DDF_CMD_SUB("SQUISH", squish, DDF_MainGetFloat),
  DDF_CMD_SUB("OFFSET", offset, DDF_MainGetFloat),

  DDF_CMD_END
};

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_ladder

const commandlist_t ladder_commands[] =
{
  DDF_CMD_SUB("HEIGHT", height, DDF_MainGetFloat),
  DDF_CMD_END
};

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_slider

const commandlist_t slider_commands[] =
{
  DDF_CMD_SUB("TYPE",  type, DDF_LineGetSlideType),
  DDF_CMD_SUB("SPEED", speed, DDF_MainGetFloat),
  DDF_CMD_SUB("PAUSE TIME", wait, DDF_MainGetTime),
  DDF_CMD_SUB("SEE THROUGH", see_through, DDF_MainGetBoolean),
  DDF_CMD_SUB("DISTANCE",  distance,  DDF_MainGetPercent),
  DDF_CMD_SUB("SFX START", sfx_start, DDF_MainLookupSound),
  DDF_CMD_SUB("SFX OPEN",  sfx_open,  DDF_MainLookupSound),
  DDF_CMD_SUB("SFX CLOSE", sfx_close, DDF_MainLookupSound),
  DDF_CMD_SUB("SFX STOP",  sfx_stop,  DDF_MainLookupSound),
  
  DDF_CMD_END
};

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_line

static const commandlist_t linedef_commands[] =
{
  // sub-commands
  DDF_SUB_LIST("FLOOR",    f, floor_commands),
  DDF_SUB_LIST("CEILING",  c, floor_commands),
  DDF_SUB_LIST("ELEVATOR", e, elevator_commands),
  DDF_SUB_LIST("SLIDER",   s, slider_commands),
  DDF_SUB_LIST("TILESKY",  sky, tilesky_commands),
  DDF_SUB_LIST("LADDER",   ladder, ladder_commands),

  DF("NEWTRIGGER", newtrignum, DDF_MainGetNumeric),
  DF("ACTIVATORS", obj, DDF_LineGetActivators),
  DF("TYPE", type, DDF_LineGetTrigType),
  DF("KEYS", keys, DDF_LineGetSecurity),
  DF("FAILED MESSAGE", failedmessage, DDF_MainGetString),
  DF("COUNT", count, DDF_MainGetNumeric),
  DF("SECSPECIAL", specialtype, DDF_MainGetNumeric),
  DF("CRUSH", crush, DDF_MainGetBoolean),

  DF("DONUT", d.dodonut, DDF_MainGetBoolean),
  DF("DONUT IN SFX", d.d_sfxin, DDF_MainLookupSound),
  DF("DONUT IN SFXSTOP", d.d_sfxinstop, DDF_MainLookupSound),
  DF("DONUT OUT SFX", d.d_sfxout, DDF_MainLookupSound),
  DF("DONUT OUT SFXSTOP", d.d_sfxoutstop, DDF_MainLookupSound),
  
  DF("TELEPORT", t.teleport, DDF_MainGetBoolean),
  DF("TELEPORT DELAY", t.delay, DDF_MainGetTime),
  DF("TELEIN EFFECTOBJ", t.inspawnobj_ref, DDF_MainGetString),
  DF("TELEOUT EFFECTOBJ", t.outspawnobj_ref, DDF_MainGetString),
  DF("TELEPORT SPECIAL", t.special, DDF_LineGetTeleportSpecial),
  
  DF("LIGHT TYPE", l.type, DDF_SectGetLighttype),
  DF("LIGHT LEVEL", l.level, DDF_MainGetNumeric),
  DF("LIGHT DARK TIME", l.darktime, DDF_MainGetTime),
  DF("LIGHT BRIGHT TIME", l.brighttime, DDF_MainGetTime),
  DF("LIGHT CHANCE", l.chance, DDF_MainGetPercent),
  DF("LIGHT SYNC", l.sync, DDF_MainGetTime),
  DF("LIGHT STEP", l.step, DDF_MainGetNumeric),
  DF("EXIT", e_exit, DDF_SectGetExit),
  
  {"SCROLL", DDF_LineGetScroller, &amp;s_dir, NULL},
  {"SCROLLING SPEED", DDF_MainGetFloat, &amp;s_speed, NULL},
  
  DF("SCROLL XSPEED", s_xspeed, DDF_MainGetFloat),
  DF("SCROLL YSPEED", s_yspeed, DDF_MainGetFloat),
  DF("SCROLL PARTS", scroll_parts, DDF_LineGetScrollPart),
  DF("USE COLOURMAP", use_colourmap, DDF_MainGetColourmap),
  DF("GRAVITY", gravity, DDF_MainGetFloat),
  DF("FRICTION", friction, DDF_MainGetFloat),
  DF("VISCOSITY", viscosity, DDF_MainGetFloat),
  DF("DRAG", drag, DDF_MainGetFloat),
  DF("AMBIENT SOUND", ambient_sfx, DDF_MainLookupSound),
  DF("ACTIVATE SOUND", activate_sfx, DDF_MainLookupSound),
  DF("MUSIC", music, DDF_MainGetNumeric),
  DF("AUTO", autoline, DDF_MainGetBoolean),
  DF("SINGLESIDED", singlesided, DDF_MainGetBoolean),
  DF("EXTRAFLOOR TYPE", ddf, DDF_LineGetExtraFloor),
  DF("EXTRAFLOOR CONTROL", ddf, DDF_LineGetEFControl),
  DF("TRANSLUCENCY", translucency, DDF_MainGetPercent),
  DF("WHEN APPEAR", appear, DDF_MainGetWhenAppear),
  DF("SPECIAL", special_flags, DDF_LineGetSpecialFlags),
  DF("RADIUS TRIGGER", ddf, DDF_LineGetRadTrig),
  DF("LINE EFFECT", line_effect, DDF_LineGetLineEffect),
  DF("LINE PARTS",  line_parts,  DDF_LineGetScrollPart),
  DF("SECTOR EFFECT", sector_effect, DDF_LineGetSectorEffect),
  
  // -AJA- backwards compatibility cruft...
  DF("!EXTRAFLOOR TRANSLUCENCY", translucency, DDF_MainGetPercent),
  DF("!SOUND", ddf, DDF_DummyFunction),
  DF("!LIGHT PROBABILITY", ddf, DDF_DummyFunction),

  DDF_CMD_END
};


// -AJA- FIXME

static struct
{
  char *s;
  int n;
}

s_scroll[] =
{
  { "NONE", dir_none | dir_none } ,
  { "UP", (dir_vert | dir_up) | ((~dir_none) &lt;&lt; 16) } ,
  { "DOWN", (dir_vert) | ((~dir_up) &lt;&lt; 16) } ,
  { "LEFT", (dir_horiz | dir_left) | ((~dir_none) &lt;&lt; 16) } ,
  { "RIGHT", (dir_horiz) | ((~dir_left) &lt;&lt; 16) }
}
,

// FIXME: use keytype_names (in ddf_mobj.c)
s_keys[] =
{
  { "NONE",           KF_NONE },

  { "BLUE CARD",      KF_BlueCard },
  { "YELLOW CARD",    KF_YellowCard },
  { "RED CARD",       KF_RedCard },
  { "BLUE SKULL",     KF_BlueSkull },
  { "YELLOW SKULL",   KF_YellowSkull },
  { "RED SKULL",      KF_RedSkull },
  { "GREEN CARD",     KF_GreenCard },
  { "GREEN SKULL",    KF_GreenSkull },

  { "GOLD KEY",       KF_GoldKey },
  { "SILVER KEY",     KF_SilverKey },
  { "BRASS KEY",      KF_BrassKey },
  { "COPPER KEY",     KF_CopperKey },
  { "STEEL KEY",      KF_SteelKey },
  { "WOODEN KEY",     KF_WoodenKey },
  { "FIRE KEY",       KF_FireKey },
  { "WATER KEY",      KF_WaterKey },
    
  // backwards compatibility
  { "REQUIRES ALL", KF_STRICTLY_ALL |
        KF_BlueCard | KF_YellowCard | KF_RedCard |
        KF_BlueSkull | KF_YellowSkull | KF_RedSkull }
}
,

s_trigger[] =
{
  { "WALK",  line_walkable },
  { "PUSH",  line_pushable },
  { "SHOOT", line_shootable },
  { "MANUAL", line_manual }
}
,

s_activators[] =
{
  { "PLAYER",  trig_player } ,
  { "MONSTER", trig_monster },
  { "OTHER",   trig_other },

  // obsolete stuff
  { "MISSILE", 0 }
};
</t>
<t tx="T2321">@ DDF PARSE ROUTINES


LinedefStartEntry
@c

static boolean_t LinedefStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;
  int number = MAX(0, atoi(name));

  if (number == 0)
    DDF_Error("Bad linedef number in lines.ddf: %s\n", name);

  for (i=0; i &lt; num_ddf_linetypes; i++)
  {
    if (ddf_linetypes[i]-&gt;ddf.number == number)
    {
      dynamic_line = ddf_linetypes[i];
      replaces = true;
      break;
    }
  }
    
  // if found, adjust pointer array to keep newest entries at end
  if (replaces &amp;&amp; i &lt; (num_ddf_linetypes-1))
  {
    Z_MoveData(ddf_linetypes + i, ddf_linetypes + i + 1, linedeftype_t *,
        num_ddf_linetypes - i);
    ddf_linetypes[num_ddf_linetypes - 1] = dynamic_line;
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;ddf_linetypes_a, ++num_ddf_linetypes);
    
    dynamic_line = ddf_linetypes[num_ddf_linetypes - 1];
  }

  dynamic_line-&gt;ddf.name   = NULL;
  dynamic_line-&gt;ddf.number = number;

  s_speed = 1.0;
  s_dir = dir_none;

  // instantiate the static entry
  buffer_line = template_line;

  return replaces;
}
</t>
<t tx="T2322">@ LinedefParseField
@c

static void LinedefParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("LINEDEF_PARSE: %s = %s;\n", field, contents);
#endif

  if (DDF_MainParseField(linedef_commands, field, contents))
    return;

  // handle properties
  if (index == 0 &amp;&amp; DDF_CompareName(contents, "TRUE") == 0)
  {
    DDF_LineGetSpecialFlags(field, NULL);  // FIXME FOR OFFSETS
    return;
  }

  DDF_WarnError("Unknown lines.ddf command: %s\n", field);
}
</t>
<t tx="T2323">@ LinedefFinishEntry
@c

static void LinedefFinishEntry(void)
{
  ddf_base_t base;
  
  buffer_line.c.crush = buffer_line.f.crush = buffer_line.crush;

  // -KM- 1999/01/29 Convert old style scroller to new.
  if (s_dir &amp; dir_vert)
  {
    if (s_dir &amp; dir_up)
      buffer_line.s_yspeed = s_speed;
    else
      buffer_line.s_yspeed = -s_speed;
  }
  if (s_dir &amp; dir_horiz)
  {
    if (s_dir &amp; dir_left)
      buffer_line.s_xspeed = s_speed;
    else
      buffer_line.s_xspeed = -s_speed;
  }

  // backwards compat: COUNT=0 means no limit on triggering
  if (buffer_line.count == 0)
    buffer_line.count = -1;

  // check stuff...

  if (buffer_line.ef.type)
  {
    if ((buffer_line.ef.type &amp; EXFL_Flooder) &amp;&amp;
        (buffer_line.ef.type &amp; EXFL_NoShade))
    {
      DDF_WarnError("FLOODER and NOSHADE tags cannot be used together.\n");
      buffer_line.ef.type &amp;= ~EXFL_Flooder;
    }

    if (! (buffer_line.ef.type &amp; EXFL_Present))
    {
      DDF_WarnError("Extrafloor type missing THIN, THICK or LIQUID.\n");
      buffer_line.ef.type = 0;
    }
  }

  if (buffer_line.friction != (float_t)M_PI &amp;&amp; 
      buffer_line.friction &lt; 0.01)
  {
    DDF_WarnError("Friction value too low (%1.2f), it would prevent "
        "all movement.\n", buffer_line.friction);
    buffer_line.friction = 0.1;
  }
  
  if (buffer_line.viscosity != (float_t)M_PI &amp;&amp; 
      buffer_line.viscosity &gt; 0.99)
  {
    DDF_WarnError("Viscosity value too high (%1.2f), it would prevent "
        "all movement.\n", buffer_line.viscosity);
    buffer_line.viscosity = 0.9;
  }
  
  // FIXME: check more stuff...
  
  // transfer static entry to dynamic entry
  
  base = dynamic_line-&gt;ddf;
  dynamic_line[0] = buffer_line;
  dynamic_line-&gt;ddf = base;

  // compute CRC...
  CRC32_Init(&amp;dynamic_line-&gt;ddf.crc);

  // FIXME: add stuff...
  
  CRC32_Done(&amp;dynamic_line-&gt;ddf.crc);
}
</t>
<t tx="T2324">@ LinedefClearAll
@c

static void LinedefClearAll(void)
{
  // it is safe to just delete all the lines

  num_ddf_linetypes = 0;
  Z_SetArraySize(&amp;ddf_linetypes_a, num_ddf_linetypes);
}
</t>
<t tx="T2325">@ DDF_ReadLines
@c

void DDF_ReadLines(void *data, int size)
{
  readinfo_t lines;

  lines.memfile = data;
  lines.memsize = size;
  lines.tag = "LINES";
  lines.entries_per_dot = 6;

  if (lines.memfile)
  {
    lines.message = NULL;
    lines.filename = NULL;
    lines.lumpname = "DDFLINE";
  }
  else
  {
    lines.message = "DDF_InitLinedefs";
    lines.filename = "lines.ddf";
    lines.lumpname = NULL;
  }

  lines.start_entry  = LinedefStartEntry;
  lines.parse_field  = LinedefParseField;
  lines.finish_entry = LinedefFinishEntry;
  lines.clear_all    = LinedefClearAll;

  DDF_MainReadFile(&amp;lines);
}
</t>
<t tx="T2326">@ DDF_LinedefInit
@c

void DDF_LinedefInit(void)
{
  Z_InitStackArray(&amp;ddf_linetypes_a, (void ***)&amp;ddf_linetypes, 
      sizeof(linedeftype_t), 0);

  Z_InitStackArray(&amp;ddf_gen_lines_a, (void ***)&amp;ddf_gen_lines, 
      sizeof(linedeftype_t), 0);
  
  // clear lookup cache
  memset(line_lookup_cache, 0, sizeof(line_lookup_cache));
}
</t>
<t tx="T2327">@ DDF_LinedefCleanUp
@c

void DDF_LinedefCleanUp(void)
{
  int i;
  
  for (i=0; i &lt; num_ddf_linetypes; i++)
  {
    linedeftype_t *line = ddf_linetypes[i];
    
    DDF_ErrorSetEntryName("[%d]  (lines.ddf)", line-&gt;ddf.number);

    line-&gt;t.inspawnobj = line-&gt;t.inspawnobj_ref ?
        DDF_MobjLookup(line-&gt;t.inspawnobj_ref) : NULL;
    
    line-&gt;t.outspawnobj = line-&gt;t.outspawnobj_ref ?
        DDF_MobjLookup(line-&gt;t.outspawnobj_ref) : NULL;
    
    DDF_ErrorClearEntryName();
  }
}
</t>
<t tx="T2328">@ DDF_LineGetScroller

Check for scroll types
@c

void DDF_LineGetScroller(const char *info, void *storage)
{
  int i;

  for (i = sizeof(s_scroll) / sizeof(s_scroll[0]); i--;)
  {
    if (!stricmp(info, s_scroll[i].s))
    {
      s_dir &amp;= s_scroll[i].n &gt;&gt; 16;
      s_dir |= s_scroll[i].n &amp; 0xffff;
      return;
    }
  }
  DDF_WarnError("Unknown scroll direction %s\n", info);
}
</t>
<t tx="T2329">@ DDF_LineGetSecurity

Get Red/Blue/Yellow
@c

void DDF_LineGetSecurity(const char *info, void *storage)
{
  int i;
  boolean_t required = false;

  if (info[0] == '+')
  {
    required = true;
    info++;
  }
  else if (buffer_line.keys &amp; KF_STRICTLY_ALL)
  {
    // -AJA- when there is at least one required key, then the
    // non-required keys don't have any effect.
    return;
  }

  for (i = sizeof(s_keys) / sizeof(s_keys[0]); i--;)
  {
    if (!stricmp(info, s_keys[i].s))
    {
      buffer_line.keys |= s_keys[i].n;

      if (required)
        buffer_line.keys |= KF_STRICTLY_ALL;

      return;
    }
  }

  DDF_WarnError("Unknown key type %s\n", info);
}
</t>
<t tx="T2330">@ DDF_LineGetTrigType

Check for walk/push/shoot
@c

void DDF_LineGetTrigType(const char *info, void *storage)
{
  int i;

  for (i = sizeof(s_trigger) / sizeof(s_trigger[0]); i--;)
  {
    if (!stricmp(info, s_trigger[i].s))
    {
      buffer_line.type = s_trigger[i].n;
      return;
    }
  }

  DDF_WarnError("Unknown Trigger type %s\n", info);
}
</t>
<t tx="T2331">@ DDF_LineGetActivators

Get player/monsters/missiles
@c

void DDF_LineGetActivators(const char *info, void *storage)
{
  int i;

  for (i = sizeof(s_activators) / sizeof(s_activators[0]); i--;)
  {
    if (!stricmp(info, s_activators[i].s))
    {
      buffer_line.obj |= s_activators[i].n;
      return;
    }
  }

  DDF_WarnError("Unknown Activator type %s\n", info);
}
</t>
<t tx="T2332">
static specflags_t extrafloor_types[] =
{
  // definers:
  {"THIN",          EF_DEF_THIN,       0},
  {"THICK",         EF_DEF_THICK,      0},
  {"LIQUID",        EF_DEF_LIQUID,     0},

  // modifiers:
  {"SEE THROUGH",   EXFL_SeeThrough,   0},
  {"WATER",         EXFL_Water,        0},
  {"SHADE",         EXFL_NoShade,      1},
  {"FLOODER",       EXFL_Flooder,      0},
  {"SIDE UPPER",    EXFL_SideUpper,    0},
  {"SIDE LOWER",    EXFL_SideLower,    0},
  {"BOOMTEX",       EXFL_BoomTex,      0},

  // backwards compat...
  {"FALL THROUGH",  EXFL_Liquid, 0},
  {"SHOOT THROUGH", 0, 0},
  {NULL, 0, 0}
};

//
// DDF_LineGetExtraFloor
//
// Gets the extra floor type(s).
//
// -AJA- 1999/06/21: written.
// -AJA- 2000/03/27: updated for simpler system.
//
void DDF_LineGetExtraFloor(const char *info, void *storage)
{
  int flag_value;

  if (DDF_CompareName(info, "NONE") == 0)
  {
    buffer_line.ef.type = 0;
    return;
  }

  switch (DDF_MainCheckSpecialFlag(info, extrafloor_types,
      &amp;flag_value, true, false))
  {
    case CHKF_Positive:
      buffer_line.ef.type |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_line.ef.type &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown Extrafloor Type: %s", info);
      break;
  }
}
</t>
<t tx="T2333">
static specflags_t ef_control_types[] =
{
    {"NONE",   EFCTL_None,   0},
    {"REMOVE", EFCTL_Remove, 0},
    {NULL, 0, 0}
};

//
// DDF_LineGetEFControl
//
void DDF_LineGetEFControl(const char *info, void *storage)
{
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, ef_control_types,
      &amp;flag_value, false, false))
  {
    case CHKF_Positive:
    case CHKF_Negative:
      buffer_line.ef.control = flag_value;
      break;
    
    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown CONTROL_EXTRAFLOOR tag: %s", info);
      break;
  }
}
</t>
<t tx="T2334">
static specflags_t teleport_specials[] =
{
    {"SAME DIR", TELSP_SameDir, 0},
    {"SAME HEIGHT", TELSP_SameHeight, 0},
    {"SAME SPEED", TELSP_SameSpeed, 0},
    {"SAME OFFSET", TELSP_SameOffset, 0},
    {"PRESERVE", TELSP_Preserve, 0},
    {"ROTATE", TELSP_Rotate, 0},
    {NULL, 0, 0}
};

//
// DDF_LineGetTeleportSpecial
//
// Gets the teleporter special flags.
//
// -AJA- 1999/07/12: written.
//
void DDF_LineGetTeleportSpecial(const char *info, void *storage)
{
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, teleport_specials,
      &amp;flag_value, true, false))
  {
    case CHKF_Positive:
      buffer_line.t.special |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_line.t.special &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("DDF_LineGetTeleportSpecial: Unknown Special: %s", info);
      break;
  }
}
</t>
<t tx="T2335">
static specflags_t scrollpart_specials[] =
{
    {"RIGHT UPPER", SCPT_RightUpper, 0},
    {"RIGHT MIDDLE", SCPT_RightMiddle, 0},
    {"RIGHT LOWER", SCPT_RightLower, 0},
    {"RIGHT", SCPT_RIGHT, 0},
    {"LEFT UPPER", SCPT_LeftUpper, 0},
    {"LEFT MIDDLE", SCPT_LeftMiddle, 0},
    {"LEFT LOWER", SCPT_LeftLower, 0},
    {"LEFT", SCPT_LEFT, 0},
    {"LEFT REVERSE X", SCPT_LeftRevX, 0},
    {"LEFT REVERSE Y", SCPT_LeftRevY, 0},
    {NULL, 0, 0}
};

//
// DDF_LineGetScrollPart
//
// Gets the scroll part flags.
//
// -AJA- 1999/07/12: written.
//
void DDF_LineGetScrollPart(const char *info, void *storage)
{
  int flag_value;
  scroll_part_e *dest = (scroll_part_e *)storage;

  if (DDF_CompareName(info, "NONE") == 0)
  {
    (*dest) = 0;
    return;
  }
 
  switch (DDF_MainCheckSpecialFlag(info, scrollpart_specials,
      &amp;flag_value, true, false))
  {
    case CHKF_Positive:
      (*dest) |= flag_value;
      break;
    
    case CHKF_Negative:
      (*dest) &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("DDF_LineGetScrollPart: Unknown Part: %s", info);
      break;
  }
}
</t>
<t tx="T2336">@ ----------------------------------------------------------------------------

DDF_LineLookupGeneralised

Support for BOOM generalised linetypes.
@c

static const linedeftype_t *DDF_LineLookupGeneralised(int number)
{
  int i;
  linedeftype_t *line;

  for (i=0; i &lt; num_ddf_gen_lines; i++)
  {
    if (ddf_gen_lines[i]-&gt;ddf.number == number)
      return ddf_gen_lines[i];
  }

  // this linetype does not exist yet in the array of dynamic
  // linetypes.  Thus we need to create it.

  Z_SetArraySize(&amp;ddf_gen_lines_a, ++num_ddf_gen_lines);
    
  line = ddf_gen_lines[num_ddf_gen_lines - 1];

  // instantiate it with defaults
  (*line) = template_line;

  DDF_BoomMakeGenLine(line, number);

  return (const linedeftype_t *) line;
}
</t>
<t tx="T2337">
void DDF_LineClearGeneralised(void)
{
  num_ddf_gen_lines = 0;
  Z_SetArraySize(&amp;ddf_gen_lines_a, num_ddf_gen_lines);

  // clear the cache
  memset(line_lookup_cache, 0, sizeof(line_lookup_cache));
}
</t>
<t tx="T2338">@ DDF_LineLookupNum

Returns the special linedef properties from given specialtype

-KM- 1998/09/01 Wrote Procedure
-ACB- 1998/09/06 Remarked and Reformatted....
@c

const linedeftype_t *DDF_LineLookupNum(int number)
{
  int slot = DDF_LineHashFunc(number);
  int i;

  // check the cache
  if (line_lookup_cache[slot] &amp;&amp;
      line_lookup_cache[slot]-&gt;ddf.number == number)
  {
    return line_lookup_cache[slot];
  }

  // check for BOOM generalised linetype
  if ((level_flags.compat_mode == CM_BOOM) &amp;&amp; number &gt;= 0x2F80)
  {
    line_lookup_cache[slot] = DDF_LineLookupGeneralised(number);
    return line_lookup_cache[slot];
  }
  
  // find line by number
  // NOTE: go backwards, so newer ones are found first
  for (i=num_ddf_linetypes-1; i &gt;= 0; i--)
  {
    if (ddf_linetypes[i]-&gt;ddf.number == number)
      break;
  }
  
  if (i &lt; 0)
  {
    // -AJA- 1999/06/19: Don't crash out if the line type is unknown, just
    // print a message and ignore it (like for unknown thing types).

    I_Warning("Unknown line type %i\n", number);

    return &amp;template_line;
  }

  // update the cache
  line_lookup_cache[slot] = ddf_linetypes[i];

  return line_lookup_cache[slot];
}
</t>
<t tx="T2339">
static specflags_t line_specials[] =
{
  {"MUST REACH", LINSP_MustReach, 0},
  {"SWITCH SEPARATE", LINSP_SwitchSeparate, 0},
  {NULL, 0, 0}
};

//
// DDF_LineGetSpecialFlags
//
// Gets the line special flags.
//
void DDF_LineGetSpecialFlags(const char *info, void *storage)
{
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, line_specials, &amp;flag_value,
      true, false))
  {
    case CHKF_Positive:
      buffer_line.special_flags |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_line.special_flags &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown line special: %s", info);
      break;
  }
}
</t>
<t tx="T2340">@ DDF_LineGetRadTrig

Gets the line's radius trigger effect.
@c

static void DDF_LineGetRadTrig(const char *info, void *storage)
{
  if (DDF_CompareName(info, "ENABLE_TAGGED") == 0)
  {
    buffer_line.trigger_effect = +1;
    return;
  }
  if (DDF_CompareName(info, "DISABLE_TAGGED") == 0)
  {
    buffer_line.trigger_effect = -1;
    return;
  }

  DDF_WarnError("DDF_LineGetRadTrig: Unknown effect: %s\n", info);
}
</t>
<t tx="T2341">
static const specflags_t slidingdoor_names[] =
{
  {"NONE",   SLIDE_None,   0},
  {"LEFT",   SLIDE_Left,   0},
  {"RIGHT",  SLIDE_Right,  0},
  {"CENTER", SLIDE_Center, 0},
  {"CENTRE", SLIDE_Center, 0},   // synonym
  {NULL, 0, 0}
};

//
// DDF_LineGetSlideType
//
static void DDF_LineGetSlideType(const char *info, void *storage)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(info,
      slidingdoor_names, (int *) storage, false, false))
  {
    DDF_WarnError("DDF_LineGetSlideType: Unknown slider: %s\n", info);
  }
}
</t>
<t tx="T2342">
static const specflags_t tilesky_names[] =
{
  {"NONE",    TILESKY_None,    0},
  {"FLAT",    TILESKY_Flat,    0},
  {"TEXTURE", TILESKY_Texture, 0},
  {NULL, 0, 0}
};

//
// DDF_LineGetSkyType
//
static void DDF_LineGetSkyType(const char *info, void *storage)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(info,
      tilesky_names, (int *) storage, false, false))
  {
    DDF_WarnError("DDF_LineGetSkyType: Unknown type: %s\n", info);
  }
}
</t>
<t tx="T2343">
static specflags_t line_effect_names[] =
{
  {"TRANSLUCENT",    LINEFX_Translucency, 0},
  {"VECTOR SCROLL",  LINEFX_VectorScroll, 0},
  {"OFFSET SCROLL",  LINEFX_OffsetScroll, 0},

  {"SCALE TEX",      LINEFX_Scale,         0},
  {"SKEW TEX",       LINEFX_Skew,          0},
  {"LIGHT WALL",     LINEFX_LightWall,     0},

  {"UNBLOCK THINGS", LINEFX_UnblockThings, 0},
  {"BLOCK SHOTS",    LINEFX_BlockShots,    0},
  {"BLOCK SIGHT",    LINEFX_BlockSight,    0},
  {NULL, 0, 0}
};

//
// DDF_LineGetLineEffect
//
// Gets the line effect flags.
//
static void DDF_LineGetLineEffect(const char *info, void *storage)
{
  int flag_value;

  if (DDF_CompareName(info, "NONE") == 0)
  {
    buffer_line.line_effect = 0;
    return;
  }

  switch (DDF_MainCheckSpecialFlag(info, line_effect_names,
      &amp;flag_value, true, false))
  {
    case CHKF_Positive:
      buffer_line.line_effect |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_line.line_effect &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown line effect type: %s", info);
      break;
  }
}
</t>
<t tx="T2344">
static specflags_t sector_effect_names[] =
{
  {"LIGHT FLOOR",     SECTFX_LightFloor,     0},
  {"LIGHT CEILING",   SECTFX_LightCeiling,   0},
  {"SCROLL FLOOR",    SECTFX_ScrollFloor,    0},
  {"SCROLL CEILING",  SECTFX_ScrollCeiling,  0},
  {"PUSH THINGS",     SECTFX_PushThings,     0},
  {"RESET FLOOR",     SECTFX_ResetFloor,     0},
  {"RESET CEILING",   SECTFX_ResetCeiling,   0},
 
  {"ALIGN FLOOR",     SECTFX_AlignFloor,     0},
  {"ALIGN CEILING",   SECTFX_AlignCeiling,   0},
  {"SCALE FLOOR",     SECTFX_ScaleFloor,     0},
  {"SCALE CEILING",   SECTFX_ScaleCeiling,   0},
  {NULL, 0, 0}
};

//
// DDF_LineGetSectorEffect
//
// Gets the sector effect flags.
//
static void DDF_LineGetSectorEffect(const char *info, void *storage)
{
  int flag_value;

  if (DDF_CompareName(info, "NONE") == 0)
  {
    buffer_line.sector_effect = 0;
    return;
  }

  switch (DDF_MainCheckSpecialFlag(info, sector_effect_names,
      &amp;flag_value, true, false))
  {
    case CHKF_Positive:
      buffer_line.sector_effect |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_line.sector_effect &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown sector effect type: %s", info);
      break;
  }
}
</t>
<t tx="T2345">@ignore
@language c

// Data Definition Files Code (Main)

&lt;&lt; ddf_main #includes &gt;&gt;
&lt;&lt; ddf_main declarations &gt;&gt;
@others
</t>
<t tx="T2346">#include "i_defs.h"

#include "ddf_main.h"

#include "e_search.h"
#include "ddf_locl.h"
#include "dm_state.h"
#include "dstrings.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_math.h"
#include "m_misc.h"
#include "p_action.h"
#include "p_mobj.h"
#include "r_things.h"
#include "z_zone.h"
</t>
<t tx="T2347">
#define DEBUG_DDFREAD  0

static readchar_t DDF_MainProcessChar(char character, char *buffer,
    readstatus_t status);

//
// DDF_Error
//
// -AJA- 1999/10/27: written.

static int cur_ddf_line_num;
static char *cur_ddf_filename = NULL;
static char *cur_ddf_entryname = NULL;
static char *cur_ddf_linedata = NULL;
</t>
<t tx="T2348">
void DDF_Error(const char *err, ...)
{
  va_list argptr;
  char buffer[2048];
  char *pos;

  buffer[2047] = 0;

  // put actual error message on first line
  va_start(argptr, err);
  vsprintf(buffer, err, argptr);
  va_end(argptr);
 
  pos = buffer + strlen(buffer);

  if (cur_ddf_filename)
  {
    sprintf(pos, "Error occurred near line %d of %s\n", 
        cur_ddf_line_num, cur_ddf_filename);
    pos += strlen(pos);
  }

  if (cur_ddf_entryname)
  {
    sprintf(pos, "Error occurred in entry: %s\n", cur_ddf_entryname);
    pos += strlen(pos);
  }

  if (cur_ddf_linedata)
  {
    sprintf(pos, "Line contents: %s\n", cur_ddf_linedata);
    pos += strlen(pos);
  }

  // check for buffer overflow
  DEV_ASSERT(buffer[2047] == 0, ("Buffer overflow in DDF_Error"));
  
  // add a blank line for readability under DOS/Linux.  Two linefeeds
  // because the cursor may be at the end of a line with dots.
  I_Printf("\n\n");
 
  I_Error("%s", buffer);
}
</t>
<t tx="T2349">
void DDF_Warning(const char *err, ...)
{
  va_list argptr;
  char buffer[1024];

  if (no_warnings)
    return;

  va_start(argptr, err);
  vsprintf(buffer, err, argptr);
  va_end(argptr);

  I_Warning("\n");

  if (cur_ddf_filename)
  {
    I_Warning("Found problem near line %d of %s\n", 
        cur_ddf_line_num, cur_ddf_filename);
  }

  if (cur_ddf_entryname)
    I_Warning("occurred in entry: %s\n", cur_ddf_entryname);

  if (cur_ddf_linedata)
    I_Warning("with line contents: %s\n", cur_ddf_linedata);

  I_Warning("%s", buffer);
}
</t>
<t tx="T2350">
void DDF_WarnError(const char *err, ...)
{
  va_list argptr;
  char buffer[1024];

  va_start(argptr, err);
  vsprintf(buffer, err, argptr);
  va_end(argptr);

  if (strict_errors)
    DDF_Error("%s", buffer);
  else
    DDF_Warning("%s", buffer);
}
</t>
<t tx="T2351">
static void DDF_ErrorSetFilename(const char *name)
{
  if (cur_ddf_filename)
    Z_Free(cur_ddf_filename);

  cur_ddf_filename = Z_StrDup(name);
}
</t>
<t tx="T2352">
static void DDF_ErrorClearFilename(void)
{
  if (cur_ddf_filename)
  {
    Z_Free(cur_ddf_filename);
    cur_ddf_filename = NULL;
  }
}
</t>
<t tx="T2353">@ DDF_ErrorSetEntryName

Note: should only be called by external code outside of parsing (in
particular: during the Cleanup routines).
@c

void DDF_ErrorSetEntryName(const char *err, ...)
{
  va_list argptr;
  char buffer[1024];

  if (cur_ddf_entryname)
    Z_Free(cur_ddf_entryname);

  va_start(argptr, err);
  vsprintf(buffer, err, argptr);
  va_end(argptr);
  
  cur_ddf_entryname = Z_StrDup(buffer);
}
</t>
<t tx="T2354">@ DDF_ErrorClearEntryName

Note: should only be called by external code outside of parsing (in
particular: during the Cleanup routines).
@c

void DDF_ErrorClearEntryName(void)
{
  if (cur_ddf_entryname)
  {
    Z_Free(cur_ddf_entryname);
    cur_ddf_entryname = NULL;
  }
}
</t>
<t tx="T2355">
static void DDF_ErrorSetLineData(const char *data, int len)
{
  char buffer[1024];

  if (cur_ddf_linedata)
    Z_Free(cur_ddf_linedata);

  if (len &gt; 500)
    len = 500;
 
  Z_StrNCpy(buffer, data, len);

  cur_ddf_linedata = Z_StrDup(buffer);
}
</t>
<t tx="T2356">
static void DDF_ErrorClearLineData(void)
{
  if (cur_ddf_linedata)
  {
    Z_Free(cur_ddf_linedata);
    cur_ddf_linedata = NULL;
  }
}
</t>
<t tx="T2357">
void DDF_MainInit(void)
{
  I_Printf("Data Definition v%i.%02i\n", DDFVERSION / 100, DDFVERSION % 100);

  DDF_StateInit();
  DDF_LanguageInit();
  DDF_SFXInit();
  DDF_ColmapInit();
  DDF_AttackInit(); 
  DDF_WeaponInit();
  DDF_MobjInit();
  DDF_LinedefInit();
  DDF_SectorInit();
  DDF_SWInit();
  DDF_AnimInit();
  DDF_GameInit();
  DDF_LevelInit();
  DDF_MusicPlaylistInit();

  if (external_ddf)
  {
    DDF_ReadLangs(NULL, 0);
    DDF_ReadSFX(NULL, 0);
    DDF_ReadColourMaps(NULL, 0);
    DDF_ReadAtks(NULL, 0); 
    DDF_ReadWeapons(NULL, 0);
    DDF_ReadThings(NULL, 0);
    DDF_ReadLines(NULL, 0);
    DDF_ReadSectors(NULL, 0);
    DDF_ReadSW(NULL, 0);
    DDF_ReadAnims(NULL, 0);
    DDF_ReadGames(NULL, 0);
    DDF_ReadLevels(NULL, 0);
    DDF_ReadMusicPlaylist(NULL, 0);
  }
}
</t>
<t tx="T2358">@ -KM- 1999/01/29 Fixed #define system.
@c

typedef struct
{
  char *name;
  char *value;
}
define_t;

// -AJA- 1999/09/12: Made these static.  The variable `defines' was
//       clashing with the one in rad_trig.c.  Ugh.

static define_t *defines = NULL;
static int numDefines = 0;

static void DDF_MainAddDefine(char *name, char *value)
{
  int i;

  for (i = 0; i &lt; numDefines; i++)
  {
    if (!strcmp(defines[i].name, name))
      DDF_Error("Redefinition of '%s'\n", name);
  }

  Z_Resize(defines, define_t, numDefines + 1);

  defines[numDefines].name = name;
  defines[numDefines++].value = value;
}
</t>
<t tx="T2359">
static char *DDF_MainGetDefine(char *name)
{
  int i;

  for (i = 0; i &lt; numDefines; i++)
    if (!strcmp(defines[i].name, name))
      return defines[i].value;

  // Not a define.
  return name;
}
</t>
<t tx="T2360">@ DDF_MainCleanup

This goes through the information loaded via DDF and matchs any
info stored as references.
@c

boolean_t DDF_MainCleanUp(void)
{
  int i;
  char *s;

  DDF_LanguageCleanUp();
  DDF_MobjCleanUp();
  DDF_AttackCleanUp();
  DDF_StateCleanUp();
  DDF_LinedefCleanUp();
  DDF_SFXCleanUp();
  DDF_ColmapCleanUp();
  DDF_WeaponCleanUp();
  DDF_SectorCleanUp();
  DDF_SWCleanUp();
  DDF_AnimCleanUp();
  DDF_GameCleanUp();
  DDF_LevelCleanUp();
  DDF_MusicPlaylistCleanUp();

  // -AJA- FIXME: all this stuff belongs elsewhere...
  
  //hu_stuff.c
  //m_misc.c
  // -KM- 1999/01/29 Added chat macro defaults, gamma messages and talk keys back in.
  i = 0;

  while (strcmp(defaults[i].name, "chatmacro0"))
    i++;

  // -ACB- 1999/09/28 Proper Casting Order
  chat_macros[0] = DDF_LanguageLookup("DefaultCHATMACRO0");
  chat_macros[1] = DDF_LanguageLookup("DefaultCHATMACRO1");
  chat_macros[2] = DDF_LanguageLookup("DefaultCHATMACRO2");
  chat_macros[3] = DDF_LanguageLookup("DefaultCHATMACRO3");
  chat_macros[4] = DDF_LanguageLookup("DefaultCHATMACRO4");
  chat_macros[5] = DDF_LanguageLookup("DefaultCHATMACRO5");
  chat_macros[6] = DDF_LanguageLookup("DefaultCHATMACRO6");
  chat_macros[7] = DDF_LanguageLookup("DefaultCHATMACRO7");
  chat_macros[8] = DDF_LanguageLookup("DefaultCHATMACRO8");
  chat_macros[9] = DDF_LanguageLookup("DefaultCHATMACRO9");

  defaults[i++].defaultvalue = (int)chat_macros[0];
  defaults[i++].defaultvalue = (int)chat_macros[1]; 
  defaults[i++].defaultvalue = (int)chat_macros[2]; 
  defaults[i++].defaultvalue = (int)chat_macros[3]; 
  defaults[i++].defaultvalue = (int)chat_macros[4]; 
  defaults[i++].defaultvalue = (int)chat_macros[5]; 
  defaults[i++].defaultvalue = (int)chat_macros[6]; 
  defaults[i++].defaultvalue = (int)chat_macros[7]; 
  defaults[i++].defaultvalue = (int)chat_macros[8]; 
  defaults[i].defaultvalue = (int)chat_macros[9];

  // There should not yet exist a player
  DEV_ASSERT2(players == NULL);

  // Create all the players
  // -ES- FIXME: Do the player system more cleanly
  // (remove limitations, dynamify)
  for (i = 0; i &lt; MAXPLAYERS; i++)
    P_AddPlayer(i);

  s = Z_New(char, MAXPLAYERS + 1);
  Z_StrNCpy(s, DDF_LanguageLookup("ChatKeys"), MAXPLAYERS);
  destination_keys = s;
  
  //m_menu.c
  gammamsg[0] = DDF_LanguageLookup("GammaOff");
  gammamsg[1] = DDF_LanguageLookup("GammaLevelOne");
  gammamsg[2] = DDF_LanguageLookup("GammaLevelTwo");
  gammamsg[3] = DDF_LanguageLookup("GammaLevelThree");
  gammamsg[4] = DDF_LanguageLookup("GammaLevelFour");

  return true;
}
</t>
<t tx="T2361">@ -KM- 1998/12/16 This loads the ddf file into memory for parsing.
-AJA- Returns NULL if no such file exists.
@c

static void *DDF_MainCacheFile(readinfo_t * readinfo)
{
  FILE *file;
  char *memfile;
  char *filename;
  size_t size;

  if (!readinfo-&gt;filename)
    I_Error("DDF_MainReadFile: No file to read");

  filename = I_TmpMalloc(strlen(ddfdir) + strlen(readinfo-&gt;filename) + 2);
  sprintf(filename, "%s%c%s", ddfdir, DIRSEPARATOR, readinfo-&gt;filename);

  file = fopen(filename, "rb");

  if (file == NULL)
  {
    I_Error("DDF_MainReadFile: Unable to open: '%s'\n", filename);

    I_TmpFree(filename);
    return NULL;
  }

  I_TmpFree(filename);

#if (DEBUG_DDFREAD)
  L_WriteDebug("\nDDF Parser Output:\n");
#endif

  // get to the end of the file
  fseek(file, 0, SEEK_END);

  // get the size
  size = ftell(file);

  // reset to beginning
  fseek(file, 0, SEEK_SET);

  // malloc the size
  memfile = Z_New(char, size + 1);

  fread(memfile, sizeof(char), size, file);
  memfile[size] = 0;

  // close the file
  fclose(file);

  readinfo-&gt;memsize = size;
  return (void *)memfile;
}
</t>
<t tx="T2362">@ Description of the DDF Parser:

The DDF Parser is a simple reader that is very limited in error checking,
however it can adapt to most tasks, as is required for the variety of stuff
need to be loaded in order to configure the EDGE Engine.

The parser will read an ascii file, character by character an interpret each
depending in which mode it is in; Unless an error is encountered or a called
procedure stops the parser, it will read everything until EOF is encountered.

When the parser function is called, a pointer to a readinfo_t is passed and
contains all the info needed, it contains:

* message        - message displayed on the screen, if NULL nothing displayed
* filename       - filename to be read, returns error if NULL
* DDF_MainCheckName   - function called when a def has been just been started
* DDF_MainCheckCmd   - function called when we need to check a command
* DDF_MainCreateEntry  - function called when a def has been completed
* DDF_MainFinishingCode - function called when EOF is read
* currentcmdlist    - Current list of commands

Also when commands are referenced, they use currentcmdlist, which is a pointer
to a list of entries, the entries are formatted like this:

* name - name of command
* routine - function called to interpret info
* numeric - void pointer to an value (possibly used by routine)

name is compared with the read command, to see if it matchs.
routine called to interpret info, if command name matches read command.
numeric is used if a numeric value needs to be changed, by routine.

The different parser modes are:
waiting_newdef
reading_newdef
reading_command
reading_data
reading_remark
reading_string

'waiting_newdef' is only set at the start of the code, At this point every
character with the exception of DEFSTART is ignored. When DEFSTART is
encounted, the parser will switch to reading_newdef. DEFSTART the parser
will only switches modes and sets firstgo to false.

'reading_newdef' reads all alphanumeric characters and the '_' character - which
substitudes for a space character (whitespace is ignored) - until DEFSTOP is read.
DEFSTOP passes the read string to DDF_MainCheckName and then clears the string.
Mode reading_command is now set. All read stuff is passed to char *buffer.

'reading_command' picks out all the alphabetic characters and passes them to
buffer as soon as COMMANDREAD is encountered; DDF_MainReadCmd looks through
for a matching command, if none is found a fatal error is returned. If a matching
command is found, this function returns a command reference number to command ref
and sets the mode to reading_data. if DEFSTART is encountered the procedure will
clear the buffer, run DDF_MainCreateEntry (called this as it reflects that in Items
&amp; Scenery if starts a new mobj type, in truth it can do anything procedure wise) and
then switch mode to reading_newdef.

'reading_data' passes alphanumeric characters, plus a few other characters that
are also needed. It continues to feed buffer until a SEPARATOR or a TERMINATOR is
found. The difference between SEPARATOR and TERMINATOR is that a TERMINATOR refs
the cmdlist to find the routine to use and then sets the mode to reading_command,
whereas SEPARATOR refs the cmdlist to find the routine and a looks for more data
on the same command. This is how the multiple states and specials are defined.

'reading_remark' does not process any chars except REMARKSTOP, everything else is
ignored. This mode is only set when REMARKSTART is found, when this happens the
current mode is held in formerstatus, which is restored when REMARKSTOP is found.

'reading_string' is set when the parser is going through data (reading_data) and
encounters STRINGSTART and only stops on a STRINGSTOP. When reading_string,
everything that is an ASCII char is read (which the exception of STRINGSTOP) and
passed to the buffer. REMARKS are ignored in when reading_string and the case is
take notice of here.

The maximum size of BUFFER is set in the BUFFERSIZE define.

DDF_MainReadFile &amp; DDF_MainProcessChar handle the main processing of the file, all
the procedures in the other DDF files (which the exceptions of the Inits) are
called directly or indirectly. DDF_MainReadFile handles to opening, closing and
calling of procedures, DDF_MainProcessChar makes sense from the character read
from the file.


DDF_MainReadFile

-ACB- 1998/08/10 Added the string reading code
-ACB- 1998/09/28 DDF_ReadFunction Localised here
-AJA- 1999/10/02 Recursive { } comments.
-ES- 2000/02/29 Added
@c

void DDF_MainReadFile(readinfo_t * readinfo)
{
  char *name;
  char *value = NULL;
  char *buffer;
  char character;
  char *memfile;
  char *memfileptr;
  readstatus_t status, formerstatus;
  readchar_t response;
  int size;
  int comment_level;
  int bracket_level;
  boolean_t firstgo;
  char *current_command = NULL;
  int current_index = 0;
  char namebuf[200];
  int entry_count = 0;
  
#if (DEBUG_DDFREAD)
  char charcount = 0;
#endif

  status = waiting_tag;
  formerstatus = 0;
  comment_level = 0;
  bracket_level = 0;
  firstgo = true;

  cur_ddf_line_num = 1;

  if (readinfo-&gt;message)
    I_Printf("  %s", readinfo-&gt;message);

  if (!readinfo-&gt;memfile &amp;&amp; !readinfo-&gt;filename)
    I_Error("DDF_MainReadFile: No file to read\n");

  if (!readinfo-&gt;memfile)
  {
    readinfo-&gt;memfile = DDF_MainCacheFile(readinfo);

    // no file ?  No worries, act as if it existed but had no entries
    if (!readinfo-&gt;memfile)
      return;
      
    DDF_ErrorSetFilename(readinfo-&gt;filename);
  }
  else
  {
    DDF_ErrorSetFilename(readinfo-&gt;lumpname);
  }

  buffer = Z_ClearNew(char, BUFFERSIZE);

  memfileptr = memfile = readinfo-&gt;memfile;
  size = readinfo-&gt;memsize;

  // -ACB- 1998/09/12 Copy file to memory: Read until end. Speed optimisation.
  while (memfileptr &lt; &amp;memfile[size])
  {
    // -KM- 1998/12/16 Added #define command to ddf files.
    if (!strnicmp(memfileptr, "#DEFINE", 7))
    {
      boolean_t line = false;

      memfileptr += 8;
      name = memfileptr;

      while (*memfileptr != ' ' &amp;&amp; memfileptr &lt; &amp;memfile[size])
        memfileptr++;

      if (memfileptr &lt; &amp;memfile[size])
      {
        *memfileptr++ = 0;
        value = memfileptr;
      }
      else
      {
        DDF_Error("#DEFINE '%s' as what?!\n", name);
      }

      while (memfileptr &lt; &amp;memfile[size])
      {
        if (*memfileptr == '\r')
          *memfileptr = ' ';
        if (*memfileptr == '\\')
          line = true;
        if (*memfileptr == '\n' &amp;&amp; !line)
          break;
        memfileptr++;
      }

      if (*memfileptr == '\n')
        cur_ddf_line_num++;

      *memfileptr++ = 0;

      DDF_MainAddDefine(name, value);

      buffer[0] = '\0';
      continue;
    }

    // -AJA- 1999/10/27: Not the greatest place for it, but detect //
    //       comments here and ignore them.  Ow the pain of long
    //       identifier names...  Ow the pain of &amp;memfile[size] :-)
    
    if (comment_level == 0 &amp;&amp; status != reading_string &amp;&amp;
        memfileptr+1 &lt; &amp;memfile[size] &amp;&amp;
        memfileptr[0] == '/' &amp;&amp; memfileptr[1] == '/')
    {
      while (memfileptr &lt; &amp;memfile[size] &amp;&amp; *memfileptr != '\n')
        memfileptr++;

      if (memfileptr &gt;= &amp;memfile[size])
        break;
    }
    
    character = *memfileptr++;

    if (character == '\n')
    {
      int l_len;

      cur_ddf_line_num++;

      // -AJA- 2000/03/21: determine linedata.  Ouch.
      for (l_len=0; &amp;memfileptr[l_len] &lt; &amp;memfile[size] &amp;&amp;
           memfileptr[l_len] != '\n' &amp;&amp; memfileptr[l_len] != '\r'; l_len++)
      { }

      DDF_ErrorSetLineData(memfileptr, l_len);

      // -AJA- 2001/05/21: handle directives (lines beginning with #).
      // This code is more hackitude -- to be fixed when the whole
      // parsing code gets the overhaul it needs.
      
      if (strnicmp(memfileptr, "#CLEARALL", 9) == 0)
      {
        if (! firstgo)
          DDF_Error("#CLEARALL cannot be used inside an entry !\n");

        (* readinfo-&gt;clear_all)();

        memfileptr += l_len;
        continue;
      }
    }

    response = DDF_MainProcessChar(character, buffer, status);

    switch (response)
    {
      case remark_start:
        if (comment_level == 0)
        {
          formerstatus = status;
          status = reading_remark;
        }
        comment_level++;
        break;

      case remark_stop:
        comment_level--;
        if (comment_level == 0)
        {
          status = formerstatus;
        }
        break;

      case command_read:
        strupr(buffer);

        if (current_command)
          Z_Free(current_command);
        
        current_command = Z_StrDup(buffer);
        DEV_ASSERT2(current_index == 0);

        buffer[0] = '\0';
        status = reading_data;
        break;

      case tag_start:
        status = reading_tag;
        break;

      case tag_stop:
        if (stricmp(buffer, readinfo-&gt;tag))
          DDF_Error("Start tag &lt;%s&gt; expected, found &lt;%s&gt;!\n", 
              readinfo-&gt;tag, buffer);
        status = waiting_newdef;
        buffer[0] = '\0';
        break;

      case def_start:
        if (bracket_level &gt; 0)
          DDF_Error("Unclosed () brackets detected.\n");
         
        if (entry_count % MAX(1, readinfo-&gt;entries_per_dot) == 0)
          I_Printf(".");
        entry_count++;

        if (firstgo)
        {
          firstgo = false;
          status = reading_newdef;
        }
        else
        {
          DDF_ErrorClearLineData();

          // finish off previous entry
          (* readinfo-&gt;finish_entry)();

          buffer[0] = '\0';
          status = reading_newdef;

          DDF_ErrorClearEntryName();
        }
        break;

      case def_stop:
        strupr(buffer);

        sprintf(namebuf, "[%s]", buffer);
        DDF_ErrorSetEntryName(namebuf);

        (* readinfo-&gt;start_entry)(buffer);
         
        buffer[0] = '\0';
        status = reading_command;
        break;

      // -AJA- 2000/10/02: support for () brackets
      case group_start:
        if (status == reading_data || status == reading_command)
          bracket_level++;
        break;

      case group_stop:
        if (status == reading_data || status == reading_command)
        {
          bracket_level--;
          if (bracket_level &lt; 0)
            DDF_Error("Unexpected `)' bracket.\n");
        }
        break;

      case separator:
        if (bracket_level &gt; 0)
        {
          int len = strlen(buffer);
          buffer[len] = SEPARATOR;
          buffer[len+1] = 0;
          break;
        }

        if (! current_command)
          DDF_Error("Unexpected comma `,'.\n");

        if (firstgo)
          DDF_WarnError("Command %s used outside of any entry\n");
        else
        {  
          (* readinfo-&gt;parse_field)(current_command, 
              DDF_MainGetDefine(buffer), current_index, false);
          current_index++;
        }

        buffer[0] = '\0';
        break;

        // -ACB- 1998/08/10 String Handling
      case string_start:
        status = reading_string;
        break;

        // -ACB- 1998/08/10 String Handling
      case string_stop:
        status = reading_data;
        break;

      case terminator:
        if (!current_command)
          DDF_Error("Unexpected semicolon `;'.\n");

        if (bracket_level &gt; 0)
          DDF_Error("Missing ')' bracket in ddf command.\n");

        (* readinfo-&gt;parse_field)(current_command, 
            DDF_MainGetDefine(buffer), current_index, true);
        current_index = 0;

        buffer[0] = '\0';
        status = reading_command;
        break;

      case property_read:
        DDF_WarnError("Badly formed command: Unexpected semicolon `;'\n");
        break;

      case nothing:
        break;

      case ok_char:
#if (DEBUG_DDFREAD)
        charcount++;
        L_WriteDebug("%c", character);
        if (charcount == 75)
        {
          charcount = 0;
          L_WriteDebug("\n");
        }
#endif
        break;

      default:
        break;
    }
  }

  if (current_command)
    Z_Free(current_command);

  DDF_ErrorClearLineData();

  // -AJA- 1999/10/21: check for unclosed comments
  if (comment_level &gt; 0)
    DDF_Error("Unclosed comments detected.\n");

  if (bracket_level &gt; 0)
    DDF_Error("Unclosed () brackets detected.\n");

  // if firstgo is true, nothing was defined
  if (!firstgo)
    (* readinfo-&gt;finish_entry)();

  Z_Free(buffer);

  DDF_ErrorClearEntryName();
  DDF_ErrorClearFilename();

  if (defines)
  {
    Z_Free(defines);
    numDefines = 0;
    defines = NULL;
  }

  if (readinfo-&gt;filename)
  {
    Z_Free(memfile);
    I_Printf("\n");
  }

  return;
}
</t>
<t tx="T2363">@ DDF_MainProcessChar

1998/08/10 Added String reading code.
@c

readchar_t DDF_MainProcessChar(char character, char *buffer, readstatus_t status)
{
  int len;

  // -ACB- 1998/08/11 Used for detecting formatting in a string
  static boolean_t formatchar = false;

  len = strlen(buffer);

  if (len &gt;= BUFFERSIZE)
    DDF_Error("DDF_MainProcessChar: Read Buffer Size Exceeded, Size: %d\n", BUFFERSIZE);

  // With the exception of reading_string, whitespace is ignored and
  // a SUBSPACE is replaced by a space.
  if (status != reading_string)
  {
    if (isspace(character))
      return nothing;

    if (character == SUBSPACE)
      character = SPACE;
  }
  else  // check for formatting char in a string
  {
    if (!formatchar &amp;&amp; character == '\\')
    {
      formatchar = true;
      return nothing;
    }
  }

  // -AJA- 1999/09/26: Handle unmatched '}' better.
  if (status != reading_string &amp;&amp; character == REMARKSTART)
    return remark_start;
  
  if (status == reading_remark &amp;&amp; character == REMARKSTOP)
    return remark_stop;

  if (status != reading_string &amp;&amp; character == REMARKSTOP)
    DDF_Error("DDF: Encountered '}' without previous '{'.\n");

  switch (status)
  {
    case reading_remark:
      return nothing;

    // -ES- 2000/02/29 Added tag check.
    case waiting_tag:
      if (character == TAGSTART)
        return tag_start;
      else
        DDF_Error("DDF: File must start with a tag!\n");
      break;

    case reading_tag:
      if (character == TAGSTOP)
        return tag_stop;
      else
      {
        buffer[len] = character;
        buffer[len+1] = 0;
        return ok_char;
      }

    case waiting_newdef:
      if (character == DEFSTART)
        return def_start;
      else
        return nothing;

    case reading_newdef:
      if (character == DEFSTOP)
      {
        return def_stop;
      }
      else if ((isalnum(character)) || (character == SPACE) ||
          (character == DIVIDE))
      {
        buffer[len] = character;
        buffer[len+1] = 0;
        return ok_char;
      }
      return nothing;

    case reading_command:
      if (character == COMMANDREAD)
      {
        return command_read;
      }
      else if (character == TERMINATOR)
      {
        return property_read;
      }
      else if (character == DEFSTART)
      {
        return def_start;
      }
      else if (isalnum(character) || character == SPACE ||
          character == '(' || character == ')' ||
          character == '.')
      {
        buffer[len] = character;
        buffer[len+1] = 0;
        return ok_char;
      }
      return nothing;

      // -ACB- 1998/08/10 Check for string start
    case reading_data:
      if (character == STRINGSTART)
        return string_start;
      
      if (character == TERMINATOR)
        return terminator;
      
      if (character == SEPARATOR)
        return separator;
      
      if (character == GROUPSTART)
      {
        buffer[len] = character;
        buffer[len+1] = 0;
        return group_start;
      }
      
      if (character == GROUPSTOP)
      {
        buffer[len] = character;
        buffer[len+1] = 0;
        return group_stop;
      }
      
      // Sprite Data - more than a few exceptions....
      if (isalnum(character) || character == SPACE || character == '-' ||
          character == ':' || character == '.' || character == '[' ||
          character == ']' || character == '\\' || character == '!' ||
          character == '=' ||  // -AJA- 1999/08/10.
          character == '#' || character == '%' || 
          character == '@' || character == '?')
      {
        buffer[len] = toupper(character);
        buffer[len+1] = 0;
        return ok_char;
      }
      else if (isprint(character))
        DDF_WarnError("DDF: Illegal character '%c' found.\n", character);

      break;

    case reading_string:  // -ACB- 1998/08/10 New string handling
      // -KM- 1999/01/29 Fixed nasty bug where \" would be recognised as
      //  string end over quote mark.  One of the level text used this.
      if (formatchar)
      {
        // -ACB- 1998/08/11 Formatting check: Carriage-return.
        if (character == 'n')
        {
          buffer[len] = '\n';
          buffer[len+1] = 0;
          formatchar = false;
          return ok_char;
        }
        else if (character == '\"')    // -KM- 1998/10/29 Also recognise quote
        {
          buffer[len] = '\"';
          buffer[len+1] = 0;
          formatchar = false;
          return ok_char;
        }
        else if (character == '\\') // -ACB- 1999/11/24 Double backslash means directory
        {
          buffer[len] = DIRSEPARATOR;
          buffer[len+1] = 0;
          formatchar = false;
          return ok_char;
        }
        else // -ACB- 1999/11/24 Any other characters are treated in the norm
        {
          buffer[len] = character;
          buffer[len+1] = 0;
          formatchar = false;
          return ok_char;
        }

      }
      else if (character == STRINGSTOP)
      {
        return string_stop;
      }
      // -KM- 1998/10/29 Removed ascii check, allow foreign characters ()
      // -ES- HEY! Swedish is not foreign!
      else
      {
        buffer[len] = character;
        buffer[len+1] = 0;
        return ok_char;
      }

    default:  // doh!
      I_Error("DDF_MainProcessChar: INTERNAL ERROR: "
          "Bad status value %d !\n", status);
      break;
  }

  return nothing;
}
</t>
<t tx="T2364">@ DDF_MainGetNumeric

Get numeric value directly from the file
@c

void DDF_MainGetNumeric(const char *info, void *storage)
{
  int *dest = (int *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  // -KM- 1999/01/29 strtol accepts hex and decimal.
  *dest = strtol(info, NULL, 0);  // straight conversion - no messin'
}
</t>
<t tx="T2365">@ DDF_MainGetBoolean

Get true/false from the file

-KM- 1998/09/01 Gets a true/false value
@c

void DDF_MainGetBoolean(const char *info, void *storage)
{
  boolean_t *dest = (boolean_t *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  if ((stricmp(info, "TRUE") == 0) || (strcmp(info, "1") == 0))
  {
    *dest = true;
    return;
  }

  if ((stricmp(info, "FALSE") == 0) || (strcmp(info, "0") == 0))
  {
    *dest = false;
    return;
  }

  DDF_Error("Bad boolean value: %s\n", info);
}
</t>
<t tx="T2366">@ DDF_MainGetString

Get String value directly from the file

-KM- 1998/07/31 Needed a string argument. Based on DDF_MainGetNumeric.
-AJA- 2000/02/09: Free any existing string (potential memory leak).
@c

void DDF_MainGetString(const char *info, void *storage)
{
  char **dest = (char **)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  // free any previous string
  if (*dest)
    Z_Free(*dest);

  *dest = Z_StrDup(info);
}
</t>
<t tx="T2367">@ DDF_MainParseSubField

Check if the sub-command exists, and call the parser function if it
does (and return true), otherwise return false. For sub-commands,
the storage pointer
@c

boolean_t DDF_MainParseSubField(const commandlist_t *sub_comms,
    const char *field, const char *contents, char *stor_base,
    const char *base_command)
{
  int i, len;
  boolean_t obsolete = false;
  const char *name = NULL;

  for (i=0; sub_comms[i].name; i++)
  {
    name = sub_comms[i].name;
    obsolete = false;

    if (name[0] == '!')
    {
      name++;
      obsolete = true;
    }
    
    // handle sub-fields within sub-fields
    if (name[0] == '*')
    {
      name++;

      len = strlen(name);
      DEV_ASSERT2(len &gt; 0);

      if (strncmp(field, name, len) == 0 &amp;&amp; field[len] == '.' &amp;&amp; 
          isalnum(field[len+1]))
      {
        // found the sub-field reference, recurse !

        // FIXME: current hack (FIELD_OFF stuff) can't cope !!!
        //
        // return DDF_MainParseSubField(
        //    sub_comms[i].sub_comms, field + len + 1, contents,
        //    sub_comms[i].storage, name);
        
        I_Error("DDF_MainParseSubField: can't recurse !\n");
      }

      continue;
    }

    if (DDF_CompareName(field, name) == 0)
      break;
  }

  if (!sub_comms[i].name)
    return false;

  if (obsolete &amp;&amp; !no_obsoletes)
  {
    DDF_Warning("The ddf %s.%s command is obsolete !\n",
        base_command, name);
  }

  // found it, so call parse routine

  DEV_ASSERT2(sub_comms[i].parse_command);

  (* sub_comms[i].parse_command)(contents, 
      stor_base + FIELD_P2OFF(sub_comms[i].storage));

  return true;
}
</t>
<t tx="T2368">@ DDF_MainParseField

Check if the command exists, and call the parser function if it
does (and return true), otherwise return false.
@c

boolean_t DDF_MainParseField(const commandlist_t *commands, 
    const char *field, const char *contents)
{
  int i, len;
  boolean_t obsolete = false;
  const char *name = NULL;

  for (i=0; commands[i].name; i++)
  {
    name = commands[i].name;
    obsolete = false;

    if (name[0] == '!')
    {
      name++;
      obsolete = true;
    }
    
    // handle subfields
    if (name[0] == '*')
    {
      name++;

      len = strlen(name);
      DEV_ASSERT2(len &gt; 0);

      if (strncmp(field, name, len) == 0 &amp;&amp; field[len] == '.' &amp;&amp; 
          isalnum(field[len+1]))
      {
        // found the sub-field reference
        return DDF_MainParseSubField( commands[i].sub_comms, 
            field + len + 1, contents, commands[i].storage, name);
      }
      
      continue;
    }

    if (DDF_CompareName(field, name) == 0)
      break;
  }

  if (!commands[i].name)
    return false;

  if (obsolete &amp;&amp; !no_obsoletes)
    DDF_Warning("The ddf %s command is obsolete !\n", name);

  // found it, so call parse routine

  DEV_ASSERT2(commands[i].parse_command);

  (* commands[i].parse_command)(contents, commands[i].storage);

  return true;
}
</t>
<t tx="T2369">@ DDF_MainGetInlineStr10

Gets the string and checks the length to see if is not more than 9.
@c

void DDF_MainGetInlineStr10(const char *info, void *storage)
{
  char *str = (char *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  if (strlen(info) &gt; 9)
    DDF_Error("Name %s too long (must be 9 characters or less)\n", info);

  strcpy(str, info);
}
</t>
<t tx="T2370">@ DDF_MainGetInlineStr32

Gets the string and checks the length to see if is not more than 31.
@c

void DDF_MainGetInlineStr32(const char *info, void *storage)
{
  char *str = (char *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  if (strlen(info) &gt; 31)
    DDF_Error("Name %s too long (must be 31 characters or less)\n", info);

  strcpy(str, info);
}
</t>
<t tx="T2371">
void DDF_MainRefAttack(const char *info, void *storage)
{
  attacktype_t **dest = (attacktype_t **)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  *dest = DDF_AttackLookup(info);
}
</t>
<t tx="T2372">@ DDF_MainLookupDirector
@c

int DDF_MainLookupDirector(const mobjinfo_t *info, const char *ref)
{
  int i, state, offset;
  char *director;
  const char *div;

  // find `:'
  div = strchr(ref, DIVIDE);

  i = div ? (div - ref) : strlen(ref);

  if (i &lt;= 0)
    DDF_Error("Bad Director `%s' : Nothing after divide\n", ref);

  director = Z_New(char, i + 1);
  Z_StrNCpy(director, ref, i);

  state = StateFindLabel(info-&gt;first_state, info-&gt;last_state, director);

  offset = div ? MAX(0, atoi(div + 1) - 1) : 0;

  // FIXME: check for overflow
  return state + offset;
}
</t>
<t tx="T2373">
void DDF_MainGetFloat(const char *info, void *storage)
{
  float_t *dest = (float_t *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  if (sscanf(info, "%f", dest) != 1)
    DDF_Error("Bad floating point value: %s\n", info);
}
</t>
<t tx="T2374">@ -AJA- 1999/09/11: Added DDF_MainGetAngle and DDF_MainGetSlope.
@c

void DDF_MainGetAngle(const char *info, void *storage)
{
  float val;
  angle_t *dest = (angle_t *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  if (sscanf(info, "%f", &amp;val) != 1)
    DDF_Error("Bad angle value: %s\n", info);

  *dest = FLOAT_2_ANG(val);
}
</t>
<t tx="T2375">
void DDF_MainGetSlope(const char *info, void *storage)
{
  float val;
  float_t *dest = (float_t *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  if (sscanf(info, "%f", &amp;val) != 1)
    DDF_Error("Bad slope value: %s\n", info);

  if (val &gt; +89.5)
    val = +89.5;
  if (val &lt; -89.5)
    val = -89.5;

  *dest = M_Tan(FLOAT_2_ANG(val));
}
</t>
<t tx="T2376">@ DDF_MainGetPercent

Reads percentages (0%..100%).
@c

void DDF_MainGetPercent(const char *info, void *storage)
{
  percent_t *dest = (percent_t *)storage;
  char s[101];
  char *p;
  float_t f;

  // check that the string is valid
  Z_StrNCpy(s, info, 100);
  for (p = s; isdigit(*p) || *p == '.'; p++)
  { /* do nothing */ }

  // the number must be followed by %
  if (*p != '%')
  {
    DDF_WarnError("Bad percent value '%s': Should be a number followed by %%\n", info);
    // -AJA- 2001/01/27: backwards compatibility
    DDF_MainGetFloat(s, &amp;f);
    *dest = MAX(0, MIN(1, f));
    return;
  }

  *p = 0;
  
  DDF_MainGetFloat(s, &amp;f);
  if (f &lt; 0.0 || f &gt; 100.0)
    DDF_Error("Bad percent value '%s': Must be between 0% and 100%\n");

  *dest = f / 100.0;
}
</t>
<t tx="T2377">@ DDF_MainGetPercentAny

Like the above routine, but allows percentages outside of the
0-100% range (which is useful in same instances).
@c

void DDF_MainGetPercentAny(const char *info, void *storage)
{
  percent_t *dest = (percent_t *)storage;
  char s[101];
  char *p;
  float_t f;

  // check that the string is valid
  Z_StrNCpy(s, info, 100);
  for (p = s; isdigit(*p) || *p == '.'; p++)
  { /* do nothing */ }

  // the number must be followed by %
  if (*p != '%')
  {
    DDF_WarnError("Bad percent value '%s': Should be a number followed by %%\n", info);
    // -AJA- 2001/01/27: backwards compatibility
    DDF_MainGetFloat(s, dest);
    return;
  }

  *p = 0;
  
  DDF_MainGetFloat(s, &amp;f);

  *dest = f / 100.0;
}
</t>
<t tx="T2378">@ -KM- 1998/09/27 You can end a number with T to specify tics; ie 35T
means 35 tics while 3.5 means 3.5 seconds.
@c

void DDF_MainGetTime(const char *info, void *storage)
{
  float val;
  int *dest = (int *)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  // -ES- 1999/09/14 MAXT means that time should be maximal.
  if (!stricmp(info, "maxt"))
  {
    *dest = INT_MAX; // -ACB- 1999/09/22 Standards, Please.
    return;
  }

  if (strchr(info, 'T'))
  {
    DDF_MainGetNumeric(info, storage);
    return;
  }

  if (sscanf(info, "%f", &amp;val) != 1)
    DDF_Error("Bad time value: %s\n", info);

  *dest = (int)(val * (float_t)TICRATE);
}
</t>
<t tx="T2379">@ DDF_DummyFunction
@c

void DDF_DummyFunction(const char *info, void *storage)
{
  /* does nothing */
}
</t>
<t tx="T2380">@ DDF_MainGetColourmap
@c

void DDF_MainGetColourmap(const char *info, void *storage)
{
  const colourmap_t **result = (const colourmap_t **)storage;

  *result = DDF_ColmapLookup(info);
}
</t>
<t tx="T2381">@ DDF_MainGetRGB
@c

void DDF_MainGetRGB(const char *info, void *storage)
{
  rgbcol_t *result = (rgbcol_t *)storage;
  int r, g, b;

  DEV_ASSERT2(info &amp;&amp; storage);

  if (sscanf(info, " #%2x%2x%2x ", &amp;r, &amp;g, &amp;b) != 3)
    DDF_Error("Bad RGB colour value: %s\n", info);
  
  *result = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
}
</t>
<t tx="T2382">@ DDF_MainGetWhenAppear

-AJA- 1999/10/23: written.
@c

void DDF_MainGetWhenAppear(const char *info, void *storage)
{
  when_appear_e *result = (when_appear_e *)storage;

  *result = 0;
  
  // -AJA- FIXME: such a hack...
  if (strstr(info, "1")) *result |= (1 &lt;&lt; 0);
  if (strstr(info, "2")) *result |= (1 &lt;&lt; 1);
  if (strstr(info, "3")) *result |= (1 &lt;&lt; 2);
  if (strstr(info, "4")) *result |= (1 &lt;&lt; 3);
  if (strstr(info, "5")) *result |= (1 &lt;&lt; 4);

  if (strstr(info, "SP") || strstr(info, "sp"))
    *result |= WNAP_Single;
  if (strstr(info, "COOP") || strstr(info, "coop"))
    *result |= WNAP_Coop;
  if (strstr(info, "DM") || strstr(info, "dm"))
    *result |= WNAP_DeathMatch;
}
</t>
<t tx="T2383">@ DDF_MainGetBitSet
@c

void DDF_MainGetBitSet(const char *info, void *storage)
{
  bitset_t *result = (bitset_t *)storage;
  int start, end;

  DEV_ASSERT2(info &amp;&amp; storage);

  // allow a numeric value
  if (sscanf(info, " %i ", result) == 1)
    return;

  *result = BITSET_EMPTY;

  for (; *info; info++)
  {
    if (*info &lt; 'A' || *info &gt; 'Z')
      continue;
    
    start = end = (*info) - 'A';

    // handle ranges
    if (info[1] == '-' &amp;&amp; 'A' &lt;= info[2] &amp;&amp; info[2] &lt;= 'Z' &amp;&amp;
        info[2] &gt;= info[0])
    {
      end = info[2] - 'A';
    }

    for (; start &lt;= end; start++)
      (*result) |= (1 &lt;&lt; start);
  }
}
</t>
<t tx="T2384">
static int FindSpecialFlag(const char *prefix, const char *name,
    const specflags_t *flag_set)
{
  int i;
  char try_name[512];

  for (i=0; flag_set[i].name; i++)
  {
    const char *current = flag_set[i].name;
    boolean_t obsolete = false;

    if (current[0] == '!')
    {
      current++;
      obsolete = true;
    }
    
    sprintf(try_name, "%s%s", prefix, current);
    
    if (DDF_CompareName(name, try_name) == 0)
    {
      if (obsolete &amp;&amp; !no_obsoletes)
        DDF_Warning("The ddf flag `%s' is obsolete !\n", try_name);

      return i;
    }
  }

  return -1;
}
</t>
<t tx="T2385">
checkflag_result_e DDF_MainCheckSpecialFlag(const char *name,
  const specflags_t *flag_set, int *flag_value, 
  boolean_t allow_prefixes, boolean_t allow_user)
{
  int index;
  int negate = 0;
  int user = 0;

  // try plain name...
  index = FindSpecialFlag("", name, flag_set);
  
  if (allow_prefixes)
  {
    // try name with ENABLE_ prefix...
    if (index == -1)
    {
      index = FindSpecialFlag("ENABLE_", name, flag_set);
    }

    // try name with NO_ prefix...
    if (index == -1)
    {
      negate = 1;
      index = FindSpecialFlag("NO_", name, flag_set);
    }

    // try name with NOT_ prefix...
    if (index == -1)
    {
      negate = 1;
      index = FindSpecialFlag("NOT_", name, flag_set);
    }

    // try name with DISABLE_ prefix...
    if (index == -1)
    {
      negate = 1;
      index = FindSpecialFlag("DISABLE_", name, flag_set);
    }

    // try name with USER_ prefix...
    if (index == -1 &amp;&amp; allow_user)
    {
      user = 1;
      negate = 0;
      index = FindSpecialFlag("USER_", name, flag_set);
    }
  }

  if (index &lt; 0)
    return CHKF_Unknown;

  (*flag_value) = flag_set[index].flags;

  if (flag_set[index].negative)
    negate = !negate;
  
  if (user)
    return CHKF_User;
  
  if (negate)
    return CHKF_Negative;

  return CHKF_Positive;
}
</t>
<t tx="T2386">@ DDF_MainCreateUniqueName
@c

char *DDF_MainCreateUniqueName(const char *prefix, int num)
{
  char buffer[512];

  sprintf(buffer, "_%s_%d\n", prefix, num);

  return Z_StrDup(buffer);
}
</t>
<t tx="T2387">@ignore
@language c

// Data Definition File Code (Things - MOBJs)

@
// Moving Object Setup and Parser Code
//
// -ACB- 1998/08/04 Written.
// -ACB- 1998/09/12 Use DDF_MainGetFixed for fixed number references.
// -ACB- 1998/09/13 Use DDF_MainGetTime for Time count references.
// -KM- 1998/11/25 Translucency is now a fixed_t. Fixed spelling of available.
// -KM- 1998/12/16 No limit on number of ammo types.
@c

&lt;&lt; ddf_mobj #includes &gt;&gt;
&lt;&lt; ddf_mobj declarations &gt;&gt;
@others
</t>
<t tx="T2388">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "e_search.h"
#include "m_fixed.h"
#include "m_math.h"
#include "p_action.h"
#include "p_local.h"
#include "p_mobj.h"
#include "z_zone.h"
</t>
<t tx="T2389">
#undef  DF
#define DF  DDF_CMD

#define DDF_MobjHashFunc(x)  (((x) + 211) % 211)

mobjinfo_t buffer_mobj;
mobjinfo_t *dynamic_mobj;

const mobjinfo_t template_mobj =
{
  DDF_BASE_NIL,  // ddf

  0,        // first_state
  0,        // last_state
  
  0,        // spawn_state
  0,        // idle_state
  0,        // chase_state
  0,        // pain_state
  0,        // missile_state
  0,        // melee_state
  0,        // death_state
  0,        // overkill_state
  0,        // raise_state
  0,        // res_state
  0,        // meander_state
  0,        // bounce_state
  0,        // touch_state
  0,        // jump_state
  0,        // gib_state

  0,        // reactiontime
  PERCENT_MAKE(0), // painchance
  1000.0,   // spawnhealth
  0,        // speed
  2.0,      // float_speed
  0,        // radius
  0,        // height
  24.0,     // step_size
  100.0,    // mass

  0,        // flags
  0,        // extendedflags

  // damage info
  {
    0,      // nominal
    -1,     // linear_max
    -1,     // error
    0,      // delay time
    NULL_LABEL, NULL_LABEL, NULL_LABEL,  // override labels
    false   // no_armour
  },

  NULL,     // lose_benefits
  NULL,     // pickup_benefits
  NULL,     // pickup_message
  NULL,     // initial_benefits

  0,        // castorder
  30 * TICRATE,  // respawntime
  PERCENT_MAKE(100), // translucency
  PERCENT_MAKE(0), // minatkchance
  NULL,     // palremap

  1 * TICRATE, // jump_delay
  0,        // jumpheight
  0,        // crouchheight
  PERCENT_MAKE(75), // viewheight
  PERCENT_MAKE(64), // shotheight
  0,        // maxfall
  1.0,      // fast
  1.0,      // xscale
  1.0,      // yscale
  0.5,      // bounce_speed
  0.5,      // bounce_up
  16.0,     // sight_slope
  ANG90,    // sight_angle
  RIDE_FRICTION,  // ride_friction
  PERCENT_MAKE(50), // shadow_trans

  sfx_None,  // seesound
  sfx_None,  // attacksound
  sfx_None,  // painsound
  sfx_None,  // deathsound
  sfx_None,  // overkill_sound
  sfx_None,  // activesound
  sfx_None,  // walksound
  sfx_None,  // jump_sound
  sfx_None,  // noway_sound
  sfx_None,  // oof_sound
  sfx_None,  // gasp_sound

  0,        // fuse
  BITSET_EMPTY, // side
  0,        // playernum
  20 * TICRATE,  // lung_capacity
  2  * TICRATE,  // gasp_start

  // choke_damage
  {
    6,    // nominal
    14,   // linear_max
    -1,   // error
    2 * TICRATE,  // delay time
    NULL_LABEL, NULL_LABEL, NULL_LABEL,  // override labels
    true   // no_armour
  },

  PERCENT_MAKE(100), // bobbing
  BITSET_EMPTY, // immunity

  NULL,     // closecombat
  NULL,     // rangeattack
  NULL,     // spareattack

  // halo info
  {
    -1,          // height
    32, -1, -1,  // normal/min/max size
    PERCENT_MAKE(50), // translucency
    0xFFFFFF,    // colour (RGB 8:8:8)
    ""           // graphic name
  },

  // dynamic light info
  {
    DLITE_None,  // type
    32,          // intensity
    0xFFFFFF,    // colour (RGB 8:8:8)
    PERCENT_MAKE(50)  // height
  },

  NULL,     // dropitem
  NULL,     // dropitem_ref
  NULL,     // blood
  NULL,     // blood_ref
  NULL,     // respawneffect
  NULL,     // respawneffect_ref
  NULL,     // spitspot
  NULL      // spitspot_ref
};

mobjinfo_t ** mobjinfo = NULL;
int num_mobjinfo = 0;
int num_disabled_mobjinfo = 0;

static stack_array_t mobjinfo_a;

static mobjinfo_t *mobj_lookup_cache[211];

void DDF_MobjGetBenefit(const char *info, void *storage);
void DDF_MobjGetDLight(const char *info, void *storage);

static struct haloinfo_s   dummy_halo;
static struct dlightinfo_s dummy_dlight;

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_halo

const commandlist_t halo_commands[] =
{
  DDF_CMD_SUB("HEIGHT", height, DDF_MainGetFloat),
  DDF_CMD_SUB("SIZE", size,     DDF_MainGetFloat),
  DDF_CMD_SUB("MINSIZE", minsize, DDF_MainGetFloat),
  DDF_CMD_SUB("MAXSIZE", maxsize, DDF_MainGetFloat),
  DDF_CMD_SUB("TRANSLUCENCY", translucency, DDF_MainGetPercent),
  DDF_CMD_SUB("COLOUR",  colour,  DDF_MainGetRGB),
  DDF_CMD_SUB("GRAPHIC", graphic, DDF_MainGetInlineStr10),
 
  DDF_CMD_END
};

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  dummy_dlight

const commandlist_t dlight_commands[] =
{
  DDF_CMD_SUB("TYPE", type, DDF_MobjGetDLight),
  DDF_CMD_SUB("INTENSITY", intensity, DDF_MainGetNumeric),
  DDF_CMD_SUB("COLOUR", colour, DDF_MainGetRGB),
  DDF_CMD_SUB("HEIGHT", height, DDF_MainGetPercent),
  
  DDF_CMD_END
};

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_mobj

const commandlist_t thing_commands[] =
{
  // sub-commands
  DDF_SUB_LIST("HALO",   halo,   halo_commands),
  DDF_SUB_LIST("DLIGHT", dlight, dlight_commands),
  DDF_SUB_LIST("EXPLODE DAMAGE", damage, damage_commands),
  DDF_SUB_LIST("CHOKE DAMAGE", choke_damage, damage_commands),

  DF("SPAWNHEALTH", spawnhealth, DDF_MainGetFloat),
  DF("RADIUS", radius, DDF_MainGetFloat),
  DF("HEIGHT", height, DDF_MainGetFloat),
  DF("MASS", mass, DDF_MainGetFloat),
  DF("SPEED", speed, DDF_MainGetFloat),
  DF("FAST", fast, DDF_MainGetFloat),
  DF("SPECIAL", ddf, DDF_MobjGetSpecial),
  DF("EXTRA", ddf, DDF_MobjGetExtra),
  DF("PROJECTILE SPECIAL", ddf, DDF_MobjGetSpecial),
  DF("RESPAWN TIME", respawntime, DDF_MainGetTime),
  DF("FUSE", fuse, DDF_MainGetTime),
  DF("LIFESPAN", fuse, DDF_MainGetTime),
  DF("PALETTE REMAP", palremap, DDF_MainGetColourmap),
  DF("TRANSLUCENCY", translucency, DDF_MainGetPercent),

  DF("INITIAL BENEFIT", initial_benefits, DDF_MobjGetBenefit),
  DF("LOSE BENEFIT", lose_benefits, DDF_MobjGetBenefit),
  DF("PICKUP BENEFIT", pickup_benefits, DDF_MobjGetBenefit),
  DF("PICKUP MESSAGE", pickup_message, DDF_MainGetString),

  DF("PAINCHANCE", painchance, DDF_MainGetPercent),
  DF("MINATTACK CHANCE", minatkchance, DDF_MainGetPercent),
  DF("REACTION TIME", reactiontime, DDF_MainGetTime),
  DF("JUMP DELAY", jump_delay, DDF_MainGetTime),
  DF("JUMP HEIGHT", jumpheight, DDF_MainGetFloat),
  DF("CROUCH HEIGHT", crouchheight, DDF_MainGetFloat),
  DF("VIEW HEIGHT", viewheight, DDF_MainGetPercent),
  DF("SHOT HEIGHT", shotheight, DDF_MainGetPercent),
  DF("MAX FALL", maxfall, DDF_MainGetFloat),
  DF("CASTORDER", castorder, DDF_MainGetNumeric),
  DF("PLAYER", playernum, DDF_MobjGetPlayer),
  DF("SIDE", side, DDF_MainGetBitSet),
  DF("CLOSE ATTACK", closecombat, DDF_MainRefAttack),
  DF("RANGE ATTACK", rangeattack, DDF_MainRefAttack),
  DF("SPARE ATTACK", spareattack, DDF_MainRefAttack),
  DF("DROPITEM", dropitem_ref, DDF_MainGetString),
  DF("BLOOD", blood_ref, DDF_MainGetString),
  DF("RESPAWN EFFECT", respawneffect_ref, DDF_MainGetString),
  DF("SPIT SPOT", spitspot_ref, DDF_MainGetString),

  DF("PICKUP SOUND", activesound, DDF_MainLookupSound),
  DF("ACTIVE SOUND", activesound, DDF_MainLookupSound),
  DF("LAUNCH SOUND", seesound, DDF_MainLookupSound),
  DF("AMBIENT SOUND", seesound, DDF_MainLookupSound),
  DF("SIGHTING SOUND", seesound, DDF_MainLookupSound),
  DF("DEATH SOUND", deathsound, DDF_MainLookupSound),
  DF("OVERKILL SOUND", overkill_sound, DDF_MainLookupSound),
  DF("PAIN SOUND", painsound, DDF_MainLookupSound),
  DF("STARTCOMBAT SOUND", attacksound, DDF_MainLookupSound),
  DF("WALK SOUND", walksound, DDF_MainLookupSound),
  DF("JUMP SOUND", jump_sound, DDF_MainLookupSound),
  DF("NOWAY SOUND", noway_sound, DDF_MainLookupSound),
  DF("OOF SOUND", oof_sound, DDF_MainLookupSound),
  DF("GASP SOUND", gasp_sound, DDF_MainLookupSound),

  DF("FLOAT SPEED", float_speed, DDF_MainGetFloat),
  DF("STEP SIZE", step_size, DDF_MainGetFloat),
  DF("SPRITE SCALE", yscale, DDF_MainGetFloat),
  DF("SPRITE ASPECT", xscale, DDF_MainGetFloat),
  DF("BOUNCE SPEED", bounce_speed, DDF_MainGetFloat),
  DF("BOUNCE UP", bounce_up, DDF_MainGetFloat),
  DF("SIGHT SLOPE", sight_slope, DDF_MainGetSlope),
  DF("SIGHT ANGLE", sight_angle, DDF_MainGetAngle),
  DF("RIDE FRICTION", ride_friction, DDF_MainGetFloat),
  DF("BOBBING", bobbing, DDF_MainGetPercent),
  DF("IMMUNITY CLASS", immunity, DDF_MainGetBitSet),
  DF("SHADOW TRANSLUCENCY", shadow_trans, DDF_MainGetPercent),
  DF("LUNG CAPACITY", lung_capacity, DDF_MainGetTime),
  DF("GASP START", gasp_start, DDF_MainGetTime),

  // -AJA- backwards compatibility cruft...
  DF("!EXPLOD DAMAGE", damage.nominal, DDF_MainGetFloat),
  DF("!EXPLOSION DAMAGE", damage.nominal, DDF_MainGetFloat),
  DF("!EXPLOD DAMAGERANGE", damage.nominal, DDF_MainGetFloat),
  DF("!EXPLOD DAMAGEMULTI", ddf, DDF_DummyFunction),
  DF("!GIB", ddf, DDF_DummyFunction),

  DDF_CMD_END
};

static const state_starter_t thing_starters[] =
{
    {"SPAWN",      "IDLE",     &amp;buffer_mobj.spawn_state},
    {"IDLE",       "IDLE",     &amp;buffer_mobj.idle_state},
    {"CHASE",      "CHASE",    &amp;buffer_mobj.chase_state},
    {"PAIN",       "IDLE",     &amp;buffer_mobj.pain_state},
    {"MISSILE",    "IDLE",     &amp;buffer_mobj.missile_state},
    {"MELEE",      "IDLE",     &amp;buffer_mobj.melee_state},
    {"DEATH",      "REMOVE",   &amp;buffer_mobj.death_state},
    {"OVERKILL",   "REMOVE",   &amp;buffer_mobj.overkill_state},
    {"RESPAWN",    "IDLE",     &amp;buffer_mobj.raise_state},
    {"RESURRECT",  "IDLE",     &amp;buffer_mobj.res_state},
    {"MEANDER",    "MEANDER",  &amp;buffer_mobj.meander_state},
    {"BOUNCE",     "IDLE",     &amp;buffer_mobj.bounce_state},
    {"TOUCH",      "IDLE",     &amp;buffer_mobj.touch_state},
    {"JUMP",       "IDLE",     &amp;buffer_mobj.jump_state},
    {"GIB",        "REMOVE",   &amp;buffer_mobj.gib_state},
    {NULL, NULL, NULL}
};

// -KM- 1998/11/25 Added weapon functions.
// -AJA- 1999/08/09: Moved this here from p_action.h, and added an extra
// field `handle_arg' for things like "WEAPON_SHOOT(FIREBALL)".

static const actioncode_t thing_actions[] =
{
    {"CLOSEATTEMPTSND",   P_ActMakeCloseAttemptSound, NULL},
    {"COMBOATTACK",       P_ActComboAttack, NULL},
    {"FACETARGET",        P_ActFaceTarget, NULL},
    {"PLAYSOUND",         P_ActPlaySound, DDF_StateGetSound},
    {"KILLSOUND",         P_ActKillSound, NULL},
    {"MAKESOUND",         P_ActMakeAmbientSound, NULL},
    {"MAKEACTIVESOUND",   P_ActMakeActiveSound, NULL},
    {"MAKESOUNDRANDOM",   P_ActMakeAmbientSoundRandom, NULL},
    {"MAKEDEATHSOUND",    P_ActMakeDyingSound, NULL},
    {"MAKEDEAD",          P_ActMakeIntoCorpse, NULL},
    {"MAKEOVERKILLSOUND", P_ActMakeOverKillSound, NULL},
    {"MAKEPAINSOUND",     P_ActMakePainSound, NULL},
    {"PLAYER_SCREAM",     A_PlayerScream, NULL},
    {"CLOSE ATTACK",      P_ActMeleeAttack, DDF_StateGetAttack},
    {"RANGE ATTACK",      P_ActRangeAttack, DDF_StateGetAttack},
    {"SPARE ATTACK",      P_ActSpareAttack, DDF_StateGetAttack},
    {"RANGEATTEMPTSND",   P_ActMakeRangeAttemptSound, NULL},
    {"REFIRE CHECK",      P_ActRefireCheck, NULL},
    {"LOOKOUT",           P_ActStandardLook, NULL},
    {"SUPPORT LOOKOUT",   P_ActPlayerSupportLook, NULL},
    {"CHASE",             P_ActStandardChase, NULL},
    {"RESCHASE",          P_ActResurrectChase, NULL},
    {"WALKSOUND CHASE",   P_ActWalkSoundChase, NULL},
    {"MEANDER",           P_ActStandardMeander, NULL},
    {"SUPPORT MEANDER",   P_ActPlayerSupportMeander, NULL},
    {"EXPLOSIONDAMAGE",   P_ActDamageExplosion, NULL},
    {"THRUST",            P_ActThrust, NULL},
    {"TRACER",            P_ActFixedHomingProjectile, NULL},
    {"RANDOM TRACER",     P_ActRandomHomingProjectile, NULL},
    {"RESET SPREADER",    P_ActResetSpreadCount, NULL},
    {"SMOKING",           P_ActCreateSmokeTrail, NULL},
    {"TRACKERACTIVE",     P_ActTrackerActive, NULL},
    {"TRACKERFOLLOW",     P_ActTrackerFollow, NULL},
    {"TRACKERSTART",      P_ActTrackerStart, NULL},
    {"EFFECTTRACKER",     P_ActEffectTracker, NULL},
    {"CHECKBLOOD",        P_ActCheckBlood, NULL},
    {"CHECKMOVING",       P_ActCheckMoving, NULL},
    {"JUMP",              P_ActJump, DDF_StateGetJump},
    {"EXPLODE",           P_ActExplode, NULL},
    {"ACTIVATE LINETYPE", P_ActActivateLineType, DDF_StateGetIntPair},
    {"RTS ENABLE TAGGED", P_ActEnableRadTrig,  DDF_StateGetInteger},
    {"RTS DISABLE TAGGED",P_ActDisableRadTrig, DDF_StateGetInteger},
    {"TOUCHY REARM",      P_ActTouchyRearm, NULL},
    {"TOUCHY DISARM",     P_ActTouchyDisarm, NULL},
    {"BOUNCE REARM",      P_ActBounceRearm, NULL},
    {"BOUNCE DISARM",     P_ActBounceDisarm, NULL},
    {"PATH CHECK",        P_ActPathCheck, NULL},
    {"PATH FOLLOW",       P_ActPathFollow, NULL},
    {"DROPITEM",          P_ActDropItem, DDF_StateGetMobj},
    {"TRANS SET",         P_ActTransSet, DDF_StateGetPercent},
    {"TRANS FADE",        P_ActTransFade, DDF_StateGetPercent},
    {"TRANS MORE",        P_ActTransMore, DDF_StateGetPercent},
    {"TRANS LESS",        P_ActTransLess, DDF_StateGetPercent},
    {"TRANS ALTERNATE",   P_ActTransAlternate, DDF_StateGetPercent},
    {"DLIGHT SET",        P_ActDLightSet,  DDF_StateGetInteger},
    {"DLIGHT FADE",       P_ActDLightFade, DDF_StateGetInteger},
    {"DLIGHT RANDOM",     P_ActDLightRandom, DDF_StateGetIntPair},

    {"FACE",              P_ActFaceDir, DDF_StateGetInteger},
    {"TURN",              P_ActTurnDir, DDF_StateGetInteger},
    {"TURN RANDOM",       P_ActTurnRandom, DDF_StateGetInteger},
    {"MLOOK FACE",        P_ActMlookFace, DDF_StateGetSlope},
    {"MLOOK TURN",        P_ActMlookTurn, DDF_StateGetSlope},
    {"MOVE FWD",          P_ActMoveFwd, DDF_StateGetFloat},
    {"MOVE RIGHT",        P_ActMoveRight, DDF_StateGetFloat},
    {"MOVE UP",           P_ActMoveUp, DDF_StateGetFloat},
    {"STOP",              P_ActStopMoving, NULL},

    // miscellaneous actions
    {"NOTHING", NULL, NULL},

    // bossbrain actions
    {"BRAINSPIT", A_BrainSpit, NULL},
    {"CUBESPAWN", A_CubeSpawn, NULL},
    {"CUBETRACER", P_ActHomeToSpot, NULL},
    {"BRAINSCREAM", A_BrainScream, NULL},
    {"BRAINMISSILEEXPLODE", A_BrainMissileExplode, NULL},
    {"BRAINDIE", A_BrainDie, NULL},

    // -AJA- backwards compatibility cruft...
    {"!VARIEDEXPDAMAGE",   P_ActDamageExplosion, NULL},
    {"!VARIED THRUST",     P_ActThrust, NULL},
    {"!RANDOMJUMP", NULL, NULL},
    {"!ALTERTRANSLUC",   NULL, NULL},
    {"!ALTERVISIBILITY", NULL, NULL},
    {"!LESSVISIBLE", NULL, NULL},
    {"!MOREVISIBLE", NULL, NULL},
    {NULL, NULL, NULL}
};

const specflags_t keytype_names[] =
{
    {"BLUECARD",    KF_BlueCard,    0},
    {"YELLOWCARD",  KF_YellowCard,  0},
    {"REDCARD",     KF_RedCard,     0},
    {"BLUESKULL",   KF_BlueSkull,   0},
    {"YELLOWSKULL", KF_YellowSkull, 0},
    {"REDSKULL",    KF_RedSkull,    0},
    {"GREENCARD",   KF_GreenCard,   0},
    {"GREENSKULL",  KF_GreenSkull,  0},

    {"GOLD KEY",    KF_GoldKey,     0},
    {"SILVER KEY",  KF_SilverKey,   0},
    {"BRASS KEY",   KF_BrassKey,    0},
    {"COPPER KEY",  KF_CopperKey,   0},
    {"STEEL KEY",   KF_SteelKey,    0},
    {"WOODEN KEY",  KF_WoodenKey,   0},
    {"FIRE KEY",    KF_FireKey,     0},
    {"WATER KEY",   KF_WaterKey,    0},

    // backwards compatibility
    {"KEY BLUECARD",    KF_BlueCard,    0},
    {"KEY YELLOWCARD",  KF_YellowCard,  0},
    {"KEY REDCARD",     KF_RedCard,     0},
    {"KEY BLUESKULL",   KF_BlueSkull,   0},
    {"KEY YELLOWSKULL", KF_YellowSkull, 0},
    {"KEY REDSKULL",    KF_RedSkull,    0},
    {NULL, 0, 0}
};

const specflags_t armourtype_names[] =
{
    {"GREEN ARMOUR",  ARMOUR_Green,  0},
    {"BLUE ARMOUR",   ARMOUR_Blue,   0},
    {"YELLOW ARMOUR", ARMOUR_Yellow, 0},
    {"RED ARMOUR",    ARMOUR_Red,    0},
    {NULL, 0, 0}
};

const specflags_t powertype_names[] =
{
    {"POWERUP INVULNERABLE", PW_Invulnerable, 0},
    {"POWERUP BERSERK",      PW_Berserk,      0},
    {"POWERUP PARTINVIS",    PW_PartInvis,    0},
    {"POWERUP ACIDSUIT",     PW_AcidSuit,     0},
    {"POWERUP AUTOMAP",      PW_AllMap,       0},
    {"POWERUP LIGHTGOGGLES", PW_Infrared,     0},
    {"POWERUP JETPACK",      PW_Jetpack,      0},
    {"POWERUP NIGHTVISION",  PW_NightVision,  0},
    {"POWERUP SCUBA",        PW_Scuba,        0},
    {NULL, 0, 0}
};

const specflags_t simplecond_names[] =
{
    {"JUMPING",     COND_Jumping,    0},
    {"CROUCHING",   COND_Crouching,  0},
    {"SWIMMING",    COND_Swimming,   0},
    {"ATTACKING",   COND_Attacking,  0},
    {"RAMPAGING",   COND_Rampaging,  0},
    {"USING",       COND_Using,      0},
    {NULL, 0, 0}
};
</t>
<t tx="T2390">@ DDF_CompareName

Compare two names. This is like stricmp(), except that spaces
and `_' characters are ignored for comparison purposes.

-AJA- 1999/09/11: written.
@c

int DDF_CompareName(const char *A, const char *B)
{
  for (;;)
  {
    if (*A == 0 &amp;&amp; *B == 0)
      return 0;

    if (*A == 0)
      return -1;

    if (*B == 0)
      return +1;

    if (*A == ' ' || *A == '_')
    {
      A++; continue;
    }

    if (*B == ' ' || *B == '_')
    {
      B++; continue;
    }

    if (toupper(*A) != toupper(*B))
      break;

    A++; B++;
  }

  return toupper(*A) - toupper(*B);
}
</t>
<t tx="T2391">
static boolean_t ThingTryParseState(const char *field, 
    const char *contents, int index, boolean_t is_last)
{
  int i;
  const state_starter_t *starter;
  const char *pos;

  char labname[68];

  if (strncasecmp(field, "STATES(", 7) != 0)
    return false;

  // extract label name
  field += 7;

  pos = strchr(field, ')');
  
  if (pos == NULL || pos == field || pos &gt; (field+64))
    return false;

  Z_StrNCpy(labname, field, pos - field);
  
  // check for the "standard" states
  starter = NULL;

  for (i=0; thing_starters[i].label; i++)
    if (DDF_CompareName(thing_starters[i].label, labname) == 0)
      break;
  
  if (thing_starters[i].label)
    starter = &amp;thing_starters[i];

  DDF_StateReadState(contents, labname,
      &amp;buffer_mobj.first_state, &amp;buffer_mobj.last_state,
      starter ? starter-&gt;state_num : NULL, index, 
      is_last ? starter ? starter-&gt;last_redir : "IDLE" : NULL, 
      thing_actions);

  return true;
}
</t>
<t tx="T2392">@ DDF PARSE ROUTINES
@c

static boolean_t ThingStartEntry(const char *buffer)
{
  int i;
  boolean_t replaces = false;

  char namebuf[200];
  int number = 0;
  char *pos = strchr(buffer, ':');

  if (pos)
  {
    Z_StrNCpy(namebuf, buffer, pos - buffer);
    number = MAX(0, atoi(pos+1));
  }
  else
  {
    strcpy(namebuf, buffer);
  }

  if (namebuf[0])
  {
    for (i=num_disabled_mobjinfo; i &lt; num_mobjinfo; i++)
    {
      if (DDF_CompareName(mobjinfo[i]-&gt;ddf.name, namebuf) == 0)
      {
        dynamic_mobj = mobjinfo[i];
        replaces = true;
        break;
      }
    }

    // if found, adjust pointer array to keep newest entries at end
    if (replaces &amp;&amp; i &lt; (num_mobjinfo-1))
    {
      Z_MoveData(mobjinfo + i, mobjinfo + i + 1, mobjinfo_t *,
          num_mobjinfo - i);
      mobjinfo[num_mobjinfo - 1] = dynamic_mobj;
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;mobjinfo_a, ++num_mobjinfo);
    
    dynamic_mobj = mobjinfo[num_mobjinfo - 1];
    dynamic_mobj-&gt;ddf.name = (namebuf[0]) ? Z_StrDup(namebuf) :
        DDF_MainCreateUniqueName("UNNAMED_THING", num_mobjinfo);
  }

  dynamic_mobj-&gt;ddf.number = number;

  // instantiate the static entry
  buffer_mobj = template_mobj;

  return replaces;
}
</t>
<t tx="T2393">
void ThingParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("THING_PARSE: %s = %s;\n", field, contents);
#endif

  if (DDF_MainParseField(thing_commands, field, contents))
    return;
  
  if (ThingTryParseState(field, contents, index, is_last))
    return;

  // handle properties
  if (index == 0 &amp;&amp; DDF_CompareName(contents, "TRUE") == 0)
  {
    DDF_MobjGetSpecial(field, NULL);  // FIXME FOR OFFSETS
    return;
  }

  DDF_WarnError("Unknown thing/attack command: %s\n", field);
}
</t>
<t tx="T2394">
static void ThingFinishEntry(void)
{
  ddf_base_t base;
  
  if (buffer_mobj.first_state)
    DDF_StateFinishStates(buffer_mobj.first_state, buffer_mobj.last_state);

  // count-as-kill things are automatically monsters
  if (buffer_mobj.flags &amp; MF_COUNTKILL)
    buffer_mobj.extendedflags |= EF_MONSTER;

  // check stuff...

  if (buffer_mobj.mass &lt; 1)
  {
    DDF_WarnError("Bad MASS value %f in DDF.\n", buffer_mobj.mass);
    buffer_mobj.mass = 1;
  }

  if (buffer_mobj.halo.height &gt;= 0)
  {
    if (buffer_mobj.halo.minsize &lt; 0)
      buffer_mobj.halo.minsize = buffer_mobj.halo.size / 2;

    if (buffer_mobj.halo.maxsize &lt; 0)
      buffer_mobj.halo.maxsize = buffer_mobj.halo.size * 2;
  }

  // check CAST stuff
  if (buffer_mobj.castorder &gt; 0)
  {
    if (! buffer_mobj.chase_state)
      DDF_Error("Cast object must have CHASE states !\n");

    if (! buffer_mobj.death_state)
      DDF_Error("Cast object must have DEATH states !\n");
  }

  // FIXME: check more stuff
  
  if (!buffer_mobj.idle_state &amp;&amp; buffer_mobj.spawn_state)
    buffer_mobj.idle_state = buffer_mobj.spawn_state;
  
  // transfer static entry to dynamic entry
  
  base = dynamic_mobj-&gt;ddf;
  dynamic_mobj[0] = buffer_mobj;
  dynamic_mobj-&gt;ddf = base;

  // compute CRC...
  CRC32_Init(&amp;dynamic_mobj-&gt;ddf.crc);

  // FIXME: add more stuff...

  CRC32_Done(&amp;dynamic_mobj-&gt;ddf.crc);
}
</t>
<t tx="T2395">
static void ThingClearAll(void)
{
  // not safe to delete the thing entries

  num_disabled_mobjinfo = num_mobjinfo;
}
</t>
<t tx="T2396">

void DDF_ReadThings(void *data, int size)
{
  readinfo_t things;

  things.memfile = data;
  things.memsize = size;
  things.tag = "THINGS";
  things.entries_per_dot = 6;

  if (things.memfile)
  {
    things.message = NULL;
    things.filename = NULL;
    things.lumpname = "DDFTHING";
  }
  else
  {
    things.message = "DDF_InitThings";
    things.filename = "things.ddf";
    things.lumpname = NULL;
  }

  things.start_entry  = ThingStartEntry;
  things.parse_field  = ThingParseField;
  things.finish_entry = ThingFinishEntry;
  things.clear_all    = ThingClearAll;

  DDF_MainReadFile(&amp;things);
}
</t>
<t tx="T2397">
void DDF_MobjInit(void)
{
  Z_InitStackArray(&amp;mobjinfo_a, (void ***)&amp;mobjinfo, sizeof(mobjinfo_t), 0);

  // clear lookup cache
  memset(mobj_lookup_cache, 0, sizeof(mobj_lookup_cache));
}
</t>
<t tx="T2398">
void DDF_MobjCleanUp(void)
{
  int i;
  mobjinfo_t *mo;

  // lookup references

  for (i=num_disabled_mobjinfo; i &lt; num_mobjinfo; i++)
  {
    mo = mobjinfo[i];

    DDF_ErrorSetEntryName("[%s]  (things.ddf)", mo-&gt;ddf.name);

    mo-&gt;dropitem = mo-&gt;dropitem_ref ? DDF_MobjLookup(mo-&gt;dropitem_ref) : NULL;

    mo-&gt;blood = mo-&gt;blood_ref ? DDF_MobjLookup(mo-&gt;blood_ref) :
        DDF_MobjLookup("BLOOD");

    mo-&gt;respawneffect = mo-&gt;respawneffect_ref ? 
        DDF_MobjLookup(mo-&gt;respawneffect_ref) :
        (mo-&gt;flags &amp; MF_SPECIAL) ? 
            DDF_MobjLookup("ITEM RESPAWN") :
            DDF_MobjLookup("RESPAWN FLASH");

    mo-&gt;spitspot = mo-&gt;spitspot_ref ? DDF_MobjLookup(mo-&gt;spitspot_ref) : NULL;

    // -AJA- 1999/08/07: New SCALE &amp; ASPECT fields.
    //       The parser placed ASPECT in xscale and SCALE in yscale.
    //       Now clean it up.
    mo-&gt;xscale *= mo-&gt;yscale;

    DDF_ErrorClearEntryName();
  }
}
</t>
<t tx="T2399">@ DDF_MobjLookup

Looks an mobjinfo by name, returns a fatal error if it does not exist.
@c

const mobjinfo_t *DDF_MobjLookup(const char *refname)
{
  int i;
  int downto;

  // special rule for internal names (beginning with `_'), to allow
  // savegame files to find attack MOBJs that may have been masked by
  // a #CLEARALL.

  downto = (refname[0] == '_') ? 0 : num_disabled_mobjinfo;

  // NOTE: we go backwards, so that later entries take priority
  for (i=num_mobjinfo-1; i &gt;= downto; i--)
  {
    if (mobjinfo[i]-&gt;ddf.name &amp;&amp; 
        DDF_CompareName(mobjinfo[i]-&gt;ddf.name, refname) == 0)
      return mobjinfo[i];
  }

  if (lax_errors)
    return mobjinfo[0];

  DDF_Error("Unknown thing type: %s\n", refname);
  return NULL;
}
</t>
<t tx="T2400">
const mobjinfo_t *DDF_MobjLookupNum(const int number)
{
  int slot = DDF_MobjHashFunc(number);
  int i;

  // check the cache
  if (mobj_lookup_cache[slot] &amp;&amp;
      mobj_lookup_cache[slot]-&gt;ddf.number == number)
  {
    return mobj_lookup_cache[slot];
  }

  // find mobj by number
  // NOTE: go backwards, so newer entries are found first
  for (i=num_mobjinfo-1; i &gt;= num_disabled_mobjinfo; i--)
  {
    if (mobjinfo[i]-&gt;ddf.number == number)
      break;
  }
  
  if (i &lt; 0)
    return NULL;

  // update the cache
  mobj_lookup_cache[slot] = mobjinfo[i];

  return mobjinfo[i];
}
</t>
<t tx="T2401">@ DDF_MobjLookupCast
@c

const mobjinfo_t *DDF_MobjLookupCast(int castnum)
{
  int i;

  // search for a matching cast
  for (i=num_mobjinfo-1; i &gt;= num_disabled_mobjinfo; i--)
  {
    if (mobjinfo[i]-&gt;castorder == castnum)
      return mobjinfo[i];
  }

  // not found, try castnumber #1
  
  if (castnum == 1)
    I_Error("Must have thing with castorder of 1 !\n");

  return DDF_MobjLookupCast(1);
}
</t>
<t tx="T2402">@ ParseBenefitString

Parses a string like "HEALTH(20:100)". Returns the number of
number parameters (0, 1 or 2). Causes an error if it cannot parse
the string.
@c

static int ParseBenefitString(const char *info, char *name,
    float_t *value, float_t *limit)
{
  int len = strlen(info);

  char *pos = strchr(info, '(');
  char buffer[200];

  // do we have matched parentheses ?
  if (pos &amp;&amp; len &gt;= 4 &amp;&amp; info[len - 1] == ')')
  {
    int len2 = (pos - info);

    Z_StrNCpy(name, info, len2);

    len -= len2 + 2;
    Z_StrNCpy(buffer, pos + 1, len);

    switch (sscanf(buffer, " %f : %f ", value, limit))
    {
      case 1: return 1;
      case 2: return 2;
        
      default:
        DDF_WarnError("Missing values in benefit string: %s\n", info);
        return -1;
    }
  }
  else if (pos)
  {
    DDF_WarnError("Malformed benefit string: %s\n", info);
    return -1;
  }

  strcpy(name, info);
  return 0;
}
</t>
<t tx="T2403">@ BENEFIT TESTERS

These return true if the name matches that particular type of
benefit (e.g. "ROCKET" for ammo), and then adjusts the benefit
according to how many number values there were. Otherwise returns
false.
@c

static boolean_t BenefitTryAmmo(const char *name, benefit_t *be,
    int num_vals)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(name, ammo_types, 
      &amp;be-&gt;subtype, false, false))
  {
    return false;
  }

  be-&gt;type = BENEFIT_Ammo;
  be-&gt;limit = 0;

  if ((ammotype_t)be-&gt;subtype == AM_NoAmmo)
  {
    DDF_WarnError("Illegal ammo benefit: %s\n", name);
    return false;
  }
    
  if (num_vals &lt; 1)
  {
    DDF_WarnError("Ammo benefit used, but amount is missing.\n");
    return false;
  }

  if (num_vals &gt; 1)
  {
    DDF_WarnError("Ammo benefit cannot have a limit value.\n");
    return false;
  }
    
  return true;
}
</t>
<t tx="T2404">
static boolean_t BenefitTryAmmoLimit(const char *name, benefit_t *be,
    int num_vals)
{
  char namebuf[200];
  int len = strlen(name);

  // check for ".LIMIT" prefix

  if (len &lt; 7 || DDF_CompareName(name+len-6, ".LIMIT") != 0)
    return false;
  
  len -= 6;
  Z_StrNCpy(namebuf, name, len);

  if (CHKF_Positive != DDF_MainCheckSpecialFlag(namebuf, ammo_types, 
      &amp;be-&gt;subtype, false, false))
  {
    return false;
  }

  be-&gt;type = BENEFIT_AmmoLimit;
  be-&gt;limit = 0;

  if (be-&gt;subtype == AM_NoAmmo)
  {
    DDF_WarnError("Illegal ammolimit benefit: %s\n", name);
    return false;
  }
    
  if (num_vals &lt; 1)
  {
    DDF_WarnError("AmmoLimit benefit used, but amount is missing.\n");
    return false;
  }

  if (num_vals &gt; 1)
  {
    DDF_WarnError("AmmoLimit benefit cannot have a limit value.\n");
    return false;
  }
    
  return true;
}
</t>
<t tx="T2405">
static boolean_t BenefitTryWeapon(const char *name, benefit_t *be,
    int num_vals)
{
  be-&gt;subtype = DDF_WeaponLookup(name);
  
  if (be-&gt;subtype &lt; 0)
    return false;

  be-&gt;type = BENEFIT_Weapon;
  be-&gt;limit = 1.0;

  if (num_vals &lt; 1)
    be-&gt;amount = 1.0;
  else if (be-&gt;amount != 0.0 &amp;&amp; be-&gt;amount != 1.0)
  {
    DDF_WarnError("Weapon benefit used, bad amount value: %1.1f\n", be-&gt;amount);
    return false;
  }

  if (num_vals &gt; 1)
  {
    DDF_WarnError("Weapon benefit cannot have a limit value.\n");
    return false;
  }
 
  return true;
}
</t>
<t tx="T2406">
static boolean_t BenefitTryKey(const char *name, benefit_t *be,
    int num_vals)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(name, keytype_names, 
      &amp;be-&gt;subtype, false, false))
  {
    return false;
  }

  be-&gt;type = BENEFIT_Key;
  be-&gt;limit = 1.0;

  if (num_vals &lt; 1)
    be-&gt;amount = 1.0;
  else if (be-&gt;amount != 0.0 &amp;&amp; be-&gt;amount != 1.0)
  {
    DDF_WarnError("Key benefit used, bad amount value: %1.1f\n", be-&gt;amount);
    return false;
  }

  if (num_vals &gt; 1)
  {
    DDF_WarnError("Key benefit cannot have a limit value.\n");
    return false;
  }
 
  return true;
}
</t>
<t tx="T2407">
static boolean_t BenefitTryHealth(const char *name, benefit_t *be,
    int num_vals)
{
  if (DDF_CompareName(name, "HEALTH") != 0)
    return false;
  
  be-&gt;type = BENEFIT_Health;
  be-&gt;subtype = 0;

  if (num_vals &lt; 1)
  {
    DDF_WarnError("Health benefit used, but amount is missing.\n");
    return false;
  }

  if (num_vals &lt; 2)
    be-&gt;limit = 100.0;
    
  return true;
}
</t>
<t tx="T2408">
static boolean_t BenefitTryArmour(const char *name, benefit_t *be,
    int num_vals)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(name, armourtype_names, 
      &amp;be-&gt;subtype, false, false))
  {
    return false;
  }

  be-&gt;type = BENEFIT_Armour;

  if (num_vals &lt; 1)
  {
    DDF_WarnError("Armour benefit used, but amount is missing.\n");
    return false;
  }

  if (num_vals &lt; 2)
  {
    switch (be-&gt;subtype)
    {
      case ARMOUR_Green:  be-&gt;limit = 100; break;
      case ARMOUR_Blue:   be-&gt;limit = 200; break;
      case ARMOUR_Yellow: be-&gt;limit = 200; break;
      case ARMOUR_Red:    be-&gt;limit = 200; break;
      default: ;
    }
  }

  return true;
}
</t>
<t tx="T2409">
static boolean_t BenefitTryPowerup(const char *name, benefit_t *be,
    int num_vals)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(name, powertype_names, 
      &amp;be-&gt;subtype, false, false))
  {
    return false;
  }

  be-&gt;type = BENEFIT_Powerup;

  if (num_vals &lt; 1)
    be-&gt;amount = 99999.0;

  if (num_vals &lt; 2)
    be-&gt;limit = 99999.0;
 
  return true;
}
</t>
<t tx="T2410">
static void BenefitAdd(benefit_t **list, benefit_t *source)
{
  benefit_t *cur, *tail;

  // check if this benefit overrides a previous one
  for (cur=(*list); cur; cur=cur-&gt;next)
  {
    if (cur-&gt;type == source-&gt;type &amp;&amp; cur-&gt;subtype == source-&gt;subtype)
    {
      cur-&gt;amount = source-&gt;amount;
      cur-&gt;limit  = source-&gt;limit;
      return;
    }
  }

  // nope, create a new one and link it onto the _TAIL_
  cur = Z_New(benefit_t, 1);

  cur[0] = source[0];
  cur-&gt;next = NULL;

  if ((*list) == NULL)
  {
    (*list) = cur;
    return;
  }

  for (tail = (*list); tail &amp;&amp; tail-&gt;next; tail=tail-&gt;next)
  { }

  tail-&gt;next = cur;
}
</t>
<t tx="T2411">@ DDF_MobjGetBenefit

Parse a single benefit and update the benefit list accordingly. If
the type/subtype are not in the list, add a new entry, otherwise
just modify the existing entry.
@c

void DDF_MobjGetBenefit(const char *info, void *storage)
{
  char namebuf[200];
  int num_vals;

  benefit_t temp;

  DEV_ASSERT2(storage);

  num_vals = ParseBenefitString(info, namebuf, &amp;temp.amount, &amp;temp.limit);

  // an error occurred ?
  if (num_vals &lt; 0)
    return;

  if (BenefitTryAmmo(namebuf, &amp;temp, num_vals) ||
      BenefitTryAmmoLimit(namebuf, &amp;temp, num_vals) ||
      BenefitTryWeapon(namebuf, &amp;temp, num_vals) ||
      BenefitTryKey(namebuf, &amp;temp, num_vals) ||
      BenefitTryHealth(namebuf, &amp;temp, num_vals) ||
      BenefitTryArmour(namebuf, &amp;temp, num_vals) ||
      BenefitTryPowerup(namebuf, &amp;temp, num_vals))
  {
    BenefitAdd((benefit_t **) storage, &amp;temp);
    return;
  }

  DDF_WarnError("Unknown/Malformed benefit type: %s\n", namebuf);
}
</t>
<t tx="T2412">@ -KM- 1998/11/25 Translucency to fractional.
-KM- 1998/12/16 Added individual flags for all.
-AJA- 2000/02/02: Split into two lists.
@c

static const specflags_t normal_specials[] =
{
    {"FUZZY", MF_FUZZY, 0},
    {"SOLID", MF_SOLID, 0},
    {"ON CEILING", MF_SPAWNCEILING + MF_NOGRAVITY, 0},
    {"FLOATER", MF_FLOAT + MF_NOGRAVITY, 0},
    {"INERT", MF_NOBLOCKMAP, 0},
    {"TELEPORT TYPE", MF_NOGRAVITY, 0},
    {"LINKS", MF_NOBLOCKMAP + MF_NOSECTOR, 1},
    {"DAMAGESMOKE", MF_NOBLOOD, 0},
    {"SHOOTABLE", MF_SHOOTABLE, 0},
    {"COUNT AS KILL", MF_COUNTKILL, 0},
    {"COUNT AS ITEM", MF_COUNTITEM, 0},
    {"SPECIAL", MF_SPECIAL, 0},
    {"SECTOR", MF_NOSECTOR, 1},
    {"BLOCKMAP", MF_NOBLOCKMAP, 1},
    {"SPAWNCEILING", MF_SPAWNCEILING, 0},
    {"GRAVITY", MF_NOGRAVITY, 1},
    {"DROPOFF", MF_DROPOFF, 0},
    {"PICKUP", MF_PICKUP, 0},
    {"CLIP", MF_NOCLIP, 1},
    {"SLIDER", MF_SLIDE, 0},
    {"FLOAT", MF_FLOAT, 0},
    {"TELEPORT", MF_TELEPORT, 0},
    {"MISSILE", MF_MISSILE, 0},
    {"BARE MISSILE", MF_MISSILE, 0},
    {"DROPPED", MF_DROPPED, 0},
    {"CORPSE", MF_CORPSE, 0},
    {"STEALTH", MF_STEALTH, 0},
    {"DEATHMATCH", MF_NOTDMATCH, 1},
    {"TOUCHY", MF_TOUCHY, 0},
    {NULL, 0, 0}
};

static specflags_t extended_specials[] =
{
    {"RESPAWN", EF_NORESPAWN, 1},
    {"RESURRECT", EF_NORESURRECT, 1},
    {"DISLOYAL", EF_DISLOYALTYPE, 0},
    {"TRIGGER HAPPY", EF_TRIGGERHAPPY, 0},
    {"ATTACK HURTS", EF_OWNATTACKHURTS, 0},
    {"BOSSMAN", EF_BOSSMAN, 0},
    {"NEVERTARGETED", EF_NEVERTARGET, 0},
    {"GRAV KILL", EF_NOGRAVKILL, 1},
    {"GRUDGE", EF_NOGRUDGE, 1},
    {"BOUNCE", EF_BOUNCE, 0},
    {"EDGEWALKER", EF_EDGEWALKER, 0},
    {"GRAVFALL", EF_GRAVFALL, 0},
    {"CLIMBABLE", EF_CLIMBABLE, 0},
    {"WATERWALKER", EF_WATERWALKER, 0},
    {"MONSTER", EF_MONSTER, 0},
    {"CROSSLINES", EF_CROSSLINES, 0},
    {"FRICTION", EF_NOFRICTION, 1},
    {"USABLE", EF_USABLE, 0},
    {"BLOCK SHOTS", EF_BLOCKSHOTS, 0},
    {"TUNNEL", EF_TUNNEL, 0},
    {NULL, 0, 0}
};

//
// DDF_MobjGetSpecial
//
// Compares info the the entries in special flag lists.  If found
// apply attribs for it to current buffer_mobj.
//
void DDF_MobjGetSpecial(const char *info, void *storage)
{
  int flag_value;

  // handle the "INVISIBLE" tag
  if (DDF_CompareName(info, "INVISIBLE") == 0)
  {
    buffer_mobj.translucency = PERCENT_MAKE(0);
    return;
  }

  // handle the "NOSHADOW" tag
  if (DDF_CompareName(info, "NOSHADOW") == 0)
  {
    buffer_mobj.shadow_trans = PERCENT_MAKE(0);
    return;
  }

  // the "MISSILE" tag needs special treatment, since it sets both
  // normal flags &amp; extended flags.
  if (DDF_CompareName(info, "MISSILE") == 0)
  {
    buffer_mobj.flags |= MF_MISSILE;
    buffer_mobj.extendedflags |= EF_CROSSLINES | EF_NOFRICTION;
    return;
  }
  
  switch (DDF_MainCheckSpecialFlag(info, normal_specials,
          &amp;flag_value, true, false))
  {
    case CHKF_Positive:
      buffer_mobj.flags |= flag_value;
      break;

    case CHKF_Negative:
      buffer_mobj.flags &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:

      // wasn't a normal special.  Try the extended ones...

      switch (DDF_MainCheckSpecialFlag(info, extended_specials,
              &amp;flag_value, true, false))
      {
        case CHKF_Positive:
          buffer_mobj.extendedflags |= flag_value;
          break;

        case CHKF_Negative:
          buffer_mobj.extendedflags &amp;= ~flag_value;
          break;

        case CHKF_User:
        case CHKF_Unknown:
          DDF_WarnError("DDF_MobjGetSpecial: Unknown special '%s'", info);
          break;
      }
      break;
  }
}
</t>
<t tx="T2413">
static specflags_t dlight_type_names[] =
{
    {"NONE",      DLITE_None,      0},
    {"CONSTANT",  DLITE_Constant,  0},
    {"LINEAR",    DLITE_Linear,    0},
    {"QUADRATIC", DLITE_Quadratic, 0},
    {NULL, 0, 0}
};

//
// DDF_MobjGetDLight
//
void DDF_MobjGetDLight(const char *info, void *storage)
{
  dlight_type_e *dtype = (dlight_type_e *)storage;
  int flag_value;
  
  DEV_ASSERT2(dtype);

  if (CHKF_Positive != DDF_MainCheckSpecialFlag(info, 
      dlight_type_names, &amp;flag_value, false, false))
  {
    DDF_WarnError("Unknown dlight type '%s'", info);
    return;
  }

  (*dtype) = flag_value;
}
</t>
<t tx="T2414">@ DDF_MobjGetExtra

The "EXTRA" field. FIXME: Improve the system.
@c

void DDF_MobjGetExtra(const char *info, void *storage)
{
  // If NULL is passed, then the mobj is not marked as extra. Otherwise,
  // it is (in the future, we may support a system where extras can be split
  // up into several subsets, which can be individually toggled, based
  // on the EXTRA= value).
  if (!DDF_CompareName(info, "NULL"))
  {
    buffer_mobj.extendedflags &amp;= ~EF_EXTRA;
  }
  else
  {
    buffer_mobj.extendedflags |= EF_EXTRA;
  }
}
</t>
<t tx="T2415">@ DDF_MobjGetPlayer

Reads player number and makes sure that maxplayer is large enough.
@c

void DDF_MobjGetPlayer(const char *info, void *storage)
{
  int *dest = (int *)storage;

  DDF_MainGetNumeric(info, storage);

  if (*dest &gt; MAXPLAYERS)
    DDF_Error("Bad player number `%d'.  Maximum is %d\n", *dest,
        MAXPLAYERS);
}
</t>
<t tx="T2416">@ DDF_MobjMakeAttackObj

Creates an object that is tightly bound to an attack.

-AJA- 2000/02/11: written.
@c

mobjinfo_t *DDF_MobjMakeAttackObj(mobjinfo_t *info, const char *atk_name)
{
  char namebuf[400];

  mobjinfo_t *result;

  sprintf(namebuf, "__ATKMOBJ_%s", atk_name);

  // add it to array
  Z_SetArraySize(&amp;mobjinfo_a, ++num_mobjinfo);
 
  result = mobjinfo[num_mobjinfo-1];

  result[0] = info[0];

  result-&gt;ddf.name = Z_StrDup(namebuf);
  result-&gt;ddf.number = 0;
  result-&gt;ddf.crc = -1;

  return result;
}
</t>
<t tx="T2417">
const mobjinfo_t *DDF_MobjLookupPlayer(int playernum)
{
  int i;

  for (i=num_mobjinfo-1; i &gt;= num_disabled_mobjinfo; i--)
    if (mobjinfo[i]-&gt;playernum == playernum)
      return mobjinfo[i];

  I_Error("Player type %d%s missing in DDF !", playernum+1,
      (playernum &lt;= -2) ? " (DEATHBOT)" : "");
  return NULL;
}
</t>
<t tx="T2418">@ CONDITION TESTERS

These return true if the name matches that particular type of
condition (e.g. "ROCKET" for ammo), and adjusts the condition
accodingly. Otherwise returns false.
@c

static boolean_t ConditionTryAmmo(const char *name, const char *sub,
    condition_check_t *cond)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(name, ammo_types, 
      &amp;cond-&gt;subtype, false, false))
  {
    return false;
  }

  if ((ammotype_t)cond-&gt;subtype == AM_NoAmmo)
  {
    DDF_WarnError("Illegal ammo in condition: %s\n", name);
    return false;
  }
    
  if (sub[0])
    sscanf(sub, " %f ", &amp;cond-&gt;amount);
   
  cond-&gt;cond_type = COND_Ammo;
  return true;
}
</t>
<t tx="T2419">
static boolean_t ConditionTryWeapon(const char *name, const char *sub,
    condition_check_t *cond)
{
  cond-&gt;subtype = DDF_WeaponLookup(name);
  
  if (cond-&gt;subtype &lt; 0)
    return false;

  cond-&gt;cond_type = COND_Weapon;
  return true;
}
</t>
<t tx="T2420">
static boolean_t ConditionTryKey(const char *name, const char *sub,
    condition_check_t *cond)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(name, keytype_names, 
      &amp;cond-&gt;subtype, false, false))
  {
    return false;
  }

  cond-&gt;cond_type = COND_Key;
  return true;
}
</t>
<t tx="T2421">
static boolean_t ConditionTryHealth(const char *name, const char *sub,
    condition_check_t *cond)
{
  if (DDF_CompareName(name, "HEALTH") != 0)
    return false;
 
  if (sub[0])
    sscanf(sub, " %f ", &amp;cond-&gt;amount);
   
  cond-&gt;cond_type = COND_Health;
  return true;
}
</t>
<t tx="T2422">
static boolean_t ConditionTryArmour(const char *name, const char *sub,
    condition_check_t *cond)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(name, armourtype_names, 
      &amp;cond-&gt;subtype, false, false))
  {
    return false;
  }

  if (sub[0])
    sscanf(sub, " %f ", &amp;cond-&gt;amount);

  cond-&gt;cond_type = COND_Armour;
  return true;
}
</t>
<t tx="T2423">
static boolean_t ConditionTryPowerup(const char *name, const char *sub,
    condition_check_t *cond)
{
  if (CHKF_Positive != DDF_MainCheckSpecialFlag(name, powertype_names, 
      &amp;cond-&gt;subtype, false, false))
  {
    return false;
  }

  if (sub[0])
    sscanf(sub, " %f ", &amp;cond-&gt;amount);
 
  cond-&gt;cond_type = COND_Powerup;
  return true;
}
</t>
<t tx="T2424">
static boolean_t ConditionTryPlayerState(const char *name, const char *sub,
    condition_check_t *cond)
{
  return (CHKF_Positive == DDF_MainCheckSpecialFlag(name, 
        simplecond_names, (int *)&amp;cond-&gt;cond_type, false, false));
}
</t>
<t tx="T2425">@ DDF_MainParseCondition

Returns `false' if parsing failed.
@c

boolean_t DDF_MainParseCondition(const char *info, condition_check_t *cond)
{
  char typebuf[100];
  char sub_buf[100];

  int len = strlen(info);
  int t_off;
  const char *pos;

  cond-&gt;negate = false;
  cond-&gt;cond_type = COND_NONE;
  cond-&gt;subtype = 0;
  cond-&gt;amount = 1;

  pos = strchr(info, '(');

  // do we have matched parentheses ?
  if (pos &amp;&amp; pos &gt; info &amp;&amp; len &gt;= 4 &amp;&amp; info[len-1] == ')')
  {
    int len2 = (pos - info);

    Z_StrNCpy(typebuf, info, len2);

    len -= len2 + 2;
    Z_StrNCpy(sub_buf, pos + 1, len);
  }
  else if (pos || strchr(info, ')'))
  {
    DDF_WarnError("Malformed condition string: %s\n", info);
    return false;
  }
  else
  {
    strcpy(typebuf, info);
    sub_buf[0] = 0;
  }

  // check for negation
  t_off = 0;
  if (strnicmp(typebuf, "NOT_", 4) == 0)
  {
    cond-&gt;negate = true;
    t_off = 4;
  }
  
  if (ConditionTryAmmo(typebuf + t_off, sub_buf, cond) ||
      ConditionTryWeapon(typebuf + t_off, sub_buf, cond) ||
      ConditionTryKey(typebuf + t_off, sub_buf, cond) ||
      ConditionTryHealth(typebuf + t_off, sub_buf, cond) ||
      ConditionTryArmour(typebuf + t_off, sub_buf, cond) ||
      ConditionTryPowerup(typebuf + t_off, sub_buf, cond) ||
      ConditionTryPlayerState(typebuf + t_off, sub_buf, cond))
  {
    return true;
  }

  DDF_WarnError("Unknown/Malformed condition type: %s\n", typebuf);
  return false;
}
</t>
<t tx="T2426">@ignore
@language c

// Data Definition File Code (Music Playlist Handling)

&lt;&lt; ddf_mus #includes &gt;&gt;
&lt;&lt; ddf_mus declarations &gt;&gt;
@others
</t>
<t tx="T2427">#include "i_defs.h"
#include "dm_defs.h"
#include "ddf_locl.h"
#include "z_zone.h"
</t>
<t tx="T2428">
static playlist_t buffer_playlist;
static playlist_t *dynamic_playlist;

static const playlist_t template_playlist =
{
  DDF_BASE_NIL,    // ddf
  MUS_UNKNOWN,     // type
  MUSINF_UNKNOWN,  // infotype
  NULL             // info
};

playlist_t ** playlist = NULL;
int num_playlist = 0;

static stack_array_t playlist_a;

static void DDF_MusicParseInfo(const char *info, void *storage);

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_playlist

static const commandlist_t musplaylistcmds[] =
{
  DDF_CMD("MUSICINFO", ddf, DDF_MusicParseInfo),
  DDF_CMD_END
};
</t>
<t tx="T2429">@ DDF_MusicParseInfo

Parses the music information given.
@c

static void DDF_MusicParseInfo(const char *info, void *storage)
{
  char *musstrtype[] = { "UNKNOWN", "CD", "MIDI", "MUS", "MP3", NULL };
  char *musinftype[] = { "UNKNOWN", "TRACK", "LUMP", "FILE", NULL };
  char charbuff[256];
  int pos,i;

  // Get the music type
  i=0;
  pos=0;
  while (info[pos] != DIVIDE &amp;&amp; i&lt;255)
  {
    if (info[i] == '\0')
      DDF_Error("DDF_MusicParseInfo: Premature end of music info\n");

    charbuff[i] = info[pos];

    i++;
    pos++;
  }

  if (i==255)
    DDF_Error("DDF_MusicParseInfo: Music info too big\n");

  // -AJA- terminate charbuff with trailing \0.
  charbuff[i] = 0;

  i=MUS_UNKNOWN;
  while (i!=ENDOFMUSTYPES &amp;&amp; strcasecmp(charbuff, musstrtype[i]))
    i++;

  if (i==ENDOFMUSTYPES)
    DDF_Error("DDF_MusicParseInfo: Unknown music type: '%s'\n", charbuff);
  else
    buffer_playlist.type = i;

  // Data Type
  i=0;
  pos++;
  while (info[pos] != DIVIDE &amp;&amp; i&lt;255)
  {
    if (info[pos] == '\0')
      DDF_Error("DDF_MusicParseInfo: Premature end of music info\n");

    charbuff[i] = info[pos];

    pos++;
    i++;
  }

  if (i==255)
    DDF_Error("DDF_MusicParseInfo: Music info too big\n");

  // -AJA- terminate charbuff with trailing \0.
  charbuff[i] = 0;

  i=MUSINF_UNKNOWN;
  while (musinftype[i] != NULL &amp;&amp; strcasecmp(charbuff, musinftype[i]))
    i++;

  if (i==ENDOFMUSINFTYPES)
    DDF_Error("DDF_MusicParseInfo: Unknown music info: '%s'\n", charbuff);
  else
    buffer_playlist.infotype = i; // technically speaking this is proper

  // Remained is the string reference: filename/lumpname/track-number
  pos++;
  buffer_playlist.info = Z_StrDup(&amp;info[pos]);

  return;
}
</t>
<t tx="T2430">@ DDF PARSE ROUTINES
@c

static boolean_t PlaylistStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;
  int number = MAX(0, atoi(name));

  if (number == 0)
    DDF_Error("Bad music number in playlist.ddf: %s\n", name);

  for (i=0; i &lt; num_playlist; i++)
  {
    if (playlist[i]-&gt;ddf.number == number)
    {
      dynamic_playlist = playlist[i];
      replaces = true;
      break;
    }
  }
    
  // if found, adjust pointer array to keep newest entries at end
  if (replaces &amp;&amp; i &lt; (num_playlist-1))
  {
    Z_MoveData(playlist + i, playlist + i + 1, playlist_t *,
        num_playlist - i);
    playlist[num_playlist - 1] = dynamic_playlist;
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;playlist_a, ++num_playlist);
    
    dynamic_playlist = playlist[num_playlist - 1];
  }

  dynamic_playlist-&gt;ddf.name   = NULL;
  dynamic_playlist-&gt;ddf.number = number;

  // instantiate the static entry
  buffer_playlist = template_playlist;

  return replaces;
}
</t>
<t tx="T2431">
static void PlaylistParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("PLAYLIST_PARSE: %s = %s;\n", field, contents);
#endif

  if (! DDF_MainParseField(musplaylistcmds, field, contents))
    DDF_WarnError("Unknown playlist.ddf command: %s\n", field);
}
</t>
<t tx="T2432">
static void PlaylistFinishEntry(void)
{
  ddf_base_t base;
  
  // transfer static entry to dynamic entry
  
  base = dynamic_playlist-&gt;ddf;
  dynamic_playlist[0] = buffer_playlist;
  dynamic_playlist-&gt;ddf = base;

  // Compute CRC.  In this case, there is no need, since the music
  // playlist has zero impact on the game simulation itself.
  dynamic_playlist-&gt;ddf.crc = 0;
}
</t>
<t tx="T2433">
static void PlaylistClearAll(void)
{
  // safe to just remove all current entries

  num_playlist = 0;
  Z_SetArraySize(&amp;playlist_a, num_playlist);
}
</t>
<t tx="T2434">@ DDF_ReadMusicPlaylist
@c

void DDF_ReadMusicPlaylist(void *data, int size)
{
  readinfo_t playlistinfo;

  playlistinfo.memfile = data;
  playlistinfo.memsize = size;
  playlistinfo.tag = "PLAYLISTS";
  playlistinfo.entries_per_dot = 3;

  if (playlistinfo.memfile)
  {
    playlistinfo.message  = NULL;
    playlistinfo.filename = NULL;
    playlistinfo.lumpname = "DDFPLAY";
  }
  else
  {
    playlistinfo.message  = "DDF_InitMusicPlaylist";
    playlistinfo.filename = "playlist.ddf";
    playlistinfo.lumpname = NULL;
  }

  playlistinfo.start_entry  = PlaylistStartEntry;
  playlistinfo.parse_field  = PlaylistParseField;
  playlistinfo.finish_entry = PlaylistFinishEntry;
  playlistinfo.clear_all    = PlaylistClearAll;

  DDF_MainReadFile(&amp;playlistinfo);
}
</t>
<t tx="T2435">@ DDF_MusicPlaylistInit
@c

void DDF_MusicPlaylistInit(void)
{
  Z_InitStackArray(&amp;playlist_a, (void ***)&amp;playlist, sizeof(playlist_t), 0);
}
</t>
<t tx="T2436">@ DDF_MusicPlaylistCleanUp
@c

void DDF_MusicPlaylistCleanUp(void)
{
  /* nothing to do */
}
</t>
<t tx="T2437">@ DDF_MusicLookupNum
@c

const playlist_t *DDF_MusicLookupNum(int number)
{
  int i;

  for (i=0; i &lt; num_playlist; i++)
    if (playlist[i]-&gt;ddf.number == number)
      return playlist[i];
  
  // not found
  return NULL;
}
</t>
<t tx="T2438">@ignore
@language c

// Data Definition File Code (Sectors)

// Sector Setup and Parser Code

// -KM- 1998/09/27 Written.

&lt;&lt; ddf_sect #includes &gt;&gt;
&lt;&lt; ddf_sect declarations &gt;&gt;
@others
</t>
<t tx="T2439">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "m_fixed.h"
#include "p_mobj.h"
#include "p_local.h"
#include "z_zone.h"
</t>
<t tx="T2440">
#undef  DF
#define DF  DDF_CMD

#define DDF_SectHashFunc(x)  (((x) + 211) % 211)

static specialsector_t buffer_sect;
static specialsector_t *dynamic_sect;

static const specialsector_t template_sect =
{
  DDF_BASE_NIL,  // ddf

  false,      // secret
  GRAVITY,    // gravity
  FRICTION,   // friction
  VISCOSITY,  // viscosity
  DRAG,       // drag 
  false,      // crush

  // Floor
  {
    mov_undefined,  // type
    false,  // is_ceiling
    false,  // crush
    0,      // speed_up
    0,      // speed_down
    REF_Absolute, // destref
    0,      // dest
    REF_Absolute, // otherref
    0,      // other
    "",     // tex
    0,      // wait
    0,      // prewait
    NULL,   // sfxstart
    NULL,   // sfxup
    NULL,   // sfxdown
    NULL,   // sfxstop
    0,      // scroll_angle
    0.0     // scroll_speed
  },

  // Ceiling
  {
    mov_undefined,  // type
    true,   // is_ceiling
    false,  // crush
    0,      // speed_up
    0,      // speed_down
    REF_Absolute, // destref
    0,      // dest
    REF_Absolute, // otherref
    0,      // other
    "",     // tex
    0,      // wait
    0,      // prewait
    NULL,   // sfxstart
    NULL,   // sfxup
    NULL,   // sfxdown
    NULL,   // sfxstop
    0,      // scroll_angle
    0.0     // scroll_speed
  },

  // Elevator
  {
    mov_undefined,  // type
    -1,             // speed up
    -1,             // speed down
    0,              // wait
    0,              // prewait
    sfx_None,       // SFX start
    sfx_None,       // SFX up
    sfx_None,       // SFX down
    sfx_None        // SFX stop
  },

  // Light
  { LITE_None, 64, PERCENT_MAKE(50), 0,0,0, 8 },

  // Damage
  {
    0,      // nominal
    -1,     // linear_max
    -1,     // error
    31,     // delay (in tics)
    NULL_LABEL, NULL_LABEL, NULL_LABEL,  // override labels
    false   // no_armour
  },

  0,            // special_flags
  EXIT_None,    // exit type
  NULL,         // colourmap
  NULL,         // ambient_sfx
  DEFAULT_APPEAR,  // appear
  4,            // crush_time
  10.0,         // crush_damage
  0,            // push_angle
  0.0,          // push_speed
  0.0           // push_zspeed
};

specialsector_t ** ddf_sectors = NULL;
int num_ddf_sectors = 0;

static stack_array_t ddf_sectors_a;

static const specialsector_t *sector_lookup_cache[211];

// BOOM generalised sector support
static specialsector_t ** ddf_gen_sectors;
int num_ddf_gen_sectors;
static stack_array_t ddf_gen_sectors_a;


void DDF_SectGetSpecialFlags(const char *info, void *storage);

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_sect

static const commandlist_t sect_commands[] =
{
  DDF_SUB_LIST("FLOOR",    f,      floor_commands),
  DDF_SUB_LIST("CEILING",  c,      floor_commands),
  DDF_SUB_LIST("ELEVATOR", e,      elevator_commands),
  DDF_SUB_LIST("DAMAGE",   damage, damage_commands),

  DF("SECRET", secret, DDF_MainGetBoolean),
  DF("SPECIAL", special_flags, DDF_SectGetSpecialFlags),
  DF("CRUSH", crush, DDF_MainGetBoolean),

  DF("LIGHT TYPE", l.type, DDF_SectGetLighttype),
  DF("LIGHT LEVEL", l.level, DDF_MainGetNumeric),
  DF("LIGHT DARKTIME", l.darktime, DDF_MainGetTime),
  DF("LIGHT BRIGHTTIME", l.brighttime, DDF_MainGetTime),
  DF("LIGHT CHANCE", l.chance, DDF_MainGetPercent),
  DF("LIGHT SYNC", l.sync, DDF_MainGetTime),
  DF("LIGHT STEP", l.step, DDF_MainGetNumeric),
  DF("EXIT", e_exit, DDF_SectGetExit),
  DF("USE COLOURMAP", use_colourmap, DDF_MainGetColourmap),
  DF("GRAVITY", gravity, DDF_MainGetFloat),
  DF("FRICTION", friction, DDF_MainGetFloat),
  DF("VISCOSITY", viscosity, DDF_MainGetFloat),
  DF("DRAG", drag, DDF_MainGetFloat),
  DF("AMBIENT SOUND", ambient_sfx, DDF_MainLookupSound),
  DF("WHEN APPEAR", appear, DDF_MainGetWhenAppear),
  DF("PUSH ANGLE", push_angle, DDF_MainGetAngle),
  DF("PUSH SPEED", push_speed, DDF_MainGetFloat),
  DF("PUSH ZSPEED", push_zspeed, DDF_MainGetFloat),

  // -AJA- backwards compatibility cruft...
  DF("!DAMAGE", damage.nominal, DDF_MainGetFloat),
  DF("!DAMAGETIME", damage.delay, DDF_MainGetTime),
  DF("!SOUND", ddf, DDF_DummyFunction),
  DF("!LIGHT PROBABILITY", ddf, DDF_DummyFunction),

  DF("CRUSH TIME", crush_time, DDF_MainGetTime),
  DF("CRUSH DAMAGE", crush_damage, DDF_MainGetFloat),

  DDF_CMD_END
};
</t>
<t tx="T2441">@ DDF PARSE ROUTINES


SectorStartEntry
@c

static boolean_t SectorStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;
  int number = MAX(0, atoi(name));

  if (number == 0)
    DDF_Error("Bad sector number in sectors.ddf: %s\n", name);

  for (i=0; i &lt; num_ddf_sectors; i++)
  {
    if (ddf_sectors[i]-&gt;ddf.number == number)
    {
      dynamic_sect = ddf_sectors[i];
      replaces = true;
      break;
    }
  }
    
  // if found, adjust pointer array to keep newest entries at end
  if (replaces &amp;&amp; i &lt; (num_ddf_sectors-1))
  {
    Z_MoveData(ddf_sectors + i, ddf_sectors + i + 1, specialsector_t *,
        num_ddf_sectors - i);
    ddf_sectors[num_ddf_sectors - 1] = dynamic_sect;
  }

  // not found, create a new one
  if (!replaces)
  {
    Z_SetArraySize(&amp;ddf_sectors_a, ++num_ddf_sectors);
    dynamic_sect = ddf_sectors[num_ddf_sectors - 1];
  }

  dynamic_sect-&gt;ddf.name   = NULL;
  dynamic_sect-&gt;ddf.number = number;

  // instantiate the static entry
  buffer_sect = template_sect;

  return replaces;
}
</t>
<t tx="T2442">@ SectorParseField
@c

static void SectorParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("SECTOR_PARSE: %s = %s;\n", field, contents);
#endif

  if (DDF_MainParseField(sect_commands, field, contents))
    return;

  // handle properties
  if (index == 0 &amp;&amp; DDF_CompareName(contents, "TRUE") == 0)
  {
    DDF_SectGetSpecialFlags(field, NULL);  // FIXME FOR OFFSETS
    return;
  }

  DDF_WarnError("Unknown sectors.ddf command: %s\n", field);
}
</t>
<t tx="T2443">@ SectorFinishEntry
@c

static void SectorFinishEntry(void)
{
  ddf_base_t base;
  
  // FIXME: check stuff...
  
  // transfer static entry to dynamic entry
  
  base = dynamic_sect-&gt;ddf;
  dynamic_sect[0] = buffer_sect;
  dynamic_sect-&gt;ddf = base;

  // compute CRC...
  CRC32_Init(&amp;dynamic_sect-&gt;ddf.crc);

  // FIXME: add stuff...
  
  CRC32_Done(&amp;dynamic_sect-&gt;ddf.crc);
}
</t>
<t tx="T2444">@ SectorClearAll
@c

static void SectorClearAll(void)
{
  // it is safe to just delete all sector types

  num_ddf_sectors = 0;
  Z_SetArraySize(&amp;ddf_sectors_a, num_ddf_sectors);
}
</t>
<t tx="T2445">@ DDF_ReadSectors
@c

void DDF_ReadSectors(void *data, int size)
{
  readinfo_t sects;

  sects.memfile = data;
  sects.memsize = size;
  sects.tag = "SECTORS";
  sects.entries_per_dot = 1;

  if (sects.memfile)
  {
    sects.message = NULL;
    sects.filename = NULL;
    sects.lumpname = "DDFSECT";
  }
  else
  {
    sects.message = "DDF_InitSectors";
    sects.filename = "sectors.ddf";
    sects.lumpname = NULL;
  }

  sects.start_entry  = SectorStartEntry;
  sects.parse_field  = SectorParseField;
  sects.finish_entry = SectorFinishEntry;
  sects.clear_all    = SectorClearAll;

  DDF_MainReadFile(&amp;sects);
}
</t>
<t tx="T2446">@ DDF_SectorInit
@c

void DDF_SectorInit(void)
{
  Z_InitStackArray(&amp;ddf_sectors_a, (void ***)&amp;ddf_sectors,
      sizeof(specialsector_t), 0);

  Z_InitStackArray(&amp;ddf_gen_sectors_a, (void ***)&amp;ddf_gen_sectors, 
      sizeof(specialsector_t), 0);

  // clear lookup cache
  memset(sector_lookup_cache, 0, sizeof(sector_lookup_cache));
}
</t>
<t tx="T2447">@ DDF_SectorCleanUp
@c

void DDF_SectorCleanUp(void)
{
  /* nothing to do */
}
</t>
<t tx="T2448">@ ----------------------------------------------------------------------------

DDF_SectorLookupGeneralised

Support for BOOM generalised sector types.
@c

static const specialsector_t *DDF_SectorLookupGeneralised(int number)
{
  int i;
  specialsector_t *sector;

  for (i=0; i &lt; num_ddf_gen_sectors; i++)
  {
    if (ddf_gen_sectors[i]-&gt;ddf.number == number)
      return ddf_gen_sectors[i];
  }

  // this sector type does not exist yet in the array of dynamic
  // sector types.  Thus we need to create it.

  Z_SetArraySize(&amp;ddf_gen_sectors_a, ++num_ddf_gen_sectors);
    
  sector = ddf_gen_sectors[num_ddf_gen_sectors - 1];

  // instantiate it with defaults
  (*sector) = template_sect;

  DDF_BoomMakeGenSector(sector, number);
  
  return (const specialsector_t *) sector;
}
</t>
<t tx="T2449">
void DDF_SectorClearGeneralised(void)
{
  num_ddf_gen_sectors = 0;
  Z_SetArraySize(&amp;ddf_gen_sectors_a, num_ddf_gen_sectors);

  // clear the cache
  memset(sector_lookup_cache, 0, sizeof(sector_lookup_cache));
}
</t>
<t tx="T2450">@ DDF_SectorLookupNum

Returns the special sector properties from given specialtype

-KM- 1998/09/19 Wrote Procedure
-AJA- 2000/02/09: Reworked. Hash table is now a cache.
@c

const specialsector_t *DDF_SectorLookupNum(int number)
{
  int i;
  int slot = DDF_SectHashFunc(number);

  // check the lookup cache...
  if (sector_lookup_cache[slot] &amp;&amp;
      sector_lookup_cache[slot]-&gt;ddf.number == number)
  {
    return sector_lookup_cache[slot];
  }

  // check for BOOM generalised sector types
  if ((level_flags.compat_mode == CM_BOOM) &amp;&amp; number &gt;= 0x20)
  {
    sector_lookup_cache[slot] = DDF_SectorLookupGeneralised(number);
    return sector_lookup_cache[slot];
  }
  
  // find sector by number
  // NOTE: we go backwards, so that later entries are found first
  for (i=num_ddf_sectors-1; i &gt;= 0; i--)
  {
    if (ddf_sectors[i]-&gt;ddf.number == number)
      break;
  }

  if (i &lt; 0)
  {
    // -AJA- 1999/06/19: Don't crash out if the sector type is unknown,
    // just print a message and ignore it (like for unknown thing types).

    I_Warning("Unknown sector type: %d\n", number);

    return &amp;template_sect;
  }

  // update the cache
  sector_lookup_cache[slot] = ddf_sectors[i];

  return sector_lookup_cache[slot];
}
</t>
<t tx="T2451">
static specflags_t sector_specials[] =
{
  {"WHOLE REGION", SECSP_WholeRegion, 0},
  {"PROPORTIONAL", SECSP_Proportional, 0},
  {"PUSH ALL", SECSP_PushAll, 0},
  {"PUSH CONSTANT", SECSP_PushConstant, 0},
  {"AIRLESS", SECSP_AirLess, 0},
  {"SWIM", SECSP_Swimming, 0},
  {NULL, 0, 0}
};

//
// DDF_SectGetSpecialFlags
//
// Gets the sector specials.
//
void DDF_SectGetSpecialFlags(const char *info, void *storage)
{
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, sector_specials, &amp;flag_value,
      true, false))
  {
    case CHKF_Positive:
      buffer_sect.special_flags |= flag_value;
      break;
    
    case CHKF_Negative:
      buffer_sect.special_flags &amp;= ~flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown sector special: %s", info);
      break;
  }
}
</t>
<t tx="T2452">
static specflags_t exit_types[] =
{
    {"NONE", EXIT_None, 0},
    {"NORMAL", EXIT_Normal, 0},
    {"SECRET", EXIT_Secret, 0},

    // -AJA- backwards compatibility cruft...
    {"!EXIT", EXIT_Normal, 0},
    {NULL, 0, 0}
};

//
// DDF_SectGetExit
//
// Get the exit type
//
void DDF_SectGetExit(const char *info, void *storage)
{
  int *dest = (int *)storage;
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, exit_types, &amp;flag_value,
      false, false))
  {
    case CHKF_Positive:
    case CHKF_Negative:
      (*dest) = flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown Exit type: %s\n", info);
      break;
  }
}
</t>
<t tx="T2453">
static specflags_t light_types[] =
{
    {"NONE", LITE_None, 0},
    {"SET",  LITE_Set,  0},
    {"FADE", LITE_Fade, 0},
    {"STROBE", LITE_Strobe, 0},
    {"FLASH",  LITE_Flash,  0},
    {"GLOW",   LITE_Glow,   0},
    {"FLICKER", LITE_FireFlicker, 0},
    {NULL, 0, 0}
};

//
// DDF_SectGetLighttype
//
// Get the light type
//
void DDF_SectGetLighttype(const char *info, void *storage)
{
  int *dest = (int *)storage;
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, light_types, &amp;flag_value,
      false, false))
  {
    case CHKF_Positive:
    case CHKF_Negative:
      (*dest) = flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown light type: %s\n", info);
      break;
  }
}
</t>
<t tx="T2454">
static specflags_t movement_types[] =
{
    {"MOVE", mov_Once, 0},
    {"MOVEWAITRETURN", mov_MoveWaitReturn, 0},
    {"CONTINUOUS", mov_Continuous, 0},
    {"PLAT", mov_Plat, 0},
    {"BUILDSTAIRS", mov_Stairs, 0},
    {"STOP", mov_Stop, 0},
    {NULL, 0, 0}
};

//
// DDF_SectGetMType
//
// Get movement types: MoveWaitReturn etc
//
void DDF_SectGetMType(const char *info, void *storage)
{
  int *dest = (int *)storage;
  int flag_value;

  switch (DDF_MainCheckSpecialFlag(info, movement_types, &amp;flag_value,
      false, false))
  {
    case CHKF_Positive:
    case CHKF_Negative:
      (*dest) = flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown Movement type: %s\n", info);
      break;
  }
}
</t>
<t tx="T2455">
static specflags_t reference_types[] =
{
    {"ABSOLUTE", REF_Absolute, false},
    
    {"FLOOR", REF_Current, false},
    {"CEILING", REF_Current + REF_CEILING, false},
    
    // Note that LOSURROUNDINGFLOOR has the REF_INCLUDE flag, but the
    // others do not.  It's there to maintain backwards compatibility.
    // 
    {"LOSURROUNDINGCEILING", REF_Surrounding + REF_CEILING, false},
    {"HISURROUNDINGCEILING", REF_Surrounding + REF_CEILING + REF_HIGHEST, false},
    {"LOSURROUNDINGFLOOR", REF_Surrounding + REF_INCLUDE, false},
    {"HISURROUNDINGFLOOR", REF_Surrounding + REF_HIGHEST, false},
    
    // Note that REF_HIGHEST is used for the NextLowest types, and
    // vice versa, which may seem strange.  It's because the next
    // lowest sector is actually the highest of all adjacent sectors
    // that are lower than the current sector.
    // 
    {"NEXTLOWESTFLOOR", REF_Surrounding + REF_NEXT + REF_HIGHEST, false},
    {"NEXTHIGHESTFLOOR", REF_Surrounding + REF_NEXT, false},
    {"NEXTLOWESTCEILING", REF_Surrounding + REF_NEXT + REF_CEILING + REF_HIGHEST, false},
    {"NEXTHIGHESTCEILING", REF_Surrounding + REF_NEXT + REF_CEILING, false},
    
    {"LOWESTBOTTOMTEXTURE", REF_LowestLoTexture, false}
};

//
// DDF_SectGetDestRef
//
// Get surroundingsectorceiling/floorheight etc
//
void DDF_SectGetDestRef(const char *info, void *storage)
{
  int *dest = (int *)storage;
  int flag_value;

  // check for modifier flags
  if (DDF_CompareName(info, "INCLUDE") == 0)
  {
    *dest |= REF_INCLUDE;
    return;
  }
  else if (DDF_CompareName(info, "EXCLUDE") == 0)
  {
    *dest &amp;= ~REF_INCLUDE;
    return;
  }
   
  switch (DDF_MainCheckSpecialFlag(info, reference_types, &amp;flag_value,
      false, false))
  {
    case CHKF_Positive:
    case CHKF_Negative:
      (*dest) = flag_value;
      break;

    case CHKF_User:
    case CHKF_Unknown:
      DDF_WarnError("Unknown Reference Point: %s\n", info);
      break;
  }
}
</t>
<t tx="T2456">@ignore
@language c

// Data Definition File Code (Sounds)

// -KM- 1998/09/27 Finished :-)

&lt;&lt; ddf_sfx #includes &gt;&gt;
&lt;&lt; ddf_sfx declarations &gt;&gt;
@others
</t>
<t tx="T2457">#include "i_defs.h"

#include "dm_defs.h"
#include "dm_type.h"
#include "ddf_locl.h"
#include "m_random.h"
#include "s_sound.h"
#include "z_zone.h"
</t>
<t tx="T2458">
#undef  DF
#define DF  DDF_CMD

static sfxinfo_t buffer_sfx;
static sfxinfo_t *dynamic_sfx;

static const sfxinfo_t template_sfx =
{
  DDF_BASE_NIL,  // ddf

  "",     // lump_name
  { 0, { 0 }}, // normal
  0,      // singularity
  999,    // priority (lower is more important)
  PERCENT_MAKE(100), // volume
  false,  // looping
  false,  // precious
  S_CLIPPING_DIST, // max_distance
  NULL,   // cache next
  NULL    // cache prev
};

sfxinfo_t ** S_sfx;
int numsfx = 0;
int num_disabled_sfx = 0;

static stack_array_t S_sfx_a;


#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_sfx

static const commandlist_t sfx_commands[] =
{
  DF("LUMP NAME", lump_name, DDF_MainGetInlineStr10),
  DF("SINGULAR", singularity, DDF_MainGetNumeric),
  DF("PRIORITY", priority, DDF_MainGetNumeric),
  DF("VOLUME", volume, DDF_MainGetPercent),
  DF("LOOP", looping, DDF_MainGetBoolean),
  DF("PRECIOUS", precious, DDF_MainGetBoolean),
  DF("MAX DISTANCE", max_distance, DDF_MainGetFloat),

  // -AJA- backwards compatibility cruft...
  DF("!BITS",   ddf, DDF_DummyFunction),
  DF("!STEREO", ddf, DDF_DummyFunction),

  DDF_CMD_END
};

// -KM- 1998/10/29 Done sfx_t first so structure is aligned.
bastard_sfx_t bastard_sfx[] =
{
    {0, "swtchn"},
    {0, "tink"},
    {0, "radio"},
    {0, "oof"},
    {0, "pstop"},
    {0, "stnmov"},
    {0, "pistol"},
    {0, "swtchx"},
    {0, "jpmove"},
    {0, "jpidle"},
    {0, "jprise"},
    {0, "jpdown"},
    {0, "jpflow"}
};
</t>
<t tx="T2459">@ DDF PARSE ROUTINES
@c

static boolean_t SoundStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=num_disabled_sfx; i &lt; numsfx; i++)
    {
      if (DDF_CompareName(S_sfx[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_sfx = S_sfx[i];
        replaces = true;
        break;
      }
    }
    
    // if found, adjust pointer array to keep newest entries at end
    if (replaces &amp;&amp; i &lt; (numsfx-1))
    {
      Z_MoveData(S_sfx + i, S_sfx + i + 1, sfxinfo_t *, numsfx - i);
      S_sfx[numsfx - 1] = dynamic_sfx;
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;S_sfx_a, ++numsfx);
    
    dynamic_sfx = S_sfx[numsfx - 1];
    dynamic_sfx-&gt;normal.num = 1;
    dynamic_sfx-&gt;normal.sounds[0] = numsfx - 1;
    dynamic_sfx-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_SOUND", numsfx);
  }

  dynamic_sfx-&gt;ddf.number = 0;

  // instantiate the static entry
  buffer_sfx = template_sfx;

  return replaces;
}
</t>
<t tx="T2460">
static void SoundParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("SOUND_PARSE: %s = %s;\n", field, contents);
#endif

  if (! DDF_MainParseField(sfx_commands, field, contents))
    DDF_WarnError("Unknown sounds.ddf command: %s\n", field);
}
</t>
<t tx="T2461">
static void SoundFinishEntry(void)
{
  ddf_base_t base;
  sfx_t id;
  
  if (!buffer_sfx.lump_name[0])
    DDF_Error("Missing LUMP_NAME for sound.\n");

  // transfer static entry to dynamic entry
  // Keeps the ID info intact as well.
  
  base = dynamic_sfx-&gt;ddf;
  id = dynamic_sfx-&gt;normal;
  dynamic_sfx[0] = buffer_sfx;
  dynamic_sfx-&gt;ddf = base;
  dynamic_sfx-&gt;normal = id;

  // Compute CRC.  In this case, there is no need, since sounds have
  // zero impact on the game simulation itself.
  dynamic_sfx-&gt;ddf.crc = 0;
}
</t>
<t tx="T2462">
static void SoundClearAll(void)
{
  // not safe to delete entries -- mark them disabled

  num_disabled_sfx = numsfx;
}
</t>
<t tx="T2463">

void DDF_ReadSFX(void *data, int size)
{
  readinfo_t sfx_r;

  sfx_r.memfile = data;
  sfx_r.memsize = size;
  sfx_r.tag = "SOUNDS";
  sfx_r.entries_per_dot = 8;

  if (sfx_r.memfile)
  {
    sfx_r.message = NULL;
    sfx_r.filename = NULL;
    sfx_r.lumpname = "DDFSFX";
  }
  else
  {
    sfx_r.message = "DDF_InitSounds";
    sfx_r.filename = "sounds.ddf";
    sfx_r.lumpname = NULL;
  }

  sfx_r.start_entry  = SoundStartEntry;
  sfx_r.parse_field  = SoundParseField;
  sfx_r.finish_entry = SoundFinishEntry;
  sfx_r.clear_all    = SoundClearAll;

  DDF_MainReadFile(&amp;sfx_r);
}
</t>
<t tx="T2464">
void DDF_SFXInit(void)
{
  Z_InitStackArray(&amp;S_sfx_a, (void ***)&amp;S_sfx, sizeof(sfxinfo_t), 0);

  // create the null sfx
  Z_SetArraySize(&amp;S_sfx_a, numsfx = 1);
  S_sfx[numsfx-1][0] = template_sfx;
}
</t>
<t tx="T2465">
void DDF_SFXCleanUp(void)
{
  int i;

  for (i = sizeof(bastard_sfx) / sizeof(bastard_sfx_t); i--; )
    bastard_sfx[i].s = DDF_SfxLookupSound(bastard_sfx[i].name);
}
</t>
<t tx="T2466">@ DDF_SfxLookupSound

-ACB- 1999/11/06:
Fixed from using zero-length array style malloc - Not ANSI Compliant.
Renamed DDF_SfxLookupSound to destingush from the one in DDF_MAIN.C.

-AJA- 2001/11/03:
Modified to count matches first, then allocate the memory.
Prevents memory fragmentation.
@c

sfx_t *DDF_SfxLookupSound(const char *name)
{
  int i, count;
  int last_id = -1;

  sfx_t *r;

  // NULL Sound
  if (!name || !name[0])
    return NULL;

  // count them
  for (count=0, i=numsfx-1; i &gt;= num_disabled_sfx; i--)
  {
    if (strncasecmpwild(name, S_sfx[i]-&gt;ddf.name, 8) == 0)
    {
      count++;
      last_id = i;
    }
  }

  if (count == 0)
  {
    if (! lax_errors)
      DDF_Error("Unknown SFX: '%.8s'\n", name);

    return NULL;
  }

  // -AJA- optimisation to save some memory
  if (count == 1)
    return &amp; (S_sfx[last_id]-&gt;normal);

  // allocate elements.  Uses (count-1) since sfx_t already includes
  // the first integer.
  // 
  r = (sfx_t *) Z_New(byte, sizeof(sfx_t) + (count-1) * sizeof(int));

  // now store them
  for (r-&gt;num=0, i=numsfx-1; i &gt;= num_disabled_sfx; i--)
  {
    if (strncasecmpwild(name, S_sfx[i]-&gt;ddf.name, 8) == 0)
      r-&gt;sounds[r-&gt;num++] = i;
  }

  DEV_ASSERT2(r-&gt;num == count);

  return r;
}
</t>
<t tx="T2467">@ DDF_MainLookupSound

Lookup the sound specificed.

-ACB- 1998/07/08 Checked the S_sfx table for sfx names.
-ACB- 1998/07/18 Removed to the need set *currentcmdlist[commandref].data to -1
-KM- 1998/09/27 Fixed this func because of sounds.ddf
-KM- 1998/10/29 sfx_t finished
@c

void DDF_MainLookupSound(const char *info, void *storage)
{
  sfx_t **dest = (sfx_t **)storage;

  DEV_ASSERT2(info &amp;&amp; storage);

  *dest = DDF_SfxLookupSound(info);
}
</t>
<t tx="T2468">@ DDF_SfxSelect

Choose one of the sounds in sfx_t. Mainly here for data hiding,
keeping numsfx and S_sfx out of other code.
@c

sfxinfo_t *DDF_SfxSelect(const sfx_t *sound_id)
{
  int snd_num;
  
  DEV_ASSERT2(sound_id-&gt;num &gt;= 1);

  // -KM- 1999/01/31 Using P_Random here means demos and net games 
  //  get out of sync.
  // -AJA- 1999/07/19: That's why we use M_Random instead :).

  snd_num = sound_id-&gt;sounds[M_Random() % sound_id-&gt;num];

  DEV_ASSERT2(0 &lt;= snd_num &amp;&amp; snd_num &lt; numsfx);

  return S_sfx[snd_num];
}
</t>
<t tx="T2469">@ignore
@language c

// Data Definition File Code (States)

&lt;&lt; ddf_stat #includes &gt;&gt;
&lt;&lt; ddf_stat declarations &gt;&gt;
@others
</t>
<t tx="T2470">#include "i_defs.h"

#include "ddf_main.h"

#include "e_search.h"
#include "ddf_locl.h"
#include "dm_state.h"
#include "dstrings.h"
#include "m_argv.h"
#include "m_inline.h"
#include "m_math.h"
#include "m_misc.h"
#include "p_action.h"
#include "p_mobj.h"
#include "r_things.h"
#include "z_zone.h"
</t>
<t tx="T2471">

static const state_t template_state =
{
  0,          // sprite ref
  0,          // frame ref
  0,          // brightness
  -1,         // tics
  NULL,       // label
  NULL,       // routine
  NULL,       // parameter
  0,          // next state ref
  -1          // jump state ref
};

// -KM- 1998/11/25 All weapon related states are out
state_t *states = NULL;
int num_states;

// Until the DDF_StateFinishState() routine is called, the `nextstate'
// field of each state contains a special value.  0 for normal (no
// redirector).  -1 for the #REMOVE redirector.  Otherwise the top 16
// bits is a redirector, and the bottom 16 bits is a positive offset
// from that redirector (usually 0).
//
// Every time a new redirector is used, it is added to this list.  The
// top 16 bits (minus 1) will be an index into this list of redirector
// names.  These labels will be looked for in the states when the
// fixup routine is called.

static char **redirection_names = NULL;
static int num_redirection_names;

static char *stateinfo[NUMSPLIT + 1];
</t>
<t tx="T2472">

void DDF_StateInit(void)
{
  // setup the `S_NULL' state
  states = Z_New(state_t, 1);
  states[0] = template_state;
  num_states = 1;
}
</t>
<t tx="T2473">
void DDF_StateCleanUp(void)
{
  /* nothing to do */
}
</t>
<t tx="T2474">@ DDF_MainSplitIntoState

Small procedure that takes the info and splits it into relevant stuff

-KM- 1998/12/21 Rewrote procedure, much cleaner now.

-AJA- 2000/09/03: Rewrote _again_ damn it, in order to handle `:'
appearing inside brackets.
@c

static int DDF_MainSplitIntoState(const char *info)
{
  char *temp;
  char *first;

  int cur;
  int brackets=0;
  boolean_t done=false;

  // use a buffer, since we modify the string
  char infobuf[512];

  strcpy(infobuf, info);

  memset(stateinfo, 0, sizeof(stateinfo));

  first = temp = infobuf;

  for (cur=0; !done &amp;&amp; cur &lt; NUMSPLIT; temp++)
  {
    if (*temp == '(')
    {
      brackets++;
      continue;
    }

    if (*temp == ')')
    {
      if (brackets == 0)
        DDF_Error("Mismatched ) bracket in states: %s\n", info);

      brackets--;
      continue;
    }

    if (*temp &amp;&amp; *temp != ':')
      continue;

    if (brackets &gt; 0)
      continue;

    if (*temp == 0)
      done = true;

    *temp = 0;

    if (first[0] == REDIRECTOR)
    {
      // signify that we have found redirector
      stateinfo[0] = Z_StrDup(first + 1);
      stateinfo[1] = NULL;
      stateinfo[2] = NULL;

      if (! done)
        stateinfo[1] = Z_StrDup(temp + 1);

      return -1;
    }

    stateinfo[cur++] = Z_StrDup(first);
    first = temp + 1;
  }

  if (brackets &gt; 0)
    DDF_Error("Unclosed ( bracket in states: %s\n", info);

  return cur;
}
</t>
<t tx="T2475">@ DDF_DestroyStates

Kills a leak.
-ES- 2000/02/02 Added.
@c

static void DestroyStateInfo(void)
{
  int i;
  
  for (i = 0; i &lt; NUMSPLIT; i++)
  {
    if (stateinfo[i])
    {
      Z_Free(stateinfo[i]);
      stateinfo[i] = NULL;
    }
  }
}
</t>
<t tx="T2476">@ DDF_MainSplitActionArg

Small procedure that takes an action like "FOO(BAR)", and splits it
into two strings "FOO" and "BAR".

-AJA- 1999/08/10: written.
@c

static void DDF_MainSplitActionArg(char *info, char *actname, char *actarg)
{
  int len = strlen(info);
  char *mid = strchr(info, '(');

  if (mid &amp;&amp; len &gt;= 4 &amp;&amp; info[len - 1] == ')')
  {
    int len2 = (mid - info);

    Z_StrNCpy(actname, info, len2);

    len -= len2 + 2;
    Z_StrNCpy(actarg, mid + 1, len);
  }
  else
  {
    strcpy(actname, info);
    actarg[0] = 0;
  }
}
</t>
<t tx="T2477">@ StateGetRedirector
@c

static int StateGetRedirector(const char *redir)
{
  int i;

  for (i=0; i &lt; num_redirection_names; i++)
  {
    if (DDF_CompareName(redirection_names[i], redir) == 0)
      return i;
  }

  Z_Resize(redirection_names, char *, ++num_redirection_names);
  
  redirection_names[num_redirection_names-1] = Z_StrDup(redir);

  return num_redirection_names-1;
}
</t>
<t tx="T2478">@ StateFindLabel
@c

int StateFindLabel(int first, int last, const char *label)
{
  int i;

  for (i=first; i &lt;= last; i++)
  {
    if (!states[i].label)
      continue;

    if (DDF_CompareName(states[i].label, label) == 0)
      return i;
  }

  // compatibility hack:
  if (DDF_CompareName(label, "IDLE") == 0)
  {
    return StateFindLabel(first, last, "SPAWN");
  }
  
  DDF_Error("Unknown label `%s' (object has no such frames).\n", label);
  return 0;
}
</t>
<t tx="T2479">@ DDF_StateReadState
@c

void DDF_StateReadState(const char *info, const char *label,
    int *first, int *last, int *state_num, int index,
    const char *redir, const actioncode_t *action_list)
{
  int i, j;

  char action_name[128];
  char action_arg[128];

  state_t *cur;

  // Split the state info into component parts
  // -ACB- 1998/07/26 New Procedure, for cleaner code.

  i = DDF_MainSplitIntoState(info);
  if (i &lt; 5 &amp;&amp; i &gt;= 0)
  {
    if (strchr(info, '['))
    {
      // -ES- 2000/02/02 Probably unterminated state.
      DDF_Error("DDF_MainLoadStates: Bad state '%s', possibly missing ';'\n");
    }
    DDF_Error("Bad state '%s'\n", info);
  }

  if (stateinfo[0] == NULL)
    DDF_Error("Missing sprite in state frames: `%s'\n", info);

  //--------------------------------------------------
  //----------------REDIRECTOR HANDLING---------------
  //--------------------------------------------------

  if (stateinfo[2] == NULL)
  {
    if ((*first) == 0)
      DDF_Error("Redirector used without any states (`%s')\n", info);

    cur = &amp;states[(*last)];

    DEV_ASSERT2(stateinfo[0]);

    if (DDF_CompareName(stateinfo[0], "REMOVE") == 0)
    {
      cur-&gt;nextstate = -1;
      DestroyStateInfo();
      return;
    }  

    cur-&gt;nextstate = (StateGetRedirector(stateinfo[0]) + 1) &lt;&lt; 16;

    if (stateinfo[1] != NULL)
      cur-&gt;nextstate += MAX(0, atoi(stateinfo[1]) - 1);

    DestroyStateInfo();
    return;
  }

  //--------------------------------------------------
  //---------------- ALLOCATE NEW STATE --------------
  //--------------------------------------------------

  Z_Resize(states, state_t, ++num_states);

  cur = &amp;states[num_states-1];

  // initialise with defaults
  cur[0] = template_state;
  
  if ((*first) == 0)
  {
    // very first state for thing/weapon
    (*first) = num_states-1;
  }

  (*last) = num_states-1;
  
  if (index == 0)
  {
    // first state in this set of states
    if (state_num)
      state_num[0] = num_states-1;
    
    // ...therefore copy the label
    cur-&gt;label = Z_StrDup(label);
  }

  if (redir &amp;&amp; cur-&gt;nextstate == 0)
  {
    if (DDF_CompareName("REMOVE", redir) == 0)
      cur-&gt;nextstate = -1;
    else
      cur-&gt;nextstate = (StateGetRedirector(redir) + 1) &lt;&lt; 16;
  }

  //--------------------------------------------------
  //----------------SPRITE NAME HANDLING--------------
  //--------------------------------------------------

  if (!stateinfo[1] || !stateinfo[2] || !stateinfo[3])
    DDF_Error("Bad state frame, missing fields: %s\n", info);
  
  if (strlen(stateinfo[0]) != 4)
    DDF_Error("DDF_MainLoadStates: Sprite names must be 4 "
        "characters long '%s'.\n", stateinfo[0]);

  //--------------------------------------------------
  //--------------SPRITE INDEX HANDLING---------------
  //--------------------------------------------------

  // look at the first character
  j = stateinfo[1][0];

  // check for bugger up
  if (j &lt; 'A' || j &gt; ']')
    DDF_Error("DDF_MainLoadStates: Illegal sprite index: %s\n", stateinfo[1]);

  cur-&gt;frame = (short)(j - 65);
  cur-&gt;sprite = R_AddSpriteName(stateinfo[0], cur-&gt;frame);  

  //--------------------------------------------------
  //------------STATE TIC COUNT HANDLING--------------
  //--------------------------------------------------

  cur-&gt;tics = atol(stateinfo[2]);

  //--------------------------------------------------
  //------------STATE BRIGHTNESS LEVEL----------------
  //--------------------------------------------------

  if (!strcmp("BRIGHT", stateinfo[3]))
    cur-&gt;bright = 1;
  else if (strcmp("NORMAL", stateinfo[3]))
    DDF_WarnError("DDF_MainLoadStates: Lighting is not BRIGHT or NORMAL\n");

  //--------------------------------------------------
  //------------STATE ACTION CODE HANDLING------------
  //--------------------------------------------------

  if (stateinfo[4])
  {
    // Get Action Code Ref (Using remainder of the string).
    // Go through all the actions, end if terminator or action found
    //
    // -AJA- 1999/08/10: Updated to handle a special argument.

    DDF_MainSplitActionArg(stateinfo[4], action_name, action_arg);

    for (i=0; action_list[i].actionname; i++)
    {
      const char *current = action_list[i].actionname;
      boolean_t obsolete = false;

      if (current[0] == '!')
      {
        current++;
        obsolete = true;
      }
    
      if (DDF_CompareName(current, action_name) == 0)
      {
        if (obsolete &amp;&amp; !no_obsoletes)
          DDF_Warning("The ddf %s action is obsolete !\n", current);

        break;
      }
    }

    if (!action_list[i].actionname)
      DDF_WarnError("Unknown code pointer: %s\n", stateinfo[4]);
    else
    {
      cur-&gt;action = action_list[i].action;
      cur-&gt;action_par = NULL;

      if (action_list[i].handle_arg)
        (* action_list[i].handle_arg)(action_arg, cur);
    }
  }

  //--------------------------------------------------
  //---------------- MISC1 and MISC2 -----------------
  //--------------------------------------------------

  if ((stateinfo[5] || stateinfo[6]) &amp;&amp; !no_obsoletes)
    DDF_WarnError("Misc1 and Misc2 are no longer used.\n");

  DestroyStateInfo();
}
</t>
<t tx="T2480">@ DDF_StateFinishStates

Check through the states on an mobj and attempts to dereference any
encoded state redirectors.
@c

void DDF_StateFinishStates(int first, int last)
{
  int i;

  for (i=first; i &lt;= last; i++)
  {
    // handle next state ref
    if (states[i].nextstate == -1)
    {
      states[i].nextstate = S_NULL;
    }
    else if ((states[i].nextstate &gt;&gt; 16) == 0)
    {
      states[i].nextstate = (i == last) ? S_NULL : i+1;
    }
    else
    {
      states[i].nextstate = StateFindLabel(first, last,
        redirection_names[(states[i].nextstate &gt;&gt; 16) - 1]) +
        (states[i].nextstate &amp; 0xFFFF);
    }

    // handle jump state ref
    if (states[i].jumpstate == -1)
    {
      states[i].jumpstate = S_NULL;
    }
    else if ((states[i].jumpstate &gt;&gt; 16) == 0)
    {
      states[i].jumpstate = (i == last) ? S_NULL : i+1;
    }
    else
    {
      states[i].jumpstate = StateFindLabel(first, last,
        redirection_names[(states[i].jumpstate &gt;&gt; 16) - 1]) +
        (states[i].jumpstate &amp; 0xFFFF);
    }
  }
  
  // FIXME: can free the redirection name list here
}
</t>
<t tx="T2481">@ DDF_StateGetAttack

Parse the special argument for the state as an attack.

-AJA- 1999/08/10: written.
@c

void DDF_StateGetAttack(const char *arg, state_t * cur_state)
{
  if (!arg || !arg[0])
    return;

  cur_state-&gt;action_par = (void *)DDF_AttackLookup(arg);
}
</t>
<t tx="T2482">@ DDF_StateGetMobj
@c

void DDF_StateGetMobj(const char *arg, state_t * cur_state)
{
  if (!arg || !arg[0])
    return;

  cur_state-&gt;action_par = (void *)DDF_MobjLookup(arg);
}
</t>
<t tx="T2483">@ DDF_StateGetSound
@c

void DDF_StateGetSound(const char *arg, state_t * cur_state)
{
  if (!arg || !arg[0])
    return;

  cur_state-&gt;action_par = (void *)DDF_SfxLookupSound(arg);
}
</t>
<t tx="T2484">@ DDF_StateGetInteger
@c

void DDF_StateGetInteger(const char *arg, state_t * cur_state)
{
  int *value;

  if (!arg || !arg[0])
    return;

  value = Z_New(int, 1);

  if (sscanf(arg, " %i ", value) != 1)
    DDF_Error("DDF_StateGetInteger: bad value: %s\n", arg);

  cur_state-&gt;action_par = value;
}
</t>
<t tx="T2485">@ DDF_StateGetIntPair

Parses two integers separated by commas.
@c

void DDF_StateGetIntPair(const char *arg, state_t * cur_state)
{
  int *values;

  if (!arg || !arg[0])
    return;

  values = Z_New(int, 2);

  if (sscanf(arg, " %i , %i ", &amp;values[0], &amp;values[1]) != 2)
    DDF_Error("DDF_StateGetIntPair: bad values: %s\n", arg);

  cur_state-&gt;action_par = values;
}
</t>
<t tx="T2486">@ DDF_StateGetFloat
@c

void DDF_StateGetFloat(const char *arg, state_t * cur_state)
{
  float_t *value;

  if (!arg || !arg[0])
    return;

  value = Z_New(float_t, 1);

  if (sscanf(arg, " %f ", value) != 1)
    DDF_Error("DDF_StateGetFloat: bad value: %s\n", arg);

  cur_state-&gt;action_par = value;
}
</t>
<t tx="T2487">@ DDF_StateGetPercent
@c

void DDF_StateGetPercent(const char *arg, state_t * cur_state)
{
  percent_t *value;

  if (!arg || !arg[0])
    return;

  value = Z_New(percent_t, 1);

  if (sscanf(arg, " %f%% ", value) != 1 || (*value) &lt; 0)
    DDF_Error("DDF_StateGetPercent: Bad percentage: %s\n", arg);

  (* value) /= 100.0;

  cur_state-&gt;action_par = value;
}
</t>
<t tx="T2488">@ DDF_StateGetJump
@c

void DDF_StateGetJump(const char *arg, state_t * cur_state)
{
  // JUMP(label)
  // JUMP(label,chance)
  
  const char *s;
  act_jump_info_t *jump;

  char buffer[80];
  int len;
  int offset = 0;

  if (!arg || !arg[0])
    return;

  jump = Z_New(act_jump_info_t, 1);
  jump-&gt;chance = 1.0f;                  // -ACB- 2001/02/04 tis a precent_t

  s = strchr(arg, ',');

  if (! s)
  {
    len = strlen(arg);
  }
  else
  {
    // convert chance value
    DDF_MainGetPercent(s+1, &amp;jump-&gt;chance);
    
    len = s - arg;
  }

  if (len == 0)
    DDF_Error("DDF_StateGetJump: missing label !\n");

  if (len &gt; 75)
    DDF_Error("DDF_StateGetJump: label name too long !\n");

  // copy label name
  for (len=0; *arg &amp;&amp; (*arg != ':') &amp;&amp; (*arg != ','); len++, arg++)
    buffer[len] = *arg;

  buffer[len] = 0;

  if (*arg == ':')
    offset = MAX(0, atoi(arg+1) - 1);

  // set the jump state 
  
  cur_state-&gt;jumpstate = ((StateGetRedirector(buffer) + 1) &lt;&lt; 16) + offset;
  cur_state-&gt;action_par = jump;
}
</t>
<t tx="T2489">@ DDF_StateGetAngle
@c

void DDF_StateGetAngle(const char *arg, state_t * cur_state)
{
  angle_t *value;
  float_t tmp;

  if (!arg || !arg[0])
    return;

  value = Z_New(angle_t, 1);

  if (sscanf(arg, " %f ", &amp;tmp) != 1)
    DDF_Error("DDF_StateGetAngle: bad value: %s\n", arg);

  *value = FLOAT_2_ANG(tmp);

  cur_state-&gt;action_par = value;
}
</t>
<t tx="T2490">@ DDF_StateGetSlope
@c

void DDF_StateGetSlope(const char *arg, state_t * cur_state)
{
  float_t *value, tmp;

  if (!arg || !arg[0])
    return;

  value = Z_New(float_t, 1);

  if (sscanf(arg, " %f ", &amp;tmp) != 1)
    DDF_Error("DDF_StateGetSlope: bad value: %s\n", arg);

  if (tmp &gt; +89.5)
    tmp = +89.5;
  if (tmp &lt; -89.5)
    tmp = -89.5;

  *value = M_Tan(FLOAT_2_ANG(tmp));

  cur_state-&gt;action_par = value;
}
</t>
<t tx="T2491">@ignore
@language c

// Data Definition File Codes (Switch textures)

// Switch Texture Setup and Parser Code

&lt;&lt; ddf_swth #includes &gt;&gt;
&lt;&lt; ddf_swth declarations &gt;&gt;
@others
</t>
<t tx="T2492">#include "i_defs.h"

#include "ddf_locl.h"
#include "ddf_main.h"
#include "dm_state.h"
#include "p_local.h"
#include "p_spec.h"
#include "z_zone.h"
</t>
<t tx="T2493">
#undef  DF
#define DF  DDF_CMD

static switchlist_t buffer_switch;
static switchlist_t *dynamic_switch;

static const switchlist_t template_switch =
{
  DDF_BASE_NIL,  // ddf
  "",    // name1;
  "",    // name2;
  sfx_None,  // on_sfx;
  sfx_None,  // off_sfx;
  BUTTONTIME, // time
  {{0,0}}  // cache
};

switchlist_t ** alph_switches = NULL;
int num_alph_switches = 0;

static stack_array_t alph_switches_a;

#undef  DDF_CMD_BASE
#define DDF_CMD_BASE  buffer_switch

static const commandlist_t switch_commands[] =
{
  DF("ON TEXTURE",  name1, DDF_MainGetInlineStr10),
  DF("OFF TEXTURE", name2, DDF_MainGetInlineStr10),
  DF("ON SOUND",  on_sfx,  DDF_MainLookupSound),
  DF("OFF SOUND", off_sfx, DDF_MainLookupSound),
  DF("TIME", time, DDF_MainGetTime),

  // -AJA- backwards compatibility cruft...
  DF("!SOUND", on_sfx, DDF_MainLookupSound),

  DDF_CMD_END
};
</t>
<t tx="T2494">@ DDF PARSE ROUTINES
@c

static boolean_t SwitchStartEntry(const char *name)
{
  int i;
  boolean_t replaces = false;

  if (name &amp;&amp; name[0])
  {
    for (i=0; i &lt; num_alph_switches; i++)
    {
      if (DDF_CompareName(alph_switches[i]-&gt;ddf.name, name) == 0)
      {
        dynamic_switch = alph_switches[i];
        replaces = true;
        break;
      }
    }
    
    // if found, adjust pointer array to keep newest entries at end
    if (replaces &amp;&amp; i &lt; (num_alph_switches-1))
    {
      Z_MoveData(alph_switches + i, alph_switches + i + 1, switchlist_t *,
          num_alph_switches - i);
      alph_switches[num_alph_switches - 1] = dynamic_switch;
    }
  }

  // not found, create a new one
  if (! replaces)
  {
    Z_SetArraySize(&amp;alph_switches_a, ++num_alph_switches);
    
    dynamic_switch = alph_switches[num_alph_switches - 1];
    dynamic_switch-&gt;ddf.name = (name &amp;&amp; name[0]) ? Z_StrDup(name) :
        DDF_MainCreateUniqueName("UNNAMED_SWITCH", num_alph_switches);
  }

  dynamic_switch-&gt;ddf.number = 0;

  // instantiate the static entry
  buffer_switch = template_switch;

  return replaces;
}
</t>
<t tx="T2495">
static void SwitchParseField(const char *field, const char *contents,
    int index, boolean_t is_last)
{
#if (DEBUG_DDF)  
  L_WriteDebug("SWITCH_PARSE: %s = %s;\n", field, contents);
#endif

  if (! DDF_MainParseField(switch_commands, field, contents))
    DDF_WarnError("Unknown switch.ddf command: %s\n", field);
}
</t>
<t tx="T2496">
static void SwitchFinishEntry(void)
{
  ddf_base_t base;
  
  if (!buffer_switch.name1[0])
    DDF_Error("Missing first name for switch.\n");

  if (!buffer_switch.name2[0])
    DDF_Error("Missing last name for switch.\n");
 
  if (buffer_switch.time &lt;= 0)
    DDF_Error("Bad time value for switch: %d\n", buffer_switch.time);
   
  // transfer static entry to dynamic entry
  
  base = dynamic_switch-&gt;ddf;
  dynamic_switch[0] = buffer_switch;
  dynamic_switch-&gt;ddf = base;

  // Compute CRC.  In this case, there is no need, since switch
  // textures have zero impact on the game simulation.
  dynamic_switch-&gt;ddf.crc = 0;
}
</t>
<t tx="T2497">
static void SwitchClearAll(void)
{
  // safe here to delete all switches

  num_alph_switches = 0;
  Z_SetArraySize(&amp;alph_switches_a, num_alph_switches);
}
</t>
<t tx="T2498">

void DDF_ReadSW(void *data, int size)
{
#if (DEBUG_DDF)
  int i;
#endif

  readinfo_t switches;

  switches.memfile = data;
  switches.memsize = size;
  switches.tag = "SWITCHES";
  switches.entries_per_dot = 2;

  if (switches.memfile)
  {
    switches.message = NULL;
    switches.filename = NULL;
    switches.lumpname = "DDFSWTH";
  }
  else
  {
    switches.message = "DDF_InitSwitches";
    switches.filename = "switch.ddf";
    switches.lumpname = NULL;
  }

  switches.start_entry  = SwitchStartEntry;
  switches.parse_field  = SwitchParseField;
  switches.finish_entry = SwitchFinishEntry;
  switches.clear_all    = SwitchClearAll;

  DDF_MainReadFile(&amp;switches);

#if (DEBUG_DDF)
  L_WriteDebug("DDF_ReadSW: Switch List:\n");

  for (i = 0; i &lt; num_alph_switches; i++)
  {
    L_WriteDebug("  Num: %d  ON: '%s'  OFF: '%s'\n",
        i, alph_switches[i]-&gt;name1, alph_switches[i]-&gt;name2);
  }
#endif
}
</t>
<t tx="T2499">
void DDF_SWInit(void)
{
  Z_InitStackArray(&amp;alph_switches_a, (void ***)&amp;alph_switches,
      sizeof(switchlist_t), 0);
}
</t>
<t tx="T2500">
void DDF_SWCleanUp(void)
{
  // nothing to do
}
</t>
<t tx="T2501">@language c

@ I created this file to give an overview of the edge project.
This file is based on the Edge127 sources.

It is amazing that that Doom &amp; Quake are Open Source, and that they have spawned the Machinema movement.</t>
<t tx="T2502">//  Copyright (c) 1999-2000  The EDGE Team.
// 
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.

//  Based on the DOOM source code, released by Id Software under the
//  following copyright:
//
//    Copyright (C) 1993-1996 by id Software, Inc.</t>
<t tx="T2509"></t>
<t tx="T2510"></t>
<t tx="T2511">// See the file "docs/save_sys.txt" for a complete description of the
// new savegame system.</t>
<t tx="T2512"></t>
<t tx="T2513"></t>
<t tx="T2514"></t>
<t tx="T2515"></t>
<t tx="T2516"></t>
<t tx="T2517"></t>
<t tx="T2518"></t>
<t tx="T2519"></t>
<t tx="T2520"></t>
<t tx="T2521"></t>
<t tx="T2522"></t>
<t tx="T2523"></t>
<t tx="T2524"></t>
<t tx="T2525"></t>
<t tx="T2526"></t>
<t tx="T2527"></t>
<t tx="T2528">import leoImport
leoImport.importFiles("c:/prog/edge127", ".h")
</t>
<t tx="T2529">@ignore

//  EDGE Automap Functions

#ifndef __AMMAP_H__
#define __AMMAP_H__

#include "dm_defs.h"
#include "e_event.h"

//
// Automap drawing structs
//
typedef struct
{
  float_t x, y;
}
mpoint_t;

typedef struct
{
  mpoint_t a, b;
}
mline_t;

void AM_InitResolution(void);

// Called by main loop.
boolean_t AM_Responder(event_t * ev);

// Called by main loop.
void AM_Ticker(void);

// Called by main loop,
// called instead of view drawer if automap active.
void AM_Drawer(void);

// Called to force the automap to quit
// if the level is completed while it is up.
void AM_Stop(void);

#endif
</t>
<t tx="T2530">@ignore

// Console Variable Code

#ifndef __CON_CVAR__
#define __CON_CVAR__

typedef struct cvartype_s cvartype_t;
typedef struct cvar_s cvar_t;
typedef struct function_s function_t;
typedef struct funclist_s funclist_t;

// Console variables (cvars)
typedef enum
{
  // Readable
  cf_read = 1,
  // Writable.  Player properties are not writable!
  cf_write = 2,
  // Normal: cf_read|cf_write
  cf_normal = 3,
  // cvar is in z_memory.  If it is deleted, it will be Z_Freed
  // this is handled individually by each type
  cf_mem = 4,
  // Delete: cvar can be deleted.
  cf_delete = 8
}
cflag_t;

extern cvartype_t cvar_bool;
extern cvartype_t cvar_int;
extern cvartype_t cvar_real;
extern cvartype_t cvar_str;
extern cvartype_t cvar_enum;

void CON_AddFunctionToList(funclist_t * fl, const char *name, const char *description, void (*func) (void), void (*onchange) (funclist_t *));
void CON_InitFunctionList(funclist_t * fl, const char *cvarname, void (*default_func) (void), void (*onchange) (funclist_t *));
void CON_SetFunclistDest(funclist_t * fl, void (**dest) (void));

// Sets an existing cvar (if writable)
boolean_t CON_SetCVar(const char *name, const char *value);

// Gets an existing cvar value (if readable) pass the address of a
// pointer to the data you want, eg int *p; CON_GetCVar("health", &amp;p);
// Must be done this way because using a void
boolean_t CON_GetCVar(const char *name, const void **value);

// more low-level version of GetCVar.
// Usable in callbacks and similar, when it's simpler.
// Never use this if the cvar is referenced by name, since this doesn't do
// any read-only test.
const void *CON_CVarGetValue(const cvar_t * var);

// Creates a new value.
boolean_t CON_CreateCVar(const char *name, cflag_t flags, const cvartype_t * type, void *value);

// Deletes a cvar.
boolean_t CON_DeleteCVar(const char *name);

// Some special create routines for common types.
// The value pointer points to the variable that is changed whenever the
// cvar is changed. If NULL is passed, a new value will be created internally
boolean_t CON_CreateCVarInt(const char *name, cflag_t flags, int *value);
boolean_t CON_CreateCVarStr(const char *name, cflag_t flags, char *value, int maxlen);
boolean_t CON_CreateCVarBool(const char *name, cflag_t flags, boolean_t * value);
boolean_t CON_CreateCVarReal(const char *name, cflag_t flags, float_t * value);
boolean_t CON_CreateCVarEnum(const char *name, cflag_t flags, void *value, const char *names, int num);

// Adds a callback hook, which will be called whenever the value is changed.
// The callback will get the cvar as parameter. Normally, it should only
// read from var-&gt;value.
void CON_AddCVarCallback(cvar_t * var, void (*callback) (cvar_t * var, void *user), void *user, void (*kill_user) (void *));

void CON_ChooseFunctionFromList(funclist_t *fl, const char *funcname);

#endif // __CON_CVAR__
</t>
<t tx="T2531">@ignore

// Console Definitions

// Contains definitions that most cvar users shouldn't need to
// care about.

#ifndef __CON_LOCL_H__
#define __CON_LOCL_H__

#include "con_cvar.h"
#include "con_main.h"

struct cvar_s
{
  char *name;
  cflag_t flags;
  const cvartype_t *type;
  void *value;
};

struct cvartype_s
{
  // returns what the type is called, eg "int" or "string" or "boolean"
  const char *(*get_name) (cvar_t * cvar);

  // Converts the value to a string and stores it in s.
  void (*get_value_str) (void *val, char s[1024]);

  // sets *dest to the address of the actual value (the one passed to CreateCVar)
  void (*get_value) (const void *val, const void **dest);

  // Sets the cvar's value according to a parameter list.
  // The parameter list always contains at least one argument.
  // Also use this as callback: it is called whenever the cvar changes.
  boolean_t (*set_value) (cvar_t * cvar, int argc, const char **argv);

  // Called when the cvar is destroyed. Should free the memory of the
  // cvar's value member.
  void (*kill_value) (cvar_t * cvar);
};

struct function_s
{
  // The Function
  void (*func) (void);
  // Called when the function is activated.
  void (*onchange) (funclist_t *);
  // the name of the function. One word.
  char *name;
  // a brief description of the function. Can be displayed as a help message
  char *description;
};

struct funclist_s
{
  // the available functions.
  function_t **funcs;
  int num;
  int current;
  // optionally points to a pointer, that will be changed to the active
  // function whenever it changes.
  void (**dest)(void);
  // optional console variable.
  cvar_t *cvar;
  // for internal use (enum cvar stuff)
  void *donttouch;
};

extern cvar_t **cvars;
extern int num_cvars;

cvar_t *CON_CVarPtrFromName(const char *name);

#endif // __CON_LOCL_H__
</t>
<t tx="T2532">@ignore

// Console Main

#include "dm_type.h"

#ifdef __GUI_GUI_H__
#ifndef CON_MAIN_GUI_H
// console stuff that needs gui stuff. Included if you include gui_gui.h.
#define CON_MAIN_GUI_H
// The console 'application' functions.
// Adds the console to the gui.
void CON_Start(gui_t ** gui);

// Ticker.  Animates the opening/closing effect of the console
void CON_Ticker(gui_t * gui);

// Responder obeys events.
boolean_t CON_Responder(gui_t * gui, guievent_t * event);

// Drawer. Draws the console.
void CON_Drawer(gui_t * gui);

// Re-inits the console after a resolution change.
void CON_InitResolution(void);

// Inits the console for the given dimensions.
void CON_InitConsole(int width, int height, int gfxmode);

#endif
#endif

#ifndef CON_MAIN_H
#define CON_MAIN_H

void CON_TryCommand(const char *cmd);

// Prints messages.  cf printf.
void CON_Printf(const char *message,...) GCCATTR(format(printf, 1, 2));

// Like CON_Printf, but appends an extra '\n'. Should be used for player
// messages that need more than MessageLDF.

void CON_Message(const char *message,...) GCCATTR(format(printf, 1, 2));

// Looks up the string in LDF, appends an extra '\n', and then writes it to
// the console. Should be used for most player messages.
void CON_MessageLDF(const char *message,...);

// -ACB- 1999/09/22
// Introduced because MSVC and DJGPP handle #defines differently
void CON_PlayerMessage(player_t *plyr, const char *message, ...) GCCATTR(format(printf, 2, 3));
// Looks up in LDF.
void CON_PlayerMessageLDF(player_t *plyr, const char *message, ...);

typedef enum
{
  // invisible
  vs_notvisible,
  // fullscreen + a command line
  vs_maximal,
  NUMVIS
}
visible_t;

// Displays/Hides the console.
void CON_SetVisible(visible_t v);

#endif
</t>
<t tx="T2533">@ignore

// Data Definition File Code (Local Header)

#ifndef __DDF_LOCAL__
#define __DDF_LOCAL__

#include "p_weapon.h"
#include "dm_defs.h"

#define DDFVERSION 120

// defines for parser stuff.
#define BACKSLASH   '\\'
#define COMMANDREAD '='
#define DEFSTART    '['
#define DEFSTOP     ']'
#define TAGSTART    '&lt;'
#define TAGSTOP     '&gt;'
#define DIVIDE      ':'
#define REDIRECTOR  '#'
#define REMARKSTART '{'
#define REMARKSTOP  '}'
#define GROUPSTART  '('
#define GROUPSTOP   ')'
#define SEPARATOR   ','
#define SPACE       ' '
#define STRINGSTART '\"'
#define STRINGSTOP  '\"'
#define SUBSPACE    '_'
#define TERMINATOR  ';'

#define BUFFERSIZE 1024
#define NUMSPLIT 10  // Max Number of sections a state is split info

// enum thats gives the parser's current status
typedef enum
{
  waiting_tag,
  reading_tag,
  waiting_newdef,
  reading_newdef,
  reading_command,
  reading_data,
  reading_remark,
  reading_string
}
readstatus_t;

// enum thats describes the return value from DDF_MainProcessChar
typedef enum
{
  nothing,
  command_read,
  property_read,
  def_start,
  def_stop,
  remark_start,
  remark_stop,
  separator,
  string_start,
  string_stop,
  group_start,
  group_stop,
  tag_start,
  tag_stop,
  terminator,
  ok_char
}
readchar_t;

//
// This structure forms the basis for the command checking, it hands back a code
// pointer and sometimes a pointer to a (int) numeric value. (used for info that gets
// its value directly from the file).
//
typedef struct commandlist_s
{
  // command name
  const char *name;

  // parse function.  `storage' is where the data should go (for
  // routines that don't modify the buffer_xxxx structure directly).
  //
  void (* parse_command)(const char *info, void *storage);

  void *storage;  // FIXME: should be `int offset'

  const struct commandlist_s *sub_comms;
}
commandlist_t;

// -ACB- 2000/08/15 - FIELD_OFFSET is defined in Win32 headers
#define FIELD_OFF(dummy,field)  \
    ((char *) &amp; ((dummy).field) - (char *) &amp; (dummy))

#define FIELD_OFF2P(dummy,field)  \
    ((char *) FIELD_OFF(dummy,field))

#define FIELD_P2OFF(ptr)  ((int) ptr)

// NOTE: requires DDF_CMD_BASE to be defined as the dummy struct

#define DDF_CMD(name,field,parser)  \
    { /* ((char *)&amp; (DDF_CMD_BASE . field)) - ((char *)&amp; DDF_CMD_BASE), */  \
      name, parser, &amp;DDF_CMD_BASE.field, NULL }

#define DDF_CMD_SUB(name,field,parser)  \
    { name, parser, FIELD_OFF2P(DDF_CMD_BASE,field), NULL }
 
#define DDF_SUB_LIST(name,field,subcomms)  \
    { "*" name, NULL, &amp;DDF_CMD_BASE.field, subcomms }

#define DDF_CMD_END  { NULL, NULL, NULL, NULL }


//
// This structure passes the information needed to DDF_MainReadFile, so that
// the reader uses the correct procedures when reading a file.
//
typedef struct readinfo_s
{
  char *message;   // message displayed
  char *filename;  // filename (when memfile == NULL)
  char *lumpname;  // lumpnume (when memfile != NULL)

  char *tag;    // the file has to start with &lt;tag&gt;

  char *memfile;
  size_t memsize;

  // number of entries per displayed `.'
  int entries_per_dot;
  
  // NOTES
  // -----
  // There are two entries: the "dynamic" entry and the "static"
  // entry.  The dynamic entry will be the final entry within the
  // associated list.  We keep a pointer to it.  The static entry has
  // the name "buffer_xxxxx" in the associated ddf_xxx.c file, and
  // holds the parsed info until the entry is complete, at which time
  // the static part is copied into the dynamic part.

  //
  //  FUNCTIONS
  //

  // create a new dynamic entry with the given name.  For number-only
  // ddf files (lines, sectors and playlist), it is a number.  For
  // things.ddf, it is a name with an optional ":####" number
  // appended.  For everything else it is just a normal name.
  //
  // this also instantiates the static entry's information (excluding
  // name and/or number) using the built-in defaults.
  //
  // if an entry with the given name/number already exists, re-use
  // that entry for the dynamic part, otherwise create a new dynamic
  // entry and add it to the list.  Note that only the name and/or
  // number need to be kept valid in the dynamic entry.  Returns true
  // if the name already existed, otherwise false.
  //
  // Note: for things.ddf, only the name is significant when checking
  // if the entry already exists.
  //
  boolean_t (* start_entry)(const char *name);

  // parse a single field for the entry.  Usually it will just call
  // the ddf_main routine to handle the command list.  For
  // comma-separated fields (specials, states, etc), this routine will
  // be called multiple times, once for each element, and `index' is
  // used to indicate which element (starting at 0).
  //
  void (* parse_field)(const char *field, const char *contents,
      int index, boolean_t is_last);

  // when the entry has finished, this routine can perform any
  // necessary operations here (such as updating a number -&gt; entry
  // lookup table).  In particular, it should copy the static buffer
  // part into the dynamic part.  It also should compute the CRC.
  //
  void (* finish_entry)(void);

  // this function is called when the #CLEARALL directive is used.
  // The entries should be deleted if it is safe (i.e. there are no
  // pointers to them), otherwise they should be marked `disabled' and
  // ignored in subsequent searches.  Note: The parser ensures that
  // this is never called in the middle of an entry.
  //
  void (* clear_all)(void);
}
readinfo_t;

//
// This structure forms the basis for referencing specials.
//
typedef struct
{
  // name of special
  char *name;

  // flag(s) or value of special
  int flags;

  // this is true if the DDF name (e.g. "GRAVITY") is opposite to the
  // code's flag name (e.g. MF_NoGravity).
  boolean_t negative; 
}
specflags_t;

typedef enum
{
  // special flag is unknown
  CHKF_Unknown,

  // the flag should be set (i.e. forced on)
  CHKF_Positive,

  // the flag should be cleared (i.e. forced off)
  CHKF_Negative,

  // the flag should be made user-definable
  CHKF_User
}
checkflag_result_e;

//
// This is a reference table, that determines what code pointer is placed in the
// states table entry.
//
typedef struct
{
  char *actionname;
  void (* action)(mobj_t * object);

  // -AJA- 1999/08/09: This function handles the argument when brackets
  // are present (e.g. "WEAPON_SHOOT(FIREBALL)").  NULL if unused.
  void (*handle_arg)(const char *arg, state_t * curstate);
}
actioncode_t;

// This structure is used for parsing states
typedef struct
{
  // state label
  const char *label;

  // redirection label for last state
  const char *last_redir;

  // pointer to state_num storage
  int *state_num;
}
state_starter_t;

// DDF_MAIN Code (Reading all files, main init &amp; generic functions).
void DDF_MainReadFile(readinfo_t * readinfo);

void DDF_Error(const char *err, ...);
void DDF_Warning(const char *err, ...);
void DDF_WarnError(const char *err, ...);
void DDF_ErrorSetEntryName(const char *err, ...);
void DDF_ErrorClearEntryName(void);

void DDF_MainGetPercent(const char *info, void *storage);
void DDF_MainGetPercentAny(const char *info, void *storage);
void DDF_MainGetBoolean(const char *info, void *storage);
void DDF_MainGetFloat(const char *info, void *storage);
void DDF_MainGetAngle(const char *info, void *storage);
void DDF_MainGetSlope(const char *info, void *storage);
void DDF_MainGetInlineStr10(const char *info, void *storage);
void DDF_MainGetInlineStr32(const char *info, void *storage);
void DDF_MainGetNumeric(const char *info, void *storage);
void DDF_MainGetString(const char *info, void *storage);
void DDF_MainGetTime(const char *info, void *storage);
void DDF_MainGetColourmap(const char *info, void *storage);
void DDF_MainGetRGB(const char *info, void *storage);
void DDF_MainGetWhenAppear(const char *info, void *storage);
void DDF_MainGetBitSet(const char *info, void *storage);

boolean_t DDF_MainParseField(const commandlist_t *commands,
    const char *field, const char *contents);
void DDF_MainLookupSound(const char *info, void *storage);
void DDF_MainRefAttack(const char *info, void *storage);

void DDF_DummyFunction(const char *info, void *storage);

checkflag_result_e DDF_MainCheckSpecialFlag(const char *name,
  const specflags_t *flag_set, int *flag_value, 
  boolean_t allow_prefixes, boolean_t allow_user);

char *DDF_MainCreateUniqueName(const char *prefix, int num);
int DDF_MainLookupDirector(const mobjinfo_t *obj, const char *info);

// DDF_ANIM Code
void DDF_AnimInit(void);
void DDF_AnimCleanUp(void);

// DDF_ATK Code
void DDF_AttackInit(void);
void DDF_AttackCleanUp(void);
attacktype_t *DDF_AttackLookup(const char *name);

// DDF_GAME Code
void DDF_GameInit(void);
void DDF_GameCleanUp(void);

// DDF_LANG Code
void DDF_LanguageInit(void);
void DDF_LanguageCleanUp(void);

// DDF_LEVL Code
void DDF_LevelInit(void);
void DDF_LevelCleanUp(void);

// DDF_LINE Code
void DDF_LinedefInit(void);
void DDF_LinedefCleanUp(void);

#define EMPTY_COLMAP_NAME  "_NONE_"
#define EMPTY_COLMAP_NUM   -777

// DDF_MOBJ Code  (Moving Objects)
void DDF_MobjInit(void);
void DDF_MobjCleanUp(void);
void DDF_MobjGetSpecial(const char *info, void *storage);
void DDF_MobjGetExtra(const char *info, void *storage);
void DDF_MobjGetItemType(const char *info, void *storage);
void DDF_MobjGetBpAmmo(const char *info, void *storage);
void DDF_MobjGetBpAmmoLimit(const char *info, void *storage);
void DDF_MobjGetBpArmour(const char *info, void *storage);
void DDF_MobjGetBpKeys(const char *info, void *storage);
void DDF_MobjGetBpWeapon(const char *info, void *storage);
void DDF_MobjGetPlayer(const char *info, void *storage);
mobjinfo_t *DDF_MobjMakeAttackObj(mobjinfo_t *info, const char *atk_name);

void ThingParseField(const char *field, const char *contents,
    int index, boolean_t is_last);

// DDF_MUS Code
void DDF_MusicPlaylistInit(void);
void DDF_MusicPlaylistCleanUp(void);

// DDF_STAT Code
void DDF_StateInit(void);
void DDF_StateGetAttack(const char *arg, state_t * cur_state);
void DDF_StateGetMobj(const char *arg, state_t * cur_state);
void DDF_StateGetSound(const char *arg, state_t * cur_state);
void DDF_StateGetInteger(const char *arg, state_t * cur_state);
void DDF_StateGetIntPair(const char *arg, state_t * cur_state);
void DDF_StateGetFloat(const char *arg, state_t * cur_state);
void DDF_StateGetPercent(const char *arg, state_t * cur_state);
void DDF_StateGetJump(const char *arg, state_t * cur_state);
void DDF_StateGetAngle(const char *arg, state_t * cur_state);
void DDF_StateGetSlope(const char *arg, state_t * cur_state);

void DDF_StateReadState(const char *info, const char *label,
    int *first, int *last, int *state_num, int index, 
    const char *redir, const actioncode_t *action_list);
void DDF_StateFinishStates(int first, int last);
void DDF_StateFixupStates(int first, int last);
void DDF_StateCleanUp(void);
int StateFindLabel(int first, int last, const char *label);

// DDF_SECT Code
void DDF_SectorInit(void);
void DDF_SectGetDestRef(const char *info, void *storage);
void DDF_SectGetExit(const char *info, void *storage);
void DDF_SectGetLighttype(const char *info, void *storage);
void DDF_SectGetMType(const char *info, void *storage);
void DDF_SectorCleanUp(void);

// DDF_SFX Code
void DDF_SFXInit(void);
void DDF_SFXCleanUp(void);

// DDF_SWTH Code
// -KM- 1998/07/31 Switch and Anim ddfs.
void DDF_SWInit(void);
void DDF_SWCleanUp(void);

// DDF_WEAP Code
void DDF_WeaponInit(void);
void DDF_WeaponCleanUp(void);
extern const specflags_t ammo_types[];

// DDF_COLM Code -AJA- 1999/07/09.
void DDF_ColmapInit(void);
void DDF_ColmapCleanUp(void);

// DDF_BOOM Code
void DDF_BoomMakeGenSector(specialsector_t *sec, int number);
void DDF_BoomMakeGenLine(linedeftype_t *line, int number);

// Miscellaneous stuff needed here &amp; there
extern mobjinfo_t buffer_mobj;
extern const mobjinfo_t template_mobj;
extern const commandlist_t elevator_commands[];
extern const commandlist_t floor_commands[];
extern const commandlist_t thing_commands[];
extern const commandlist_t damage_commands[];

#endif // __DDF_LOCAL__</t>
<t tx="T2534">@ignore

// Data Definition File Code (Main)

#ifndef __DDF_MAIN__
#define __DDF_MAIN__

#include "dm_defs.h"
#include "e_think.h"
#include "m_fixed.h"


#define DEBUG_DDF  0

struct image_s;


typedef struct ddf_base_s
{
  // name of this DDF entry.  For non-numbered ddf entries (lines,
  // sectors and playlists) this can be NULL, otherwise it must be
  // valid.
  char *name;

  // number of this DDF entry.  Zero means "not numbered".
  // Negative values not allowed (covert them to zero).
  int number;

  // CRC of the important parts of this DDF entry, i.e. anything that
  // has a significant effect on gameplay.  Doesn't include the entry
  // name or number.
  unsigned long crc;
}
ddf_base_t;

#define DDF_BASE_NIL  { "", 0, 0 }


// percentage type.  Ranges from 0.0 - 1.0
typedef float_t percent_t;

#define PERCENT_MAKE(val)  ((val) / 100.0)
#define PERCENT_2_FLOAT(perc)  (perc)


//-------------------------------------------------------------------------
//-----------------------  THING STATE STUFF   ----------------------------
//-------------------------------------------------------------------------

#define S_NULL 0

typedef int statenum_t;
typedef int spritenum_t;

struct mobj_s;

// State Struct
typedef struct
{
  // sprite ref
  int sprite;

  // frame ref
  short frame;
 
  // brightness
  short bright;
 
  // duration in tics
  long tics;

  // label for state, or NULL
  const char *label;

  // routine to be performed
  void (* action)(struct mobj_s * object);

  // parameter for routine, or NULL
  void *action_par;

  // next state ref.  S_NULL means "remove me".
  int nextstate;

  // jump state ref.  S_NULL means remove.
  int jumpstate;
}
state_t;

// ------------------------------------------------------------------
// -------------------------------SFX--------------------------------
// ------------------------------------------------------------------

// -KM- 1998/10/29
typedef struct
{
  int num;
  int sounds[1]; // -ACB- 1999/11/06 Zero based array is not ANSI compliant
                 // -AJA- I'm also relying on the [1] within sfxinfo_t.
}
sfx_t;

// Bastard SFX are sounds that are hardcoded into the
// code.  They should be removed if at all possible

typedef struct
{
  sfx_t *s;
  char name[8];
}
bastard_sfx_t;

extern bastard_sfx_t bastard_sfx[];

#define sfx_swtchn bastard_sfx[0].s
#define sfx_tink bastard_sfx[1].s
#define sfx_radio bastard_sfx[2].s
#define sfx_oof bastard_sfx[3].s
#define sfx_pstop bastard_sfx[4].s
#define sfx_stnmov bastard_sfx[5].s
#define sfx_pistol bastard_sfx[6].s
#define sfx_swtchx bastard_sfx[7].s
#define sfx_jpmove bastard_sfx[8].s
#define sfx_jpidle bastard_sfx[9].s
#define sfx_jprise bastard_sfx[10].s
#define sfx_jpdown bastard_sfx[11].s
#define sfx_jpflow bastard_sfx[12].s

#define sfx_None (sfx_t*) NULL

// ------------------------------------------------------------------
// ------------------- COLOURMAP &amp; PALETTE STUFF --------------------
// ------------------------------------------------------------------

// -AJA- 1999/07/09: colmap.ddf structures.

// RGB 8:8:8
typedef unsigned int rgbcol_t;

typedef enum
{
  // don't apply gun-flash type effects (looks silly for fog)
  COLSP_NoFlash  = 0x0001
}
colourspecial_e;

typedef struct colmapcache_s
{
  // the pointer returned by Z_New.
  char *baseptr;

  // the actual pointer. This one is aligned.
  void *data;

  int validcount;
  int bpp;
  
  // colour for GL renderer
  rgbcol_t gl_colour;
}
colmapcache_t;

typedef struct colourmap_s
{
  ddf_base_t ddf;

  char lump_name[10];

  int start;
  int length;

  colourspecial_e special;

  colmapcache_t cache;
}
colourmap_t;

// ------------------------------------------------------------------
// ------------------------BENEFIT TYPES-----------------------------
// ------------------------------------------------------------------

typedef enum
{
  BENEFIT_None = 0,
  BENEFIT_Ammo,
  BENEFIT_AmmoLimit,
  BENEFIT_Weapon,
  BENEFIT_Key,
  BENEFIT_Health,
  BENEFIT_Armour,
  BENEFIT_Powerup
}
benefit_type_e;

// Ammunition types defined.
typedef enum
{
  // Only used for P_SelectNewWeapon()
  AM_DontCare = -2,
  
  // Unlimited for chainsaw / fist.
  AM_NoAmmo = -1,
  
  // Pistol / chaingun ammo.
  AM_Bullet,
  
  // Shotgun / double barreled shotgun.
  AM_Shell,
  
  // Missile launcher.
  AM_Rocket,

  // Plasma rifle, BFG.
  AM_Cell,

  // New ammo types
  AM_Pellet,
  AM_Nail,
  AM_Grenade,
  AM_Gas,

  // -AJA- Note: Savegame code relies on NUMAMMO == 8.
  NUMAMMO
}
ammotype_t;

typedef enum
{
  // weakest armour, saves 33% of damage
  ARMOUR_Green = 0,

  // better armour, saves 50% of damage
  ARMOUR_Blue,

  // good armour, saves 75% of damage.  (not in Doom)
  ARMOUR_Yellow,

  // the best armour, saves 90% of damage.  (not in Doom)
  ARMOUR_Red,
  
  // -AJA- Note: Savegame code relies on NUMARMOUR == 4.
  NUMARMOUR
}
armour_type_e;

typedef short armour_set_t;  // one bit per armour

// Power up artifacts.
//
// -MH- 1998/06/17  Jet Pack Added
// -ACB- 1998/07/15 NightVision Added

typedef enum
{
  PW_Invulnerable = 0,
  PW_Berserk,
  PW_PartInvis,
  PW_AcidSuit,
  PW_AllMap,
  PW_Infrared,

  // extra powerups (not in Doom)
  PW_Jetpack,
  PW_NightVision,
  PW_Scuba,

  PW_Unused9,
  PW_Unused10,
  PW_Unused11,

  PW_Unused12,
  PW_Unused13,
  PW_Unused14,
  PW_Unused15,

  // -AJA- Note: Savegame code relies on NUMPOWERS == 16.
  NUMPOWERS
}
power_type_e;

// -AJA- 2000/02/27: added this new structure 
typedef struct benefit_s
{
  // next in linked list
  struct benefit_s *next;

  // type of benefit (ammo, ammo-limit, weapon, key, health, armour,
  // or powerup).
  benefit_type_e type;
  
  // sub-type (specific type of ammo, weapon, key or powerup).  For
  // armour this is the class, for health it is unused.
  int subtype;

  // amount of benefit (e.g. quantity of ammo or health).  For weapons
  // and keys, this is a boolean value: 1 to give, 0 to ignore.  For
  // powerups, it is number of seconds the powerup lasts.
  float_t amount;

  // for health, armour and powerups, don't make the new value go
  // higher than this (if it is already higher, prefer not to pickup
  // the object).
  float_t limit;
}
benefit_t;

// -AJA- 2000/07/23: added this structure
typedef struct condition_check_s
{
  // next in linked list (order is unimportant)
  struct condition_check_s *next;

  // negate the condition
  boolean_t negate;

  enum
  {
    // dummy condition, used if parsing failed
    COND_NONE = 0,
      
    // object must have health
    COND_Health,

    // player must have armour (subtype is ARMOUR_* value)
    COND_Armour,

    // player must have a key (subtype is KF_* value).
    COND_Key,

    // player must have a weapon (subtype is slot number).
    COND_Weapon,

    // player must have a powerup (subtype is PW_* value).
    COND_Powerup,

    // player must have ammo (subtype is AM_* value)
    COND_Ammo,

    // player must be jumping
    COND_Jumping,

    // player must be crouching
    COND_Crouching,

    // object must be swimming (i.e. in water)
    COND_Swimming,

    // player must be attacking (holding fire down)
    COND_Attacking,

    // player must be rampaging (holding fire a long time)
    COND_Rampaging,

    // player must be using (holding space down)
    COND_Using
  }
  cond_type;

  // sub-type (specific type of ammo, weapon, key, powerup).  Not used
  // for health, jumping, crouching, etc.
  int subtype;

  // required amount of health, armour or ammo,   Not used for
  // weapon, key, powerup, jumping, crouching, etc.
  float_t amount;
}
condition_check_t;

// ------------------------------------------------------------------
// --------------------MOVING OBJECT INFORMATION---------------------
// ------------------------------------------------------------------

// improved damage support
typedef struct damage_s
{
  // nominal damage amount (required)
  float_t nominal;

  // used for DAMAGE.MAX: when this is &gt; 0, the damage is random
  // between nominal and linear_max, where each value has equal
  // probability.
  float_t linear_max;
  
  // used for DAMAGE.ERROR: when this is &gt; 0, the damage is the
  // nominal value +/- this error amount, with a bell-shaped
  // distribution (values near the nominal are much more likely than
  // values at the outer extreme).
  float_t error;

  // delay (in terms of tics) between damage application, e.g. 34
  // would be once every second.  Only used for slime/crush damage.
  int delay;

  // override labels for various states, if the object being damaged
  // has such a state then it is used instead of the normal ones
  // (PAIN, DEATH, OVERKILL).  Defaults to NULL.
  struct label_offset_s
  {
    const char *label;
    int offset;
  }
  pain, death, overkill;

  // this flag says that the damage is unaffected by the player's
  // armour -- and vice versa.
  boolean_t no_armour;
}
damage_t;

#define NULL_LABEL  { NULL, 0 }

#define DAMAGE_COMPUTE(var,dam)  \
    do {  \
      (var) = (dam)-&gt;nominal;  \
      \
      if ((dam)-&gt;error &gt; 0)  \
        (var) += (dam)-&gt;error * P_RandomNegPos() / 255.0;  \
      else if ((dam)-&gt;linear_max &gt; 0)  \
        (var) += ((dam)-&gt;linear_max - (var)) * P_Random() / 255.0;  \
      \
      if ((var) &lt; 0) (var) = 0;  \
    } while (0)

// a bitset is a set of named bits, from `A' to `Z'.
typedef int bitset_t;

#define BITSET_EMPTY  0
#define BITSET_FULL   0x7FFFFFFF
#define BITSET_MAKE(ch)  (1 &lt;&lt; ((ch) - 'A'))

typedef enum
{
  // dynamic lighting disabled
  DLITE_None,

  // lighting is constant (regardless of distance)
  DLITE_Constant,

  // lighting is proportional to 1 / distance
  DLITE_Linear,

  // lighting is proportional to 1 / (distance^2)
  DLITE_Quadratic
}
dlight_type_e;

// -KM- 1998/10/29 sfx_t SFXs
// -KM- 1998/11/25 Added weapons, changed invisibility + accuracy.
typedef struct mobjinfo_s
{
  ddf_base_t ddf;

  // range of states used
  int first_state;
  int last_state;
  
  int spawn_state;
  int idle_state;
  int chase_state;
  int pain_state;
  int missile_state;
  int melee_state;
  int death_state;
  int overkill_state;
  int raise_state;
  int res_state;
  int meander_state;
  int bounce_state;
  int touch_state;
  int jump_state;
  int gib_state;

  int reactiontime;
  percent_t painchance;
  float_t spawnhealth;
  float_t speed;
  float_t float_speed;
  float_t radius;
  float_t height;
  float_t step_size;
  float_t mass;

  int flags;
  int extendedflags;
  damage_t damage;

  // linked list of losing benefits, or NULL
  benefit_t *lose_benefits;
  
  // linked list of pickup benefits, or NULL
  benefit_t *pickup_benefits;

  // pickup message, a reference to languages.ldf
  char *pickup_message;

  // linked list of initial benefits for players, or NULL if none
  benefit_t *initial_benefits;

  int castorder;
  int respawntime;
  percent_t translucency;
  percent_t minatkchance;
  const colourmap_t *palremap;

  int jump_delay;
  float_t jumpheight;
  float_t crouchheight;
  percent_t viewheight;
  percent_t shotheight;
  float_t maxfall;
  float_t fast;
  float_t xscale;
  float_t yscale;
  float_t bounce_speed;
  float_t bounce_up;
  float_t sight_slope;
  angle_t sight_angle;
  float_t ride_friction;
  percent_t shadow_trans;

  sfx_t *seesound;
  sfx_t *attacksound;
  sfx_t *painsound;
  sfx_t *deathsound;
  sfx_t *overkill_sound;
  sfx_t *activesound;
  sfx_t *walksound;
  sfx_t *jump_sound;
  sfx_t *noway_sound;
  sfx_t *oof_sound;
  sfx_t *gasp_sound;

  int fuse;
  bitset_t side;
  int playernum;

  // breathing support: lung_capacity is how many tics we can last
  // underwater.  gasp_start is how long underwater before we gasp
  // when leaving it.  Damage and choking interval is in choke_damage.
  int lung_capacity;
  int gasp_start;
  damage_t choke_damage;

  // controls how much the player bobs when walking.
  percent_t bobbing;

  // what attack classes we are immune to (usually none).
  bitset_t immunity;

  const struct attacktype_s *closecombat;
  const struct attacktype_s *rangeattack;
  const struct attacktype_s *spareattack;

  // halo information (height &lt; 0 disables halo)
  struct haloinfo_s
  {
    float_t height;
    float_t size, minsize, maxsize;
    percent_t translucency;
    rgbcol_t colour;
    char graphic[10];
  }
  halo;

  // dynamic light info
  struct dlightinfo_s
  {
    dlight_type_e type;
    int intensity;
    rgbcol_t colour;
    percent_t height;
  }
  dlight;

  // item to drop (or NULL).  The mobjinfo pointer is only valid after
  // DDF_MobjCleanUp() has been called.
  const struct mobjinfo_s *dropitem;
  const char *dropitem_ref;

  // blood object (or NULL).  The mobjinfo pointer is only valid after
  // DDF_MobjCleanUp() has been called.
  const struct mobjinfo_s *blood;
  const char *blood_ref;
  
  // respawn effect object (or NULL).  The mobjinfo pointer is only
  // valid after DDF_MobjCleanUp() has been called.
  const struct mobjinfo_s *respawneffect;
  const char *respawneffect_ref;
  
  // spot type for the `SHOOT_TO_SPOT' attack (or NULL).  The mobjinfo
  // pointer is only valid after DDF_MobjCleanUp() has been called.
  const struct mobjinfo_s *spitspot;
  const char *spitspot_ref;
}
mobjinfo_t;

// ------------------------------------------------------------------
// --------------------ATTACK TYPE STRUCTURES------------------------
// ------------------------------------------------------------------

// -KM- 1998/11/25 Added BFG SPRAY attack type.
typedef enum
{
  ATK_PROJECTILE,
  ATK_SPAWNER,
  ATK_TRIPLESPAWNER,
  ATK_SPREADER,
  ATK_RANDOMSPREAD,
  ATK_SHOT,
  ATK_TRACKER,
  ATK_CLOSECOMBAT,
  ATK_SHOOTTOSPOT,
  ATK_SKULLFLY,
  ATK_SMARTPROJECTILE,
  ATK_SPRAY,
  NUMATKCLASS
}
attackstyle_e;

typedef enum
{
  AF_TraceSmoke      = 1,
  AF_KillFailedSpawn = 2,
  AF_PrestepSpawn    = 4,
  AF_SpawnTelefrags  = 8,
  AF_NeedSight       = 16,
  AF_FaceTarget      = 32,
  AF_Player          = 64,
  AF_ForceAim        = 128,
  AF_AngledSpawn     = 256,
  AF_NoTriggerLines  = 512
}
attackflags_e;

typedef struct attacktype_s
{
  ddf_base_t ddf;

  attackstyle_e attackstyle;
  attackflags_e flags;
  sfx_t *initsound;
  sfx_t *sound;
  float_t accuracy_slope;
  angle_t accuracy_angle;
  float_t xoffset;
  float_t yoffset;
  angle_t angle_offset;  // -AJA- 1999/09/10.
  float_t slope_offset;  //
  float_t assault_speed;
  float_t height;
  float_t range;
  int count;
  int tooclose;
  damage_t damage;

  // class of the attack.
  bitset_t attack_class;
 
  // object init state.  The integer value only becomes valid after
  // DDF_AttackCleanUp() has been called.
  int objinitstate;
  const char *objinitstate_ref;
  
  percent_t notracechance;
  percent_t keepfirechance;

  // the MOBJ that is integrated with this attack, or NULL
  const struct mobjinfo_s *atk_mobj;

  // spawned object (for spawners).  The mobjinfo pointer only becomes
  // valid after DDF_AttackCleanUp().  Can be NULL.
  const struct mobjinfo_s *spawnedobj;
  const char *spawnedobj_ref;
  
  // puff object.  The mobjinfo pointer only becomes valid after
  // DDF_AttackCleanUp() has been called.  Can be NULL.
  const struct mobjinfo_s *puff;
  const char *puff_ref;
}
attacktype_t;

// ------------------------------------------------------------------
// -----------------------WEAPON HANDLING----------------------------
// ------------------------------------------------------------------

// -AJA- 2000/01/12: Weapon special flags
typedef enum
{
  // monsters cannot hear this weapon (doesn't wake them up)
  WPSP_SilentToMonsters = 0x0001
}
weapon_flag_e;

// Weapon info: sprite frames, ammunition use.
typedef struct weaponinfo_s
{
  // Weapon's name, etc...
  ddf_base_t ddf;

  // Attack type used.
  struct attacktype_s *attack;
  
  // Type of ammo this weapon uses.
  ammotype_t ammo;
  
  // Ammo used per shot.
  int ammopershot;
  
  // Amount of shots in a clip
  int clip;
  
  // If true, this is an automatic weapon.  If false it is semiautomatic.
  boolean_t autofire;
  
  // Amount of kick this weapon gives
  float_t kick;
  
  // Second attack type.
  struct attacktype_s *sa_attack;
  
  // Type of ammo for second attack.
  ammotype_t sa_ammo;
  
  // Ammo used per second attack shot.
  int sa_ammopershot;

  // Amount of shots in a second attack clip
  int sa_clip;
  
  // Second attack is automatic ?
  boolean_t sa_autofire;
  
  // range of states used
  int first_state;
  int last_state;
  
  // State to use when raising the weapon
  int up_state;
  
  // State to use when lowering the weapon (if changing weapon)
  int down_state;
  
  // State that the weapon is ready to fire in.
  int ready_state;
  
  // State showing the weapon 'firing'
  int attack_state;
  
  // State showing the weapon being reloaded
  int reload_state;

  // State showing the muzzle flash
  int flash_state;
  
  // State showing the second attack firing
  int sa_attack_state;
  
  // State showing the second attack reloading
  int sa_reload_state;

  // State showing the second attack muzzle flash
  int sa_flash_state;
  
  // Crosshair states
  int crosshair;
  
  // State showing viewfinder when zoomed.  Can be zero
  int zoom_state;

  // The player gets this weapon on spawn.  (Fist + Pistol)
  boolean_t autogive;
  
  // This weapon gives feedback on hit (chainsaw)
  boolean_t feedback;
  
  // This weapon upgrades a previous one. (Berserk -&gt; Fist)
  int upgraded_weap;
 
  // This affects how it will be selected if out of ammo.  Also
  // determines the cycling order when on the same key.  Dangerous
  // weapons are not auto-selected when out of ammo.
  int priority;
  boolean_t dangerous;
 
  // Attack type for the WEAPON_EJECT code pointer.
  struct attacktype_s *eject_attack;
  
  // Sounds.
  // Played at the start of every readystate
  sfx_t *idle;
  
  // Played while the trigger is held (chainsaw)
  sfx_t *engaged;
  
  // Played while the trigger is held and it is pointed at a target.
  sfx_t *hit;
  
  // Played when the weapon is selected
  sfx_t *start;
  
  // Misc sounds
  sfx_t *sound1;
  sfx_t *sound2;
  sfx_t *sound3;
  
  // This close combat weapon should not push the target away (chainsaw)
  boolean_t nothrust;
  
  // which number key this weapon is bound to, or -1 for none
  int bind_key;
  
  // -AJA- 2000/01/12: weapon special flags
  weapon_flag_e special_flags;

  // -AJA- 2000/03/18: when &gt; 0, this weapon can zoom
  angle_t zoom_fov;

  // -AJA- 2000/05/23: weapon loses accuracy when refired.
  boolean_t refire_inacc;

  // -AJA- 2000/10/20: show current clip in status bar (not total)
  boolean_t show_clip;

  // controls for weapon bob (up &amp; down) and sway (left &amp; right).
  // Given as percentages in DDF.
  percent_t bobbing;
  percent_t swaying;
}
weaponinfo_t;

// -KM- 1998/11/25 Dynamic number of choices, 10 keys.
typedef struct
{
  int numchoices;
  weaponinfo_t ** choices;
}
weaponkey_t;

// ------------------------------------------------------------------
// --------------------------ANIMATIONS------------------------------
// ------------------------------------------------------------------

//
// source animation definition
//
// -KM- 98/07/31 Anims.ddf
//
typedef struct
{
  ddf_base_t ddf;

  // true for textures, false for flats
  boolean_t istexture;
  
  // first and last names in TEXTURE1/2 lump
  char endname[10];
  char startname[10];

  // how many 1/35s ticks each frame lasts
  int speed;
}
animdef_t;

//
// SWITCHES
//
#define BUTTONTIME  35

typedef struct switchcache_s
{
  const struct image_s *image[2];
}
switchcache_t;

typedef struct switchlist_s
{
  ddf_base_t ddf;

  char name1[10];
  char name2[10];

  // sound effects for this switch
  sfx_t *on_sfx;
  sfx_t *off_sfx;

  // how many ticks the button image lasts
  int time;

  switchcache_t cache;
}
switchlist_t;

// ------------------------------------------------------------------
// ---------------MAP STRUCTURES AND CONFIGURATION-------------------
// ------------------------------------------------------------------

// -KM- 1998/11/25 Added generalised Finale type.
typedef struct
{
  // Text
  char *text;
  char text_back[10];
  char text_flat[10];
  float_t text_speed;
  unsigned int text_wait;

  // Pic
  unsigned int numpics;
  unsigned int picwait;
  char *pics;

  // Cast
  boolean_t docast;

  // Bunny
  boolean_t dobunny;

  // Music
  int music;
}
finale_t;

typedef enum
{
   MPF_Jumping       = 0x1,
   MPF_Mlook         = 0x2,
   MPF_Translucency  = 0x4,
   MPF_Cheats        = 0x8,
   MPF_ItemRespawn   = 0x10,
   MPF_FastParm      = 0x20,     // Fast Monsters
   MPF_ResRespawn    = 0x40,     // Resurrect Monsters (else Teleport)
   MPF_StretchSky    = 0x80,
   MPF_True3D        = 0x100,    // True 3D Gameplay
   MPF_Stomp         = 0x200,    // Monsters can stomp players
   MPF_MoreBlood     = 0x400,    // Make a bloody mess
   MPF_Respawn       = 0x800,
   MPF_AutoAim       = 0x1000,
   MPF_AutoAimMlook  = 0x2000,
   MPF_ResetPlayer   = 0x4000,   // Force player back to square #1
   MPF_Extras        = 0x8000,
   MPF_LimitZoom     = 0x10000,  // Limit zoom to certain weapons
   MPF_Shadows       = 0x20000,
   MPF_Halos         = 0x40000,
   MPF_Crouching     = 0x80000,
   MPF_Kicking       = 0x100000, // Weapon recoil
   MPF_BoomCompat    = 0x200000
}
mapsettings_t;

typedef enum
{
  // standard Doom shading
  LMODEL_Doom = 0,

  // Doom shading without the brighter N/S, darker E/W walls
  LMODEL_Doomish = 1,

  // flat lighting (no shading at all)
  LMODEL_Flat = 2,

  // vertex lighting
  LMODEL_Vertex = 3
}
lighting_model_e;

typedef enum
{
  // standard Doom intermission stats
  WISTYLE_Doom = 0,

  // no stats at all
  WISTYLE_None = 1
}
intermission_style_e;

typedef struct mapstuff_s
{
  ddf_base_t ddf;

  // next in the list
  struct mapstuff_s *next;

  // level description, a reference to languages.ldf
  char *description;
  
  char namegraphic[10];
  char lump[10];
  char sky[10];
  char surround[10];
  int music;

  int partime;
  char *episode_name;

  // flags come in two flavours: "force on" and "force off".  When not
  // forced, then the user is allowed to control it (not applicable to
  // all the flags, e.g. RESET_PLAYER).
  mapsettings_t force_on;
  mapsettings_t force_off;

  // name of the next normal level
  char nextmapname[10];

  // name of the secret level
  char secretmapname[10];

  // -KM- 1998/11/25 All lines with this trigger will be activated at
  // the level start. (MAP07)
  int autotag;

  // -AJA- 2000/08/23: lighting model &amp; intermission style
  lighting_model_e lighting;
  intermission_style_e wistyle;

  // -KM- 1998/11/25 Generalised finales.
  finale_t f[2];
}
mapstuff_t;

// ------------------------------------------------------------------
// -------------------------INTERMISSIONS----------------------------
// ------------------------------------------------------------------

typedef enum
{
  WI_NORMAL,
  WI_LEVEL
}
animtype_t;

typedef struct
{
  int x;
  int y;
}
point_t;

typedef struct
{
  // Tics on this frame
  int tics;

  // Position on screen where this goes
  point_t pos;

  // Name of pic to display.
  char pic[10];

  // cached image
  const struct image_s *image;
}
wi_frame_t;

typedef struct wi_anim_s
{
  animtype_t type;
  char level[10];

  int numframes;
  wi_frame_t *frames;

  // Countdown number of tics
  int count;
  int frameon;
}
wi_anim_t;

typedef struct
{
  point_t pos;
  char name[10];
}
mappos_t;

typedef struct wi_map_s
{
  ddf_base_t ddf;

  wi_anim_t *anims;
  int numanims;

  mappos_t *mappos;
  boolean_t *mapdone;
  int nummaps;

  char background[10];
  char splatpic[10];
  char yah[2][10];

  // -AJA- 1999/10/22: background cameras.
  char bg_camera[32];

  int music;
  sfx_t *percent;
  sfx_t *done;
  sfx_t *endmap;
  sfx_t *nextmap;
  sfx_t *accel_snd;
  sfx_t *frag_snd;

  char firstmap[10];
  char namegraphic[10];
  char **titlepics;
  int numtitlepics;
  int titlemusic;
  int titletics;
}
wi_map_t;

// ------------------------------------------------------------------
// ---------------------------LANGUAGES------------------------------
// ------------------------------------------------------------------

typedef struct langref_s
{
  const char *refname;
  const char *string;

  struct langref_s *next;
}
langref_t;

// -AJA- 2000/04/16: new container, one for each language

typedef struct language_s
{
  ddf_base_t ddf;

  langref_t *refs;
}
language_t;


// ------------------------------------------------------------------
// ------------------------LINEDEF TYPES-----------------------------
// ------------------------------------------------------------------

// Triggers (What the line triggers)
typedef enum
{
  line_none,
  line_shootable,
  line_walkable,
  line_pushable,
  line_manual,   // same as pushable, but ignore any tag
  line_Any
}
trigger_e;

// Triggers (What object types can cause the line to be triggered)
typedef enum
{
  trig_player  = 1,
  trig_monster = 2,
  trig_other   = 4
}
trigacttype_e;

// Height Info Reference
typedef enum
{
  REF_Absolute = 0,  // Absolute from current position
  REF_Current,       // Measure from current sector height
  REF_Surrounding,   // Measure from surrounding heights
  REF_LowestLoTexture,

  // additive flags
  REF_MASK    = 0x00FF,
  REF_CEILING = 0x0100,   // otherwise floor
  REF_HIGHEST = 0x0200,   // otherwise lowest
  REF_NEXT    = 0x0400,   // otherwise absolute
  REF_INCLUDE = 0x0800,   // otherwise excludes self
}
heightref_e;

// Light Specials
typedef enum
{
  LITE_None,

  // set light to new level instantly
  LITE_Set,

  // fade light to new level over time
  LITE_Fade,

  // flicker like a fire
  LITE_FireFlicker,

  // smoothly fade between bright and dark, continously
  LITE_Glow,

  // blink randomly between bright and dark
  LITE_Flash,

  // blink between bright and dark, alternating
  LITE_Strobe
}
litetype_e;

// Movement type
typedef enum
{
  mov_undefined,
  mov_Once,
  mov_MoveWaitReturn,
  mov_Continuous,
  mov_Plat,
  mov_Stairs,
  mov_Stop
}
movetype_e;

// Security type: requires certain key
typedef enum
{
  KF_NONE = 0,

  // keep card/skull together, for easy SKCK check
  KF_BlueCard    = (1 &lt;&lt; 0),
  KF_YellowCard  = (1 &lt;&lt; 1),
  KF_RedCard     = (1 &lt;&lt; 2),
  KF_GreenCard   = (1 &lt;&lt; 3),

  KF_BlueSkull   = (1 &lt;&lt; 4),
  KF_YellowSkull = (1 &lt;&lt; 5),
  KF_RedSkull    = (1 &lt;&lt; 6),
  KF_GreenSkull  = (1 &lt;&lt; 7),

  // -AJA- 2001/06/30: ten new keys (these + Green ones)
  KF_GoldKey     = (1 &lt;&lt; 8),
  KF_SilverKey   = (1 &lt;&lt; 9),
  KF_BrassKey    = (1 &lt;&lt; 10),
  KF_CopperKey   = (1 &lt;&lt; 11),
  KF_SteelKey    = (1 &lt;&lt; 12),
  KF_WoodenKey   = (1 &lt;&lt; 13),
  KF_FireKey     = (1 &lt;&lt; 14),
  KF_WaterKey    = (1 &lt;&lt; 15),

  // this is a special flag value that indicates that _all_ of the
  // keys in the bitfield must be held.  Normally we require _any_ of
  // the keys in the bitfield to be held.
  //
  KF_STRICTLY_ALL = (1 &lt;&lt; 16),

  // Boom compatibility: don't care if card or skull
  KF_BOOM_SKCK = (1 &lt;&lt; 17),

  // mask of actual key bits
  KF_CARDS  = 0x000F,
  KF_SKULLS = 0x00F0,
  KF_MASK = 0xFFFF
}
keys_e;

#define EXPAND_KEYS(set)  ((set) |  \
    (((set) &amp; KF_CARDS) &lt;&lt; 4) | (((set) &amp; KF_SKULLS) &gt;&gt; 4))


// -AJA- 1999/06/21: extra floor types

typedef enum
{
  // keeps the value from being zero
  EXFL_Present = 0x0001,

  // floor is thick, has sides.  When clear: surface only
  EXFL_Thick = 0x0002,

  // floor is liquid, i.e. non-solid.  When clear: solid
  EXFL_Liquid = 0x0004,

  // can monsters see through this extrafloor ?
  EXFL_SeeThrough = 0x0010,

  // things with the WATERWALKER tag will not fall through.
  // Also, certain player sounds (pain, death) can be overridden when
  // in a water region.  Scope for other "waterish" effects...
  // 
  EXFL_Water = 0x0020,

  // the region properties will "flood" all lower regions (unless it
  // finds another flooder).
  // 
  EXFL_Flooder = 0x0040,

  // the properties (lighting etc..) below are not transferred from
  // the dummy sector, they'll be the same as the above region.
  // 
  EXFL_NoShade = 0x0080,

  // take the side texture for THICK floors from the upper part of the
  // sidedef where the thick floor is drawn (instead of tagging line).
  // 
  EXFL_SideUpper = 0x0100,

  // like above, but use the lower part.
  EXFL_SideLower = 0x0200,

  // Boom compatibility flag (for linetype 242)
  EXFL_BoomTex = 0x0400
}
extrafloor_type_e;

#define EF_DEF_THIN    (EXFL_Present | 0)
#define EF_DEF_THICK   (EXFL_Present | EXFL_Thick)
#define EF_DEF_LIQUID  (EXFL_Present | EXFL_Liquid)

typedef enum
{
  EFCTL_None = 0,

  // remove an extra floor
  EFCTL_Remove
}
extrafloor_control_e;

typedef struct extrafloor_info_s
{
  extrafloor_type_e type;
  extrafloor_control_e control;
}
extrafloor_info_t;

// -AJA- 1999/07/12: teleporter special flags.
typedef enum
{
  TELSP_SameDir = 0x0001,
  TELSP_SameHeight = 0x0002,
  TELSP_SameSpeed = 0x0004,
  TELSP_SameOffset = 0x0008,
  TELSP_Rotate = 0x0010
}
teleportspecial_e;

#define TELSP_Preserve  \
    (TELSP_SameDir | TELSP_SameHeight | TELSP_SameSpeed)

//
// Moving Planes (Ceilings, floors and doors)
//
typedef struct moving_plane_s
{
  // Type of floor: raise/lower/etc
  movetype_e type;

  // True for a ceiling, false for a floor
  boolean_t is_ceiling;
  boolean_t crush;

  // How fast the plane moves.
  float_t speed_up;
  float_t speed_down;

  // This refers to what the dest. height refers to.
  heightref_e destref;

  // Destination height.
  float_t dest;

  // -AJA- 2001/05/28: This specifies the other height used.
  heightref_e otherref;
  float_t other;

  // Floor texture to change to.
  char tex[10];

  // PLAT/DOOR Specific: Time to wait before returning.
  int wait;
  int prewait;

  // Up/Down/Stop sfx
  sfx_t *sfxstart, *sfxup, *sfxdown, *sfxstop;

  // Scrolling. -AJA- 2000/04/16
  angle_t scroll_angle;
  float_t scroll_speed;
}
moving_plane_t;

//
// Elevator structure
//
// This is essentially used the same way as linking the floor and
// ceiling together, but I don't intend on hacking the code for that,
// so we do it the more informative way.
//
// -ACB- 2001/01/11 Added as elevator sector
//
typedef struct elevator_sector_s
{
  // Type of floor: raise/lower/etc
  movetype_e type;
  
  // How fast the elevator moves.
  float_t speed_up;
  float_t speed_down;

  // Wait times.
  int wait;       
  int prewait;

  // Up/Down/Stop sfx
  sfx_t *sfxstart, *sfxup, *sfxdown, *sfxstop;  
}
elevator_sector_t;

typedef enum
{
  // not a slider
  SLIDE_None = 0,

  // door slides left (when looking at the right side)
  SLIDE_Left,

  // door slides right (when looking at the right side)
  SLIDE_Right,

  // door opens from middle
  SLIDE_Center
}
slidetype_e;

//
// Thin Sliding Doors
//
// -AJA- 2000/08/05: added this.
//
typedef struct sliding_door_s
{
  // type of slider, normally SLIDE_None
  slidetype_e type;

  // how fast it opens/closes
  float_t speed;

  // time to wait before returning (in tics).  Note: door stays open
  // after the last activation.
  int wait;

  // whether or not the texture can be seen through
  boolean_t see_through;

  // how far it actually opens (usually 100%)
  percent_t distance;

  // sound effects.
  sfx_t *sfx_start;
  sfx_t *sfx_open;
  sfx_t *sfx_close;
  sfx_t *sfx_stop;
}
sliding_door_t;

// DONUT SPECIFIC
typedef struct donut_s
{
  // Do Donut?
  boolean_t dodonut;

  // SFX for inner donut parts
  sfx_t *d_sfxin, *d_sfxinstop;

  // SFX for outer donut parts
  sfx_t *d_sfxout, *d_sfxoutstop;
}
donut_t;

typedef struct teleport_point_s
{
  // If true, teleport activator
  boolean_t teleport;

  // effect object spawned when going in...
  const mobjinfo_t *inspawnobj;
  const char *inspawnobj_ref;

  // effect object spawned when going out...
  const mobjinfo_t *outspawnobj;
  const char *outspawnobj_ref;

  // Teleport delay
  int delay;

  // Special flags.
  teleportspecial_e special;
}
teleport_point_t;

// -KM- 1998/09/27 Generalisation of light types for lines + sectors
typedef struct
{
  litetype_e type;

  // light level to change to (for SET and FADE)
  int level;

  // chance value for FLASH type
  percent_t chance;
  
  // time remaining dark and bright, in tics
  int darktime;
  int brighttime;

  // synchronisation time, in tics
  int sync;

  // stepping used for FADE and GLOW types
  int step;
}
lighttype_t;

typedef enum
{
  EXIT_None = 0,
  EXIT_Normal,
  EXIT_Secret
}
exittype_e;

typedef enum
{
  // make tagged lines (inclusive) 50% translucent
  LINEFX_Translucency = 0x0001,

  // make tagged walls (inclusive) scroll using vector
  LINEFX_VectorScroll = 0x0002,

  // make source line scroll using sidedef offsets
  LINEFX_OffsetScroll = 0x0004,

  // experimental: tagged walls (inclusive) scaling &amp; skewing
  LINEFX_Scale = 0x0010,
  LINEFX_Skew  = 0x0020,

  // experimental: transfer properties to tagged walls (incl)
  LINEFX_LightWall = 0x0040,

  // experimental: make tagged lines (exclusive) non-blocking
  LINEFX_UnblockThings = 0x0100,

  // experimental: make tagged lines (incl) block bullets/missiles
  LINEFX_BlockShots = 0x0200,

  // experimental: make tagged lines (incl) block monster sight
  LINEFX_BlockSight = 0x0400
}
line_effect_type_e;

typedef enum
{
  // transfer sector lighting to tagged floors/ceilings
  SECTFX_LightFloor   = 0x0001,
  SECTFX_LightCeiling = 0x0002,

  // make tagged floors/ceilings scroll
  SECTFX_ScrollFloor   = 0x0004,
  SECTFX_ScrollCeiling = 0x0008,

  // push things on tagged floor
  SECTFX_PushThings = 0x0010,

  // restore light/scroll/push in tagged floors/ceilings
  SECTFX_ResetFloor   = 0x0040,
  SECTFX_ResetCeiling = 0x0080,

  // experimental: set floor/ceiling texture scale
  SECTFX_ScaleFloor   = 0x0100,
  SECTFX_ScaleCeiling = 0x0200,

  // experimental: align floor/ceiling texture to line
  SECTFX_AlignFloor   = 0x0400,
  SECTFX_AlignCeiling = 0x0800
}
sector_effect_type_e;

// -AJA- 1999/10/12: Generalised scrolling parts of walls.
typedef enum
{
  SCPT_RightUpper  = 0x0001,
  SCPT_RightMiddle = 0x0002,
  SCPT_RightLower  = 0x0004,

  SCPT_LeftUpper  = 0x0010,
  SCPT_LeftMiddle = 0x0020,
  SCPT_LeftLower  = 0x0040,

  SCPT_LeftRevX   = 0x0100,
  SCPT_LeftRevY   = 0x0200
}
scroll_part_e;

#define SCPT_RIGHT  (SCPT_RightUpper | SCPT_RightMiddle | SCPT_RightLower)
#define SCPT_LEFT   (SCPT_LeftUpper | SCPT_LeftMiddle | SCPT_LeftLower)

// -AJA- 2001/01/23: Implementation of layered skies.
typedef enum
{
  TILESKY_None = 0,
  TILESKY_Flat,
  TILESKY_Texture
}
tilesky_type_e;

#define MAX_TILESKY  4

typedef struct tilesky_info_s
{
  tilesky_type_e type;

  // which layer, lower numbers are further away
  int layer;
  
  // how many times the image should tile
  int number;

  // dimensions for the sky sphere
  float_t squish;
  float_t offset;
}
tilesky_info_t;

typedef struct ladder_info_s
{
  // height of ladder itself.  Zero or negative disables.  Bottom of
  // ladder comes from Y_OFFSET on the linedef.
  float_t height;
}
ladder_info_t;

// -AJA- 1999/10/24: Reimplemented when_appear_e type.
typedef enum
{
  WNAP_SkillBits = 0x001F,

  WNAP_Single = 0x0100,
  WNAP_Coop = 0x0200,
  WNAP_DeathMatch = 0x0400
}
when_appear_e;

#define DEFAULT_APPEAR  (0xFFFF)

// -AJA- 1999/12/07: Linedef special flags
typedef enum
{
  // player must be able to vertically reach this linedef to press it
  LINSP_MustReach = 0x0001,

  // don't change the texture on other linedefs with the same tag
  LINSP_SwitchSeparate = 0x0002
}
line_special_e;

// Linedef structure itself
typedef struct linedeftype_s
{
  // Line's name, number, etc...
  ddf_base_t ddf;

  // Linedef will change to this.
  int newtrignum;

  // Determines whether line is shootable/walkable/pushable
  trigger_e type;

  // Determines whether line is acted on by monsters/players/projectiles
  trigacttype_e obj;

  // Keys required to use
  keys_e keys;

  // Number of times this line can be triggered. -1 = Any amount
  int count;

  // Special sector type to change to.  Used to turn off acid
  int specialtype;

  // Crush.  If true, players will be crushed.  If false, obj will stop(/return)
  boolean_t crush;

  // Floor
  moving_plane_t f;

  // Ceiling
  moving_plane_t c;

  // Elevator (moving sector) -ACB- 2001/01/11
  elevator_sector_t e;

  // Donut 
  donut_t d;

  // Slider
  sliding_door_t s;

  // Tile Skies
  tilesky_info_t sky;
  
  // -AJA- 2001/03/10: ladder linetypes
  ladder_info_t ladder;

  // Teleport
  teleport_point_t t;

  // LIGHT SPECIFIC
  // Things may be added here; start strobing/flashing glowing lights.
  lighttype_t l;

  // EXIT SPECIFIC
  exittype_e e_exit;

  // SCROLLER SPECIFIC
  float_t s_xspeed;
  float_t s_yspeed;
  scroll_part_e scroll_parts;

  // -ACB- 1998/09/11 Message handling
  char *failedmessage;

  // Colourmap changing
  // -AJA- 1999/07/09: Now uses colmap.ddf
  const colourmap_t *use_colourmap;

  // Property Transfers
  float_t gravity;
  float_t friction;
  float_t viscosity;
  float_t drag;

  // Ambient sound transfer
  sfx_t *ambient_sfx;

  // Activation sound (overrides the switch sound)
  sfx_t *activate_sfx;

  int music;

  // Automatically trigger this line at level start ?
  boolean_t autoline;

  // Activation only possible from right side of line
  boolean_t singlesided;

  // -AJA- 1999/06/21: Extra floor handling
  extrafloor_info_t ef;

  // -AJA- 1999/06/30: TRANSLUCENT MID-TEXTURES
  percent_t translucency;

  // -AJA- 1999/10/24: Appearance control.
  when_appear_e appear;

  // -AJA- 1999/12/07: line special flags
  line_special_e special_flags;

  // -AJA- 2000/01/09: enable (if +1) or disable (if -1) all radius
  //       triggers with the same tag as the linedef.
  int trigger_effect;

  // -AJA- 2000/09/28: BOOM compatibility fields (and more !).
  line_effect_type_e line_effect;
  scroll_part_e line_parts;
  sector_effect_type_e sector_effect;
}
linedeftype_t;

// -AJA- 1999/11/25: Sector special flags
typedef enum
{
  // apply damage whenever in whole region (not just touching floor)
  SECSP_WholeRegion = 0x0001,

  // goes with above: damage is proportional to how deep you're in
  // Also affects pushing sectors.
  SECSP_Proportional = 0x0002,

  // push _all_ things, including NOGRAVITY ones
  SECSP_PushAll = 0x0008,

  // the push force is constant, regardless of the mass
  SECSP_PushConstant = 0x0010,

  // breathing support: this sector contains no air.
  SECSP_AirLess = 0x0020,

  // player can swim in this sector
  SECSP_Swimming = 0x0040
}
sector_flag_e;

// -KM- 1998/09/27 Sectors.ddf stuff
typedef struct
{
  // Sector's name, number, etc...
  ddf_base_t ddf;

  // This sector gives you secret count
  boolean_t secret;

  // Gravity
  float_t gravity;
  float_t friction;
  float_t viscosity;
  float_t drag;

  boolean_t crush;

  // Movement
  moving_plane_t f, c;

  // Elevator: Added -ACB- 2001/01/11
  elevator_sector_t e;

  // Lighting
  lighttype_t l;

  // Slime
  damage_t damage;

  // -AJA- 1999/11/25: sector special flags
  sector_flag_e special_flags;

  // Exit.  Also disables god mode.
  exittype_e e_exit;

  // Colourmap changing
  // -AJA- 1999/07/09: Now uses colmap.ddf
  const colourmap_t *use_colourmap;

  // SFX
  sfx_t *ambient_sfx;

  // -AJA- 1999/10/24: Appearance control.
  when_appear_e appear;

  // -AJA- 2000/01/02: DDF-itisation of crushers.
  int crush_time;
  float_t crush_damage;

  // -AJA- 2000/04/16: Pushing (fixed direction).
  float_t push_speed;
  float_t push_zspeed;
  angle_t push_angle;
}
specialsector_t;

// ----------------------------------------------------------------
// -------------------------MUSIC PLAYLIST-------------------------
// ----------------------------------------------------------------

typedef enum
{
  MUS_UNKNOWN   = 0,
  MUS_CD        = 1,
  MUS_MIDI      = 2,
  MUS_MUS       = 3,
  MUS_MP3       = 4,
  ENDOFMUSTYPES = 5
}
musictype_t;

typedef enum
{
  MUSINF_UNKNOWN   = 0,
  MUSINF_TRACK     = 1,
  MUSINF_LUMP      = 2,
  MUSINF_FILE      = 3,
  ENDOFMUSINFTYPES = 4
}
musicinftype_t;

typedef struct playlist_s
{
  ddf_base_t ddf;
  musictype_t type;
  musicinftype_t infotype;
  char *info;
}
playlist_t;

// ----------------------------------------------------------------
// ------------------------ SOUND EFFECTS ------------------------
// ----------------------------------------------------------------

//
// -ACB- 1999/10/06 Removed usefulness and priv_data. Usefulness was
//                  removed because I felt no need for sound caching
//                  in a basic system.  Priv_data was removed as this
//                  should be held by only the system specific code.
//                  Lumpnum got booted for the same reason as above.

typedef struct sfxinfo_s
{
  // sound's name, etc..
  ddf_base_t ddf;

  // full sound lump name
  char lump_name[10];

  // sfxinfo ID number
  // -AJA- Changed to a sfx_t.  It serves two purposes: (a) hold the
  //       sound ID, like before, (b) better memory usage, as we don't
  //       need to allocate a new sfx_t for non-wildcard sounds.
  sfx_t normal;

  // Sfx singularity (only one at a time), or 0 if not singular
  int singularity;

  // Sfx priority
  int priority;

  // volume of sound, 255 is normal, lower is quieter.
  percent_t volume;

  // -KM- 1998/09/01  Looping: for non NULL origins
  boolean_t looping;

  // -AJA- 2000/04/19: Prefer to play the whole sound rather than
  //       chopping it off with a new sound.
  boolean_t precious;
 
  // distance limit, if the hearer is further away than `max_distance'
  // then the this sound won't be played at all.
  float_t max_distance;
 
  // for the cache's circular linked list. NULL if not cached.
  struct sfxinfo_s *next, *prev;
}
sfxinfo_t;

// ------------------------------------------------------------------
// -------------------------EXTERNALISATIONS-------------------------
// ------------------------------------------------------------------

extern state_t *states;
extern int num_states;

extern animdef_t ** animdefs;
extern int numanimdefs;

extern attacktype_t ** ddf_attacks;
extern int num_ddf_attacks;

extern linedeftype_t ** ddf_linetypes;
extern int num_ddf_linetypes;

extern specialsector_t ** ddf_sectors;
extern int num_ddf_sectors;

extern wi_map_t ** wi_maps;
extern int num_wi_maps;

extern mapstuff_t ** level_maps;
extern int num_level_maps;
extern const mapstuff_t *currentmap;
extern const mapstuff_t *nextmap;

extern const moving_plane_t donut_floor;
extern const linedeftype_t template_line;
extern linedeftype_t *specialLineDefs[211];

extern language_t ** languages;
extern int num_languages;
extern int cur_lang_index;

extern mobjinfo_t ** mobjinfo;
extern int num_mobjinfo;

// the complete set of sound effects
extern sfxinfo_t ** S_sfx;
extern int numsfx;

extern switchlist_t ** alph_switches;
extern int num_alph_switches;

// -KM- 1998/11/25 Dynamic number of weapons, always 10 weapon keys.
extern weaponinfo_t ** weaponinfo;
extern int numweapons;
extern int num_disabled_weapons;
extern weaponkey_t weaponkey[10];

void DDF_MainInit(void);
boolean_t DDF_MainCleanUp(void);
boolean_t DDF_MainParseCondition(const char *str, condition_check_t *cond);

int DDF_CompareName(const char *A, const char *B);
sfx_t *DDF_SfxLookupSound(const char *name);
sfxinfo_t *DDF_SfxSelect(const sfx_t *sound_id);
const char *DDF_LanguageLookup(const char *refname);
boolean_t DDF_LanguageValidRef(const char *refname);

void DDF_MobjGetBenefit(const char *info, void *storage);
const mobjinfo_t *DDF_MobjLookup(const char *refname);
const mobjinfo_t *DDF_MobjLookupNum(int number);
const mobjinfo_t *DDF_MobjLookupCast(int castnum);
const mobjinfo_t *DDF_MobjLookupPlayer(int playernum);

const colourmap_t *DDF_ColmapLookup(const char *name);
const wi_map_t *DDF_GameLookup(const char *name);
const playlist_t *DDF_MusicLookupNum(int number);
const mapstuff_t *DDF_LevelMapLookup(const char *refname);
const linedeftype_t *DDF_LineLookupNum(int number);
const specialsector_t *DDF_SectorLookupNum(int number);
int DDF_WeaponLookup(const char *name);

struct sector_s;

// -AJA- 2001/05/29: BOOM generalised line/sector type support.
void DDF_LineClearGeneralised(void);
void DDF_SectorClearGeneralised(void);

// -KM- 1998/12/16 If you have a ddf file to add, call
//  this, passing the data and the size of the data in
//  memory.
void DDF_ReadAnims(void *data, int size);
void DDF_ReadAtks(void *data, int size);
void DDF_ReadColourMaps(void *data, int size);
void DDF_ReadGames(void *data, int size);
void DDF_ReadLangs(void *data, int size);
void DDF_ReadLevels(void *data, int size);
void DDF_ReadLines(void *data, int size);
void DDF_ReadMusicPlaylist(void *data, int size);
void DDF_ReadSectors(void *data, int size);
void DDF_ReadSFX(void *data, int size);
void DDF_ReadSW(void *data, int size);
void DDF_ReadThings(void *data, int size);
void DDF_ReadWeapons(void *data, int size);

#endif
</t>
<t tx="T2535">@ignore

// Data

//
// DESCRIPTION:
//  all external data is defined here
//  most of the data is loaded into different structures at run time
//  some internal structures shared by many modules are here
//

#ifndef __DOOMDATA__
#define __DOOMDATA__

// The most basic types we use, portability.
#include "dm_type.h"

// Some global defines, that configure the game.
#include "dm_defs.h"

//
// Map level types.
// The following data structures define the persistent format
// used in the lumps of the WAD files.
//

// Lump order in a map WAD: each map needs a couple of lumps
// to provide a complete scene geometry description.
enum
{
   ML_LABEL=0,   // A separator name, ExMx or MAPxx
   ML_THINGS,    // Monsters, items..
   ML_LINEDEFS,  // LineDefs, from editing
   ML_SIDEDEFS,  // SideDefs, from editing
   ML_VERTEXES,  // Vertices, edited and BSP splits generated
   ML_SEGS,      // LineSegs, from LineDefs split by BSP
   ML_SSECTORS,  // SubSectors, list of LineSegs
   ML_NODES,     // BSP nodes
   ML_SECTORS,   // Sectors, from editing
   ML_REJECT,    // LUT, sector-sector visibility 
   ML_BLOCKMAP,  // LUT, motion clipping, walls/grid element
   ML_BEHAVIOR   // Hexen scripting stuff
};

// -AJA- 1999/12/20: Lump order from "GL-Friendly Nodes" specs.
enum
{
   ML_GL_LABEL=0,  // A separator name, GL_ExMx or GL_MAPxx
   ML_GL_VERT,     // Extra Vertices
   ML_GL_SEGS,     // Segs, from linedefs &amp; minisegs
   ML_GL_SSECT,    // SubSectors, list of segs
   ML_GL_NODES     // GL BSP nodes
};

// A single Vertex.
typedef struct
{
  short x;
  short y;
}
mapvertex_t;

// A SideDef, defining the visual appearance of a wall,
// by setting textures and offsets.
typedef struct
{
  short textureoffset;
  short rowoffset;
  char toptexture[8];
  char bottomtexture[8];
  char midtexture[8];
  // Front sector, towards viewer.
  short sector;
}
mapsidedef_t;

// A LineDef, as used for editing, and as input
// to the BSP builder.
typedef struct
{
  short v1;
  short v2;
  short flags;
  short special;
  short tag;
  // sidenum[1] will be -1 if one sided
  short sidenum[2];
}
maplinedef_t;

//
// LineDef attributes.
//

typedef enum
{
  // Solid, is an obstacle.
  ML_Blocking = 0x0001,

  // Blocks monsters only.
  ML_BlockMonsters = 0x0002,

  // Backside will not be present at all if not two sided.
  ML_TwoSided = 0x0004,

  // If a texture is pegged, the texture will have
  // the end exposed to air held constant at the
  // top or bottom of the texture (stairs or pulled
  // down things) and will move with a height change
  // of one of the neighbor sectors.
  // Unpegged textures allways have the first row of
  // the texture at the top pixel of the line for both
  // top and bottom textures (use next to windows).

  // upper texture unpegged
  ML_UpperUnpegged = 0x0008,

  // lower texture unpegged
  ML_LowerUnpegged = 0x0010,

  // In AutoMap: don't map as two sided: IT'S A SECRET!
  ML_Secret = 0x0020,

  // Sound rendering: don't let sound cross two of these.
  ML_SoundBlock = 0x0040,

  // Don't draw on the automap at all.
  ML_DontDraw = 0x0080,

  // Set if already seen, thus drawn in automap.
  ML_Mapped = 0x0100,

  // -AJA- 1999/08/16: This one is from Boom. Allows multiple lines to
  //       be pushed simultaneously.
  ML_PassThru = 0x0200,

  // -AJA- These three from XDoom.  Translucent one doesn't do
  //       anything at present.
  ML_Translucent = 0x0400,
  ML_ShootBlock  = 0x0800,
  ML_SightBlock  = 0x1000,

  // --- internal flags ---
}
lineflag_e;

// -AJA- 2001/08/04: Hexen linedef
typedef struct
{
  short v1;
  short v2;
  short flags;
  byte special[6];
  short sidenum[2];
}
maphexenlinedef_t;

// Sector definition, from editing.
typedef struct
{
  short floorheight;
  short ceilingheight;
  char floorpic[8];
  char ceilingpic[8];
  short lightlevel;
  short special;
  short tag;
}
mapsector_t;

// SubSector, as generated by BSP.
typedef struct
{
  short numsegs;
  // Index of first one, segs are stored sequentially.
  short firstseg;
}
mapsubsector_t;

// LineSeg, generated by splitting LineDefs
// using partition lines selected by BSP builder.
typedef struct mapseg_t
{
  short v1;
  short v2;
  short angle;
  short linedef;
  short side;
  short offset;
}
mapseg_t;

// -AJA- 1999/12/20: New kind of seg, contained in the GL_SEGS lump
//       and conforming to the "GL-friendly Nodes" specifications.

// Indicates a GL-specific vertex
#define	SF_GL_VERTEX	0x8000

typedef struct map_glseg_s
{
  // start &amp; end vertices
  unsigned short v1;
  unsigned short v2;

  // linedef, or -1 for minisegs
  short linedef;

  // side on linedef: 0 for right, 1 for left
  short side;

  // corresponding partner seg, or -1 on one-sided walls
  short partner;
}
map_glseg_t;

// -AJA- 2000/07/01: New kind of vertex for V2.0 of the "GL Nodes"
//      specifications.  These vertices are in 16.16 fixed point.
typedef struct
{
  long x;
  long y;
}
map_gl2vertex_t;

// BSP node structure.

// Indicate a leaf.
#define	NF_SUBSECTOR	0x8000

typedef struct
{
  // Partition line from (x,y) to x+dx,y+dy)
  short x;
  short y;
  short dx;
  short dy;

  // Bounding box for each child,
  // clip against view frustum.
  short bbox[2][4];

  // If NF_SUBSECTOR its a subsector,
  // else it's a node of another subtree.
  unsigned short children[2];

}
mapnode_t;

// Thing definition, position, orientation and type,
// plus skill/visibility flags and attributes.
typedef struct
{
  short x;
  short y;
  short angle;
  short type;
  short options;
}
mapthing_t;

// -AJA- 2001/08/04: Hexen thing definition
typedef struct
{
  short tag;
  short x, y, z;
  short angle;
  short type;
  short options;
  byte special[6];
}
maphexenthing_t;

// Wad header definition
typedef struct wad_header_s
{
  // should be "IWAD" or "PWAD".
  char identification[4];
  long numlumps;
  long infotableofs;
}
wad_header_t;

// Wad table entry
typedef struct wad_entry_s
{
  long pos;
  long size;
  char name[8];
}
wad_entry_t;

// Patches.
//
// A patch holds one or more columns.
// Patches are used for sprites and all masked pictures,
// and we compose textures from the TEXTURE1/2 lists
// of patches.
//
typedef struct patch_s
{
  // bounding box size 
  short width;
  short height;

  // pixels to the left of origin 
  short leftoffset;

  // pixels below the origin 
  short topoffset;

  int columnofs[1];  // only [width] used
}
patch_t;

//
// Texture element.
//
// Each texture is composed of one or more patches,
// with patches being lumps stored in the WAD.
//
// The lumps are referenced by number, and patched into the rectangular
// texture space using origin and possibly other attributes.
//
typedef struct
{
  short originx;
  short originy;
  short patch;
  short stepdir;
  short colourmap;
}
mappatch_t;

//
// Texture definition.
//
// A DOOM wall texture is a list of patches which are to be combined in a
// predefined order.
//
// Removing the obsolete columndirectory fails because this defines how a
// texture is stored in the wad file.
//
typedef struct
{
  char name[8];
  int masked;
  short width;
  short height;
  int columndirectory;
  short patchcount;
  mappatch_t patches[1];
}
maptexture_t;

#endif // __DOOMDATA__
</t>
<t tx="T2536">@ignore

// Basic Definitions File



#ifndef __DEFINITIONS__
#define __DEFINITIONS__

#include "dm_type.h"

//
// Global parameters/defines.
//

#define INV_ASPECT_RATIO  0.625  // 0.75, ideally

// State updates, number of tics / second.
#define TICRATE         35

// The current state of the game: whether we are
// playing, gazing at the intermission screen,
// the game final animation, or a demo. 
typedef enum
{
  GS_LEVEL,
  GS_INTERMISSION,
  GS_FINALE,
  GS_DEMOSCREEN,
  GS_NOTHING
}
gamestate_t;

//
// Difficulty/skill settings/filters.
//

// Skill flags.
#define MTF_EASY         1
#define MTF_NORMAL       2
#define MTF_HARD         4

// Deaf monsters/do not react to sound.
#define MTF_AMBUSH       8

// Multiplayer only.
#define MTF_NOT_SINGLE  16

// -AJA- 1999/09/22: Boom compatibility.
#define MTF_NOT_DM      32
#define MTF_NOT_COOP    64

// -AJA- 2000/07/31: Friend flag, from MBF
#define MTF_FRIEND      128 

typedef enum
{
  sk_baby,
  sk_easy,
  sk_medium,
  sk_hard,
  sk_nightmare
}
skill_t;

// -KM- 1998/12/16 Added gameflags typedef here.
typedef enum
{
  AA_OFF,
  AA_ON,
  AA_MLOOK
}
autoaim_t;

typedef enum
{
  CM_EDGE,
  CM_BOOM
}
compat_mode_t;

typedef struct gameflags_s
{
  // checkparm of -nomonsters
  boolean_t nomonsters;
  // checkparm of -fast
  boolean_t fastparm;

  boolean_t respawn;
  boolean_t res_respawn;
  boolean_t itemrespawn;

  boolean_t true3dgameplay;
  int menu_grav;
  boolean_t more_blood;

  boolean_t jump;
  boolean_t crouch;
  boolean_t mlook;
  autoaim_t autoaim;

  boolean_t trans;
  boolean_t cheats;
  boolean_t stretchsky;
  boolean_t have_extra;
  boolean_t limit_zoom;
  boolean_t shadows;
  boolean_t halos;

  compat_mode_t compat_mode;
  boolean_t kicking;
}
gameflags_t;

#define  VISIBLE (1.0)
#define  VISSTEP (1.0/256)
#define  INVISIBLE (0)

//
// DOOM keyboard definition.
// This is the stuff configured by Setup.Exe.
// Most key data are simple ascii (uppercased).
//
#define KEYD_TILDE      ('`')
#define KEYD_RIGHTARROW (0x80+0x2e)
#define KEYD_LEFTARROW  (0x80+0x2c)
#define KEYD_UPARROW    (0x80+0x2d)
#define KEYD_DOWNARROW  (0x80+0x2f)
#define KEYD_ESCAPE     27
#define KEYD_ENTER      13
#define KEYD_TAB        9
#define KEYD_SPACE      32
#define KEYD_BACKSPACE  127
#define KEYD_EQUALS     0x3d
#define KEYD_MINUS      0x2d

#define KEYD_F1         (0x80+0x3b)
#define KEYD_F2         (0x80+0x3c)
#define KEYD_F3         (0x80+0x3d)
#define KEYD_F4         (0x80+0x3e)
#define KEYD_F5         (0x80+0x3f)
#define KEYD_F6         (0x80+0x40)
#define KEYD_F7         (0x80+0x41)
#define KEYD_F8         (0x80+0x42)
#define KEYD_F9         (0x80+0x43)
#define KEYD_F10        (0x80+0x44)
#define KEYD_F11        (0x80+0x57)
#define KEYD_F12        (0x80+0x58)
#define KEYD_RCTRL      (0x80+0x1d)
#define KEYD_RSHIFT     (0x80+0x36)
#define KEYD_RALT       (0x80+0x38)
#define KEYD_LALT       KEYD_RALT
#define KEYD_NUMLOCK    (0x80+0x45)
#define KEYD_SCRLOCK    (0x80+0x46)
#define KEYD_HOME       (0x80+0x47)
#define KEYD_PGUP       (0x80+0x49)
#define KEYD_END        (0x80+0x4f)
#define KEYD_PGDN       (0x80+0x51)
#define KEYD_INSERT     (0x80+0x52)
#define KEYD_DELETE     (0x80+0x53)
#define KEYD_PRTSCR     (0x80+0x54)
#define KEYD_CAPSLOCK   0xfe
#define KEYD_PAUSE      0xff

// All keys greater than this aren't actually keyboard keys, but buttons on
// joystick/mice.
#define KEYD_NONKBKEY   0x100

#define KEYD_MOUSE1     0x100
#define KEYD_MOUSE2     0x101
#define KEYD_MOUSE3     0x102
#define KEYD_MOUSE4     0x103 // -ACB- 1999/09/30 Fourth Mouse Button Added 
#define KEYD_MWHEEL_UP  0x104
#define KEYD_MWHEEL_DN  0x105

#define KEYD_JOYBASE    0x110

// -KM- 1998/09/27 Analogue binding, added a fly axis
#define AXIS_DISABLE     5
#define AXIS_TURN        0
#define AXIS_FORWARD     1
#define AXIS_STRAFE      2
#define AXIS_FLY         4  // includes SWIM up/down
#define AXIS_MLOOK       3

#endif // __DEFINITIONS__

</t>
<t tx="T2537">@ignore

// Global State Variables

//
// -MH- 1998/07/02 "lookupdown" --&gt; "true3dgameplay"
//
// -ACB- 1999/10/07 Removed Sound Parameters - New Sound API
//

#ifndef __D_STATE__
#define __D_STATE__

// We need globally shared data structures,
//  for defining the global state variables.
#include "dm_data.h"
#include "e_net.h"

// We need the playr data structure as well.
#include "e_player.h"

extern boolean_t devparm;  // DEBUG: launched with -devparm

extern boolean_t redrawsbar;

extern gameflags_t level_flags;
extern gameflags_t global_flags;

// -----------------------------------------------------
// Game Mode - identify IWAD as shareware, retail etc.
//

// Set if homebrew PWAD stuff has been added.
extern boolean_t modifiedgame;

// -------------------------------------------
// Selected skill type, map etc.
//

// Defaults for menu, methinks.
extern skill_t startskill;
extern char *startmap;
extern boolean_t drone;

extern boolean_t autostart;

// Selected by user. 
extern skill_t gameskill;

// Netgame? Only true if &gt;1 player.
extern boolean_t netgame;

// Flag: true only if started as net deathmatch.
// An enum might handle altdeath/cooperative better.
extern int deathmatch;

// -------------------------
// Status flags for refresh.
//

// Depending on view size - no status bar?
// Note that there is no way to disable the
//  status bar explicitely.
extern boolean_t statusbaractive;
extern int automapactive;  // In AutoMap mode?
extern boolean_t menuactive;  // Menu overlayed?
extern boolean_t paused;  // Game Pause?
extern boolean_t viewactive;
extern boolean_t nodrawers;
extern boolean_t noblit;

// This one is related to the 3-screen display mode.
// ANG90 = left side, ANG270 = right
extern angle_t viewanglebaseoffset;

// -------------------------------------
// Scores, rating.
// Statistics on a given map, for intermission.
//
extern int totalkills;
extern int totalitems;
extern int totalsecret;

// Timer, for scores.
extern int leveltime;  // tics in game play for par

// --------------------------------------
// DEMO playback/recording related stuff.
// No demo, there is a human player in charge?
// Disable save/end game?
extern boolean_t usergame;

//?
extern boolean_t demoplayback;
extern boolean_t demorecording;

// -AJA- 2000/12/07: auto quick-load feature
extern boolean_t autoquickload;

// Quit after playing a demo from cmdline.
extern boolean_t singledemo;

//?
extern gamestate_t gamestate;

//-----------------------------
// Internal parameters, fixed.
// These are set by the engine, and not changed
//  according to user inputs. Partly load from
//  WAD, partly set at startup time.

extern int gametic;

// The maximum number of players, multiplayer/networking.
#define MAXPLAYERS  32

// Pointer to each player.
extern player_t **playerlookup;

// Linked list of all players in the game.
extern player_t *players;

// Player taking events, and displaying.
extern player_t *consoleplayer;
extern player_t *displayplayer;

#define MAXHEALTH 200
#define MAXARMOUR 200

#define CHEATARMOUR      MAXARMOUR
#define CHEATARMOURTYPE  ARMOUR_Blue

// Player spawn spots for deathmatch.
extern int max_deathmatch_starts;
extern spawnpoint_t *deathmatchstarts;
extern spawnpoint_t *deathmatch_p;

// Player spawn spots.
extern spawnpoint_t *playerstarts;

// Intermission stats.
// Parameters for world map / intermission.
extern wbstartstruct_t wminfo;

//-----------------------------------------
// Internal parameters, used for engine.
//

// File handling stuff.
extern char *iwaddir;
extern char *homedir;
extern char *gamedir;
extern char *savedir;
extern char *ddfdir;
extern const char *cfgfile;
extern FILE *debugfile;

// if true, load DDF/RTS as external files (instead of from EDGE.WAD)
extern boolean_t external_ddf;

// if true, load all graphics at level load
extern boolean_t precache;

// if true, prefer to crash out on various errors
extern boolean_t strict_errors;

// if true, prefer to ignore or fudge various (serious) errors
extern boolean_t lax_errors;

// if true, disable warning messages
extern boolean_t no_warnings;

// if true, disable obsolete warning messages
extern boolean_t no_obsoletes;

// if true, enable HOM detection (hall of mirrors effect)
extern boolean_t hom_detect;

// wipegamestate can be set to -1
//  to force a wipe on the next draw
extern gamestate_t wipegamestate;

extern int mouseSensitivity;

extern boolean_t inhelpscreens;
extern int setblocks;
extern int quickSaveSlot;
extern int darken_screen;

// debug flag to cancel adaptiveness
extern boolean_t singletics;

extern int bodyqueslot;

// Needed to store the number of the dummy sky flat.
// Used for rendering, as well as tracking projectiles etc.

extern const struct image_s *skyflatimage;

#define IS_SKY(plane)  ((plane).image == skyflatimage)


//---------------------------------------------------
// Netgame stuff (buffers and pointers, i.e. indices).

// This is for use in the network communication.
extern doomcom_t *doomcom;

extern int maketic;

extern int ticdup;

//misc stuff
extern boolean_t newhud;
extern boolean_t rotatemap;
extern boolean_t showstats;
extern boolean_t swapstereo;
extern boolean_t infight;

extern int crosshair;
extern int screen_size;
extern int screenblocks;
extern int menunormalfov, menuzoomedfov;
extern int usemouse;
extern int usejoystick;

extern int missileteleport;
extern int teleportdelay;

//cd-audio stuff
typedef enum
{
  CD_OFF = 0,
  CD_ON,
  CD_ATMOS
}
cdType_t;

extern cdType_t cdaudio;
extern int cdtrack;
extern int cdnumtracks;
extern int cdcounter;

//okay, heres the resolution/hicolour:
extern int SCREENWIDTH;
extern int SCREENHEIGHT;
extern int SCREENPITCH;
extern int SCREENBITS;
extern boolean_t SCREENWINDOW;

// transitional macros
#define BPP  (SCREENBITS / 8)
#define SCREENDEPTH  SCREENPITCH
#define in_a_window  SCREENWINDOW

// I_Video.c / V_Video*.c Precalc. Stuff
extern float_t DX, DY, DXI, DYI, DY2, DYI2;
extern int SCALEDWIDTH, SCALEDHEIGHT, X_OFFSET, Y_OFFSET;
extern float_t BASEYCENTER, BASEXCENTER;

extern boolean_t graphicsmode;

// -ES- 1999/08/15 Added teleport effects
extern int telept_effect;
extern int telept_flash;
extern int telept_reverse;
extern int wipe_reverse;
extern int wipe_method;

//mlook stuff
extern int mlookspeed;
extern int mlookon;
extern boolean_t invertmouse; // -ACB- 1999/09/03 Must be true or false - becomes boolean

// -KM- 1998/09/01 Analogue binding stuff, These hold what axis they bind to.
extern int joy_xaxis;
extern int joy_yaxis;
extern int mouse_xaxis;
extern int mouse_yaxis;

//
// -ACB- 1998/09/06 Analogue binding:
//                   Two stage turning, angleturn control
//                   horzmovement control, vertmovement control
//                   strafemovediv;
//
extern boolean_t stageturn;
extern int forwardmovespeed;
extern int angleturnspeed;
extern int sidemovespeed;

#endif
</t>
<t tx="T2538">@ignore

// Basic Types

#ifndef __EDGETYPES__
#define __EDGETYPES__

typedef unsigned char byte;
typedef unsigned int angle_t;

// -AJA- 1999/07/19: Just can't cope without these... :)

#ifndef MAX
#define MAX(x,y)  ((x) &gt; (y) ? (x) : (y))
#endif

#ifndef MIN
#define MIN(x,y)  ((x) &lt; (y) ? (x) : (y))
#endif

#ifndef ABS
#define ABS(x)  ((x) &gt;= 0 ? (x) : -(x))
#endif

#endif
</t>
<t tx="T2539">@ignore

// Strings

#ifndef __DOOM_STRINGS__
#define __DOOM_STRINGS__

// Misc. other strings.
#define SAVEGAMEBASE	"save"
#define SAVEGAMEDIR	"savegame"
#define SAVEGAMEEXT     "esg"
#define SAVEGAMEMODE    0755

extern const char *chat_macros[10];

extern const char *destination_keys;
extern const char *gammamsg[5];

#endif</t>
<t tx="T2540">@ignore

// Event handling Header

#ifndef __E_EVENT_H__
#define __E_EVENT_H__

#include "dm_type.h"

//
// Event handling.
//

// Input event types.
// -KM- 1998/09/01 Amalgamate joystick/mouse into analogue
typedef enum
{
  ev_keydown,
  ev_keyup,
  ev_analogue
}
evtype_t;

// Event structure.
typedef struct
{
  evtype_t type;

  union
  {
    int key;
    struct
    {
      int axis;
      int amount;
    } analogue;
  } value;
}
event_t;

// -KM- 1998/11/25 Added support for finales before levels
typedef enum
{
  ga_nothing,
  ga_loadlevel,
  ga_newgame,
  ga_loadgame,
  ga_savegame,
  ga_playdemo,
  ga_completed,
  ga_worlddone,
  ga_screenshot,
  ga_briefing
}
gameaction_t;

//
// Button/action code definitions.
//
typedef enum
{
  // Press "Fire".
  BT_ATTACK = 1,

  // Use button, to open doors, activate switches.
  BT_USE = 2,

  // Flag: game events, not really buttons.
  BT_SPECIAL = 128,
  BT_SPECIALMASK = 3,

  // Flag, weapon change pending.
  // If true, the next 3 bits hold weapon num.
  BT_CHANGE = 4,

  // The 3bit weapon mask and shift, convenience.
  BT_WEAPONMASK = (8 + 16 + 32 + 64),
  BT_WEAPONSHIFT = 3,

  // Pause the game.
  BTS_PAUSE = 1,

  // Save the game at each console.
  BTS_SAVEGAME = 2,

  // Savegame slot numbers
  //  occupy the second byte of buttons.    
  BTS_SAVEMASK = (4 + 8 + 16),
  BTS_SAVESHIFT = 2
}
buttoncode_t;

//
// Extended Buttons: EDGE Specfics
// -ACB- 1998/07/03
//
typedef enum
{
  EBT_JUMP = 1,
  EBT_MLOOK = 2,
  EBT_CENTER = 4,

  // -AJA- 2000/02/08: support for second attack.
  EBT_SECONDATK = 8,

  // -AJA- 2000/03/18: more control over zooming
  EBT_ZOOM = 16
}
extbuttoncode_t;

//
// GLOBAL VARIABLES
//
#define MAXEVENTS 128

extern event_t events[MAXEVENTS];
extern int eventhead;
extern int eventtail;

extern gameaction_t gameaction;

#endif
</t>
<t tx="T2541">@ignore

// Main Header

#ifndef __E_MAIN__
#define __E_MAIN__

#include "e_event.h"

extern boolean_t redrawsbar;
extern boolean_t advancedemo;
extern boolean_t e_display_OK;
extern boolean_t need_save_screenshot;

void E_AddFile(const char *file);
void E_EDGEMain(void);
void E_EDGELoopRoutine(void);
boolean_t E_CheckNetGame(void);
void E_ProcessEvents(void);
void E_DoAdvanceDemo(void);
void E_PostEvent(event_t * ev);
void E_PageTicker(void);
void E_PageDrawer(void);
void E_AdvanceDemo(void);
void E_StartTitle(void);
void E_EngineShutdown(void);
void E_Display(void);

#endif
</t>
<t tx="T2542">@ignore

// Networking stuff

#ifndef __E_NET_H__
#define __E_NET_H__

#include "e_player.h"


#define DEBUG_NET  0

// Network play related stuff.
// There is a data struct that stores network
//  communication related stuff, and another
//  one that defines the actual packets to
//  be transmitted.


#define DOOMCOM_ID		0x12345678l

// Max computers/players in a game.
#define MAXNETNODES		8

typedef enum
{
  CMD_SEND = 1,
  CMD_GET = 2

}
command_t;

//
// Network packet data.
//
typedef struct
{
  // High bit is retransmit request.
  unsigned checksum;
  // Only valid if NCMD_RETRANSMIT.
  byte retransmitfrom;
  byte starttic;
  byte player;
  byte numtics;

  ticcmd_t cmds[BACKUPTICS];
}
doomdata_t;

typedef struct setup_info_s
{
  byte version;
  byte skill;
  byte deathmatch;
  byte drone;
  gameflags_t setupflags;
  long random_seed;
  // variable length
  char startmap[1];
}
setup_info_t;

typedef struct
{
  unsigned checksum;
  byte retransmitfrom;
  byte starttic;
  byte player;
  byte numtics;

  setup_info_t info;
}
setupdata_t;

typedef struct
{
  // Supposed to be DOOMCOM_ID?
  long id;

  // DOOM executes an int to execute commands.
  short intnum;
  // Communication between DOOM and the driver.
  // Is CMD_SEND or CMD_GET.
  short command;
  // Is dest for send, set by get (-1 = no packet).
  short remotenode;

  // Number of bytes in doomdata to be sent
  short datalength;

  // Info common to all nodes.
  // Console is allways node 0.
  short numnodes;
  // Flag: 1 = no duplication, 2-5 = dup for slow nets.
  short ticdup;
  // Flag: 1 = send a backup tic in every packet.
  short extratics;
  // Flag: 1 = deathmatch.
  short deathmatch;
  // Flag: -1 = new game, 0-5 = load savegame
  short savegame;
  short episode;  // 1-3

  short map;  // 1-9

  short skill;  // 1-5

  // Info specific to this node.
  short consoleplayer;
  short numplayers;

  // These are related to the 3-display mode,
  //  in which two drones looking left and right
  //  were used to render two additional views
  //  on two additional computers.
  // Probably not operational anymore.
  // 1 = left, 0 = center, -1 = right
  short angleoffset;
  // 1 = drone
  short drone;

  // The packet data to be sent.
  doomdata_t data;

}
doomcom_t;

// The current time. Used by bot code.
extern int gametime;

// Create any new ticcmds and broadcast to other players.
void E_NetUpdate(void);

// Broadcasts special packets to other players
//  to notify of game exit
void E_QuitNetGame(void);

// Get the random seed to use for a game.
long E_NetGetRandomSeed(void);

//? how many ticks to run?
void E_TryRunTics(void);

// Sends a setup packet to sync settings globally.
void E_SendSetupPacket(int flags);

#endif
</t>
<t tx="T2543">@ignore

// Player Definition

#ifndef __E_PLAYER_H__
#define __E_PLAYER_H__

// The player data structure depends on a number
// of other structs: items (internal inventory),
// animation states (closely tied to the sprites
// used to represent them, unfortunately).
#include "p_weapon.h"

// In addition, the player is just a special
// case of the generic moving object/actor.
#include "p_mobj.h"

// Finally, for odd reasons, the player input
// is buffered within the player data struct,
// as commands per game tick.
#include "e_ticcmd.h"

#include "ddf_main.h"  // colmap.ddf stuff

// Networking and tick handling related.
#define BACKUPTICS 12

#define MAX_PLAYNAME  32

//
// Player states.
//
typedef enum
{
  // Playing or camping.
  PST_LIVE,

  // Dead on the ground, view follows killer.
  PST_DEAD,

  // Waiting to be respawned in the level.
  PST_REBORN
}
playerstate_t;

//
// Player internal flags, for cheats and debug.
//
typedef enum
{
  // No clipping, walk through barriers.
  CF_NOCLIP = 1,

  // No damage, no health loss.
  CF_GODMODE = 2,
}
cheat_t;

typedef struct
{
  // amount of ammo available
  int num;

  // maximum ammo carryable
  int max;
}
playerammo_t;

typedef enum
{
  // (for pending_wp only) no change is occuring
  WPSEL_NoChange = -2,

  // absolutely no weapon at all
  WPSEL_None = -1
}
weapon_selection_e;

//
// Extended player object info: player_t
//
typedef struct player_s
{
  // Linked list of in-game players.
  struct player_s *prev, *next;

  // player number.  Starts at 0.
  int pnum;

  // is this player currently playing ?
  // NOTE: when false, all fields below it are unused.
  boolean_t in_game;

  // actions to perform.  Comes either from the local computer or over
  // the network in multiplayer mode.
  ticcmd_t cmd;

  playerstate_t playerstate;
  
  // map object that this player controls.  Will be NULL outside of a
  // level (e.g. on the intermission screen).
  mobj_t *mo;

  // player's name
  char playername[MAX_PLAYNAME];

  // Determine POV,
  //  including viewpoint bobbing during movement.
  // Focal origin above r.z
  float_t viewz;

  // Base height above floor for viewz.  Tracks `std_viewheight' but
  // is different when squatting (i.e. after a fall).
  float_t viewheight;

  // Bob/squat speed.
  float_t deltaviewheight;

  // standard viewheight, usually 75% of height.
  float_t std_viewheight;

  // bounded/scaled total momentum.
  float_t bob;

  // Kick offset for vertangle (in mobj_t)
  float_t kick_offset;
  
  // This is only used between levels,
  // mo-&gt;health is used during levels.
  float_t health;

  // Armour points for each type
  float_t armours[NUMARMOUR];

  // Power ups. invinc and invis are tic counters.
  float_t powers[NUMPOWERS];

  // Set of keys held
  keys_e cards;

  // Frags, kills of other players.
  int frags;
  int totalfrags;

  // weapons, either an index into the player-&gt;weapons[] array, or one
  // of the WPSEL_* values.
  weapon_selection_e ready_wp;
  weapon_selection_e pending_wp;

  // -AJA- 1999/08/11: Now uses playerweapon_t.
  playerweapon_t weapons[MAXWEAPONS];

  // current weapon choice for each key (1..9 and 0).  Note: the
  // values are indexes into the `choices' array in the corresponding
  // weaponkey[] structure (i.e. NOT indexes into weaponinfo[]).
  int key_choices[10];
 
  // for status bar: which numbers to light up
  boolean_t avail_weapons[10];
  
  // ammunition, one for each ammotype_t (except AM_NoAmmo)
  playerammo_t ammo[NUMAMMO];

  // True if button down last tic.
  int attackdown;
  int secondatk_down;
  int usedown;

  // Bit flags, for cheats and debug.
  // See cheat_t, above.
  int cheats;

  // Refired shots are less accurate.
  int refire;

  // For intermission stats.
  int killcount;
  int itemcount;
  int secretcount;

  // For screen flashing (red or bright).
  int damagecount;
  int bonuscount;

  // Who did damage (NULL for floors/ceilings).
  mobj_t *attacker;

  // So gun flashes light up the screen.
  int extralight;
  boolean_t flash;

  // -AJA- 1999/07/10: changed for colmap.ddf.
  const colourmap_t *effect_colourmap;
  boolean_t effect_infrared;
  float_t effect_strength;

  // Overlay view sprites (gun, etc).
  pspdef_t psprites[NUMPSPRITES];

  // Current PSP for action
  int action_psp;

  // Implements a wait counter to prevent use jumping again
  // -ACB- 1998/08/09
  int jumpwait;

  // breathing support.  In air-less sectors, this is decremented on
  // each tic.  When it reaches zero, the player starts choking (which
  // hurts), and player drowns when health drops to zero.
  int air_in_lungs;
  boolean_t underwater;
  boolean_t swimming;
   
  // how many tics to grin :-)
  int grin_count;

  // used (and updated) by the status bar to gauge amount of pain
  float_t old_health;

  // how many tics player has been attacking (for rampage face)
  int attackdown_count;
  
  // status bar: used to choose which face to show
  int face_index;
  int face_count;

  // -AJA- 1999/08/10: This field is the state number which is
  // remembered for WEAPON_NOFIRE_RETURN when the player lets go of
  // the button.  -1 if not yet fired or after changing weapons.
  int remember_atk1;
  int remember_atk2;

  short consistency[BACKUPTICS];
  ticcmd_t netcmds[BACKUPTICS];
  int netnode;

  // This function will be called by P_PlayerThink to initialise
  // the ticcmd_t.
  void (*thinker)(const struct player_s *, void *data, ticcmd_t *dest);
  void *data;
  void (*level_init)(const struct player_s *, void *data);
}
player_t;

//
// INTERMISSION
// Structure passed e.g. to WI_Start(wb)
//
typedef struct
{
  boolean_t in;  // whether the player is in game

  // Player stats, kills, collected items etc.
  int skills;
  int sitems;
  int ssecret;
  int stime;
  int frags;
  int totalfrags;
}
wbplayerstruct_t;

typedef struct
{
  char *level;  // episode # (0-2)

  // previous and next levels, origin 0
  const mapstuff_t *last;
  const mapstuff_t *next;

  int maxkills;
  int maxitems;
  int maxsecret;
  int maxfrags;

  // the par time
  int partime;

  // index of this player in game
  int pnum;

  wbplayerstruct_t *plyr;

}
wbstartstruct_t;

// Player thinkers
void P_ConsolePlayerThinker(const player_t *p, void *data, ticcmd_t *dest);
void P_BotPlayerThinker(const player_t *p, void *data, ticcmd_t *dest);

// This is the only way to create a new player.
void P_AddPlayer(int pnum);

#endif
</t>
<t tx="T2544">@ignore

// Search Definition

#ifndef __E_SEARCH_H__
#define __E_SEARCH_H__

// QSORT routine  QuickSorts array in arr of type type, number of elements n
//  and stops when elements are cutoff sorted.  Then does an insertion sort
//  to complete data
// -ES- 2000/02/15 Removed iQSORT: Unneeded.
#define CUTOFF 10
#define QSORT(type, arr, n, cutoff)\
{                                                                       \
  int *stk;                                                             \
  type pivot;                                                           \
  type t;                                                               \
  int i, j, c, top;                                                     \
  unsigned int a, b;                                                    \
                                                                        \
  stk = Z_New(int, (n+1));                                              \
                                                                        \
  a = top = 0;                                                          \
  b = n - 1;                                                            \
                                                                        \
  while (1)                                                             \
  {                                                                     \
     while (b &gt; a + cutoff)                                             \
     {                                                                  \
       c = (a + b) / 2;                                                 \
       if (CMP(arr[b], arr[a]))                                                   \
       {                                                                \
          t = arr[a];                                                   \
          arr[a] = arr[b];                                              \
          arr[b] = t;                                                   \
       }                                                                \
       if (CMP(arr[c], arr[a]))                                                   \
       {                                                                \
          t = arr[a];                                                   \
          arr[a] = arr[c];                                              \
          arr[c] = t;                                                   \
       }                                                                \
       if (CMP(arr[c], arr[b]))                                                   \
       {                                                                \
          t = arr[c];                                                   \
          arr[c] = arr[b];                                              \
          arr[b] = t;                                                   \
       }                                                                \
                                                                        \
       pivot = arr[c];                                                  \
       arr[c] = arr[b-1];                                               \
       arr[b-1] = pivot;                                                \
                                                                        \
       i = a, j = b-1;                                                  \
       while (1)                                                        \
       {                                                                \
          do { i++; }                                                   \
          while (CMP(arr[i], arr[b-1]));                                          \
          do { j--; }                                                   \
          while (CMP(arr[b-1], arr[j]));                                          \
          if (j &lt; i)                                                    \
            break;                                                      \
          t = arr[i];                                                   \
          arr[i] = arr[j];                                              \
          arr[j] = t;                                                   \
       }                                                                \
                                                                        \
       pivot = arr[i];                                                  \
       arr[i] = arr[b-1];                                               \
       arr[b-1] = pivot;                                                \
                                                                        \
       if (j - a &gt; b - 1)                                               \
       {                                                                \
          stk[top++] = a;                                               \
          stk[top++] = j;                                               \
          a = i+1;                                                      \
       }                                                                \
       else                                                             \
       {                                                                \
          stk[top++] = i+1;                                             \
          stk[top++] = b;                                               \
          b = j;                                                        \
       }                                                                \
     }                                                                  \
                                                                        \
     if (!top)                                                          \
       break;                                                           \
     b = stk[--top];                                                    \
     a = stk[--top];                                                    \
   }                                                                    \
                                                                        \
   for (i = 1; i &lt; n; i++)                                              \
   {                                                                    \
     t = arr[i];                                                        \
     j = i;                                                             \
     while (j &gt;= 1 &amp;&amp; CMP(t, arr[j-1]))                                 \
     {                                                                  \
        arr[j] = arr[j-1];                                              \
        j--;                                                            \
     }                                                                  \
     arr[j] = t;                                                        \
   }                                                                    \
                                                                        \
   Z_Free(stk);                                                         \
}

#define MAPSORT(type, arr, map, n)                                      \
{                                                                       \
   type tmp;                                                            \
   int i, j, k;                                                         \
                                                                        \
   for (i = 0; i &lt; n; i++)                                              \
   {                                                                    \
      if (map[i] != i)                                                  \
      {                                                                 \
         tmp = arr[i];                                                  \
         k = i;                                                         \
         do                                                             \
         {                                                              \
            j = k;                                                      \
            k = map[j];                                                 \
            arr[j] = arr[k];                                            \
            map[j] = j;                                                 \
         } while (k != i);                                              \
         arr[j] = tmp;                                                  \
      }                                                                 \
   }                                                                    \
}

#define BSEARCH(n, pos)                                                 \
{                                                                       \
     int hi, mid;                                                       \
                                                                        \
     pos = 0;                                                           \
     hi = n-1;                                                          \
                                                                        \
     while (pos &lt;= hi)                                                  \
     {                                                                  \
        mid = (pos + hi) &gt;&gt; 1;                                          \
        if (CMP(mid))                                                   \
          pos = mid + 1;                                                \
        else                                                            \
          hi = mid - 1;                                                 \
     }                                                                  \
}

#endif
</t>
<t tx="T2545">@ignore

// Thinker Definition

#ifndef __E_THINK_H__
#define __E_THINK_H__

#endif // __E_THINK_H__
</t>
<t tx="T2546">@ignore

// EDGE Tic Command Definition

#ifndef __E_TICCMD_H__
#define __E_TICCMD_H__

#include "dm_type.h"

// The data sampled per tick (single player)
// and transmitted to other peers (multiplayer).
// Mainly movements/button commands per game tick,
// plus a checksum for internal state consistency.

typedef struct
{
  // vertical angle for mlook, /256 for slope
  signed char vertangle;

  // -MH- 1998/08/23 upward movement
  signed char upwardmove;

  // /32 for move
  signed char forwardmove;

  // /32 for move
  signed char sidemove;

  // *65536 for angle delta
  short angleturn;

  // checks for net game
  short consistency;

  byte chatchar;
  byte buttons;
  byte extbuttons;
}
ticcmd_t;

#endif
</t>
<t tx="T2547">@ignore

// Finale Definition

#ifndef __F_FINALE__
#define __F_FINALE__

#include "dm_type.h"
#include "e_event.h"
#include "p_mobj.h"

// Called by main loop.
boolean_t F_Responder(event_t * ev);

// Called by main loop.
void F_Ticker(void);

// Called by main loop.
void F_Drawer(void);

// -KM- 1998/11/25 Finales generalised.
void F_StartFinale(const finale_t * f, gameaction_t newaction);

#endif
</t>
<t tx="T2548">@ignore

// Game Handling Code

#ifndef __G_GAME__
#define __G_GAME__

#include "dm_defs.h"
#include "e_event.h"
#include "ddf_main.h"

//
// GAME
//
void G_DeathMatchSpawnPlayer(player_t *p);

void G_InitNew(skill_t skill, const mapstuff_t * map, long random_seed);

//
// Called by the Startup code &amp; M_Responder; A normal game
// is started by calling the beginning map. The level jump
// cheat can get us anywhere.
//
// -ACB- 1998/08/10 New DDF Structure, Use map reference name.
//
boolean_t G_DeferedInitNew(skill_t skill, const char *mapname,
    boolean_t warpopt);

void G_DeferedPlayDemo(const char *demo);

// Can be called by the startup code or M_Responder,
// calls P_SetupLevel or W_EnterWorld.
void G_LoadGame(int slot);

void G_DoLoadGame(void);

// Called by M_Responder.
void G_SaveGame(int slot, const char *description);

// Only called by startup code.
void G_RecordDemo(const char *name);

void G_BeginRecording(void);

void G_PlayDemo(const char *name);
void G_TimeDemo(const char *name);
boolean_t G_CheckDemoStatus(void);
void G_PlayerReborn(player_t *player);

void G_SetTurboScale(int scale);

// -KM- 1998/11/25 Added Time param
void G_ExitLevel(int time);
void G_SecretExitLevel(int time);
void G_ExitToLevel(char *name, int time);

void G_WorldDone(void);

void G_Ticker(void);
boolean_t G_Responder(event_t * ev);

void G_BuildTiccmd(ticcmd_t *cmd);

void G_ScreenShot(void);

boolean_t G_CheckWhenAppear(when_appear_e appear);
boolean_t G_CheckConditions(mobj_t *mo, condition_check_t *cond);
char *G_FileNameFromSlot(int slot);

#endif
</t>
<t tx="T2549">@ignore

// GUI Controls

#ifndef __GUI_CTLS_H__
#define __GUI_CTLS_H__

#include "gui_gui.h"
#include "v_screen.h"

// Standard gui controls.  (Need more!)

// Message box.  Displays a string in a box with an ok button
//    gui_t **g:  the gui subsystem to add to
//    gui_t *parent: the app to notify when the message box is closed.
//    int msg, int id:  When the app is closed, the parents responder will be passed
//            an event with type = msg, data1 = id.
//    char *string:  The string displayed in the message box.
gui_t *GUI_MSGStart(gui_t ** g, gui_t * parent, int msg, int id, char *string);

// Button. (Needs work)   Displays a push button.
//    gui_t **g:  The gui subsystem to add to
//    gui_t *parent: the app to notify when the button is clicked
//    int id: When the button is clicked, the parents responder will be passed an
//            event with type = gev_bnclick and data1 = id
gui_t *GUI_BTStart(gui_t ** g, gui_t * parent, int id, int x, int y, char *string);

// A progress bar, bar chart bar, health bar etc.
//    gui_t **g:  The gui subsystem to attach to
//    char *watch: The console variable to watch
//    int max: The maximum value the cvar is likely to get to.
//
gui_t *GUI_BARStart(gui_t ** g, char *watch, int max);

// A Drag control
//    This invisible control will send gev_drag messages to it's parent
//    when it is dragged.  Move and size it by sending it gev_move and
//    gev_size events.
gui_t *GUI_DRAGStart(gui_t ** g, gui_t * parent, int id);

// Writes the string to the screen.  Same as M_WriteText, but
// doesn't scale to 320x200.
void GUI_WriteText(screen_t * scr, int x, int y, char *string);

#endif
</t>
<t tx="T2550">@ignore

// GUI Definitions

#ifndef __GUI_GUI_H__
#define __GUI_GUI_H__

#include "dm_type.h"
#include "v_screen.h"

// This header should be included by all gui apps

// Input event types.
typedef enum
{
  // Base events (see d_event.h) so guievent_t can be used
  // as an extension of event_t
  gev_keydown,
  gev_keyup,
  gev_analogue,

  // Creation events
  gev_spawn,
  gev_destroy,
  gev_losefocus,

  // If a responder returns false in relation to these two
  // events, the system will handle them.
  gev_move,
  gev_size,

  // Sent to do stuff like drag
  gev_hover,

  // All gui controls send messages &gt;= 1000. So it is extendable
  gev_ctrl = 1000,
  gev_bnclick,
  gev_drag,

  // Events greater than gev_user are free for user applications
  gev_user = 10000
}
guievtype_t;

// Event structure.
typedef struct
{
  guievtype_t type;
  int data1;  // buttons (keys) / data2 axis
  int data2;  // analogue axis 1
  int data3;  // data4 axis
  int data4;  // analogue axis 2
}
guievent_t;

typedef struct gui_s
{
  // The id is essentially a user field.  Usually used to identify
  // controls in sub windows.  eg you create buttons with ids 0, 1...
  // and the buttons send their id numbers back when they are pushed,
  // so you know which button is clicked.
  int id;
  // The ticker function is where you do the main thinking of the application
  // If there is no ticker, set this field to NULL.  Remember that this is
  // not a real multitasking environment, so no big for loops please!
  // The parameter passed is a pointer to the structure, so it is called
  // (by the system as gui_t *gui;  gui-&gt;Ticker(gui);
  // Tickers are called 35 times per second.
  void (*Ticker) (struct gui_s *gui);
  // This function is used to respond to events like key presses and spawn
  // events.  Passes a pointer to the structure (see Ticker) and a pointer
  // to the event to process.  (Don't modify the event.) Set to NULL to
  // ignore all events.
   boolean_t(*Responder) (struct gui_s *gui, guievent_t * event);
  // Should draw the app to the screen.  Once again optional and passed
  // a pointer to the structure.
  void (*Drawer) (struct gui_s * gui);
  // This is a user pointer.  To make apps "thread safe" in this mock
  // gui, store all 'global' variables in a structure pointed to by this.
  // Otherwise, you can only have one instance of your app open at any one
  // time.
  void *process;
  // These variables store the position of your app on the screen.  You should
  // not draw outside these coordinates.
  int left, right, top, bottom;
  // The gui is stored as a circular linked list.
  struct gui_s *prev, *next;
  // The entire gui system is stored in a single gui_t*, which points to the
  // forground application.  This field points to that variable.  You can create
  // other guis, eg dialog boxes which consist of gui's (buttons, check boxes etc)
  // that are sub windows your window.  (Pheww!) (See message box?)
  struct gui_s **gui;
}
gui_t;

// This returns a pointer to the top level gui system.
gui_t **GUI_NULL(void);

// This initialises a gui_t * to be used as a gui.
// eg:  gui_t *gui;
//      GUI_Init(&amp;gui);
void GUI_Init(gui_t ** gui);

// Adds an application g to the gui.
void GUI_Start(gui_t ** gui, gui_t * g);

// Removes an application from it's gui
void GUI_Destroy(gui_t * g);

// Sets the foreground application
void GUI_SetFocus(gui_t ** gui, gui_t * g);

// Calls all the Tickers for the specified gui
void GUI_Ticker(gui_t ** gui);

// Sends an event to the specified gui.  Usually only the foreground
// application's responder is called.
boolean_t GUI_Responder(gui_t ** gui, guievent_t * e);

// Draws all the windows in the gui, using Painters' Algorithm
void GUI_Drawer(gui_t ** gui);

// Enables disables the mouse cursor.
boolean_t GUI_MainGetMouseVisibility(void);
void GUI_MainSetMouseVisibility(boolean_t visible);

// Sets the mouse lump
boolean_t GUI_SetMouse(char *name);

#ifdef CON_MAIN_H
// include the gui parts of con_main.h if con_main earlier has been included.
#include "con_main.h"
#endif

#endif
</t>
<t tx="T2551">@ignore

// GUI Main

#ifndef __GUI_MAIN_H__
#define __GUI_MAIN_H__

#include "dm_type.h"
#include "e_event.h"

// This function inits the GUI system (&amp;&amp; console)
boolean_t GUI_MainInit(void);

// This function calls the tickers for all gui apps.
void GUI_MainTicker(void);

// This function handles input to all guis.
boolean_t GUI_MainResponder(event_t * ev);

// This function draws all the guis to the screen
void GUI_MainDrawer(void);

// Reinits the gui system for a new resolution
void GUI_InitResolution(void);

#endif
</t>
<t tx="T2552">@ignore

// Heads-up-display library Code (header)

#ifndef __HULIB__
#define __HULIB__

// We are referring to patches.
#include "r_defs.h"
#include "w_image.h"

//
//  Font stuff
//

// -AJA- 2000/12/24: new typedef for font.  `H' wart to prevent
//       clashes with any libraries.
typedef struct H_font_s
{
  // name of font.  Not used yet.
  char name[32];
  
  // prefix for patch names, e.g. "STFCN".
  char prefix[10];
  
  // nominal width and height.  Characters can be larger or smaller
  // than this, but these values give a good guess for formatting
  // purposes.
  int width, height;
 
  // range of characters in the font.  Charset is IBM cp437.
  int first_ch;
  int last_ch;
  
  // images for each character.  Missing characters will be filled
  // with a default image.
  const image_t ** images;
}
H_font_t;

#define HFONT_GET_CH(font,ch)  \
    ((font)-&gt;images[MAX((font)-&gt;first_ch, MIN((font)-&gt;last_ch, (ch))) -  \
     (font)-&gt;first_ch])


#define HU_MAXLINES		4
#define HU_MAXLINELENGTH	80

//
// Typedefs of widgets
//

// Text Line widget

typedef struct
{
  // position of top/left corner of text
  int x, y;

  // font
  const H_font_t *font;

  // line of text
  unsigned char ch[HU_MAXLINELENGTH + 1];

  // current line length
  int len;

  // whether this line needs to be udpated
  int needsupdate;

  // centre text horizontally, around x.
  boolean_t centre;
}
hu_textline_t;

// Scrolling Text window widget
//  (child of Text Line widget)

typedef struct
{
  // text lines to draw
  hu_textline_t L[HU_MAXLINES];

  // height in lines
  int h;

  // current line number
  int curline;

  // pointer to boolean_t stating whether to update window
  boolean_t *on;
  boolean_t laston;  // last value of *-&gt;on.
}
hu_stext_t;

// Input Text Line widget
//  (child of Text Line widget)

typedef struct
{
  // text line to input on
  hu_textline_t L;

  // left margin past which I am not to delete characters
  int margin;

  // pointer to boolean_t stating whether to update window
  boolean_t *on;
  boolean_t laston;  // last value of *-&gt;on;
}
hu_itext_t;

//
// Widget creation, access, and update routines
//

// initialises heads-up widget library
void HL_Init(void);

//
// Text Line routines
//

// clear a line of text
void HL_ClearTextLine(hu_textline_t * t);

void HL_InitTextLine(hu_textline_t * t, int x, int y, 
    const H_font_t *font);

// returns success
boolean_t HL_AddCharToTextLine(hu_textline_t * t, char ch);

// returns success
boolean_t HL_DelCharFromTextLine(hu_textline_t * t);

// draws tline
void HL_DrawTextLine(hu_textline_t * l, boolean_t drawcursor);

// erases text line
void HL_EraseTextLine(hu_textline_t * l);

//
// Scrolling Text window widget routines
//

// initialise new stext
void HL_InitSText(hu_stext_t * s, int x, int y, int h, 
    const H_font_t *font, boolean_t * on);

// add a new line
void HL_AddLineToSText(hu_stext_t * s);

// add message to stext
void HL_AddMessageToSText(hu_stext_t * s, 
    const unsigned char *prefix, const unsigned char *msg);

// draws stext
void HL_DrawSText(hu_stext_t * s);

// erases all stext lines
void HL_EraseSText(hu_stext_t * s);

// Input Text Line widget routines
void HL_InitIText(hu_itext_t * it, int x, int y, 
    const H_font_t *font, boolean_t * on);

// enforces left margin
void HL_DelCharFromIText(hu_itext_t * it);

// enforces left margin
void HL_EraseLineFromIText(hu_itext_t * it);

// resets line and left margin
void HL_ResetIText(hu_itext_t * it);

// left of left-margin
void HL_AddPrefixToIText(hu_itext_t * it, const unsigned char *str);

// whether eaten
boolean_t HL_KeyInIText(hu_itext_t * it, unsigned char ch);

void HL_DrawIText(hu_itext_t * it);

// erases all itext lines
void HL_EraseIText(hu_itext_t * it);

// -ACB- 1998/06/10
void HL_DrawTextLineAlpha(hu_textline_t * l, boolean_t drawcursor, 
    const colourmap_t *colmap, fixed_t alpha);

#define HL_DrawTextLineTrans(L,DC,TR)  \
    HL_DrawTextLineAlpha(L,DC,TR,FRACUNIT)


// hu_font size routines
int HL_CharWidth(const H_font_t *font, int c);
int HL_TextMaxLen(int max_w, const unsigned char *str);
int HL_StringWidth(const unsigned char *string);
int HL_StringHeight(const unsigned char *string);

void HL_WriteText(int x, int y, const unsigned char *string);
void HL_WriteTextTrans(int x, int y, const colourmap_t *colmap, 
    const unsigned char *string);

#endif  // __HULIB__
</t>
<t tx="T2553">@ignore

// Head Up Display

#ifndef __HU_STUFF_H__
#define __HU_STUFF_H__

#include "e_event.h"
#include "hu_lib.h"
#include "r_defs.h"

extern int showMessages;

// Globally visible constants.
//
#define HU_FONTSTART	'!'  // the first font characters
#define HU_FONTEND	255  // the last font characters

// Calculate # of glyphs in font.
#define HU_FONTSIZE	(HU_FONTEND - HU_FONTSTART + 1)

#define HU_BROADCAST	5

#define HU_MSGREFRESH	KEYD_ENTER
#define HU_MSGX		0
#define HU_MSGY		0
#define HU_MSGWIDTH	64  // in characters
#define HU_MSGHEIGHT	1  // in lines

#define HU_MSGTIMEOUT	(4*TICRATE)

extern H_font_t hu_font;
extern boolean_t chat_on;
extern boolean_t message_dontfuckwithme;

//
// HEADS UP TEXT
//

boolean_t HU_Init(void);
void HU_Start(void);

boolean_t HU_Responder(event_t * ev);

void HU_StartMessage(const char *msg);

void HU_Ticker(void);
void HU_Drawer(void);
void HU_QueueChatChar(char c);
char HU_DequeueChatChar(void);
void HU_Erase(void);

#endif
</t>
<t tx="T2554">@ignore

// System Specific Header

// -ACB- 1999/09/19 Written

#ifndef __SYSTEM_SPECIFIC_DEFS__
#define __SYSTEM_SPECIFIC_DEFS__

// NULL port
// Template for new ports. It is as close to ANSI C as possible, and comments
// have been added to show what code you have to add to make it work.
#if 0

//typedef long long Int64;

//
// Define USE_INT64 if the system supports 64 bit integers.
//#define USE_INT64
//
typedef float float_t;

//
// define FLOAT_IEEE_754 if the float is IEEE_754 compliant, i.e. 1 bit
// sign + 8 bits exponent + 23 bits mantissa.
//
//#define FLOAT_IEEE_754
typedef enum { false, true } boolean_t;

//
// Add any system includes here, e.g.
// #include &lt;stdio.h&gt;
//

#define EDGECONFIGFILE "EDGE.CFG"
#define EDGEHOMEDIR    "EDGE"
#define EDGEWADDIR     "EDGEWADDIR"
#define EDGEWADEXT     "wad"
#define EDGEGWAEXT     "gwa"
#define REQUIREDWAD    "EDGE"

//
// This is the default directory separator. It is '\\' in DOS, and '/' on
// most other systems.
//
#define DIRSEPARATOR '/'

// If GCC is used, this one is defined as __attribute__((a)).
#define GCCATTR(a)

//
// INLINE can be defined to a keyword which hints the compiler to inline a
// function.
//
#define INLINE

// See m_inline.h for usage. This is the ANSI C compliant definition.
#define EDGE_INLINE(decl, body) extern decl;

//
// TmpMalloc is a memory allocater which can be used for temporary allocations.
// Memory allocated with I_TmpMalloc has to be freed with I_TmpFree before the
// procedure containing the I_TmpMalloc call exits. Its advantage is that it
// gets much faster on all systems that support alloca.
//
#define I_TmpMalloc(size) Z_Malloc(size)
#define I_TmpFree(ptr) Z_Free(ptr)

// If memmove is not optimal on your system, you can use your own I_MoveData,
// which should have exactly the same type as memcpy, and should declared here.
#define I_MoveData memmove

// include headers to compensate for missing standard functions.
#include ".\null\i_compen.h"
#include "i_system.h"

#endif // NULL port

// DOS GCC
#ifdef DJGPP

typedef long long Int64;
#define USE_INT64
typedef float float_t;
#define FLOAT_IEEE_754
typedef enum { false, true } boolean_t;

#include &lt;ctype.h&gt;
#include &lt;dirent.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;values.h&gt;
#include &lt;sys\stat.h&gt;

#define EDGECONFIGFILE "EDGE.CFG"
#define EDGEHOMEDIR    "EDGE"
#define EDGEWADDIR     "EDGEWADDIR"
#define EDGEWADEXT     "wad"
#define EDGEGWAEXT     "gwa"
#define REQUIREDWAD    "EDGE"

#define DIRSEPARATOR '\\'

#define GCCATTR(a) __attribute__((a))
#define INLINE inline
#define EDGE_INLINE(decl, body) extern decl ; extern inline decl body

//
// TmpMalloc is a memory allocater which can be used for temporary allocations.
// Memory allocated with TmpMalloc has to be freed with TmpFree before the
// procedure containing the TmpMalloc call exits. Its advantage is that it
// gets much faster on all systems that support alloca.
//
#define I_TmpMalloc(size) alloca(size)
#define I_TmpFree(ptr) do { } while (0)

#define I_MoveData memmove

#include ".\djgpp\i_compen.h"
#include "i_system.h"

#endif

// Microsoft Visual C++ V6.0 for Win32
#ifdef WIN32 
#ifdef _GATESY_

#define WIN32_LEAN_AND_MEAN

typedef __int64 Int64;
typedef float float_t;
#define FLOAT_IEEE_754

typedef enum { false, true } boolean_t;

#include &lt;windows.h&gt;

#include &lt;ctype.h&gt;
#include &lt;direct.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;io.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;
#include &lt;malloc.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;sys\stat.h&gt;
#include &lt;time.h&gt;

#include &lt;gl/gl.h&gt;

#define EDGECONFIGFILE "EDGE.CFG"
#define EDGEHOMEDIR    "EDGE"
#define EDGEWADDIR     "EDGEWADDIR"
#define EDGEWADEXT     "wad"
#define EDGEGWAEXT     "gwa"
#define REQUIREDWAD    "EDGE"

#define DIRSEPARATOR '\\'

#define NAME        "The EDGE Engine"
#define OUTPUTNAME  "EDGECONSOLE"
#define TITLE       "EDGE Engine"
#define OUTPUTTITLE "EDGE System Console"

// Access() define values. Nicked from DJGPP's &lt;unistd.h&gt;
#define R_OK    0x02
#define W_OK    0x04

// PI define. Nicked from DJGPP's &lt;math.h&gt;
#define M_PI 3.14159265358979323846

#define GCCATTR(a)
#define INLINE _inline 
#define EDGE_INLINE(decl, body) extern decl;

#define I_TmpMalloc(size) alloca(size)
#define I_TmpFree(ptr) do { } while (0)

#define MAXPATH _MAX_PATH

#define I_MoveData memmove

#include ".\win32\i_compen.h"
#include "i_system.h"

#endif
#endif

// Borland C++ V5.5 for Win32
#ifdef WIN32 
#ifdef __BORLANDC__

#define STRICT
#define _WINDOWS
#define WIN32_LEAN_AND_MEAN

typedef __int64 Int64;
typedef float float_t;
#define FLOAT_IEEE_754

typedef enum { false, true } boolean_t;

#include &lt;windows.h&gt;

#include &lt;ctype.h&gt;
#include &lt;direct.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;io.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;
#include &lt;malloc.h&gt;
#include &lt;mem.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys\stat.h&gt;
#include &lt;time.h&gt;

#include &lt;gl/gl.h&gt;

#define EDGECONFIGFILE "EDGE.CFG"
#define EDGEHOMEDIR    "EDGE"
#define EDGEWADDIR     "EDGEWADDIR"
#define EDGEWADEXT     "wad"
#define EDGEGWAEXT     "gwa"
#define REQUIREDWAD    "EDGE"

#define DIRSEPARATOR '\\'

#define NAME        "EDGE"
#define OUTPUTNAME  "EDGECONSOLE"
#define TITLE       "EDGE Engine"
#define OUTPUTTITLE "EDGE System Console"

// Access() define values. Nicked from DJGPP's &lt;unistd.h&gt;
#define R_OK    0x02
#define W_OK    0x04

// PI define. Nicked from DJGPP's &lt;math.h&gt;
#define M_PI 3.14159265358979323846

#define GCCATTR(a)
#define INLINE 
#define EDGE_INLINE(decl, body) extern decl;

#define I_TmpMalloc(size) alloca(size)
#define I_TmpFree(ptr) do { } while (0)

#define I_MoveData memmove

#include ".\win32\i_compen.h"
#include "i_system.h"

#endif
#endif

// LINUX GCC
#ifdef LINUX

typedef long long Int64;
typedef float float_t;
#define FLOAT_IEEE_754
typedef enum { false, true } boolean_t;

#include &lt;ctype.h&gt;
#include &lt;dirent.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;values.h&gt;
#include &lt;sys/stat.h&gt;


#ifdef USE_GL
#include &lt;GL/gl.h&gt;
#endif

#define EDGECONFIGFILE "edge.cfg"
#define EDGEHOMEDIR    "HOME"
#define EDGEWADDIR     "EDGEWADDIR"
#define EDGEWADEXT     "wad"
#define EDGEGWAEXT     "gwa"
#define REQUIREDWAD    "edge"

#define DIRSEPARATOR '/'

#define NAME        "EDGE"
#define OUTPUTNAME  "EDGECONSOLE"
#define TITLE       "EDGE Engine"
#define OUTPUTTITLE "EDGE Engine console"

#define GCCATTR(a) __attribute__((a))
#define INLINE inline
#define EDGE_INLINE(decl, body) extern inline decl body

#define I_TmpMalloc(size) alloca(size)
#define I_TmpFree(ptr) do { } while (0)

#define I_MoveData memmove

#include "i_system.h"
#include "linux/i_compen.h"

#endif // LINUX GCC

// BeOS GCC
#ifdef BeOS

typedef long long Int64;
typedef float float_t;
#define FLOAT_IEEE_754
typedef enum { false, true } boolean_t;

#include &lt;ctype.h&gt;
#include &lt;dirent.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;


#ifdef USE_GL
#include &lt;GL/gl.h&gt;
#endif

#define EDGECONFIGFILE "edge.cfg"
#define EDGEHOMEDIR    "HOME"
#define EDGEWADDIR     "EDGEWADDIR"
#define EDGEWADEXT     "wad"
#define EDGEGWAEXT     "gwa"
#define REQUIREDWAD    "edge"

#define DIRSEPARATOR '/'

#define NAME        "EDGE"
#define OUTPUTNAME  "EDGECONSOLE"
#define TITLE       "EDGE Engine"
#define OUTPUTTITLE "EDGE Engine console"

#define GCCATTR(a) __attribute__((a))
#define INLINE inline
#define EDGE_INLINE(decl, body) extern inline decl body

#define I_TmpMalloc(size) alloca(size)
#define I_TmpFree(ptr) do { } while (0)

#define I_MoveData memmove

#include "i_system.h"
#include "beos/b_compen.h"

#endif // BeOS GCC

#ifdef LEAK_HUNT

#undef I_TmpMalloc
#undef I_TmpFree

#ifdef __GNUC__

//
// use __FUNCTION__: This will check that the corresponding Z_TmpFree is done
// within the function.
//
#define I_TmpMalloc(size) Z_RegisterMalloc(Z_Malloc2(size), __FUNCTION__, __LINE__)
#define I_TmpFree(ptr) Z_Free(Z_UnRegisterTmpMalloc(ptr, __FUNCTION__))

#else

//
// Can not use __FUNCTION__, so we can only check whether it is freed within
// the same file
//
#define I_TmpMalloc(size) Z_RegisterMalloc(Z_Malloc2(size), __FILE__, __LINE__)
#define I_TmpFree(ptr) Z_Free(Z_UnRegisterTmpMalloc(ptr, __FILE__))

#endif

#endif

#endif /*__SYSTEM_SPECIFIC_DEFS__*/


</t>
<t tx="T2555">@ignore

// Platform Interface (EPI) Header

#ifndef __I_SYSTEM__
#define __I_SYSTEM__

#include "dm_defs.h"
#include "dm_type.h"
#include "dm_state.h"
#include "e_event.h"
#include "e_ticcmd.h"

//--------------------------------------------------------
//  SYSTEM functions.
//--------------------------------------------------------
//
// -ACB- 1999/09/20 Removed system specific attribs.

boolean_t I_SystemStartup(void);
// This routine is responsible for getting things off the ground, in
// particular calling all the other platform initialisers (i.e.
// I_StartupControl, I_StartupGraphics, I_StartupMusic and
// I_StartupSound).  Can do whatever else the platform code needs to
// do.  Returns true for success, otherwise false (in which case any
// partially completed actions should be undone, e.g. freeing all
// resources obtained).

void I_EDGELoop(void);
// This is called by EDGE to begin the main engine loop, and is not
// expected to return.  It must call E_EDGELoopRoutine() to perform a
// single loop in the system, which processes events, updates the play
// simulation, keeps sound and music playing, and most importantly
// renders a single frame of graphics.

void I_Printf(const char *message,...) GCCATTR(format(printf, 1, 2));
// The generic print function.  If in text mode, the message should be
// displayed on the text mode screen.  This function should also call
// L_WriteDebug() and CON_Printf().

void I_PutTitle(const char *title);
// This function should clear the text mode screen (or window), and
// write the given title in a banner at the top (in a stand-out way,
// e.g. bright white on a red background).

void I_Error(const char *error,...) GCCATTR(format(printf, 1, 2));
// The error function.  All fatal errors call I_Error().  This
// function should shut things down (e.g. via I_SystemShutdown),
// display the error message to the user (and possibly debugging info,
// like a traceback) and finally exit the program (e.g. by calling
// I_CloseProgram).

void I_DisplayExitScreen(void);
// Displays the exit screen on the text mode screen (or window).  The
// text typically comes from the "ENDOOM" lump in the IWAD.

void I_SystemShutdown(void);
// The opposite of the I_SystemStartup routine.  This will shutdown
// everything running in the platform code, by calling the other
// termination functions (I_ShutdownSound, I_ShutdownMusic,
// I_ShutdownGraphics and I_ShutdownControl), and doing anything else
// the platform code needs to (e.g. freeing all other resources).

void I_CloseProgram(int exitnum) GCCATTR(noreturn);
// Exit the program immediately, using the given `exitnum' as the
// program's exit status.  This is the very last thing done, and
// I_SystemShutdown() is guaranteed to have already been called.

void I_TraceBack(void);
// Aborts the program, and displays a traceback if possible (which is
// useful for debugging).  The system code should check for the
// "-traceback" option, and when present call this routine instead of
// I_CloseProgram() whenever a fatal error occurs.

boolean_t I_Access(const char *filename);
// Returns true if the given file or directory exists.  For files it
// should check if it readable.

char *I_PreparePath(const char *path);
// Prepares the end of the path name, so it will be possible to
// concatenate a DIRSEPARATOR and a file name to it.  Allocates and
// returns the new string.  Doesn't fail.

boolean_t I_PathIsAbsolute(const char *path);
// Returns true if the path should be treated as an absolute path,
// otherwise false.

boolean_t I_PathIsDirectory(const char *path);
// Returns true if the given path refers to a directory, otherwise
// false (e.g. the path is a file, _or_ doesn't exist).

void I_Warning(const char *warning,...) GCCATTR(format(printf, 1, 2));
// Writes a warning to the console and the debug file (if any).  This
// function should call CON_Printf().


typedef struct i_time_s
{
  byte day;
  byte month;
  short year;
  byte hours;
  byte minutes;
  byte secs;
}
i_time_t;

boolean_t I_GetModifiedTime(const char *filename, i_time_t *time);
// -ACB- 2000/06/05 The returns the time of when the filename passed
// was modified.

//--------------------------------------------------------
//  ASM functions.
//--------------------------------------------------------
//
// -ES- 1999/10/30 i_asm.c

void I_CheckCPU(void);
// Determines the CPU type that EDGE is running under, and possibly
// selects some routines (e.g. column drawers) that are better
// optimised for the detected CPU.

void I_RegisterAssembler(void);
void I_PrepareAssembler(void);


//--------------------------------------------------------
//  INPUT functions.
//--------------------------------------------------------
//
// -ACB- 1999/09/19 moved from I_Input.H

void I_StartupControl(void);
// Initialises all control devices (i.e. input devices), such as the
// keyboard, mouse and joysticks.  Should be called from
// I_SystemStartup() -- the main code never calls this function.

void I_ControlGetEvents(void);
// Causes all control devices to send their events to the engine via
// the E_PostEvent() function.

void I_CalibrateJoystick(int ch);
// Something for calibrating a joystick -- not currently used.

void I_ShutdownControl(void);
// Shuts down all control devices.  This is the opposite of
// I_StartupControl().  Should be called from I_SystemShutdown(), the
// main code never calls this function.

long I_PureRandom(void);
// Returns a fairly random value, used as seed for EDGE's internal
// random engine.  If this function would return a constant value,
// everything would still work great, except that random events before
// the first tic of a level (like random RTS spawn) would be
// predictable.

int I_GetTime(void);
// Returns a value that increases monotonically over time.  The value
// should increase by TICRATE every second (TICRATE is currently 35).
// The starting value is not significant.

unsigned long I_ReadMicroSeconds(void);
// Like I_GetTime(), this function returns a value that increases
// monotonically over time, but in this case the value increases by
// 1000000 every second (i.e. each unit is 1 microsecond).  Since this
// value will overflow regularly (assuming `long' is 32 bits), the
// caller should check for this situation.

extern unsigned long microtimer_granularity;
// This variable specifies the granularity of the I_ReadMicroSeconds()
// function.  It is the minimum difference (other than 0) that any two
// calls to I_ReadMicroSeconds() will have.


//--------------------------------------------------------
//  MUSIC functions.
//--------------------------------------------------------
//
// -ACB- 1999/09/19 moved from I_Music.H

extern boolean_t nomusic;
// This variable enables/disables music.  Initially false, it is set
// to true by the "-nomusic" option.  Can also be set to true by the
// platform code when no working music device is found.

typedef struct i_music_info_s
{
  enum
  {
    IMUSF_DATA,
    IMUSF_FILE,
    IMUSF_LUMP,
    IMUSF_CD
  }
  format;

  union
  {
    struct { void *ptr; int size; } data;
    struct { char *name; } file;
    struct { int handle; int pos; int size; } lump;
    struct { int track; } cd;
  }
  info;
}
i_music_info_t;
// Struct for setting up music playback. This 
// is here because it is an interface between engine and EPI Code.

boolean_t I_StartupMusic(void *sysinfo);
// Initialises the music system.  Returns true if successful,
// otherwise false.  (You should set "nomusic" to true if it fails).
// The main code never calls this function, it should be called by
// I_SystemStartup(), and can be passed some platform-specific data
// via the `sysinfo' parameter.

int I_MusicPlayback(i_music_info_t* musdat, int type, boolean_t looping);
// Starts music playing using the 'i_music_info_t' for info.
//
// Returns an integer handle that is used to refer to the music (in
// the other functions below), or -1 if an error occurred.  Note: any
// previously playing music should be killed (via I_MusicKill) before
// calling this function.

void I_MusicPause(int *handle);
// Pauses the music.

void I_MusicResume(int *handle);
// Resumes the music after being paused.

void I_MusicKill(int *handle);
// You can't stop the rock!!  This does.

void I_SetMusicVolume(int *handle, int volume);
// Sets the music's volume.  The volume is in the range 0 to 15, from
// quietest to loudest.

void I_MusicTicker(int *handle);
// Called once in a while.  Should keep the music going.

void I_ShutdownMusic(void);
// Shuts down the music system.  This is the opposite to
// I_StartupMusic().  Must be called by I_SystemShutdown(), the main
// code never calls this function.

char *I_MusicReturnError(void);
// Returns an error message string that describes the error from the
// last music function that failed.  It may return an empty string if
// no errors have yet occurred, but never NULL.  The message is not
// cleared.


//--------------------------------------------------------
//  SOUND functions.
//--------------------------------------------------------
//
// -ACB- 1999/09/20 Moved from I_Sound.H

extern boolean_t nosound;
// This variable enables/disables sound.  Initially false, it is set
// to true by the "-nosound" option.  Can also be set to true by the
// platform code when no working sound device is found.

boolean_t I_StartupSound(void *sysinfo);
// Initialises the sound system.  Returns true if successful,
// otherwise false if something went wrong (NOTE: you must set nosound
// to false when it fails).   The main code never calls this function,
// it should be called by I_SystemStartup(), and can be passed some
// platform-specific data via the `sysinfo' parameter.

boolean_t I_LoadSfx(const unsigned char *data, unsigned int length, 
      unsigned int freq, unsigned int handle);
// Loads the given `handle' with the specified sound data.  Handle is
// a small integer value from 0 onwards.  If no such handle exists
// then it is created.  The handle must not already contain any sound
// data.  The data must be copied, e.g. into memory that the sound
// device can use.  Returns true if successful, otherwise false.
//
// The data format is unsigned, i.e. 0x80 is the zero point, ranging
// upto 0xFF for the peaks, and down to 0x00 for the valleys.  The
// sound data is also mono.  There is no support for 16-bit or stereo
// sounds yet.

boolean_t I_UnloadSfx(unsigned int handle);
// Unloads the sound data for the given handle, previously loaded via
// I_LoadSfx().  This frees the sound data.  Returns true on success,
// otherwise false.

int I_SoundPlayback(unsigned int handle, int pan, int vol, boolean_t looping);
// Starts the sound with the given handle playing, using the
// paramaters for panning, volume and looping.  Pan ranges from 0
// (hard left) to 128 (middle) to 255 (hard right).  Volume ranges
// from 0 (silent) to 255 (loudest).
//
// Returns the channel ID where the sound is played, which is used to
// refer to the sound in the other functions below.  If something goes
// wrong, especially when there are no free channels, then -1 is
// returned.

boolean_t I_SoundAlter(unsigned int chanid, int pan, int vol);
// Alters the parameters of a currently playing sound.  Returns true
// if successful, otherwise false.

boolean_t I_SoundCheck(unsigned int chanid);
// Checks that the given sound is still playing (i.e. has not reached
// the end yet), and returns true if it is, otherwise false.

boolean_t I_SoundPause(unsigned int chanid);
// Pauses the sound on the specified channel.  Returns true on
// success, otherwise false.

boolean_t I_SoundResume(unsigned int chanid);
// Resumes the previously paused sound on the specified channel.
// Returns true on success, otherwise false.

boolean_t I_SoundStopLooping(unsigned int chanid);
// Stops the sound on this channel looping

boolean_t I_SoundKill(unsigned int chanid);
// Kills a sound on the specified channel that was started with
// I_SoundPlayback(), and frees the channel to be used for future
// sound playbacks.  Note that this function must be called even if
// the sound finished played (i.e. I_SoundCheck() == false).  Returns
// true on success, otherwise false.

void I_SoundTicker(void);
// Called every tic to keep the sounds playing.

void I_ShutdownSound(void);
// Shuts down the sound system.  This is the companion function to
// I_StartupSound().  This must be called by I_SystemShutdown(), the
// main code never calls this function.

const char *I_SoundReturnError(void);
// Returns an error message string that describes the error from the
// last sound function that failed.  It will return an empty string if
// no errors have yet occurred, but never NULL.  This function may
// clear the error message.


//--------------------------------------------------------
//  NETWORKING functions.
//--------------------------------------------------------
//
// -ACB- 1999/09/20 Moved from I_Net.H

void I_InitNetwork(void);
// Initialise the platform's networking code.  Not currently used.
// Note well that networking in EDGE is not currently implemented, and
// if it ever does get implemented then this interface is likely to
// change significantly.

void I_NetCmd(void);
// Send or receive a network command packet.  Not currently used (but
// must be defined).


//--------------------------------------------------------
//  VIDEO functions.
//--------------------------------------------------------
//
// -ACB- 1999/09/20 Moved from I_Video.H

// Truecolor information struct.  The masks are non-shifted values and
// can be used directly (e.g. 0xF800).  The shifts are right shifts
// (i.e. use VAL &lt;&lt; SHIFT).  The masks are always contiguous (no
// missing bits).  Grey_mask is the value to AND with a pixel datum to
// make it pure grey (e.g. 0xFFDF on RGB 5:6:5 mode).
typedef struct truecol_info_s
{
  int red_bits, green_bits, blue_bits;
  int red_shift, green_shift, blue_shift;
  long red_mask, green_mask, blue_mask;
  long grey_mask;
}
truecol_info_t;

// Screen mode information.
typedef struct screenmode_s
{
  int width;
  int height;
  int depth;
  boolean_t windowed;
}
screenmode_t;

void I_StartupGraphics(void);
// Initialises the graphics system.  This should be called by
// I_SystemStartup(), the main code never calls this function
// directly.  This function should determine what video modes are
// available, and call V_AddAvailableResolution() for them.

void I_SetPalette(byte palette[256][3]);
// Sets the palette to the given set of colours.  Only called for
// 8-bit mode.  The order of each triplet is: red, green, blue.  This
// routine must apply the current gamma level to the colours before
// setting the hardware palette.

void I_StartFrame(void);
// Called to prepare the screen for rendering (if necessary).

void I_FinishFrame(void);
// Called when the current frame has finished being rendered.  This
// routine typically copies the screen buffer to the video memory.  It
// may also handle double/triple buffering here.

void I_WaitVBL(int count);
// Waits until the video card is in Vertical Blanking.  The count
// parameter is the number of frames to wait for (1 means this very
// frame).  This function may do nothing if VBL information is not
// available on the platform.

long I_Colour2Pixel(byte palette[256][3], int col);
// Converts an indexed colour (0 to 255) into a pixel datum that could
// be written directly into the framebuffer, and returns it.  On 8-bit
// mode, it just returns `col'.  On hicolor/truecolor modes, it should
// look up the colour in the given palette, and convert the RGB colour
// into the correct pixel datum.  Used for translucency, etc..

void I_GetTruecolInfo(truecol_info_t *info);
// Returns the truecolor information for the current mode.

boolean_t I_SetScreenSize(screenmode_t *mode);
// Tries to set the video card to the given mode (or open a window).
// If there already was a valid mode (or open window), this call
// should replace it.  The previous contents (including the palette)
// is assumed to be lost.  The global variable SCREENPITCH must be set
// to a valid value (typically by calling the V_GetDepth() routine).
//
// This routine must also initialise a screen_t structure (typically
// static) with valid values and set the global variable `main_scr' to
// be a sub-screen of this (i.e. via the V_CreateSubScreen() routine).
//
// Returns true if successful, otherwise false.  The platform is free
// to select a working mode if the given mode was not possible, in
// which case the values of the global variables SCREENWIDTH,
// SCREENHEIGHT, SCREENPITCH and SCREENBITS must be updated.

void I_ShutdownGraphics(void);
// Shuts down the graphics system.  This is the companion function to
// I_StartupGraphics.  Note that this should be called by
// I_SystemStartup(), the main code never calls this function.


//--------------------------------------------------------
//  ASSERTION macros.
//--------------------------------------------------------

// -ES- 2000/02/07 DEV_ASSERT fails if the condition is false.
// The second parameter is the entire I_Error argument list, surrounded
// by parentheses (which makes it possible to use an arbitrary number of
// parameters even without GCC)
#ifdef DEVELOPERS
#define DEV_ASSERT(cond, arglist)  \
    ((cond)?(void) 0 : I_Error arglist)
#else
#define DEV_ASSERT(cond, arglist)  ((void) 0)
#endif

// -AJA- 2000/02/13: variation on a theme...
#ifdef DEVELOPERS
#define DEV_ASSERT2(cond)  \
    ((cond)? (void)0:I_Error("Assertion `%s' failed at line %d of %s.\n",  \
         #cond , __LINE__, __FILE__))
#else
#define DEV_ASSERT2(cond)  ((void) 0)
#endif

#ifdef DEVELOPERS
#define CHECKVAL(x) \
  (((x)!=0)?(void)0:I_Error("'" #x "' Value Zero in %s, Line: %d",__FILE__,__LINE__))
#else
#define CHECKVAL(x)  do {} while(0)
#endif

void L_WriteDebug(const char *message,...) GCCATTR(format(printf, 1, 2));

// TEMP: another temporary "common lib" thing.
int L_ConvertToDB(int volume, int min, int max);

#endif // __I_SYSTEM__
</t>
<t tx="T2556">@ignore
#ifndef __L_EPI_H__
#define __L_EPI_H__

//
// Engine links
//

void ENGINE_Main(void);

//
// From l_main.c
//

typedef void shutdown_f(void *data);
typedef void text_receiver_f(const char *str);

void L_Startup(void);
void L_RegisterShutdownRoutine(shutdown_f *f, void *data);
void L_Shutdown(void);
void L_Error(const char *message, ...);

//
// From l_mem.c
//

typedef enum
{
  L_UrgencyLow     = 1,
  L_UrgencyMedium  = 2,
  L_UrgencyHigh    = 3,
  L_UrgencyExtreme = 4
}
flusher_urgency_e;

// A cache flusher is a function that can find and free unused memory.
typedef void cache_flusher_f(flusher_urgency_e urge);

void L_RegisterCacheFlusher(cache_flusher_f *f);
void L_UnregisterCacheFlusher(cache_flusher_f *f);
void *L_Calloc2(int size);
void *L_Malloc2(int size);
void *L_ReMalloc2(void *ptr, int size);
void L_Free(void *ptr);
void L_CheckHeap(void);
int L_FreeMemory(int level);
int L_UsedMemory(int level);

void L_InitMemorySystem(void);
void L_ShutdownMemorySystem(void);

// -ES- 1999/12/16 Leak Hunt
#ifdef LEAK_HUNT
void *L_RegisterMalloc(void *ptr, const char *file, int row);
void *L_UnRegisterTmpMalloc(void *ptr, const char *func);
void L_DumpLeakInfo(int level);
#define L_Malloc(size) L_RegisterMalloc(L_Malloc2(size),__FILE__,__LINE__)
#define L_Calloc(size) L_RegisterMalloc(L_Calloc2(size),__FILE__,__LINE__)
#define L_ReMalloc(ptr,size) L_RegisterMalloc(L_ReMalloc2(ptr,size),__FILE__,__LINE__)
#else
#define L_Malloc L_Malloc2
#define L_Calloc L_Calloc2
#define L_ReMalloc L_ReMalloc2
#endif

//
// L_New
//
// Allocates num elements of type. Use this instead of L_Malloc whenever
// possible.
#define L_New(type, num) ((type *) L_Malloc((num) * sizeof(type)))

//
// L_Resize
//
// Reallocates a block. Use instead of L_ReMalloc wherever possible.
// Unlike normal L_ReMalloc, the pointer parameter is assigned the new
// value, and there is no return value.
#define L_Resize(ptr,type,n)  \
    (void)((ptr) = (type *) L_ReMalloc((void *)(ptr), (n) * sizeof(type)))

//
// L_ClearNew
//
// The L_Calloc version of L_New. Allocates mem and clears it to zero.
#define L_ClearNew(type, num) ((type *) L_Calloc((num) * sizeof(type)))

//
// From l_memhlp.c
//

typedef struct stack_array_s stack_array_t;

struct stack_array_s
{
  // points to the actual array pointer.
  // the stack_array is defined to be uninitialised if this one is NULL.
  void ***ptr;

  // the size of each element in ptr.
  int elem_size;

  // The number of currently used objects.
  // Elements above this limit will be freed automatically if memory gets
  // tight. Otherwise it will stay there, saving some future L_ReMalloc calls.
  int num;

  // The number of allocated objects.
  int max;

  // alloc_bunch elements will be allocated at a time, saving some memory block
  // overheads.
  // If this is negative, the array will work in a different way:
  // *ptr will be an array of elements rather than an array of pointers.
  // This means that no pointer except *ptr may point to an element
  // of the array, since it can be reallocated any time.
  int alloc_bunch;

  // Shows the number of users who have locked this grow_array.
  int locked;

  stack_array_t *next;
};

// Stack array functions.
void L_LockStackArray(stack_array_t *a);
void L_UnlockStackArray(stack_array_t *a);
void L_ClearStackArray(stack_array_t *a);
void L_DeleteStackArray(stack_array_t *a);
void L_InitStackArray(stack_array_t *a, void ***ptr, int elem_size, int alloc_bunch);
stack_array_t *L_CreateStackArray(void ***ptr, int elem_size, int alloc_bunch);
void L_SetArraySize(stack_array_t *a, int num);

// Generic helper functions.
char *L_StrDup(const char *s);

// Initialisation
void L_InitMemoryHelpers(void);

//
// stdio wrappers
//

//
// L_MemSet
//
// Clears memory to ch.
#define L_MemSet(ptr, ch, type, num)  \
    memset((void *)(ptr), (ch) + ((ptr) - ((type *)(ptr))), (num) * sizeof(type))

//
// L_Clear
//
// Clears memory to zero.
#define L_Clear(ptr, type, num) L_MemSet(ptr, 0, type, num)

//
// L_MoveMem
//
// Moves data from src to dest.
#define L_MoveMem(dest, src, type, num)  \
    memmove((void *)(dest), (void *)(src), (num) * sizeof(type) + ((src) - (type *)(src)) + ((dest) - (type *)(dest)))

//
// L_CopyMem
//
// Copies data from src to dest. Faster than L_MoveMem, but the memory areas
// must be disjunctive.
#define L_CopyMem(dest, src, type, num)  \
    memcpy((void *)(dest), (void *)(src), (num) * sizeof(type) + ((src) - (type *)(src)) + ((dest) - (type *)(dest)))

//
// L_StrNCpy
//
// Copies up to max characters of src into dest, and then applies a
// terminating zero (so dest must hold at least max+1 characters).
// The terminating zero is always applied (there is no reason not to)
#define L_StrNCpy(dest, src, max) \
    (void)(strncpy((dest), (src), (max)), (dest)[(max)] = 0)

//
// L_StrCpy
//
#define L_StrCpy(dest, src) \
    (void)(strcpy((dest), (src)))

//
// l_compen.c
//

#ifndef L_StrUpr
void L_StrUpr(char *str);
#endif
#ifndef L_StrCaseCmp
int L_StrCaseCmp(const char *s1, const char *s2);
#endif
#ifndef L_StrNCaseCmp
int L_StrNCaseCmp(const char *s1, const char *s2, int max);
#endif

//
// l_string.c
//
int L_StrNCaseCmpWild(const char *s1, const char *s2, int n);

#endif // __L_EPI_H__
</t>
<t tx="T2557">@ignore

//  EDGE&lt;-&gt;GLBSP Bridging code

#ifndef __L_GLBSP__
#define __L_GLBSP__

extern boolean_t gb_draw_progress;

boolean_t GB_BuildNodes(int map_lump);
void GB_DrawProgress(void);

#endif  // __L_GLBSP__
</t>
<t tx="T2558">@ignore

// MP3 Interface

#ifndef __L_MP3__
#define __L_MP3__

// NOTE: this interface to be used by platform code only.
// (It will one day be a part of the "common lib").

void L_MP3Init(int sample_rate, int sample_bits, int channels);
void L_MP3Shutdown(void);

boolean_t L_MP3SetMusicFile(const char *filename, int *sample_rate);
boolean_t L_MP3SetMusicLump(int handle, int position, int size, 
    int *sample_rate);
void L_MP3ClearMusicFile(void);

boolean_t L_MP3FillBuffer(void);
void L_MP3RestartMusicFile(void);

byte *L_MP3ReadBuffer(int samples);
void L_MP3ReadAdvance(int samples);

#endif  // __L_MP3__
</t>
<t tx="T2559">@ignore

// Mathematics LookUp Tables

// In the order of appearance:
//
// int finetangent[4096] - Tangens LUT.
//   Should work with BAM fairly well (12 of 16bit, effectively, by shifting).
//
// int finesine[10240] - Sine lookup.
//   Guess what, serves as cosine, too. Remarkable thing is,
//        how to use BAMs with this?
//
// int tantoangle[2049] - ArcTan LUT,
//   maps tan(angle) to angle fast. Gotta search. 
//    

#ifndef __TABLES__
#define __TABLES__

#include "m_fixed.h"
#include "dm_type.h"
#define FINEANGLES 8192
#define FINEMASK (FINEANGLES-1)

// 0x100000000 to 0x2000
#define ANGLETOFINESHIFT 19

// Effective size is 10240.
extern fixed_t finesine[5 * FINEANGLES / 4];

// Re-use data, is just PI/2 phase shift.
extern fixed_t *finecosine;

// Effective size is 4096.
extern fixed_t finetangent[FINEANGLES / 2];

// Binary Angle Measument, BAM.
#define ANG1   0x00B60B61
#define ANG45  0x20000000
#define ANG90  0x40000000
#define ANG135 0x60000000
#define ANG180 0x80000000
#define ANG225 0xa0000000
#define ANG270 0xc0000000
#define ANG315 0xe0000000
// Only use this one with float_t.
#define ANG360  (4294967296.0)
#define ANGLEBITS  32

#define SLOPERANGE 2048
#define SLOPEBITS  11
#define DBITS      (FRACBITS-SLOPEBITS)

// Effective size is 2049;
// The +1 size is to handle the case when x==y without additional checking.
extern angle_t tantoangle[SLOPERANGE + 1];

// Utility function, called by R_PointToAngle.
int SlopeDiv(unsigned num, unsigned den);

// Conversion macros:

#define FIX_2_FLOAT(x)  ((float_t) (x) / 65536.0)
#define FLOAT_2_FIX(f)  ((fixed_t) ((f) * 65536.0))

#define ANG_2_FLOAT(a)  ((float_t) (a) * 360.0 / 4294967296.0)
#define FLOAT_2_ANG(f)  ((angle_t) ((f) / 360.0 * 4294967296.0))

#endif
</t>
<t tx="T2560">@ignore

// Arguments/Parameters Code

#ifndef __M_ARGV__
#define __M_ARGV__

#include "i_defs.h"

// Returns the position of the given parameter
// in the arg list (0 if not found).
int M_CheckParm(const char *check);
int M_CheckNextParm(const char *check, int prev);
const char *M_GetParm(const char *check);
void M_InitArguments(int argc, const char **argv);
void M_ApplyResponseFile(const char *name, int position);
void M_CheckBooleanParm(const char *parm, boolean_t *bool, boolean_t reverse);
const char **M_GetArguments(int *ret_argc);
const char *M_GetArgument(int argnum);
int M_GetArgCount(void);

#endif
</t>
<t tx="T2561">@ignore

// Bounding-box Code

#ifndef __M_BBOX__
#define __M_BBOX__

#include &lt;limits.h&gt;

#include "m_fixed.h"

// Bounding box coordinate storage.
enum
{
  BOXTOP,
  BOXBOTTOM,
  BOXLEFT,
  BOXRIGHT
};  // bbox coordinates

// Bounding box functions.
void M_ClearBox(float_t * box);
void M_AddToBox(float_t * box, float_t x, float_t y);
void M_CopyBox(float_t * box, float_t * other);
void M_UnionBox(float_t * box, float_t * other);

//
//  DIRTY REGION HANDLING
// 
// Each byte in dirty_region[][] represents a block (DIRT_X x DIRT_Y)
// on the screen.  When `dirty_region_whole' is true, then the whole
// screen is considered dirty (simplifying some operations).  When
// `dirty_region_always' is true, the whole screen is ALWAYS
// considered to be dirty (e.g. double buffering &amp; drawing into video
// memory).

#define DIRT_X  16
#define DIRT_Y  16

#define DIRT_REG_W  ((2048+DIRT_X-1) / DIRT_X)
#define DIRT_REG_H  ((1536+DIRT_Y-1) / DIRT_X)

extern byte dirty_region[DIRT_REG_H][DIRT_REG_W];
extern boolean_t dirty_region_whole;
extern boolean_t dirty_region_always;

void M_CleanMatrix(void);
void M_DirtyMatrix(void);
void M_DirtyRegion(int x1, int y1, int x2, int y2);


#endif
</t>
<t tx="T2562">@ignore

// Cheat Sequence Checking

#ifndef __M_CHEAT__
#define __M_CHEAT__

// -MH- 1998/06/17 for cheat to give jetpack
// -KM- 1998-07-21 Added some extra headers in here
#include "dm_defs.h"
#include "dm_type.h"
#include "dm_state.h"
#include "e_event.h"

//
// CHEAT SEQUENCE PACKAGE
//
// -KM- 1998/07/21 Needed in am_map.c (iddt cheat)
typedef struct
{
  const char *sequence;
  const char *p;
}
cheatseq_t;

int M_CheckCheat(cheatseq_t * cht, char key);
boolean_t M_CheatResponder(event_t * ev);
void M_CheatInit(void);

#endif
</t>
<t tx="T2563">@ignore

// Fixed Point Stuff

#ifndef __M_FIXED__
#define __M_FIXED__

//
// Fixed point, 32bit as &lt;-16bits . 16bits-&gt;
//
#define FRACBITS    16
#define FRACUNIT    (1 &lt;&lt; FRACBITS)
#define FRACSQRT2   0x16A0A

typedef int fixed_t;

#endif
</t>
<t tx="T2564">@ignore

// Inline Functions

#include "i_defs.h"

#ifndef EDGE_INLINE
#define EDGE_INLINE(decl,body) extern decl;
#endif

EDGE_INLINE(
float_t M_FixedToFloat(fixed_t fix),
{
  return (float_t)fix / 65536;
})

#ifdef FLOAT_IEEE_754
// Use routines written for the usual 32-bit float format
EDGE_INLINE(
fixed_t M_FloatToFixed(float_t fl),
{
  long i;
  int sign;

  i = *(long*)&amp;fl;
  // extract sign bit: -1 if negative, 0 if positive.
  sign = i &gt;&gt; 31;
  // mask sign bit.
  i &amp;= 0x7FFFFFFF;
  // check bounds: Prevent shift wraparound
  if (i &gt;= 0x47000000)
  {
    // Very big/small.
    // Return MAXINT or MININT depending on sign
    return 0x7FFFFFFF - sign;
  }
  // near zero.
  if (i &lt;= 0x37000000)
  {
    return 0;
  }

  // Extract the mantissa (which is the last 23 bits of the float, plus
  // an extra leading bit). Shift these according to the exponent
  // (which is i&gt;&gt;23), and finally apply the sign.
  return (((((i &amp; 0x007FFFFF) | 0x00800000) &lt;&lt; 7) &gt;&gt; (0x8d - (i &gt;&gt; 23))) + sign) ^ sign;
})

EDGE_INLINE(
long M_FloatToInt(float_t fl),
{
  long i;
  int sign;

  i = *(long*)&amp;fl;
  sign = i &gt;&gt; 31;
  i &amp;= 0x7FFFFFFF;
  if (i &gt;= 0x4f000000)
  {
    return 0x7FFFFFFF - sign;
  }
  if (i &lt;= 0x3f000000)
  {
    return 0;
  }

  return (((((i &amp; 0x007FFFFF) | 0x00800000) &lt;&lt; 7) &gt;&gt; (0x7d - (i &gt;&gt; 23))) + sign) ^ sign;
})
#else
// Some other kind of float_t is used, so we have to use the portable versions

EDGE_INLINE(
fixed_t M_FloatToFixed(float_t fl),
{
  if (fl &gt; 32767)
    return (fixed_t) INT_MAX;

  if (fl &lt; -32767)
    return (fixed_t) INT_MIN;

  return (fixed_t)(fl * 65536);
})

EDGE_INLINE(
long M_FloatToInt(float_t fl),
{
  if (fl &gt;= INT_MAX)
    return (long)INT_MAX;

  if (fl &lt;= INT_MIN)
    return (long)INT_MIN;

  return (long)fl;
})

#endif

</t>
<t tx="T2565">@ignore

// Floating Point Math Stuff

#ifndef __M_MATH_H__
#define __M_MATH_H__

#include "m_fixed.h"

typedef struct vec2_s
{
  float_t x, y;
}
vec2_t;

#define Vec2Add(dest, src)  do {  \
    (dest).x += (src).x; (dest).y += (src).y; } while(0)

#define Vec2Sub(dest, src)  do {  \
    (dest).x -= (src).x; (dest).y -= (src).y; } while(0)

#define Vec2Mul(dest, val)  do {  \
    (dest).x *= (val); (dest).y *= (val); } while(0)

typedef struct vec3_s
{
  float_t x, y, z;
}
vec3_t;

#define Vec3Add(dest, src)  do {  \
    (dest).x += (src).x;  (dest).y += (src).y;  \
    (dest).z += (src).z; } while(0)

#define Vec3Sub(dest, src)  do {  \
    (dest).x -= (src).x;  (dest).y -= (src).y;  \
    (dest).z -= (src).z; } while(0)

#define Vec3Mul(dest, val)  do {  \
    (dest).x *= (val); (dest).y *= (val);  \
    (dest).z *= (val); } while(0)


fixed_t FixedDiv(fixed_t a, fixed_t b) GCCATTR(const);
fixed_t FixedMul(fixed_t a, fixed_t b) GCCATTR(const);
float_t M_Tan(angle_t ang)             GCCATTR(const);
angle_t M_ATan(float_t slope)          GCCATTR(const);
float_t M_Cos(angle_t ang)             GCCATTR(const);
float_t M_Sin(angle_t ang)             GCCATTR(const);
void M_Angle2Matrix(angle_t ang, vec2_t *x, vec2_t *y);

/* CRC stuff */

void CRC32_Init(unsigned long *crc);
void CRC32_ProcessByte(unsigned long *crc, byte data);
void CRC32_ProcessBlock(unsigned long *crc, const byte *data, int len);
void CRC32_Done(unsigned long *crc);

void CRC32_ProcessInt(unsigned long *crc, int value);
void CRC32_ProcessFixed(unsigned long *crc, fixed_t value);
void CRC32_ProcessFloat(unsigned long *crc, float_t value);
void CRC32_ProcessStr(unsigned long *crc, const char *str);

#endif //__M_MATH_H__

</t>
<t tx="T2566">@ignore

// Main Menu Code

#ifndef __M_MENU__
#define __M_MENU__

#include "e_event.h"

//
// MENUS
//
// Called by main loop,
// saves config file and calls I_Quit when user exits.
// Even when the menu is not displayed,
// this can resize the view and change game parameters.
// Does all the real work of the menu interaction.
boolean_t M_Responder(event_t * ev);

// Called by main loop,
// only used for menu (skull cursor) animation.
void M_Ticker(void);

// Called by main loop,
// draws the menus directly into the screen buffer.
void M_Drawer(void);

// Called by D_DoomMain,
// loads the config file.
boolean_t M_Init(void);

// Called by intro code to force menu up upon a keypress,
// does nothing if menu is already up.
void M_StartControlPanel(void);

// 25-6-98 KM
void M_StartMessage(const char *string, void (* routine)(int response), 
    boolean_t input);

// -KM- 1998/07/21
// String will be printed as a prompt.
// Routine should be void Foobar(char *string)
// and will be called with the input returned
// or NULL if user pressed escape.

void M_StartMessageInput(const char *string, 
    void (* routine)(char *response));

void M_DoSave(int page, int slot);
void M_QuickSave(void);

void M_QuitEDGE(int choice);

void M_DrawThermo(int x, int y, int thermWidth, int thermDot, int div);

#endif
</t>
<t tx="T2567">@ignore

// Misc: Screenshots, Menu and defaults Code

// 1998/07/02 -MH- Added key_flyup and key_flydown
//

#ifndef __M_MISC__
#define __M_MISC__

#include "dm_type.h"

//
// MISC
//
typedef struct
{
  char *name;
  int *location;
  int defaultvalue;
}
default_t;

typedef enum
{
  EXT_WEIRD       = 0x00,
  EXT_NONE        = 0x01,
  EXT_NOTMATCHING = 0x02,
  EXT_MATCHING    = 0x04
}
exttype_e;

boolean_t M_WriteFile(char const *name, void *source, int length);
boolean_t M_LoadDefaults(void);
void M_SaveDefaults(void);
int M_ReadFile(char const *name, byte **buffer);
void M_DisplayDisk(void);
void M_DisplayAir(void);
void M_ScreenShot(void);
void M_MakeSaveScreenShot(void);
exttype_e M_CheckExtension(const char *ext, const char* filename);
byte *M_GetFileData(char *filename, int *length);
char *M_ComposeFileName(const char *dir, const char *file);
void M_WarnError(const char *error,...) GCCATTR(format(printf, 1, 2));

int L_CompareTimeStamps(i_time_t *A, i_time_t *B);

extern unsigned short save_screenshot[160][100];
extern boolean_t save_screenshot_valid;

extern boolean_t display_disk;

extern int cfgnormalfov, cfgzoomedfov;

extern int key_right;
extern int key_left;
extern int key_lookup;
extern int key_lookdown;
extern int key_lookcenter;

// -ES- 1999/03/28 Zoom Key
extern int key_zoom;
extern int key_up;
extern int key_down;

extern int key_strafeleft;
extern int key_straferight;

// -ACB- for -MH- 1998/07/19 Flying keys
extern int key_flyup;
extern int key_flydown;

extern int key_fire;
extern int key_use;
extern int key_strafe;
extern int key_speed;
extern int key_autorun;
extern int key_nextweapon;
extern int key_jump;
extern int key_map;
extern int key_180;
extern int key_talk;
extern int key_mlook;  // -AJA- 1999/07/27.
extern int key_secondatk;

extern int mousebfire;
extern int mousebstrafe;
extern int mousebforward;

extern int joybfire;
extern int joybstrafe;
extern int joybuse;
extern int joybspeed;

extern boolean_t autorunning;

extern default_t defaults[];

#endif
</t>
<t tx="T2568">@ignore

// Option Menu (header)

#ifndef __M_OPTION__
#define __M_OPTION__

#include "dm_type.h"
#include "e_event.h"

extern int optionsmenuon;

void M_InitOptmenu(void);
void M_OptDrawer(void);
void M_OptTicker(void);
boolean_t M_OptResponder(event_t * ev, int ch);
void M_ResetToDefaults(int keypressed);

#endif
</t>
<t tx="T2569">@ignore

// Pseudo-Random Number Code (via LUT)

#ifndef __M_RANDOM__
#define __M_RANDOM__

#include "dm_type.h"

int M_Random(void);
int P_Random(void);
int P_RandomNegPos(void);
boolean_t M_RandomTest(percent_t chance);
boolean_t P_RandomTest(percent_t chance);

// Savegame support
int P_ReadRandomState(void);
void P_WriteRandomState(int value);

// This is used in various places:
extern unsigned char rndtable[256];

#endif
</t>
<t tx="T2570">@ignore

// Endianess handling

#ifndef __M_SWAP__
#define __M_SWAP__

// Endianess handling.
// WAD files are stored little endian.

#ifdef __BIG_ENDIAN__

// Swap 16bit, that is, MSB and LSB byte.
static short SHORT(unsigned short x)
{
  // No masking with 0xFF should be necessary.
  return (x &gt;&gt; 8) | (x &lt;&lt; 8);
}

// Swapping 32bit.
static long LONG(unsigned long x)
{
  return
      (x &gt;&gt; 24)
      | ((x &gt;&gt; 8) &amp; 0xff00)
      | ((x &lt;&lt; 8) &amp; 0xff0000)
      | (x &lt;&lt; 24);
}

#else

#define SHORT(x) ((short) (x))
#define LONG(x)  ((long) (x))

#endif

#define USHORT(x) ((unsigned short) SHORT(x))
#define ULONG(x)  ((unsigned long) LONG(x))

#endif
</t>
<t tx="T2571">@ignore

// Play Simulation Action routines

#ifndef __P_ACTION_H__
#define __P_ACTION_H__

#include "dm_type.h"
#include "p_mobj.h"

// Info for the JUMP action
typedef struct act_jump_info_s
{
  // chance value
  percent_t chance; 
}
act_jump_info_t;

// Weapon Action Routine pointers
void A_Light0(mobj_t * object);
void A_Light1(mobj_t * object);
void A_Light2(mobj_t * object);

void A_WeaponReady(mobj_t * object);
void A_WeaponShoot(mobj_t * object);
void A_WeaponEject(mobj_t * object);
void A_WeaponJump(mobj_t * object);
void A_Lower(mobj_t * object);
void A_Raise(mobj_t * object);
void A_ReFire(mobj_t * object);
void A_NoFire(mobj_t * object);
void A_NoFireReturn(mobj_t * object);
void A_CheckReload(mobj_t * object);
void A_SFXWeapon1(mobj_t * object);
void A_SFXWeapon2(mobj_t * object);
void A_SFXWeapon3(mobj_t * object);
void A_WeaponPlaySound(mobj_t * object);
void A_WeaponKillSound(mobj_t * object);
void A_WeaponTransSet(mobj_t * object);
void A_WeaponTransFade(mobj_t * object);
void A_WeaponEnableRadTrig(mobj_t * object);
void A_WeaponDisableRadTrig(mobj_t * object);

void A_SetCrosshair(mobj_t * object);
void A_GotTarget(mobj_t * object);
void A_GunFlash(mobj_t * object);
void A_WeaponKick(mobj_t * object);

void A_WeaponShootSA(mobj_t * object);
void A_ReFireSA(mobj_t * object);
void A_NoFireSA(mobj_t * object);
void A_NoFireReturnSA(mobj_t * object);
void A_CheckReloadSA(mobj_t * object);
void A_GunFlashSA(mobj_t * object);

// Needed for the bossbrain.
void A_BrainScream(mobj_t * object);
void A_BrainDie(mobj_t * object);
void A_BrainSpit(mobj_t * object);
void A_CubeSpawn(mobj_t * object);
void A_BrainMissileExplode(mobj_t * object);

// Visibility Actions
void P_ActTransSet(mobj_t * object);
void P_ActTransFade(mobj_t * object);
void P_ActTransMore(mobj_t * object);
void P_ActTransLess(mobj_t * object);
void P_ActTransAlternate(mobj_t * object);

// Sound Actions
void P_ActPlaySound(mobj_t * object);
void P_ActKillSound(mobj_t * object);
void P_ActMakeAmbientSound(mobj_t * object);
void P_ActMakeAmbientSoundRandom(mobj_t * object);
void P_ActMakeCloseAttemptSound(mobj_t * object);
void P_ActMakeDyingSound(mobj_t * object);
void P_ActMakeOverKillSound(mobj_t * object);
void P_ActMakePainSound(mobj_t * object);
void P_ActMakeRangeAttemptSound(mobj_t * object);
void P_ActMakeActiveSound(mobj_t * object);

// Explosion Damage Actions
void P_ActDamageExplosion(mobj_t * object);
void P_ActThrust(mobj_t * object);

// Stand-by / Looking Actions
void P_ActStandardLook(mobj_t * object);
void P_ActPlayerSupportLook(mobj_t * object);

// Meander, aimless movement actions.
void P_ActStandardMeander(mobj_t * object);
void P_ActPlayerSupportMeander(mobj_t * object);

// Chasing Actions
void P_ActResurrectChase(mobj_t * object);
void P_ActStandardChase(mobj_t * object);
void P_ActWalkSoundChase(mobj_t * object);

// Attacking Actions
void P_ActComboAttack(mobj_t * object);
void P_ActMeleeAttack(mobj_t * object);
void P_ActRangeAttack(mobj_t * object);
void P_ActSpareAttack(mobj_t * object);
void P_ActRefireCheck(mobj_t * object);

// Miscellanous
void P_ActFaceTarget(mobj_t * object);
void P_ActMakeIntoCorpse(mobj_t * object);
void P_ActResetSpreadCount(mobj_t * object);
void P_ActExplode(mobj_t * object);
void P_ActActivateLineType(mobj_t * object);
void P_ActEnableRadTrig(mobj_t * object);
void P_ActDisableRadTrig(mobj_t * object);
void P_ActTouchyRearm(mobj_t * object);
void P_ActTouchyDisarm(mobj_t * object);
void P_ActBounceRearm(mobj_t * object);
void P_ActBounceDisarm(mobj_t * object);
void P_ActPathCheck(mobj_t * object);
void P_ActPathFollow(mobj_t * object);
void P_ActDropItem(mobj_t * object);
void P_ActDLightSet(mobj_t * object);
void P_ActDLightFade(mobj_t * object);
void P_ActDLightRandom(mobj_t * object);

// Movement actions
void P_ActFaceDir(mobj_t * object);
void P_ActTurnDir(mobj_t * object);
void P_ActTurnRandom(mobj_t * object);
void P_ActMlookFace(mobj_t * object);
void P_ActMlookTurn(mobj_t * object);
void P_ActMoveFwd(mobj_t * object);
void P_ActMoveRight(mobj_t * object);
void P_ActMoveUp(mobj_t * object);
void P_ActStopMoving(mobj_t * object);

// Projectiles
void P_ActFixedHomingProjectile(mobj_t * object);
void P_ActRandomHomingProjectile(mobj_t * object);
void P_ActLaunchOrderedSpread(mobj_t * object);
void P_ActLaunchRandomSpread(mobj_t * object);
void P_ActCreateSmokeTrail(mobj_t * object);
void P_ActHomeToSpot(mobj_t * object);
boolean_t P_ActLookForTargets(mobj_t * object);

// Trackers
void P_ActEffectTracker(mobj_t * object);
void P_ActTrackerActive(mobj_t * object);
void P_ActTrackerFollow(mobj_t * object);
void P_ActTrackerStart(mobj_t * object);

// Blood and bullet puffs
void P_ActCheckBlood(mobj_t * object);
void P_ActCheckMoving(mobj_t * object);

void P_ActJump(mobj_t * object);
void A_PlayerScream(mobj_t * object);

#endif //__P_ACTION_H__
</t>
<t tx="T2572">@ignore

// Play Simulation Action routines: 'DeathBots'

#ifndef __P_BOT_H__
#define __P_BOT_H__

#include "e_player.h"

// This describes what action the bot wants to do.
// It will be translated to a ticcmd_t by P_BotPlayerThinker.
typedef struct botcmd_s
{
  // The
  enum
  {
    FOLLOW_NONE = 0,
    FOLLOW_MOBJ,
    FOLLOW_XY,
    FOLLOW_DIR
  } 
  followtype;
  
  union
  {
    struct {float_t x,y;} xyz;
    struct {angle_t angle; float_t distance;} dir;
    mobj_t *mo;
  } 
  followobj;

  // If we want to face someone, do this here.
  // Either face a mobj, a specified map coordinate, or a given angle.
  enum
  {
    FACE_NONE = 0,
    FACE_MOBJ,
    FACE_XYZ,
    FACE_ANGLE
  }
  facetype;

  union
  {
    struct {float_t x,y,z;} xyz;
    struct {angle_t angle; float_t slope;} angle;
    mobj_t *mo;
  }
  faceobj;

  // The weapon we want to use. -1 if the current one is fine.
  int new_weapon;

  boolean_t attack;
  boolean_t second_attack;
  boolean_t use;
  boolean_t jump;
} 
botcmd_t;

typedef struct bot_s
{
  const player_t *pl;

  boolean_t strafedir;
  int confidence;
  int threshold;
  int movecount;

  mobj_t *target;
  mobj_t *supportobj;
  angle_t angle;

  botcmd_t cmd;

  // remember previous movements, just in case the thinker is run twice the
  // same gametic.
  ticcmd_t prev_cmd;
  int prev_gametime;

  struct bot_s *next;
}
bot_t;

void P_BotCreate(player_t *p);
void BOT_DMSpawn(void);
void P_RemoveBots(void);

#endif
</t>
<t tx="T2573">@ignore

// Local Header for play sim functions 

// -ACB- 1998/07/27 Cleaned up, Can read it now :).

#ifndef __P_LOCAL__
#define __P_LOCAL__

#ifndef __R_LOCAL__
#include "r_local.h"
#endif

#define DEATHVIEWHEIGHT  6.0f
#define CROUCH_SLOWDOWN  0.6f

#ifdef USE_GL
#define LOOKUPLIMIT    0.9f
#define LOOKDOWNLIMIT -0.9f
#else
#define LOOKUPLIMIT    0.5f
#define LOOKDOWNLIMIT -0.5f
#endif

// mapblocks are used to check movement
// against lines and things
#define MAPBLOCKUNITS 128

// MAXRADIUS is for precalculated sector block boxes
// the spider demon is larger, but we do not have any moving sectors nearby
#define MAXRADIUS    (32.0f)
#define MAXDLIGHTRADIUS    (200.0f)

#define MAXMOVE      (100.0f)
#define STEPMOVE     (16.0f)
#define USERANGE     (64.0f)
#define USE_Z_RANGE  (32.0f)
#define MELEERANGE   (64.0f)
#define MISSILERANGE (2000.0f)

#define RESPAWN_DELAY  (TICRATE / 2)

// Weapon sprite speeds
#define LOWERSPEED (6.0f)
#define RAISESPEED (6.0f)

#define WPNLOWERSPEED (6.0f)
#define WPNRAISESPEED (6.0f)

#define WEAPONBOTTOM     128
#define WEAPONTOP        32

// follow a player exlusively for 3 seconds
#define BASETHRESHOLD 100

extern mobj_t *RandomTarget;

// useful macro for the vertical center of an object
#define MO_MIDZ(mo)  ((mo)-&gt;z + (mo)-&gt;height / 2)

//
// P_ACTION
//
void P_ActPlayerAttack(mobj_t * playerobj, const attacktype_t * attack);
void P_ActSlammedIntoObject(mobj_t * object, mobj_t * objecthit);
boolean_t P_ActMissileContact(mobj_t * object, mobj_t * objecthit);
boolean_t P_ActBulletContact(mobj_t * object, mobj_t * objecthit, 
    float_t damage, const damage_t * damtype);
void P_ActTouchyContact(mobj_t * touchy, mobj_t * victim);
boolean_t P_ActUseThing(mobj_t * user, mobj_t * thing, float_t open_bottom,
    float_t open_top);
void P_BringCorpseToLife(mobj_t * corpse);

//
// P_WEAPON
//
void P_SetupPsprites(player_t * curplayer);
void P_MovePsprites(player_t * curplayer);
void P_SetPsprite(player_t * p, int position, int stnum);
void P_DropWeapon(player_t * player);
void P_BringUpWeapon(player_t * player);
boolean_t P_CheckWeaponSprite(weaponinfo_t *info);
void P_SelectNewWeapon(player_t * player, int priority, ammotype_t ammo);
void P_Zoom(player_t * player);
void P_RefillClips(player_t * player);

//
// P_USER
//
void P_PlayerThink(player_t * player);
void P_UpdateAvailWeapons(player_t *p);
boolean_t P_AddWeapon(player_t *player, weaponinfo_t *info, int *index);
boolean_t P_RemoveWeapon(player_t *player, weaponinfo_t *info);
void P_GiveInitialBenefits(player_t *player, const mobjinfo_t *info);
void P_AddPlayerToGame(player_t *p);
void P_RemovePlayerFromGame(player_t *p);
void P_RemoveAllPlayers(void);

//
// P_MOBJ
//
#define ONFLOORZ   ((float_t)INT_MIN)
#define ONCEILINGZ ((float_t)INT_MAX)

// -ACB- 1998/07/30 Start Pointer the item-respawn-que.
extern iteminque_t *itemquehead;

// -ACB- 1998/08/27 Start Pointer in the mobj list.
extern mobj_t *mobjlisthead;

void P_SpawnPlayer(player_t *p, const spawnpoint_t * sthing);
void P_RemoveMobj(mobj_t * th);
statenum_t P_MobjFindLabel(mobj_t * mobj, const char *label);
boolean_t P_SetMobjState(mobj_t * mobj, statenum_t state);
boolean_t P_SetMobjStateDeferred(mobj_t * mobj, statenum_t state, int tic_skip);
void P_SetMobjDirAndSpeed(mobj_t * mobj, angle_t angle, float_t slope, float_t speed);
void P_RunMobjThinkers(void);
void P_SpawnPuff(float_t x, float_t y, float_t z, const mobjinfo_t * puff);
void P_SpawnBlood(float_t x, float_t y, float_t z, float_t damage, angle_t angle, const mobjinfo_t * blood);
void P_RemoveQueuedMobjs(void);
void P_CalcFullProperties(const mobj_t *mo, region_properties_t *new);

void P_MobjSetTracer(mobj_t *mo, mobj_t *target);
void P_MobjSetSource(mobj_t *mo, mobj_t *target);
void P_MobjSetTarget(mobj_t *mo, mobj_t *target);
void P_MobjSetSupportObj(mobj_t *mo, mobj_t *target);
void P_MobjSetAboveMo(mobj_t *mo, mobj_t *target);
void P_MobjSetBelowMo(mobj_t *mo, mobj_t *target);
void P_MobjSetRealSource(mobj_t *mo, mobj_t *source);

// -ACB- 1998/08/02 New procedures for DDF etc...
void P_MobjItemRespawn(void);
void P_MobjRemoveMissile(mobj_t * missile);
void P_MobjExplodeMissile(mobj_t * missile);
mobj_t *P_MobjCreateObject(float_t x, float_t y, float_t z, const mobjinfo_t * type);

//
// P_ENEMY
//

typedef struct 
{
  int number;

  // FIXME: big troubles if one of these objects disappears.
  struct mobj_s ** targets;
}
shoot_spot_info_t;

extern dirtype_t opposite[];
extern dirtype_t diags[];
extern float_t xspeed[8];
extern float_t yspeed[8];
extern shoot_spot_info_t brain_spots;

void P_NoiseAlert(player_t *p);
void P_NewChaseDir(mobj_t * actor);
boolean_t P_CreateAggression(mobj_t * actor);
boolean_t P_CheckMeleeRange(mobj_t * actor);
boolean_t P_CheckMissileRange(mobj_t * actor);
boolean_t P_Move(mobj_t * actor, boolean_t path);
boolean_t P_LookForPlayers(mobj_t * actor, angle_t range);
void P_LookForShootSpots(const mobjinfo_t *spot_type);
void P_FreeShootSpots(void);

//
// P_MAPUTL
//
#define PT_ADDLINES  1
#define PT_ADDTHINGS 2
#define PT_EARLYOUT  4

typedef struct
{
  float_t frac;  // along trace line

  enum
  {
    INCPT_Line  = 0,
    INCPT_Thing = 1
  }
  type;

  union
  {
    mobj_t *thing;
    line_t *line;
  }
  d;
}
intercept_t;

typedef boolean_t(*traverser_t) (intercept_t * in);

extern intercept_t **intercepts;
extern int intercept_p;

extern divline_t trace;

float_t P_ApproxDistance(float_t dx, float_t dy);
float_t P_ApproxSlope(float_t dx, float_t dy, float_t dz);
int P_PointOnDivlineSide(float_t x, float_t y, divline_t *div);
int P_PointOnDivlineThick(float_t x, float_t y, divline_t *div,
    float_t div_len, float_t thickness);
float_t P_InterceptVector(divline_t * v2, divline_t * v1);
int P_BoxOnLineSide(float_t * tmbox, line_t * ld);
int P_FindThingGap(vgap_t * gaps, int gap_num, float_t z1, float_t z2);
void P_ComputeGaps(line_t * ld);
float_t P_ComputeThingGap(mobj_t * thing, sector_t * sec, float_t z, float_t * f, float_t * c);
void P_AddExtraFloor(sector_t *sec, line_t *line);
void P_ComputeWallTiles(line_t *ld, int sidenum);
void P_RecomputeGapsAroundSector(sector_t *sec);
void P_RecomputeTilesInSector(sector_t *sec);
void P_FloodExtraFloors(sector_t *sector);
void P_UnsetThingFinally(mobj_t * thing);
void P_SetThingPosition(mobj_t * thing);
void P_ChangeThingPosition(mobj_t * thing, float_t x, float_t y, float_t z);
void P_FreeSectorTouchNodes(sector_t *sec);
  
boolean_t P_BlockLinesIterator(int x, int y, boolean_t(*func) (line_t *));
boolean_t P_BlockThingsIterator(int x, int y, boolean_t(*func) (mobj_t *));
boolean_t P_ThingsInArea(float_t *bbox);
boolean_t P_ThingsOnLine(line_t *ld);

typedef enum
{
  EXFIT_Ok = 0,
  EXFIT_StuckInCeiling,
  EXFIT_StuckInFloor,
  EXFIT_StuckInExtraFloor
}
exfloor_fit_e;

exfloor_fit_e P_ExtraFloorFits(sector_t *sec, float_t z1, float_t z2);

boolean_t P_PathTraverse(float_t x1, float_t y1, float_t x2, float_t y2, int flags, traverser_t trav);

//
// P_MAP
//

typedef enum
{
  // sector move is completely OK
  CHKMOV_Ok = 0,

  // sector move would crush something, but OK
  CHKMOV_Crush = 1,

  // sector can't move (solid floor or uncrushable thing)
  CHKMOV_Nope = 2
}
check_sec_move_e;

// If "floatok" true, move would be OK at float_destz height.
extern boolean_t floatok;
extern float_t float_destz;

extern mobj_t *linetarget;  // who got hit (or NULL)

extern boolean_t mobj_hit_sky;
extern line_t *blockline;

extern stack_array_t spechit_a;
extern line_t **spechit;
extern int numspechit;

boolean_t P_MapInit(void);
boolean_t P_MapCheckBlockingLine(mobj_t * thing, mobj_t * spawnthing);
mobj_t *P_MapFindCorpse(mobj_t * thing);
mobj_t *P_MapTargetAutoAim(mobj_t * source, angle_t angle,
    float_t distance, boolean_t force_aim);
mobj_t *P_MapTargetTheory(mobj_t * source);

float_t P_AimLineAttack(mobj_t * t1, angle_t angle, float_t distance);
void P_UpdateMultipleFloors(sector_t * sector);
boolean_t P_CheckSolidSectorMove(sector_t *sec, boolean_t is_ceiling,
        float_t dh);
boolean_t P_SolidSectorMove(sector_t *sec, boolean_t is_ceiling,
        float_t dh, boolean_t crush, boolean_t nocarething);
void P_ChangeThingSize(mobj_t *mo);
boolean_t P_CheckAbsPosition(mobj_t * thing, float_t x, float_t y, float_t z);
boolean_t P_CheckSight(mobj_t * src, mobj_t * dest);
boolean_t P_CheckSightApproxVert(mobj_t * src, mobj_t * dest);
void P_RadiusAttack(mobj_t * spot, mobj_t * source, float_t radius,
    float_t damage, const damage_t * damtype, boolean_t thrust_only);

boolean_t P_TeleportMove(mobj_t * thing, float_t x, float_t y, float_t z);
boolean_t P_TryMove(mobj_t * thing, float_t x, float_t y);
void P_SlideMove(mobj_t * mo, float_t x, float_t y);
void P_UseLines(player_t * player);
void P_LineAttack(mobj_t * t1, angle_t angle, float_t distance, 
    float_t slope, float_t damage, const damage_t * damtype,
    const mobjinfo_t *puff);


//
// P_SETUP
//
// 23-6-98 KM Short*s changed to int*s, for bigger, better blockmaps
// -AJA- 2000/07/31: line data changed back to shorts.
//

// for fast sight rejection.  Can be NULL
extern const byte *rejectmatrix;

#define BMAP_END  ((unsigned short) 0xFFFF)

extern unsigned short *bmap_lines;
extern unsigned short ** bmap_pointers;

extern int bmapwidth;
extern int bmapheight;  // in mapblocks

extern float_t bmaporgx;
extern float_t bmaporgy;  // origin of block map

extern mobj_t **blocklinks;   // for thing chains
extern mobj_t **blocklights;  // for dynamic lights

//
// P_INTER
//

void P_TouchSpecialThing(mobj_t * special, mobj_t * toucher);
void P_ThrustMobj(mobj_t * target, mobj_t * source, float_t thrust);
void P_DamageMobj(mobj_t * target, mobj_t * inflictor, mobj_t * source,
    float_t amount, const damage_t * damtype);
void P_KillMobj(mobj_t * source, mobj_t * target, const damage_t * damtype);
boolean_t P_GiveBenefitList(player_t *player, mobj_t *special,
    benefit_t *list, boolean_t lose_em);


//
// P_SPEC
//
#include "p_spec.h"

#endif // __P_LOCAL__
</t>
<t tx="T2574">@ignore

// Moving Object Header

//
// IMPORTANT NOTE: Altering anything within the mobj_t will most likely
//                 require changes to p_saveg.c and the save-game object
//                 (savegmobj_t); if you experience any problems with
//                 savegames, check here!
//

#ifndef __P_MOBJ__
#define __P_MOBJ__

#include "m_math.h"

#include "dm_data.h"
#include "ddf_main.h"
#include "lu_math.h"

// forward decl.
struct mobj_s;

//
// NOTES: mobj_t
//
// mobj_ts are used to tell the refresh where to draw an image,
// tell the world simulation when objects are contacted,
// and tell the sound driver how to position a sound.
//
// The refresh uses the next and prev links to follow
// lists of things in sectors as they are being drawn.
// The sprite, frame, and angle elements determine which patch_t
// is used to draw the sprite if it is visible.
// The sprite and frame values are allmost always set
// from state_t structures.
//
// The statescr.exe utility generates the states.h and states.c
// files that contain the sprite/frame numbers from the
// statescr.txt source file.
//
// The xyz origin point represents a point at the bottom middle
// of the sprite (between the feet of a biped).
// This is the default origin position for patch_ts grabbed
// with lumpy.exe.
// A walking creature will have its z equal to the floor
// it is standing on.
//
// The sound code uses the x,y, and subsector fields
// to do stereo positioning of any sound effited by the mobj_t.
//
// The play simulation uses the blocklinks, x,y,z, radius, height
// to determine when mobj_ts are touching each other,
// touching lines in the map, or hit by trace lines (gunshots,
// lines of sight, etc).
// The mobj_t-&gt;flags element has various bit flags
// used by the simulation.
//
// Every mobj_t is linked into a single sector
// based on its origin coordinates.
// The subsector_t is found with R_PointInSubsector(x,y),
// and the sector_t can be found with subsector-&gt;sector.
// The sector links are only used by the rendering code,
// the play simulation does not care about them at all.
//
// Any mobj_t that needs to be acted upon by something else
// in the play world (block movement, be shot, etc) will also
// need to be linked into the blockmap.
// If the thing has the MF_NOBLOCK flag set, it will not use
// the block links. It can still interact with other things,
// but only as the instigator (missiles will run into other
// things, but nothing can run into a missile).
// Each block in the grid is 128*128 units, and knows about
// every line_t that it contains a piece of, and every
// interactable mobj_t that has its origin contained.  
//
// A valid mobj_t is a mobj_t that has the proper subsector_t
// filled in for its xy coordinates and is linked into the
// sector from which the subsector was made, or has the
// MF_NOSECTOR flag set (the subsector_t needs to be valid
// even if MF_NOSECTOR is set), and is linked into a blockmap
// block or has the MF_NOBLOCKMAP flag set.
// Links should only be modified by the P_[Un]SetThingPosition()
// functions.
// Do not change the MF_NO? flags while a thing is valid.
//
// Any questions?
//

//
// Misc. mobj flags
//
typedef enum
{
  // Call P_TouchSpecialThing when touched.
  MF_SPECIAL = 1,

  // Blocks.
  MF_SOLID = 2,

  // Can be hit.
  MF_SHOOTABLE = 4,

  // Don't use the sector links (invisible but touchable).
  MF_NOSECTOR = 8,

  // Don't use the blocklinks (inert but displayable)
  MF_NOBLOCKMAP = 16,

  // Not to be activated by sound, deaf monster.
  MF_AMBUSH = 32,

  // Will try to attack right back.
  MF_JUSTHIT = 64,

  // Will take at least one step before attacking.
  MF_JUSTATTACKED = 128,

  // On level spawning (initial position),
  // hang from ceiling instead of stand on floor.
  MF_SPAWNCEILING = 256,

  // Don't apply gravity (every tic), that is, object will float,
  // keeping current height or changing it actively.
  MF_NOGRAVITY = 512,

  // Movement flags. This allows jumps from high places.
  MF_DROPOFF = 0x400,

  // For players, will pick up items.
  MF_PICKUP = 0x800,

  // Object is not checked when moving, no clipping is used.
  MF_NOCLIP = 0x1000,

  // Player: keep info about sliding along walls.
  MF_SLIDE = 0x2000,

  // Allow moves to any height, no gravity.
  // For active floaters, e.g. cacodemons, pain elementals.
  MF_FLOAT = 0x4000,

  // Instantly cross lines, whatever the height differences may be
  // (e.g. go from the bottom of a cliff to the top).
  // Note: nothing to do with teleporters.
  MF_TELEPORT = 0x8000,

  // Don't hit same species, explode on block.
  // Player missiles as well as fireballs of various kinds.
  MF_MISSILE = 0x10000,

  // Dropped by a demon, not level spawned.
  // E.g. ammo clips dropped by dying former humans.
  MF_DROPPED = 0x20000,

  // Use fuzzy draw (shadow demons or spectres),
  // temporary player invisibility powerup.
  MF_FUZZY = 0x40000,

  // Flag: don't bleed when shot (use puff),
  // barrels and shootable furniture shall not bleed.
  MF_NOBLOOD = 0x80000,

  // Don't stop moving halfway off a step,
  // that is, have dead bodies slide down all the way.
  MF_CORPSE = 0x100000,

  // Floating to a height for a move, ???
  // don't auto float to target's height.
  MF_INFLOAT = 0x200000,

  // On kill, count this enemy object
  // towards intermission kill total.
  // Happy gathering.
  MF_COUNTKILL = 0x400000,

  // On picking up, count this item object
  // towards intermission item total.
  MF_COUNTITEM = 0x800000,

  // Special handling: skull in flight.
  // Neither a cacodemon nor a missile.
  MF_SKULLFLY = 0x1000000,

  // Don't spawn this object
  // in death match mode (e.g. key cards).
  MF_NOTDMATCH = 0x2000000,

  // Monster grows (in)visible at certain times.
  MF_STEALTH = 0x4000000,

  // Used so bots know they have picked up their target item.
  MF_JUSTPICKEDUP = 0x8000000,

  // Object reacts to being touched (often violently :-&gt;)
  // -AJA- 1999/08/21: added this.
  MF_TOUCHY = 0x10000000
}
mobjflag_t;

typedef enum
{
  // Act like a big ugly bossman (ignores certain types of damage and
  // makes start and death sound at full volume regardless of location).
  EF_BOSSMAN = 1,

  // Used when varying visibility levels
  EF_LESSVIS = 2,

  // This thing does not respawn
  EF_NORESPAWN = 4,

  // double the chance of object using range attack
  EF_NOGRAVKILL = 8,

  // This thing is not loyal to its own type, fights its own
  EF_DISLOYALTYPE = 16,

  // This thing can be hurt by another thing with same attack
  EF_OWNATTACKHURTS = 32,

  // Used for tracing (homing) projectiles, its the first time
  // this projectile has been checked for tracing if set.
  EF_FIRSTCHECK = 64,

  // This projectile can trace, but if this is set it will not.
  EF_NOTRACE = 128,

  // double the chance of object using range attack
  EF_TRIGGERHAPPY = 256,

  // not targeted by other monsters for damaging them
  EF_NEVERTARGET = 512,

  // Normally most monsters will follow a target which caused them
  // damage for a length of time, even if another object inflicted
  // pain upon them; with this enabled, they will not hold the grudge
  // and switch targets to the other object that has caused them the
  // more recent pain.
  EF_NOGRUDGE = 1024,

  // This object is dummy, used for carring a dummy set of co-ordinates for
  // use as a target.
  EF_DUMMYMOBJ = 2048,

  // Archvile cannot resurrect this monster
  EF_NORESURRECT = 4096,

  // Object bounces
  EF_BOUNCE = 8192,

  // Thing walks along the edge near large dropoffs. 
  // -AJA- 1999/07/21: added this.
  EF_EDGEWALKER = 0x4000,

  // Monster falls with gravity when walks over cliff. 
  // -AJA- 1999/07/21: added this.
  EF_GRAVFALL = 0x8000,

  // Thing can be climbed on-top-of or over. 
  // -AJA- 1999/07/21: added this.
  EF_CLIMBABLE = 0x10000,

  // Thing won't penetrate WATER extra floors. 
  // -AJA- 1999/09/25: added this.
  EF_WATERWALKER = 0x20000,

  // Thing is a monster. 
  // -AJA- 1999/10/02: added this (removed 3006 hack).
  EF_MONSTER = 0x40000,

  // Thing can cross blocking lines.
  // -AJA- 1999/10/02: added this.
  EF_CROSSLINES = 0x80000,

  // Thing is never affected by friction
  // -AJA- 1999/10/02: added this.
  EF_NOFRICTION = 0x100000,

  // Thing is optional, won't exist when -noextra is used.
  // -AJA- 1999/10/07: added this.
  EF_EXTRA = 0x200000,

  // Just bounced, won't enter bounce states until BOUNCE_REARM.
  // -AJA- 1999/10/18: added this.
  EF_JUSTBOUNCED = 0x400000,

  // Thing can be "used" (like linedefs) with the spacebar.  Thing
  // will then enter its TOUCH_STATES (when they exist).
  // -AJA- 2000/02/17: added this.
  EF_USABLE = 0x800000,

  // Thing will block bullets and missiles.  -AJA- 2000/09/29
  EF_BLOCKSHOTS = 0x1000000,

  // Player is currently crouching.  -AJA- 2000/10/19
  EF_CROUCHING = 0x2000000,

  // Missile can tunnel through enemies.  -AJA- 2000/10/23
  EF_TUNNEL = 0x4000000,

  // Marks thing as being a dynamic light.
  EF_DLIGHT = 0x8000000,

  // Thing has been gibbed.
  EF_GIBBED = 0x10000000
}
mobjextendedflag_t;

// Directions
typedef enum
{
  DI_EAST,
  DI_NORTHEAST,
  DI_NORTH,
  DI_NORTHWEST,
  DI_WEST,
  DI_SOUTHWEST,
  DI_SOUTH,
  DI_SOUTHEAST,
  DI_NODIR,
  NUMDIRS
}
dirtype_t;

// Each sector has a degenmobj_t in its center for sound origin
// purposes.
typedef struct
{
  float_t x, y, z;
}
degenmobj_t;

typedef struct
{
  // location on the map.  `z' can take the special values ONFLOORZ
  // and ONCEILINGZ.
  float_t x, y, z;

  // direction thing faces
  angle_t angle;
  float_t slope;

  // type of thing
  const mobjinfo_t *info;

  // certain flags (mainly MF_AMBUSH).
  int flags;
}
spawnpoint_t;

// Map Object definition.
typedef struct mobj_s mobj_t;

struct mobj_s
{
  // Info for drawing: position.
  // NOTE: these three fields must be first, so mobj_t can be used
  // anywhere that degenmobj_t is expected.
  float_t x, y, z;

  // More drawing info: to determine current sprite.
  angle_t angle;  // orientation

  // used to find patch_t and flip value
  spritenum_t sprite;

  // frame and brightness
  short frame, bright;

  // current subsector
  struct subsector_s *subsector;

  // properties from extrafloor the thing is in
  struct region_properties_s *props;

  // The closest interval over all contacted Sectors.
  float_t floorz;
  float_t ceilingz;
  float_t dropoffz;

  // For movement checking.
  float_t radius;
  float_t height;

  // Momentum, used to update position.
  vec3_t mom;

  // Thing's health level
  float_t health;

  // This is the current speed of the object.
  // if fastparm, it is already calculated.
  float_t speed;
  int fuse;

  // If == validcount, already checked.
  int validcount;

  const mobjinfo_t *info;

  // state tic counter
  int tics;
  int tic_skip;

  const state_t *state;
  const state_t *next_state;

  // flags (Old and New)
  int flags;
  int extendedflags;

  // Movement direction, movement generation (zig-zagging).
  dirtype_t movedir;  // 0-7

  // when 0, select a new dir
  int movecount;

  // Reaction time: if non 0, don't attack yet.
  // Used by player to freeze a bit after teleporting.
  int reactiontime;

  // If &gt;0, the target will be chased
  // no matter what (even if shot)
  int threshold;

  // Additional info record for player avatars only.
  struct player_s *player;

  // Player number last looked for.
  int lastlook;

  // For respawning.
  spawnpoint_t spawnpoint;

  float_t origheight;

  // current visibility and target visibility
  float_t visibility;
  float_t vis_target;

  // looking up or down.....
  float_t vertangle;

  // current attack to be made
  const attacktype_t *currentattack;

  // spread count for Ordered spreaders
  int spreadcount;

  // -ES- 1999/10/25 Reference Count. DO NOT TOUCH.
  // All the following mobj references should be set only
  // through P_MobjSetX, where X is the field name. This is useful because
  // it sets the pointer to NULL if the mobj is removed, this protects us
  // from a crash.
  int refcount;

  // source of the mobj, used for projectiles (i.e. the shooter)
  mobj_t * source;

  // target of the mobj
  mobj_t * target;

  // current spawned fire of the mobj
  mobj_t * tracer;

  // if exists, we are supporting/helping this object
  mobj_t * supportobj;
  int side;

  // objects that is above and below this one.  If there were several,
  // then the closest one (in Z) is chosen.  We are riding the below
  // object if the head height == our foot height.  We are being
  // ridden if our head == the above object's foot height.
  //
  mobj_t * above_mo;
  mobj_t * below_mo;

  // these delta values give what position from the ride_em thing's
  // center that we are sitting on.
  float_t ride_dx, ride_dy;

  // -AJA- 1999/09/25: Path support.
  struct rad_script_s *path_trigger;

  // if we're on a ladder, this is the linedef #, otherwise -1.
  int on_ladder;
  
  float_t dlight_qty;
  float_t dlight_target;

  // hash values for TUNNEL missiles
  unsigned long tunnel_hash[2];

  // touch list: sectors this thing is in or touches
  struct touch_node_s *touch_sectors;

  // linked list (mobjlisthead)
  mobj_t *next, *prev;

  // Interaction info, by BLOCKMAP.
  // Links in blocks (if needed).
  mobj_t *bnext, *bprev;

  // More list: links in subsector (if needed)
  mobj_t *snext, *sprev;

  // One more: link in dynamic light blockmap
  mobj_t *dlnext, *dlprev;
};

// Item-in-Respawn-que Structure -ACB- 1998/07/30
typedef struct iteminque_s
{
  spawnpoint_t spawnpoint;
  int time;
  struct iteminque_s *next;
  struct iteminque_s *prev;
}
iteminque_t;

#endif  // __P_MOBJ__
</t>
<t tx="T2575">@ignore

// SaveGame Handling Header

#ifndef __P_SAVEG__
#define __P_SAVEG__

#include "dm_type.h"

// Persistent storage/archiving. These are the load/save game routines.
void P_ArchivePlayers(void);
void P_UnArchivePlayers(void);
void P_ArchiveWorld(void);
void P_UnArchiveWorld(void);
void P_ArchiveThinkers(void);
void P_UnArchiveThinkers(void);
void P_ArchiveItemRespawnQue(void);
void P_UnArchiveItemRespawnQue(void);
void P_ArchiveSpecials(void);
void P_UnArchiveSpecials(void);

extern byte *savebuffer;
extern int savegame_size;
extern byte *save_p;

#endif
</t>
<t tx="T2576">@ignore

// Level Loading/Setup Code

#ifndef __P_SETUP__
#define __P_SETUP__

#include "dm_defs.h"

extern unsigned long mapsector_CRC;
extern unsigned long mapline_CRC;
extern unsigned long mapthing_CRC;
extern int mapthing_NUM;

// -KM- 1998/11/25 Added autotag.  Linedefs with this tag are automatically
//   triggered.
void P_SetupLevel(skill_t skill, int autotag);

// Called by startup code.
boolean_t P_Init(void);

// Needed by savegame code.
void P_RemoveMobjs(void);
void P_RemoveItemsInQue(void);

#endif
</t>
<t tx="T2577">@ignore

// Specials Lines, Elevator &amp; Floor Code

// -KM-  1998/09/01 Lines.ddf
// -ACB- 1998/09/13 Cleaned Up.
// -ACB- 2001/01/14 Added Elevator Types

#ifndef __P_SPEC__
#define __P_SPEC__

#include "e_player.h"
#include "ddf_main.h"
#include "r_defs.h"
#include "w_image.h"

#define CEILSPEED   1.0f
#define FLOORSPEED  1.0f

#define GRAVITY     8.0f
#define FRICTION    0.9063f
#define VISCOSITY   0.0f
#define DRAG        0.99f
#define RIDE_FRICTION    0.7f
#define LADDER_FRICTION  0.8f

#define STOPSPEED   0.15f
#define OOF_SPEED   20.0f

#define MENU_GRAV_NORMAL  8

typedef enum
{
  MDT_INVALID  = 0,
  MDT_ELEVATOR = 1,
  MDT_PLANE    = 2,
  MDT_SLIDER   = 3,
  ENDOFMDTTYPES
}
movedat_e;

typedef struct light_s
{
  // type of light effect
  const lighttype_t *type;

  sector_t *sector;

  // countdown value to next change, or 0 if disabled
  int count;

  // dark and bright levels
  int minlight;
  int maxlight;
  
  // current direction for GLOW type, -1 down, +1 up
  int direction;

  // countdown value for FADE type
  int fade_count;
 
  struct light_s *prev, *next;
}
light_t;

typedef enum
{
  BWH_None,
  BWH_Top,
  BWH_Middle,
  BWH_Bottom
}
bwhere_e;

typedef struct button_s
{
  line_t *line;
  bwhere_e where;
  const image_t *bimage;
  int btimer;
  sfx_t *off_sound;
}
button_t;

// -ACB- 2001/01/29 Maybe I'm thinking too OO.
typedef struct gen_move_s
{
  movedat_e whatiam;
  struct gen_move_s *next, *prev;
}
gen_move_t;

typedef struct elev_move_s
{
  movedat_e whatiam;
  struct elev_move_s *next, *prev;

  const elevator_sector_t *type;
  sector_t *sector;

  float_t startheight;
  float_t destheight;
  float_t speed;

  // 1 = up, 0 = waiting at top, -1 = down
  int direction;
  int olddirection;

  int tag;

  // tics to wait when fully open
  int waited;

  boolean_t sfxstarted;

  int newspecial;

  const image_t *new_ceiling_image;
  const image_t *new_floor_image;
}
elev_move_t;

typedef struct plane_move_s
{
  movedat_e whatiam;
  struct plane_move_s *next, *prev;

  const moving_plane_t *type;
  sector_t *sector;

  boolean_t is_ceiling;

  float_t startheight;
  float_t destheight;
  float_t speed;
  boolean_t crush;

  // 1 = up, 0 = waiting at top, -1 = down
  int direction;
  int olddirection;

  int tag;

  // tics to wait when fully open
  int waited;

  boolean_t sfxstarted;

  int newspecial;
  const image_t *new_image;
}
plane_move_t;

typedef struct slider_move_s
{
  movedat_e whatiam;
  struct slider_move_s *next, *prev;

  const sliding_door_t *info;
  line_t *line;

  // current distance it has opened
  float_t opening;

  // target distance
  float_t target;

  // length of line
  float_t line_len;
 
  // 1 = opening, 0 = waiting, -1 = closing
  int direction;

  // tics to wait at the top
  int waited;

  boolean_t sfxstarted;
  boolean_t final_open;
}
slider_move_t;

// End-level timer (-TIMER option)
extern boolean_t levelTimer;
extern int levelTimeCount;

extern int maxbuttons;
extern button_t *buttonlist;
extern light_t *lights;
extern gen_move_t *active_movparts;

extern linedeftype_t donut[2];

// at map load
void P_SpawnSpecials(int autotag);

// every tic
void P_UpdateSpecials(void);

// when needed
boolean_t P_UseSpecialLine(mobj_t * thing, line_t * line, int side,
    float_t open_bottom, float_t open_top);
boolean_t P_CrossSpecialLine(line_t *ld, int side, mobj_t * thing);
void P_ShootSpecialLine(line_t *ld, int side, mobj_t * thing);
void P_RemoteActivation(mobj_t * thing, int typenum, int tag, 
    int side, trigger_e method);
void P_PlayerInSpecialSector(player_t * player, sector_t *sec);

// Utilities...
int P_TwoSided(int sector, int line);
side_t *P_GetSide(int currentSector, int line, int side);
sector_t *P_GetSector(int currentSector, int line, int side);
sector_t *P_GetNextSector(const line_t * line, const sector_t * sec);

// Info Needs....
float_t P_FindSurroundingHeight(const heightref_e ref, const sector_t *sec);
float_t P_FindRaiseToTexture(sector_t * sec);  // -KM- 1998/09/01 New func, old inline

// -AJA- 1999/09/29: added this.
sector_t *P_FindSectorFromTag(int tag);

int P_FindMinSurroundingLight(sector_t * sector, int max);

// start an action...
boolean_t EV_Lights(sector_t * sec, const lighttype_t * type);

void P_RunActiveSectors(void);

void P_RemoveAllActiveParts(void);
void P_AddActivePart(gen_move_t *movpart);

extern line_t * line_speciallist;
extern sector_t * sect_speciallist;
void P_AddSpecialLine(line_t *ld);
void P_AddSpecialSector(sector_t *sec);

void P_RunLights(void);
light_t *P_NewLight(void);
void P_DestroyAllLights(void);
void P_RunSectorSFX(void);
void P_DestroyAllSectorSFX(void);

void EV_LightTurnOn(int tag, int bright);
boolean_t EV_DoDonut(sector_t * s1, sfx_t * sfx[4]);
boolean_t EV_Teleport(line_t * line, int tag, int side, mobj_t * thing, 
    int delay, int special, const mobjinfo_t * ineffectobj,
    const mobjinfo_t * outeffectobj);
boolean_t EV_ManualPlane(line_t * line, mobj_t * thing, const moving_plane_t * type);
boolean_t EV_ManualElevator(line_t * line, mobj_t * thing, const elevator_sector_t * type);

void EV_DoSlider(line_t * line, mobj_t * thing, const sliding_door_t * s);
boolean_t EV_DoPlane(sector_t * sec, const moving_plane_t * type, sector_t * model);
boolean_t EV_DoElevator(sector_t * sec, const elevator_sector_t * type, sector_t * model);

//
//  P_SWITCH
//
boolean_t P_InitSwitchList(void);
void P_ChangeSwitchTexture(line_t * line, boolean_t useAgain, line_special_e specials, boolean_t noSound);
boolean_t P_ButtonCheckPressed(line_t * line);

#endif
</t>
<t tx="T2578">@ignore

// Thinker &amp; Ticker Code

#ifndef __P_TICK__
#define __P_TICK__

// Called by C_Ticker,
// can call G_PlayerExited.
// Carries out all thinking of monsters and players.
void P_Ticker(void);

#endif
</t>
<t tx="T2579">@ignore

// Weapon (player sprites) Action Code

#ifndef __P_PSPR__
#define __P_PSPR__

// Basic data types.
// Needs fixed point, and BAM angles.
#include "lu_math.h"
#include "m_fixed.h"

#include "ddf_main.h"

// maximum weapons player can hold at once
#define MAXWEAPONS  32

//
// Overlay psprites are scaled shapes
// drawn directly on the view screen,
// coordinates are given for a 320*200 view screen.
//
typedef enum
{
  ps_weapon = 0,
  ps_flash,
  ps_crosshair,
  ps_NOT_USED,

  // -AJA- Savegame code relies on NUMPSPRITES == 4.
  NUMPSPRITES
}
psprnum_t;

typedef struct
{
  // current state.  NULL state means not active
  const state_t *state;

  // state to enter next.
  const state_t *next_state;

  // time (in tics) remaining for current state
  int tics;
  
  // screen position values
  float_t sx;
  float_t sy;

  // translucency values
  float_t visibility;
  float_t vis_target;
}
pspdef_t;

//
// Per-player Weapon Info.
// 
// -AJA- 1999/08/11: added this.

typedef struct
{
  weaponinfo_t *info;

  // player has this weapon.
  boolean_t owned;

  // current clip sizes
  int clip_size;
  int sa_clip_size;
}
playerweapon_t;

#endif
</t>
<t tx="T2580">@ignore

// True BSP Rendering (Definitions)

// -AJA- 1999/08/31: Wrote this file.

#ifndef __R2_DEFS__
#define __R2_DEFS__

#include "v_ctx.h"


struct drawfloor_s;


//
//  R2_BSP
//

typedef struct Y_range_s
{
  // range is inclusive.  y1 &gt; y2 means the column is empty.
  short y1, y2;
}
Y_range_t;

//
// ScreenLine
//
// Stores the info for one on-screen area of a wall, plane or thing.
//
typedef struct screenline_s
{
  // horizontal range (inclusive)
  short x1, x2;

  // vertical columns over x1..x2.
  Y_range_t *ranges;

  // top line (higher on screen), used only for tex coords.  When the
  // ranges are unclipped, this should correspond to the top pixel
  // positions in the ranges.
  float_t y, step;

  // vertical offset (in WORLD coordinates, but positive goes down)
  float_t y_offset;
}
screenline_t;


//
// DrawWall
//
// Stores the info about a single visible section of a wall of a
// subsector.
//
typedef struct drawwall_s
{
  // link for list
  struct drawwall_s *next;

  screenline_t area;

  // seg this belongs to
  seg_t *seg;

  // texture to use
  surface_t *part;
  
  // texture scaling
  float_t scale1;
  float_t scale_step;

  // colourmap &amp; lighting
  region_properties_t *props;

  // dynamic lighting
  int extra_light[2];

  // info for texture mapper
  float_t distance;
  float_t x_offset;
  angle_t angle;

  // contains transparent parts ?
  int is_masked;
  
  // horizontal slider ?
  slidetype_e slide_type;
  float_t opening, line_len;
  int side;
}
drawwall_t;


//
// DrawPlane
//
// Stores the info about a single visible plane (either floor or
// ceiling) of a subsector.
//
typedef struct drawplane_s
{
  // link for list
  struct drawplane_s *next;

  screenline_t area;

  // when true, this drawplane only marks where a plane ends
  // (where it starts will be determined by a future drawplane).
  boolean_t marker_only;

  int face_dir;

  // height
  float_t h;

  // texture &amp; offsets to use
  surface_t *info;

  // colourmap &amp; lighting
  region_properties_t *props;

  // dynamic lighting
  int extra_light[2];
  int min_y, max_y;
}
drawplane_t;


//
// DrawThing
//
// Stores the info about a single visible sprite in a subsector.
//
typedef struct drawthing_s
{
  // link for list
  struct drawthing_s *next;
  struct drawthing_s *prev;

  // Note: the area.ranges field isn't used here, instead the x1..x2
  // range is looked-up in the the containing subsector, which stores
  // *empty* areas to clip against.
  //
  screenline_t area;

  // actual map object
  mobj_t *mo;

  // vertical extent of sprite (world coords)
  float_t top;
  float_t bottom;

  // these record whether this piece of a sprite has been clipped on
  // the left or right side.  We can skip certain clipsegs when one of
  // these is true (and stop when they both become true).
  // 
  boolean_t clipped_left, clipped_right;
  
  // +1 if this sprites should be vertically clipped at a solid
  // floor or ceiling, 0 if just clip at translucent planes, or -1 if
  // shouldn't be vertically clipped at all.
  //
  int clip_vert;
  
  // sprite image to use
  const image_t *image;
  boolean_t flip;

  // scaling
  float_t xfrac;
  float_t xscale;
  float_t yscale;
  float_t ixscale;
  float_t iyscale;
  
  // distance
  float_t dist_scale;

  // translated coords
  float_t tx, tz;
  float_t tx1, tx2;
  
  // colourmap/lighting
  region_properties_t *props;
  boolean_t bright;
  const byte *trans_table;

  // dynamic lighting
  int extra_light;

  //...

  // world offsets for GL
  float_t left_dx,  left_dy;
  float_t right_dx, right_dy;
  
  // EXPERIMENTAL
  boolean_t is_shadow;
  boolean_t is_halo;
}
drawthing_t;


//
// DrawFloor
//
// Stores all the information needed to draw a single on-screen
// floor of a subsector.
//
typedef struct drawfloor_s
{
  // link for list, drawing order
  struct drawfloor_s *next, *prev;

  // link for height order list
  struct drawfloor_s *higher, *lower;

  // heights for this floor
  float_t f_h, c_h, top_h;
 
  surface_t *floor, *ceil;

  extrafloor_t *ef;

  // properties used herein
  region_properties_t *props;

  // list of walls (includes midmasked textures)
  drawwall_t *walls;

  // list of planes (including translucent ones).
  drawplane_t *planes;

  // list of things
  // (not sorted until R2_DrawFloor is called).
  drawthing_t *things;

  // list of dynamic lights
  drawthing_t *dlights;
}
drawfloor_t;


extern int detail_level;
extern boolean_t use_dlights;
extern int sprite_kludge;

boolean_t R2_CheckBBox(float_t *bspcoord);
void R2_RenderTrueBSP(void);

const image_t * R2_GetThingSprite(mobj_t *mo, boolean_t *flip);
const image_t * R2_GetOtherSprite(int sprite, int frame, boolean_t *flip);
void R2_ClipSpriteVertically(subsector_t *dsub, drawthing_t *dthing);

void R2_AddDLights(int num, int *level, 
    float_t *x, float_t *y, float_t *z, mobj_t *mo);
void R2_AddColourDLights(int num, int *r, int *g, int *b, 
    float_t *x, float_t *y, float_t *z, mobj_t *mo);
void R2_FindDLights(subsector_t *sub, drawfloor_t *dfloor);


//
//  R2_UTIL
//

typedef struct tilesky_s
{
  boolean_t active;
  
  const tilesky_info_t *info;

  // linedef that info comes from
  struct line_s *line;
}
tilesky_t;

extern byte *subsectors_seen;
extern Y_range_t Screen_clip[2048];

extern tilesky_t sky_tiles[4];
extern int sky_tiles_active;

void R2_InitUtil(void);
void R2_ClearBSP(void);

drawwall_t  *R2_GetDrawWall(void);
drawplane_t *R2_GetDrawPlane(void);
drawthing_t *R2_GetDrawThing(void);
drawfloor_t *R2_GetDrawFloor(void);

void R2_CommitDrawWall(int used);
void R2_CommitDrawPlane(int used);
void R2_CommitDrawThing(int used);
void R2_CommitDrawFloor(int used);

Y_range_t *R2_GetOpenings(int width);
void R2_CommitOpenings(int width);

void R2_1DOcclusionClear(int x1, int x2);
void R2_1DOcclusionSet(int x1, int x2);
boolean_t R2_1DOcclusionTest(int x1, int x2);
boolean_t R2_1DOcclusionTestShrink(int *x1, int *x2);
void R2_1DOcclusionClose(int x1, int x2, Y_range_t *ranges);

void R2_2DOcclusionClear(int x1, int x2);
void R2_2DOcclusionClose(int x1, int x2, Y_range_t *ranges,
    boolean_t connect_low, boolean_t connect_high, boolean_t solid);
void R2_2DOcclusionCopy(int x1, int x2, Y_range_t *ranges);
void R2_2DUpdate1D(int x1, int x2);

void R2_TileSkyClear(void);
void R2_TileSkyAdd(const tilesky_info_t *info, struct line_s *line);

int R2_GetPointLOD(float_t x, float_t y, float_t z);
int R2_GetBBoxLOD(float_t x1, float_t y1, float_t z1,
    float_t x2, float_t y2, float_t z2);
int R2_GetWallLOD(float_t x1, float_t y1, float_t z1,
    float_t x2, float_t y2, float_t z2);
int R2_GetPlaneLOD(subsector_t *sub, float_t h);


//
//  R2_DRAW
//

extern video_context_t vctx;

void R2_DrawWall (subsector_t *dsub, drawwall_t  *wall);
void R2_DrawPlane(subsector_t *dsub, drawplane_t *plane);
void R2_DrawThing(subsector_t *dsub, drawthing_t *thing);
void R2_DrawFloor(subsector_t *dsub, drawfloor_t *dfloor);
void R2_DrawSubsector(subsector_t *dsub);
void R2_DrawPlayerSprites(player_t * p);

void BOGUS_Clear(void);
void BOGUS_Line(float x1, float y1, float x2, float y2, int col);

void R2_Init(void);


#endif  // __R2_DEFS__

</t>
<t tx="T2581">@ignore

// BSP Handling Code

#ifndef __R_BSP__
#define __R_BSP__

#include "r_defs.h"
#include "z_zone.h"

extern side_t *sidedef;
extern line_t *linedef;
extern sector_t *frontsector;
extern sector_t *backsector;
extern int root_node;

extern int rw_x;
extern int rw_stopx;

extern boolean_t segtextured;

// false if the back side is the same plane
extern boolean_t markfloor;
extern boolean_t markceiling;

extern boolean_t skymap;

#endif
</t>
<t tx="T2582">@ignore

// Rendering Data Handling Code

// DESCRIPTION:
//  Refresh module, data I/O, caching, retrieval of graphics by name.

#ifndef __R_DATA__
#define __R_DATA__

#include "r_defs.h"
#include "r_state.h"

// I/O, setting up the stuff.
boolean_t R_InitFlats(void);
boolean_t R_InitPicAnims(void);

void R_AddFlatAnim(animdef_t *anim);
void R_AddTextureAnim(animdef_t *anim);
void R_PrecacheLevel(void);

#endif
</t>
<t tx="T2583">@ignore

// Rendering Definitions Header

#ifndef __R_DEFS__
#define __R_DEFS__

// Screenwidth.
#include "dm_defs.h"

// Some more or less basic data types
// we depend on.
#include "m_fixed.h"
#include "m_math.h"

// SECTORS do store MObjs anyway.
#include "p_mobj.h"

// -AJA- 1999/07/10: Need this for colourmap_t.
#include "ddf_main.h"

struct image_s;

// Silhouette, needed for clipping Segs (mainly)
// and sprites representing things.
#define SIL_NONE                0
#define SIL_BOTTOM              1
#define SIL_TOP                 2
#define SIL_BOTH                3


//
// INTERNAL MAP TYPES
//  used by play and refresh
//

//
// Your plain vanilla vertex.
// Note: transformed values not buffered locally, like some
// DOOM-alikes ("wt", "WebView") did.
//
typedef vec2_t vertex_t;

// Forward of LineDefs, for Sectors.
struct line_s;
struct side_s;
struct region_properties_s;


//
// Touch Node
//
// -AJA- Used for remembering things that are inside or touching
// sectors.  The idea is blatantly copied from BOOM: there are two
// lists running through each node, (a) list for things, to remember
// what sectors they are in/touch, (b) list for sectors, holding what
// things are in or touch them.
//
// NOTE: we use the same optimisation: in P_UnsetThingPos we just
// clear all the `mo' fields to NULL.  During P_SetThingPos we find
// the first NULL `mo' field (i.e. as an allocation).  The interesting
// part is that we only need to unlink the node from the sector list
// (and relink) if the sector in that node is different.  Thus saving
// work for the common case where the sector(s) don't change.
// 
// CAVEAT: this means that very little should be done in between
// P_UnsetThingPos and P_SetThingPos calls, ideally just load some new
// x/y position.  Avoid especially anything that scans the sector
// touch lists.
//
typedef struct touch_node_s
{
  struct mobj_s *mo;
  struct touch_node_s *mo_next;
  struct touch_node_s *mo_prev;

  struct sector_s *sec;
  struct touch_node_s *sec_next;
  struct touch_node_s *sec_prev;
}
touch_node_t;


//
// Region Properties
//
// Stores the properties that affect each vertical region.
//
// -AJA- 1999/10/09: added this.
//
typedef struct region_properties_s
{
  // rendering related
  int lightlevel;
  const colourmap_t *colourmap;

  // special type (e.g. damaging)
  const specialsector_t *special;

  // -KM- 1998/10/29 Added gravity + friction
  float_t gravity;
  float_t friction;
  float_t viscosity;
  float_t drag;

  // pushing sector information (normally all zero)
  vec3_t push;
}
region_properties_t;

//
// Surface
//
// Stores the texturing information about a single "surface", which is
// either a wall part or a ceiling/floor.  Doesn't include position
// info -- that is elsewhere.
// 
typedef struct surface_s
{
  const struct image_s *image;

  float_t translucency;

  // transformation matrix (usually identity)
  vec2_t x_mat;
  vec2_t y_mat;

  // current offset and scrolling deltas
  vec2_t offset;
  vec2_t scroll;

  // lighting override (as in BOOM).  Usually NULL.
  struct region_properties_s *override_p;
}
surface_t;

//
// ExtraFloor
//
// Stores information about a single extrafloor within a sector.
//
// -AJA- 2001/07/11: added this, replaces vert_region.
//
typedef struct extrafloor_s
{
  // links in chain.  These are sorted by increasing heights, using
  // bottom_h as the reference.  This is important, especially when a
  // liquid extrafloor overlaps a solid one: using this rule, the
  // liquid region will be higher than the solid one.
  // 
  struct extrafloor_s *higher;
  struct extrafloor_s *lower;

  struct sector_s *sector;

  // top and bottom heights of the extrafloor.  For non-THICK
  // extrafloors, these are the same.  These are generally the same as
  // in the dummy sector, EXCEPT during the process of moving the
  // extrafloor.
  //
  float_t top_h, bottom_h;

  // top/bottom surfaces of the extrafloor
  surface_t *top;
  surface_t *bottom;

  // properties used for stuff below us
  region_properties_t *p;

  // type of extrafloor this is.  Only NULL for unused extrafloors.
  // This value is cached pointer to ef_line-&gt;special-&gt;ef.
  //
  const extrafloor_info_t *ef_info;

  // extrafloor linedef (frontsector == control sector).  Only NULL
  // for unused extrafloors.
  //
  struct line_s *ef_line;

  // link in dummy sector's controlling list
  struct extrafloor_s *ctrl_next;
}
extrafloor_t;

// Vertical gap between a floor &amp; a ceiling.
// -AJA- 1999/07/19. 
//
typedef struct
{
  float_t f;  // floor
  float_t c;  // ceiling
}
vgap_t;


//
// The SECTORS record, at runtime.
//
struct subsector_s;

typedef struct sector_s
{
  // floor and ceiling heights
  float_t f_h, c_h;

  surface_t floor, ceil;

  region_properties_t props;

  int tag;

  // set of extrafloors (in the global `extrafloors' array) that this
  // sector can use.  At load time we can deduce the maximum number
  // needed for extrafloors, even if they dynamically come and go.
  //
  short exfloor_max;
  short exfloor_used;
  extrafloor_t *exfloor_first;

  // -AJA- 2001/07/11: New multiple extrafloor code.
  //
  // Now the FLOORS ARE IMPLIED.  Unlike before, the floor below an
  // extrafloor is NOT stored in each extrafloor_t -- you must scan
  // down to find them, and use the sector's floor if you hit NULL.
  //
  extrafloor_t *bottom_ef;
  extrafloor_t *top_ef;

  // Liquid extrafloors are now kept in a separate list.  For many
  // purposes (especially moving sectors) they otherwise just get in
  // the way.
  //
  extrafloor_t *bottom_liq;
  extrafloor_t *top_liq;

  // properties that are active for this sector (top-most extrafloor).
  // This may be different than the sector's actual properties (the
  // "props" field) due to flooders.
  // 
  region_properties_t *p;
 
  // linked list of extrafloors that this sector controls.  NULL means
  // that this sector is not a controller.
  //
  extrafloor_t *control_floors;
 
  // movement thinkers, for quick look-up
  struct gen_move_s *floor_move;
  struct gen_move_s *ceil_move;

  // 0 = untraversed, 1,2 = sndlines-1
  int soundtraversed;

  // player# that made a sound (starting at 0), or -1
  int sound_player;

  // mapblock bounding box for height changes
  int blockbox[4];

  // origin for any sounds played by the sector
  degenmobj_t soundorg;

  int linecount;
  struct line_s **lines;  // [linecount] size

  // touch list: objects in or touching this sector
  touch_node_t *touch_things;
    
  // sky height for GL renderer
  float_t sky_h;
 
  // keep track of vertical sight gaps within the sector.  This is
  // just a much more convenient form of the info in the extrafloor
  // list.
  // 
  short max_gaps;
  short sight_gap_num;

  vgap_t *sight_gaps;

  // if == validcount, already checked
  int validcount;

  // -AJA- 1999/07/29: Keep sectors with same tag in a list.
  struct sector_s *tag_next;
  struct sector_s *tag_prev;

  // Keep animating sectors in a linked list.
  struct sector_s *animate_next;
 
  // -AJA- 2000/03/30: Keep a list of child subsectors.
  struct subsector_s *subsectors;
}
sector_t;


typedef struct wall_tile_s
{
  // vertical extent of this tile.  The seg determines the horizontal
  // extent.
  // 
  float_t z1, z2;

  // texturing top, in world coordinates
  float_t tex_z;

  // various flags
  int flags;

  // corresponding surface.  NULL if this tile is unused.
  surface_t *surface;
}
wall_tile_t;

#define WTILF_Extra    0x0001
#define WTILF_MidMask  0x0004
#define WTILF_Sky      0x0010
#define WTILF_Slider   0x0020


//
// The SideDef.
//
typedef struct side_s
{
  surface_t top;
  surface_t middle;
  surface_t bottom;

  // Sector the SideDef is facing.
  sector_t *sector;

  // set of tiles used for this side
  short tile_max;
  short tile_used;
  wall_tile_t *tiles;

  // midmasker Y offset
  float_t midmask_offset;
}
side_t;

//
// Move clipping aid for LineDefs.
//
typedef enum
{
  ST_HORIZONTAL,
  ST_VERTICAL,
  ST_POSITIVE,
  ST_NEGATIVE
}
slopetype_t;

//
// LINEDEF
//
typedef struct line_s
{
  // Vertices, from v1 to v2.
  vertex_t *v1;
  vertex_t *v2;

  // Precalculated v2 - v1 for side checking.
  float_t dx;
  float_t dy;
  float_t length;

  // Animation related.
  int flags;
  int tag;
  int count;

  const linedeftype_t *special;

  // Visual appearance: SideDefs.
  // side[1] will be NULL if one sided.
  side_t *side[2];

  // Front and back sector.
  // Note: kinda redundant (could be retrieved from sidedefs), but it
  // simplifies the code.
  sector_t *frontsector;
  sector_t *backsector;

  // Neat. Another bounding box, for the extent of the LineDef.
  float_t bbox[4];

  // To aid move clipping.
  slopetype_t slopetype;

  // if == validcount, already checked
  int validcount;

  // whether this linedef is "blocking" for rendering purposes.
  // Always true for 1s lines.  Always false when both sides of the
  // line reference the same sector.
  //
  boolean_t blocked;

  // -AJA- 1999/07/19: Extra floor support.  We now keep track of the
  // gaps between the front &amp; back sectors here, instead of computing
  // them each time in P_LineOpening() -- which got a lot more complex
  // due to extra floors.  Now they only need to be recomputed when
  // one of the sectors changes height.  The pointer here points into
  // the single global array `vertgaps'.
  //
  short max_gaps;
  short gap_num;

  vgap_t *gaps;

  // slider thinker, normally NULL
  struct slider_move_s *slider_move;

  // Keep animating lines in a linked list.
  struct line_s *animate_next;
}
line_t;

//
// SubSector.
//
// References a Sector.
// Basically, this is a list of LineSegs, indicating the visible walls
// that define all sides of a convex BSP leaf.
//
typedef struct subsector_s
{
  // link in sector list
  struct subsector_s *sec_next;
  
  sector_t *sector;
  struct seg_s *segs;

  // list of mobjs in subsector
  mobj_t *thinglist;

  // pointer to bounding box (usually in parent node)
  float_t *bbox;

  // -- Rendering stuff (only used during rendering) --

  // link in render list (furthest to closest)
  struct subsector_s *rend_next, *rend_prev;

  // here we remember the 1D/2D occlusion buffer (for sprite
  // clipping).
  byte clip_left, clip_right;
  short x_min, x_max;
  struct Y_range_s *ranges;

  // list of floors (sorted into drawing order)
  struct drawfloor_s *floors;

  // floors sorted in height order.
  struct drawfloor_s *z_floors;

  // list of sprites to draw (unsorted).  The sprites on this list are
  // unclipped (both horizontally and vertically).  Later on in the
  // rendering process they are clipped, whereby they get moved into
  // the correct drawfloors.
  struct drawthing_s *raw_things;
}
subsector_t;

//
// The LineSeg
//
// Defines part of a wall that faces inwards on a convex BSP leaf.
//
typedef struct seg_s
{
  vertex_t *v1;
  vertex_t *v2;

  angle_t angle;
  float_t length;

  // link in subsector list.
  // (NOTE: sorted in clockwise order)
  struct seg_s *sub_next;
  
  // -AJA- 1999/12/20: Reference to partner seg, or NULL if the seg
  //       lies along a one-sided line.
  struct seg_s *partner;

  // -AJA- 1999/09/23: Reference to subsector on each side of seg,
  //       back_sub is NULL for one-sided segs.
  //       (Addendum: back_sub is obsolete with new `partner' field)
  subsector_t *front_sub;
  subsector_t *back_sub;
  
  // -AJA- 1999/09/23: For "True BSP rendering", we keep track of the
  //       `minisegs' which define all the non-wall borders of the
  //       subsector.  Thus all the segs (normal + mini) define a
  //       closed convex polygon.  When the `miniseg' field is true,
  //       all the fields below it are unused.
  //
  boolean_t miniseg;

  float_t offset;

  side_t *sidedef;
  line_t *linedef;

  // Sector references.
  // backsector is NULL for one sided lines

  sector_t *frontsector;
  sector_t *backsector;

  // -- Rendering stuff (only used during rendering) --

  boolean_t visible;
  boolean_t back;

  unsigned short x1, x2;
  angle_t angle1, angle2;
  float_t scale1, scale2;
  float_t rw_distance, rw_offset;

  // translated coords
  float_t tx1, tz1;
  float_t tx2, tz2;
  
  // orientation.  (Used for sprite clipping)
  //    0 : not needed for clipping (e.g. parallel to viewplane)
  //   +1 : right side (on screen) faces containing subsector
  //   -1 : left  side (on screen) faces containing subsector
  int orientation;
}
seg_t;

// Partition line.
typedef struct divline_s
{
  float_t x;
  float_t y;
  float_t dx;
  float_t dy;
}
divline_t;

//
// BSP node.
//
typedef struct node_s
{
  divline_t div;
  float_t div_len;

  // If NF_SUBSECTOR its a subsector.
  unsigned short children[2];

  // Bounding boxes for this node.
  float_t bbox[2][4];
}
node_t;

// posts are runs of non masked source pixels
typedef struct
{
  // -1 is the last post in a column
  byte topdelta;

  // length data bytes follows
  byte length;  // length data bytes follows
}
post_t;

// column_t is a list of 0 or more post_t, (byte)-1 terminated
typedef post_t column_t;


//
// OTHER TYPES
//

// Lighttables.
//
// Each value ranges from 0 to 255, from totally black to fully lighted.
// The values get scaled to fit the colourmap being used (e.g. divided
// by 8 for the 32-level COLORMAP lump).
//
typedef byte lighttable_t;

// Coltables.
//
// Each coltable is 256 bytes from some colourmap lump, which maps the
// index colour to a palette colour.  In 16-bit mode however, it is 256
// shorts which are the pixel values for the screen.
//
typedef byte coltable_t;

//      
// Sprites are patches with a special naming convention so they can be
// recognized by R_InitSprites.  The base name is NNNNFx or NNNNFxFx,
// with x indicating the rotation, x = 0, 1-15.
//
// Horizontal flipping is used to save space, thus NNNNF2F5 defines a
// mirrored patch (F5 is the mirrored one).
//
// Some sprites will only have one picture used for all views: NNNNF0.
// In that case, the `rotated' field is false.
//
typedef struct spriteframe_s
{
  // whether this frame has been completed.  Completed frames cannot
  // be replaced by sprite lumps in older wad files.
  // 
  byte finished;
  
  // if not rotated, we don't have to determine the angle for the
  // sprite.  This is an optimisation.
  // 
  byte rotated;
  
  // Flip bits (1 = flip) to use for view angles 0-15.
  byte flip[16];
  
  // normally zero, will be 1 if the [9ABCDEFG] rotations are used.
  byte extended;
    
  // Images for each view angle 0-15.  Never NULL.
  const struct image_s *images[16];
}
spriteframe_t;

// utility macro.
#define ANG_2_ROT(angle)  ((angle_t)(angle) &gt;&gt; (ANGLEBITS-4))

//
// A sprite definition: a number of animation frames.
//
typedef struct spritedef_s
{
  // four letter sprite name (e.g. "TROO").
  char name[6];
  
  // total number of frames.  Zero for missing sprites.
  int numframes;

  // sprite frames.
  spriteframe_t *frames;
}
spritedef_t;

#endif  // __R_DEFS__
</t>
<t tx="T2584">@ignore

// Column/Span Drawing for 8-bit Colour Code

//
// -ACB- 1998/09/10 Cleaned up.
//

#ifndef __R_DRAW1__
#define __R_DRAW1__

#include "con_cvar.h"

extern funclist_t drawcol8_funcs;
extern funclist_t drawspan8_funcs;

void resinit_r_draw_c8(void);

void R_DrawColumn8_CVersion(void);  // C Version
void R_DrawColumn8_MIP(void);  // Mipmap version
void R_DrawColumn8_vfi(void);  // David Finch's fast smooth version
void R_DrawColumn8_KM(void);  // Smooth version
void R_DrawColumn8_BLF(void);  // Smooth version
void R_DrawColumn8_id(void);  // id's original
void R_DrawColumn8_id_Erik(void);  // improved id's original
void R_DrawColumn8_Pentium(void);  // Optimised for Pentium
void R_DrawColumn8_Chi(void);  // DOSDoom original
void R_DrawColumn8_K6_MMX(void);  // MMX asm version, optimised for K6
void R_DrawColumn8_Rasem(void);  // Rasem's
void R_DrawColumn8_dontdraw(void);  // Returns without drawing anything

void R_DrawFuzzColumn8(void);

void R_DrawTranslucentColumn8(void);
void R_DrawTranslucentColumn8_MIP(void);
void R_DrawTranslucentSpan8(void);
void R_DrawTranslucentSpan8_MIP(void);
void R_DrawHoleySpan8_MIP(void);
void R_DrawHaloColumn8_MIP(void);

void R_DrawTranslatedColumn8(void);
void R_DrawTranslucentTranslatedColumn8(void);

void R_DrawSpan8_CVersion(void);  // C Version
void R_DrawSpan8_MIP(void);  // Mipmap version
void R_DrawSpan8_vfi(void);  // David Finch's fast smooth version
void R_DrawSpan8_KM(void);  // Interpolated
void R_DrawSpan8_BLF(void);  // Bilinear Filtering
void R_DrawSpan8_id(void);  // id's original
void R_DrawSpan8_id_Erik(void);  // improved id's original
void R_DrawSpan8_MMX(void);  // MMX asm version
void R_DrawSpan8_Rasem(void);  // Rasem's
void R_DrawSpan8_dontdraw(void);  // Returns without drawing anything

void R_InitFunctions_Draw1(void);

void R_VideoErase8(unsigned ofs, int count);
void R_FillBackScreen8(void);
void R_DrawViewBorder8(void);

#endif
</t>
<t tx="T2585">@ignore

// Column/Span Drawing for 16-bit Colour Code

// Note: The best place for optimisation!
//
// -ACB- 1998/09/10 Cleaned up.

#ifndef __R_DRAW2__
#define __R_DRAW2__
#ifndef NOHICOLOUR

#include "con_cvar.h"

extern funclist_t drawcol16_funcs;
extern funclist_t drawspan16_funcs;

void resinit_r_draw_c16(void);

void R_DrawColumn16_KM(void);  // Smooth version
void R_DrawColumn16_BLF(void);  // Smooth version
void R_DrawColumn16_CVersion(void);  // C Version
void R_DrawColumn16_MIP(void);  // Mipmap version
void R_DrawColumn16_Rasem(void);  // Rasem's
void R_DrawColumn16_Chi(void);  // Chi's Original
void R_DrawSpan16_BLF(void);  // Bilinear Filtering

void R_DrawFuzzColumn16(void);

void R_DrawTranslucentColumn16(void);
void R_DrawTranslucentColumn16_MIP(void);
void R_DrawTranslucentSpan16(void);
void R_DrawTranslucentSpan16_MIP(void);
void R_DrawHoleySpan16_MIP(void);
void R_DrawHaloColumn16_MIP(void);

void R_DrawTranslatedColumn16(void);
void R_DrawTranslucentTranslatedColumn16(void);

void R_DrawSpan16_KM(void);  // Smooth version
void R_DrawSpan16_CVersion(void);  // C Version
void R_DrawSpan16_MIP(void);  // Mipmap Version
void R_DrawSpan16_Rasem(void);  // Rasem's
void R_InitFunctions_Draw2(void);

void R_VideoErase16(unsigned ofs, int count);
void R_FillBackScreen16(void);
void R_DrawViewBorder16(void);

#endif // NOHICOLOUR
#endif // __R_DRAW2__
</t>
<t tx="T2586">@ignore

// Layer Rendering System

//  See the file "docs/layersys.txt" for a complete description of the
//  layer system.
//
//  -AJA- 2000/06/13: Started work on this file.

#ifndef __R_LAYERS__
#define __R_LAYERS__


//
// Flags/Properties
//

typedef enum
{
  // Whether this layer is active or not.  Only active layers get
  // drawn and receive events.
  
  LAYF_Active = 0x0001,
  
  // The layer is completely solid, nothing inside the layer bounding
  // rectangle will show through.
  
  LAYF_Solid = 0x0002,

  // The layer is Volatile, which means the contents are always
  // changing.  Camera views are examples of volatile layers.  Use
  // this for "Non-Clippable" layers as well
  
  LAYF_Volatile = 0x0004
}
layerflags_e;


//
// LAYER itself
//

typedef struct layer_s
{
  // Link in list.
  
  struct layer_s *next;
  struct layer_s *prev;

  // Parent layer, or NULL if this is a top level layer.
  
  struct layer_s *parent;

  // Child list (often empty).  All children layers are considered to
  // sit above their parent.
  
  struct layer_s *children;

  // Depth.  Higher layers are drawn later than lower ones.  Multiple
  // layers of the same depth are allowed, but the results are
  // undefined if they overlap.

  int depth;

  // Rectangular bounds of layer on the screen.  (x,y) coordinates are
  // absolute.  Coordinates are inclusive.
  
  int x1, y1, x2, y2;

  // Various flags/properties for the layer.
  
  layerflags_e flags;

  // Draw routine.  Can be NULL (for listen-only layers).  Doesn't
  // need to handle child layers, they will be called automatically.
  // All drawing MUST be clipped to the current clipping rectangle (in
  // the clip_* fields).
  
  void (* Drawer)(struct layer_s *layer);
  
  // Event handler.  Can be NULL (for draw-only layers).  Doesn't need
  // to handle child layers, they will be called automatically.
  
  boolean_t (* Listener)(struct layer_s *layer, event_t *ev);

  // Resize routine, called whenever the parent layer's bounding box
  // changes.  For top level layers, this means whenever the user
  // selects a different video mode.  Must not be NULL !  The routine
  // must call R_LayerChangeBounds() on itself with the new size; this
  // will take care of resizing any children layers.  The parameters
  // are the parent layer bounds.
  
  void (* Resizer)(struct layer_s *layer, int x1, int y1, int x2, int y2);

  // Private pointer, store any layer-specific information here.  Must
  // be allocated with Z_New() or similiar if not NULL.
  
  void *private;

  // --- stuff private to layer system itself ---

  // Layer is not visible (e.g. completely covered by a higher layer
  // that is solid, or lies totally outside parent's bounding box).
  
  boolean_t invisible;
  
  // Index into stack array of solid rectangles.  All solid rects
  // strictly _before_ this value can be used for clipping.
  
  int solid_index;

  // Current clipping rectangle (based on parent and current layer
  // dimensions).  Only valid when Drawer() is called, and the draw
  // function MUST clip to this rectangle. 

  int clip_x1, clip_y1, clip_x2, clip_y2;

  // Visible size of the layer (assuming `invisible' field is false)
  // once clipped to the solid rectangles.  No need to draw anything
  // outside of this rectangle, e.g. a rendering window can skip
  // columns and spans the lie totally outside.  Only valid when
  // Drawer() is called.  This rectangle is guaranteed to exist
  // completely within the clip rectangle.

  int vis_x1, vis_y1, vis_x2, vis_y2;
}
layer_t;


extern layer_t *layer_list;


//
// SOLID RECTS
//

extern layer_t ** solid_rects;
extern int num_solid_rects;


//
// INTERFACE
//

boolean_t R_LayerInit(void);

layer_t *R_LayerNew(int depth, int x1, int y1, int x2, int y2,
    layerflags_e flags, void *private);
void R_LayerDestroy(layer_t *layer);

void R_LayerAdd(layer_t *parent, layer_t *layer);
void R_LayerRemove(layer_t *layer);

void R_LayerEnable(layer_t *layer);
void R_LayerDisable(layer_t *layer);

void R_LayerChangeBounds(layer_t *layer, int x1, int y1, int x2, int y2);
void R_LayerChangeFlags(layer_t *layer, layerflags_e flags);
void R_LayerChangeContents(layer_t *layer);

boolean_t R_LayerClipRectToSolids(int solid_index,
    int *x1, int *y1, int *x2, int *y2);

void R_DrawLayers(void);
boolean_t R_ListenLayers(event_t *ev);
void R_ResizeLayers(void);


#endif  // __R_LAYERS__
</t>
<t tx="T2587">@ignore

// Refresh Local Header

//
// DESCRIPTION:
//   Refresh (R_*) module, global header.
//   All the rendering/drawing stuff is here.
//

#ifndef __R_LOCAL__
#define __R_LOCAL__

// Binary Angles, sine/cosine/atan lookups.
#include "lu_math.h"

// Screen size related parameters.
#include "dm_defs.h"

// Include the refresh/render data structs.
#include "r_data.h"

//
// Separate header file for each module.
//
#include "r_main.h"
#include "r_bsp.h"
#include "r_segs.h"
#include "r_plane.h"
#include "r_things.h"
#include "v_res.h"

#endif // __R_LOCAL__
</t>
<t tx="T2588">@ignore

// Main Rendering Organisation Code

//
// -KM- 1998/09/27 Dynamic Colourmaps.
//

#ifndef __R_MAIN__
#define __R_MAIN__

#include "e_player.h"
#include "r_data.h"
#include "r_defs.h"

//
// POV related.
//
extern float_t viewcos;
extern float_t viewsin;
extern float_t viewvertangle;

extern subsector_t *viewsubsector;
extern region_properties_t *view_props;

extern int viewwidth;
extern int viewheight;
extern int viewwindowx;
extern int viewwindowy;
extern int viewwindowwidth;
extern int viewwindowheight;

// the x and y coords of the focus
// -ES- 1999/03/19 Renamed center to focus
extern float_t focusxfrac;
extern float_t focusyfrac;

extern int validcount;

extern int linecount;

// -ES- 1999/03/29 Added these
extern angle_t normalfov, zoomedfov;
extern boolean_t viewiszoomed;

extern boolean_t setsizeneeded;
extern boolean_t changeresneeded;  // -ES- 1998/08/20
extern int use_3d_mode;

extern int framecount;

//
// Lighting LUT.
// Used for z-depth cuing per column/row,
//  and other lighting effects (sector ambient, flash).
//

// Lighting constants.
#define LIGHTLEVELS	        32
#define LIGHTSEGSHIFT	         3

#define MAXLIGHTZ	       512
#define LIGHTZSHIFT		18
#define FLAT_LIGHTZ             24

#define MAXLIGHTSCALE		48
#define LIGHTSCALESHIFT		12
#define FLAT_LIGHTSCALE         16

extern lighttable_t zlight[LIGHTLEVELS][MAXLIGHTZ];
extern lighttable_t scalelight[LIGHTLEVELS][MAXLIGHTSCALE];

extern int extralight;
extern const colourmap_t *effect_colourmap;
extern float_t effect_strength;
extern boolean_t effect_infrared;
extern boolean_t setresfailed;

//
// Function pointers to switch refresh/drawing functions.
// Used to select shadow mode etc.
//
extern void (*colfunc) (void);
extern void (*basecolfunc) (void);
extern void (*fuzzcolfunc) (void);
extern void (*spanfunc) (void);
extern void (*trans_spanfunc) (void);

//
// Utility functions.
angle_t R_PointToAngle(float_t x1, float_t y1, float_t x2, float_t y2);
float_t R_PointToDist(float_t x1, float_t y1, float_t x2, float_t y2);
float_t R_ScaleFromGlobalAngle(angle_t visangle);
subsector_t *R_PointInSubsector(float_t x, float_t y);
region_properties_t *R_PointGetProps(subsector_t *sub, float_t z);

//
// REFRESH - the actual rendering functions.
//

// Renders the view for the next frame.
extern void (*R_Render) (void);

// Called by startup code.
boolean_t R_Init(void);

// -ES- 1998/09/11 Added these prototypes.
void R_SetViewSize(int blocks);

// Changes Field of View to the specified angle.
void R_SetFOV(angle_t fov);

// Changes the FOV variables that the zoom key toggles between.
void R_SetNormalFOV(angle_t newfov);
void R_SetZoomedFOV(angle_t newfov);

// call this to change the resolution before the next frame.
void R_ChangeResolution(int width, int height, int depth, boolean_t windowed);

void R_StartFading(int start, int range);

// only call these when it really is time to do the actual resolution
// or view size change, i.e. at the start of a frame.
void R_ExecuteChangeResolution(void);
void R_ExecuteSetViewSize(void);

#endif
</t>
<t tx="T2589">@ignore

// Floor and Ceiling Rendering Code

// -KM- 1998/09/27 Dynamic colourmaps

#ifndef __R_PLANE__
#define __R_PLANE__

#include "r_data.h"
#include "m_math.h"
#include "z_zone.h"

// -ES- 1999/03/20 Removed origyslope
extern float_t *yslope;
extern float_t *distscale;

// -ES- 1999/05/26 Externalised these.
extern int *spanstart;

#endif
</t>
<t tx="T2590">@ignore

// Segs Code

#ifndef __R_SEGS__
#define __R_SEGS__

#endif
</t>
<t tx="T2591">@ignore

// Sky Handling Code

#ifndef __R_SKY__
#define __R_SKY__

// SKY, store the number for name.
#define SKYFLATNAME  "F_SKY1"

// The sky map is 256*4 wide (10 bits), and angles have 32 bits
#define ANGLETOSKYSHIFT  (32 - 10)

extern float_t skytexturemid;

extern const struct image_s *sky_image;

// -ES- 1999-04-11 Added This
extern float_t skytexturescale;

// Called every frame.
void R_InitSkyMap(void);

// Used by GL renderer
void R_ComputeSkyHeights(void);

#endif
</t>
<t tx="T2592">@ignore

// Refresh internal state variables

#ifndef __R_STATE__
#define __R_STATE__

// Need data structure definitions.
#include "e_player.h"
#include "r_data.h"
#include "m_math.h"

//
// Lookup tables for map data.
//
extern int numsprites;
extern spritedef_t *sprites;

extern int numvertexes;
extern vertex_t *vertexes;

extern int num_gl_vertexes;
extern vertex_t *gl_vertexes;

extern int numsegs;
extern seg_t *segs;

extern int numsectors;
extern sector_t *sectors;

extern int numsubsectors;
extern subsector_t *subsectors;

extern int numextrafloors;
extern extrafloor_t *extrafloors;
     
extern int numnodes;
extern node_t *nodes;

extern int numlines;
extern line_t *lines;

extern int numsides;
extern side_t *sides;

extern int numwalltiles;
extern wall_tile_t *walltiles;

extern int numvertgaps;
extern vgap_t *vertgaps;

//
// POV data.
//
extern float_t viewx;
extern float_t viewy;
extern float_t viewz;

extern angle_t viewangle;

// -ES- 1999/03/20 Added these.
// Angles that are used for linedef clipping.
// Nearly the same as leftangle/rightangle, but slightly rounded to fit
// viewangletox lookups, and converted to BAM format.

// angles used for clipping
extern angle_t leftclipangle, rightclipangle;

// the scope of the clipped area (leftclipangle-rightclipangle)
extern angle_t clipscope;

// the most extreme angles of the view
extern angle_t topangle, bottomangle,
 rightangle, leftangle;
// tangents for the angles
extern float_t topslope, bottomslope,
 rightslope, leftslope;

// -ES- 1999/03/02 Added these.
extern angle_t FIELDOFVIEW;  // Number of FINEANGLES in viewwidth wide window

// -ES- 1999/06/01 Added these.
// Mostly used to get the address offset when moving from y to y+1.
extern int vb_w, vb_h, vb_depth;

#define vb_pitch vb_depth  // transitional wart

// Unit scale is used at distance distunit
extern float_t x_distunit;
extern float_t y_distunit;

// -ES- 1999/05/22 Made Dynamic
extern int *viewangletox;
extern angle_t *xtoviewangle;

extern float_t rw_distance;
extern angle_t rw_normalangle;

// angle to line origin
extern int rw_angle1;

#endif
</t>
<t tx="T2593">@ignore

// Rendering things (objects as sprites) Code

#ifndef __R_THINGS__
#define __R_THINGS__

#include "e_player.h"
#include "r_defs.h"
#include "z_zone.h"

// Constant arrays used for psprite clipping
//  and initializing clipping.
extern int negonearray;
#define screenheightarray 0

extern float_t pspritescale;
extern float_t pspriteiscale;
extern float_t pspritescale2;
extern float_t pspriteiscale2;
extern float_t masked_translucency;

extern int extra_psp_light;

int R_AddSpriteName(const char *name, int frame);
boolean_t R_InitSprites(void);

// -ES- 1999/05/31 Changed player sprite system.
void R_DrawPlayerSprites(player_t * p);

#endif
</t>
<t tx="T2594">@ignore

// View Bitmap Initialisation code

#ifndef __R_VBINIT_H__
#define __R_VBINIT_H__
#include "r_view.h"
#include "con_cvar.h"

// vbinit_t: Struct containing info about a screen composition mode
typedef struct vbinit_s vbinit_t;
struct vbinit_s
{
  // short name of the routine
  char *name;
  // pointer to the initialisation routine
  void (*routine)(viewbitmap_t * vb);
  // a longer description of it
  char *description;
};

// null-terminated list of available viewbitmap initialisers
extern vbinit_t screencomplist[];
// the current index in vbinitlist
extern int screencomposition;

extern funclist_t enlarge8_2_2_funcs;
extern funclist_t enlarge16_2_2_funcs;
extern void (*R_DoEnlargeView_2_2) (void);

void R_InitVBFunctions(void);

void R_InitCamera_StdObject(camera_t * c, mobj_t * mo);
void R_InitCamera_StdPlayer(camera_t * c);
void R_InitCamera_ViewOffs(camera_t * c, angle_t offs);
void R_InitCamera_3D_Right(camera_t * c);
void R_InitCamera_3D_Left(camera_t * c);

void R_InitVB_3D_Right(viewbitmap_t * r, viewbitmap_t * l);
void R_InitVB_3D_Left(viewbitmap_t * r, viewbitmap_t * l);

#endif
</t>
<t tx="T2595">@ignore

// View Bitmap systems

#ifndef __R_VIEW__
#define __R_VIEW__

#include "e_player.h"
#include "m_fixed.h"
#include "m_math.h"
#include "v_screen.h"
#include "z_zone.h"

typedef struct view_s view_t;
typedef struct viewbitmap_s viewbitmap_t;
typedef struct aspect_s aspect_t;
typedef struct camera_s camera_t;
typedef struct callback_s callback_t;

// A callback function that is called either at the start or end of a frame,
// specific either to view, viewbitmap or camera. Can be used for other
// purposes too.
struct callback_s
{
  // the actual callback. Could for example be a detail increaser for a view.
  // The parameter is the data field of the callback_t.
  void (*f) (void *);
  // User data: The callback needs info about what to operate on. Typically
  // just a pointer to the view_t (or viewbitmap_t or camera_t).
  // Could also be a pointer to a user defined struct containing that pointer
  // plus some extra user info.
  void *data;
  // Routine that deallocates the data field. Typically Z_Free, if data was
  // allocated with Z_New. Or NULL if nothing was allocated when the
  // callback was created.
  // Some start-of-frame callbacks might want to share data with end-of-frame
  // ones, in that case the destruction should be done in the end-of-frame
  // one, since the start-of-frame list always is destroyed first.
  void (*kill_data) (void *);
  // prev is executed before this callback and next after.
  callback_t *prev, *next;
};

//
// The camera whose view is projected.
//
struct camera_s
{
  // executed at the start of every frame when it's used for rendering,
  // to set some globals
  callback_t *frame_start;
  // Optional, does any necessary cleanup at end of frame
  callback_t *frame_end;

  // If the camera is attached to a player, this points to it. Otherwise
  // it's NULL. It's used for psprite drawing.
  // -AJA- 1999/09/11: Now a pointer to mobj_t instead of player_t.
  mobj_t *view_obj;
};

//
// A viewbitmap is a screen on which one or more views can be projected.
//
// -ES- 1999/07/31 Use the screen_t system.
struct viewbitmap_s
{
  screen_t screen;

  // Linked list of the views that can be drawn to this bitmap.
  view_t *views;

  // Linked list of the aspects that can be used with this bitmap.
  aspect_t *aspects;

  // Array of size (height), containing the addresses of each line.
  // the views' ylookups will point to one of the elements.
  byte **baseylookup;

  // Array of size (width), where element x contains x*BPP (currently).
  // the views' columnoffsets will point to one of these elements.
  int *basecolumnofs;

  // If these aren't null, they will be called at the start/end of each frame.
  callback_t *frame_start;
  callback_t *frame_end;
};

//
// aspect_s
//
// Contains the precalculated tables used when rendering a view with the
// specified aspect ratio etc.
//
// FIXME: Split up aspect_s into separate x and y?
struct aspect_s
{
  // the maximal width/height for views using this aspect.
  int maxwidth;
  int maxheight;

  // X RELATED STUFF

  // These show the tables for maxwidth.
  // The tables used in view_t are based on these ones, but can do some small
  // changes if not maxwidth is used.
  int *baseviewangletox;
  angle_t *basextoviewangle;
  float_t *basedistscale;
  float_t x_distunit;
  float_t focusxfrac;

  // Y RELATED STUFF

  float_t *baseyslope;
  float_t y_distunit;
  float_t focusyfrac;

  // the slope of the real focus is 0, this is the slope which we pretend to be focus.
  // ie. the slope that normally is in the middle of the screen.
  float_t fakefocusslope;
  // topslope &amp; bottomslope show the offset to fakefocusslope.
  float_t topslope;
  float_t bottomslope;

  // GENERAL STUFF

  // list of views that use this aspect. These will be updated if the aspect
  // is changed.
  view_t *views;

  // aspects are atm viewbitmap specific.
  viewbitmap_t *parent;

  // next in parent's list
  aspect_t *next;
};

//
// VIEW STRUCT
//
// A view is an area on a viewbitmap, on which a view is projected.
struct view_s
{
  // The memory area this view is drawn to. A subscreen of the parent
  // viewbitmap's screen.
  screen_t screen;

  byte **ylookup;
  int *columnofs;

  // aspect related
  int *viewangletox;
  angle_t *xtoviewangle;
  float_t *distscale;
  int aspect_x;

  int aspect_y;
  float_t *yslope;

#define VRF_PSPR (1)
#define VRF_VIEW (2)
  unsigned char renderflags;  // flag variable telling what to render here

  // Lists of routines that will be called at the start/end of each frame.
  callback_t *frame_start;
  callback_t *frame_end;

  // Views with high priority are drawn on top on low-prioritised.
  // Conventions:
  // A normal view has priority 0.
  // A player sprite view has priority 100.
  int priority;

  camera_t *camera;

  aspect_t *aspect;
  view_t *anext;  // the next view in the aspect's list

  viewbitmap_t *parent;
  view_t *vbnext;  // the next view in the parent viewbitmap's list

};

extern viewbitmap_t *screenvb;

extern view_t *curview;
extern viewbitmap_t *curviewbmp;

extern camera_t *camera;
extern mobj_t *background_camera_mo;

// Adds a callback to the end of *list. Use this for start_frame lists.
extern void R_AddStartCallback(callback_t ** list, void (*f) (void *), void *data, void (*kill_data) (void *));

// Adds a callback to the start of *list. Use this for end_frame lists.
extern void R_AddEndCallback(callback_t ** list, void (*f) (void *), void *data, void (*kill_data) (void *));

// Destroys a list of callbacks
extern void R_DestroyCallbackList(callback_t ** list);

// Calls all the callbacks in the list.
extern void R_CallCallbackList(callback_t * list);

extern void R_DestroyViewBitmap(viewbitmap_t * view);
extern viewbitmap_t *R_CreateViewBitmap(int width, int height, int bytepp, screen_t * p, int x, int y);

extern void R_DestroyAspect(aspect_t * a);
extern aspect_t *R_CreateAspect(viewbitmap_t * parent,
    float_t x_distunit, float_t y_distunit,
    float_t focusxfrac,
    float_t topslope, float_t bottomslope,
    int maxwidth, int maxheight);

extern void R_ViewSetAspectXPos(view_t * v, int ax, int width);
extern void R_AspectChangeX(aspect_t * a, float_t x_distunit, float_t focusxslope);
extern void R_AspectChangeY(aspect_t * a, float_t y_distunit, float_t fakefocusslope);
extern void R_ViewSetXPosition(view_t * v, int vbx, int ax, int width);
extern void R_ViewSetYPosition(view_t * v, int vby, int ay, int width);
extern void R_ViewSetAspect(view_t * v, aspect_t * a);

extern void R_ViewClearAspect(view_t * v);
extern void R_DestroyView(view_t * v);
extern view_t *R_CreateView(viewbitmap_t * parent, aspect_t * aspect, int x, int y, camera_t * camera, unsigned char flags, int priority);

extern void R_SetActiveViewBitmap(viewbitmap_t * vb);
extern void R_SetActiveView(view_t * v);

extern void R_RenderViewBitmap(viewbitmap_t * vb);

void R_DestroyCamera(camera_t * c);
camera_t *R_CreateCamera(void);

#endif
</t>
<t tx="T2596">@ignore

//  Radius Trigger Main definitions

#ifndef __RAD_MAIN__
#define __RAD_MAIN__

#include "dm_type.h"
#include "ddf_main.h"
#include "e_player.h"
#include "r_defs.h"
#include "hu_stuff.h"


struct rts_state_s;
struct rad_script_s;
struct rad_trigger_s;


typedef struct s_tip_s
{
  // tip text or graphic.  Two of these must be NULL.
  const char *tip_text;
  char *tip_ldf;
  char *tip_graphic;
  
  // display time, in ticks
  int display_time;

  // play the TINK sound ?
  boolean_t playsound;
}
s_tip_t;


typedef struct s_tip_prop_s
{
  // new slot number, or &lt; 0 for no change.
  int slot_num;
  
  // tip position (as a percentage, 0-255), &lt; 0 for no change
  percent_t x_pos, y_pos;

  // left justify.  Can be 1, 0, or &lt; 0 for no change.
  int left_just;
  
  // tip colourmap, or NULL for no change
  const char *colourmap_name;
 
  // translucency value (normally 1.0), or &lt; 0 for no change
  percent_t translucency;

  // time (in tics) to reach target.
  int time;
}
s_tip_prop_t;


// SpawnThing Function
typedef struct s_thing_s
{
  // If the object is spawned somewhere
  // else on the map.  z can be ONFLOORZ or ONCEILINGZ.
  float_t x;
  float_t y;
  float_t z;

  angle_t angle;
  float_t slope;

  // -AJA- 1999/09/11: since the RSCRIPT lump can be loaded before
  //       DDF* lumps, we can't store a pointer to a mobjinfo_t here
  //       (and the mobjinfos can move about with later additions).
  
  // thing's DDF name, or if NULL, then thing's mapnumber.
  char *thing_name;
  int thing_type;

  boolean_t ambush;
  boolean_t spawn_effect;
}
s_thing_t;


// Radius Damage Player Trigger
typedef struct
{
  float_t damage_amount;
}
s_damagep_t;


// Radius Heal Player Trigger
typedef struct
{
  float_t limit;
  float_t heal_amount;
}
s_healp_t;


// Radius GiveArmour Player Trigger
typedef struct
{
  armour_type_e type;
  float_t limit;
  float_t armour_amount;
}
s_armour_t;


// Radius Give/Lose Benefit
typedef struct
{
  benefit_t *benefit;
  boolean_t lose_it;  // or use_it :)
}
s_benefit_t;


// Radius Damage Monster Trigger
typedef struct s_damage_monsters_s
{
  // type of monster to damage: DDF name, or if NULL, then the
  // monster's mapnumber, or if -1 then ANY monster can be damaged.
  char *thing_name;
  int thing_type;

  // how much damage to do
  float_t damage_amount;
}
s_damage_monsters_t;


// Set Skill
typedef struct
{
  skill_t skill;
  int Respawn;
  boolean_t FastMonsters;
}
s_skill_t;


// Go to map
typedef struct
{
  char *map_name;
}
s_gotomap_t;


// Play Sound function
typedef struct s_sound_s
{
  enum
  {
    PSOUND_Normal = 0,
    PSOUND_BossMan
  }
  kind;
  
  // sound location.  z can be ONFLOORZ.
  float_t x, y, z;

  sfx_t *soundid;
}
s_sound_t;


// Change Music function
typedef struct s_music_s
{
  // playlist entry number
  int playnum;

  // whether to loop or not
  boolean_t looping;
}
s_music_t;


//Sector Vertical movement
typedef struct s_movesector_s
{
  // tag to apply to.  When tag == 0, use the exact sector number
  // (deprecated, but kept for backwards compat).
  int tag;
  int secnum;

  // Ceiling or Floor
  boolean_t is_ceiling;

  // when true, add the value to current height.  Otherwise set it.
  boolean_t relative;

  float_t value;
}
s_movesector_t;


//Sector Light change
typedef struct s_lightsector_s
{
  // tag to apply to.  When tag == 0, use the exact sector number
  // (deprecated, but kept for backwards compat).
  int tag;
  int secnum;

  // when true, add the value to current light.  Otherwise set it.
  boolean_t relative;

  float_t value;
}
s_lightsector_t;


// Enable/Disable
typedef struct s_enabler_s
{
  // script to enable/disable.  If script_name is NULL, then `tag' is
  // the tag number to enable/disable.
  char *script_name;
  int tag;

  // true to disable, false to enable
  boolean_t new_disabled;
}
s_enabler_t;


// ActivateLine
typedef struct s_lineactivator_s
{
  // line type
  int typenum;

  // sector tag
  int tag;
}
s_lineactivator_t;


// UnblockLines
typedef struct s_lineunblocker_s
{
  // line tag
  int tag;
}
s_lineunblocker_t;


// Jump
typedef struct s_jump_s
{
  // label name
  char *label;

  // state to jump to.  Initially NULL, it is looked up when needed
  // (since the label may be a future reference, we can't rely on
  // looking it up at parse time).
  struct rts_state_s *cache_state;

  // chance (from 0 -&gt; 256 means never -&gt; always) that the jump is
  // taken.
  int random_chance;
}
s_jump_t;


// Exit
typedef struct s_exit_s
{
  // exit time, in tics
  int exittime;
}
s_exit_t;


// Texture changing on lines/sectors
typedef enum
{
  // right side of the line
  CHTEX_RightUpper  = 0,
  CHTEX_RightMiddle = 1,
  CHTEX_RightLower  = 2,

  // left side of the line
  CHTEX_LeftUpper  = 3,
  CHTEX_LeftMiddle = 4,
  CHTEX_LeftLower  = 5,

  // the sky texture
  CHTEX_Sky = 6,

  // sector floor or ceiling
  CHTEX_Floor   = 7,
  CHTEX_Ceiling = 8,
}
changetex_type_e;

typedef struct s_changetex_s
{
  // what to change
  changetex_type_e what;

  // texture/flat name
  char texname[10];

  // tags used to find lines/sectors to change.  The `tag' value must
  // match sector.tag for sector changers and line.tag for line
  // changers.  The `subtag' value, if not 0, acts as a restriction:
  // for sector changers, a line in the sector must match subtag, and
  // for line changers, the sector on the given side must match the
  // subtag.  Both are ignored for sky changers.
  int tag, subtag;
}
s_changetex_t;


// Thing Event
typedef struct s_thing_event_s
{
  // DDF type name of thing to cause the event.  If NULL, then the
  // thing map number is used instead.
  const char *thing_name;
  int thing_type;

  // label to jump to
  const char *label;
  int offset;
}
s_thing_event_t;


// A single RTS action, not unlike the ones for DDF things.  (In fact,
// they may merge at some point in the future).
//
// -AJA- 1999/10/23: added this.
//
typedef struct rts_state_s
{
  // link in list of states
  struct rts_state_s *next;
  struct rts_state_s *prev;

  // duration in tics
  int tics;

  // routine to be performed
  void (*action)(struct rad_trigger_s *trig, mobj_t *actor, void *param);

  // parameter for routine, or NULL
  void *param;

  // state's label, or NULL
  char *label;
}
rts_state_t;


// Destination path name
typedef struct rts_path_s
{
  // next in list, or NULL
  struct rts_path_s *next;
  
  const char *name;

  // cached pointer to script
  struct rad_script_s *cached_scr;
}
rts_path_t;


// ONDEATH info
typedef struct s_ondeath_s
{
  // next in link (order is unimportant)
  struct s_ondeath_s *next;

  // thing's DDF name, or if NULL, then thing's mapnumber.
  char *thing_name;
  int thing_type;

  // threshhold: number of things still alive before the trigger can
  // activate.  Defaults to zero (i.e. all of them must be dead).
  int threshhold;
  
  // mobjinfo pointer, computed the first time this ONDEATH condition
  // is tested.
  const mobjinfo_t *cached_info;
}
s_ondeath_t;


// ONHEIGHT info
typedef struct s_onheight_s
{
  // next in link (order is unimportant)
  struct s_onheight_s *next;

  // height range, trigger won't activate until sector's floor is
  // within this range (inclusive).
  float_t z1, z2;

  // sector number, &lt; 0 means use the trigger's location
  int sec_num;

  // sector pointer, computed the first time this ONHEIGHT condition
  // is tested.
  sector_t *cached_sector;
}
s_onheight_t;


// Trigger Definition (Made up of actions)
// Start_Map &amp; Radius_Trigger Declaration
typedef struct rad_script_s
{
  // link in list
  struct rad_script_s *next;
  struct rad_script_s *prev;

  // Which map
  char *mapid;

  // When appears
  when_appear_e appear;

  int min_players;
  int max_players;

  // Map Coordinates
  float_t x, y, z;

  // Trigger size
  float_t rad_x, rad_y, rad_z;

  // Script name (or NULL)
  char *script_name;

  // Script tag (or 0 for none)
  int tag;

  // Multiplayer info
  enum
  {
    // spawn a separate trigger for each player
    RNET_Separate = 0,

    // spawn only a single trigger, "absolute" semantics
    RNET_Absolute
  }
  netmode;
  
  // for SEPARATE mode, bit field of players to spawn trigger
  unsigned long what_players;
  
  // ABSOLUTE mode: minimum players needed to trigger, -1 for ALL
  int absolute_req_players;
  
  // Initially disabled ?
  boolean_t tagged_disabled;

  // Check for use.
  boolean_t tagged_use;

  // Continues working ?
  boolean_t tagged_independent;

  // Requires no player intervention ?
  boolean_t tagged_immediate;

  // Should external enables/disables be player specific ?
  boolean_t tagged_player_specific;

  // Tagged_Repeat info (normal if repeat_count &lt; 0)
  int repeat_count;
  int repeat_delay;

  // Optional conditions...
  s_ondeath_t *boss_trig;
  s_onheight_t *height_trig;
  condition_check_t *cond_trig;

  // Path info
  rts_path_t *next_in_path;
  int next_path_total;

  const char *path_event_label;
  int path_event_offset;

  // Set of states
  rts_state_t *first_state;
  rts_state_t *last_state;

  // CRC of the important parts of this RTS script.
  unsigned long crc;
}
rad_script_t;


// Dynamic Trigger info.
// Goes away when trigger is finished.
typedef struct rad_trigger_s
{
  // link in list
  struct rad_trigger_s *next;
  struct rad_trigger_s *prev;
  
  // link for triggers with the same tag
  struct rad_trigger_s *tag_next;
  struct rad_trigger_s *tag_prev;
  
  // parent info of trigger
  rad_script_t *info;

  // is it disabled ?
  boolean_t disabled;

  // has it been activated yet?
  boolean_t activated;

  // players who activated it (bit field)
  unsigned long acti_players;

  // repeat info
  int repeats_left;
  int repeat_delay;

  // current state info
  rts_state_t *state;
  int wait_tics;

  // current tip slot (each tip slot works independently).
  int tip_slot;

  // origin for any sounds played by the trigger
  degenmobj_t soundorg;
}
rad_trigger_t;


//
// Tip Displayer info
//
#define MAXTIPSLOT    30
#define TIP_LINE_MAX  10

typedef struct drawtip_s
{
  // current properties
  s_tip_prop_t p;

  // display time.  When &lt; 0, this slot is not in use (and all of the
  // fields below this one are unused).
  int delay;

  // do we need to recompute some stuff (e.g. colmap) ?
  boolean_t dirty;
  
  // tip text DOH!
  const char *tip_text;
  const struct image_s *tip_graphic;

  // play a sound ?
  boolean_t playsound;

  // current colour
  const struct colourmap_s *colmap;

  // fading fields
  int fade_time;
  float_t fade_target;

  // HULIB info
  int hu_linenum;
  hu_textline_t hu_lines[TIP_LINE_MAX];
}
drawtip_t;

extern drawtip_t tip_slots[MAXTIPSLOT];

#endif
</t>
<t tx="T2597">@ignore

//  Radius Trigger header file

#ifndef __RAD_TRIG__
#define __RAD_TRIG__

#include "dm_type.h"
#include "e_player.h"
#include "rad_main.h"


#define DEBUG_RTS  0


// Radius Trigger Parser Version
#define PARSERV       11
#define PARSERVFIX    10

#define MAXSTRLEN     512
#define FIXEDSLOTS    9

extern rad_script_t *r_scripts;
extern rad_trigger_t *r_triggers;
extern int rad_itemsread;

// Tip Prototypes
void RAD_InitTips(void);
void RAD_ResetTips(void);
void RAD_DisplayTips(void);

// RadiusTrigger &amp; Scripting Prototypes
boolean_t RAD_Init(void);
boolean_t RAD_LoadParam(void);
void RAD_LoadLump(void *data, int size);
void RAD_SpawnTriggers(char *map_name);
void RAD_ClearTriggers(void);
void RAD_GroupTriggerTags(rad_trigger_t *trig);

void RAD_DoRadiTrigger(player_t * p);
void RAD_Ticker(void);
boolean_t RAD_WithinRadius(mobj_t * mo, rad_script_t * r);
rad_script_t *RAD_FindScriptByName(const char *map_name, const char *name);
rad_trigger_t *RAD_FindTriggerByName(const char *name);
rts_state_t *RAD_FindStateByLabel(rad_script_t *scr, char *label);
void RAD_EnableByTag(mobj_t *actor, int tag, boolean_t disable);

// Path support
boolean_t RAD_CheckReachedTrigger(mobj_t * thing);

//
//  PARSING
//
void RAD_ParserBegin(void);
void RAD_ParserDone(void);
void RAD_ParseLine(char *s);
int RAD_StringHashFunc(const char *s);

void RAD_Error(const char *err, ...);
void RAD_Warning(const char *err, ...);
void RAD_WarnError(const char *err, ...);

extern int rad_cur_linenum;
extern char *rad_cur_filename;

//
//  ACTIONS
//

void RAD_ActNOP(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActTip(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActTipProps(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActSpawnThing(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActPlaySound(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActKillSound(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActChangeMusic(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActChangeTex(rad_trigger_t *R, mobj_t *actor, void *param);

void RAD_ActMoveSector(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActLightSector(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActEnableScript(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActActivateLinetype(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActUnblockLines(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActJump(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActSleep(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActRetrigger(rad_trigger_t *R, mobj_t *actor, void *param);

void RAD_ActDamagePlayers(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActHealPlayers(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActArmourPlayers(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActBenefitPlayers(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActDamageMonsters(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActThingEvent(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActSkill(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActGotoMap(rad_trigger_t *R, mobj_t *actor, void *param);
void RAD_ActExitLevel(rad_trigger_t *R, mobj_t *actor, void *param);

#endif
</t>
<t tx="T2598">@ignore

// OpenGL Rendering (Definitions)

#ifdef USE_GL

#ifndef __RGL_DEFS__
#define __RGL_DEFS__

#include "v_ctx.h"

//
//  RGL_MAIN
//

#define FUZZY_TRANS  0.30

extern int glmax_lights;
extern int glmax_clip_planes;
extern int glmax_tex_size;

extern int rgl_light_map[256];
extern angle_t oned_side_angle;

void RGL_Init(void);
void RGL_SoftInit(void);
void RGL_SetupMatrices2D(void);
void RGL_SetupMatrices3D(void);
void RGL_SetupMatricesSky(void);
void RGL_DrawPlayerSprites(player_t * p);

void RGL_RainbowEffect(player_t *player);
void RGL_ColourmapEffect(player_t *player);
void RGL_PaletteEffect(player_t *player);


//
//  RGL_SKY
//
//
void RGL_DrawSkyPlane(subsector_t *sub, float_t h);
void RGL_DrawSkyWall(seg_t *seg, float_t h1, float_t h2);


//
//  RGL_BSP
//

#define M_ROOT2  1.414213562

// save a little room for lighting effects
#define TOP_LIGHT  (0.9)

#define MAX_PLVERT  64

// extra lighting on the player weapon
extern int rgl_weapon_r;
extern int rgl_weapon_g;
extern int rgl_weapon_b;

void RGL_RenderScene(int x, int y, int w, int h, vid_view_t *view);
void RGL_RenderTrueBSP(void);


//
// RGL_UNIT
//

// a single vertex to pass to the GL 
typedef struct local_gl_vert_s
{
  GLfloat x, y, z;
  GLfloat col[4];
  GLfloat t_x, t_y;
  GLfloat n_x, n_y, n_z;
  GLboolean edge;
}
local_gl_vert_t;

void RGL_InitUnits(void);
void RGL_StartUnits(boolean_t solid);
void RGL_FinishUnits(void);

local_gl_vert_t *RGL_BeginUnit(GLuint mode, int max_vert, 
    GLuint tex_id, boolean_t masked, boolean_t blended);
void RGL_EndUnit(int actual_vert);
void RGL_DrawUnits(void);

// utility macros
#define SET_COLOR(R,G,B,A)  \
    do { vert-&gt;col[0] = (R); vert-&gt;col[1] = (G); vert-&gt;col[2] = (B);  \
         vert-&gt;col[3] = (A); } while(0)

#define SET_TEXCOORD(X,Y)  \
    do { vert-&gt;t_x = (X); vert-&gt;t_y = (Y); } while(0)

#define SET_NORMAL(X,Y,Z)  \
    do { vert-&gt;n_x = (X); vert-&gt;n_y = (Y); vert-&gt;n_z = (Z); } while(0)

#define SET_EDGE_FLAG(E)  \
    do { vert-&gt;edge = (E); } while(0)

#define SET_VERTEX(X,Y,Z)  \
    do { vert-&gt;x = (X); vert-&gt;y = (Y); vert-&gt;z = (Z); } while(0)
 

// RAW STUFF

typedef struct raw_polyquad_s
{
  // Quad ?  When true, the number of vertices must be even, and the
  // order must be the same as for glBegin(GL_QUADSTRIP).
  // 
  boolean_t quad;
 
  vec3_t *verts;
  int num_verts;
  int max_verts;

  // When a polyquad is split, the other pieces are linked from the
  // original through this pointer.
  //
  struct raw_polyquad_s *sisters;

  // 3D bounding box
  vec3_t min, max;
}
raw_polyquad_t;

#define PQ_ADD_VERT(P,X,Y,Z)  do {  \
    (P)-&gt;verts[(P)-&gt;num_verts].x = (X);  \
    (P)-&gt;verts[(P)-&gt;num_verts].y = (Y);  \
    (P)-&gt;verts[(P)-&gt;num_verts].z = (Z);  \
    (P)-&gt;num_verts++; } while(0)

raw_polyquad_t *RGL_NewPolyQuad(int maxvert, boolean_t quad);
void RGL_FreePolyQuad(raw_polyquad_t *poly);
void RGL_BoundPolyQuad(raw_polyquad_t *poly);

void RGL_SplitPolyQuad(raw_polyquad_t *poly, int division, 
    boolean_t separate);
void RGL_SplitPolyQuadLOD(raw_polyquad_t *poly, int max_lod, int base_div);

void RGL_RenderPolyQuad(raw_polyquad_t *poly, void *data,
    void (* CoordFunc)(vec3_t *src, local_gl_vert_t *vert, void *data),
    GLuint tex_id, boolean_t masked, boolean_t blended);


//
//  1D OCCLUSION STUFF
//
void RGL_1DOcclusionClear(angle_t low, angle_t high);
void RGL_1DOcclusionSet(angle_t low, angle_t high);
boolean_t RGL_1DOcclusionTest(angle_t low, angle_t high);


//
// RGL_WIPE
//

void RGL_InitWipe(int reverse, int effect);
void RGL_StopWipe(void);
boolean_t RGL_DoWipe(void);


#endif  // __RGL_DEFS__
#endif  // USE_GL

</t>
<t tx="T2599">@ignore

// Sound FX Handling Code

#ifndef __S_SOUND__
#define __S_SOUND__

#include "p_mobj.h"
#include "z_zone.h"

// for the sliders
#define S_MIN_VOLUME 0
#define S_MAX_VOLUME 15

#define S_CLOSE_DIST    160.0
#define S_CLIPPING_DIST 1600.0

// S_MUSIC.C
void S_ChangeMusic(int entrynum, boolean_t looping);
void S_ResumeMusic(void);
void S_PauseMusic(void);
void S_StopMusic(void);
void S_MusicTicker(void);
int S_GetMusicVolume(void);
void S_SetMusicVolume(int volume);

// S_SOUND.C
boolean_t S_Init(void);
void S_SoundLevelInit(void);
int S_StartSound(mobj_t *origin, sfx_t *sound_id);
void S_ResumeSounds(void);
void S_PauseSounds(void);
void S_RemoveSoundOrigin(mobj_t *origin);
void S_AddToFreeQueue(mobj_t *origin, void *block);
void S_StopSound(mobj_t *origin);
void S_StopLoopingSound(mobj_t *origin); // -ACB- 2001/01/09 Addition Functionality
void S_StopChannel(int cnum);
void S_UpdateSounds(mobj_t *listener);
void S_SoundTicker(void);
int S_GetSfxVolume(void);
void S_SetSfxVolume(int volume);

// S_UTIL.C
byte *S_UtilConvertMUStoMIDI(byte *data);

#endif
</t>
<t tx="T2600">@ignore

// Status Bar Library Code

#ifndef __STLIB__
#define __STLIB__

// We are referring to patches.
#include "r_defs.h"
#include "w_image.h"

//
// Typedefs of widgets
//

// Number widget

typedef struct
{
  // upper right-hand corner
  //  of the number (right-justified)
  int x, y;

  // max # of digits in number
  int width;

  // last number value
  int oldnum;

  // pointer to current value
  int *num;

  // pointer to boolean stating
  //  whether to update number
  boolean_t *on;

  // list of images for 0-9
  const image_t ** digits;

  // minus, or NULL for none.
  const image_t *minus;

  // colourmap
  const colourmap_t *colmap;
}
st_number_t;

// -ES- 1999/11/10 Quick hack to allow floats. FIXME: Rewrite All.
typedef struct
{
  st_number_t num;
  float_t *f;
}
st_float_t;


// Percent widget ("child" of number widget,
//  or, more precisely, contains a number widget.)
typedef struct
{
  // number information
  st_float_t f;

  // percent sign graphic
  const image_t *percsign;
}
st_percent_t;

// Multiple Icon widget
typedef struct
{
  // center-justified location of icons
  int x, y;

  // last icon number
  int oldinum;

  // pointer to current icon
  int *inum;

  // pointer to boolean stating
  //  whether to update icon
  boolean_t *on;

  // list of icons
  const image_t ** icons;
}
st_multicon_t;

// Binary Icon widget

typedef struct
{
  // center-justified location of icon
  int x, y;

  // last icon value
  boolean_t oldval;

  // pointer to current icon status
  boolean_t *val;

  // pointer to boolean
  //  stating whether to update icon
  boolean_t *on;

  // icon
  const image_t *icon;
}
st_binicon_t;

//
// Widget creation, access, and update routines
//

// Initialises widget library.
// More precisely, initialise STMINUS,
//  everything else is done somewhere else.
//
void STLIB_Init(void);

// Number widget routines
void STLIB_InitNum(st_number_t * n, int x, int y, 
    const image_t ** digits, const image_t *minus, int *num, 
    boolean_t * on, int width);

void STLIB_InitFloat(st_float_t * n, int x, int y, const image_t ** digits, 
    float_t *num, boolean_t * on, int width);

void STLIB_UpdateNum(st_number_t * n, boolean_t refresh);
void STLIB_UpdateFloat(st_float_t * n, boolean_t refresh);

// Percent widget routines
void STLIB_InitPercent(st_percent_t * p, int x, int y, 
    const image_t ** digits, const image_t *percsign,
    float_t *num, boolean_t * on);

void STLIB_UpdatePercent(st_percent_t * per, int refresh);

// Multiple Icon widget routines
void STLIB_InitMultIcon(st_multicon_t * mi, int x, int y, 
    const image_t ** icons, int *inum, boolean_t * on);

void STLIB_UpdateMultIcon(st_multicon_t * mi, boolean_t refresh);

// Binary Icon widget routines

void STLIB_InitBinIcon(st_binicon_t * b, int x, int y, 
    const image_t * icon, boolean_t * val, boolean_t * on);

void STLIB_UpdateBinIcon(st_binicon_t * bi, boolean_t refresh);

#endif
</t>
<t tx="T2601">@ignore

// Video Context

#ifndef __V_CTX__
#define __V_CTX__

#include "dm_type.h"
#include "ddf_main.h"
#include "w_image.h"

//
// Video Context
//
// This is the video context that contains high-level drawing
// operations (like "render a scene").  Details about column drawers
// or whatever are intentionally ignored here, they are low-level
// (e.g. column drawers aren't even used by the OpenGL system).  This
// interface is used by "Drawer" functions in the layer system to draw
// the stuff contained in layers.
//
// Note: the drawing routines don't take into account the dirty matrix
// and/or solid rectangles.  Use the functions in v_toplev for this.

typedef struct vid_view_s vid_view_t;  //!!! Not yet defined

typedef struct video_context_s
{
  // Video output is double buffered, or in some way requires
  // everything to be re-drawn at each frame.  When true, the dirty
  // matrix logic cannot be used.
  
  boolean_t double_buffered;

  // This routine should inform the lower level system(s) that the
  // screen has changed size/depth.  New size/depth is given.  Must be
  // called before any rendering has occurred (e.g. just before
  // I_StartFrame).

  void (* NewScreenSize)(int width, int height, int bpp);
  
  // Rendering routine, which renders a scene using the given view
  // (which is precomputed from an in-game object).  Coordinates are
  // inclusive.
  
  void (* RenderScene)(int x, int y, int w, int h, vid_view_t *view);
  
  // Begin/End a sequence of drawing for a particular layer.  The
  // coordinates to BeginDraw are the bounding box the future drawing
  // operations must clip to.  Coordinates are inclusive.  It is
  // illegal to call the drawing operations (DrawImage, SolidBox and
  // SolidLine) outside of a Begin/End sequence.
  
  void (* BeginDraw)(int x1, int y1, int x2, int y2);
  void (* EndDraw)(void);
  
  // Draws an image into a rectangular area of the screen.  Screen
  // coordinates are inclusive.  Alpha ranges from 0.0 (invisible) to
  // 1.0 (totally opaque).  The colmap parameter is a colourmap to use
  // to shade the image (especially font characters), or NULL to draw
  // the image as-is.  If the texture coordinates lie outside of the
  // [0-1] range, then the image will be tiled.  Proper tiling is only
  // guaranteed for power-of-two sized images.  The drawing will be
  // clipped to the current clipping rectangle.
  
  void (* DrawImage)(int x, int y, int w, int h, const image_t *image,
      float_t tx1, float_t ty1, float_t tx2, float_t ty2,
      const colourmap_t *colmap, float_t alpha);
 
  // Draw a solid colour box (possibly translucent) in the given
  // rectangle.  Coordinates are inclusive.  Alpha ranges from 0
  // (invisible) to 255 (totally opaque).  Colour is a palette index
  // (0-255).  Drawing will be clipped to the current clipping
  // rectangle.
  
  void (* SolidBox)(int x, int y, int w, int h,
      int colour, float_t alpha);
 
  // Draw a solid colour line (possibly translucent) between the two
  // end points.  Coordinates are inclusive.  Used for the automap.
  // Colour is a palette index (0-255).  Drawing will be clipped to
  // the current clipping rectangle.
  
  void (* SolidLine)(int x1, int y1, int x2, int y2, int colour);
  
  // Read the contents of the screen into the given buffer, which is
  // in RGB format (3 bytes per pixel).  Buffer must be large enough
  // for the data.  Coordinates are inclusive.  This routine may only
  // be called after screen is fully rendered but _before_ the
  // I_FinishFrame() function has been called.

  void (* ReadScreen)(int x, int y, int w, int h, byte *rgb_buffer);
}
video_context_t;


// Global video context.  There is only ever one.
extern video_context_t vctx;


// Convenience macros

#define VCTX_Image(X,Y,W,H,Image)  \
    vctx.DrawImage((X)-(Image)-&gt;offset_x, (Y)-(Image)-&gt;offset_y,  \
       (W),(H),(Image),0,0,IM_RIGHT(Image),IM_BOTTOM(Image),NULL,1.0)

#define VCTX_Image320(X,Y,W,H,Image)  \
    vctx.DrawImage(FROM_320((X)-(Image)-&gt;offset_x), \
       FROM_200((Y)-(Image)-&gt;offset_y), FROM_320(W), FROM_200(H),  \
       (Image),0,0,IM_RIGHT(Image),IM_BOTTOM(Image),NULL,1.0)

#define VCTX_ImageEasy(X,Y,Image)  \
    vctx.DrawImage((X)-(Image)-&gt;offset_x, (Y)-(Image)-&gt;offset_y,  \
       IM_WIDTH(Image),IM_HEIGHT(Image),(Image),  \
       0,0,IM_RIGHT(Image),IM_BOTTOM(Image),NULL,1.0)

#define VCTX_ImageEasy320(X,Y,Image)  \
    vctx.DrawImage(FROM_320((X)-(Image)-&gt;offset_x), \
       FROM_200((Y)-(Image)-&gt;offset_y), \
       FROM_320(IM_WIDTH(Image)), FROM_200(IM_HEIGHT(Image)),  \
       (Image),0,0,IM_RIGHT(Image),IM_BOTTOM(Image),NULL,1.0)


#endif  // __V_CTX__
</t>
<t tx="T2602">@ignore

// Status Bar Code

#ifndef __STSTUFF_H__
#define __STSTUFF_H__

#include "dm_type.h"
#include "e_event.h"
#include "v_screen.h"

// Size of statusbar.
#define ST_HEIGHT       32
#define ST_WIDTH        320

#define ST_X            0
#define ST_Y            (200 - ST_HEIGHT)

//
// STATUS BAR
//

// Called by main loop.
boolean_t ST_Responder(event_t * ev);

// Called by main loop.
void ST_Ticker(void);

// Called by main loop.
void ST_Drawer(boolean_t fullscreen, boolean_t refresh);

// Called when the console player is spawned on each level.
void ST_Start(void);

// Called when changing resolution
void ST_ReInit(void);

// Called by startup code.
boolean_t ST_Init(void);

extern boolean_t stbar_update;

// States for the chat code.
typedef enum
{
  StartChatState,
  WaitDestState,
  GetChatState
}
st_chatstateenum_t;

#endif
</t>
<t tx="T2603">@ignore

// New SaveGame Handling (Chunks)

//
// -AJA- 2000/07/13: Wrote this file.
//

#ifndef __SV_CHUNK_
#define __SV_CHUNK_

#include "i_defs.h"
#include "p_local.h"

#define DATA_END_MARKER  "ENDE"

boolean_t SV_ChunkInit(void);
void SV_ChunkShutdown(void);

int SV_GetError(void);

//
//  READING
//

boolean_t SV_OpenReadFile(const char *filename);
boolean_t SV_CloseReadFile(void);
boolean_t SV_VerifyHeader(int *version);
boolean_t SV_VerifyContents(void);

boolean_t SV_PushReadChunk(const char *id);
boolean_t SV_PopReadChunk(void);
int SV_RemainingChunkSize(void);
boolean_t SV_SkipReadChunk(const char *id);

unsigned char  SV_GetByte(void);
unsigned short SV_GetShort(void);
unsigned int   SV_GetInt(void);

fixed_t SV_GetFixed(void);
angle_t SV_GetAngle(void);
float_t SV_GetFloat(void);

const char *SV_GetString(void);
boolean_t SV_GetMarker(char id[5]);

//
//  WRITING
//

boolean_t SV_OpenWriteFile(const char *filename, int version);
boolean_t SV_CloseWriteFile(void);

boolean_t SV_PushWriteChunk(const char *id);
boolean_t SV_PopWriteChunk(void);

void SV_PutByte(unsigned char value);
void SV_PutShort(unsigned short value);
void SV_PutInt(unsigned int value);

void SV_PutFixed(fixed_t value);
void SV_PutAngle(angle_t value);
void SV_PutFloat(float value);

void SV_PutString(const char *str);
void SV_PutMarker(const char *id);

#endif  // __SV_CHUNK_
</t>
<t tx="T2604">@ignore

// New SaveGame Handling (Main defs)

//
// TERMINOLOGY:
//
//   - "known" here means an array/structure that is currently built
//     into EDGE.
//
//   - "loaded" here means an array/structure definition that has been
//     loaded from the savegame file.
//

#ifndef __SV_MAIN_
#define __SV_MAIN_

#include "i_defs.h"
#include "p_local.h"

//
// STRUCTURE TABLE STUFF
//

typedef enum
{
  SFKIND_Invalid = 0,  // invalid values can be helpful
  SFKIND_Numeric,
  SFKIND_Index,
  SFKIND_String,
  SFKIND_Struct
}
savefieldkind_e;

typedef struct
{
  // basic kind of field (for SDEF chunk)
  savefieldkind_e kind;
  
  // number of bytes for SFKIND_Numeric (1, 2, 4 or 8)
  int size;

  // name of structure for SFKIND_Struct, or name of array
  // for SFKIND_Index.
  const char *name;
}
savefieldtype_t;

#define SVT_INVALID        { SFKIND_Invalid, 0, NULL }

#define SVT_INT            { SFKIND_Numeric, 4, NULL }
#define SVT_SHORT          { SFKIND_Numeric, 2, NULL }
#define SVT_BYTE           { SFKIND_Numeric, 1, NULL }
#define SVT_FLOAT          { SFKIND_Numeric, 4, NULL }
#define SVT_VEC2           { SFKIND_Numeric, 8, NULL }
#define SVT_VEC3           { SFKIND_Numeric, 12,NULL }
#define SVT_INDEX(name)    { SFKIND_Index,   4, name }
#define SVT_STRING         { SFKIND_String,  0, NULL }
#define SVT_STRUCT(name)   { SFKIND_Struct,  0, name }

#define SVT_ANGLE          SVT_INT
#define SVT_FIXED          SVT_INT
#define SVT_BOOLEAN        SVT_INT
#define SVT_ENUM           SVT_INT
#define SVT_PERCENT        SVT_FLOAT


// This describes a single field
typedef struct savefieldtype_s
{
  // offset of field into structure
  int offset;

  // name of field in savegame system
  const char *field_name;

  // number of sequential elements
  int count;
 
  // field type information
  savefieldtype_t type;

  // get &amp; put routines.  The extra parameter depends on the type, for
  // SFKIND_Struct it is the name of the structure, for SFKIND_Index
  // it is the name of the array.  When `field_put' is NULL, then this
  // field is not saved into the output SDEF chunk.
  boolean_t (* field_get)(void *storage, int index, void *extra);
  void (* field_put)(void *storage, int index, void *extra);

  // for loaded info, this points to the known version of the field,
  // otherwise NULL if the loaded field is unknown.
  struct savefieldtype_s *known_field;
}
savefield_t;

// NOTE: requires SV_F_BASE to be defined as the dummy struct

#define SVFIELD(field,fname,fnum,ftype,getter,putter)  \
    { ((char *)&amp; (SV_F_BASE . field)) - ((char *)&amp; SV_F_BASE),  \
      fname, fnum, ftype, getter, putter, NULL }

#define SVFIELD_END  { 0, NULL, 0, SVT_INVALID, NULL, NULL, NULL }


// This describes a single structure
typedef struct savestruct_s
{
  // link in list of structure definitions
  struct savestruct_s *next;

  // structure name (for SDEF/ADEF chunks)
  const char *struct_name;

  // four letter marker
  const char *marker;

  // array of field definitions
  savefield_t *fields;

  // this must be true to put the definition into the savegame file.
  // Allows compatibility structures that are read-only.
  boolean_t define_me;

  // only used when loading.  For loaded info, this refers to the
  // known struct of the same name (or NULL if none).  For known info,
  // this points to the loaded info (or NULL if absent).
  struct savestruct_s *counterpart;
}
savestruct_t;


// This describes a single array
typedef struct savearray_s
{
  // link in list of array definitions
  struct savearray_s *next;

  // array name (for ADEF and STOR chunks)
  const char *array_name;

  // array type.  For loaded info, this points to the loaded
  // structure.  Never NULL.
  savestruct_t *sdef;

  // this must be true to put the definition into the savegame file.
  // Allows compatibility arrays that are read-only.
  boolean_t define_me;

  // array routines.  Not used for loaded info.
  int (* count_elems)(void);
  void * (* get_elem)(int index);
  void (* create_elems)(int num_elems);
  void (* finalise_elems)(void);

  // only used when loading.  For loaded info, this refers to the
  // known array (or NULL if none).  For known info, this points to
  // the loaded info (or NULL if absent).
  struct savearray_s *counterpart;

  // number of elements to be loaded.
  int loaded_size;
}
savearray_t;


//
//  COMMON GET ROUTINES
//
//  Note the `SR_' prefix.
//
boolean_t SR_GetByte(void *storage, int index, void *extra);
boolean_t SR_GetShort(void *storage, int index, void *extra);
boolean_t SR_GetInt(void *storage, int index, void *extra);

boolean_t SR_GetFixed(void *storage, int index, void *extra);
boolean_t SR_GetAngle(void *storage, int index, void *extra);
boolean_t SR_GetFloat(void *storage, int index, void *extra);
boolean_t SR_GetVec2(void *storage, int index, void *extra);
boolean_t SR_GetVec3(void *storage, int index, void *extra);

boolean_t SR_GetIntAsFloat(void *storage, int index, void *extra);

#define SR_GetBoolean  SR_GetInt
#define SR_GetEnum     SR_GetInt
#define SR_GetPercent  SR_GetFloat


//
//  COMMON PUT ROUTINES
//
//  Note the `SR_' prefix.
//
void SR_PutByte(void *storage, int index, void *extra);
void SR_PutShort(void *storage, int index, void *extra);
void SR_PutInt(void *storage, int index, void *extra);

void SR_PutFixed(void *storage, int index, void *extra);
void SR_PutAngle(void *storage, int index, void *extra);
void SR_PutFloat(void *storage, int index, void *extra);
void SR_PutVec2(void *storage, int index, void *extra);
void SR_PutVec3(void *storage, int index, void *extra);

#define SR_PutBoolean  SR_PutInt
#define SR_PutEnum     SR_PutInt
#define SR_PutPercent  SR_PutFloat


//
//  GLOBAL STUFF
//

typedef struct crc_check_s
{
  // number of items
  int count;

  // CRC computed over all the items
  unsigned long crc;
}
crc_check_t;

// this structure contains everything for the top-level [GLOB] chunk.
// Strings are copies and need to be freed.
typedef struct
{
  // [IVAR] stuff:
  
  const char *game;
  const char *level;
  gameflags_t flags;
  int gravity;
  
  int level_time;
  int p_random;
  int total_kills;
  int total_items;
  int total_secrets;
 
  int console_player;
  int skill;
  int netgame;

  const char *description;
  const char *desc_date;

  crc_check_t mapsector;
  crc_check_t mapline;
  crc_check_t mapthing;

  crc_check_t rscript;
  crc_check_t ddfatk;
  crc_check_t ddfgame;
  crc_check_t ddflevl;
  crc_check_t ddfline;
  crc_check_t ddfsect;
  crc_check_t ddfmobj;
  crc_check_t ddfweap;

  // [VIEW] info.  Unused if view_pixels is NULL.
  unsigned short *view_pixels;
  int view_width;
  int view_height;

  // [WADS] info
  int wad_num;
  const char ** wad_names;
}
saveglobals_t;

saveglobals_t *SV_NewGLOB(void);
saveglobals_t *SV_LoadGLOB(void);
void SV_SaveGLOB(saveglobals_t *globs);
void SV_FreeGLOB(saveglobals_t *globs);


//
//  ADMININISTRATION
//

boolean_t SV_MainInit(void);

savestruct_t *SV_MainLookupStruct(const char *name);
savearray_t  *SV_MainLookupArray(const char *name);

void SV_BeginLoad(void);
void SV_FinishLoad(void);

boolean_t SV_LoadStruct(void *base, savestruct_t *info);
boolean_t SV_LoadEverything(void);

void SV_BeginSave(void);
void SV_FinishSave(void);

void SV_SaveStruct(void *base, savestruct_t *info);
void SV_SaveEverything(void);


//
//  DEBUGGING
//

void SV_DumpSaveGame(int slot);


//
//  EXTERNAL DEFS
//

extern void *sv_current_elem;

extern savestruct_t *sv_known_structs;
extern savearray_t  *sv_known_arrays;

boolean_t SR_MobjGetMobj(void *storage, int index, void *extra);
void SR_MobjPutMobj(void *storage, int index, void *extra);

int SV_MobjFindElem(mobj_t *elem);
void * SV_MobjGetElem(int index);

int SV_PlayerFindElem(player_t *elem);
void * SV_PlayerGetElem(int index);

boolean_t SR_LevelGetImage(void *storage, int index, void *extra);
void SR_LevelPutImage(void *storage, int index, void *extra);

boolean_t SR_LevelGetColmap(void *storage, int index, void *extra);
void SR_LevelPutColmap(void *storage, int index, void *extra);

boolean_t SR_LineGetLine(void *storage, int index, void *extra);
void SR_LinePutLine(void *storage, int index, void *extra);

boolean_t SR_SectorGetSector(void *storage, int index, void *extra);
void SR_SectorPutSector(void *storage, int index, void *extra);

boolean_t SR_SectorGetEF(void *storage, int index, void *extra);
void SR_SectorPutEF(void *storage, int index, void *extra);

boolean_t SR_TriggerGetScript(void *storage, int index, void *extra);
void SR_TriggerPutScript(void *storage, int index, void *extra);


#endif  // __SV_MAIN_
</t>
<t tx="T2605">@ignore

// Colour Code

#ifndef __V_COLOUR_H__
#define __V_COLOUR_H__

#include "dm_type.h"
#include "dm_defs.h"

#include "ddf_main.h"
#include "r_defs.h"

boolean_t V_InitPalette(void);
void V_InitColour(void);

// -ACB- 1999/10/11 Gets an RGB colour from the current palette
// -AJA- Added `nominal' version, which gets colour from palette 0.
void V_IndexColourToRGB(int indexcol, byte *returncol);
void V_IndexNominalToRGB(int indexcol, byte *returncol);

// -ES- 1998/11/29 Added translucency tables
// -AJA- 1999/06/30: Moved 'em here, from dm_state.h.
extern byte rgb_32k[32][32][32];  // 32K RGB table, for 8-bit translucency
extern unsigned long col2rgb16[65][256][2];
extern unsigned long col2rgb8[65][256];
extern unsigned long hicolourtransmask;  // OR mask used for translucency

// -AJA- 1999/07/03: moved here from v_res.h.
extern byte gammatable[5][256];
extern int usegamma;
extern int current_gamma;

#define GAMMA_CONV(light)  (gammatable[usegamma][light])

// -AJA- 1999/07/03: Some palette stuff. Should be replaced later on with
// some DDF system (e.g. "palette.ddf").

extern byte playpal_data[14][256][3];

#define PALETTE_NORMAL   0
#define PALETTE_PAIN     1
#define PALETTE_BONUS    2
#define PALETTE_SUIT     3

int V_FindColour(int r, int g, int b);
void V_SetPalette(int type, float_t amount);
void V_ColourNewFrame(void);

// -AJA- 1999/07/05: Added this, to be used instead of the
// Allegro-specific `palette_color' array.

extern long pixel_values[256];

// -AJA- 1999/07/10: Some stuff for colmap.ddf.

typedef enum
{
  VCOL_Sky = 0x0001
}
vcol_flags_e;

const coltable_t *V_GetRawColtable(const colourmap_t * nominal, int level);
const coltable_t *V_GetColtable
 (const colourmap_t * nominal, int lightlevel, vcol_flags_e flags);

// translation support
const byte *V_GetTranslationTable(const colourmap_t * colmap);

const coltable_t *V_GetTranslatedColtable(const coltable_t *src,
    const byte *trans);

// support for GL
#ifdef USE_GL
void V_GetColmapRGB(const colourmap_t *colmap,
    float_t *r, float_t *g, float_t *b, boolean_t font);
#endif

// general purpose colormaps &amp; coltables
extern const colourmap_t *normal_map;
extern const colourmap_t *sky_map;
extern const colourmap_t *shadow_map;
extern const coltable_t *fuzz_coltable;
extern const coltable_t *dim_coltable;

// text translation tables
extern const byte *font_whitener;

extern const colourmap_t *text_red_map;
extern const colourmap_t *text_white_map;
extern const colourmap_t *text_grey_map;
extern const colourmap_t *text_green_map;
extern const colourmap_t *text_brown_map;
extern const colourmap_t *text_blue_map;
extern const colourmap_t *text_yellow_map;

// automap translation tables
extern const byte *am_normal_colmap;
extern const byte *am_overlay_colmap;

// do-nothing translation table
extern byte null_tranmap[256];

// halo translation table
extern byte halo_conv_table[256];

// colour indices from palette
extern int pal_black, pal_white, pal_gray239;
extern int pal_red, pal_green, pal_blue;
extern int pal_yellow, pal_green1, pal_brown1;

// colour values.  These assume the standard Doom palette.  Maybe
// remove most of these one day -- will take some work though...
// Note: some of the ranges begin with a bright (often white) colour.

#define BLACK   0
#define WHITE   4

#define PINK         0x10
#define PINK_LEN     32
#define BROWN        0x30
#define BROWN_LEN    32
#define GRAY         0x50
#define GRAY_LEN     32
#define GREEN        0x70
#define GREEN_LEN    16
#define BEIGE        0x80
#define BEIGE_LEN    16
#define RED          0xB0
#define RED_LEN      16
#define CYAN         0xC0
#define CYAN_LEN     8
#define BLUE         0xC8
#define BLUE_LEN     8
#define ORANGE       0xD8
#define ORANGE_LEN   8
#define YELLOW       0xE7
#define YELLOW_LEN   1
#define DBLUE        0xF0
#define DBLUE_LEN    8

#endif
</t>
<t tx="T2606">@ignore

// Video Code

//
// Original Author: Chi Hoang
//

#ifndef __MULTIRES_H__
#define __MULTIRES_H__

#include "dm_type.h"
#include "dm_defs.h"
#include "r_data.h"
#include "v_screen.h"
#include "v_video1.h"

boolean_t V_MultiResInit(void);
void V_InitResolution(void);
void V_AddAvailableResolution(screenmode_t *mode);
int V_FindClosestResolution(screenmode_t *mode,
    boolean_t samesize, boolean_t samedepth);
int V_CompareModes(screenmode_t *A, screenmode_t *B);

//
//start with v_video.h
//
#define CENTERY                 (SCREENHEIGHT/2)

#define FROM_320(x)  ((x) * SCREENWIDTH  / 320)
#define FROM_200(y)  ((y) * SCREENHEIGHT / 200)

extern screen_t *main_scr;
extern screen_t *back_scr;


extern void (*V_CopyRect) (screen_t * dest, screen_t * src, int srcx, int srcy, int width, int height, int destx, int desty);
extern void (*V_CopyScreen) (screen_t * dest, screen_t * src);

extern void (*V_DrawPixel) (screen_t * scr, int x, int y, int c);
extern void (*V_DrawLine) (screen_t * scr, int x1, int y1, int x2, int y2, int c);
extern void (*V_DrawBox) (screen_t * scr, int x, int y, int w, int h, int c);
extern void (*V_DrawBoxAlpha) (screen_t * scr, int x, int y, int w, int h, int c, fixed_t alpha);

//
// now with r_draw.h
//
extern const coltable_t *dc_colourmap;
extern int dc_x;
extern int dc_yl;
extern int dc_yh;
extern int dc_width, dc_height;
extern fixed_t dc_yfrac;
extern fixed_t dc_ystep;
extern fixed_t dc_translucency;

#ifndef NOSMOOTHING
extern boolean_t dc_usesmoothing;
extern boolean_t ds_usesmoothing;
#endif

// first pixel in a column
extern const byte *dc_source;

#ifndef NOSMOOTHING
extern fixed_t dc_xfrac;
extern const byte *dc_source2;
#endif

extern byte **ylookup;
extern int *columnofs;

extern void (*resinit_r_draw_c) (void);
extern void (*R_DrawColumn) (void);
extern void (*R_DrawColumn_MIP) (void);
extern void (*R_DrawFuzzColumn) (void);
extern void (*R_DrawTranslucentColumn) (void);
extern void (*R_DrawTranslucentColumn_MIP) (void);
extern void (*R_DrawTranslatedColumn) (void);
extern void (*R_DrawTranslucentTranslatedColumn) (void);
extern void (*R_VideoErase) (unsigned ofs, int count); 

extern int ds_y;
extern int ds_x1;
extern int ds_x2;

extern const coltable_t *ds_colourmap;

extern fixed_t ds_xfrac, ds_yfrac;
extern fixed_t ds_xstep, ds_ystep;
extern int ds_width, ds_height;

// start of a 64*64 tile image
extern const byte *ds_source;

extern const byte *dc_translation;

extern void (*R_DrawSpan) (void);
extern void (*R_DrawSpan_MIP) (void);
extern void (*R_DrawTranslucentSpan) (void);
extern void (*R_DrawTranslucentSpan_MIP) (void);
extern void (*R_DrawHoleySpan_MIP) (void);
extern void V_ClearPageBackground(screen_t * scr);

void R_DrawViewBorder(void);
void R_FillBackScreen(void);

// WPost stuff

extern int dp_x;
extern int dp_yl, dp_yh;

extern fixed_t dp_yfrac;
extern fixed_t dp_ystep;
extern fixed_t dp_yscale;

// Screen Modes
extern screenmode_t *scrmode;
extern int numscrmodes;

#endif // __MULTIRES_H__
</t>
<t tx="T2607">@ignore

// Screen Handling

#ifndef __V_SCREENS_H__
#define __V_SCREENS_H__

#include "dm_type.h"

typedef struct screen_s screen_t;

// screen_t:
// The struct used by all rendering routines to describe where to
// draw.
struct screen_s
{
  // unique number for this screen. Changes whenever screen is resized.
  long id;
  // Dimensions
  int width;
  int height;
  // The address difference between two vertically adjacent pixels
  int pitch;
  // Bytes Per Pixel
  int bytepp;
  // The data area to draw to
  byte *data;
  // Parent screen: The screen this screen is part of if it's a subscreen.
  // Otherwise this is NULL.
  screen_t *parent;
  // The number of children this screen has. You must destroy all children
  // before changing the data pointer (ie. resize or destroy the screen).
  int children;
  // position within parent if it's a subscreen
  int x, y;
};

void V_EmptyScreen(screen_t *scr);
void V_DestroyScreen(screen_t *scr);
void V_InitScreen(screen_t *s, int width, int height, int bytepp);
screen_t *V_CreateScreen(int width, int height, int bytepp);
screen_t *V_CreateEmptyScreen(void);
void V_InitSubScreen(screen_t *s, screen_t *p, int x, int y, int width, int height);
screen_t *V_CreateSubScreen(screen_t *p, int x, int y, int width, int height);
void V_MoveSubScreen(screen_t *s, int x, int y);
screen_t *V_ResizeScreen(screen_t *s, int newwidth, int newheight, int newbytepp);
int V_GetPitch(int width, int bytepp);
boolean_t V_ScreensIntersect(screen_t *s1, screen_t * s2);
int V_ScreenHasCurrentRes(screen_t *scr);

#endif // __V_SCREENS_H__
</t>
<t tx="T2608">@ignore

// Top-level Video System

#ifndef __V_TOPLEV__
#define __V_TOPLEV__

#include "dm_type.h"
#include "w_image.h"
#include "v_ctx.h"

//
// These routines provide an interface to the video context (see
// v_ctx.h) to be used by Drawer() functions in the layer system.
// Most importantly, the drawing routines here (Drawimage and
// SolidBox) will clip to the dirty matrix and solid rectangles
// which the VCTX routines ignore.
//

void VTOP_NewScreenSize(int width, int height, int bpp);
void VTOP_RenderScene(int x1, int y1, int x2, int y2, vid_view_t *view);
byte *VTOP_ReadScreen(int x1, int y1, int x2, int y2);

void VTOP_BeginDraw(int x1, int y1, int x2, int y2, int solid_index);
void VTOP_EndDraw(void);

void VTOP_DrawImage(int x1, int y1, int x2, int y2,
    float_t tx1, float_t ty1, float_t tx2, float_t ty2,
    const image_t *image, const colourmap_t *colmap, 
    int alpha, boolean_t is_vol);
  
void VTOP_SolidBox(int x1, int y1, int x2, int y2,
    int colour, int alpha, boolean_t is_vol);
void VTOP_SolidLine(int x1, int y1, int x2, int y2,
    int colour, int alpha);

//
// Utility routines for analysing the dirty matrix and/or solid
// rectangles and returning rectangles to draw.
//

void VTOP_AnalyseBegin(int x1, int y1, int x2, int y2, int solid_index);
void VTOP_AnalyseEnd(void);
boolean_t VTOP_AnalyseNextRect(int *x1, int *y1, int *x2, int *y2);


#endif  // __V_TOPLEV__
</t>
<t tx="T2609">@ignore

// Video Code for 8-Bit Colour. 

#ifndef __V_VIDEO1__
#define __V_VIDEO1__

#include "dm_type.h"
#include "dm_defs.h"

// Needed because we are refering to patches.
#include "r_data.h"
#include "v_screen.h"

// -AJA- 1999/07/04: added the following misc drawing functions:
void V_DrawPixel8(screen_t * scr, int x, int y, int c);
void V_DrawLine8(screen_t * scr, int x1, int y1, int x2, int y2, int c);
void V_DrawBox8(screen_t * scr, int x, int y, int w, int h, int c);
void V_DrawBoxAlpha8(screen_t * scr, int x, int y, int w, int h, int c, fixed_t alpha);

void V_CopyRect8(screen_t * dest, screen_t * src, int srcx, int srcy, int width, int height, int destx, int desty);

void V_CopyScreen8(screen_t * dest, screen_t * src);

#endif
</t>
<t tx="T2610">@ignore

// Video Code for 16-Bit Colour. 

#ifndef __V_VIDEO2__
#define __V_VIDEO2__
#ifndef NOHICOLOUR

#include "dm_type.h"
#include "dm_defs.h"

// Needed because we are refering to patches.
#include "r_data.h"
#include "v_screen.h"

// -AJA- 1999/07/04: added the following misc drawing functions:
void V_DrawPixel16(screen_t * scr, int x, int y, int c);
void V_DrawLine16(screen_t * scr, int x1, int y1, int x2, int y2, int c);
void V_DrawBox16(screen_t * scr, int x, int y, int w, int h, int c);
void V_DrawBoxAlpha16(screen_t * scr, int x, int y, int w, int h, int c, fixed_t alpha);

void V_CopyRect16(screen_t * dest, screen_t * src, int srcx, int srcy, int width, int height, int destx, int desty);

void V_CopyScreen16(screen_t * dest, screen_t * src);

#endif // NOHICOLOUR
#endif // __V_VIDEO2__
</t>
<t tx="T2611">@ignore

// Version Header

#define EDGEVER     0x127
#define EDGEVERSTR  "1.27"

// patch level
#define EDGEPATCH  0x00

// -ES- 2000/03/04 The version of EDGE.WAD we require.
#define EDGE_WAD_VERSION 2
#define EDGE_WAD_VERSION_FRAC 5
#define EDGE_WAD_SUB_VERSION 0

// Currently this must be one byte.  Should be removed later (and just
// use EDGEVER directly).

#define DEMOVERSION  (EDGEVER &amp; 0x0FF)
</t>
<t tx="T2612">@ignore

// Generalised Image Handling

#ifndef __W_IMAGE__
#define __W_IMAGE__

#include "dm_type.h"
#include "r_defs.h"
#include "r_state.h"
#include "z_zone.h"

struct texturedef_s;

// the transparent pixel value we use
#define TRANS_PIXEL  247

// Post end marker
#define P_SENTINEL  0xFF

// Post structure.  It isn't a C struct to prevent alignment issues,
// but the W_XXX defines are like structure fields.
typedef byte w_post_t;

#define W_SKIP  0
  // number of pixels to skip down from current position.  The initial
  // position is just the top of the sprite.  Will be P_SENTINEL for
  // the end-of-post marker.

#define W_LEN  1
  // number of real pixels following this, not including the following
  // pad pixel and another one after the last pixel.

#define W_PAD1  2
  // first pad pixel.  Another pad pixel implicitly follows the last
  // real pixel.  The pad pixels should be the same as the real pixel
  // they are next to, in case the fixed point arithmetic overflows.

#define W_DATA   3  // first data pixel.
#define W_TOTAL  4  // total of post

// preferred access routines
#define WPOST_SKIP(wp)  (wp[W_SKIP])
#define WPOST_LEN(wp)   (wp[W_LEN])
#define WPOST_DATA(wp)  (wp + W_DATA)
#define WPOST_NEXT(wp)  (wp + W_TOTAL + WPOST_LEN(wp))


typedef struct image_s
{
  // total image size, must be a power of two on each axis.
  unsigned short total_w;
  unsigned short total_h;

  // actual image size.  Images that are smaller than their total size
  // are located in the top left corner, cannot tile, and are padded
  // with black pixels if solid, or transparent pixels otherwise.
  unsigned short actual_w;
  unsigned short actual_h;

  // offset values.  Only used for sprites.
  short offset_x;
  short offset_y;

  // scale values, where 0x0100 is normal.  Higher values stretch the
  // image (on the wall/floor), lower values shrink it.
  unsigned short scale_x;
  unsigned short scale_y;

  // when true, the image is guaranteed to be solid (i.e. contain no
  // transparent parts).
  boolean_t solid;

  // ...rest of this structure is private...
}
image_t;

// opaque structure for using images
typedef byte cached_image_t;

// macro for converting image_t sizes to cached_image_t sizes
#define MIP_SIZE(size,mip)  MAX(1, (size) &gt;&gt; (mip))

// utility macros
#define IM_RIGHT(image)  ((float_t)(image)-&gt;actual_w / (image)-&gt;total_w)
#define IM_BOTTOM(image) ((float_t)(image)-&gt;actual_h / (image)-&gt;total_h)

#define IM_WIDTH(image)  ((image)-&gt;actual_w * (image)-&gt;scale_x / 0x100)
#define IM_HEIGHT(image) ((image)-&gt;actual_h * (image)-&gt;scale_y / 0x100)

#define IM_OFFSETX(image) ((image)-&gt;offset_x * (image)-&gt;scale_x / 0x100)
#define IM_OFFSETY(image) ((image)-&gt;offset_y * (image)-&gt;scale_y / 0x100)

typedef enum
{
  // Vertical posts.  Each post is essentially the same as in normal
  // doom, with one exception: the first byte is not an absolute Y
  // offset from top of sprite, but the number of pixels to skip from
  // the current position.  This removes the height limitation from
  // the column drawers (it still exists in the WAD format though).
  IMG_Post = 0,

  // Block o' pixels.  Total size is MIP_SIZE(total_h, mip) *
  // MIP_SIZE(total_w, mip).  Pixel ordering is optimised for walls:
  // 1st byte is top left, 2nd byte is next pixel down, etc...
  // Transparent parts (if any) have `TRANS_PIXEL' values.
  IMG_Block = 1,

  // OpenGL support.  The image is not read directly, but referred to
  // as a GL texture id number (which can be given to glBindTexture).
  // The `mip' value must be 0.  Transparent parts (if any) are given
  // an alpha of zero (otherwise alpha is 255).
  IMG_OGL = 2
}
image_mode_e;

//
//  IMAGE LOOKUP
//

const image_t *W_ImageFromTexture(const char *tex_name);
const image_t *W_ImageFromFlat(const char *flat_name);
const image_t *W_ImageFromPatch(const char *patch_name);
const image_t *W_ImageFromFont(const char *patch_name);
const image_t *W_ImageFromHalo(const char *patch_name);
const image_t *W_ImageForDummySprite(void);

extern image_t *savepic_image;

const image_t *W_ImageFromString(char type, const char *name);
void W_ImageToString(const image_t *image, char *type, char *namebuf);


//
//  IMAGE USAGE
//

extern int use_mipmapping;
extern boolean_t use_smoothing;
extern boolean_t use_dithering;

boolean_t W_InitImages(void);
void W_UpdateImageAnims(void);
void W_ResetImages(void);

void W_ImageCreateFlats(int *lumps, int number);
void W_ImageCreateTextures(struct texturedef_s ** defs, int number);
const image_t *W_ImageCreateSprite(int lump);
void W_AnimateImageSet(const image_t ** images, int number, int speed);
void W_DrawSavePic(const byte *pixels);

void W_LockImagesOGL(void);
void W_UnlockImagesOGL(void);

const cached_image_t *W_ImageCache(const image_t *image, 
    image_mode_e mode, int mip, boolean_t anim);
void W_ImageDone(const cached_image_t *c);
void W_ImagePreCache(const image_t *image);

const w_post_t *W_ImageGetPost(const cached_image_t *c, int column);

const byte *W_ImageGetBlock(const cached_image_t *c);

#ifdef USE_GL
GLuint W_ImageGetOGL(const cached_image_t *c);
#endif

#ifdef DEVELOPERS
const char *W_ImageDebugName(const image_t *image);
#endif

// internal routines -- only needed by rgl_wipe.c
int W_MakeValidSize(int value);

#endif  // __W_IMAGE__
</t>
<t tx="T2613">@ignore

// Rendering Data Handling Code

//
// DESCRIPTION:
//  Refresh module, data I/O, caching, retrieval of graphics
//  by name.
//

#ifndef __W_TEXTURE__
#define __W_TEXTURE__

#include "r_defs.h"
#include "r_state.h"
#include "z_zone.h"

// Texture cache reference structure, returned by the texture cache system.
// The actual structure is private.
typedef byte cached_tex_t;

// Retrieve column data.
const byte *W_GetColumn(int col, const cached_tex_t *t);

// Standard cache functions. Call W_CacheTextureNum when you first need
// the lump, and release it with DoneWithTexture.
const cached_tex_t *W_CacheTextureNum(int texnum);
void W_DoneWithTexture(const cached_tex_t *t);

void W_PreCacheTextureNum(int texnum);


// Called by P_Ticker for switches and animations,
// returns the texture number for the texture name.
int W_TextureNumForName(const char *name);
int W_CheckTextureNumForName(const char *name);

boolean_t W_InitTextures(void);
int W_FindTextureSequence(const char *start, const char *end,
    int *s_offset, int *e_offset);
const char *W_TextureNameInSet(int set, int offset);
  

//
// Graphics:
// ^^^^^^^^^
// DOOM graphics for walls and sprites is stored in vertical runs of
// opaque pixels (posts).
//
// A column is composed of zero or more posts, a patch or sprite is
// composed of zero or more columns.
//

//
// A single patch from a texture definition, basically a rectangular area
// within the texture rectangle.
//
// Note: Block origin (always UL), which has already accounted
// for the internal origin of the patch.
//
typedef struct
{
  int originx;
  int originy;
  int patch;  // lump number
}
texpatch_t;

//
// A texturedef_t describes a rectangular texture, which is composed of
// one or more mappatch_t structures that arrange graphic patches.
//
typedef struct texturedef_s
{
  // Keep name for switch changing, etc.  Zero terminated.
  char name[10];

  short width;
  short height;

  // which WAD file this texture came from
  short file;
  
  unsigned short *columnofs;
  int palette_lump;

  // All the patches[patchcount] are drawn back to front into the
  // cached texture.
  short patchcount;
  texpatch_t patches[1];
}
texturedef_t;

#endif
</t>
<t tx="T2614">@ignore

// WAD Support Code

#ifndef __W_WAD__
#define __W_WAD__

#include "dm_defs.h"
#include "z_zone.h"

typedef struct wadtex_resource_s
{
  // lump numbers, or -1 if nonexistent
  int palette;
  int pnames;
  int texture1;
  int texture2;
}
wadtex_resource_t;

typedef enum
{
  LMPLST_Sprites,
  LMPLST_Flats,
}
lumplist_e;

extern int numlumps;
extern int addwadnum;

void W_AddRawFilename(const char *file, boolean_t allow_ddf);
boolean_t W_InitMultipleFiles(void);

int W_CheckNumForName2(const char *name);
int W_GetNumForName2(const char *name);

int W_LumpLength(int lump);
void W_ReadLump(int lump, void *dest);
boolean_t W_LumpRawInfo(int lump, int *handle, int *pos, int *size);

void W_DoneWithLump(const void *ptr);
void W_DoneWithLump_Flushable(const void *ptr);
const void *W_CacheLumpNum2(int lump);
const void *W_CacheLumpName2(const char *name);
void W_PreCacheLumpNum(int lump);
void W_PreCacheLumpName(const char *name);
void *W_LoadLumpNum(int lump);
void *W_LoadLumpName(const char *name);
boolean_t W_VerifyLumpName(int lump, const char *name);
const char *W_GetLumpName(int lump);
int W_CacheInfo(int level);

const char *W_GetFileName(int lump);
int W_GetPaletteForLump(int lump);
void W_AddDynamicGWA(const char *filename, int map_lump);
int W_FindFlatSequence(const char *start, const char *end, 
    int *s_offset, int *e_offset);
const int *W_GetListLumps(int file, lumplist_e which, int *count);
void W_GetTextureLumps(int file, wadtex_resource_t *res);
int W_GetNumFiles(void);

// Define this only in an emergency.  All these debug printfs quickly
// add up, and it takes only a few seconds to end up with a 40 meg debug file!
#ifdef WAD_CHECK
static int W_CheckNumForName3(const char *x, const char *file, int line)
{
  Debug_Printf("Find '%s' @ %s:%d\n", x, file, line);
  return W_CheckNumForName2(x);
}

static int W_GetNumForName3(const char *x, const char *file, int line)
{
  Debug_Printf("Find '%s' @ %s:%d\n", x, file, line);
  return W_GetNumForName2(x);
}

static void *W_CacheLumpNum3(int lump, const char *file, int line)
{
  Debug_Printf("Cache '%d' @ %s:%d\n", lump, file, line);
  return W_CacheLumpNum2(lump, tag);
}

static void *W_CacheLumpName3(const char *name, const char *file, int line)
{
  Debug_Printf("Cache '%s' @ %s:%d\n", name, file, line);
  return W_CacheLumpName2(name, tag);
}

#define W_CheckNumForName(x) W_CheckNumForName3(x, __FILE__, __LINE__)
#define W_GetNumForName(x) W_GetNumForName3(x, __FILE__, __LINE__)
#define W_CacheLumpNum(x) W_CacheLumpNum3(x, __FILE__, __LINE__)
#define W_CacheLumpName(x) W_CacheLumpName3(x, __FILE__, __LINE__)

#else
#define W_CheckNumForName(x) W_CheckNumForName2(x)
#define W_GetNumForName(x) W_GetNumForName2(x)
#define W_CacheLumpNum(x) W_CacheLumpNum2(x)
#define W_CacheLumpName(x) W_CacheLumpName2(x)
#endif
#endif
</t>
<t tx="T2615">@ignore

// Intermission Screen Code

#ifndef __WI_STUFF__
#define __WI_STUFF__

#include "dm_defs.h"
#include "e_player.h"

// States for the intermission

typedef enum
{
  NoState = -1,
  StatCount,
  ShowNextLoc

}
stateenum_t;

// Called by main loop, animate the intermission.
void WI_Ticker(void);

// Called by main loop,
// draws the intermission directly into the screen buffer.
void WI_Drawer(void);

// Setup for an intermission screen.
void WI_Start(wbstartstruct_t * wbstartstruct);

extern wi_map_t worldmap;
void WI_MapInit(const wi_map_t * map);

#endif
</t>
<t tx="T2616">@ignore

// Wipe Main

//
// DESCRIPTION:
//   Mission start screen wipe/melt, special effects.
// 

#ifndef __F_WIPE_H__
#define __F_WIPE_H__

#include "v_screen.h"
#include "m_fixed.h"

//
//                       SCREEN WIPE PACKAGE
//

typedef enum
{
  // no wiping
  WIPE_None,
  // weird screen melt
  WIPE_Melt,
  // cross-fading
  WIPE_Crossfade,
  // pixel fading
  WIPE_Pixelfade,

  // new screen simply scrolls in from the given side of the screen
  // (or if reversed, the old one scrolls out to the given side)
  WIPE_Top,
  WIPE_Bottom,
  WIPE_Left,
  WIPE_Right,

  // Scrolls in from all corners
  WIPE_Corners,

  // Opens like doors
  WIPE_Doors,

  WIPE_NUMWIPES
}
wipetype_e;

typedef struct wipeinfo_s wipeinfo_t;
typedef struct wipeparm_s wipeparm_t;
typedef struct wipescr_s wipescr_t;

typedef struct wipetype_s
{
  // allow that start or end are equal to dest
  boolean_t allow_start_dest;
  boolean_t allow_end_dest;
  // these should init/destroy the data field of wp
  void (*init_info) (wipeparm_t * wp);
  void (*destroy_info) (wipeparm_t * wp);
  // returns the default duration of the effect.
  int (*def_duration) (wipeinfo_t * wi);

  // wipe: take in some way (1-progress)*start plus
  // progress*end and put the result in dest.
  void (*do_wipe) (wipeparm_t * wp);
}
wipetype_t;

struct wipescr_s
{
  // the id of the screen to be wiped. Wiping is cancelled if
  // the screen changes before it's finished.
  long id;

  // This is either just a subscreen to the one that was passed to
  // InitWipe, or it's a standalone copy of it.
  screen_t *scr;
  // if this is true, scr is a copy of the actual screen, and should
  // be updated in every call to WIPE_DoWipe. Used when destination
  // intersects with start (or end).
  boolean_t update_scr;
  // used for positioning if update_scr is set.
  int update_x, update_y;
};

// the parameters to the actual wipe routines
struct wipeparm_s
{
  // the screens the wiping affects. Points to the scr elements of the
  // wipeinfo's wipescrs, but may be shuffled if the effect is reversed.
  screen_t *dest;
  screen_t *start;
  screen_t *end;

  // ranges from 0 to 1.0. 0 means 100% start, 1.0 means 100% end.
  float_t progress;

  // data that is customisable for wipetype
  void *data;
};

struct wipeinfo_s
{
  wipescr_t dest, start, end;

  // the total number of tics this wipe will last.
  int duration;

  // tells whether this wipeinfo is active or done.
  boolean_t active;

  // w &amp; h of the area where wiping will take place
  int width, height;

  // a reversed wipe does the effect backwards, but it still starts with
  // start screen and ends with end screen. E.g. a reversed melt means that
  // the end screen anti-melts (moves upward) until it covers the entire
  // screen. Crossfading is not affected by revesion.
  boolean_t reversed;
  wipetype_t *type;

  // the parameters to the wiper
  wipeparm_t parms;
};

extern wipetype_t wipes[WIPE_NUMWIPES];

// for enum cvars
extern const char WIPE_EnumStr[];

// creates and destroys wipeinfos.
wipeinfo_t *WIPE_CreateWipeInfo(void);
void WIPE_DestroyWipeInfo(wipeinfo_t * wi);

wipeinfo_t *WIPE_InitWipe(screen_t * dest, int destx, int desty,
    screen_t * start, int startx, int starty, int cstart,
    screen_t * end, int endx, int endy, int cend,
    int width, int height, wipeinfo_t * wi,
    int duration, boolean_t reverse, wipetype_e effect);

// you don't need to call this, that's done automatically.
void WIPE_StopWipe(screen_t * dest, screen_t * start, screen_t * end, wipeinfo_t * wi);

// does the progress'th tic of the wipe. Returns true when done. Always keep
// calling this until it returns true.
boolean_t WIPE_DoWipe(screen_t * dest, screen_t * start, screen_t * end, int progress, wipeinfo_t * wi);

#endif
</t>
<t tx="T2617">@ignore

// Zone Memory Allocation Code 

#ifndef __Z_ZONE__
#define __Z_ZONE__

#include "dm_type.h"

#define ZONEID  0x1d4a11f1

typedef enum
{
  Z_UrgencyLow     = 1,
  Z_UrgencyMedium  = 2,
  Z_UrgencyHigh    = 3,
  Z_UrgencyExtreme = 4
}
z_urgency_e;

// A cache flusher is a function that can find and free unused memory.
typedef void cache_flusher_f(z_urgency_e urge);

typedef struct stack_array_s stack_array_t;

struct stack_array_s
{
  // points to the actual array pointer.
  // the stack_array is defined to be uninitialised if this one is NULL.
  void ***ptr;

  // the size of each element in ptr.
  int elem_size;

  // The number of currently used objects.
  // Elements above this limit will be freed automatically if memory gets
  // tight. Otherwise it will stay there, saving some future Z_ReMalloc calls.
  int num;

  // The number of allocated objects.
  int max;

  // alloc_bunch elements will be allocated at a time, saving some memory block
  // overheads.
  // If this is negative, the array will work in a different way:
  // *ptr will be an array of elements rather than an array of pointers.
  // This means that no pointer except *ptr may point to an element
  // of the array, since it can be reallocated any time.
  int alloc_bunch;

  // Shows the number of users who have locked this grow_array.
  int locked;

  stack_array_t *next;
};

// Stack array functions.
void Z_LockStackArray(stack_array_t *a);
void Z_UnlockStackArray(stack_array_t *a);
void Z_ClearStackArray(stack_array_t *a);
void Z_DeleteStackArray(stack_array_t *a);
void Z_InitStackArray(stack_array_t *a, void ***ptr, int elem_size, int alloc_bunch);
stack_array_t *Z_CreateStackArray(void ***ptr, int elem_size, int alloc_bunch);
void Z_SetArraySize(stack_array_t *a, int num);

// Generic helper functions.
char *Z_StrDup(const char *s);

// Memory handling functions.
void Z_RegisterCacheFlusher(cache_flusher_f *f);
void Z_Init(void);
void *Z_Calloc2(int size);
void *Z_Malloc2(int size);
void *Z_ReMalloc2(void *ptr, int size);
void Z_Free(void *ptr);
void Z_CheckHeap(void);
int Z_FreeMemory(int level);
int Z_UsedMemory(int level);
boolean_t Z_CheckIfZero(const byte *ptr, int size);

// -ES- 1999/12/16 Leak Hunt
#ifdef LEAK_HUNT
void *Z_RegisterMalloc(void *ptr, const char *file, int row);
void *Z_UnRegisterTmpMalloc(void *ptr, const char *func);
void Z_DumpLeakInfo(int level);
#define Z_Malloc(size) Z_RegisterMalloc(Z_Malloc2(size),__FILE__,__LINE__)
#define Z_Calloc(size) Z_RegisterMalloc(Z_Calloc2(size),__FILE__,__LINE__)
#define Z_ReMalloc(ptr,size) Z_RegisterMalloc(Z_ReMalloc2(ptr,size),__FILE__,__LINE__)
#else
#define Z_Malloc Z_Malloc2
#define Z_Calloc Z_Calloc2
#define Z_ReMalloc Z_ReMalloc2
#endif

//
// Z_New
//
// Allocates num elements of type. Use this instead of Z_Malloc whenever
// possible.
//
#define Z_New(type, num) ((type *) Z_Malloc((num) * sizeof(type)))

//
// Z_Resize
//
// Reallocates a block. Use instead of Z_ReMalloc wherever possible.
// Unlike normal Z_ReMalloc, the pointer parameter is assigned the new
// value, and there is no return value.
//
#define Z_Resize(ptr,type,n)  \
    (void)((ptr) = (type *) Z_ReMalloc((void *)(ptr), (n) * sizeof(type)))

//
// Z_ClearNew
//
// The Z_Calloc version of Z_New. Allocates mem and clears it to zero.
//
#define Z_ClearNew(type, num) ((type *) Z_Calloc((num) * sizeof(type)))

//
// Z_Clear
//
// Clears memory to zero.
//
#define Z_Clear(ptr, type, num)  \
    memset((void *)(ptr), ((ptr) - ((type *)(ptr))), (num) * sizeof(type))

//
// Z_MoveData
//
// moves data from src to dest.
//
#define Z_MoveData(dest, src, type, num)  \
    I_MoveData((void *)(dest), (void *)(src), (num) * sizeof(type) + ((src) - (type *)(src)) + ((dest) - (type *)(dest)))

//
// StrNCpy
//
// Copies up to max characters of src into dest, and then applies a
// terminating zero (so dest must hold at least max+1 characters).
// The terminating zero is always applied (there is no reason not to)
//
#define Z_StrNCpy(dest, src, max) \
     (void)(strncpy((dest), (src), (max)), (dest)[(max)] = 0)

// -AJA- 2001/07/24: New lightweight "Bunches"

#define Z_Bunch(type)  \
    struct { type *arr; int max; int num; }
    
#define Z_BunchNewSize(var, type)  do {  \
      if ((var).num &gt; (var).max)  \
      { (var).max = (var).num + 16;  \
        Z_Resize((var).arr, type, (var).max);  \
      } } while(0)
 
#endif
</t>
<t tx="T2619">//    For documentation, see http://edge.sourceforge.net/
//    Version 3.7

@comment //
</t>
<t tx="T2620">@ignore

//    EDGE LINES.DDF -redefine or add new line triggers.

&lt;LINES&gt;

@others</t>
<t tx="T2621">@ignore
 
//    EDGE PLAYLIST.DDF -redefine music playing information(s)

&lt;PLAYLISTS&gt;

// DOOM 2

[01] MUSICINFO=MUS:LUMP:"D_RUNNIN";
[02] MUSICINFO=MUS:LUMP:"D_STALKS";
[03] MUSICINFO=MUS:LUMP:"D_COUNTD";
[04] MUSICINFO=MUS:LUMP:"D_BETWEE";
[05] MUSICINFO=MUS:LUMP:"D_DOOM";
[06] MUSICINFO=MUS:LUMP:"D_THE_DA";
[07] MUSICINFO=MUS:LUMP:"D_SHAWN";
[08] MUSICINFO=MUS:LUMP:"D_DDTBLU";
[09] MUSICINFO=MUS:LUMP:"D_IN_CIT";
[10] MUSICINFO=MUS:LUMP:"D_DEAD";
[11] MUSICINFO=MUS:LUMP:"D_STLKS2";
[12] MUSICINFO=MUS:LUMP:"D_THEDA2";
[13] MUSICINFO=MUS:LUMP:"D_DOOM2";
[14] MUSICINFO=MUS:LUMP:"D_DDTBL2";
[15] MUSICINFO=MUS:LUMP:"D_RUNNI2";
[16] MUSICINFO=MUS:LUMP:"D_DEAD2";
[17] MUSICINFO=MUS:LUMP:"D_STLKS3";
[18] MUSICINFO=MUS:LUMP:"D_ROMERO";
[19] MUSICINFO=MUS:LUMP:"D_SHAWN2";
[20] MUSICINFO=MUS:LUMP:"D_MESSAG";
[21] MUSICINFO=MUS:LUMP:"D_COUNT2";
[22] MUSICINFO=MUS:LUMP:"D_DDTBL3";
[23] MUSICINFO=MUS:LUMP:"D_AMPIE";
[24] MUSICINFO=MUS:LUMP:"D_THEDA3";
[25] MUSICINFO=MUS:LUMP:"D_ADRIAN";
[26] MUSICINFO=MUS:LUMP:"D_MESSG2";
[27] MUSICINFO=MUS:LUMP:"D_ROMER2";
[28] MUSICINFO=MUS:LUMP:"D_TENSE";
[29] MUSICINFO=MUS:LUMP:"D_SHAWN3";
[30] MUSICINFO=MUS:LUMP:"D_OPENIN";
[31] MUSICINFO=MUS:LUMP:"D_EVIL";
[32] MUSICINFO=MUS:LUMP:"D_ULTIMA";

// DOOM 1

[33] MUSICINFO=MUS:LUMP:"D_E1M1";
[34] MUSICINFO=MUS:LUMP:"D_E1M2";
[35] MUSICINFO=MUS:LUMP:"D_E1M3";
[36] MUSICINFO=MUS:LUMP:"D_E1M4";
[37] MUSICINFO=MUS:LUMP:"D_E1M5";
[38] MUSICINFO=MUS:LUMP:"D_E1M6";
[39] MUSICINFO=MUS:LUMP:"D_E1M7";
[40] MUSICINFO=MUS:LUMP:"D_E1M8";
[41] MUSICINFO=MUS:LUMP:"D_E1M9";

[42] MUSICINFO=MUS:LUMP:"D_E2M1";
[43] MUSICINFO=MUS:LUMP:"D_E2M2";
[44] MUSICINFO=MUS:LUMP:"D_E2M3";
[45] MUSICINFO=MUS:LUMP:"D_E2M4";
[46] MUSICINFO=MUS:LUMP:"D_E2M5";
[47] MUSICINFO=MUS:LUMP:"D_E2M6";
[48] MUSICINFO=MUS:LUMP:"D_E2M7";
[49] MUSICINFO=MUS:LUMP:"D_E2M8";
[50] MUSICINFO=MUS:LUMP:"D_E2M9";

[51] MUSICINFO=MUS:LUMP:"D_E3M1";
[52] MUSICINFO=MUS:LUMP:"D_E3M2";
[53] MUSICINFO=MUS:LUMP:"D_E3M3";
[54] MUSICINFO=MUS:LUMP:"D_E3M4";
[55] MUSICINFO=MUS:LUMP:"D_E3M5";
[56] MUSICINFO=MUS:LUMP:"D_E3M6";
[57] MUSICINFO=MUS:LUMP:"D_E3M7";
[58] MUSICINFO=MUS:LUMP:"D_E3M8";
[59] MUSICINFO=MUS:LUMP:"D_E3M9";

[60] MUSICINFO=MUS:LUMP:"D_READ_M";
[61] MUSICINFO=MUS:LUMP:"D_VICTOR";
[62] MUSICINFO=MUS:LUMP:"D_INTRO";
[63] MUSICINFO=MUS:LUMP:"D_INTER";

// DOOM 2 Title and EDGE Title

[64] MUSICINFO=MUS:LUMP:"D_DM2INT";
[65] MUSICINFO=MUS:LUMP:"D_DM2TTL";
[66] MUSICINFO=MUS:LUMP:"D_EDGTTL";</t>
<t tx="T2622">@ignore

//    EDGE SECTORS.DDF -redefine or add new sector type(s).

&lt;SECTORS&gt;

[1]  // Light Random Off
LIGHT_TYPE=FLASH;
LIGHT_CHANCE=10%;
LIGHT_DARKTIME=8T;
LIGHT_BRIGHTTIME=8T;

[2]  // Light Blink Half Second
LIGHT_TYPE=STROBE;
LIGHT_DARKTIME=15T;
LIGHT_BRIGHTTIME=5T;

[3]  // Light Blink 1 Second
LIGHT_TYPE=STROBE;
LIGHT_DARKTIME=35T;
LIGHT_BRIGHTTIME=5T;

[4]  // Light Blink And Damage
LIGHT_TYPE=STROBE;
LIGHT_DARKTIME=15T;
LIGHT_BRIGHTTIME=5T;
DAMAGE.VAL=20;
DAMAGE.DELAY=32T;

[5]  // Damage Large
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;

[7]  // Damage Small
DAMAGE.VAL=5;
DAMAGE.DELAY=32T;

[8]  // Light Oscillate
LIGHT_TYPE=GLOW;
LIGHT_DARKTIME=1T;
LIGHT_BRIGHTTIME=1T;

[9]  // Secret
SECRET=TRUE;

[10]  // Ceiling Close 30 Sec
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=2;
CEILING.WAIT_TIME=30;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=DORCLS;

[11]  // End Damage Special
DAMAGE.VAL=20;
DAMAGE.DELAY=32T;
EXIT=NORMAL;

[12]  // Light Sync Half Second
LIGHT_TYPE=STROBE;
LIGHT_DARKTIME=35T;
LIGHT_BRIGHTTIME=5T;
LIGHT_SYNC=40T;

[13]  // Light Sync 1 Second
LIGHT_TYPE=STROBE;
LIGHT_DARKTIME=15T;
LIGHT_BRIGHTTIME=5T;
LIGHT_SYNC=20T;

[14]  // Ceiling Open 5 Min
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.WAIT_TIME=300;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

[16]  // Damage Extreme
DAMAGE.VAL=20;
DAMAGE.DELAY=32T;

[17]  // Light Flicker
LIGHT_TYPE=FLICKER;
LIGHT_DARKTIME=4T;
LIGHT_BRIGHTTIME=4T;

// EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH

[18] // EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH NORTH
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    
FLOOR.SCROLL_ANGLE=90;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=90;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=90;
PUSH_SPEED=12;

[19] // EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH NORTH EAST
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    
FLOOR.SCROLL_ANGLE=45;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=45;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=45;
PUSH_SPEED=12;

[20] // EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH EDGE EAST
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    
FLOOR.SCROLL_ANGLE=0;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=0;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=0;
PUSH_SPEED=12;

[21] // EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH EDGE SOUTH EAST
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    
FLOOR.SCROLL_ANGLE=315;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=315;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=315;
PUSH_SPEED=12;

[22] // EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH EDGE SOUTH
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    
FLOOR.SCROLL_ANGLE=270;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=270;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=270;
PUSH_SPEED=12;

[23] // EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH EDGE SOUTH WEST
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    
FLOOR.SCROLL_ANGLE=225;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=225;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=225;
PUSH_SPEED=12;

[24] // EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH EDGE WEST
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    
FLOOR.SCROLL_ANGLE=180;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=180;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=180;
PUSH_SPEED=12;

[25] // EDGE WATER LIQUID EXTRAFLOOR SCROLL/PUSH EDGE NORTH WEST
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    
FLOOR.SCROLL_ANGLE=135;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=135;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=135;
PUSH_SPEED=12;

// EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH SLIME LIQUID EXTRAFLOOR SCROLL/PUSH

[26] // EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH NORTH
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;
FLOOR.SCROLL_ANGLE=90;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=90;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=90;
PUSH_SPEED=12;

[27] // EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH NORTH EAST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;
FLOOR.SCROLL_ANGLE=45;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=45;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=45;
PUSH_SPEED=12;

[28] // EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH EAST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;
FLOOR.SCROLL_ANGLE=0;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=0;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=0;
PUSH_SPEED=12;

[29] // EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH SOUTH EAST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;
FLOOR.SCROLL_ANGLE=315;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=315;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=315;
PUSH_SPEED=12;

[30] // EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH SOUTH
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;
FLOOR.SCROLL_ANGLE=270;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=270;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=270;
PUSH_SPEED=12;

[31] // EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH SOUTH WEST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;
FLOOR.SCROLL_ANGLE=225;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=225;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=225;
PUSH_SPEED=12;

[32] // EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH WEST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;
FLOOR.SCROLL_ANGLE=180;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=180;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=180;
PUSH_SPEED=12;

[33] // EDGE SLIME LIQUID EXTRAFLOOR SCROLL/PUSH NORTH WEST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;
FLOOR.SCROLL_ANGLE=135;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=135;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=135;
PUSH_SPEED=12;

// EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH

[34] // EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH NORTH
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.70;
FLOOR.SCROLL_ANGLE=90;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=90;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=90;
PUSH_SPEED=12;

[35] // EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH NORTH EAST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.70;
FLOOR.SCROLL_ANGLE=45;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=45;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=45;
PUSH_SPEED=12;

[36] // EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH EAST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.70;
FLOOR.SCROLL_ANGLE=0;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=0;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=0;
PUSH_SPEED=12;

[37] // EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH SOUTH EAST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.70;
FLOOR.SCROLL_ANGLE=315;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=315;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=315;
PUSH_SPEED=12;

[38] // EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH SOUTH
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.70;
FLOOR.SCROLL_ANGLE=270;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=270;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=270;
PUSH_SPEED=12;

[39] // EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH SOUTH WEST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.70;
FLOOR.SCROLL_ANGLE=225;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=225;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=225;
PUSH_SPEED=12;

[40] // EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH WEST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.70;
FLOOR.SCROLL_ANGLE=180;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=180;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=180;
PUSH_SPEED=12;

[41] // EDGE LAVA LIQUID EXTRAFLOOR SCROLL/PUSH NORTH WEST
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.70;
FLOOR.SCROLL_ANGLE=135;
FLOOR.SCROLL_SPEED=12;
CEILING.SCROLL_ANGLE=135;
CEILING.SCROLL_SPEED=12;
PUSH_ANGLE=135;
PUSH_SPEED=12;

// EDGE PUSH

[42] // EDGE PUSH NORTH
PUSH_ANGLE=90;
PUSH_SPEED=6;

[43] // EDGE PUSH NORTH EAST
PUSH_ANGLE=45;
PUSH_SPEED=6;

[44] // EDGE PUSH EAST
PUSH_ANGLE=0;
PUSH_SPEED=6;

[45] // EDGE PUSH SOUTH EAST
PUSH_ANGLE=315;
PUSH_SPEED=6;

[46] // EDGE PUSH SOUTH
PUSH_ANGLE=270;
PUSH_SPEED=6;

[47] // EDGE PUSH SOUTH WEST
PUSH_ANGLE=225;
PUSH_SPEED=6;

[48] // EDGE PUSH WEST
PUSH_ANGLE=180;
PUSH_SPEED=6;

[49] // EDGE PUSH NORTH WEST
PUSH_ANGLE=135;
PUSH_SPEED=6;

// EDGE SCROLL FLOOR TEXTURE

[50] // EDGE SCROLL FLOOR TEXTURE NORTH
FLOOR.SCROLL_ANGLE=90;
FLOOR.SCROLL_SPEED=12;

[51] // EDGE SCROLL FLOOR TEXTURE NORTH EAST
FLOOR.SCROLL_ANGLE=45;
FLOOR.SCROLL_SPEED=12;

[52] // EDGE SCROLL FLOOR TEXTURE EAST
FLOOR.SCROLL_ANGLE=0;
FLOOR.SCROLL_SPEED=12;

[53] // EDGE SCROLL FLOOR TEXTURE SOUTH EAST
FLOOR.SCROLL_ANGLE=315;
FLOOR.SCROLL_SPEED=12;

[54] // EDGE SCROLL FLOOR TEXTURE SOUTH
FLOOR.SCROLL_ANGLE=270;
FLOOR.SCROLL_SPEED=12;

[55] // EDGE SCROLL FLOOR TEXTURE SOUTH WEST
FLOOR.SCROLL_ANGLE=225;
FLOOR.SCROLL_SPEED=12;

[56] // EDGE SCROLL FLOOR TEXTURE WEST
FLOOR.SCROLL_ANGLE=180;
FLOOR.SCROLL_SPEED=12;

[57] // EDGE SCROLL FLOOR TEXTURE NORTH WEST
FLOOR.SCROLL_ANGLE=135;
FLOOR.SCROLL_SPEED=12;

// EDGE SCROLL FLOOR TEXTURE/PUSH

[58] // EDGE SCROLL FLOOR TEXTURE/PUSH NORTH
FLOOR.SCROLL_ANGLE=90;
FLOOR.SCROLL_SPEED=12;
PUSH_ANGLE=90;
PUSH_SPEED=6;

[59] // EDGE SCROLL FLOOR TEXTURE/PUSH NORTH EAST
FLOOR.SCROLL_ANGLE=45;
FLOOR.SCROLL_SPEED=12;
PUSH_ANGLE=45;
PUSH_SPEED=6;

[60] // EDGE SCROLL FLOOR TEXTURE/PUSH EAST
FLOOR.SCROLL_ANGLE=0;
FLOOR.SCROLL_SPEED=12;
PUSH_ANGLE=0;
PUSH_SPEED=6;

[61] // EDGE SCROLL FLOOR TEXTURE/PUSH SOUTH EAST
FLOOR.SCROLL_ANGLE=315;
FLOOR.SCROLL_SPEED=12;
PUSH_ANGLE=315;
PUSH_SPEED=6;

[62] // EDGE SCROLL FLOOR TEXTURE/PUSH SOUTH
FLOOR.SCROLL_ANGLE=270;
FLOOR.SCROLL_SPEED=12;
PUSH_ANGLE=270;
PUSH_SPEED=6;

[63] // EDGE SCROLL FLOOR TEXTURE/PUSH SOUTH WEST
FLOOR.SCROLL_ANGLE=225;
FLOOR.SCROLL_SPEED=12;
PUSH_ANGLE=225;
PUSH_SPEED=6;

[64] // EDGE SCROLL FLOOR TEXTURE/PUSH WEST
FLOOR.SCROLL_ANGLE=180;
FLOOR.SCROLL_SPEED=12;
PUSH_ANGLE=180;
PUSH_SPEED=6;

[65] // EDGE SCROLL FLOOR TEXTURE/PUSH NORTH WEST
FLOOR.SCROLL_ANGLE=135;
FLOOR.SCROLL_SPEED=12;
PUSH_ANGLE=135;
PUSH_SPEED=6;

[66] // EDGE BLUE HUE (SWIMABLE WATER)
USE_COLOURMAP=WATER;
SPECIAL=SWIM,AIRLESS;
GRAVITY=0.5;
FRICTION=0.9;
DRAG=0.9;    

[67] // EDGE GREEN HUE
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;

[68] // EDGE GREEN HUE + DAMAGE
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=SLIME;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;

[69] // EDGE RED HUE
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;

[70] // EDGE RED HUE + DAMAGE
DAMAGE.VAL=10;
DAMAGE.DELAY=32T;
USE_COLOURMAP=LAVA;
SPECIAL=WHOLE_REGION;
FRICTION=0.80;</t>
<t tx="T2623">@ignore

//    EDGE SOUNDS.DDF -redefine or add new sound(s).

&lt;SOUNDS&gt;

[PISTOL]
LUMP_NAME="DSPISTOL";
PRIORITY=64;

[SHOTGN]
LUMP_NAME="DSSHOTGN";
SINGULAR=16;
PRIORITY=64;

[SGCOCK]
LUMP_NAME="DSSGCOCK";
PRIORITY=64;

[DSHTGN]
LUMP_NAME="DSDSHTGN";
PRIORITY=64;

[DBOPN]
LUMP_NAME="DSDBOPN";
PRIORITY=64;

[DBCLS]
LUMP_NAME="DSDBCLS";
PRIORITY=64;

[DBLOAD]
LUMP_NAME="DSDBLOAD";
PRIORITY=64;

[PLASMA]
LUMP_NAME="DSPLASMA";
PRIORITY=64;

[BFG]
LUMP_NAME="DSBFG";
PRIORITY=64;

[SAWUP]
LUMP_NAME="DSSAWUP";
PRIORITY=64;
SINGULAR=2;

[SAWIDL]
LUMP_NAME="DSSAWIDL";
PRIORITY=118;
SINGULAR=2;

[SAWFUL]
LUMP_NAME="DSSAWFUL";
PRIORITY=64;
SINGULAR=2;

[SAWHIT]
LUMP_NAME="DSSAWHIT";
PRIORITY=64;
SINGULAR=2;

[RLAUNC]
LUMP_NAME="DSRLAUNC";
PRIORITY=64;

[RXPLOD]
LUMP_NAME="DSRXPLOD";
PRIORITY=70;


[FIRSHT]
LUMP_NAME="DSFIRSHT";
PRIORITY=70;

[FIRXPL]
LUMP_NAME="DSFIRXPL";
PRIORITY=70;

[PSTART]
LUMP_NAME="DSPSTART";
PRIORITY=100;
SINGULAR=18;

[PSTOP]
LUMP_NAME="DSPSTOP";
PRIORITY=100;
SINGULAR=18;

[DOROPN]
LUMP_NAME="DSDOROPN";
PRIORITY=100;

[DORCLS]
LUMP_NAME="DSDORCLS";
PRIORITY=100;

[STNMOV]
LUMP_NAME="DSSTNMOV";
PRIORITY=119;
SINGULAR=18;
LOOP=TRUE;

[SWTCHN]
LUMP_NAME="DSSWTCHN";
PRIORITY=78;

[SWTCHX]
LUMP_NAME="DSSWTCHX";
PRIORITY=78;

[PLPAIN]
LUMP_NAME="DSPLPAIN";
PRIORITY=96;

[DMPAIN]
LUMP_NAME="DSDMPAIN";
PRIORITY=96;

[POPAIN]
LUMP_NAME="DSPOPAIN";
PRIORITY=96;

[VIPAIN]
LUMP_NAME="DSVIPAIN";
PRIORITY=96;

[MNPAIN]
LUMP_NAME="DSMNPAIN";
PRIORITY=96;

[PEPAIN]
LUMP_NAME="DSPEPAIN";
PRIORITY=96;

[SLOP]
LUMP_NAME="DSSLOP";
PRIORITY=78;

[ITEMUP]
LUMP_NAME="DSITEMUP";
PRIORITY=78;

[WPNUP]
LUMP_NAME="DSWPNUP";
PRIORITY=78;

[OOF]
LUMP_NAME="DSOOF";
PRIORITY=96;

[TELEPT]
LUMP_NAME="DSTELEPT";
PRIORITY=32;

[POSIT1]
LUMP_NAME="DSPOSIT1";
SINGULAR=3;
PRIORITY=98;

[POSIT2]
LUMP_NAME="DSPOSIT2";
SINGULAR=3;
PRIORITY=98;

[POSIT3]
LUMP_NAME="DSPOSIT3";
SINGULAR=3;
PRIORITY=98;

[POSACT]
LUMP_NAME="DSPOSACT";
SINGULAR=3;
PRIORITY=120;

[BGSIT1]
LUMP_NAME="DSBGSIT1";
SINGULAR=4;
PRIORITY=98;

[BGSIT2]
LUMP_NAME="DSBGSIT2";
SINGULAR=4;
PRIORITY=98;

[BGACT]
LUMP_NAME="DSBGACT";
SINGULAR=4;
PRIORITY=120;

[SGTSIT]
LUMP_NAME="DSSGTSIT";
SINGULAR=5;
PRIORITY=98;

[CACSIT]
LUMP_NAME="DSCACSIT";
SINGULAR=6;
PRIORITY=98;

[BRSSIT]
LUMP_NAME="DSBRSSIT";
SINGULAR=7;
PRIORITY=94;

[CYBSIT]
LUMP_NAME="DSCYBSIT";
SINGULAR=8;
PRIORITY=92;

[SPISIT]
LUMP_NAME="DSSPISIT";
SINGULAR=9;
PRIORITY=90;

[BSPSIT]
LUMP_NAME="DSBSPSIT";
SINGULAR=10;
PRIORITY=90;

[BSPACT]
LUMP_NAME="DSBSPACT";
SINGULAR=10;
PRIORITY=100;

[BSPWLK]
LUMP_NAME="DSBSPWLK";
SINGULAR=16;
PRIORITY=100;

[KNTSIT]
LUMP_NAME="DSKNTSIT";
SINGULAR=11;
PRIORITY=90;

[VILSIT]
LUMP_NAME="DSVILSIT";
SINGULAR=12;
PRIORITY=90;

[VILACT]
LUMP_NAME="DSVILACT";
SINGULAR=12;
PRIORITY=100;

[MANSIT]
LUMP_NAME="DSMANSIT";
SINGULAR=13;
PRIORITY=90;

[PESIT]
LUMP_NAME="DSPESIT";
SINGULAR=14;
PRIORITY=90;

[DMACT]
LUMP_NAME="DSDMACT";
SINGULAR=15;
PRIORITY=120;

[SKLATK]
LUMP_NAME="DSSKLATK";
PRIORITY=70;

[SGTATK]
LUMP_NAME="DSSGTATK";
PRIORITY=70;

[SKEPCH]
LUMP_NAME="DSSKEPCH";
PRIORITY=70;

[VILATK]
LUMP_NAME="DSVILATK";
PRIORITY=70;

[CLAW]
LUMP_NAME="DSCLAW";
PRIORITY=70;

[SKESWG]
LUMP_NAME="DSSKESWG";
PRIORITY=70;

[PLDETH]
LUMP_NAME="DSPLDETH";
PRIORITY=32;

[PDIEHI]
LUMP_NAME="DSPDIEHI";
PRIORITY=32;

[PODTH1]
LUMP_NAME="DSPODTH1";
PRIORITY=70;

[PODTH2]
LUMP_NAME="DSPODTH2";
PRIORITY=70;

[PODTH3]
LUMP_NAME="DSPODTH3";
PRIORITY=70;

[BGDTH1]
LUMP_NAME="DSBGDTH1";
PRIORITY=70;

[BGDTH2]
LUMP_NAME="DSBGDTH2";
PRIORITY=70;

[SGTDTH]
LUMP_NAME="DSSGTDTH";
PRIORITY=70;

[CACDTH]
LUMP_NAME="DSCACDTH";
PRIORITY=70;

[SKLDTH]
LUMP_NAME="DSSKLDTH";
PRIORITY=70;

[BRSDTH]
LUMP_NAME="DSBRSDTH";
PRIORITY=32;

[CYBDTH]
LUMP_NAME="DSCYBDTH";
PRIORITY=32;

[SPIDTH]
LUMP_NAME="DSSPIDTH";
PRIORITY=32;

[BSPDTH]
LUMP_NAME="DSBSPDTH";
PRIORITY=32;

[VILDTH]
LUMP_NAME="DSVILDTH";
PRIORITY=32;

[KNTDTH]
LUMP_NAME="DSKNTDTH";
PRIORITY=32;

[PEDTH]
LUMP_NAME="DSPEDTH";
PRIORITY=32;

[SKEDTH]
LUMP_NAME="DSSKEDTH";
PRIORITY=32;

[NOWAY]
LUMP_NAME="DSNOWAY";
PRIORITY=78;

[BAREXP]
LUMP_NAME="DSBAREXP";
PRIORITY=60;

[PUNCH]
LUMP_NAME="DSPUNCH";
PRIORITY=64;

[HOOF]
LUMP_NAME="DSHOOF";
PRIORITY=70;

[METAL]
LUMP_NAME="DSMETAL";
PRIORITY=70;

[CHGUN]
LUMP_NAME="DSPISTOL";
PRIORITY=60;

[TINK]
LUMP_NAME="DSTINK";
PRIORITY=60;

[BDOPN]
LUMP_NAME="DSBDOPN";
PRIORITY=100;

[BDCLS]
LUMP_NAME="DSBDCLS";
PRIORITY=100;

[ITMBK]
LUMP_NAME="DSITMBK";
PRIORITY=100;

[FLAME]
LUMP_NAME="DSFLAME";
PRIORITY=32;

[FLAMST]
LUMP_NAME="DSFLAMST";
PRIORITY=32;

[GETPOW]
LUMP_NAME="DSGETPOW";
PRIORITY=60;

[BOSPIT]
LUMP_NAME="DSBOSPIT";
PRIORITY=70;

[BOSCUB]
LUMP_NAME="DSBOSCUB";
PRIORITY=70;

[BOSSIT]
LUMP_NAME="DSBOSSIT";
PRIORITY=70;

[BOSPN]
LUMP_NAME="DSBOSPN";
PRIORITY=70;

[BOSDTH]
LUMP_NAME="DSBOSDTH";
PRIORITY=70;

[MANATK]
LUMP_NAME="DSMANATK";
PRIORITY=70;

[MANDTH]
LUMP_NAME="DSMANDTH";
PRIORITY=70;

[SSSIT]
LUMP_NAME="DSSSSIT";
PRIORITY=70;

[SSDTH]
LUMP_NAME="DSSSDTH";
PRIORITY=70;

[KEENPN]
LUMP_NAME="DSKEENPN";
PRIORITY=70;

[KEENDT]
LUMP_NAME="DSKEENDT";
PRIORITY=70;

[SKEACT]
LUMP_NAME="DSSKEACT";
PRIORITY=70;

[SKESIT]
LUMP_NAME="DSSKESIT";
PRIORITY=70;

[SKEATK]
LUMP_NAME="DSSKEATK";
PRIORITY=70;

[RADIO]
LUMP_NAME="DSRADIO";
PRIORITY=60;

[JPRISE]
LUMP_NAME="DSJPRISE";
SINGULAR=17;
PRIORITY=64;

[JPMOVE]
LUMP_NAME="DSJPMOVE";
SINGULAR=17;
PRIORITY=64;

[JPIDLE]
LUMP_NAME="DSJPIDLE";
SINGULAR=17;
PRIORITY=64;

[JPDOWN]
LUMP_NAME="DSJPDOWN";
SINGULAR=17;
PRIORITY=64;

[JPFLOW]
LUMP_NAME="DSJPFLOW";
SINGULAR=17;
PRIORITY=64;

// Marine's Best Friend

[DOG_SIGHT]
LUMP_NAME="DSDGSIT";
SINGULAR=888;
PRIORITY=98;

[DOG_LOOK]
LUMP_NAME="DSDGACT";
SINGULAR=888;
PRIORITY=120;

[DOG_BITE]
LUMP_NAME="DSDGATK";
PRIORITY=70;

[DOG_PAIN]
LUMP_NAME="DSDGPAIN";
PRIORITY=96;

[DOG_DIE]
LUMP_NAME="DSDGDTH";
PRIORITY=70;

[CRUSH] // called for gib states
LUMP_NAME="DSCRUSH";
PRIORITY=100;
</t>
<t tx="T2624">@ignore

//    EDGE SWITCH.DDF -redefine or add new switch textures and sounds.

&lt;SWITCHES&gt;

[SW1BRCOM]
ON_TEXTURE ="SW1BRCOM";
OFF_TEXTURE="SW2BRCOM";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1BRN1]
ON_TEXTURE ="SW1BRN1";
OFF_TEXTURE="SW2BRN1";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1BRN2]
ON_TEXTURE ="SW1BRN2";
OFF_TEXTURE="SW2BRN2";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1BRNGN]
ON_TEXTURE ="SW1BRNGN";
OFF_TEXTURE="SW2BRNGN";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1BROWN]
ON_TEXTURE ="SW1BROWN";
OFF_TEXTURE="SW2BROWN";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1COMM]
ON_TEXTURE ="SW1COMM";
OFF_TEXTURE="SW2COMM";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1COMP]
ON_TEXTURE ="SW1COMP";
OFF_TEXTURE="SW2COMP";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1DIRT]
ON_TEXTURE ="SW1DIRT";
OFF_TEXTURE="SW2DIRT";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1EXIT]
ON_TEXTURE ="SW1EXIT";
OFF_TEXTURE="SW2EXIT";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1GRAY]
ON_TEXTURE ="SW1GRAY";
OFF_TEXTURE="SW2GRAY";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1GRAY1]
ON_TEXTURE ="SW1GRAY1";
OFF_TEXTURE="SW2GRAY1";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1METAL]
ON_TEXTURE ="SW1METAL";
OFF_TEXTURE="SW2METAL";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1PIPE]
ON_TEXTURE ="SW1PIPE";
OFF_TEXTURE="SW2PIPE";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1SLAD]
ON_TEXTURE ="SW1SLAD";
OFF_TEXTURE="SW2SLAD";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1STARG]
ON_TEXTURE ="SW1STARG";
OFF_TEXTURE="SW2STARG";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1STON1]
ON_TEXTURE ="SW1STON1";
OFF_TEXTURE="SW2STON1";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1STON2]
ON_TEXTURE ="SW1STON2";
OFF_TEXTURE="SW2STON2";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1STONE]
ON_TEXTURE ="SW1STONE";
OFF_TEXTURE="SW2STONE";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1STRTN]
ON_TEXTURE ="SW1STRTN";
OFF_TEXTURE="SW2STRTN";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1BLUE]
ON_TEXTURE ="SW1BLUE";
OFF_TEXTURE="SW2BLUE";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1CMT]
ON_TEXTURE ="SW1CMT";
OFF_TEXTURE="SW2CMT";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1GARG]
ON_TEXTURE ="SW1GARG";
OFF_TEXTURE="SW2GARG";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1GSTON]
ON_TEXTURE ="SW1GSTON";
OFF_TEXTURE="SW2GSTON";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1HOT]
ON_TEXTURE ="SW1HOT";
OFF_TEXTURE="SW2HOT";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1LION]
ON_TEXTURE ="SW1LION";
OFF_TEXTURE="SW2LION";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1SATYR]
ON_TEXTURE ="SW1SATYR";
OFF_TEXTURE="SW2SATYR";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1SKIN]
ON_TEXTURE ="SW1SKIN";
OFF_TEXTURE="SW2SKIN";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1VINE]
ON_TEXTURE ="SW1VINE";
OFF_TEXTURE="SW2VINE";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1WOOD]
ON_TEXTURE ="SW1WOOD";
OFF_TEXTURE="SW2WOOD";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1PANEL]
ON_TEXTURE ="SW1PANEL";
OFF_TEXTURE="SW2PANEL";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1ROCK]
ON_TEXTURE ="SW1ROCK";
OFF_TEXTURE="SW2ROCK";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1MET2]
ON_TEXTURE ="SW1MET2";
OFF_TEXTURE="SW2MET2";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1WDMET]
ON_TEXTURE ="SW1WDMET";
OFF_TEXTURE="SW2WDMET";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1BRIK]
ON_TEXTURE ="SW1BRIK";
OFF_TEXTURE="SW2BRIK";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1MOD1]
ON_TEXTURE ="SW1MOD1";
OFF_TEXTURE="SW2MOD1";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1ZIM]
ON_TEXTURE ="SW1ZIM";
OFF_TEXTURE="SW2ZIM";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1STON6]
ON_TEXTURE ="SW1STON6";
OFF_TEXTURE="SW2STON6";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1TEK]
ON_TEXTURE ="SW1TEK";
OFF_TEXTURE="SW2TEK";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1MARB]
ON_TEXTURE ="SW1MARB";
OFF_TEXTURE="SW2MARB";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";

[SW1SKULL]
ON_TEXTURE ="SW1SKULL";
OFF_TEXTURE="SW2SKULL";
ON_SOUND="SWTCHN";
OFF_SOUND="SWTCHN";</t>
<t tx="T2625">@ignore

//    EDGE THINGS.DDF -redefine or add new thing entrie(s).

&lt;THINGS&gt;</t>
<t tx="T2626">@ignore

//    EDGE WEAPONS.DDF -redefine or add new weapons.

&lt;WEAPONS&gt;

@others</t>
<t tx="T2627">@ignore

//    EDGE ANIMS.DDF -redefine or add new animated wall textures, or ceiling/floor textures.

&lt;ANIMATIONS&gt;

// ------ Flat Animations ------------------

[NUKAGE1]
TYPE =FLAT;
FIRST="NUKAGE1";
LAST ="NUKAGE3";
SPEED=8T;

[FWATER1]
TYPE =FLAT;
FIRST="FWATER1";
LAST ="FWATER4";
SPEED=8T;

[SWATER1]
TYPE =FLAT;
FIRST="SWATER1";
LAST ="SWATER4";
SPEED=8T;

[LAVA1]
TYPE =FLAT;
FIRST="LAVA1";
LAST ="LAVA4";
SPEED=8T;

[BLOOD1]
TYPE =FLAT;
FIRST="BLOOD1";
LAST ="BLOOD3";
SPEED=8T;

[RROCK05]
TYPE =FLAT;
FIRST="RROCK05";
LAST ="RROCK08";
SPEED=8T;

[SLIME01]
TYPE =FLAT;
FIRST="SLIME01";
LAST ="SLIME04";
SPEED=8T;

[SLIME05]
TYPE =FLAT;
FIRST="SLIME05";
LAST ="SLIME08";
SPEED=8T;

[SLIME09]
TYPE =FLAT;
FIRST="SLIME09";
LAST ="SLIME12";
SPEED=8T;

// ------ Texture Animations ------------------

[BLODGR1]
TYPE =TEXTURE;
FIRST="BLODGR1";
LAST ="BLODGR4";
SPEED=8T;

[SLADRIP1]
TYPE =TEXTURE;
FIRST="SLADRIP1";
LAST ="SLADRIP3";
SPEED=8T;

[BLODRIP1]
TYPE =TEXTURE;
FIRST="BLODRIP1";
LAST ="BLODRIP4";
SPEED=8T;

[FIREWALA]
TYPE =TEXTURE;
FIRST="FIREWALA";
LAST ="FIREWALL";
SPEED=8T;

[GSTFONT1]
TYPE =TEXTURE;
FIRST="GSTFONT1";
LAST ="GSTFONT3";
SPEED=8T;

[FIRELAV3]
TYPE =TEXTURE;
FIRST="FIRELAV3";
LAST ="FIRELAVA";
SPEED=8T;

[FIREMAG1]
TYPE =TEXTURE;
FIRST="FIREMAG1";
LAST ="FIREMAG3";
SPEED=8T;

[FIREBLU1]
TYPE =TEXTURE;
FIRST="FIREBLU1";
LAST ="FIREBLU2";
SPEED=8T;

[ROCKRED1]
TYPE =TEXTURE;
FIRST="ROCKRED1";
LAST ="ROCKRED3";
SPEED=8T;

[BFALL1]
TYPE =TEXTURE;
FIRST="BFALL1";
LAST ="BFALL4";
SPEED=8T;

[SFALL1]
TYPE =TEXTURE;
FIRST="SFALL1";
LAST ="SFALL4";
SPEED=8T;

[WFALL1]
TYPE =TEXTURE;
FIRST="WFALL1";
LAST ="WFALL4";
SPEED=8T;

[DBRAIN1]
TYPE =TEXTURE;
FIRST="DBRAIN1";
LAST ="DBRAIN4";
SPEED=8T;</t>
<t tx="T2628">@ignore

//    EDGE ATTACKS.DDF -redefine or add new attacks.

&lt;ATTACKS&gt;

@others
</t>
<t tx="T2629">@ignore

//    EDGE COLMAP.DDF -redefine or add new color maps.

&lt;COLOURMAPS&gt;

[NORMAL]
LUMP="COLORMAP";
START=0;
LENGTH=32;

[SKY]
LUMP="COLORMAP";
START=0;
LENGTH=1;

[FUZZY]
LUMP="COLORMAP";
START=7;
LENGTH=1;

[SHADOW]
LUMP="SHADEMAP";
START=0;
LENGTH=1;

[DIMSCREEN]  // Note: only affects 8 bit mode
LUMP="COLORMAP";
START=16;
LENGTH=1;

// For the invulnerability effect
[ALLWHITE]
LUMP="COLORMAP";
START=32;
LENGTH=1;

// For the infrared-goggles effect
[ALLBRIGHT]
LUMP="COLORMAP";
START=1;
LENGTH=1;

// For the EDGE night-vision effect
[ALLGREEN]
LUMP="NITEVMAP";
START=0;
LENGTH=1;

[FOG]
LUMP="FOGMAP";
START=0;
LENGTH=32;
SPECIAL=NO_FLASH;

[WATER] // BLUE WATER HUE
LUMP="WATERMAP";
START=0;
LENGTH=32;
SPECIAL=NO_FLASH;

[SLIME] // GREEN WATER HUE
LUMP="SLIMEMAP";
START=0;
LENGTH=32;
SPECIAL=NO_FLASH;

[LAVA] // RED WATER HUE
LUMP="LAVAMAP";
START=0;
LENGTH=32;
SPECIAL=NO_FLASH;

// ----- Text Colour remaps ---------------

[TEXT_RED]
LUMP="TXTREDS";
START=1;
LENGTH=1;

[TEXT_WHITE]
LUMP="TXTGREYS";
START=1;
LENGTH=1;

[TEXT_GREY]
LUMP="TXTGREYS";
START=4;
LENGTH=1;

[TEXT_GREEN]
LUMP="TXTGRNS";
START=1;
LENGTH=1;

[TEXT_LT_BLUE]
LUMP="TEXTMAPS";
START=4;
LENGTH=1;

[TEXT_BLUE]
LUMP="TXTBLUES";
START=1;
LENGTH=1;

[TEXT_YELLOW]
LUMP="TXTYLWS2";
START=1;
LENGTH=1;

[TEXT_ORANGE]
LUMP="TXTORANS";
START=1;
LENGTH=1;

[TEXT_BROWN]
LUMP="TXTBRNS1";
START=2;
LENGTH=1;

[TEXT_BEIGE]
LUMP="TXTBRNS2";
START=2;
LENGTH=1;

[TEXT_PINK]
LUMP="TXTPNKS1";
START=2;
LENGTH=1;

[TEXT_PURPLE]
LUMP="TXTPURPS";
START=2;
LENGTH=1;

// ----- Player Colour Remaps ---------------

[PLAYER_GREEN]
LUMP="COLORMAP";
START=0;
LENGTH=1;

[PLAYER_GREY] 
LUMP="PLYRMAPS"; 
START=14; 
LENGTH=1;

[PLAYER_LT_GREY] 
LUMP="PLYRMAPS"; 
START=4; 
LENGTH=1;

[PLAYER_DK_GREY] 
LUMP="PLYRMAPS"; 
START=0; 
LENGTH=1;

[PLAYER_BROWN] 
LUMP="PLYRMAPS"; 
START=1; 
LENGTH=1;

[PLAYER_DULL_RED] 
LUMP="PLYRMAPS"; 
START=2; 
LENGTH=1;

[PLAYER_LT_RED] 
LUMP="PLYRMAPS"; 
START=5; 
LENGTH=1;

[PLAYER_DK_RED] 
LUMP="PLYRMAPS"; 
START=11; 
LENGTH=1;

[PLAYER_ORANGE] 
LUMP="PLYRMAPS"; 
START=3; 
LENGTH=1;

[PLAYER_PINK] 
LUMP="PLYRMAPS"; 
START=6; 
LENGTH=1;

[PLAYER_GOLD] 
LUMP="PLYRMAPS"; 
START=7; 
LENGTH=1;

[PLAYER_BLUE] 
LUMP="PLYRMAPS"; 
START=8; 
LENGTH=1;

[PLAYER_DK_BLUE] 
LUMP="PLYRMAPS"; 
START=9; 
LENGTH=1;

[PLAYER_DK_GREEN] 
LUMP="PLYRMAPS"; 
START=10; 
LENGTH=1;

[PLAYER_RED_SKIN] 
LUMP="PLYRMAPS"; 
START=12; 
LENGTH=1;

[PLAYER_PALE_SKIN] 
LUMP="PLYRMAPS"; 
START=13; 
LENGTH=1;

// ----- Monster Skin Remaps ---------------

[SKIN_PALE] 
LUMP="SKINMAPS"; 
START=0; 
LENGTH=1;

[SKIN_GREY] 
LUMP="SKINMAPS"; 
START=1; 
LENGTH=1;

[SKIN_BLUE] 
LUMP="SKINMAPS"; 
START=2; 
LENGTH=1;

[SKIN_GREEN] 
LUMP="SKINMAPS"; 
START=3; 
LENGTH=1;

[SKIN_LT_RED] 
LUMP="SKINMAPS"; 
START=4; 
LENGTH=1;

[FONTWHITEN]
LUMP="FNWHTMAP";
START=0;
LENGTH=1;

[AUTOMAP_NORMAL]
LUMP="AUTOMAPS";
START=0;
LENGTH=1;

[AUTOMAP_OVERLAY]
LUMP="AUTOMAPS";
START=1;
LENGTH=1;</t>
<t tx="T2630">@ignore

//    EDGE GAMES.DDF -redefine game/mission information(s).

&lt;GAMES&gt;

[EDGE]
TITLE_GRAPHIC="EDGETTL","CREDIT2";
TITLE_TIME=320T;
TITLE_MUSIC=66;

@others</t>
<t tx="T2631">@ignore

//    EDGE LEVELS.DDF -redefine or add new level information(s).

&lt;LEVELS&gt;

@others</t>
<t tx="T2632">[ARACHNOTRON_PLASMA]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=13;
DAMAGE.VAL=5;
DAMAGE.MAX=40;
ATTACK_HEIGHT=16;
SPEED=25;
KEEP_FIRING_CHANCE=3.92%;
LAUNCH_SOUND=PLASMA;
ATTACK_SPECIAL=FACE_TARGET;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY,NOSHADOW;
TRANSLUCENCY=45%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=200;
DLIGHT.COLOUR=#C0FF00;

STATES(IDLE)=APLS:A:5:BRIGHT:NOTHING,
             APLS:B:5:BRIGHT:NOTHING;

STATES(DEATH)=APBX:A:0:BRIGHT:DLIGHT_SET(500),
              APBX:A:0:BRIGHT:DLIGHT_FADE(0),
              APBX:A:5:BRIGHT:KILLSOUND,
              APBX:A:5:BRIGHT:PLAYSOUND(FIRXPL),
              APBX:A:5:BRIGHT:TRANS_FADE(0%),
              APBX:B:5:BRIGHT:NOTHING,
              APBX:C:5:BRIGHT:NOTHING,
              APBX:D:5:BRIGHT:NOTHING,
              APBX:E:5:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2633">[ARCHVILE_FIRE]
ATTACKTYPE=TRACKER;
RADIUS=20;
HEIGHT=16;
DAMAGE.VAL=20;
EXPLODE_DAMAGE.VAL=70;
ATTEMPT_SOUND=VILATK;
ENGAGED_SOUND=BAREXP;
ATTACK_SPECIAL=NEED_SIGHT,FACE_TARGET;
TRANSLUCENCY=80%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=400;
DLIGHT.COLOUR=#FFFF40;

STATES(SPAWN)=FIRE:A:2:BRIGHT:DLIGHT_FADE(0),
              FIRE:A:2:BRIGHT:TRANS_FADE(0%),
              FIRE:A:2:BRIGHT:TRACKERSTART,
              FIRE:B:2:BRIGHT:TRACKERFOLLOW,
              FIRE:A:2:BRIGHT:TRACKERFOLLOW,
              FIRE:B:2:BRIGHT:TRACKERFOLLOW,
              FIRE:C:2:BRIGHT:TRACKERACTIVE,
              FIRE:B:2:BRIGHT:TRACKERFOLLOW,
              FIRE:C:2:BRIGHT:TRACKERFOLLOW,
              FIRE:B:2:BRIGHT:TRACKERFOLLOW,
              FIRE:C:2:BRIGHT:TRACKERFOLLOW,
              FIRE:D:2:BRIGHT:TRACKERFOLLOW,
              FIRE:C:2:BRIGHT:TRACKERFOLLOW,
              FIRE:D:2:BRIGHT:TRACKERFOLLOW,
              FIRE:C:2:BRIGHT:TRACKERFOLLOW,
              FIRE:D:2:BRIGHT:TRACKERFOLLOW,
              FIRE:E:2:BRIGHT:TRACKERFOLLOW,
              FIRE:D:2:BRIGHT:TRACKERFOLLOW,
              FIRE:E:2:BRIGHT:TRACKERFOLLOW,
              FIRE:D:2:BRIGHT:TRACKERFOLLOW,
              FIRE:E:2:BRIGHT:TRACKERACTIVE,
              FIRE:F:2:BRIGHT:TRACKERFOLLOW,
              FIRE:E:2:BRIGHT:TRACKERFOLLOW,
              FIRE:F:2:BRIGHT:TRACKERFOLLOW,
              FIRE:E:2:BRIGHT:TRACKERFOLLOW,
              FIRE:F:2:BRIGHT:TRACKERFOLLOW,
              FIRE:G:2:BRIGHT:TRACKERFOLLOW,
              FIRE:H:2:BRIGHT:TRACKERFOLLOW,
              FIRE:G:2:BRIGHT:TRACKERFOLLOW,
              FIRE:H:2:BRIGHT:TRACKERFOLLOW,
              #REMOVE;</t>
<t tx="T2634">[BARON_CLOSECOMBAT]
ATTACKTYPE=CLOSECOMBAT;
DAMAGE.VAL=10;
DAMAGE.MAX=80;
ENGAGED_SOUND=CLAW;
ATTACKRANGE=64;
ATTACK_SPECIAL=NEED_SIGHT,FACE_TARGET;</t>
<t tx="T2635">[BARON_FIREBALL]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=6;
DAMAGE.VAL=8;
DAMAGE.MAX=64;
ATTACK_HEIGHT=32;
SPEED=15;
FAST=1.33333;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY;
LAUNCH_SOUND=FIRSHT;
ATTACK_SPECIAL=FACE_TARGET;
TRANSLUCENCY=65%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=400;
DLIGHT.COLOUR=#FF0000;

STATES(IDLE)=BAL7:A:4:BRIGHT:NOTHING,
             BAL7:B:4:BRIGHT:NOTHING;

STATES(DEATH)=BAL7:C:0:BRIGHT:DLIGHT_SET(800),
              BAL7:C:0:BRIGHT:DLIGHT_FADE(0),
              BAL7:C:0:BRIGHT:TRANS_FADE(0%),
              BAL7:C:0:BRIGHT:KILLSOUND,
              BAL7:C:7:BRIGHT:PLAYSOUND(FIRXPL),
              BAL7:D:7:BRIGHT:NOTHING,
              BAL7:E:7:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2636">[IMP_FIREBALL]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=6;
DAMAGE.VAL=3;
DAMAGE.MAX=24;
ATTACK_HEIGHT=32;
SPEED=10;
FAST=2;
ATTACK_SPECIAL=FACE_TARGET;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY;
LAUNCH_SOUND=FIRSHT;
TRANSLUCENCY=65%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FF0000;

STATES(IDLE)=BAL1:A:4:BRIGHT:NOTHING,
             BAL1:B:4:BRIGHT:NOTHING;

STATES(DEATH)=BAL1:C:0:BRIGHT:DLIGHT_SET(400),
              BAL1:C:0:BRIGHT:DLIGHT_FADE(0),
              BAL1:C:0:BRIGHT:TRANS_FADE(0%),
              BAL1:C:0:BRIGHT:KILLSOUND,
              BAL1:C:6:BRIGHT:PLAYSOUND(FIRXPL),
              BAL1:D:6:BRIGHT:NOTHING,
              BAL1:E:6:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2637">[MANCUBUS_FIREBALL]
ATTACKTYPE=FIXED_SPREADER;
HEIGHT=8;
RADIUS=6;
DAMAGE.VAL=8;
DAMAGE.MAX=64;
ATTACK_HEIGHT=32;
SPEED=20;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY,NOSHADOW;
ATTEMPT_SOUND=MANATK;
LAUNCH_SOUND=FIRSHT;
DEATH_SOUND=FIRXPL;
TRANSLUCENCY=80%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=500;
DLIGHT.COLOUR=#FF0000;

STATES(IDLE)=MANF:A:4:BRIGHT:NOTHING,
             MANF:B:4:BRIGHT:NOTHING;

STATES(DEATH)=MISL:B:0:BRIGHT:DLIGHT_SET(800),
              MISL:B:0:BRIGHT:DLIGHT_FADE(0),
              MISL:B:0:BRIGHT:TRANS_FADE(0%),
              MISL:B:0:BRIGHT:KILLSOUND,
              MISL:B:8:BRIGHT:PLAYSOUND(FIRXPL),
              MISL:C:6:BRIGHT:NOTHING,
              MISL:D:4:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2638">[PLAYER_MISSILE]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=11;
SPEED=20;
DAMAGE.VAL=20;
DAMAGE.MAX=160;
ATTACKRANGE=1024;
ATTACK_SPECIAL=KILL_FAILED_SPAWN;
PROJECTILE_SPECIAL=NOBLOCKMAP,DROPOFF,NOGRAVITY,MISSILE,NOSHADOW;
ATTACK_HEIGHT=32;
EXPLODE_DAMAGE.VAL=128;
LAUNCH_SOUND=RLAUNC;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FFFF00;

STATES(IDLE)=MISL:A:1:BRIGHT:NOTHING;

STATES(DEATH)=MISL:B:0:BRIGHT:DLIGHT_SET(1000),
              MISL:B:0:BRIGHT:DLIGHT_FADE(0),
              MISL:B:0:BRIGHT:TRANS_FADE(0%),
              MISL:B:0:BRIGHT:KILLSOUND,
              MISL:B:0:BRIGHT:PLAYSOUND(BAREXP),
              MISL:B:8:BRIGHT:EXPLOSIONDAMAGE,
              MISL:C:6:BRIGHT:NOTHING,
              MISL:D:4:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2639">[CYBERDEMON_MISSILE]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=11;
DAMAGE.VAL=20;
DAMAGE.MAX=160;
ACCURACY_ANGLE=0;
ACCURACY_SLOPE=0;
ATTACK_HEIGHT=44;
X_OFFSET=20;
SPEED=20;
EXPLODE_DAMAGE.VAL=128;
ATTACK_SPECIAL=FACE_TARGET;
PROJECTILE_SPECIAL=NOBLOCKMAP,DROPOFF,NOGRAVITY,MISSILE,NOSHADOW;
LAUNCH_SOUND=RLAUNC;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FFFF00;

STATES(IDLE)=MISL:A:1:BRIGHT:NOTHING;

STATES(DEATH)=MISL:B:0:BRIGHT:DLIGHT_SET(1000),
              MISL:B:0:BRIGHT:DLIGHT_FADE(0),
              MISL:B:0:BRIGHT:TRANS_FADE(0%),
              MISL:B:0:BRIGHT:KILLSOUND,
              MISL:B:0:BRIGHT:PLAYSOUND(BAREXP),
              MISL:B:8:BRIGHT:EXPLOSIONDAMAGE,
              MISL:C:6:BRIGHT:NOTHING,
              MISL:D:4:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2640">[TRACER_MISSILE_L]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=11;
DAMAGE.VAL=10;
DAMAGE.MAX=80;
ATTACK_HEIGHT=50;
X_OFFSET=-16;
SPEED=10;
NO_TRACE_CHANCE=1.56%;
TOO_CLOSE_RANGE=196;
ATTACK_SPECIAL=SMOKING_TRACER;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY;
LAUNCH_SOUND=SKEATK;
DEATH_SOUND=BAREXP;
PUFF=PUFF;

STATES(IDLE)=FATB:A:2:BRIGHT:TRACER,
             FATB:B:2:BRIGHT:TRACER;

STATES(DEATH)=FBXP:A:8:BRIGHT:TRANS_FADE(10%),
              FBXP:B:6:BRIGHT:NOTHING,
              FBXP:C:4:BRIGHT:NOTHING,
              #REMOVE;

[TRACER_MISSILE_R]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=11;
DAMAGE.VAL=10;
DAMAGE.MAX=80;
X_OFFSET=16;
ATTACK_HEIGHT=50;
SPEED=10;
NO_TRACE_CHANCE=1.56%;
TOO_CLOSE_RANGE=196;
ATTACK_SPECIAL=SMOKING_TRACER;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY;
LAUNCH_SOUND=SKEATK;
DEATH_SOUND=BAREXP;
PUFF=PUFF;

STATES(IDLE)=FATB:A:2:BRIGHT:TRACER,
             FATB:B:2:BRIGHT:TRACER;

STATES(DEATH)=FBXP:A:8:BRIGHT:TRANS_FADE(10%),
              FBXP:B:6:BRIGHT:NOTHING,
              FBXP:C:4:BRIGHT:NOTHING,
              #REMOVE;

[IMP_SPAWNER]
ATTACKTYPE=SPAWNER;
ATTACK_HEIGHT=0;
SPAWNED_OBJECT=IMP;
SPAWN_OBJECT_STATE=CHASE:1;
ENGAGED_SOUND=TELEPT;

[MANCUBUS_FIREBALL_L]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=6;
DAMAGE.VAL=8;
DAMAGE.MAX=64;
ATTACK_HEIGHT=24;
X_OFFSET=-24;
SPEED=20;
ACCURACY_ANGLE=17;
ACCURACY_SLOPE=9;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY;
ATTEMPT_SOUND=MANATK;
LAUNCH_SOUND=FIRSHT;
TRANSLUCENCY=80%;

STATES(IDLE)=MANF:A:4:BRIGHT:NOTHING,
             MANF:B:4:BRIGHT:NOTHING;

STATES(DEATH)=MISL:B:0:BRIGHT:TRANS_FADE(10%),
              MISL:B:0:BRIGHT:KILLSOUND,
              MISL:B:8:BRIGHT:PLAYSOUND(FIRXPL),
              MISL:C:6:BRIGHT:NOTHING,
              MISL:D:4:BRIGHT:NOTHING,
              #REMOVE;

[MANCUBUS_FIREBALL_R]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=6;
DAMAGE.VAL=8;
DAMAGE.MAX=64;
ATTACK_HEIGHT=24;
X_OFFSET=24;
SPEED=20;
ACCURACY_ANGLE=17;
ACCURACY_SLOPE=9;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY;
ATTEMPT_SOUND=MANATK;
LAUNCH_SOUND=FIRSHT;
TRANSLUCENCY=80%;

STATES(IDLE)=MANF:A:4:BRIGHT:NOTHING,
             MANF:B:4:BRIGHT:NOTHING;

STATES(DEATH)=MISL:B:0:BRIGHT:TRANS_FADE(10%),
              MISL:B:0:BRIGHT:KILLSOUND,
              MISL:B:8:BRIGHT:PLAYSOUND(FIRXPL),
              MISL:C:6:BRIGHT:NOTHING,
              MISL:D:4:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2641">// ------ BOSSBRAIN STUFF ---------

[BRAIN_CUBE]
ATTACKTYPE=SHOOTTOSPOT;
RADIUS=6;
HEIGHT=8;
SPAWNHEALTH=1000;
DAMAGE.VAL=8;
DAMAGE.MAX=64;
ATTACK_HEIGHT=16;
SPEED=9;
MASS=100;
REACTIONTIME=8T;
PROJECTILE_SPECIAL=NOBLOCKMAP,NOCLIP,MISSILE,DROPOFF,NOGRAVITY,BOSSMAN;
LAUNCH_SOUND=BOSPIT;
ACTIVE_SOUND=BOSCUB;
DEATH_SOUND=TELEPT;  // FIRXPL
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=0;
DLIGHT.COLOUR=#FFFF40;

STATES(IDLE)=BOSF:A:3:BRIGHT:CUBETRACER,
             BOSF:B:3:BRIGHT:NOTHING,
             BOSF:C:3:BRIGHT:CUBETRACER,
             BOSF:D:3:BRIGHT:MAKEACTIVESOUND;

STATES(DEATH)=FIRE:A:0:BRIGHT:DLIGHT_SET(1000),
              FIRE:A:0:BRIGHT:DLIGHT_FADE(0),
              FIRE:A:4:BRIGHT:TRANS_FADE(10%),
              FIRE:B:4:BRIGHT:NOTHING,
              FIRE:C:4:BRIGHT:NOTHING,
              FIRE:D:4:BRIGHT:NOTHING,
              FIRE:E:4:BRIGHT:NOTHING,
              FIRE:F:4:BRIGHT:NOTHING,
              FIRE:G:4:BRIGHT:NOTHING,
              FIRE:H:4:BRIGHT:CUBESPAWN,
              #REMOVE;</t>
<t tx="T2642">[CHAINSAW]
AMMOTYPE=NOAMMO;
AUTOMATIC=TRUE;
BINDKEY=1;
PRIORITY=1;
ATTACK=PLAYER_SAW;
NOTHRUST=TRUE;
START_SOUND=SAWUP;
IDLE_SOUND=SAWIDL;
ENGAGED_SOUND=SAWFUL;
FEEDBACK=TRUE;
STATES(UP)=SAWG:C:1:NORMAL:RAISE;
STATES(DOWN)=SAWG:C:1:NORMAL:LOWER;
STATES(READY)=SAWG:C:4:NORMAL:READY,
              SAWG:D:4:NORMAL:READY;
STATES(ATTACK)=SAWG:A:4:NORMAL:SHOOT,
               SAWG:B:4:NORMAL:SHOOT,
               SAWG:B:0:NORMAL:REFIRE;</t>
<t tx="T2643">[FIST]
AMMOTYPE=NOAMMO;
AUTOMATIC=TRUE;
FREE=TRUE;
BINDKEY=1;
PRIORITY=0;
SPECIAL=SILENT_TO_MONSTERS;
ATTACK=PLAYER_PUNCH;
STATES(UP)=PUNG:A:1:NORMAL:RAISE;
STATES(DOWN)=PUNG:A:1:NORMAL:LOWER;
STATES(READY)=PUNG:A:1:NORMAL:READY;
STATES(ATTACK)=PUNG:B:4:NORMAL:NOTHING,
               PUNG:C:4:NORMAL:SHOOT,
               PUNG:D:5:NORMAL:NOTHING,
               PUNG:C:4:NORMAL:NOTHING,
               PUNG:B:5:NORMAL:REFIRE;</t>
<t tx="T2644">[PISTOL]
AMMOTYPE=BULLETS;
AMMOPERSHOT=1;
AUTOMATIC=TRUE;
REFIRE_INACCURATE=TRUE;
BINDKEY=2;
PRIORITY=2;
FREE=TRUE;
ATTACK=PLAYER_PISTOL;
KICK=0.002;
STATES(UP)=PISG:A:1:NORMAL:RAISE;
STATES(DOWN)=PISG:A:1:NORMAL:LOWER;
STATES(READY)=PISG:A:1:NORMAL:READY;
STATES(ATTACK)=PISG:A:4:NORMAL:NOTHING,
               PISG:B:6:NORMAL:SHOOT,
               PISG:C:4:NORMAL:NOTHING,
               PISG:B:5:NORMAL:REFIRE;
STATES(FLASH)=PISF:A:0:BRIGHT:TRANS_SET(50%),
              PISF:A:7:BRIGHT:LIGHT1,
              PISF:A:0:NORMAL:LIGHT0,
              #REMOVE;</t>
<t tx="T2645">[SUPERSHOTGUN]
AMMOTYPE=SHELLS;
AMMOPERSHOT=2;
AUTOMATIC=TRUE;
BINDKEY=3;
PRIORITY=4;
ATTACK=PLAYER_SHOTGUN2;
KICK=0.1;
STATES(UP)=SHT2:A:1:NORMAL:RAISE;
STATES(DOWN)=SHT2:A:1:NORMAL:LOWER;
STATES(READY)=SHT2:A:1:NORMAL:READY;
STATES(ATTACK)=SHT2:A:3:NORMAL:NOTHING,
               SHT2:A:7:NORMAL:SHOOT,
               SHT2:B:7:NORMAL:NOTHING,
               SHT2:C:7:NORMAL:NOTHING,
               SHT2:C:0:NORMAL:CHECKRELOAD;
STATES(RELOAD)=SHT2:D:7:NORMAL:PLAYSOUND(DBOPN),
               SHT2:E:7:NORMAL:NOTHING,
               SHT2:F:7:NORMAL:PLAYSOUND(DBLOAD),
               SHT2:G:6:NORMAL:NOTHING,
               SHT2:H:6:NORMAL:PLAYSOUND(DBCLS),
               SHT2:A:5:NORMAL:REFIRE;
STATES(FLASH)=SHT2:I:0:BRIGHT:TRANS_SET(50%),
              SHT2:I:5:BRIGHT:LIGHT1,
              SHT2:J:4:BRIGHT:LIGHT2,
              SHT2:J:0:NORMAL:LIGHT0,
              #REMOVE;</t>
<t tx="T2646">[SHOTGUN]
AMMOTYPE=SHELLS;
AMMOPERSHOT=1;
AUTOMATIC=TRUE;
BINDKEY=3;
PRIORITY=3;
ATTACK=PLAYER_SHOTGUN;
KICK=0.05;
STATES(UP)=SHTG:A:1:NORMAL:RAISE;
STATES(DOWN)=SHTG:A:1:NORMAL:LOWER;
STATES(READY)=SHTG:A:1:NORMAL:READY;
STATES(ATTACK)=SHTG:A:3:NORMAL:NOTHING,
               SHTG:A:7:NORMAL:SHOOT,
               SHTG:B:5:NORMAL:NOTHING,
               SHTG:C:5:NORMAL:NOTHING,
               SHTG:D:4:NORMAL:NOTHING,
               SHTG:C:5:NORMAL:NOTHING,
               SHTG:B:5:NORMAL:NOTHING,
               SHTG:A:3:NORMAL:NOTHING,
               SHTG:A:7:NORMAL:REFIRE;
STATES(FLASH)=SHTF:A:0:BRIGHT:TRANS_SET(50%),
              SHTF:A:4:BRIGHT:LIGHT1,
              SHTF:B:3:BRIGHT:LIGHT2,
              SHTF:A:0:NORMAL:LIGHT0,
              #REMOVE;</t>
<t tx="T2647">[CHAINGUN]
AMMOTYPE=BULLETS;
AMMOPERSHOT=1;
AUTOMATIC=TRUE;
REFIRE_INACCURATE=TRUE;
BINDKEY=4;
PRIORITY=5;
ATTACK=PLAYER_CHAINGUN;
KICK=0.02;
STATES(UP)=CHGG:A:1:NORMAL:RAISE;
STATES(DOWN)=CHGG:A:1:NORMAL:LOWER;
STATES(READY)=CHGG:A:1:NORMAL:READY;
STATES(ATTACK)=CHGG:A:4:NORMAL:SHOOT,
               CHGG:B:4:NORMAL:SHOOT,
               CHGG:B:0:NORMAL:REFIRE;
STATES(FLASH)=CHGF:A:0:BRIGHT:TRANS_SET(50%),
              CHGF:A:5:BRIGHT:LIGHT1,
              CHGF:B:5:BRIGHT:LIGHT2,
              CHGF:B:0:NORMAL:LIGHT0,
              #REMOVE;</t>
<t tx="T2648">[ROCKET_LAUNCHER]
AMMOTYPE=ROCKETS;
AMMOPERSHOT=1;
AUTOMATIC=TRUE;
BINDKEY=5;
PRIORITY=7;
DANGEROUS=TRUE;
ATTACK=PLAYER_MISSILE;
KICK=0.15;
STATES(UP)=MISG:A:1:NORMAL:RAISE;
STATES(DOWN)=MISG:A:1:NORMAL:LOWER;
STATES(READY)=MISG:A:1:NORMAL:READY;
STATES(ATTACK)=MISG:B:8:NORMAL:FLASH,
               MISG:B:12:NORMAL:SHOOT,
               MISG:B:0:NORMAL:REFIRE;
STATES(FLASH)=MISF:A:0:BRIGHT:TRANS_SET(50%),
              MISF:A:3:BRIGHT:LIGHT1,
              MISF:B:4:BRIGHT:NOTHING,
              MISF:C:4:BRIGHT:LIGHT2,
              MISF:D:4:BRIGHT:LIGHT2,
              MISF:D:0:NORMAL:LIGHT0,
              #REMOVE;</t>
<t tx="T2649">[PLASMA_RIFLE]
AMMOTYPE=CELLS;
AMMOPERSHOT=1;
AUTOMATIC=TRUE;
BINDKEY=6;
PRIORITY=6;
ATTACK=PLAYER_PLASMA;
KICK=0.005;
STATES(UP)=PLSG:A:1:NORMAL:RAISE;
STATES(DOWN)=PLSG:A:1:NORMAL:LOWER;
STATES(READY)=PLSG:A:1:NORMAL:READY;
STATES(ATTACK)=PLSG:A:3:NORMAL:SHOOT,
               PLSG:B:20:NORMAL:REFIRE;
STATES(FLASH)=PLSF:A:0:BRIGHT:TRANS_SET(50%),
              PLSF:A:2:BRIGHT:LIGHT1,
              PLSF:B:2:BRIGHT:LIGHT2,
              PLSF:B:0:NORMAL:LIGHT0,
              #REMOVE;</t>
<t tx="T2650">[BFG9000]
AMMOTYPE=CELLS;
AMMOPERSHOT=40;
AUTOMATIC=TRUE;
BINDKEY=7;
PRIORITY=8;
DANGEROUS=TRUE;
ATTACK=PLAYER_BFG9000;
KICK=0.2;
STATES(UP)=BFGG:A:1:NORMAL:RAISE;
STATES(DOWN)=BFGG:A:1:NORMAL:LOWER;
STATES(READY)=BFGG:A:1:NORMAL:READY;
STATES(ATTACK)=BFGG:A:20:NORMAL:PLAYSOUND(BFG),
               BFGG:B:10:NORMAL:FLASH,
               BFGG:B:10:NORMAL:SHOOT,
               BFGG:B:20:NORMAL:REFIRE;
STATES(FLASH)=BFGF:A:0:BRIGHT:TRANS_SET(50%),
              BFGF:A:11:BRIGHT:LIGHT1,
              BFGF:B:6:BRIGHT:LIGHT2,
              BFGF:B:0:NORMAL:LIGHT0,
              #REMOVE;</t>
<t tx="T2651">[CACO_FIREBALL]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=6;
DAMAGE.VAL=5;
DAMAGE.MAX=40;
ATTACK_HEIGHT=32;
LAUNCH_SOUND=FIRSHT;
SPEED=10;
FAST=2;
ATTACK_SPECIAL=FACE_TARGET;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY;
TRANSLUCENCY=75%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=400;
DLIGHT.COLOUR=#FF0000;

STATES(IDLE)=BAL2:A:4:BRIGHT:NOTHING,
             BAL2:B:4:BRIGHT:NOTHING;

STATES(DEATH)=BAL2:C:0:BRIGHT:DLIGHT_SET(500),
              BAL2:C:0:BRIGHT:DLIGHT_FADE(0),
              BAL2:C:0:BRIGHT:TRANS_FADE(0%),
              BAL2:C:0:BRIGHT:KILLSOUND,
              BAL2:C:6:BRIGHT:PLAYSOUND(FIRXPL),
              BAL2:D:6:BRIGHT:NOTHING,
              BAL2:E:6:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2652">[PLAYER_PLASMA]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=13;
DAMAGE.VAL=5;
DAMAGE.MAX=40;
ATTACK_HEIGHT=32;
SPEED=25;
KEEP_FIRING_CHANCE=3.92%;
ATTACKRANGE=1024;
ATTACK_SPECIAL=KILL_FAILED_SPAWN;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY,NOSHADOW;
LAUNCH_SOUND=PLASMA;
TRANSLUCENCY=55%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#0000FF;

STATES(IDLE)=PLSS:A:2:BRIGHT:NOTHING,
             PLSS:B:2:BRIGHT:NOTHING;

STATES(DEATH)=PLSE:A:0:BRIGHT:DLIGHT_SET(500),
              PLSE:A:0:BRIGHT:DLIGHT_FADE(0),
              PLSE:A:0:BRIGHT:TRANS_FADE(0%),
              PLSE:A:0:BRIGHT:KILLSOUND,
              PLSE:A:4:BRIGHT:PLAYSOUND(FIRXPL),
              PLSE:B:4:BRIGHT:NOTHING,
              PLSE:C:4:BRIGHT:NOTHING,
              PLSE:D:4:BRIGHT:NOTHING,
              PLSE:E:4:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2653">[BFG9000_SPRAY]
ATTACKTYPE=SPRAY;
HEIGHT=16;
RADIUS=20;
TRANSLUCENCY=50%;
DAMAGE.VAL=15;
DAMAGE.MAX=120;
ATTACKRANGE=1024;
PROJECTILE_SPECIAL=NOGRAVITY,NOSHADOW;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#00FF00;

STATES(SPAWN)=BFE2:A:0:BRIGHT:DLIGHT_FADE(0),
              BFE2:A:0:BRIGHT:TRANS_FADE(0%),
              BFE2:A:8:BRIGHT:NOTHING,
              BFE2:B:8:BRIGHT:NOTHING,
              BFE2:C:8:BRIGHT:NOTHING,
              BFE2:D:8:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2654">[PLAYER_BFG9000]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=13;
SPEED=25;
DAMAGE.VAL=100;
DAMAGE.MAX=800;
ATTACK_HEIGHT=32;
ATTACKRANGE=1024;
TRANSLUCENCY=66%;
SPARE_ATTACK=BFG9000_SPRAY;
ATTACK_SPECIAL=KILL_FAILED_SPAWN;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY,NOSHADOW;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=500;
DLIGHT.COLOUR=#00FF00;

STATES(IDLE)=BFS1:A:4:BRIGHT:NOTHING,
             BFS1:B:4:BRIGHT:NOTHING;

STATES(DEATH)=BFE1:A:0:BRIGHT:DLIGHT_SET(1000),
              BFE1:A:0:BRIGHT:DLIGHT_FADE(0),
              BFE1:A:0:BRIGHT:TRANS_FADE(0%),
              BFE1:A:0:BRIGHT:KILLSOUND,
              BFE1:A:8:BRIGHT:PLAYSOUND(RXPLOD),
              BFE1:B:8:BRIGHT:NOTHING,
              BFE1:C:8:BRIGHT:SPARE_ATTACK,
              BFE1:D:8:BRIGHT:NOTHING,
              BFE1:E:8:BRIGHT:NOTHING,
              BFE1:F:8:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2655">[REVENANT_MISSILE]
ATTACKTYPE=PROJECTILE;
HEIGHT=8;
RADIUS=11;
DAMAGE.VAL=10;
DAMAGE.MAX=80;
ATTACK_HEIGHT=48;
SPEED=10;
NO_TRACE_CHANCE=1.56%;
TOO_CLOSE_RANGE=196;
ATTACK_SPECIAL=FACE_TARGET,SMOKING_TRACER;
PROJECTILE_SPECIAL=NOBLOCKMAP,MISSILE,DROPOFF,NOGRAVITY,NOSHADOW;
LAUNCH_SOUND=SKEATK;
PUFF=PUFF;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=200;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=FATB:A:2:BRIGHT:RANDOM_TRACER,
             FATB:B:2:BRIGHT:RANDOM_TRACER;

STATES(DEATH)=FBXP:A:0:BRIGHT:DLIGHT_FADE(0),
              FBXP:A:0:BRIGHT:TRANS_FADE(0%),
              FBXP:A:0:BRIGHT:KILLSOUND,
              FBXP:A:8:BRIGHT:PLAYSOUND(BAREXP),
              FBXP:B:6:BRIGHT:NOTHING,
              FBXP:C:4:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2656">[CACO_CLOSECOMBAT]
ATTACKTYPE=CLOSECOMBAT;
DAMAGE.VAL=10;
DAMAGE.MAX=60;
ATTACKRANGE=64;
ATTACK_SPECIAL=NEED_SIGHT,FACE_TARGET;</t>
<t tx="T2657">[DEMON_CLOSECOMBAT]
ATTACKTYPE=CLOSECOMBAT;
DAMAGE.VAL=4;
DAMAGE.MAX=40;
ATTACKRANGE=64;
ATTACK_SPECIAL=NEED_SIGHT,FACE_TARGET;</t>
<t tx="T2658">[ELEMENTAL_SPAWNER]
ATTACKTYPE=SPAWNER;
ATTACK_HEIGHT=8;
ATTACK_SPECIAL=PRESTEP_SPAWN;
SPAWNED_OBJECT=LOST_SOUL;
SPAWN_OBJECT_STATE=MISSILE:2;
ATTACK_SPECIAL=FACE_TARGET;</t>
<t tx="T2659">[ELEMENTAL_DEATHSPAWN]
ATTACKTYPE=TRIPLE_SPAWNER;
ATTACK_HEIGHT=8;
ATTACK_SPECIAL=PRESTEP_SPAWN,FACE_TARGET;
SPAWNED_OBJECT=LOST_SOUL;
SPAWN_OBJECT_STATE=MISSILE:2;</t>
<t tx="T2660">[FORMER_HUMAN_CHAINGUN]
ATTACKTYPE=SHOT;
SHOTCOUNT=1;
DAMAGE.VAL=3;
DAMAGE.MAX=15;
ACCURACY_ANGLE=22;
ACCURACY_SLOPE=12;
ENGAGED_SOUND=SHOTGN;
KEEP_FIRING_CHANCE=15.68%;
ATTACK_SPECIAL=FACE_TARGET;
PUFF=PUFF;</t>
<t tx="T2661">[FORMER_HUMAN_PISTOL]
ATTACKTYPE=SHOT;
SHOTCOUNT=1;
DAMAGE.VAL=3;
DAMAGE.MAX=15;
ACCURACY_ANGLE=22;
ACCURACY_SLOPE=12;
ENGAGED_SOUND=PISTOL;
ATTACK_SPECIAL=FACE_TARGET;
PUFF=PUFF;</t>
<t tx="T2662">[FORMER_HUMAN_SHOTGUN]
ATTACKTYPE=SHOT;
SHOTCOUNT=3;
DAMAGE.VAL=3;
DAMAGE.MAX=15;
ACCURACY_ANGLE=14;
ACCURACY_SLOPE=0;
ENGAGED_SOUND=SHOTGN;
KEEP_FIRING_CHANCE=3.92%;
ATTACK_SPECIAL=FACE_TARGET;
PUFF=PUFF;</t>
<t tx="T2663">[IMP_CLOSECOMBAT]
ATTACKTYPE=CLOSECOMBAT;
DAMAGE.VAL=3;
DAMAGE.MAX=24;
ENGAGED_SOUND=CLAW;
ATTACKRANGE=64;
ATTACK_SPECIAL=NEED_SIGHT,FACE_TARGET;</t>
<t tx="T2664">[PLAYER_PISTOL]
ATTACKTYPE=SHOT;
SHOTCOUNT=1;
DAMAGE.VAL=5;
DAMAGE.MAX=15;
ATTACK_HEIGHT=32;
ACCURACY_ANGLE=3;
ACCURACY_SLOPE=1.5;
ENGAGED_SOUND=PISTOL;
ATTACKRANGE=1024;
PUFF=PUFF;</t>
<t tx="T2665">[PLAYER_SHOTGUN]
ATTACKTYPE=SHOT;
SHOTCOUNT=7;
DAMAGE.VAL=5;
DAMAGE.MAX=15;
ATTACK_HEIGHT=32;
ACCURACY_ANGLE=6;
ACCURACY_SLOPE=0;
ENGAGED_SOUND=SHOTGN;
ATTACKRANGE=1024;
PUFF=PUFF;</t>
<t tx="T2666">[PLAYER_SHOTGUN2]
ATTACKTYPE=SHOT;
SHOTCOUNT=20;
DAMAGE.VAL=5;
DAMAGE.MAX=15;
ATTACK_HEIGHT=32;
ACCURACY_ANGLE=12;
ACCURACY_SLOPE=6;
ENGAGED_SOUND=DSHTGN;
ATTACKRANGE=1024;
PUFF=PUFF;</t>
<t tx="T2667">[PLAYER_CHAINGUN]
ATTACKTYPE=SHOT;
SHOTCOUNT=1;
DAMAGE.VAL=5;
DAMAGE.MAX=15;
ATTACK_HEIGHT=32;
ACCURACY_ANGLE=6;
ACCURACY_SLOPE=3;
ATTACKRANGE=1024;
ENGAGED_SOUND=CHGUN;
PUFF=PUFF;</t>
<t tx="T2668">[PLAYER_SAW]
ATTACKTYPE=CLOSECOMBAT;
DAMAGE.VAL=2;
DAMAGE.MAX=20;
ATTACK_HEIGHT=28;
X_OFFSET=4;
ACCURACY_ANGLE=12;
ACCURACY_SLOPE=6;
ENGAGED_SOUND=SAWHIT;
ATTACK_SPECIAL=FACE_TARGET,FORCE_AIM;
ATTACKRANGE=63.9;
PUFF=PUFF;</t>
<t tx="T2669">[PLAYER_PUNCH]
ATTACKTYPE=CLOSECOMBAT;
DAMAGE.VAL=2;
DAMAGE.MAX=20;
ATTACK_HEIGHT=32;
ATTACKRANGE=96;
ACCURACY_ANGLE=0;
ACCURACY_SLOPE=0;
ATTACK_SPECIAL=FACE_TARGET,FORCE_AIM;
ENGAGED_SOUND=PUNCH;</t>
<t tx="T2670">[REVENANT_CLOSECOMBAT]
ATTACKTYPE=CLOSECOMBAT;
DAMAGE.VAL=6;
DAMAGE.MAX=60;
ATTEMPT_SOUND=SKESWG;
ENGAGED_SOUND=SKEPCH;
ATTACKRANGE=64;</t>
<t tx="T2671">[SKULL_ASSAULT]
ATTACKTYPE=SKULLFLY;
DAMAGE.VAL=3;
DAMAGE.MAX=24;
ASSAULT_SPEED=20;
ATTEMPT_SOUND=SKLATK;
ATTACK_SPECIAL=FACE_TARGET;</t>
<t tx="T2672">@others</t>
<t tx="T2673">[HEALTH_POTION:2014]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=HEALTH(1:200);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotHealthPotion;
TRANSLUCENCY=60%;
RESPAWN_EFFECT=ITEM_RESPAWN;
SPECIAL=COUNT_AS_ITEM,SPECIAL;

STATES(IDLE)=BON1:A:6:NORMAL:NOTHING, 
             BON1:B:6:NORMAL:NOTHING,
             BON1:C:6:NORMAL:NOTHING,
             BON1:D:6:NORMAL:NOTHING,
             BON1:C:6:NORMAL:NOTHING,
             BON1:B:6:NORMAL:NOTHING;</t>
<t tx="T2674">[STIMPACK:2011]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=HEALTH(10:100);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotStim;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=STIM:A:-1:NORMAL:NOTHING;</t>
<t tx="T2675">[MEDIKIT:2012]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=HEALTH(25:100);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotMedi;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=MEDI:A:-1:NORMAL:NOTHING;</t>
<t tx="T2676">[SOULSPHERE:2013]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FFFFFF;
PICKUP_BENEFIT=HEALTH(100:200);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotSoul;
TRANSLUCENCY=60%;
SPECIAL=SPECIAL,COUNT_AS_ITEM,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=SOUL:A:6:BRIGHT:NOTHING,
             SOUL:B:6:BRIGHT:NOTHING,
             SOUL:C:6:BRIGHT:NOTHING,
             SOUL:D:6:BRIGHT:NOTHING,
             SOUL:C:6:BRIGHT:NOTHING,
             SOUL:B:6:BRIGHT:NOTHING;</t>
<t tx="T2677">[BERSERKER:2023]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FF0000;
PICKUP_BENEFIT=POWERUP_BERSERK(60:60),HEALTH(100:100);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotBerserk;
RESPAWN_EFFECT=ITEM_RESPAWN;
SPECIAL=SPECIAL,COUNT_AS_ITEM,NOSHADOW;

STATES(IDLE)=PSTR:A:-1:BRIGHT:NOTHING;</t>
<t tx="T2678">// Special, gives both health and armour
[MEGASPHERE:83]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=200;
DLIGHT.COLOUR=#FFFFFF;
PICKUP_BENEFIT=HEALTH(200:200),BLUE_ARMOUR(200:200);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotMega;
TRANSLUCENCY=60%;
SPECIAL=SPECIAL,COUNT_AS_ITEM,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=MEGA:A:6:BRIGHT:NOTHING,
             MEGA:B:6:BRIGHT:NOTHING,
             MEGA:C:6:BRIGHT:NOTHING,
             MEGA:D:6:BRIGHT:NOTHING;</t>
<t tx="T2679">@others</t>
<t tx="T2680">[ARMOUR_HELMET:2015]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=GREEN_ARMOUR(1:200);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotArmourHelmet;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;
SPECIAL=COUNT_AS_ITEM;

STATES(IDLE)=BON2:A:6:NORMAL:NOTHING,
             BON2:B:6:NORMAL:NOTHING,
             BON2:C:6:NORMAL:NOTHING,
             BON2:D:6:NORMAL:NOTHING,
             BON2:C:6:NORMAL:NOTHING,
             BON2:B:6:NORMAL:NOTHING;</t>
<t tx="T2681">[GREEN_ARMOUR:2018]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=GREEN_ARMOUR(100:100);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotArmour;
RESPAWN_EFFECT=ITEM_RESPAWN;
SPECIAL=SPECIAL;

STATES(IDLE)=ARM1:A:6:NORMAL:NOTHING,
            ARM1:B:6:BRIGHT:NOTHING;</t>
<t tx="T2682">[BLUE_ARMOUR:2019]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=BLUE_ARMOUR(200:200);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotMegaArmour;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=ARM2:A:6:NORMAL:NOTHING,
             ARM2:B:6:BRIGHT:NOTHING;</t>
<t tx="T2683">@others</t>
<t tx="T2684">[BLUE_KEY:5]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#0000FF;
PICKUP_BENEFIT=KEY_BLUECARD;
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotBlueCard;
SPECIAL=SPECIAL,NODEATHMATCH,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=BKEY:A:10:NORMAL:NOTHING,
             BKEY:B:10:BRIGHT:NOTHING;</t>
<t tx="T2685">[YELLOW_KEY:6]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FFFF40;
PICKUP_BENEFIT=KEY_YELLOWCARD;
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotYellowCard;
SPECIAL=SPECIAL,NODEATHMATCH,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=YKEY:A:10:NORMAL:NOTHING,
             YKEY:B:10:BRIGHT:NOTHING;</t>
<t tx="T2686">[RED_KEY:13]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FF0000;
PICKUP_BENEFIT=KEY_REDCARD;
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotRedCard;
SPECIAL=SPECIAL,NODEATHMATCH,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=RKEY:A:10:NORMAL:NOTHING,
             RKEY:B:10:BRIGHT:NOTHING;</t>
<t tx="T2687">[RED_SKULLKEY:38]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FF0000;
PICKUP_BENEFIT=KEY_REDSKULL;
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotRedSkull;
SPECIAL=SPECIAL,NODEATHMATCH,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=RSKU:A:10:NORMAL:NOTHING,
             RSKU:B:10:BRIGHT:NOTHING;</t>
<t tx="T2688">[YELLOW_SKULLKEY:39]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FFFF40;
PICKUP_BENEFIT=KEY_YELLOWSKULL;
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotYellowSkull;
SPECIAL=SPECIAL,NODEATHMATCH,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=YSKU:A:10:NORMAL:NOTHING,
             YSKU:B:10:BRIGHT:NOTHING;</t>
<t tx="T2689">[BLUE_SKULLKEY:40]
RADIUS=20;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#0000FF;
PICKUP_BENEFIT=KEY_BLUESKULL;
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotBlueSkull;
SPECIAL=SPECIAL,NODEATHMATCH,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=BSKU:A:10:NORMAL:NOTHING,
             BSKU:B:10:BRIGHT:NOTHING;</t>
<t tx="T2690">@others</t>
<t tx="T2691">[BFG:2006]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=BFG9000,CELLS(40);
PICKUP_SOUND=WPNUP;
PICKUP_MESSAGE=GotBFG;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=BFUG:A:-1:NORMAL:NOTHING;</t>
<t tx="T2692">[CHAINGUN:2002]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=CHAINGUN,BULLETS(20);
PICKUP_SOUND=WPNUP;
PICKUP_MESSAGE=GotChainGun;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=MGUN:A:-1:NORMAL:NOTHING;</t>
<t tx="T2693">[CHAINSAW:2005]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=CHAINSAW;
PICKUP_SOUND=WPNUP;
PICKUP_MESSAGE=GotChainSaw;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=CSAW:A:-1:NORMAL:NOTHING;</t>
<t tx="T2694">[MISSILE_LAUNCHER:2003]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=ROCKET_LAUNCHER,ROCKETS(2);
PICKUP_SOUND=WPNUP;
PICKUP_MESSAGE=GotRocketLauncher;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=LAUN:A:-1:NORMAL:NOTHING;</t>
<t tx="T2695">[PLASMA_RIFLE:2004]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=PLASMA_RIFLE,CELLS(40);
PICKUP_SOUND=WPNUP;
PICKUP_MESSAGE=GotPlasmaGun;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=PLAS:A:-1:NORMAL:NOTHING;</t>
<t tx="T2696">[SHOTGUN:2001]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=SHOTGUN,SHELLS(8);
PICKUP_SOUND=WPNUP;
PICKUP_MESSAGE=GotShotGun;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=SHOT:A:-1:NORMAL:NOTHING;</t>
<t tx="T2697">[SUPER_SHOTGUN:82]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=SUPERSHOTGUN,SHELLS(8);
PICKUP_SOUND=WPNUP;
PICKUP_MESSAGE=GotDoubleBarrel;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=SGN2:A:-1:NORMAL:NOTHING;</t>
<t tx="T2698">@others</t>
<t tx="T2699">@others</t>
<t tx="T2700">@others</t>
<t tx="T2701">@others</t>
<t tx="T2702">@others</t>
<t tx="T2703">[BRAIN_SPAWNSPOT:87]
RADIUS=20;
HEIGHT=32;
SPAWNHEALTH=1000;
MASS=1000;
SPEED=0;
REACTION_TIME=8T;
SPECIAL=NOBLOCKMAP,NOSECTOR;
TRANSLUCENCY=0%;

STATES(IDLE)=BBRN:A:-1:NORMAL:Nothing;

[BOSS_BRAIN:88]
RADIUS=20;
HEIGHT=120;
SPAWNHEALTH=300;
MASS=10000;
SPEED=0;
REACTION_TIME=8T;
SPECIAL=SOLID,SHOOTABLE,BOSSMAN;
PAINCHANCE=100%;
PAIN_SOUND=BOSPN;
DEATH_SOUND=BOSDTH;

STATES(IDLE)=BBRN:A:100:NORMAL:NOTHING;
STATES(PAIN)=BBRN:B:36:NORMAL:NOTHING;
STATES(DEATH)=BBRN:A:100:NORMAL:BRAINSCREAM,
              BBRN:A:10:NORMAL:NOTHING,
              BBRN:A:20:NORMAL:NOTHING,
              BBRN:A:-1:NORMAL:BRAINDIE;

[BRAIN_SHOOTER:89]
RADIUS=20;
HEIGHT=32;
SPAWNHEALTH=1000;
MASS=100;
SPEED=0;
REACTION_TIME=8T;
SPECIAL=NOBLOCKMAP,NOSECTOR,BOSSMAN;
SIGHTING_SOUND=BOSSIT;
TRANSLUCENCY=0%;
SPIT_SPOT=BRAIN_SPAWNSPOT;
RANGE_ATTACK=BRAIN_CUBE;

STATES(IDLE)=BBRN:A:10:NORMAL:LOOKOUT;
STATES(CHASE)=BBRN:A:150:NORMAL:NOTHING,
              BBRN:A:180:NORMAL:BRAINSPIT,
              #CHASE;

[BRAIN_DEATH_MISSILE]
RADIUS=11;
HEIGHT=8;
SPAWNHEALTH=1000;
MASS=100;
REACTIONTIME=8T;
SPECIAL=NOBLOCKMAP,DROPOFF,NOGRAVITY,MISSILE,BOSSMAN;
SPEED=20;
EXPLODE_DAMAGE.VAL=128;
LAUNCH_SOUND=RLAUNC;
DEATH_SOUND=BAREXP;

STATES(SPAWN)=MISL:B:0:BRIGHT:TRANS_FADE(0%),
              MISL:B:15:BRIGHT:NOTHING,
              MISL:C:10:BRIGHT:BRAINMISSILEEXPLODE,
              MISL:D:10:BRIGHT:BRAINMISSILEEXPLODE,
              #REMOVE;
			  
&lt;&lt; New Experimental Creatures &gt;&gt;</t>
<t tx="T2704">
[REVENANT_MKII:7100]
SPAWNHEALTH=350;
REACTION_TIME=0.23;
RADIUS=20;
HEIGHT=56;
SPEED=10;
MASS=500;
PAINCHANCE=40%;
SPECIAL=COUNT_AS_KILL,SOLID,SHOOTABLE,TRIGGER_HAPPY,ATTACK_HURTS,DISLOYAL;
MINATTACK_CHANCE=25%;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=SKEACT;
DEATH_SOUND=SKEDTH;
PAIN_SOUND=POPAIN;
SIGHTING_SOUND=SKESIT;
RANGE_ATTACK=TRACER_MISSILE_L;
SPARE_ATTACK=TRACER_MISSILE_R;
CLOSE_ATTACK=REVENANT_CLOSECOMBAT;

STATES(IDLE)=SKEL:A:10:NORMAL:LOOKOUT,
             SKEL:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=SKEL:A:2:NORMAL:CHASE,
              SKEL:A:2:NORMAL:CHASE,
              SKEL:B:2:NORMAL:CHASE,
              SKEL:B:2:NORMAL:CHASE,
              SKEL:C:2:NORMAL:CHASE,
              SKEL:C:2:NORMAL:CHASE,
              SKEL:D:2:NORMAL:CHASE,
              SKEL:D:2:NORMAL:CHASE,
              SKEL:E:2:NORMAL:CHASE,
              SKEL:E:2:NORMAL:CHASE,
              SKEL:F:2:NORMAL:CHASE,
              SKEL:F:2:NORMAL:CHASE;

STATES(MELEE)=SKEL:G:0:NORMAL:FACETARGET,
              SKEL:G:6:NORMAL:CLOSEATTEMPTSND,
              SKEL:H:6:NORMAL:FACETARGET,
              SKEL:I:6:NORMAL:CLOSE_ATTACK,
              #CHASE;

STATES(MISSILE)=SKEL:J:10:BRIGHT:FACETARGET,
                SKEL:J:0:BRIGHT:SPARE_ATTACK,
                SKEL:K:10:NORMAL:RANGE_ATTACK,
                SKEL:K:10:NORMAL:FACETARGET,
                #CHASE;

STATES(PAIN)=SKEL:L:5:NORMAL:NOTHING,
             SKEL:L:5:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=SKEL:L:7:NORMAL:NOTHING,
              SKEL:M:7:NORMAL:NOTHING,
              SKEL:N:7:NORMAL:MAKEDEATHSOUND,
              SKEL:O:7:NORMAL:MAKEDEAD,
              SKEL:P:7:NORMAL:NOTHING,
              SKEL:Q:-1:NORMAL:NOTHING;

STATES(RESPAWN)=SKEL:Q:5:NORMAL:NOTHING,
                SKEL:P:5:NORMAL:NOTHING,
                SKEL:O:5:NORMAL:NOTHING,
                SKEL:N:5:NORMAL:NOTHING,
                SKEL:M:5:NORMAL:NOTHING,
                SKEL:L:5:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);

[TELEPORT_SPAWNER:7101]
SPAWNHEALTH=1000;
REACTION_TIME=0.23;
MASS=1000;
SPECIAL=INVISIBLE;
TRANSLUCENCY=0%;
RESPAWN_EFFECT=RESPAWN_FLASH;
RANGE_ATTACK=IMP_SPAWNER;

STATES(IDLE)=TFOG:A:10:NORMAL:LOOKOUT,
             TFOG:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=TFOG:A:0:BRIGHT:TRANS_FADE(10%),
              TFOG:A:0:BRIGHT:RANGE_ATTACK,
              TFOG:A:6:BRIGHT:NOTHING,
              TFOG:B:6:BRIGHT:NOTHING,
              TFOG:A:6:BRIGHT:NOTHING,
              TFOG:B:6:BRIGHT:NOTHING,
              TFOG:C:6:BRIGHT:NOTHING,
              TFOG:D:6:BRIGHT:NOTHING,
              TFOG:E:6:BRIGHT:NOTHING,
              TFOG:F:6:BRIGHT:NOTHING,
              TFOG:G:6:BRIGHT:NOTHING,
              TFOG:H:6:BRIGHT:NOTHING,
              TFOG:I:6:BRIGHT:NOTHING,
              TFOG:J:6:BRIGHT:NOTHING,
              TFOG:J:105:BRIGHT:NOTHING;

[ARACHNOTRON_MKII:7102]
SPAWNHEALTH=750;
REACTION_TIME=0.23;
RADIUS=64;
HEIGHT=64;
SPEED=12;
MASS=600;
PAINCHANCE=50%;
SPECIAL=COUNT_AS_KILL,SOLID,SHOOTABLE,DISLOYAL,ATTACK_HURTS;
MINATTACK_CHANCE=22%;
BLOOD=BLOOD;
ACTIVE_SOUND=BSPACT;
DEATH_SOUND=BSPDTH;
PAIN_SOUND=DMPAIN;
SIGHTING_SOUND=BSPSIT;
WALK_SOUND=BSPWLK;
RESPAWN_EFFECT=RESPAWN_FLASH;
RANGE_ATTACK=ARACHNOTRON_PLASMA;

STATES(IDLE)=BSPI:A:10:NORMAL:LOOKOUT,
             BSPI:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=BSPI:A:20:NORMAL:NOTHING,
              BSPI:A:3:NORMAL:WALKSOUND_CHASE,
              BSPI:A:3:NORMAL:CHASE,
              BSPI:B:3:NORMAL:CHASE,
              BSPI:B:3:NORMAL:CHASE,
              BSPI:C:3:NORMAL:CHASE,
              BSPI:C:3:NORMAL:CHASE,
              BSPI:D:3:NORMAL:WALKSOUND_CHASE,
              BSPI:D:3:NORMAL:CHASE,
              BSPI:E:3:NORMAL:CHASE,
              BSPI:E:3:NORMAL:CHASE,
              BSPI:F:3:NORMAL:CHASE,
              BSPI:F:3:NORMAL:CHASE, 
              #CHASE:2;

STATES(MISSILE)=BSPI:A:20:BRIGHT:FACETARGET,
                BSPI:G:3:BRIGHT:RANGE_ATTACK,
                BSPI:H:1:BRIGHT:NOTHING,
                BSPI:H:1:BRIGHT:REFIRE_CHECK,
                #MISSILE:2;
 
STATES(PAIN)=BSPI:I:3:NORMAL:NOTHING,
           BSPI:I:3:NORMAL:MAKEPAINSOUND,
           #CHASE:2;

STATES(DEATH)=BSPI:J:20:NORMAL:MAKEDEATHSOUND,
            BSPI:K:7:NORMAL:MAKEDEAD,
            BSPI:L:7:NORMAL:NOTHING,
            BSPI:M:7:NORMAL:NOTHING,
            BSPI:N:7:NORMAL:NOTHING,
            BSPI:O:7:NORMAL:NOTHING,
            BSPI:P:-1:NORMAL:NOTHING;

STATES(RESPAWN)=BSPI:P:5:NORMAL:NOTHING,
               BSPI:O:5:NORMAL:NOTHING,
               BSPI:N:5:NORMAL:NOTHING,
               BSPI:M:5:NORMAL:NOTHING,
               BSPI:L:5:NORMAL:NOTHING,
               BSPI:K:5:NORMAL:NOTHING,
               BSPI:J:5:NORMAL:NOTHING,
               #CHASE:2;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);

[MANCUBUS_MKII:7103]
SPAWNHEALTH=600;
REACTION_TIME=0.23;
RADIUS=48;
HEIGHT=64;
SPEED=8;
MASS=1000;
PAINCHANCE=30%;
SPECIAL=COUNT_AS_KILL,SOLID,SHOOTABLE,DISLOYAL,ATTACK_HURTS;
MINATTACK_CHANCE=22%;
BLOOD=BLOOD;
ACTIVE_SOUND=POSACT;
DEATH_SOUND=MANDTH;
PAIN_SOUND=MNPAIN;
SIGHTING_SOUND=MANSIT;
RESPAWN_EFFECT=RESPAWN_FLASH;
RANGE_ATTACK=MANCUBUS_FIREBALL_L;
SPARE_ATTACK=MANCUBUS_FIREBALL_R;

STATES(IDLE)=FATT:A:15:NORMAL:LOOKOUT,
            FATT:B:15:NORMAL:LOOKOUT;

STATES(CHASE)=FATT:A:4:NORMAL:CHASE,
              FATT:A:4:NORMAL:CHASE,
              FATT:B:4:NORMAL:CHASE,
              FATT:B:4:NORMAL:CHASE,
              FATT:C:4:NORMAL:CHASE,
              FATT:C:4:NORMAL:CHASE,
              FATT:D:4:NORMAL:CHASE,
              FATT:D:4:NORMAL:CHASE,
              FATT:E:4:NORMAL:CHASE,
              FATT:E:4:NORMAL:CHASE,
              FATT:F:4:NORMAL:CHASE,
              FATT:F:4:NORMAL:CHASE;

STATES(MISSILE)=FATT:G:0:NORMAL:FACETARGET,
               FATT:G:20:NORMAL:RANGEATTEMPTSND,
               FATT:H:0:NORMAL:FACETARGET,
               FATT:H:0:BRIGHT:RANGE_ATTACK,
               FATT:H:10:BRIGHT:SPARE_ATTACK,
               FATT:I:5:NORMAL:FACETARGET,
               FATT:G:5:NORMAL:FACETARGET,
               FATT:H:0:NORMAL:FACETARGET,
               FATT:H:0:BRIGHT:RANGE_ATTACK,
               FATT:H:10:BRIGHT:SPARE_ATTACK,
               FATT:I:5:NORMAL:FACETARGET,
               FATT:G:5:NORMAL:FACETARGET,
               FATT:H:0:NORMAL:FACETARGET,
               FATT:H:0:BRIGHT:RANGE_ATTACK,
               FATT:H:10:BRIGHT:SPARE_ATTACK,
               FATT:I:5:NORMAL:FACETARGET,
               FATT:G:5:NORMAL:FACETARGET,
               #CHASE;

STATES(PAIN)=FATT:J:3:NORMAL:NOTHING,
             FATT:J:3:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=FATT:K:6:NORMAL:NOTHING,
              FATT:L:6:NORMAL:MAKEDEATHSOUND,
              FATT:M:6:NORMAL:MAKEDEAD,
              FATT:N:6:NORMAL:NOTHING,
              FATT:O:6:NORMAL:NOTHING,
              FATT:P:6:NORMAL:NOTHING,
              FATT:Q:6:NORMAL:NOTHING,
              FATT:R:6:NORMAL:NOTHING,
              FATT:S:6:NORMAL:NOTHING,
              FATT:T:-1:NORMAL:NOTHING;

STATES(RESPAWN)=FATT:R:5:NORMAL:NOTHING,
               FATT:Q:5:NORMAL:NOTHING,
               FATT:P:5:NORMAL:NOTHING,
               FATT:O:5:NORMAL:NOTHING,
               FATT:N:5:NORMAL:NOTHING,
               FATT:M:5:NORMAL:NOTHING,
               FATT:L:5:NORMAL:NOTHING,
               FATT:K:5:NORMAL:NOTHING,
               #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);

// Marine's Best Friend :-&gt;

[DOG:888]
SPAWNHEALTH=500;
REACTION_TIME=8T;
RADIUS=12;
HEIGHT=28;
SPEED=10;
FAST=2;
MASS=100;
PAINCHANCE=70%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=DOG_LOOK;
DEATH_SOUND=DOG_DIE;
PAIN_SOUND=DOG_PAIN;
SIGHTING_SOUND=DOG_SIGHT;
STARTCOMBAT_SOUND=DOG_BITE;
CLOSE_ATTACK=DEMON_CLOSECOMBAT;

STATES(IDLE)=DOGS:A:10:NORMAL:LOOKOUT,
             DOGS:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=DOGS:A:2:NORMAL:CHASE,
              DOGS:A:2:NORMAL:CHASE,
              DOGS:B:2:NORMAL:CHASE,
              DOGS:B:2:NORMAL:CHASE,
              DOGS:C:2:NORMAL:CHASE,
              DOGS:C:2:NORMAL:CHASE,
              DOGS:D:2:NORMAL:CHASE,
              DOGS:D:2:NORMAL:CHASE;

STATES(MELEE)=DOGS:E:8:NORMAL:FACETARGET,
              DOGS:F:8:NORMAL:FACETARGET,
              DOGS:G:8:NORMAL:CLOSE_ATTACK,
              #CHASE;

STATES(PAIN)=DOGS:H:2:NORMAL:NOTHING,
             DOGS:H:2:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=DOGS:I:8:NORMAL:NOTHING,
              DOGS:J:8:NORMAL:MAKEDEATHSOUND,
              DOGS:K:4:NORMAL:MAKEDEAD,
              DOGS:L:-1:NORMAL:NOTHING;

STATES(RESPAWN)=DOGS:L:5:NORMAL:NOTHING,
                DOGS:K:5:NORMAL:NOTHING,
                DOGS:J:5:NORMAL:NOTHING,
                DOGS:I:5:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH)</t>
<t tx="T2705">[BOX_OF_BULLETS:2048]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=BULLETS(50);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotClipBox;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=AMMO:A:-1:NORMAL:NOTHING;</t>
<t tx="T2706">[BOX_OF_ROCKETS:2046]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=ROCKETS(5);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotRocketBox;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=BROK:A:-1:NORMAL:NOTHING;</t>
<t tx="T2707">[BOX_OF_SHELLS:2049]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=SHELLS(20);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotShellBox;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=SBOX:A:-1:NORMAL:NOTHING;</t>
<t tx="T2708">[CELL_PACK:17]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=CELLS(100);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotCellPack;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=CELP:A:-1:NORMAL:NOTHING;</t>
<t tx="T2709">[CELLS:2047]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=CELLS(20);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotCell;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=CELL:A:-1:NORMAL:NOTHING;</t>
<t tx="T2710">[CLIP:2007]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=BULLETS(10);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotClip;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=CLIP:A:-1:NORMAL:NOTHING;</t>
<t tx="T2711">[ROCKET:2010]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=ROCKETS(1);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotRocket;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=ROCK:A:-1:NORMAL:NOTHING;</t>
<t tx="T2712">[SHELLS:2008]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=SHELLS(4);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotShells;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=SHEL:A:-1:NORMAL:NOTHING;</t>
<t tx="T2713">[AUTOMAP:2026]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=POWERUP_AUTOMAP;
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotMap;
RESPAWN_EFFECT=ITEM_RESPAWN;
SPECIAL=SPECIAL,COUNT_AS_ITEM,NOSHADOW;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=PMAP:A:6:BRIGHT:NOTHING,
             PMAP:B:6:BRIGHT:NOTHING,
             PMAP:C:6:BRIGHT:NOTHING,
             PMAP:D:6:BRIGHT:NOTHING,
             PMAP:C:6:BRIGHT:NOTHING,
             PMAP:B:6:BRIGHT:NOTHING;</t>
<t tx="T2714">[BACKPACK:8]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=BULLETS.LIMIT(400),SHELLS.LIMIT(100),
               ROCKETS.LIMIT(100),CELLS.LIMIT(600),
               BULLETS(10),SHELLS(4),ROCKETS(1),CELLS(20);
PICKUP_SOUND=ITEMUP;
PICKUP_MESSAGE=GotBackpack;
RESPAWN_EFFECT=ITEM_RESPAWN;
SPECIAL=SPECIAL;

STATES(IDLE)=BPAK:A:-1:NORMAL:NOTHING;</t>
<t tx="T2715">[BLURSPHERE:2024]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=POWERUP_PARTINVIS(100:100);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotInvis;
SPECIAL=SPECIAL,NO_RESPAWN,COUNT_AS_ITEM,NOSHADOW;
TRANSLUCENCY=60%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=150;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=PINS:A:6:BRIGHT:NOTHING,
             PINS:B:6:BRIGHT:NOTHING,
             PINS:C:6:BRIGHT:NOTHING,
             PINS:D:6:BRIGHT:NOTHING;</t>
<t tx="T2716">[INVULNERABILITY_SPHERE:2022]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=POWERUP_INVULNERABLE(30:30);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotInvulner;
SPECIAL=SPECIAL,NO_RESPAWN,COUNT_AS_ITEM,NOSHADOW;
TRANSLUCENCY=70%;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=PINV:A:6:BRIGHT:NOTHING,
             PINV:B:6:BRIGHT:NOTHING,
             PINV:C:6:BRIGHT:NOTHING,
             PINV:D:6:BRIGHT:NOTHING;</t>
<t tx="T2717">[LIGHT_SPECS:2045]
RADIUS=20;
HEIGHT=16;
PICKUP_BENEFIT=POWERUP_LIGHTGOGGLES(120:120);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotVisor;
RESPAWN_EFFECT=ITEM_RESPAWN;
SPECIAL=SPECIAL,COUNT_AS_ITEM,NOSHADOW;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=PVIS:A:6:BRIGHT:NOTHING,
             PVIS:B:6:NORMAL:NOTHING;</t>
<t tx="T2718">[RADIATION_SUIT:2025]
RADIUS=20;
HEIGHT=60;
PICKUP_BENEFIT=POWERUP_ACIDSUIT(60:60);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotSuit;
RESPAWN_EFFECT=ITEM_RESPAWN;
SPECIAL=SPECIAL;

STATES(IDLE)=SUIT:A:-1:BRIGHT:NOTHING;</t>
<t tx="T2719">[NIGHTVISION_SPECS:7000]
RADIUS=16;
HEIGHT=16;
PICKUP_BENEFIT=POWERUP_NIGHTVISION(30:30);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotNight;
SPECIAL=SPECIAL,NOSHADOW;
RESPAWN_EFFECT=ITEM_RESPAWN;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=NVSC:A:6:NORMAL:NOTHING,
             NVSC:B:6:BRIGHT:NOTHING;</t>
<t tx="T2720">[JETPACK:7020]
RADIUS=16;
HEIGHT=16;
PICKUP_BENEFIT=POWERUP_JETPACK(30:30);
PICKUP_SOUND=GETPOW;
PICKUP_MESSAGE=GotJetPack;
SPECIAL=SPECIAL;
RESPAWN_EFFECT=ITEM_RESPAWN;

STATES(IDLE)=JPCK:A:35:NORMAL:NOTHING;</t>
<t tx="T2721">[HELL_ON_EARTH]
INTERMISSION_GRAPHIC="INTERPIC";
INTERMISSION_MUSIC=64;
NAME_GRAPHIC="M_EPI5";
PERCENT_SOUND=PISTOL;
DONE_SOUND=BAREXP;
NEXTMAP_SOUND=SGCOCK;
ACCEL_SOUND="SLOP";
FRAG_SOUND="PLDETH";
FIRSTMAP=MAP01;
TITLE_GRAPHIC="TITLEPIC","CREDIT";
TITLE_TIME=365T;
TITLE_MUSIC=65;</t>
<t tx="T2722">[INFERNO]
INTERMISSION_GRAPHIC="WIMAP2";
INTERMISSION_MUSIC=63;
SPLAT_GRAPHIC="WISPLAT";
YAH1_GRAPHIC="WIURH0";
YAH2_GRAPHIC="WIURH1";
NAME_GRAPHIC="M_EPI3";
PERCENT_SOUND=PISTOL;
DONE_SOUND=BAREXP;
ENDMAP_SOUND=BAREXP;
NEXTMAP_SOUND=SGCOCK;
ACCEL_SOUND="SLOP";
FRAG_SOUND="PLDETH";
FIRSTMAP=E3M1;
MAP=E3M1:156:168,
    E3M2:48:154,
    E3M3:174:95,
    E3M4:265:75,
    E3M5:130:48,
    E3M6:279:23,
    E3M7:198:48,
    E3M8:140:25,
    E3M9:281:136;
ANIM=WIA20000:11:104:168,
     WIA20001:11:104:168,
     WIA20002:11:104:168,#END,
     WIA20100:11:40:136,
     WIA20101:11:40:136,
     WIA20102:11:40:136,#END,
     WIA20200:11:160:96,
     WIA20201:11:160:96,
     WIA20202:11:160:96,#END,
     WIA20300:11:104:80,
     WIA20301:11:104:80,
     WIA20302:11:104:80,#END,
     WIA20400:11:120:32,
     WIA20401:11:120:32,
     WIA20402:11:120:32,#END,
     WIA20500:11:40:0,
     WIA20501:11:40:0,
     WIA20502:11:40:0,#END;</t>
<t tx="T2723">[KNEE_DEEP_IN_THE_DEAD]
INTERMISSION_GRAPHIC="WIMAP0";
INTERMISSION_MUSIC=63;
SPLAT_GRAPHIC="WISPLAT";
YAH1_GRAPHIC="WIURH0";
YAH2_GRAPHIC="WIURH1";
NAME_GRAPHIC="M_EPI1";
PERCENT_SOUND=PISTOL;
DONE_SOUND=BAREXP;
ENDMAP_SOUND=BAREXP;
NEXTMAP_SOUND=SGCOCK;
ACCEL_SOUND="SLOP";
FRAG_SOUND="PLDETH";
FIRSTMAP=E1M1;
TITLE_GRAPHIC="TITLEPIC","HELP2","CREDIT";
TITLE_TIME=170T;
TITLE_MUSIC=62;
MAP=E1M1:185:164,
    E1M2:148:143,
    E1M3:69:122,
    E1M4:209:102,
    E1M5:116:89,
    E1M6:166:55,
    E1M7:71:56,
    E1M8:135:29,
    E1M9:71:24;
ANIM=WIA00000:3:224:104,
     WIA00001:3:224:104,
     WIA00002:3:224:104,#END,
     WIA00100:4:184:160,
     WIA00101:4:184:160,
     WIA00102:4:184:160,#END,
     WIA00200:3:112:136,
     WIA00201:2:112:136,
     WIA00202:3:112:136,#END,
     WIA00300:3:72:112,
     WIA00301:3:72:112,
     WIA00302:4:72:112,#END,
     WIA00400:5:88:96,
     WIA00401:5:88:96,
     WIA00402:3:88:96,#END,
     WIA00500:2:64:48,
     WIA00501:3:64:48,
     WIA00502:2:64:48,#END,
     WIA00600:3:192:40,
     WIA00601:2:192:40,
     WIA00602:3:192:40,#END,
     WIA00700:3:136:16,
     WIA00701:5:136:16,
     WIA00702:3:136:16,#END,
     WIA00800:3:80:16,
     WIA00801:7:80:16,
     WIA00802:3:80:16,#END,
     WIA00900:3:64:24,
     WIA00901:2:64:24,
     WIA00902:3:64:24,#END;</t>
<t tx="T2724">[THE_SHORES_OF_HELL]
INTERMISSION_GRAPHIC="WIMAP1";
INTERMISSION_MUSIC=63;
SPLAT_GRAPHIC="WISPLAT";
YAH1_GRAPHIC="WIURH0";
YAH2_GRAPHIC="WIURH1";
NAME_GRAPHIC="M_EPI2";
PERCENT_SOUND=PISTOL;
DONE_SOUND=BAREXP;
ENDMAP_SOUND=BAREXP;
NEXTMAP_SOUND=SGCOCK;
ACCEL_SOUND="SLOP";
FRAG_SOUND="PLDETH";
FIRSTMAP=E2M1;
MAP=E2M1:254:25,
    E2M2:97:50,
    E2M3:188:64,
    E2M4:128:78,
    E2M5:214:92,
    E2M6:133:130,
    E2M7:208:136,
    E2M8:148:140,
    E2M9:235:158;
ANIM=#E2M2:WIA10000:10:128:136,#END,
     #E2M3:WIA10100:10:128:136,#END,
     #E2M4:WIA10200:10:128:136,#END,
     #E2M5:WIA10300:10:128:136,#END,
     #E2M6:WIA10400:10:128:136,#END,
     #E2M7:WIA10500:10:128:136,#END,
     #E2M8:WIA10600:10:128:136,#END,
     #E2M9:WIA10700:11:192:144,
     WIA10701:11:192:144,
     WIA10702:11:192:144,
     WIA10701:11:192:144,#END,
     #E2M6:WIA10702:-1:192:144,#END;</t>
<t tx="T2725">[THY_FLESH_CONSUMED]
INTERMISSION_GRAPHIC="INTERPIC";
INTERMISSION_MUSIC=63;
NAME_GRAPHIC="M_EPI4";
PERCENT_SOUND=PISTOL;
DONE_SOUND=BAREXP;
ACCEL_SOUND="SLOP";
FRAG_SOUND="PLDETH";
FIRSTMAP=E4M1;</t>
<t tx="T2726">[MAP01]
LUMPNAME=MAP01;
NAME_GRAPHIC=CWILV00;
DESCRIPTION=Map01Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=1;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP02;
PARTIME=30;
EPISODE=HELL_ON_EARTH;

[MAP02]
LUMPNAME=MAP02;
NAME_GRAPHIC=CWILV01;
DESCRIPTION=Map02Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=2;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP03;
PARTIME=90;
EPISODE=HELL_ON_EARTH;

[MAP03]
LUMPNAME=MAP03;
NAME_GRAPHIC=CWILV02;
DESCRIPTION=Map03Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=3;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP04;
PARTIME=120;
EPISODE=HELL_ON_EARTH;

[MAP04]
LUMPNAME=MAP04;
NAME_GRAPHIC=CWILV03;
DESCRIPTION=Map04Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=4;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP05;
PARTIME=120;
EPISODE=HELL_ON_EARTH;

[MAP05]
LUMPNAME=MAP05;
NAME_GRAPHIC=CWILV04;
DESCRIPTION=Map05Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=5;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP06;
PARTIME=90;
EPISODE=HELL_ON_EARTH;

[MAP06]
LUMPNAME=MAP06;
NAME_GRAPHIC=CWILV05;
DESCRIPTION=Map06Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=6;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP07;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP07]
LUMPNAME=MAP07;
NAME_GRAPHIC=CWILV06;
DESCRIPTION=Map07Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=7;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP08;
PARTIME=120;
PRE.TEXT=Level7Text;
PRE.TEXT_FLAT=SLIME16;
PRE.MUSIC="read_m";
EPISODE=HELL_ON_EARTH;

[MAP08]
LUMPNAME=MAP08;
NAME_GRAPHIC=CWILV07;
DESCRIPTION=Map08Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=8;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP09;
PARTIME=120;
EPISODE=HELL_ON_EARTH;

[MAP09]
LUMPNAME=MAP09;
NAME_GRAPHIC=CWILV08;
DESCRIPTION=Map09Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=9;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP10;
PARTIME=270;
EPISODE=HELL_ON_EARTH;

[MAP10]
LUMPNAME=MAP10;
NAME_GRAPHIC=CWILV09;
DESCRIPTION=Map10Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=10;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP11;
PARTIME=90;
EPISODE=HELL_ON_EARTH;

[MAP11]
LUMPNAME=MAP11;
NAME_GRAPHIC=CWILV10;
DESCRIPTION=Map11Desc;
SKY_TEXTURE=SKY1;
MUSIC_ENTRY=11;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP12;
PARTIME=210;
END.TEXT=Level12Text;
END.TEXT_FLAT=RROCK14;
END.MUSIC=60;
EPISODE=HELL_ON_EARTH;

[MAP12]
LUMPNAME=MAP12;
NAME_GRAPHIC=CWILV11;
DESCRIPTION=Map12Desc;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=12;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP13;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP13]
LUMPNAME=MAP13;
DESCRIPTION=Map13Desc;
NAME_GRAPHIC=CWILV12;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=13;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP14;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP14]
LUMPNAME=MAP14;
NAME_GRAPHIC=CWILV13;
DESCRIPTION=Map14Desc;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=14;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP15;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP15]
LUMPNAME=MAP15;
NAME_GRAPHIC=CWILV14;
DESCRIPTION=Map15Desc;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=15;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP16;
SECRET_MAP=MAP31;
PARTIME=210;
EPISODE=HELL_ON_EARTH;

[MAP16]
LUMPNAME=MAP16;
NAME_GRAPHIC=CWILV15;
DESCRIPTION=Map16Desc;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=16;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP17;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP17]
LUMPNAME=MAP17;
NAME_GRAPHIC=CWILV16;
DESCRIPTION=Map17Desc;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=17;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP18;
PARTIME=420;
EPISODE=HELL_ON_EARTH;

[MAP18]
LUMPNAME=MAP18;
NAME_GRAPHIC=CWILV17;
DESCRIPTION=Map18Desc;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=18;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP19;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP19]
LUMPNAME=MAP19;
NAME_GRAPHIC=CWILV18;
DESCRIPTION=Map19Desc;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=19;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP20;
PARTIME=210;
EPISODE=HELL_ON_EARTH;

[MAP20]
LUMPNAME=MAP20;
NAME_GRAPHIC=CWILV19;
DESCRIPTION=Map20Desc;
SKY_TEXTURE=SKY2;
MUSIC_ENTRY=20;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP21;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP21]
LUMPNAME=MAP21;
NAME_GRAPHIC=CWILV20;
DESCRIPTION=Map21Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=21;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP22;
PARTIME=240;
PRE.TEXT=Level21Text;
PRE.TEXT_FLAT=RROCK07;
PRE.MUSIC="read_m";
EPISODE=HELL_ON_EARTH;

[MAP22]
LUMPNAME=MAP22;
NAME_GRAPHIC=CWILV21;
DESCRIPTION=Map22Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=22;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP23;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP23]
LUMPNAME=MAP23;
NAME_GRAPHIC=CWILV22;
DESCRIPTION=Map23Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=23;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP24;
PARTIME=180;
EPISODE=HELL_ON_EARTH;

[MAP24]
LUMPNAME=MAP24;
NAME_GRAPHIC=CWILV23;
DESCRIPTION=Map24Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=24;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP25;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP25]
LUMPNAME=MAP25;
NAME_GRAPHIC=CWILV24;
DESCRIPTION=Map25Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=25;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP26;
PARTIME=150;
EPISODE=HELL_ON_EARTH;

[MAP26]
LUMPNAME=MAP26;
NAME_GRAPHIC=CWILV25;
DESCRIPTION=Map26Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=26;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP27;
PARTIME=300;
EPISODE=HELL_ON_EARTH;

[MAP27]
LUMPNAME=MAP27;
NAME_GRAPHIC=CWILV26;
DESCRIPTION=Map27Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=27;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP28;
PARTIME=330;
EPISODE=HELL_ON_EARTH;

[MAP28]
LUMPNAME=MAP28;
NAME_GRAPHIC=CWILV27;
DESCRIPTION=Map28Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=28;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP29;
PARTIME=420;
EPISODE=HELL_ON_EARTH;

[MAP29]
LUMPNAME=MAP29;
NAME_GRAPHIC=CWILV28;
DESCRIPTION=Map29Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=29;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP30;
PARTIME=300;
EPISODE=HELL_ON_EARTH;

[MAP30]
LUMPNAME=MAP30;
NAME_GRAPHIC=CWILV29;
DESCRIPTION=Map30Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=30;
SURROUND_FLAT=GRNROCK;
PARTIME=180;
SPECIAL=NORMAL_BLOOD;
END.TEXT=EndGameText;
END.TEXT_FLAT=RROCK17;
END.MUSIC=60;
END.CAST=TRUE;
EPISODE=HELL_ON_EARTH;

[MAP31]
LUMPNAME=MAP31;
NAME_GRAPHIC=CWILV30;
DESCRIPTION=Map31Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=31;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP16;
SECRET_MAP=MAP32;
PARTIME=120;
PRE.TEXT=Level31Text;
PRE.TEXT_FLAT=RROCK13;
PRE.MUSIC="read_m";
EPISODE=HELL_ON_EARTH;

[MAP32]
LUMPNAME=MAP32;
NAME_GRAPHIC=CWILV31;
DESCRIPTION=Map32Desc;
SKY_TEXTURE=SKY3;
MUSIC_ENTRY=31;
SURROUND_FLAT=GRNROCK;
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=MAP16;
PARTIME=30;
PRE.TEXT=Level32Text;
PRE.TEXT_FLAT=RROCK19;
PRE.MUSIC="read_m";
EPISODE=HELL_ON_EARTH;</t>
<t tx="T2727">[E3M1]
LUMPNAME=E3M1;
NAME_GRAPHIC=WILV20;
DESCRIPTION=E3M1Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E3M2;
SECRET_MAP=E3M9;
PARTIME=90;
MUSIC_ENTRY=51;
EPISODE=INFERNO;

[E3M2]
LUMPNAME=E3M2;
NAME_GRAPHIC=WILV21;
DESCRIPTION=E3M2Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E3M3;
SECRET_MAP=E3M9;
PARTIME=45;
MUSIC_ENTRY=52;
EPISODE=INFERNO;

[E3M3]
LUMPNAME=E3M3;
NAME_GRAPHIC=WILV22;
DESCRIPTION=E3M3Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E3M4;
SECRET_MAP=E3M9;
PARTIME=90;
MUSIC_ENTRY=53;
EPISODE=INFERNO;

[E3M4]
LUMPNAME=E3M4;
NAME_GRAPHIC=WILV23;
DESCRIPTION=E3M4Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E3M5;
SECRET_MAP=E3M9;
PARTIME=150;
MUSIC_ENTRY=54;
EPISODE=INFERNO;

[E3M5]
LUMPNAME=E3M5;
NAME_GRAPHIC=WILV24;
DESCRIPTION=E3M5Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E3M6;
SECRET_MAP=E3M9;
PARTIME=90;
MUSIC_ENTRY=55;
EPISODE=INFERNO;

[E3M6]
LUMPNAME=E3M6;
NAME_GRAPHIC=WILV25;
DESCRIPTION=E3M6Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E3M7;
SECRET_MAP=E3M9;
PARTIME=90;
MUSIC_ENTRY=56;
EPISODE=INFERNO;

[E3M7]
LUMPNAME=E3M7;
NAME_GRAPHIC=WILV26;
DESCRIPTION=E3M7Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E3M8;
SECRET_MAP=E3M9;
PARTIME=165;
MUSIC_ENTRY=57;
EPISODE=INFERNO;

[E3M8]
LUMPNAME=E3M8;
NAME_GRAPHIC=WILV27;
DESCRIPTION=E3M8Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
SECRET_MAP=E3M9;
PARTIME=30;
MUSIC_ENTRY=58;
EPISODE=INFERNO;
END.TEXT=Episode3Text;
END.TEXT_FLAT="MFLR8_4";
END.MUSIC=61;
END.BUNNY=TRUE;

[E3M9]
LUMPNAME=E3M9;
NAME_GRAPHIC=WILV28;
DESCRIPTION=E3M9Desc;
SKY_TEXTURE=SKY3;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E3M7;
SECRET_MAP=E3M9;
PARTIME=135;
MUSIC_ENTRY=59;
EPISODE=INFERNO;</t>
<t tx="T2728">[E1M1]
LUMPNAME=E1M1;
NAME_GRAPHIC=WILV00;
DESCRIPTION=E1M1Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E1M2;
SECRET_MAP=E1M9;
PARTIME=30;
MUSIC_ENTRY=33;
EPISODE=KNEE_DEEP_IN_THE_DEAD;

[E1M2]
LUMPNAME=E1M2;
NAME_GRAPHIC=WILV01;
DESCRIPTION=E1M2Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E1M3;
SECRET_MAP=E1M9;
PARTIME=75;
MUSIC_ENTRY=34;
EPISODE=KNEE_DEEP_IN_THE_DEAD;

[E1M3]
LUMPNAME=E1M3;
NAME_GRAPHIC=WILV02;
DESCRIPTION=E1M3Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E1M4;
SECRET_MAP=E1M9;
PARTIME=120;
MUSIC_ENTRY=35;
EPISODE=KNEE_DEEP_IN_THE_DEAD;

[E1M4]
LUMPNAME=E1M4;
NAME_GRAPHIC=WILV03;
DESCRIPTION=E1M4Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E1M5;
SECRET_MAP=E1M9;
PARTIME=90;
MUSIC_ENTRY=36;
EPISODE=KNEE_DEEP_IN_THE_DEAD;

[E1M5]
LUMPNAME=E1M5;
NAME_GRAPHIC=WILV04;
DESCRIPTION=E1M5Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E1M6;
SECRET_MAP=E1M9;
PARTIME=165;
MUSIC_ENTRY=37;
EPISODE=KNEE_DEEP_IN_THE_DEAD;

[E1M6]
LUMPNAME=E1M6;
NAME_GRAPHIC=WILV05;
DESCRIPTION=E1M6Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E1M7;
SECRET_MAP=E1M9;
PARTIME=180;
MUSIC_ENTRY=38;
EPISODE=KNEE_DEEP_IN_THE_DEAD;

[E1M7]
LUMPNAME=E1M7;
NAME_GRAPHIC=WILV06;
DESCRIPTION=E1M7Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E1M8;
SECRET_MAP=E1M9;
PARTIME=180;
MUSIC_ENTRY=39;
EPISODE=KNEE_DEEP_IN_THE_DEAD;

[E1M8]
LUMPNAME=E1M8;
NAME_GRAPHIC=WILV07;
DESCRIPTION=E1M8Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
SECRET_MAP=E1M9;
PARTIME=30;
MUSIC_ENTRY=40;
EPISODE=KNEE_DEEP_IN_THE_DEAD;

END.TEXT=Episode1Text;
END.TEXT_FLAT="FLOOR4_8";
END.MUSIC=61;
END.GRAPHIC="CREDIT";
END.GRAPHIC_WAIT=MAXT;


[E1M9]
LUMPNAME=E1M9;
NAME_GRAPHIC=WILV08;
DESCRIPTION=E1M9Desc;
SKY_TEXTURE=SKY1;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E1M4;
SECRET_MAP=E1M9;
PARTIME=165;
MUSIC_ENTRY=41;
EPISODE=KNEE_DEEP_IN_THE_DEAD;</t>
<t tx="T2729">[E2M1]
LUMPNAME=E2M1;
NAME_GRAPHIC=WILV10;
DESCRIPTION=E2M1Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E2M2;
SECRET_MAP=E2M9;
PARTIME=90;
MUSIC_ENTRY=42;
EPISODE=THE_SHORES_OF_HELL;

[E2M2]
LUMPNAME=E2M2;
NAME_GRAPHIC=WILV11;
DESCRIPTION=E2M2Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E2M3;
SECRET_MAP=E2M9;
PARTIME=90;
MUSIC_ENTRY=43;
EPISODE=THE_SHORES_OF_HELL;

[E2M3]
LUMPNAME=E2M3;
NAME_GRAPHIC=WILV12;
DESCRIPTION=E2M3Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E2M4;
SECRET_MAP=E2M9;
PARTIME=90;
MUSIC_ENTRY=44;
EPISODE=THE_SHORES_OF_HELL;

[E2M4]
LUMPNAME=E2M4;
NAME_GRAPHIC=WILV13;
DESCRIPTION=E2M4Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E2M5;
SECRET_MAP=E2M9;
PARTIME=120;
MUSIC_ENTRY=45;
EPISODE=THE_SHORES_OF_HELL;

[E2M5]
LUMPNAME=E2M5;
NAME_GRAPHIC=WILV14;
DESCRIPTION=E2M5Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E2M6;
SECRET_MAP=E2M9;
PARTIME=90;
MUSIC_ENTRY=46;
EPISODE=THE_SHORES_OF_HELL;

[E2M6]
LUMPNAME=E2M6;
NAME_GRAPHIC=WILV15;
DESCRIPTION=E2M6Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E2M7;
SECRET_MAP=E2M9;
PARTIME=360;
MUSIC_ENTRY=47;
EPISODE=THE_SHORES_OF_HELL;

[E2M7]
LUMPNAME=E2M7;
NAME_GRAPHIC=WILV16;
DESCRIPTION=E2M7Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E2M8;
SECRET_MAP=E2M9;
PARTIME=240;
MUSIC_ENTRY=48;
EPISODE=THE_SHORES_OF_HELL;

[E2M8]
LUMPNAME=E2M8;
NAME_GRAPHIC=WILV17;
DESCRIPTION=E2M8Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
SECRET_MAP=E2M9;
PARTIME=30;
MUSIC_ENTRY=49;
EPISODE=THE_SHORES_OF_HELL;
END.TEXT=Episode2Text;
END.TEXT_FLAT="SFLR6_1";
END.MUSIC=61;
END.GRAPHIC="VICTORY2";
END.GRAPHIC_WAIT=MAXT;

[E2M9]
LUMPNAME=E2M9;
NAME_GRAPHIC=WILV18;
DESCRIPTION=E2M9Desc;
SKY_TEXTURE=SKY2;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E2M6;
SECRET_MAP=E2M9;
PARTIME=170;
MUSIC_ENTRY=50;
EPISODE=THE_SHORES_OF_HELL;</t>
<t tx="T2730">[E4M1]
LUMPNAME=E4M1;
NAME_GRAPHIC=WILV30;
DESCRIPTION=E4M1Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E4M2;
SECRET_MAP=E4M9;
MUSIC_ENTRY=54;
EPISODE=THY_FLESH_CONSUMED;

[E4M2]
LUMPNAME=E4M2;
NAME_GRAPHIC=WILV31;
DESCRIPTION=E4M2Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E4M3;
SECRET_MAP=E4M9;
MUSIC_ENTRY=52;
EPISODE=THY_FLESH_CONSUMED;

[E4M3]
LUMPNAME=E4M3;
NAME_GRAPHIC=WILV32;
DESCRIPTION=E4M3Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E4M4;
SECRET_MAP=E4M9;
MUSIC_ENTRY=53;
EPISODE=THY_FLESH_CONSUMED;

[E4M4]
LUMPNAME=E4M4;
NAME_GRAPHIC=WILV33;
DESCRIPTION=E4M4Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E4M5;
SECRET_MAP=E4M9;
MUSIC_ENTRY=37;
EPISODE=THY_FLESH_CONSUMED;

[E4M5]
LUMPNAME=E4M5;
NAME_GRAPHIC=WILV34;
DESCRIPTION=E4M5Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E4M6;
SECRET_MAP=E4M9;
MUSIC_ENTRY=48;
EPISODE=THY_FLESH_CONSUMED;

[E4M6]
LUMPNAME=E4M6;
NAME_GRAPHIC=WILV35;
DESCRIPTION=E4M6Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E4M7;
SECRET_MAP=E4M9;
MUSIC_ENTRY=45;
EPISODE=THY_FLESH_CONSUMED;

[E4M7]
LUMPNAME=E4M7;
NAME_GRAPHIC=WILV36;
DESCRIPTION=E4M7Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E4M8;
SECRET_MAP=E4M9;
MUSIC_ENTRY=47;
EPISODE=THY_FLESH_CONSUMED;

[E4M8]
LUMPNAME=E4M8;
NAME_GRAPHIC=WILV37;
DESCRIPTION=E4M8Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
SECRET_MAP=E4M9;
MUSIC_ENTRY=46;
EPISODE=THY_FLESH_CONSUMED;
END.TEXT=Episode4Text;
END.TEXT_FLAT="MFLR8_3";
END.MUSIC=61;
END.GRAPHIC="ENDPIC";
END.GRAPHIC_WAIT=MAXT;

[E4M9]
LUMPNAME=E4M9;
NAME_GRAPHIC=WILV38;
DESCRIPTION=E4M9Desc;
SKY_TEXTURE=SKY4;
SURROUND_FLAT="FLOOR7_2";
SPECIAL=NO_ENEMY_STOMP;
NEXT_MAP=E4M3;
SECRET_MAP=E4M9;
MUSIC_ENTRY=41;
EPISODE=THY_FLESH_CONSUMED;</t>
<t tx="T2731">[ARACHNOTRON:68]
SPAWNHEALTH=500;
REACTION_TIME=0.23;
RADIUS=64;
HEIGHT=64;
SPEED=12;
MASS=600;
PAINCHANCE=50%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE;
MINATTACK_CHANCE=22%;
BLOOD=BLOOD;
CASTORDER=11;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=BSPACT;
DEATH_SOUND=BSPDTH;
PAIN_SOUND=DMPAIN;
SIGHTING_SOUND=BSPSIT;
WALK_SOUND=BSPWLK;
RANGE_ATTACK=ARACHNOTRON_PLASMA;

STATES(IDLE)=BSPI:A:10:NORMAL:LOOKOUT,
             BSPI:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=BSPI:A:20:NORMAL:NOTHING,
              BSPI:A:3:NORMAL:WALKSOUND_CHASE,
              BSPI:A:3:NORMAL:CHASE,
              BSPI:B:3:NORMAL:CHASE,
              BSPI:B:3:NORMAL:CHASE,
              BSPI:C:3:NORMAL:CHASE,
              BSPI:C:3:NORMAL:CHASE,
              BSPI:D:3:NORMAL:WALKSOUND_CHASE,
              BSPI:D:3:NORMAL:CHASE,
              BSPI:E:3:NORMAL:CHASE,
              BSPI:E:3:NORMAL:CHASE,
              BSPI:F:3:NORMAL:CHASE,
              BSPI:F:3:NORMAL:CHASE, 
              #CHASE:2;

STATES(MISSILE)=BSPI:A:20:BRIGHT:FACETARGET,
                BSPI:G:4:BRIGHT:RANGE_ATTACK,
                BSPI:H:4:BRIGHT:NOTHING,
                BSPI:H:1:BRIGHT:REFIRE_CHECK,
                #MISSILE:2;

STATES(PAIN)=BSPI:I:3:NORMAL:NOTHING,
             BSPI:I:3:NORMAL:MAKEPAINSOUND,
             #CHASE:2;

STATES(DEATH)=BSPI:J:20:NORMAL:MAKEDEATHSOUND,
              BSPI:K:7:NORMAL:MAKEDEAD,
              BSPI:L:7:NORMAL:NOTHING,
              BSPI:M:7:NORMAL:NOTHING,
              BSPI:N:7:NORMAL:NOTHING,
              BSPI:O:7:NORMAL:NOTHING,
              BSPI:P:-1:NORMAL:NOTHING;

STATES(RESPAWN)=BSPI:P:5:NORMAL:NOTHING,
                BSPI:O:5:NORMAL:NOTHING,
                BSPI:N:5:NORMAL:NOTHING,
                BSPI:M:5:NORMAL:NOTHING,
                BSPI:L:5:NORMAL:NOTHING,
                BSPI:K:5:NORMAL:NOTHING,
                BSPI:J:5:NORMAL:NOTHING,
                #CHASE:2;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2732">[ARCHVILE:64]
SPAWNHEALTH=700;
REACTION_TIME=0.23;
RADIUS=20;
HEIGHT=56;
SPEED=15;
MASS=500;
PAINCHANCE=4%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,NEVERTARGETED,NO_GRUDGE,NO_RESURRECT;
MINATTACK_CHANCE=22%;
CASTORDER=15;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=VILACT;
DEATH_SOUND=VILDTH;
PAIN_SOUND=VIPAIN;
SIGHTING_SOUND=VILSIT;
RANGE_ATTACK=ARCHVILE_FIRE;

STATES(IDLE)=VILE:A:10:NORMAL:LOOKOUT,
             VILE:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=VILE:A:2:NORMAL:RESCHASE,
              VILE:A:2:NORMAL:RESCHASE,
              VILE:B:2:NORMAL:RESCHASE,
              VILE:B:2:NORMAL:RESCHASE,
              VILE:C:2:NORMAL:RESCHASE,
              VILE:C:2:NORMAL:RESCHASE,
              VILE:D:2:NORMAL:RESCHASE,
              VILE:D:2:NORMAL:RESCHASE,
              VILE:E:2:NORMAL:RESCHASE,
              VILE:E:2:NORMAL:RESCHASE,
              VILE:F:2:NORMAL:RESCHASE,
              VILE:F:2:NORMAL:RESCHASE;

STATES(MISSILE)=VILE:G:0:BRIGHT:RANGEATTEMPTSND,
                VILE:G:10:BRIGHT:FACETARGET,
                VILE:H:8:BRIGHT:RANGE_ATTACK,
                VILE:I:8:BRIGHT:FACETARGET,
                VILE:J:8:BRIGHT:FACETARGET,
                VILE:K:8:BRIGHT:FACETARGET,
                VILE:L:8:BRIGHT:FACETARGET,
                VILE:M:8:BRIGHT:FACETARGET,
                VILE:N:8:BRIGHT:FACETARGET,
                VILE:O:8:BRIGHT:EFFECTTRACKER,
                VILE:P:20:BRIGHT:NOTHING,
                #CHASE;

STATES(PAIN)=VILE:Q:5:NORMAL:NOTHING,
             VILE:Q:5:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=VILE:Q:7:NORMAL:NOTHING,
              VILE:R:7:NORMAL:MAKEDEATHSOUND,
              VILE:S:7:NORMAL:MAKEDEAD,
              VILE:T:7:NORMAL:NOTHING,
              VILE:U:7:NORMAL:NOTHING,
              VILE:V:7:NORMAL:NOTHING,
              VILE:W:7:NORMAL:NOTHING,
              VILE:X:5:NORMAL:NOTHING,
              VILE:Y:5:NORMAL:NOTHING,
              VILE:Z:-1:NORMAL:NOTHING;

STATES(RESPAWN)=VILE:Z:5:NORMAL:NOTHING,
                VILE:Y:5:NORMAL:NOTHING,
                VILE:X:5:NORMAL:NOTHING,
                VILE:W:7:NORMAL:NOTHING,
                VILE:V:7:NORMAL:NOTHING,
                VILE:U:7:NORMAL:NOTHING,
                VILE:T:7:NORMAL:NOTHING,
                VILE:S:7:NORMAL:NOTHING,
                VILE:R:7:NORMAL:NOTHING,
                VILE:Q:7:NORMAL:NOTHING,
                #CHASE;

STATES(RESURRECT)=VILE:[:10:BRIGHT:NOTHING,
                  VILE:\:10:BRIGHT:NOTHING,
                  VILE:]:10:BRIGHT:NOTHING,
                  #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2733">[BARON_OF_HELL:3003]
SPAWNHEALTH=1000;
REACTION_TIME=0.23;
RADIUS=24;
HEIGHT=64;
SPEED=8;
MASS=1000;
PAINCHANCE=20%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE;
MINATTACK_CHANCE=22%;
CASTORDER=10;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=BRSDTH;
PAIN_SOUND=DMPAIN;
SIGHTING_SOUND=BRSSIT;
RANGE_ATTACK=BARON_FIREBALL;
CLOSE_ATTACK=BARON_CLOSECOMBAT;

STATES(IDLE)=BOSS:A:10:NORMAL:LOOKOUT,
             BOSS:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=BOSS:A:3:NORMAL:CHASE,
              BOSS:A:3:NORMAL:CHASE,
              BOSS:B:3:NORMAL:CHASE,
              BOSS:B:3:NORMAL:CHASE,
              BOSS:C:3:NORMAL:CHASE,
              BOSS:C:3:NORMAL:CHASE,
              BOSS:D:3:NORMAL:CHASE,
              BOSS:D:3:NORMAL:CHASE;

STATES(MELEE)=BOSS:E:8:NORMAL:FACETARGET,
              BOSS:F:8:NORMAL:FACETARGET,
              BOSS:G:8:NORMAL:COMBOATTACK,
              #CHASE;

STATES(MISSILE)=BOSS:E:8:NORMAL:FACETARGET,
                BOSS:F:8:NORMAL:FACETARGET,
                BOSS:G:8:NORMAL:COMBOATTACK,
                #CHASE;

STATES(PAIN)=BOSS:H:2:NORMAL:NOTHING,
             BOSS:H:2:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=BOSS:I:8:NORMAL:NOTHING,
              BOSS:J:8:NORMAL:MAKEDEATHSOUND,
              BOSS:K:8:NORMAL:NOTHING,
              BOSS:L:8:NORMAL:MAKEDEAD,
              BOSS:M:8:NORMAL:NOTHING,
              BOSS:N:8:NORMAL:NOTHING,
              BOSS:O:-1:NORMAL:NOTHING;

STATES(RESPAWN)=BOSS:O:8:NORMAL:NOTHING,
                BOSS:N:8:NORMAL:NOTHING,
                BOSS:M:8:NORMAL:NOTHING,
                BOSS:L:8:NORMAL:NOTHING,
                BOSS:K:8:NORMAL:NOTHING,
                BOSS:J:8:NORMAL:NOTHING,
                BOSS:I:8:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2734">[CACODEMON:3005]
SPAWNHEALTH=400;
REACTION_TIME=0.23;
RADIUS=31;
HEIGHT=56;
SPEED=8;
MASS=400;
PAINCHANCE=50%;
FLOAT_SPEED=4;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,FLOATER;
MINATTACK_CHANCE=22%;
CASTORDER=8;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=CACDTH;
PAIN_SOUND=DMPAIN;
SIGHTING_SOUND=CACSIT;
RANGE_ATTACK=CACO_FIREBALL;
CLOSE_ATTACK=CACO_CLOSECOMBAT;

STATES(IDLE)=HEAD:A:10:NORMAL:LOOKOUT;

STATES(CHASE)=HEAD:A:3:NORMAL:CHASE;

STATES(MISSILE)=HEAD:B:5:NORMAL:FACETARGET,
                HEAD:C:5:NORMAL:FACETARGET,
                HEAD:D:5:BRIGHT:COMBOATTACK,
                #CHASE;

STATES(PAIN)=HEAD:E:3:NORMAL:NOTHING,
             HEAD:E:3:NORMAL:MAKEPAINSOUND,
             HEAD:F:6:NORMAL:NOTHING,
             #CHASE;

STATES(DEATH)=HEAD:G:8:NORMAL:MAKEDEATHSOUND,
              HEAD:H:8:NORMAL:NOTHING,
              HEAD:I:8:NORMAL:NOTHING,
              HEAD:J:8:NORMAL:MAKEDEAD,
              HEAD:K:8:NORMAL:NOTHING,
              HEAD:L:-1:NORMAL:NOTHING;

STATES(RESPAWN)=HEAD:L:8:NORMAL:NOTHING,
                HEAD:K:8:NORMAL:NOTHING,
                HEAD:J:8:NORMAL:NOTHING,
                HEAD:I:8:NORMAL:NOTHING,
                HEAD:H:8:NORMAL:NOTHING,
                HEAD:G:8:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2735">[COMMANDER_KEEN:72]
SPAWNHEALTH=100;
REACTION_TIME=0.23;
RADIUS=16;
HEIGHT=72;
MASS=10000;
PAINCHANCE=100%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,ON_CEILING;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
PAIN_SOUND=KEENPN;
DEATH_SOUND=KEENDT;

STATES(IDLE)=KEEN:A:-1:NORMAL:NOTHING;

STATES(PAIN)=KEEN:M:4:NORMAL:NOTHING,
            KEEN:M:8:NORMAL:MAKEPAINSOUND;

STATES(DEATH)=KEEN:A:6:NORMAL:NOTHING,
              KEEN:B:6:NORMAL:NOTHING,
              KEEN:C:6:NORMAL:MAKEDEATHSOUND,
              KEEN:D:6:NORMAL:NOTHING,
              KEEN:E:6:NORMAL:NOTHING,
              KEEN:F:6:NORMAL:NOTHING,
              KEEN:G:6:NORMAL:NOTHING,
              KEEN:H:6:NORMAL:NOTHING,
              KEEN:I:6:NORMAL:NOTHING,
              KEEN:J:6:NORMAL:NOTHING,
              KEEN:K:6:NORMAL:NOTHING,
              KEEN:L:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2736">[THE_CYBERDEMON:16]
SPAWNHEALTH=4000;
REACTION_TIME=0.23;
RADIUS=40;
HEIGHT=110;
SPEED=16;
MASS=1000;
PAINCHANCE=8%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,BOSSMAN,TRIGGER_HAPPY,NO_RESURRECT;
MINATTACK_CHANCE=38%;
CASTORDER=17;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=CYBDTH;
PAIN_SOUND=DMPAIN;
SIGHTING_SOUND=CYBSIT;
WALK_SOUND=HOOF;
RANGE_ATTACK=CYBERDEMON_MISSILE;

STATES(IDLE)=CYBR:A:10:NORMAL:LOOKOUT,
             CYBR:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=CYBR:A:3:NORMAL:CHASE,
              CYBR:A:3:NORMAL:CHASE,
              CYBR:B:3:NORMAL:CHASE,
              CYBR:B:3:NORMAL:CHASE,
              CYBR:C:3:NORMAL:CHASE,
              CYBR:C:3:NORMAL:CHASE,
              CYBR:D:3:NORMAL:WALKSOUND_CHASE,
              CYBR:D:3:NORMAL:CHASE;

STATES(MISSILE)=CYBR:E:6:NORMAL:FACETARGET,
                CYBR:F:12:NORMAL:RANGE_ATTACK,
                CYBR:E:12:NORMAL:FACETARGET,
                CYBR:F:12:NORMAL:RANGE_ATTACK,
                CYBR:E:12:NORMAL:FACETARGET,
                CYBR:F:12:NORMAL:RANGE_ATTACK,
                #CHASE;

STATES(PAIN)=CYBR:G:10:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=CYBR:H:10:NORMAL:NOTHING,
              CYBR:I:10:NORMAL:MAKEDEATHSOUND,
              CYBR:K:10:NORMAL:NOTHING,
              CYBR:L:10:NORMAL:NOTHING,
              CYBR:M:10:NORMAL:NOTHING,
              CYBR:N:10:NORMAL:MAKEDEAD,
              CYBR:O:10:NORMAL:NOTHING,
              CYBR:P:30:NORMAL:NOTHING,
              CYBR:P:-1:NORMAL:NOTHING;

STATES(RESPAWN)=CYBR:P:30:NORMAL:NOTHING,
                CYBR:O:10:NORMAL:NOTHING,
                CYBR:N:10:NORMAL:NOTHING,
                CYBR:M:10:NORMAL:NOTHING,
                CYBR:L:10:NORMAL:NOTHING,
                CYBR:K:10:NORMAL:NOTHING,
                CYBR:J:10:NORMAL:NOTHING,
                CYBR:I:10:NORMAL:NOTHING,
                CYBR:H:10:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2737">[DEMON:3002]
SPAWNHEALTH=150;
REACTION_TIME=0.23;
RADIUS=30;
HEIGHT=56;
SPEED=10;
FAST=2;
MASS=400;
PAINCHANCE=70%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE;
CASTORDER=6;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=SGTDTH;
PAIN_SOUND=DMPAIN;
SIGHTING_SOUND=SGTSIT;
STARTCOMBAT_SOUND=SGTATK;
CLOSE_ATTACK=DEMON_CLOSECOMBAT;

STATES(IDLE)=SARG:A:10:NORMAL:LOOKOUT,
             SARG:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=SARG:A:2:NORMAL:CHASE,
              SARG:A:2:NORMAL:CHASE,
              SARG:B:2:NORMAL:CHASE,
              SARG:B:2:NORMAL:CHASE,
              SARG:C:2:NORMAL:CHASE,
              SARG:C:2:NORMAL:CHASE,
              SARG:D:2:NORMAL:CHASE,
              SARG:D:2:NORMAL:CHASE;

STATES(MELEE)=SARG:E:8:NORMAL:FACETARGET,
              SARG:F:8:NORMAL:FACETARGET,
              SARG:G:8:NORMAL:CLOSE_ATTACK,
              #CHASE;

STATES(PAIN)=SARG:H:2:NORMAL:NOTHING,
             SARG:H:2:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=SARG:I:8:NORMAL:NOTHING,
              SARG:J:8:NORMAL:MAKEDEATHSOUND,
              SARG:K:4:NORMAL:NOTHING,
              SARG:L:4:NORMAL:MAKEDEAD,
              SARG:M:4:NORMAL:NOTHING,
              SARG:N:-1:NORMAL:NOTHING;

STATES(RESPAWN)=SARG:N:5:NORMAL:NOTHING,
                 SARG:M:5:NORMAL:NOTHING,
                 SARG:L:5:NORMAL:NOTHING,
                 SARG:K:5:NORMAL:NOTHING,
                 SARG:J:5:NORMAL:NOTHING,
                 SARG:I:5:NORMAL:NOTHING,
                 #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2738">[HEAVY_WEAPON_DUDE:65]
SPAWNHEALTH=70;
REACTION_TIME=0.23;
RADIUS=20;
HEIGHT=56;
SPEED=8;
MASS=100;
PAINCHANCE=67%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,DISLOYAL,ATTACK_HURTS;
MINATTACK_CHANCE=22%;
CASTORDER=4;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND="POSACT";
DEATH_SOUND="PODTH?";
PAIN_SOUND=POPAIN;
SIGHTING_SOUND="POSIT?";
OVERKILL_SOUND="SLOP";
DROPITEM=CHAINGUN;
RANGE_ATTACK=FORMER_HUMAN_CHAINGUN;

STATES(IDLE)=CPOS:A:10:NORMAL:LOOKOUT,
             CPOS:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=CPOS:A:3:NORMAL:CHASE,
              CPOS:A:3:NORMAL:CHASE,
              CPOS:B:3:NORMAL:CHASE,
              CPOS:B:3:NORMAL:CHASE,
              CPOS:C:3:NORMAL:CHASE,
              CPOS:C:3:NORMAL:CHASE,
              CPOS:D:3:NORMAL:CHASE,
              CPOS:D:3:NORMAL:CHASE;

STATES(MISSILE)=CPOS:E:10:NORMAL:FACETARGET,
                CPOS:F:4:BRIGHT:RANGE_ATTACK,
                CPOS:E:4:BRIGHT:RANGE_ATTACK,
                CPOS:F:1:NORMAL:REFIRE_CHECK,
                #MISSILE:2;

STATES(PAIN)=CPOS:G:3:NORMAL:NOTHING,
             CPOS:G:3:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=CPOS:H:5:NORMAL:NOTHING,
              CPOS:I:5:NORMAL:MAKEDEATHSOUND,
              CPOS:J:5:NORMAL:MAKEDEAD,
              CPOS:K:5:NORMAL:NOTHING,
              CPOS:L:5:NORMAL:NOTHING,
              CPOS:M:5:NORMAL:NOTHING,
              CPOS:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=CPOS:O:5:NORMAL:NOTHING,
                 CPOS:P:5:NORMAL:MAKEOVERKILLSOUND,
                 CPOS:Q:5:NORMAL:MAKEDEAD,
                 CPOS:R:5:NORMAL:NOTHING,
                 CPOS:S:5:NORMAL:NOTHING,
                 CPOS:T:-1:NORMAL:NOTHING;

STATES(RESPAWN)=CPOS:K:5:NORMAL:NOTHING,
                CPOS:J:5:NORMAL:NOTHING,
                CPOS:I:5:NORMAL:NOTHING,
                CPOS:H:5:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2739"></t>
<t tx="T2740">[SMALL_BOLLARD_LAMP:2028]
RADIUS=16;
HEIGHT=46;
SPECIAL=SOLID,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=150;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=COLU:A:-1:BRIGHT:NOTHING;

[SMALL_TECH_LAMP:86]
RADIUS=16;
HEIGHT=58;
SPECIAL=SOLID,CLIMBABLE,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=200;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=TLP2:A:4:BRIGHT:NOTHING,
             TLP2:B:4:BRIGHT:NOTHING,
             TLP2:C:4:BRIGHT:NOTHING,
             TLP2:D:4:BRIGHT:NOTHING;
			 
[TALL_TECH_LAMP:85]
RADIUS=16;
HEIGHT=78;
SPECIAL=SOLID,CLIMBABLE,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FFFFFF;

STATES(IDLE)=TLMP:A:4:BRIGHT:NOTHING,
             TLMP:B:4:BRIGHT:NOTHING,
             TLMP:C:4:BRIGHT:NOTHING,
             TLMP:D:4:BRIGHT:NOTHING;</t>
<t tx="T2744">[BRONZE_BLUE_TORCH:44]
RADIUS=16;
HEIGHT=96;
SPECIAL=SOLID,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#0000C0;

STATES(IDLE)=TBLU:A:4:BRIGHT:NOTHING,
             TBLU:B:4:BRIGHT:NOTHING,
             TBLU:C:4:BRIGHT:NOTHING,
             TBLU:D:4:BRIGHT:NOTHING;

[BRONZE_GREEN_TORCH:45]
RADIUS=16;
HEIGHT=96;
SPECIAL=SOLID,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#00C000;

STATES(IDLE)=TGRN:A:4:BRIGHT:NOTHING,
             TGRN:B:4:BRIGHT:NOTHING,
             TGRN:C:4:BRIGHT:NOTHING,
             TGRN:D:4:BRIGHT:NOTHING;

[BRONZE_RED_TORCH:46]
RADIUS=16;
HEIGHT=96;
SPECIAL=SOLID,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FF0000;

STATES(IDLE)=TRED:A:4:BRIGHT:NOTHING,
             TRED:B:4:BRIGHT:NOTHING,
             TRED:C:4:BRIGHT:NOTHING,
             TRED:D:4:BRIGHT:NOTHING;

[WOODEN_BLUE_TORCH:55]
RADIUS=16;
HEIGHT=72;
SPECIAL=SOLID,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#0000C0;

STATES(IDLE)=SMBT:A:4:BRIGHT:NOTHING,
             SMBT:B:4:BRIGHT:NOTHING,
             SMBT:C:4:BRIGHT:NOTHING,
             SMBT:D:4:BRIGHT:NOTHING;
                         
[WOODEN_GREEN_TORCH:56]
RADIUS=16;
HEIGHT=72;
SPECIAL=SOLID,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#00C000;

STATES(IDLE)=SMGT:A:4:BRIGHT:NOTHING,
             SMGT:B:4:BRIGHT:NOTHING,
             SMGT:C:4:BRIGHT:NOTHING,
             SMGT:D:4:BRIGHT:NOTHING;

[WOODEN_RED_TORCH:57]
RADIUS=16;
HEIGHT=72;
SPECIAL=SOLID,NOSHADOW;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FF0000;

STATES(IDLE)=SMRT:A:4:BRIGHT:NOTHING,
             SMRT:B:4:BRIGHT:NOTHING,
             SMRT:C:4:BRIGHT:NOTHING,
             SMRT:D:4:BRIGHT:NOTHING;</t>
<t tx="T2745"></t>
<t tx="T2746">[BURNING_BARREL:70]
RADIUS=16;
HEIGHT=42;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FFFF40;

SPECIAL=SOLID,CLIMBABLE,NOSHADOW;

STATES(IDLE)=FCAN:A:4:BRIGHT:NOTHING,
             FCAN:B:4:BRIGHT:NOTHING,
             FCAN:C:4:BRIGHT:NOTHING;</t>
<t tx="T2747">[BARREL:2035]
SPAWNHEALTH=20;
RADIUS=10;
HEIGHT=42;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=0;
DLIGHT.COLOUR=#FFFFFF;

EXPLODE_DAMAGE.VAL=128;
DEATH_SOUND=BAREXP; // Barrel Explosion
SPECIAL=SHOOTABLE,SOLID,CLIMBABLE,DAMAGESMOKE;
STATES(IDLE)=BAR1:A:6:NORMAL:NOTHING,
             BAR1:B:6:NORMAL:NOTHING;
STATES(DEATH)=BEXP:A:0:BRIGHT:DLIGHT_SET(900),
              BEXP:A:0:BRIGHT:DLIGHT_FADE(0),
              BEXP:A:5:BRIGHT:NOTHING,
              BEXP:B:5:BRIGHT:MAKEDEATHSOUND,   
              BEXP:C:5:BRIGHT:NOTHING,          
              BEXP:D:10:BRIGHT:EXPLOSIONDAMAGE, 
              BEXP:E:10:BRIGHT:NOTHING,        
             #REMOVE;</t>
<t tx="T2748">// A quick demo of the varying damage calculation, barrels shouldn't normally
// explode with same results as another: toxic sludge can cause major damage
// or not much at all, worth a laugh. -ACB- 1998/07/26

[UNSTABLE_BARREL:7104]
SPAWNHEALTH=20;
RADIUS=10;
HEIGHT=42;
EXPLODE_DAMAGE.VAL=16;
EXPLODE_DAMAGE.MAX=256;
DEATH_SOUND=BAREXP;
SPECIAL=SHOOTABLE,SOLID,DAMAGESMOKE;

STATES(IDLE)=BAR1:A:6:NORMAL:NOTHING,
             BAR1:B:6:NORMAL:NOTHING;

STATES(DEATH)=BEXP:A:5:BRIGHT:NOTHING,
              BEXP:B:5:BRIGHT:MAKEDEATHSOUND,
              BEXP:C:5:BRIGHT:NOTHING,
              BEXP:D:10:BRIGHT:EXPLOSIONDAMAGE,
              BEXP:E:10:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2749"></t>
<t tx="T2750">[POOL_OF_BLOOD:24]
RADIUS=20;
HEIGHT=16;
SPECIAL=NOSHADOW;
STATES(IDLE)=POL5:A:-1:NORMAL:NOTHING;</t>
<t tx="T2751">[BLOOD]
REACTION_TIME=8T;
RADIUS=8;
HEIGHT=16;
SPECIAL=CORPSE,DROPOFF,NOSHADOW;

STATES(SPAWN)=BLUD:C:8:NORMAL:NOTHING,
              BLUD:B:8:NORMAL:NOTHING,
              BLUD:A:8:NORMAL:CHECKBLOOD,
              #REMOVE;</t>
<t tx="T2752">[DEAD_GIBBER_PLAYER1:10]
RADIUS=20;
HEIGHT=16;

STATES(IDLE)=PLAY:W:-1:NORMAL:NOTHING;

[DEAD_GIBBED_PLAYER2:12]
RADIUS=20;
HEIGHT=16;

STATES(IDLE)=PLAY:W:-1:NORMAL:NOTHING;

[DEAD_PLAYER:15]
RADIUS=20;
HEIGHT=16;

STATES(IDLE)=PLAY:N:-1:NORMAL:NOTHING;

[DEAD_FORMER_HUMAN:18]
RADIUS=20;
HEIGHT=16;

STATES(IDLE)=POSS:L:-1:NORMAL:NOTHING;

[DEAD_FORMER_SARG:19]
RADIUS=20;
HEIGHT=16;

STATES(IDLE)=SPOS:L:-1:NORMAL:NOTHING;

[DEAD_IMP:20]
RADIUS=20;
HEIGHT=16;

STATES(IDLE)=TROO:M:-1:NORMAL:NOTHING;

[DEAD_DEMON:21]
RADIUS=20;
HEIGHT=16;

STATES(IDLE)=SARG:N:-1:NORMAL:NOTHING;

[DEAD_CACODEMON:22]
RADIUS=20;
HEIGHT=16;

STATES(IDLE)=HEAD:L:-1:NORMAL:NOTHING;

[DEAD_LOSTSOUL:23]
RADIUS=20;
HEIGHT=16;
TRANSLUCENCY=20%;

STATES(IDLE)=SKUL:A:-1:NORMAL:NOTHING;</t>
<t tx="T2753">[SKULL_ON_A_STICK:27]
RADIUS=16;
HEIGHT=52;
SPECIAL=SOLID;

STATES(IDLE)=POL4:A:-1:NORMAL:NOTHING;

[HEADS_ON_A_STICK:28]
RADIUS=20;
HEIGHT=64;
SPECIAL=SOLID;

STATES(IDLE)=POL2:A:-1:NORMAL:NOTHING;

[SKULL_CENTREPIECE:29]
RADIUS=20;
HEIGHT=40;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FFFF40;
SPECIAL=SOLID,NOSHADOW;

STATES(IDLE)=POL3:A:6:BRIGHT:NOTHING,
             POL3:B:6:BRIGHT:NOTHING;</t>
<t tx="T2754">[EYE_SYMBOL:41]
RADIUS=16;
HEIGHT=56;
SPECIAL=SOLID;

STATES(IDLE)=CEYE:A:6:BRIGHT:NOTHING,
             CEYE:B:6:BRIGHT:NOTHING,
             CEYE:C:6:BRIGHT:NOTHING,
             CEYE:B:6:BRIGHT:NOTHING;</t>
<t tx="T2755">// These three: Brain stem and the pools of blood are declared as INERT,
// this is because that they are completely unaffected by surroundings
[POOL_OF_BLOOD_I:79]
SPECIAL=NOSHADOW;
RADIUS=20;
HEIGHT=16;
SPECIAL=INERT;

STATES(IDLE)=POB1:A:-1:NORMAL:NOTHING;

[POOL_OF_BLOOD_II:80]
SPECIAL=NOSHADOW;
RADIUS=20;
HEIGHT=16;
SPECIAL=INERT;

STATES(IDLE)=POB2:A:-1:NORMAL:NOTHING;

[BRAINSTEM:81]
SPECIAL=NOSHADOW;
RADIUS=20;
HEIGHT=16;
SPECIAL=INERT;

STATES(IDLE)=BRS1:A:-1:NORMAL:NOTHING;</t>
<t tx="T2756">[FLOATING_SKULLROCK:42]
RADIUS=16;
HEIGHT=48;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FFFF40;

SPECIAL=SOLID,CLIMBABLE,NOSHADOW;

STATES(IDLE)=FSKU:A:6:BRIGHT:NOTHING,
             FSKU:B:6:BRIGHT:NOTHING,
             FSKU:C:6:BRIGHT:NOTHING;</t>
<t tx="T2757">[SHORT_GREEN_COLUMN:31]
RADIUS=16;
HEIGHT=38;
SPECIAL=SOLID,CLIMBABLE;

STATES(IDLE)=COL2:A:-1:NORMAL:NOTHING;

[TALL_RED_COLUMN:32]
RADIUS=16;
HEIGHT=50;
SPECIAL=SOLID,CLIMBABLE;

STATES(IDLE)=COL3:A:-1:NORMAL:NOTHING;

[SHORT_RED_COLUMN:33]
RADIUS=16;
HEIGHT=56;
SPECIAL=SOLID,CLIMBABLE;

STATES(IDLE)=COL4:A:-1:NORMAL:NOTHING;

[TALL_GREEN_COLUMN:30]
RADIUS=16;
HEIGHT=56;
SPECIAL=SOLID,CLIMBABLE;

STATES(IDLE)=COL1:A:-1:NORMAL:NOTHING;

[BEATING_HEART_COLUMN:36]
RADIUS=16;
HEIGHT=56;
SPECIAL=SOLID,CLIMBABLE;

STATES(IDLE)=COL5:A:14:NORMAL:NOTHING,
             COL5:B:14:NORMAL:NOTHING;

[SKULL_ON_COLUMN:37]
RADIUS=16;
HEIGHT=56;
SPECIAL=SOLID,CLIMBABLE;

STATES(IDLE)=COL6:A:-1:NORMAL:NOTHING;

[TECHNOCOLUMN:48]
RADIUS=16;
HEIGHT=128;
SPECIAL=SOLID,CLIMBABLE;

STATES(IDLE)=ELEC:A:-1:NORMAL:NOTHING;
</t>
<t tx="T2758">[BLACK_CANDLE:34]
RADIUS=16;
HEIGHT=16;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=100;
DLIGHT.COLOUR=#FFFFFF;
SPECIAL=NOSHADOW;

STATES(IDLE)=CAND:A:-1:BRIGHT:NOTHING;

[CANDELABRA:35]
RADIUS=16;
HEIGHT=56;
DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=300;
DLIGHT.COLOUR=#FFFFFF;
SPECIAL=SOLID,NOSHADOW;

STATES(IDLE)=CBRA:A:-1:BRIGHT:NOTHING;</t>
<t tx="T2759">[TORCHED_TREE:43]
RADIUS=16;
HEIGHT=56;
SPECIAL=SOLID;

STATES(IDLE)=TRE1:A:-1:NORMAL:NOTHING;

[SPIKY_STUMP:47]
RADIUS=16;
HEIGHT=56;
SPECIAL=SOLID;

STATES(IDLE)=SMIT:A:-1:NORMAL:NOTHING;</t>
<t tx="T2760">// This did not have an entry in the mobjinfo table, although sprite and
// state were present, so it got added as a new item -ACB- 1998/07/19
[BURNT_SPIKE_STUMP:7010]
RADIUS=16;
HEIGHT=46;
SPECIAL=SOLID;

STATES(IDLE)=SMT2:A:-1:NORMAL:NOTHING;</t>
<t tx="T2761">// The difference between the TWITCHING_BLOKEs is the fact that one is solid
// and one in not. Based on the original gameplay this makes the world of
// difference as it could block the vital escape or not. When True3d is
// enabled you may walk under/over a SOLID object, but not through it.
// So being SOLID does make a difference in either gameplay mode.
[TWITCHING_BLOKE_I:49]
RADIUS=16;
HEIGHT=68;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=GOR1:A:10:NORMAL:NOTHING,
             GOR1:B:15:NORMAL:NOTHING,
             GOR1:C:8:NORMAL:NOTHING,
             GOR1:B:6:NORMAL:NOTHING;

[TWITCHING_BLOKE_II:63]
RADIUS=20;
HEIGHT=68;
SPECIAL=ON_CEILING;

STATES(IDLE)=GOR1:A:10:NORMAL:NOTHING,
             GOR1:B:15:NORMAL:NOTHING,
             GOR1:C:8:NORMAL:NOTHING,
             GOR1:B:6:NORMAL:NOTHING;

// As with the TWITCHING BLOKE, the difference between a lot of these objects
// is whether they are solid or not.
[HANGING_DEAD_BLOKE_I:50]
RADIUS=16;
HEIGHT=68;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=GOR2:A:-1:NORMAL:NOTHING;

[HANGING_DEAD_BLOKE_II:51]
RADIUS=16;
HEIGHT=84;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=GOR3:A:-1:NORMAL:NOTHING;

[HANGING_DEAD_BLOKE_III:52]
RADIUS=16;
HEIGHT=68;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=GOR4:A:-1:NORMAL:NOTHING;

[HANGING_DEAD_BLOKE_IV:53]
RADIUS=16;
HEIGHT=68;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=GOR5:A:-1:NORMAL:NOTHING;

[HANGING_DEAD_BLOKE_V:59]
RADIUS=20;
HEIGHT=84;
SPECIAL=ON_CEILING;

STATES(IDLE)=GOR2:A:-1:NORMAL:NOTHING;

[HANGING_DEAD_BLOKE_VI:60]
RADIUS=20;
HEIGHT=68;
SPECIAL=ON_CEILING;

STATES(IDLE)=GOR4:A:-1:NORMAL:NOTHING;

[HANGING_DEAD_BLOKE_VII:61]
RADIUS=20;
HEIGHT=52;
SPECIAL=ON_CEILING;

STATES(IDLE)=GOR3:A:-1:NORMAL:NOTHING;

[HANGING_DEAD_BLOKE_VIII:62]
RADIUS=20;
HEIGHT=52;
SPECIAL=ON_CEILING;

STATES(IDLE)=GOR5:A:-1:NORMAL:NOTHING;

[BIG_TREE:54]
RADIUS=32;
HEIGHT=120;
SPECIAL=SOLID;

STATES(IDLE)=TRE2:A:-1:NORMAL:NOTHING;

[GUTTED_HUNG_BLOKE_I:73]
RADIUS=16;
HEIGHT=88;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=HDB1:A:-1:NORMAL:NOTHING;

[GUTTED_HUNG_BLOKE_II:74]
RADIUS=16;
HEIGHT=88;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=HDB2:A:-1:NORMAL:NOTHING;

[GUTTED_TORSO_I:75]
RADIUS=16;
HEIGHT=64;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=HDB3:A:-1:NORMAL:NOTHING;

[GUTTED_TORSO_II:76]
RADIUS=16;
HEIGHT=64;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=HDB4:A:-1:NORMAL:NOTHING;

[GUTTED_TORSO_III:77]
RADIUS=16;
HEIGHT=64;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=HDB5:A:-1:NORMAL:NOTHING;

[GUTTED_TORSO_IV:78]
RADIUS=16;
HEIGHT=64;
SPECIAL=SOLID,ON_CEILING;

STATES(IDLE)=HDB6:A:-1:NORMAL:NOTHING;</t>
<t tx="T2762">[SKEWERED_BLOKE:25]
RADIUS=20;
HEIGHT=64;
SPECIAL=SOLID;

STATES(IDLE)=POL1:A:-1:NORMAL:NOTHING;

[DYING_SKEWERED_BLOKE:26]
RADIUS=16;
HEIGHT=64;
SPECIAL=SOLID;

STATES(IDLE)=POL6:A:6:NORMAL:NOTHING,
             POL6:B:6:NORMAL:NOTHING;</t>
<t tx="T2763"></t>
<t tx="T2764">[PUFF]
REACTION_TIME=8T;
RADIUS=8;
HEIGHT=16;
FLOAT_SPEED=1;

DLIGHT.TYPE=QUADRATIC;
DLIGHT.INTENSITY=80;
DLIGHT.COLOUR=#FFFFFF;

SPECIAL=NOBLOCKMAP,NOGRAVITY,NOSHADOW;

STATES(SPAWN)=PUFF:A:0:BRIGHT:DLIGHT_FADE(0),
              PUFF:A:4:BRIGHT:NOTHING,
              PUFF:A:0:BRIGHT:TRANS_SET(50%),
              PUFF:B:4:NORMAL:NOTHING,
              PUFF:C:4:NORMAL:NOTHING,
              PUFF:D:4:NORMAL:NOTHING,
              #REMOVE;</t>
<t tx="T2765">[ITEM_RESPAWN]
REACTION_TIME=8T;
RADIUS=20;
HEIGHT=16;
AMBIENT_SOUND=ITMBK;
SPECIAL=NOBLOCKMAP,NOGRAVITY;

STATES(IDLE)=IFOG:A:0:BRIGHT:TRANS_FADE(0%),
             IFOG:A:6:BRIGHT:NOTHING,
             IFOG:B:6:BRIGHT:MAKESOUND,
             IFOG:A:6:BRIGHT:NOTHING,
             IFOG:B:6:BRIGHT:NOTHING,
             IFOG:C:6:BRIGHT:NOTHING,
             IFOG:D:6:BRIGHT:NOTHING,
             IFOG:E:6:BRIGHT:NOTHING,
             #REMOVE;</t>
<t tx="T2766">[TELEPORT_FLASH:14]
RADIUS=20;
HEIGHT=16;
AMBIENT_SOUND=TELEPT;
SPECIAL=TELEPORT_TYPE,NOGRAVITY;

STATES(IDLE)=TFOG:J:0:NORMAL:TRANS_SET(0%),
             TFOG:J:-1:NORMAL:NOTHING;

STATES(CHASE)=TFOG:A:1:NORMAL:TRANS_FADE(0%),
              TFOG:A:0:BRIGHT:MAKESOUND,
              TFOG:A:5:BRIGHT:NOTHING,
              TFOG:B:6:BRIGHT:NOTHING,
              TFOG:A:6:BRIGHT:NOTHING,
              TFOG:B:6:BRIGHT:NOTHING,
              TFOG:C:6:BRIGHT:NOTHING,
              TFOG:D:6:BRIGHT:NOTHING,
              TFOG:E:6:BRIGHT:NOTHING,
              TFOG:F:6:BRIGHT:NOTHING,
              TFOG:G:6:BRIGHT:NOTHING,
              TFOG:H:6:BRIGHT:NOTHING,
              TFOG:I:6:BRIGHT:NOTHING,
              TFOG:J:6:BRIGHT:NOTHING,
              #REMOVE;</t>
<t tx="T2767">[RESPAWN_FLASH:7014]
RADIUS=20;
HEIGHT=16;
AMBIENT_SOUND=TELEPT;
SPECIAL=TELEPORT_TYPE,NOGRAVITY;

STATES(IDLE)=TFOG:A:1:NORMAL:TRANS_FADE(0%),
             TFOG:A:0:BRIGHT:MAKESOUND,
             TFOG:A:5:BRIGHT:NOTHING,
             TFOG:B:6:BRIGHT:NOTHING,
             TFOG:A:6:BRIGHT:NOTHING,
             TFOG:B:6:BRIGHT:NOTHING,
             TFOG:C:6:BRIGHT:NOTHING,
             TFOG:D:6:BRIGHT:NOTHING,
             TFOG:E:6:BRIGHT:NOTHING,
             TFOG:F:6:BRIGHT:NOTHING,
             TFOG:G:6:BRIGHT:NOTHING,
             TFOG:H:6:BRIGHT:NOTHING,
             TFOG:I:6:BRIGHT:NOTHING,
             TFOG:J:6:BRIGHT:NOTHING,
             #REMOVE;</t>
<t tx="T2768">[DEATHMATCH_START:11]
SPECIAL=NOBLOCKMAP,NOSECTOR;
PLAYER=-1;
STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;</t>
<t tx="T2769">[HELL_KNIGHT:69]
SPAWNHEALTH=500;
REACTION_TIME=0.23;
RADIUS=24;
HEIGHT=64;
SPEED=8;
MASS=1000;
PAINCHANCE=20%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE;
MINATTACK_CHANCE=22%;
CASTORDER=9;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=KNTDTH;
PAIN_SOUND=DMPAIN;
SIGHTING_SOUND=KNTSIT;
RANGE_ATTACK=BARON_FIREBALL;
CLOSE_ATTACK=BARON_CLOSECOMBAT;

STATES(IDLE)=BOS2:A:10:NORMAL:LOOKOUT,
             BOS2:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=BOS2:A:3:NORMAL:CHASE,
              BOS2:A:3:NORMAL:CHASE,
              BOS2:B:3:NORMAL:CHASE,
              BOS2:B:3:NORMAL:CHASE,
              BOS2:C:3:NORMAL:CHASE,
              BOS2:C:3:NORMAL:CHASE,
              BOS2:D:3:NORMAL:CHASE,
              BOS2:D:3:NORMAL:CHASE;

STATES(MELEE)=BOS2:E:8:NORMAL:FACETARGET,
              BOS2:F:8:NORMAL:FACETARGET,
              BOS2:G:8:NORMAL:COMBOATTACK,
              #CHASE;

STATES(MISSILE)=BOS2:E:8:NORMAL:FACETARGET,
                BOS2:F:8:NORMAL:FACETARGET,
                BOS2:G:8:NORMAL:COMBOATTACK,
                #CHASE;

STATES(PAIN)=BOS2:H:2:NORMAL:NOTHING,
             BOS2:H:2:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=BOS2:I:8:NORMAL:NOTHING,
              BOS2:J:8:NORMAL:MAKEDEATHSOUND,
              BOS2:K:8:NORMAL:NOTHING,
              BOS2:L:8:NORMAL:MAKEDEAD,
              BOS2:M:8:NORMAL:NOTHING,
              BOS2:N:8:NORMAL:NOTHING,
              BOS2:O:-1:NORMAL:NOTHING;

STATES(RESPAWN)=BOS2:O:8:NORMAL:NOTHING,
                BOS2:N:8:NORMAL:NOTHING,
                BOS2:M:8:NORMAL:NOTHING,
                BOS2:L:8:NORMAL:NOTHING,
                BOS2:K:8:NORMAL:NOTHING,
                BOS2:J:8:NORMAL:NOTHING,
                BOS2:I:8:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2770">[IMP:3001]
SPAWNHEALTH=60;
REACTION_TIME=0.23;
RADIUS=20;
HEIGHT=56;
SPEED=8;
MASS=100;
PAINCHANCE=78%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE;
MINATTACK_CHANCE=22%;
CASTORDER=5;
BLOOD=BLOOD;
ACTIVE_SOUND=BGACT;
DEATH_SOUND="BGDTH?";
PAIN_SOUND=POPAIN;
SIGHTING_SOUND="BGSIT?";
OVERKILL_SOUND="SLOP";
RESPAWN_EFFECT=RESPAWN_FLASH;
RANGE_ATTACK=IMP_FIREBALL;
CLOSE_ATTACK=IMP_CLOSECOMBAT;

STATES(IDLE)=TROO:A:10:NORMAL:LOOKOUT,
             TROO:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=TROO:A:3:NORMAL:CHASE,
              TROO:A:3:NORMAL:CHASE,
              TROO:B:3:NORMAL:CHASE,
              TROO:B:3:NORMAL:CHASE,
              TROO:C:3:NORMAL:CHASE,
              TROO:C:3:NORMAL:CHASE,
              TROO:D:3:NORMAL:CHASE,
              TROO:D:3:NORMAL:CHASE;

STATES(MELEE)=TROO:E:8:NORMAL:FACETARGET,
              TROO:F:8:NORMAL:FACETARGET,
              TROO:G:6:NORMAL:COMBOATTACK,
              #CHASE;

STATES(MISSILE)=TROO:E:8:NORMAL:FACETARGET,
                TROO:F:8:NORMAL:FACETARGET,
                TROO:G:6:NORMAL:COMBOATTACK,
                #CHASE;

STATES(PAIN)=TROO:H:2:NORMAL:NOTHING,
             TROO:H:2:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=TROO:I:8:NORMAL:NOTHING,
              TROO:J:8:NORMAL:MAKEDEATHSOUND,
              TROO:K:6:NORMAL:NOTHING,
              TROO:L:6:NORMAL:MAKEDEAD,
              TROO:M:-1:NORMAL:NOTHING;

STATES(OVERKILL)=TROO:N:5:NORMAL:NOTHING,
                 TROO:O:5:NORMAL:MAKEOVERKILLSOUND,
                 TROO:P:5:NORMAL:NOTHING,
                 TROO:Q:5:NORMAL:MAKEDEAD,
                 TROO:R:5:NORMAL:NOTHING,
                 TROO:S:5:NORMAL:NOTHING,
                 TROO:T:5:NORMAL:NOTHING,
                 TROO:U:-1:NORMAL:NOTHING;

STATES(RESPAWN)=TROO:M:8:NORMAL:NOTHING,
                TROO:L:8:NORMAL:NOTHING,
                TROO:K:6:NORMAL:NOTHING,
                TROO:J:6:NORMAL:NOTHING,
                TROO:I:6:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2771">[LOST_SOUL:3006]
SPAWNHEALTH=100;
REACTION_TIME=0.23;
RADIUS=16;
HEIGHT=56;
SPEED=8;
MASS=50;
PAINCHANCE=100%;
CASTORDER=7;
BLOOD=BLOOD;
FLOAT_SPEED=2;
SPECIAL=SOLID,SHOOTABLE,TRIGGER_HAPPY,FLOATER,NOGRAV_KILL,MONSTER,DISLOYAL,ATTACK_HURTS;
TRANSLUCENCY=66%;
MINATTACK_CHANCE=22%;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=FIRXPL;
PAIN_SOUND=DMPAIN;
RANGE_ATTACK=SKULL_ASSAULT;

STATES(IDLE)=SKUL:A:10:BRIGHT:LOOKOUT,
             SKUL:B:10:BRIGHT:LOOKOUT;

STATES(CHASE)=SKUL:A:6:BRIGHT:CHASE,
              SKUL:B:6:BRIGHT:CHASE;

STATES(MISSILE)=SKUL:C:10:BRIGHT:FACETARGET,
                SKUL:D:4:BRIGHT:RANGE_ATTACK,
                SKUL:C:4:BRIGHT:NOTHING,
                SKUL:D:4:BRIGHT:NOTHING,
                #MISSILE:3;

STATES(PAIN)=SKUL:E:3:BRIGHT:NOTHING,
             SKUL:E:3:BRIGHT:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=SKUL:F:0:BRIGHT:TRANS_FADE(0%),
              SKUL:F:6:BRIGHT:NOTHING,
              SKUL:G:6:BRIGHT:MAKEDEATHSOUND,
              SKUL:H:6:BRIGHT:NOTHING,
              SKUL:I:6:BRIGHT:MAKEDEAD,
              SKUL:J:6:NORMAL:NOTHING,
              SKUL:K:6:NORMAL:NOTHING,
              #REMOVE;</t>
<t tx="T2772">[MANCUBUS:67]
SPAWNHEALTH=600;
REACTION_TIME=0.23;
RADIUS=48;
HEIGHT=64;
SPEED=8;
MASS=1000;
PAINCHANCE=30%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE;
MINATTACK_CHANCE=22%;
CASTORDER=14;
BLOOD=BLOOD;
ACTIVE_SOUND=POSACT;
DEATH_SOUND=MANDTH;
PAIN_SOUND=MNPAIN;
SIGHTING_SOUND=MANSIT;
RESPAWN_EFFECT=RESPAWN_FLASH;
RANGE_ATTACK=MANCUBUS_FIREBALL;

STATES(IDLE)=FATT:A:15:NORMAL:LOOKOUT,
             FATT:B:15:NORMAL:LOOKOUT;

STATES(CHASE)=FATT:A:4:NORMAL:CHASE,
              FATT:A:4:NORMAL:CHASE,
              FATT:B:4:NORMAL:CHASE,
              FATT:B:4:NORMAL:CHASE,
              FATT:C:4:NORMAL:CHASE,
              FATT:C:4:NORMAL:CHASE,
              FATT:D:4:NORMAL:CHASE,
              FATT:D:4:NORMAL:CHASE,
              FATT:E:4:NORMAL:CHASE,
              FATT:E:4:NORMAL:CHASE,
              FATT:F:4:NORMAL:CHASE,
              FATT:F:4:NORMAL:CHASE;

STATES(MISSILE)=FATT:G:0:NORMAL:FACETARGET,
                FATT:G:20:NORMAL:RANGEATTEMPTSND,
                FATT:H:0:NORMAL:RESET_SPREADER,
                FATT:H:0:NORMAL:FACETARGET,
                FATT:H:0:BRIGHT:RANGE_ATTACK,
                FATT:H:10:BRIGHT:RANGE_ATTACK,
                FATT:I:5:NORMAL:FACETARGET,
                FATT:G:5:NORMAL:FACETARGET,
                FATT:H:0:NORMAL:FACETARGET,
                FATT:H:0:BRIGHT:RANGE_ATTACK,
                FATT:H:10:BRIGHT:RANGE_ATTACK,
                FATT:I:5:NORMAL:FACETARGET,
                FATT:G:5:NORMAL:FACETARGET,
                FATT:H:0:NORMAL:FACETARGET,
                FATT:H:0:BRIGHT:RANGE_ATTACK,
                FATT:H:10:BRIGHT:RANGE_ATTACK,
                FATT:I:5:NORMAL:FACETARGET,
                FATT:G:5:NORMAL:FACETARGET,
                #CHASE;

STATES(PAIN)=FATT:J:3:NORMAL:NOTHING,
             FATT:J:3:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=FATT:K:6:NORMAL:NOTHING,
              FATT:L:6:NORMAL:MAKEDEATHSOUND,
              FATT:M:6:NORMAL:MAKEDEAD,
              FATT:N:6:NORMAL:NOTHING,
              FATT:O:6:NORMAL:NOTHING,
              FATT:P:6:NORMAL:NOTHING,
              FATT:Q:6:NORMAL:NOTHING,
              FATT:R:6:NORMAL:NOTHING,
              FATT:S:6:NORMAL:NOTHING,
              FATT:T:-1:NORMAL:NOTHING;

STATES(RESPAWN)=FATT:R:5:NORMAL:NOTHING,
                FATT:Q:5:NORMAL:NOTHING,
                FATT:P:5:NORMAL:NOTHING,
                FATT:O:5:NORMAL:NOTHING,
                FATT:N:5:NORMAL:NOTHING,
                FATT:M:5:NORMAL:NOTHING,
                FATT:L:5:NORMAL:NOTHING,
                FATT:K:5:NORMAL:NOTHING,
                #CHASE;</t>
<t tx="T2773">[OUR_HERO:1]
SPAWNHEALTH=100;
RADIUS=16;
HEIGHT=56;
MASS=100;
SPEED=1;
SIDE=1;
PLAYER=1;
JUMP_HEIGHT=10;
JUMP_SOUND=OOF;
CROUCH_HEIGHT=32;
PALETTE_REMAP=PLAYER_GREEN;
CASTORDER=1;
PAINCHANCE=100%;
SPECIAL=SOLID,SHOOTABLE,DROPOFF,PICKUP,NODEATHMATCH,SLIDER,ATTACK_HURTS,DISLOYAL;
DEATH_SOUND=PLDETH;
PAIN_SOUND="PLPAIN";
OVERKILL_SOUND="SLOP";
NOWAY_SOUND="NOWAY";
OOF_SOUND="OOF";
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
RESPAWN_TIME=2;
INITIAL_BENEFIT=BULLETS.LIMIT(200),SHELLS.LIMIT(50),
                ROCKETS.LIMIT(50),CELLS.LIMIT(300),
                BULLETS(50);

STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;

STATES(CHASE)=PLAY:A:4:NORMAL:NOTHING,
              PLAY:B:4:NORMAL:NOTHING,
              PLAY:C:4:NORMAL:NOTHING,
              PLAY:D:4:NORMAL:CHECKMOVING;
               
STATES(MISSILE)=PLAY:E:12:NORMAL:NOTHING,
                PLAY:F:6:BRIGHT:NOTHING;
             
STATES(MELEE)=PLAY:E:12:NORMAL:NOTHING,
              PLAY:F:6:BRIGHT:NOTHING;

STATES(PAIN)=PLAY:G:4:NORMAL:NOTHING,
             PLAY:G:4:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PLAY:H:10:NORMAL:NOTHING,
              PLAY:I:10:NORMAL:PLAYER_SCREAM,
              PLAY:J:10:NORMAL:MAKEDEAD,
              PLAY:K:10:NORMAL:NOTHING,
              PLAY:L:10:NORMAL:NOTHING,
              PLAY:M:10:NORMAL:NOTHING,
              PLAY:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=PLAY:O:5:NORMAL:NOTHING,
                 PLAY:P:5:NORMAL:PLAYER_SCREAM,
                 PLAY:Q:5:NORMAL:MAKEDEAD,
                 PLAY:R:5:NORMAL:NOTHING,
                 PLAY:S:5:NORMAL:NOTHING,
                 PLAY:T:5:NORMAL:NOTHING,
                 PLAY:U:5:NORMAL:NOTHING,
                 PLAY:V:5:NORMAL:NOTHING,
                 PLAY:W:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2774">[PAIN_ELEMENTAL:71]
SPAWNHEALTH=400;
REACTION_TIME=0.23;
RADIUS=31;
HEIGHT=56;
SPEED=8;
MASS=400;
PAINCHANCE=50%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,FLOATER;
MINATTACK_CHANCE=22%;
CASTORDER=12;
BLOOD=BLOOD;
FLOAT_SPEED=4;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=PEDTH;
PAIN_SOUND=PEPAIN;
SIGHTING_SOUND=PESIT;
RANGE_ATTACK=ELEMENTAL_SPAWNER;
SPARE_ATTACK=ELEMENTAL_DEATHSPAWN;

STATES(IDLE)=PAIN:A:10:NORMAL:LOOKOUT;

STATES(CHASE)=PAIN:A:3:NORMAL:CHASE,
              PAIN:A:3:NORMAL:CHASE,
              PAIN:B:3:NORMAL:CHASE,
              PAIN:B:3:NORMAL:CHASE,
              PAIN:C:3:NORMAL:CHASE,
              PAIN:C:3:NORMAL:CHASE;

STATES(MISSILE)=PAIN:D:5:NORMAL:FACETARGET,
                PAIN:E:5:NORMAL:FACETARGET,
                PAIN:F:5:BRIGHT:FACETARGET,
                PAIN:F:5:BRIGHT:RANGE_ATTACK,
                #CHASE;

STATES(PAIN)=PAIN:G:6:NORMAL:NOTHING,
             PAIN:G:6:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PAIN:H:8:BRIGHT:NOTHING,
              PAIN:I:8:BRIGHT:MAKEDEATHSOUND,
              PAIN:J:8:BRIGHT:NOTHING,
              PAIN:K:8:BRIGHT:NOTHING,
              PAIN:L:0:BRIGHT:MAKEDEAD,
              PAIN:L:8:BRIGHT:SPARE_ATTACK,
              PAIN:M:8:BRIGHT:NOTHING,
              #REMOVE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2775">[PLAYER2:2]
SPAWNHEALTH=100;
RADIUS=16;
HEIGHT=56;
MASS=100;
SPEED=1;
SIDE=2;
PLAYER=2;
PALETTE_REMAP=PLAYER_DK_GREY;
JUMP_HEIGHT=10;
JUMP_SOUND=OOF;
CROUCH_HEIGHT=32;
PAINCHANCE=100%;
SPECIAL=SOLID,SHOOTABLE,DROPOFF,PICKUP,NODEATHMATCH,SLIDER,ATTACK_HURTS,DISLOYAL;
DEATH_SOUND=PLDETH;
PAIN_SOUND=PLPAIN;
OVERKILL_SOUND="SLOP";
NOWAY_SOUND="NOWAY";
OOF_SOUND="OOF";
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
RESPAWN_TIME=2;
INITIAL_BENEFIT=BULLETS.LIMIT(200),SHELLS.LIMIT(50),
                ROCKETS.LIMIT(50),CELLS.LIMIT(300),
                BULLETS(50);

STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;

STATES(CHASE)=PLAY:A:4:NORMAL:NOTHING,
              PLAY:B:4:NORMAL:NOTHING,
              PLAY:C:4:NORMAL:NOTHING,
              PLAY:D:4:NORMAL:CHECKMOVING;
               
STATES(MISSILE)=PLAY:E:12:NORMAL:NOTHING,
                PLAY:F:6:BRIGHT:NOTHING;
             
STATES(MELEE)=PLAY:E:12:NORMAL:NOTHING,
              PLAY:F:6:BRIGHT:NOTHING;

STATES(PAIN)=PLAY:G:4:NORMAL:NOTHING,
             PLAY:G:4:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PLAY:H:10:NORMAL:NOTHING,
              PLAY:I:10:NORMAL:PLAYER_SCREAM,
              PLAY:J:10:NORMAL:MAKEDEAD,
              PLAY:K:10:NORMAL:NOTHING,
              PLAY:L:10:NORMAL:NOTHING,
              PLAY:M:10:NORMAL:NOTHING,
              PLAY:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=PLAY:O:5:NORMAL:NOTHING,
                 PLAY:P:5:NORMAL:PLAYER_SCREAM,
                 PLAY:Q:5:NORMAL:MAKEDEAD,
                 PLAY:R:5:NORMAL:NOTHING,
                 PLAY:S:5:NORMAL:NOTHING,
                 PLAY:T:5:NORMAL:NOTHING,
                 PLAY:U:5:NORMAL:NOTHING,
                 PLAY:V:5:NORMAL:NOTHING,
                 PLAY:W:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2776">[PLAYER3:3]
SPAWNHEALTH=100;
RADIUS=16;
HEIGHT=56;
MASS=100;
JUMP_HEIGHT=10;
JUMP_SOUND=OOF;
CROUCH_HEIGHT=32;
PALETTE_REMAP=PLAYER_BROWN;
SPEED=1;
SIDE=4;
PLAYER=3;
PAINCHANCE=100%;
SPECIAL=SOLID,SHOOTABLE,DROPOFF,PICKUP,NODEATHMATCH,SLIDER,ATTACK_HURTS,DISLOYAL;
DEATH_SOUND=PLDETH;
PAIN_SOUND=PLPAIN;
OVERKILL_SOUND="SLOP";
NOWAY_SOUND="NOWAY";
OOF_SOUND="OOF";
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
RESPAWN_TIME=2;
INITIAL_BENEFIT=BULLETS.LIMIT(200),SHELLS.LIMIT(50),
                ROCKETS.LIMIT(50),CELLS.LIMIT(300),
                BULLETS(50);

STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;

STATES(CHASE)=PLAY:A:4:NORMAL:NOTHING,
              PLAY:B:4:NORMAL:NOTHING,
              PLAY:C:4:NORMAL:NOTHING,
              PLAY:D:4:NORMAL:CHECKMOVING;
               
STATES(MISSILE)=PLAY:E:12:NORMAL:NOTHING,
                PLAY:F:6:BRIGHT:NOTHING;
             
STATES(MELEE)=PLAY:E:12:NORMAL:NOTHING,
              PLAY:F:6:BRIGHT:NOTHING;

STATES(PAIN)=PLAY:G:4:NORMAL:NOTHING,
             PLAY:G:4:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PLAY:H:10:NORMAL:NOTHING,
              PLAY:I:10:NORMAL:PLAYER_SCREAM,
              PLAY:J:10:NORMAL:MAKEDEAD,
              PLAY:K:10:NORMAL:NOTHING,
              PLAY:L:10:NORMAL:NOTHING,
              PLAY:M:10:NORMAL:NOTHING,
              PLAY:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=PLAY:O:5:NORMAL:NOTHING,
                 PLAY:P:5:NORMAL:PLAYER_SCREAM,
                 PLAY:Q:5:NORMAL:MAKEDEAD,
                 PLAY:R:5:NORMAL:NOTHING,
                 PLAY:S:5:NORMAL:NOTHING,
                 PLAY:T:5:NORMAL:NOTHING,
                 PLAY:U:5:NORMAL:NOTHING,
                 PLAY:V:5:NORMAL:NOTHING,
                 PLAY:W:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2777">[PLAYER4:4]
SPAWNHEALTH=100;
RADIUS=16;
HEIGHT=56;
MASS=100;
SPEED=1;
SIDE=8;
PLAYER=4;
PALETTE_REMAP=PLAYER_DULL_RED;
PAINCHANCE=100%;
JUMP_HEIGHT=10;
JUMP_SOUND=OOF;
CROUCH_HEIGHT=32;
SPECIAL=SOLID,SHOOTABLE,DROPOFF,PICKUP,NODEATHMATCH,SLIDER,ATTACK_HURTS,DISLOYAL;
DEATH_SOUND=PLDETH;
PAIN_SOUND=PLPAIN;
OVERKILL_SOUND="SLOP";
NOWAY_SOUND="NOWAY";
OOF_SOUND="OOF";
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
RESPAWN_TIME=2;
INITIAL_BENEFIT=BULLETS.LIMIT(200),SHELLS.LIMIT(50),
                ROCKETS.LIMIT(50),CELLS.LIMIT(300),
                BULLETS(50);

STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;

STATES(CHASE)=PLAY:A:4:NORMAL:NOTHING,
              PLAY:B:4:NORMAL:NOTHING,
              PLAY:C:4:NORMAL:NOTHING,
              PLAY:D:4:NORMAL:CHECKMOVING;
               
STATES(MISSILE)=PLAY:E:12:NORMAL:NOTHING,
                PLAY:F:6:BRIGHT:NOTHING;
             
STATES(MELEE)=PLAY:E:12:NORMAL:NOTHING,
              PLAY:F:6:BRIGHT:NOTHING;

STATES(PAIN)=PLAY:G:4:NORMAL:NOTHING,
             PLAY:G:4:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PLAY:H:10:NORMAL:NOTHING,
              PLAY:I:10:NORMAL:PLAYER_SCREAM,
              PLAY:J:10:NORMAL:MAKEDEAD,
              PLAY:K:10:NORMAL:NOTHING,
              PLAY:L:10:NORMAL:NOTHING,
              PLAY:M:10:NORMAL:NOTHING,
              PLAY:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=PLAY:O:5:NORMAL:NOTHING,
                 PLAY:P:5:NORMAL:PLAYER_SCREAM,
                 PLAY:Q:5:NORMAL:MAKEDEAD,
                 PLAY:R:5:NORMAL:NOTHING,
                 PLAY:S:5:NORMAL:NOTHING,
                 PLAY:T:5:NORMAL:NOTHING,
                 PLAY:U:5:NORMAL:NOTHING,
                 PLAY:V:5:NORMAL:NOTHING,
                 PLAY:W:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2778">[PLAYER5:4001]
SPAWNHEALTH=100;
RADIUS=16;
HEIGHT=56;
MASS=100;
SPEED=1;
SIDE=16;
PLAYER=5;
PALETTE_REMAP=PLAYER_ORANGE;
PAINCHANCE=100%;
JUMP_HEIGHT=10;
JUMP_SOUND=OOF;
CROUCH_HEIGHT=32;
SPECIAL=SOLID,SHOOTABLE,DROPOFF,PICKUP,NODEATHMATCH,SLIDER,ATTACK_HURTS,DISLOYAL;
DEATH_SOUND=PLDETH;
PAIN_SOUND=PLPAIN;
OVERKILL_SOUND="SLOP";
NOWAY_SOUND="NOWAY";
OOF_SOUND="OOF";
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
RESPAWN_TIME=2;
INITIAL_BENEFIT=BULLETS.LIMIT(200),SHELLS.LIMIT(50),
                ROCKETS.LIMIT(50),CELLS.LIMIT(300),
                BULLETS(50);

STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;

STATES(CHASE)=PLAY:A:4:NORMAL:NOTHING,
              PLAY:B:4:NORMAL:NOTHING,
              PLAY:C:4:NORMAL:NOTHING,
              PLAY:D:4:NORMAL:CHECKMOVING;
               
STATES(MISSILE)=PLAY:E:12:NORMAL:NOTHING,
                PLAY:F:6:BRIGHT:NOTHING;
             
STATES(MELEE)=PLAY:E:12:NORMAL:NOTHING,
              PLAY:F:6:BRIGHT:NOTHING;

STATES(PAIN)=PLAY:G:4:NORMAL:NOTHING,
             PLAY:G:4:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PLAY:H:10:NORMAL:NOTHING,
              PLAY:I:10:NORMAL:PLAYER_SCREAM,
              PLAY:J:10:NORMAL:MAKEDEAD,
              PLAY:K:10:NORMAL:NOTHING,
              PLAY:L:10:NORMAL:NOTHING,
              PLAY:M:10:NORMAL:NOTHING,
              PLAY:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=PLAY:O:5:NORMAL:NOTHING,
                 PLAY:P:5:NORMAL:PLAYER_SCREAM,
                 PLAY:Q:5:NORMAL:MAKEDEAD,
                 PLAY:R:5:NORMAL:NOTHING,
                 PLAY:S:5:NORMAL:NOTHING,
                 PLAY:T:5:NORMAL:NOTHING,
                 PLAY:U:5:NORMAL:NOTHING,
                 PLAY:V:5:NORMAL:NOTHING,
                 PLAY:W:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2779">[PLAYER6:4002]
SPAWNHEALTH=100;
RADIUS=16;
HEIGHT=56;
MASS=100;
PALETTE_REMAP=PLAYER_LT_GREY;
SPEED=1;
SIDE=32;
PLAYER=6;
PAINCHANCE=100%;
JUMP_HEIGHT=10;
JUMP_SOUND=OOF;
CROUCH_HEIGHT=32;
SPECIAL=SOLID,SHOOTABLE,DROPOFF,PICKUP,NODEATHMATCH,SLIDER,ATTACK_HURTS,DISLOYAL;
DEATH_SOUND=PLDETH;
PAIN_SOUND=PLPAIN;
OVERKILL_SOUND="SLOP";
NOWAY_SOUND="NOWAY";
OOF_SOUND="OOF";
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
RESPAWN_TIME=2;
INITIAL_BENEFIT=BULLETS.LIMIT(200),SHELLS.LIMIT(50),
                ROCKETS.LIMIT(50),CELLS.LIMIT(300),
                BULLETS(50);

STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;

STATES(CHASE)=PLAY:A:4:NORMAL:NOTHING,
              PLAY:B:4:NORMAL:NOTHING,
              PLAY:C:4:NORMAL:NOTHING,
              PLAY:D:4:NORMAL:CHECKMOVING;
               
STATES(MISSILE)=PLAY:E:12:NORMAL:NOTHING,
                PLAY:F:6:BRIGHT:NOTHING;
             
STATES(MELEE)=PLAY:E:12:NORMAL:NOTHING,
              PLAY:F:6:BRIGHT:NOTHING;

STATES(PAIN)=PLAY:G:4:NORMAL:NOTHING,
             PLAY:G:4:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PLAY:H:10:NORMAL:NOTHING,
              PLAY:I:10:NORMAL:PLAYER_SCREAM,
              PLAY:J:10:NORMAL:MAKEDEAD,
              PLAY:K:10:NORMAL:NOTHING,
              PLAY:L:10:NORMAL:NOTHING,
              PLAY:M:10:NORMAL:NOTHING,
              PLAY:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=PLAY:O:5:NORMAL:NOTHING,
                 PLAY:P:5:NORMAL:PLAYER_SCREAM,
                 PLAY:Q:5:NORMAL:MAKEDEAD,
                 PLAY:R:5:NORMAL:NOTHING,
                 PLAY:S:5:NORMAL:NOTHING,
                 PLAY:T:5:NORMAL:NOTHING,
                 PLAY:U:5:NORMAL:NOTHING,
                 PLAY:V:5:NORMAL:NOTHING,
                 PLAY:W:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2780">[PLAYER7:4003]
SPAWNHEALTH=100;
RADIUS=16;
HEIGHT=56;
MASS=100;
PALETTE_REMAP=PLAYER_LT_RED;
SPEED=1;
SIDE=64;
PLAYER=7;
PAINCHANCE=100%;
JUMP_HEIGHT=10;
JUMP_SOUND=OOF;
CROUCH_HEIGHT=32;
SPECIAL=SOLID,SHOOTABLE,DROPOFF,PICKUP,NODEATHMATCH,SLIDER,ATTACK_HURTS,DISLOYAL;
DEATH_SOUND=PLDETH;
PAIN_SOUND=PLPAIN;
OVERKILL_SOUND="SLOP";
NOWAY_SOUND="NOWAY";
OOF_SOUND="OOF";
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
RESPAWN_TIME=2;
INITIAL_BENEFIT=BULLETS.LIMIT(200),SHELLS.LIMIT(50),
                ROCKETS.LIMIT(50),CELLS.LIMIT(300),
                BULLETS(50);

STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;

STATES(CHASE)=PLAY:A:4:NORMAL:NOTHING,
              PLAY:B:4:NORMAL:NOTHING,
              PLAY:C:4:NORMAL:NOTHING,
              PLAY:D:4:NORMAL:CHECKMOVING;
               
STATES(MISSILE)=PLAY:E:12:NORMAL:NOTHING,
                PLAY:F:6:BRIGHT:NOTHING;
             
STATES(MELEE)=PLAY:E:12:NORMAL:NOTHING,
              PLAY:F:6:BRIGHT:NOTHING;

STATES(PAIN)=PLAY:G:4:NORMAL:NOTHING,
             PLAY:G:4:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PLAY:H:10:NORMAL:NOTHING,
              PLAY:I:10:NORMAL:PLAYER_SCREAM,
              PLAY:J:10:NORMAL:MAKEDEAD,
              PLAY:K:10:NORMAL:NOTHING,
              PLAY:L:10:NORMAL:NOTHING,
              PLAY:M:10:NORMAL:NOTHING,
              PLAY:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=PLAY:O:5:NORMAL:NOTHING,
                 PLAY:P:5:NORMAL:PLAYER_SCREAM,
                 PLAY:Q:5:NORMAL:MAKEDEAD,
                 PLAY:R:5:NORMAL:NOTHING,
                 PLAY:S:5:NORMAL:NOTHING,
                 PLAY:T:5:NORMAL:NOTHING,
                 PLAY:U:5:NORMAL:NOTHING,
                 PLAY:V:5:NORMAL:NOTHING,
                 PLAY:W:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2781">[PLAYER8:4004]
SPAWNHEALTH=100;
RADIUS=16;
HEIGHT=56;
MASS=100;
SPEED=1;
SIDE=128;
PLAYER=8;
PALETTE_REMAP=PLAYER_PINK;
PAINCHANCE=100%;
JUMP_HEIGHT=10;
JUMP_SOUND=OOF;
CROUCH_HEIGHT=32;
SPECIAL=SOLID,SHOOTABLE,DROPOFF,PICKUP,NODEATHMATCH,SLIDER,ATTACK_HURTS,DISLOYAL;
DEATH_SOUND=PLDETH;
PAIN_SOUND=PLPAIN;
OVERKILL_SOUND="SLOP";
NOWAY_SOUND="NOWAY";
OOF_SOUND="OOF";
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
RESPAWN_TIME=2;
INITIAL_BENEFIT=BULLETS.LIMIT(200),SHELLS.LIMIT(50),
                ROCKETS.LIMIT(50),CELLS.LIMIT(300),
                BULLETS(50);

STATES(IDLE)=PLAY:A:-1:NORMAL:NOTHING;

STATES(CHASE)=PLAY:A:4:NORMAL:NOTHING,
              PLAY:B:4:NORMAL:NOTHING,
              PLAY:C:4:NORMAL:NOTHING,
              PLAY:D:4:NORMAL:CHECKMOVING;
               
STATES(MISSILE)=PLAY:E:12:NORMAL:NOTHING,
                PLAY:F:6:BRIGHT:NOTHING;
             
STATES(MELEE)=PLAY:E:12:NORMAL:NOTHING,
              PLAY:F:6:BRIGHT:NOTHING;

STATES(PAIN)=PLAY:G:4:NORMAL:NOTHING,
             PLAY:G:4:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=PLAY:H:10:NORMAL:NOTHING,
              PLAY:I:10:NORMAL:PLAYER_SCREAM,
              PLAY:J:10:NORMAL:MAKEDEAD,
              PLAY:K:10:NORMAL:NOTHING,
              PLAY:L:10:NORMAL:NOTHING,
              PLAY:M:10:NORMAL:NOTHING,
              PLAY:N:-1:NORMAL:NOTHING;

STATES(OVERKILL)=PLAY:O:5:NORMAL:NOTHING,
                 PLAY:P:5:NORMAL:PLAYER_SCREAM,
                 PLAY:Q:5:NORMAL:MAKEDEAD,
                 PLAY:R:5:NORMAL:NOTHING,
                 PLAY:S:5:NORMAL:NOTHING,
                 PLAY:T:5:NORMAL:NOTHING,
                 PLAY:U:5:NORMAL:NOTHING,
                 PLAY:V:5:NORMAL:NOTHING,
                 PLAY:W:-1:NORMAL:NOTHING;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2782">[REVENANT:66]
SPAWNHEALTH=300;
REACTION_TIME=0.23;
RADIUS=20;
HEIGHT=56;
SPEED=10;
MASS=500;
PAINCHANCE=40%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,TRIGGER_HAPPY;
MINATTACK_CHANCE=22%;
CASTORDER=13;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=SKEACT;
DEATH_SOUND=SKEDTH;
PAIN_SOUND=POPAIN;
SIGHTING_SOUND=SKESIT;
RANGE_ATTACK=REVENANT_MISSILE;
CLOSE_ATTACK=REVENANT_CLOSECOMBAT;

STATES(IDLE)=SKEL:A:10:NORMAL:LOOKOUT,
             SKEL:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=SKEL:A:2:NORMAL:CHASE,
              SKEL:A:2:NORMAL:CHASE,
              SKEL:B:2:NORMAL:CHASE,
              SKEL:B:2:NORMAL:CHASE,
              SKEL:C:2:NORMAL:CHASE,
              SKEL:C:2:NORMAL:CHASE,
              SKEL:D:2:NORMAL:CHASE,
              SKEL:D:2:NORMAL:CHASE,
              SKEL:E:2:NORMAL:CHASE,
              SKEL:E:2:NORMAL:CHASE,
              SKEL:F:2:NORMAL:CHASE,
              SKEL:F:2:NORMAL:CHASE;

STATES(MELEE)=SKEL:G:0:NORMAL:FACETARGET,
              SKEL:G:6:NORMAL:CLOSEATTEMPTSND,
              SKEL:H:6:NORMAL:FACETARGET,
              SKEL:I:6:NORMAL:CLOSE_ATTACK,
              #CHASE;

STATES(MISSILE)=SKEL:J:10:BRIGHT:FACETARGET,
                SKEL:K:10:NORMAL:RANGE_ATTACK,
                SKEL:K:10:NORMAL:FACETARGET,
                #CHASE;

STATES(PAIN)=SKEL:L:5:NORMAL:NOTHING,
             SKEL:L:5:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=SKEL:L:7:NORMAL:NOTHING,
              SKEL:M:7:NORMAL:NOTHING,
              SKEL:N:7:NORMAL:MAKEDEATHSOUND,
              SKEL:O:7:NORMAL:MAKEDEAD,
              SKEL:P:7:NORMAL:NOTHING,
              SKEL:Q:-1:NORMAL:NOTHING;

STATES(RESPAWN)=SKEL:Q:5:NORMAL:NOTHING,
                SKEL:P:5:NORMAL:NOTHING,
                SKEL:O:5:NORMAL:NOTHING,
                SKEL:N:5:NORMAL:NOTHING,
                SKEL:M:5:NORMAL:NOTHING,
                SKEL:L:5:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2783">[SHOTGUN_GUY:9]
SPAWNHEALTH=30;
REACTION_TIME=0.23;
RADIUS=20;
HEIGHT=56;
SPEED=8;
MASS=100;
PAINCHANCE=67%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,DISLOYAL,ATTACK_HURTS;
MINATTACK_CHANCE=22%;
CASTORDER=3;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=POSACT;
DEATH_SOUND="PODTH?";
PAIN_SOUND=POPAIN;
SIGHTING_SOUND="POSIT?";
OVERKILL_SOUND="SLOP";
DROPITEM=SHOTGUN;
RANGE_ATTACK=FORMER_HUMAN_SHOTGUN;

STATES(IDLE)=SPOS:A:10:NORMAL:LOOKOUT,
             SPOS:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=SPOS:A:3:NORMAL:CHASE,
              SPOS:A:3:NORMAL:CHASE,
              SPOS:B:3:NORMAL:CHASE,
              SPOS:B:3:NORMAL:CHASE,
              SPOS:C:3:NORMAL:CHASE,
              SPOS:C:3:NORMAL:CHASE,
              SPOS:D:3:NORMAL:CHASE,
              SPOS:D:3:NORMAL:CHASE;

STATES(MISSILE)=SPOS:E:10:NORMAL:FACETARGET,
                SPOS:F:10:BRIGHT:RANGE_ATTACK,
                SPOS:E:10:NORMAL:NOTHING,
                #CHASE;

STATES(PAIN)=SPOS:G:3:NORMAL:NOTHING,
             SPOS:G:3:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=SPOS:H:5:NORMAL:NOTHING,
              SPOS:I:5:NORMAL:MAKEDEATHSOUND,
              SPOS:J:5:NORMAL:MAKEDEAD,
              SPOS:K:5:NORMAL:NOTHING,
              SPOS:L:-1:NORMAL:NOTHING;

STATES(OVERKILL)=SPOS:M:5:NORMAL:NOTHING,
                 SPOS:N:5:NORMAL:MAKEOVERKILLSOUND,
                 SPOS:O:5:NORMAL:MAKEDEAD,
                 SPOS:P:5:NORMAL:NOTHING,
                 SPOS:Q:5:NORMAL:NOTHING,
                 SPOS:R:5:NORMAL:NOTHING,
                 SPOS:S:5:NORMAL:NOTHING,
                 SPOS:T:5:NORMAL:NOTHING,
                 SPOS:U:-1:NORMAL:NOTHING;

STATES(RESPAWN)=SPOS:K:5:NORMAL:NOTHING,
                SPOS:J:5:NORMAL:NOTHING,
                SPOS:I:5:NORMAL:NOTHING,
                SPOS:H:5:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2784">[SPECTRE:58]
SPAWNHEALTH=150;
REACTION_TIME=0.23;
RADIUS=30;
HEIGHT=56;
SPEED=10;
MASS=400;
PAINCHANCE=70%;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
SPECIAL=COUNT_AS_KILL,FUZZY,SHOOTABLE,SOLID,CLIMBABLE,NOSHADOW;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=SGTDTH;
PAIN_SOUND=DMPAIN;
SIGHTING_SOUND=SGTSIT;
STARTCOMBAT_SOUND=SGTATK;
CLOSE_ATTACK=DEMON_CLOSECOMBAT;

STATES(IDLE)=SARG:A:10:NORMAL:LOOKOUT,
             SARG:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=SARG:A:2:NORMAL:CHASE,
              SARG:A:2:NORMAL:CHASE,
              SARG:B:2:NORMAL:CHASE,
              SARG:B:2:NORMAL:CHASE,
              SARG:C:2:NORMAL:CHASE,
              SARG:C:2:NORMAL:CHASE,
              SARG:D:2:NORMAL:CHASE,
              SARG:D:2:NORMAL:CHASE;

STATES(MELEE)=SARG:E:8:NORMAL:FACETARGET,
              SARG:F:8:NORMAL:FACETARGET,
              SARG:G:8:NORMAL:CLOSE_ATTACK,
              #CHASE;

STATES(PAIN)=SARG:H:2:NORMAL:NOTHING,
             SARG:H:2:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=SARG:I:8:NORMAL:NOTHING,
              SARG:J:8:NORMAL:MAKEDEATHSOUND,
              SARG:K:4:NORMAL:NOTHING,
              SARG:L:4:NORMAL:MAKEDEAD,
              SARG:M:4:NORMAL:NOTHING,
              SARG:N:-1:NORMAL:NOTHING;

STATES(RESPAWN)=SARG:N:5:NORMAL:NOTHING,
                SARG:M:5:NORMAL:NOTHING,
                SARG:L:5:NORMAL:NOTHING,
                SARG:K:5:NORMAL:NOTHING,
                SARG:J:5:NORMAL:NOTHING,
                SARG:I:5:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2785">[THE_SPIDER_MASTERMIND:7]
SPAWNHEALTH=3000;
REACTION_TIME=0.23;
RADIUS=128;
HEIGHT=100;
SPEED=12;
MASS=1000;
PAINCHANCE=15%;
SPECIAL=BOSSMAN,TRIGGER_HAPPY,COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,NO_RESURRECT;
MINATTACK_CHANCE=22%;
CASTORDER=16;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=DMACT;
DEATH_SOUND=SPIDTH;
PAIN_SOUND=POPAIN;
SIGHTING_SOUND=SPISIT;
WALK_SOUND=METAL;
RANGE_ATTACK=FORMER_HUMAN_SHOTGUN;

STATES(IDLE)=SPID:A:10:NORMAL:LOOKOUT,
             SPID:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=SPID:A:3:NORMAL:WALKSOUND_CHASE,
              SPID:A:3:NORMAL:CHASE,
              SPID:B:3:NORMAL:CHASE,
              SPID:B:3:NORMAL:CHASE,
              SPID:C:3:NORMAL:WALKSOUND_CHASE,
              SPID:C:3:NORMAL:CHASE,
              SPID:D:3:NORMAL:CHASE,
              SPID:D:3:NORMAL:CHASE,
              SPID:E:3:NORMAL:WALKSOUND_CHASE,
              SPID:E:3:NORMAL:CHASE,
              SPID:F:3:NORMAL:CHASE,
              SPID:F:3:NORMAL:CHASE;

STATES(MISSILE)=SPID:A:20:BRIGHT:FACETARGET,
                SPID:G:4:BRIGHT:RANGE_ATTACK,
                SPID:H:4:BRIGHT:RANGE_ATTACK,
                SPID:H:1:BRIGHT:REFIRE_CHECK,
                #MISSILE:2;

STATES(PAIN)=SPID:I:3:NORMAL:NOTHING,
             SPID:I:3:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=SPID:J:20:NORMAL:MAKEDEATHSOUND,
              SPID:K:10:NORMAL:MAKEDEAD,
              SPID:L:10:NORMAL:NOTHING,
              SPID:M:10:NORMAL:NOTHING,
              SPID:N:10:NORMAL:NOTHING,
              SPID:O:10:NORMAL:NOTHING,
              SPID:P:10:NORMAL:NOTHING,
              SPID:Q:10:NORMAL:NOTHING,
              SPID:R:10:NORMAL:NOTHING,
              SPID:S:30:NORMAL:NOTHING,
              SPID:S:-1:NORMAL:NOTHING;

STATES(RESPAWN)=SPID:S:30:NORMAL:NOTHING,
                SPID:R:10:NORMAL:NOTHING,
                SPID:Q:10:NORMAL:NOTHING,
                SPID:P:10:NORMAL:NOTHING,
                SPID:O:10:NORMAL:NOTHING,
                SPID:N:10:NORMAL:NOTHING,
                SPID:M:10:NORMAL:NOTHING,
                SPID:L:10:NORMAL:NOTHING,
                SPID:K:10:NORMAL:NOTHING,
                SPID:J:20:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2786">[WOLFENSTEIN_SS:84]
SPAWNHEALTH=50;
REACTION_TIME=0.23;
RADIUS=20;
HEIGHT=56;
SPEED=8;
MASS=100;
PAINCHANCE=65%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE;
MINATTACK_CHANCE=22%;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;

ACTIVE_SOUND=POSACT;
DEATH_SOUND=SSDTH;
PAIN_SOUND=POPAIN;
SIGHTING_SOUND=SSSIT;
OVERKILL_SOUND="SLOP";

RANGE_ATTACK=FORMER_HUMAN_CHAINGUN;
DROPITEM=CLIP;

STATES(IDLE)=SSWV:A:10:NORMAL:LOOKOUT,
             SSWV:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=SSWV:A:3:NORMAL:CHASE,
               SSWV:A:3:NORMAL:CHASE,
               SSWV:B:3:NORMAL:CHASE,
               SSWV:B:3:NORMAL:CHASE,
               SSWV:C:3:NORMAL:CHASE,
               SSWV:C:3:NORMAL:CHASE,
               SSWV:D:3:NORMAL:CHASE,
               SSWV:D:3:NORMAL:CHASE;

STATES(MISSILE)=SSWV:E:10:NORMAL:FACETARGET,
               SSWV:F:10:NORMAL:FACETARGET,
               SSWV:G:4:BRIGHT:RANGE_ATTACK,
               SSWV:F:6:NORMAL:FACETARGET,
               SSWV:G:4:BRIGHT:RANGE_ATTACK,
               SSWV:F:1:BRIGHT:REFIRE_CHECK,
               #MISSILE:2;

STATES(PAIN)=SSWV:H:3:NORMAL:NOTHING,
             SSWV:H:3:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=SSWV:I:5:NORMAL:NOTHING,
              SSWV:J:5:NORMAL:MAKEDEATHSOUND,
              SSWV:K:5:NORMAL:MAKEDEAD,
              SSWV:L:5:NORMAL:NOTHING,
              SSWV:M:-1:NORMAL:NOTHING;

STATES(OVERKILL)=SSWV:N:5:NORMAL:NOTHING,
                 SSWV:O:5:NORMAL:MAKEOVERKILLSOUND,
                 SSWV:P:5:NORMAL:MAKEDEAD,
                 SSWV:Q:5:NORMAL:NOTHING,
                 SSWV:R:5:NORMAL:NOTHING,
                 SSWV:S:5:NORMAL:NOTHING,
                 SSWV:T:5:NORMAL:NOTHING,
                 SSWV:U:5:NORMAL:NOTHING,
                 SSWV:V:-1:NORMAL:NOTHING;

STATES(RESPAWN)=SSWV:K:5:NORMAL:NOTHING,
                SSWV:J:5:NORMAL:NOTHING,
                SSWV:I:5:NORMAL:NOTHING,
                SSWV:H:5:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2787">[ZOMBIEMAN:3004]
SPAWNHEALTH=20;
REACTION_TIME=0.23;
RADIUS=20;
HEIGHT=56;
SPEED=8;
MASS=100;
PAINCHANCE=78%;
SPECIAL=COUNT_AS_KILL,SOLID,CLIMBABLE,SHOOTABLE,DISLOYAL,ATTACK_HURTS;
MINATTACK_CHANCE=22%;
CASTORDER=2;
BLOOD=BLOOD;
RESPAWN_EFFECT=RESPAWN_FLASH;
ACTIVE_SOUND=POSACT;
DEATH_SOUND="PODTH?";
PAIN_SOUND=POPAIN;
SIGHTING_SOUND="POSIT?";
OVERKILL_SOUND="SLOP";
DROPITEM=CLIP;
RANGE_ATTACK=FORMER_HUMAN_PISTOL;

STATES(IDLE)=POSS:A:10:NORMAL:LOOKOUT,
             POSS:B:10:NORMAL:LOOKOUT;

STATES(CHASE)=POSS:A:4:NORMAL:CHASE,
              POSS:A:4:NORMAL:CHASE,
              POSS:B:4:NORMAL:CHASE,
              POSS:B:4:NORMAL:CHASE,
              POSS:C:4:NORMAL:CHASE,
              POSS:C:4:NORMAL:CHASE,
              POSS:D:4:NORMAL:CHASE,
              POSS:D:4:NORMAL:CHASE;

STATES(MISSILE)=POSS:E:10:NORMAL:FACETARGET,
                POSS:F:8:NORMAL:RANGE_ATTACK,
                POSS:E:8:NORMAL:NOTHING,
                #CHASE;

STATES(PAIN)=POSS:G:3:NORMAL:NOTHING,
             POSS:G:3:NORMAL:MAKEPAINSOUND,
             #CHASE;

STATES(DEATH)=POSS:H:5:NORMAL:NOTHING,
              POSS:I:5:NORMAL:MAKEDEATHSOUND,
              POSS:J:5:NORMAL:MAKEDEAD,
              POSS:K:5:NORMAL:NOTHING,
              POSS:L:-1:NORMAL:NOTHING;

STATES(OVERKILL)=POSS:M:5:NORMAL:NOTHING,
                 POSS:N:5:NORMAL:MAKEOVERKILLSOUND,
                 POSS:O:5:NORMAL:MAKEDEAD,
                 POSS:P:5:NORMAL:NOTHING,
                 POSS:Q:5:NORMAL:NOTHING,
                 POSS:R:5:NORMAL:NOTHING,
                 POSS:S:5:NORMAL:NOTHING,
                 POSS:T:5:NORMAL:NOTHING,
                 POSS:U:-1:NORMAL:NOTHING;

STATES(RESPAWN)=POSS:K:5:NORMAL:NOTHING,
                POSS:J:5:NORMAL:NOTHING,
                POSS:I:5:NORMAL:NOTHING,
                POSS:H:5:NORMAL:NOTHING,
                #CHASE;

STATES(GIB)=POL5:A:-1:NORMAL:PLAYSOUND(CRUSH);</t>
<t tx="T2788">// Open Door (closes)
[1]
TYPE=PUSH;
ACTIVATORS=PLAYER, MONSTER;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

// Walk Once - Open the Door
[2]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2; 
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;

// Walk Once - Close the door
[3]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=DORCLS;

// Walk Once - Raise the door (with close)
[4]
TYPE=WALK;
ACTIVATORS=PLAYER, MONSTER;
COUNT=1;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;
CEILING.PAUSE_TIME=150T;

// Walk Once - Raise the floor to the next highest neighbour floor height
[5]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.DEST_OFFSET=-8;
FLOOR.SFX_UP=STNMOV;

// Walk Once - Fast ceiling crush
[6]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

// BUILD STAIRS S1
[7]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=BUILDSTAIRS;
FLOOR.SPEED_UP=0.25;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=8;
FLOOR.SFX_UP=STNMOV;

// Walk once - Build stairs
[8]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=BUILDSTAIRS;
FLOOR.SPEED_UP=0.25;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=8;
FLOOR.SFX_STOP=PSTOP;
FLOOR.SFX_UP=STNMOV;

// DONUT S1
[9]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
DONUT=TRUE;
DONUT_IN_SFX=STNMOV;
DONUT_OUT_SFX=STNMOV;

// Walk once - Platform down, wait, and then back up
[10]
TYPE=WALK;
ACTIVATORS=PLAYER, MONSTER;
COUNT=1;
FLOOR.TYPE=MOVEWAITRETURN;
FLOOR.SPEED_UP=4;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// EXIT LEVEL S1
[11]
TYPE=PUSH;
ACTIVATORS=PLAYER;
ACTIVATE_SOUND="SWTCHX";
COUNT=1;
EXIT=NORMAL;

// Walk once - Lights to the level of brightest neighbour
[12]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=SET;
LIGHT_LEVEL=0;

// Walk once - Lights to brightest (255)
[13]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=SET;
LIGHT_LEVEL=255;

// RAISE FLOOR 32 AND CHANGE S1
[14]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=32;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR 24 AND CHANGE S1
[15]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

// Walk once - CLOSE DOOR 30 W1
[16]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

// Walk once - Start light strobing
[17]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=STROBE;
LIGHT_BRIGHT_TIME=5T;
LIGHT_DARK_TIME=35T;

// RAISE FLOOR TO NEXT S1
[18]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// Walk once - Lower floor to the next lowest floor
[19]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// RAISE FLOOR TO NEXT HIGHEST AND CHANGE S1
[20]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.TEXTURE="-";
FLOOR.SFX_UP=STNMOV;

// PLAT DOWN WAIT UP STAY S1
[21]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVEWAITRETURN;
FLOOR.SPEED_UP=4;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// Walk once - Raise to next highest floor
[22]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
SECSPECIAL=0;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.SPEED_DOWN=0.5;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

// LOWER FLOOR TO LOWEST S1
[23]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// RAISE FLOOR G1
[24]
TYPE=SHOOT;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.SFX_UP=STNMOV;

// Walk once - CEILING CRUSH AND RAISE W1
[25]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=1;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=0.80091;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

// BLUE DOOR SR
[26]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=BLUE_CARD,BLUE_SKULL;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;
FAILED_MESSAGE=NeedBlueForDoor;

// YELLOW DOOR SR
[27]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=YELLOW_CARD, YELLOW_SKULL;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;
FAILED_MESSAGE=NeedYellowForDoor;

// RED DOOR SR
[28]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=RED_CARD, RED_SKULL;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;
FAILED_MESSAGE=NeedRedForDoor;

// RAISE DOOR S1
[29]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

// RAISE FLOOR TO TEXTURE
[30]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOWESTBOTTOMTEXTURE;
FLOOR.SFX_UP=STNMOV;

// MANUAL DOOR OPEN S1
[31]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;

// BLUE DOOR OPEN S1
[32]
TYPE=PUSH;
KEYS=BLUE_CARD, BLUE_SKULL;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;
FAILED_MESSAGE=NeedBlueForDoor;

// RED DOOR OPEN S1
[33]
TYPE=PUSH;
KEYS=RED_CARD, RED_SKULL;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;
FAILED_MESSAGE=NeedRedForDoor;

// YELLOW DOOR OPEN S1
[34]
TYPE=PUSH;
KEYS=YELLOW_CARD, YELLOW_SKULL;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;
FAILED_MESSAGE=NeedYellowForDoor;

// LIGHTS 35
[35]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=SET;
LIGHT_LEVEL=35;

// LOWER FLOOR (TURBO) W1
[36]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.DEST_OFFSET=8;
FLOOR.SFX_DOWN=STNMOV;

// LOWER AND CHANGE W1
[37]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.TEXTURE="-";
FLOOR.SFX_DOWN=STNMOV;

// LOWER FLOOR TO LOWEST W1
[38]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// Walk Once - Player and Creature Teleport
[39]
TYPE=WALK;
ACTIVATORS=PLAYER, MONSTER;
COUNT=1;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;
SINGLESIDED=TRUE;

// NOTE: line type 40 is defaulted to the following in DOOM and DOOM2 (rem'd out):

/*

	// RAISE CEILING LOWER FLOOR W1
	[40]
	TYPE=WALK;
	ACTIVATORS=PLAYER;
	COUNT=1;
	FLOOR.TYPE=MOVE;
	FLOOR.SPEED_DOWN=1;
	FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
	FLOOR.SFX_DOWN=STNMOV;
	CEILING.TYPE=MOVE;
	CEILING.SPEED_UP=1;
	CEILING.DEST_REF=HISURROUNDINGCEILING;
	CEILING.SFX_UP=STNMOV;
	
*/

// ...and this is the BOOM/MBF linetype defined (which is the currently active type):

[40] // RAISE CEILING TO HEC W1
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=1;
CEILING.DEST_REF=HISURROUNDINGCEILING;
CEILING.SFX_UP=STNMOV;

// LOWER CEILING TO FLOOR S1
[41]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=STNMOV;

// Switch repeater - Close Door
[42]
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=DORCLS;

// Switch Repeater -  Lower ceiling the the floor
[43]
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=STNMOV;

// CEILING CRUSH W1
[44]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

// Switch Repeater - Lower floor to the next lowest surrounding floor
[45]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// OPEN DOOR GR
[46]
TYPE=SHOOT;
ACTIVATORS=PLAYER, MONSTER;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;

// RAISE FLOOR TO NEAREST AND CHANGE G1
[47]
TYPE=SHOOT;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

// SCROLL LEFT
[48]
SCROLL=LEFT;
SCROLLING_SPEED=1;

// CEILING CRUSH AND RAISE S1
[49]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=1;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

// CLOSE DOOR S1
[50]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=DORCLS;</t>
<t tx="T2791">// SECRET EXIT S1
[51]
TYPE=PUSH;
ACTIVATORS=PLAYER;
ACTIVATE_SOUND="SWTCHX";
COUNT=1;
EXIT=SECRET;

// EXIT W1
[52]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
EXIT=NORMAL;

// PERPETUAL RAISE W1
[53]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=CONTINUOUS;
FLOOR.SPEED_UP=1;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// PLATFORM STOP W1
[54]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=STOP;

// RAISE FLOOR CRUSH S1
[55]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.DEST_OFFSET=-8;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR CRUSH W1
[56]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.DEST_OFFSET=-8;
FLOOR.SFX_UP=STNMOV;

// CEILING CRUSH STOP W1
[57]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=STOP;

// RAISE FLOOR 24
[58]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR 24 AND CHANGE W1
[59]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

// Switch Repeater - Lower floor to the lowest surrounding floor
[60]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// Switch Repeater - Open door
[61]
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;

// Switch Repeater - Platform goes down, wait, then up and stay
[62]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVEWAITRETURN;
FLOOR.SPEED_UP=4;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// Switch Repeater - Raise the door (closes after pause)
[63]
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

// RAISE FLOOR TO CEILING SR
[64]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR CRUSH SR
[65]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.DEST_OFFSET=8;
CRUSH=TRUE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR 24 AND CHANGE SR
[66]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.SFX_UP=STNMOV;
FLOOR.TEXTURE="+";

// RAISE FLOOR 32 AND CHANGE SR
[67]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=32;
FLOOR.SFX_UP=STNMOV;
FLOOR.TEXTURE="+";

// RAISE FLOOR TO NEAREST AND CHANGE SR
[68]
TYPE=PUSH;
ACTIVATORS=PLAYER;
SECSPECIAL=0;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR TO NEAREST SR
[69]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.SFX_UP=STNMOV;

// TURBO LOWER FLOOR SR
[70]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.DEST_OFFSET=8;
FLOOR.SFX_DOWN=STNMOV;

// TURBO LOWER FLOOR 71 S1
[71]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.DEST_OFFSET=8;
FLOOR.SFX_DOWN=STNMOV;

// CEILING CRUSH WR
[72]
TYPE=WALK;
ACTIVATORS=PLAYER;
CRUSH=TRUE;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_DOWN=STNMOV;

// CEILING CRUSH AND RAISE WR
[73]
TYPE=WALK;
ACTIVATORS=PLAYER;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=1;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

// CEILING CRUSH STOP WR
[74]
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=STOP;

// CLOSE DOOR WR
[75]
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=DORCLS;

// CLOSE DOOR FOR 30 WR
[76]
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

// FAST CRUSHING CEILING WR
[77]
TYPE=WALK;
ACTIVATORS=PLAYER;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

// NOTE: 78 was documented in some editors as 'WR Lights to dimmest neighbor'
//       but it actually does nothing since DOOM 1.666 (per the official DOOM specs)
//       Next is the updated BOOM line types instead.

[78] // Transfer floor texture (NXP) SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=0;
FLOOR.TEXTURE="-";

// LIGHTS DARK 35 WR
[79]
TYPE=WALK;
ACTIVATORS=PLAYER;
LIGHT_TYPE=SET;
LIGHT_LEVEL=35;

// LIGHTS NEIGHBOUR WR
[80]
TYPE=WALK;
ACTIVATORS=PLAYER;
LIGHT_TYPE=SET;
LIGHT_LEVEL=0;

// LIGHTS 255 WR
[81]
TYPE=WALK;
ACTIVATORS=PLAYER;
LIGHT_TYPE=SET;
LIGHT_LEVEL=255;

// LOWER FLOOR TO LOWEST WR
[82]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.SFX_UP=STNMOV;
FLOOR.SFX_DOWN=STNMOV;

// LOWER FLOOR WR
[83]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// LOWER AND CHANGE WR
[84]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.TEXTURE="-";
FLOOR.SFX_DOWN=STNMOV;

// NOTE: linetype 85 is not used in DOOM or DOOM2 - it's a Heretic linetype, but BOOM uses it as something else...

[85] // SCROLL RIGHT (Boom)
SCROLL=RIGHT;
SCROLLING_SPEED=1;

// OPEN DOOR WR
[86]
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;

// PERPETUAL PLAT RAISE WR
[87]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=CONTINUOUS;
FLOOR.SPEED_UP=1;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// PLAT DOWN WAIT UP STAY WR
[88]
TYPE=WALK;
ACTIVATORS=PLAYER, MONSTER;
FLOOR.TYPE=MOVEWAITRETURN;
FLOOR.SPEED_UP=4;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// PLAT STOP WR
[89]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=STOP;

// RAISE DOOR WR
[90]
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

// RAISE FLOOR WR
[91]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR 24 WR
[92]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR 24 AND CHANGE WR
[93]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR CRUSH WR
[94]
TYPE=WALK;
ACTIVATORS=PLAYER;
CRUSH=TRUE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.DEST_OFFSET=-8;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR TO NEAREST AND CHANGE WR
[95]
TYPE=WALK;
ACTIVATORS=PLAYER;
SECSPECIAL=0;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

// RAISE TO TEXTURE WR
[96]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOWESTBOTTOMTEXTURE;
FLOOR.SFX_UP=STNMOV;

// TELEPORT WR
[97]
TYPE=WALK;
ACTIVATORS=PLAYER, MONSTER;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;
SINGLESIDED=TRUE;

// LOWER FLOOR TURBO WR
[98]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.DEST_OFFSET=8;
FLOOR.SFX_DOWN=STNMOV;

// BLAZE OPEN DOOR BLUE SR
[99]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=BLUE_CARD, BLUE_SKULL;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;
FAILED_MESSAGE=NeedBlueForDoor;

// BUILD STAIRS TURBO 16 W1
[100]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=BUILDSTAIRS;
FLOOR.SPEED_UP=4;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=16;
FLOOR.SFX_UP=STNMOV;</t>
<t tx="T2792">// RAISE FLOOR S1
[101]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOSURROUNDINGCEILING;
FLOOR.SFX_UP=STNMOV;

// LOWER FLOOR TO SURROUNDING S1
[102]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// OPEN DOOR S1
[103]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=2;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=DOROPN;

// LIGHTS OFF W1
[104]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=SET;
LIGHT_LEVEL=1;

// BLAZING DOOR RAISE WR
[105]
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=8;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR OPEN WR
[106]
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;

// BLAZING DOOR CLOSE WR
[107]
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR RAISE W1
[108]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=8;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=BDOPN;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR OPEN W1
[109]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;

// BLAZING DOOR CLOSE W1
[110]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR RAISE S1
[111]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=8;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=BDOPN;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR OPEN S1
[112]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;

// BLAZING DOOR CLOSE S1
[113]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR RAISE SR
[114]
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=8;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=BDOPN;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR OPEN SR
[115]
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;

// BLAZING DOOR CLOSE SR
[116]
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR RAISE SR
[117]
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=8;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.PAUSE_TIME=150T;
CEILING.SFX_UP=BDOPN;
CEILING.SFX_DOWN=BDCLS;

// BLAZING DOOR OPEN S1
[118]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;

// RAISE FLOOR TO NEXT HIGHEST W1
[119]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.SFX_UP=STNMOV;

// BLAZING PLAT DOWN WAIT UP STAY WR
[120]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVEWAITRETURN;
FLOOR.SPEED_UP=8;
FLOOR.SPEED_DOWN=8;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// BLAZING PLAT DOWNWAITUPSTAY W1
[121]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVEWAITRETURN;
FLOOR.SPEED_UP=8;
FLOOR.SPEED_DOWN=8;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// BLAZING PLAT DOWN WAIT UP STAY S1
[122]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVEWAITRETURN;
FLOOR.SPEED_UP=8;
FLOOR.SPEED_DOWN=8;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// BLAZING PLAT DOWN WAIT UP STAY SR
[123]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVEWAITRETURN;
FLOOR.SPEED_UP=8;
FLOOR.SPEED_DOWN=8;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=105T;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

// SECRET EXIT W1
[124]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
EXIT=SECRET;

// MONSTER TELEPORT W1
[125]
TYPE=WALK;
ACTIVATORS=MONSTER;
COUNT=1;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;
SINGLESIDED=TRUE;

// TELEPORT MONSTERS WR
[126]
TYPE=WALK;
ACTIVATORS=MONSTER;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;
SINGLESIDED=TRUE;

// BUILD STAIRS TURBO 16 S1
[127]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=BUILDSTAIRS;
FLOOR.SPEED_UP=4;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=16;
FLOOR.SFX_UP=STNMOV;

// RAISE TO NEAREST FLOOR WR
[128]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR TURBO WR
[129]
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=4;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR TURBO W1
[130]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=4;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR TURBO S1
[131]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=4;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.SFX_UP=STNMOV;

// RAISE FLOOR TURBO SR
[132]
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=4;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=NEXTHIGHESTFLOOR;
FLOOR.SFX_UP=STNMOV;

// BLAZING OPEN DOOR BLUE S1
[133]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=BLUE_CARD, BLUE_SKULL;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;
FAILED_MESSAGE=NeedBlueForObject;

// BLAZE OPEN DOOR RED SR
[134]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=RED_CARD, RED_SKULL;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.SPEED_DOWN=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;
FAILED_MESSAGE=NeedRedForObject;

// BLAZING OPEN DOOR RED S1
[135]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=RED_CARD, RED_SKULL;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;
FAILED_MESSAGE=NeedRedForObject;

// BLAZING DOOR OPEN YELLOW SR
[136]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=YELLOW_CARD, YELLOW_SKULL;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;
FAILED_MESSAGE=NeedYellowForObject;

// BLAZING OPEN DOOR YELLOW S1
[137]
TYPE=PUSH;
ACTIVATORS=PLAYER;
KEYS=YELLOW_CARD, YELLOW_SKULL;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=8;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.DEST_OFFSET=-4;
CEILING.SFX_UP=BDOPN;
FAILED_MESSAGE=NeedYellowForObject;

// LIGHTS ON SR
[138]
TYPE=PUSH;
ACTIVATORS=PLAYER;
LIGHT_TYPE=SET;
LIGHT_LEVEL=255;

// LIGHTS 35 SR
[139]
TYPE=PUSH;
ACTIVATORS=PLAYER;
LIGHT_TYPE=SET;
LIGHT_LEVEL=35;

// Switch Once - Raise the floor up by 512
[140]
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=512;
FLOOR.SFX_UP=STNMOV;

// SILENT CRUSHING CEILING W1
[141]
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=1;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_START=PSTART;
CEILING.SFX_STOP=PSTOP;

// BOOM SPECIAL LINE TYPES BELOW

[142] // Raise the floor up by 512 W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=512;
FLOOR.SFX_UP=STNMOV;

[143] // RAISE FLOOR 24 AND CHANGE W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.SFX_UP=STNMOV;
FLOOR.TEXTURE="+";

[144] // RAISE FLOOR 32 AND CHANGE W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
SECSPECIAL=0;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=32;
FLOOR.SFX_UP=STNMOV;
FLOOR.TEXTURE="+";

[145] // LOWER CEILING TO FLOOR W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=STNMOV;

[146] // DONUT W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
DONUT=TRUE;
DONUT_IN_SFX=STNMOV;
DONUT_OUT_SFX=STNMOV;

[147] // Raise the floor up by 512 WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=512;
FLOOR.SFX_UP=STNMOV;

[148] // RAISE FLOOR 24 AND CHANGE WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.SFX_UP=STNMOV;
FLOOR.TEXTURE="+";

[149] // RAISE FLOOR 32 AND CHANGE WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
SECSPECIAL=0;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=0.5;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=32;
FLOOR.SFX_UP=STNMOV;
FLOOR.TEXTURE="+";

[150] // SILENT CRUSHING CEILING WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=1;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_START=PSTART;
CEILING.SFX_STOP=PSTOP;</t>
<t tx="T2793">[201] // LOWER CEILING TO LOWEST NEIGHBOUR WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.SFX_DOWN=STNMOV;

[202] // LOWER CEILING TO HIGHEST FLOOR WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=HISURROUNDINGFLOOR;
CEILING.SFX_DOWN=STNMOV;

[203] // LOWER CEILING TO LOWEST NEIGHBOUR S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.SFX_DOWN=STNMOV;

[204] // LOWER CEILING TO HIGHEST FLOOR S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=HISURROUNDINGFLOOR;
CEILING.SFX_DOWN=STNMOV;

[205] // LOWER CEILING TO LOWEST NEIGHBOUR SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.SFX_DOWN=STNMOV;

[206] // LOWER CEILING TO HIGHEST FLOOR SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=HISURROUNDINGFLOOR;
CEILING.SFX_DOWN=STNMOV;

[207] // Silent Preserving Teleport W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER, MONSTER;
COUNT=1;
SINGLESIDED=TRUE;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEPORT_SPECIAL=PRESERVE;  // SILENT
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;

[208] // Silent Preserving Teleport WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER, MONSTER;
SINGLESIDED=TRUE;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEPORT_SPECIAL=PRESERVE;  // SILENT
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;

[209] // Silent Preserving Teleport S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER, MONSTER;
COUNT=1;
SINGLESIDED=TRUE;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEPORT_SPECIAL=PRESERVE;  // SILENT
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;

[210] // Silent Preserving Teleport SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER, MONSTER;
SINGLESIDED=TRUE;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEPORT_SPECIAL=PRESERVE;  /// SILENT
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;

// 211 PLATFORM INSTANT TOGGLE SR (Boom) -- Unsupported
// 212 PLATFORM INSTANT TOGGLE WR (Boom) -- Unsupported

[213] // Transfer lighting to tagged floor (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SECTOR_EFFECT=LIGHT_FLOOR;

// 214 Scroll ceiling accelerate (Boom) -- Unsupported
// 215 Scroll floor accelerate (Boom)   -- Unsupported
// 216 Push objects accelerate (Boom)   -- Unsupported
// 217 Scroll &amp; Push accelerate (Boom)  -- Unsupported
// 218 Scroll wall accelerate (Boom)    -- Unsupported

[219] // LOWER FLOOR TURBO W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=NEXTLOWESTFLOOR;
FLOOR.SFX_DOWN=STNMOV;

[220] // LOWER FLOOR TURBO WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=NEXTLOWESTFLOOR;
FLOOR.SFX_DOWN=STNMOV;

[221] // LOWER FLOOR TURBO S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=NEXTLOWESTFLOOR;
FLOOR.SFX_DOWN=STNMOV;

[222] // LOWER FLOOR TURBO SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=4;
FLOOR.DEST_REF=NEXTLOWESTFLOOR;
FLOOR.SFX_DOWN=STNMOV;

// 223 Friction (Boom)  --  Not yet supported

// 224 Set wind force (Boom)  --  Unsupported
// 225 Set current force (Boom)  --  Unsupported
// 226 Set point push/pull force (Boom)  --  Unsupported

// 227 ELEVATOR TO NEXT HIGHEST W1 (Boom)  --  Pending new code
// 228 ELEVATOR TO NEXT HIGHEST WR (Boom)  --  Pending new code
// 229 ELEVATOR TO NEXT HIGHEST S1 (Boom)  --  Pending new code
// 230 ELEVATOR TO NEXT HIGHEST SR (Boom)  --  Pending new code

// 231 ELEVATOR TO NEXT LOWEST W1 (Boom)  --  Pending new code
// 232 ELEVATOR TO NEXT LOWEST WR (Boom)  --  Pending new code
// 233 ELEVATOR TO NEXT LOWEST S1 (Boom)  --  Pending new code
// 234 ELEVATOR TO NEXT LOWEST SR (Boom)  --  Pending new code

// 235 ELEVATOR TO ACTIVATOR HEIGHT W1 (Boom)  --  Unsupported
// 236 ELEVATOR TO ACTIVATOR HEIGHT WR (Boom)  --  Unsupported
// 237 ELEVATOR TO ACTIVATOR HEIGHT S1 (Boom)  --  Unsupported
// 238 ELEVATOR TO ACTIVATOR HEIGHT SR (Boom)  --  Unsupported

[239] // Transfer floor texture (NXP) W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=0;
FLOOR.TEXTURE="-";

[240] // Transfer floor texture (NXP) WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=0;
FLOOR.TEXTURE="-";

[241] // Transfer floor texture (NXP) S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=0;
FLOOR.TEXTURE="-";

[242] // Deep water (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=LIQUID,BOOMTEX,WATER,SEE_THROUGH,SHOOT_THROUGH;

// 243 Silent  Line Teleport Reverse W1 (Boom)  --  Unsupported
// 244 Silent  Line Teleport Reverse WR (Boom)  --  Unsupported

// 245 Scroll ceiling displacement (Boom)       -- Unsupported
// 246 Scroll floor displacement (Boom)         -- Unsupported
// 247 Push objects displacement (Boom)         -- Unsupported
// 248 Scroll &amp; Push displacement (Boom)        -- Unsupported
// 249 Scroll wall displacement (Boom)          -- Unsupported

[250] // Scroll tagged ceiling (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SECTOR_EFFECT=SCROLL_CEILING;

[251] // Scroll tagged floor (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SECTOR_EFFECT=SCROLL_FLOOR;

[252] // Carry objects on floor (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SECTOR_EFFECT=PUSH_THINGS;

[253] // Scroll floor and carry objects (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SECTOR_EFFECT=SCROLL_FLOOR,PUSH_THINGS;

[254] // 254 Scroll tagged wall (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
LINE_EFFECT=VECTOR_SCROLL;

[255] // Scroll wall by sidedef offsets (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
LINE_EFFECT=OFFSET_SCROLL;

[256] // BUILD STAIRS WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=BUILDSTAIRS;
FLOOR.SPEED_UP=0.25;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=8;
FLOOR.SFX_UP=STNMOV;

[257] // BUILD STAIRS TURBO 16 WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=BUILDSTAIRS;
FLOOR.SPEED_UP=4;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=16;
FLOOR.SFX_UP=STNMOV;

[258] // BUILD STAIRS SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=BUILDSTAIRS;
FLOOR.SPEED_UP=0.25;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=8;
FLOOR.SFX_UP=STNMOV;

[259] // BUILD STAIRS TURBO 16 SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=BUILDSTAIRS;
FLOOR.SPEED_UP=4;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=16;
FLOOR.SFX_UP=STNMOV;

[260] // Make tagged lines translucent (Boom)  
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
LINE_EFFECT=TRANSLUCENT;

[261] // Transfer lighting to tagged ceiling (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SECTOR_EFFECT=LIGHT_CEILING;

// 262 Silent  Line Teleport W1 (Boom)          --  Unsupported
// 263 Silent  Line Teleport WR (Boom)          --  Unsupported
// 264 Monster Line Teleport W1 (Boom)          --  Unsupported
// 265 Monster Line Teleport WR (Boom)          --  Unsupported

// 266 Monster Line Teleport Reverse W1 (Boom)  --  Unsupported
// 267 Monster Line Teleport Reverse WR (Boom)  --  Unsupported

[268] // Monster-only Silent Teleport W1 (Boom)
TYPE=PUSH;
ACTIVATORS=MONSTER;
COUNT=1;
SINGLESIDED=TRUE;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;

[269] // Monster-only Silent Teleport WR (Boom)
TYPE=PUSH;
ACTIVATORS=MONSTER;
SINGLESIDED=TRUE;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;

// 271 Transfer tex to sector's sky (MBF)           --  Unsupported
// 272 Transfer tex to sector's sky, flipped (MBF)  -- Unsupported

// DOOM Legacy SPECIAL LINE TYPES

[280] // Legacy "3D liquid floor" (same as EDGE line type 405)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER;
TRANSLUCENCY=60%;

[281] // Legacy "3D floor"
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THICK;

[289] // Legacy "3D floor" (does not affect light properties below the "3D floor", uses master sector light properties instead)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THICK,NOSHADE;</t>
<t tx="T2794">[151] // RAISE CEILING TO HEC WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=1;
CEILING.DEST_REF=HISURROUNDINGCEILING;
CEILING.SFX_UP=STNMOV;

[152] // LOWER CEILING TO FLOOR WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_DOWN=STNMOV;

[153] // Transfer floor texture (TXP) W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=0;
FLOOR.TEXTURE="+";

[154] // Transfer floor texture (TXP) WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=0;
FLOOR.TEXTURE="+";

[155] // DONUT WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
DONUT=TRUE;
DONUT_IN_SFX=STNMOV;
DONUT_OUT_SFX=STNMOV;

[156] // Start light strobing WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
LIGHT_TYPE=STROBE;
LIGHT_BRIGHT_TIME=5T;
LIGHT_DARK_TIME=35T;

[157] // Lights to dimmest neighbour WR (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
LIGHT_TYPE=SET;
LIGHT_LEVEL=1;   // LOSURROUNDING

[158] // RAISE FLOOR TO TEXTURE S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOWESTBOTTOMTEXTURE;
FLOOR.SFX_UP=STNMOV;

[159] // LOWER AND CHANGE S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.TEXTURE="-";
FLOOR.SFX_DOWN=STNMOV;

[160] // RAISE FLOOR 24 AND CHANGE S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

[161] // RAISE FLOOR 24 S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.SFX_UP=STNMOV;

[162] // PERPETUAL RAISE S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=CONTINUOUS;
FLOOR.SPEED_UP=1;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=3;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

[163] // PLATFORM STOP S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=STOP;

[164] // Fast ceiling crush S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

[165] // SILENT CRUSHING CEILING S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=1;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_START=PSTART;
CEILING.SFX_STOP=PSTOP;

[166] // RAISE CEILING TO HEC S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=1;
CEILING.DEST_REF=HISURROUNDINGCEILING;
CEILING.SFX_UP=STNMOV;

[167] // CEILING LOWER TO FLOOR+8 S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

[168] // CEILING CRUSH STOP S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=STOP;

[169] // Lights to brightest neighbour S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=SET;
LIGHT_LEVEL=0;  // HISURROUNDING

[170] // LIGHTS 35 S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=SET;
LIGHT_LEVEL=35;

[171] // LIGHTS 255 S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=SET;
LIGHT_LEVEL=255;

[172] // Start light strobing S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=STROBE;
LIGHT_BRIGHT_TIME=5T;
LIGHT_DARK_TIME=35T;

[173] // Lights to dimmest neighbour S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
LIGHT_TYPE=SET;
LIGHT_LEVEL=1;   // LOSURROUNDING

[174] // Player and Creature Teleport S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER, MONSTER;
COUNT=1;
SINGLESIDED=TRUE;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;

[175] // CLOSE DOOR 30 S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

[176] // RAISE FLOOR TO TEXTURE SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=LOWESTBOTTOMTEXTURE;
FLOOR.SFX_UP=STNMOV;

[177] // LOWER AND CHANGE SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=LOSURROUNDINGFLOOR;
FLOOR.TEXTURE="-";
FLOOR.SFX_DOWN=STNMOV;

[178] // Raise the floor up by 512 SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=512;
FLOOR.SFX_UP=STNMOV;

[179] // RAISE FLOOR 24 AND CHANGE SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.TEXTURE="+";
FLOOR.SFX_UP=STNMOV;

[180] // RAISE FLOOR 24 SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=24;
FLOOR.SFX_UP=STNMOV;

[181] // PERPETUAL RAISE SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=CONTINUOUS;
FLOOR.SPEED_UP=1;
FLOOR.SPEED_DOWN=1;
FLOOR.DEST_REF=HISURROUNDINGFLOOR;
FLOOR.PAUSE_TIME=3;
FLOOR.SFX_START=PSTART;
FLOOR.SFX_STOP=PSTOP;

[182] // PLATFORM STOP SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=STOP;

[183] // Fast ceiling crush SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

[184] // CEILING CRUSH AND RAISE SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=1;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

[185] // SILENT CRUSHING CEILING SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CRUSH=TRUE;
CEILING.TYPE=CONTINUOUS;
CEILING.SPEED_UP=1;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_START=PSTART;
CEILING.SFX_STOP=PSTOP;

[186] // RAISE CEILING TO HEC SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_UP=1;
CEILING.DEST_REF=HISURROUNDINGCEILING;
CEILING.SFX_UP=STNMOV;

[187] // CEILING LOWER TO FLOOR+8 SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=FLOOR;
CEILING.DEST_OFFSET=8;
CEILING.SFX_UP=STNMOV;
CEILING.SFX_DOWN=STNMOV;

[188] // CEILING CRUSH STOP SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=STOP;

[189] // Transfer floor texture (TXP) S1 (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=0;
FLOOR.TEXTURE="+";

[190] // Transfer floor texture (TXP) SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=0;
FLOOR.TEXTURE="+";

[191] // DONUT SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
DONUT=TRUE;
DONUT_IN_SFX=STNMOV;
DONUT_OUT_SFX=STNMOV;

[192] // Lights to brightest neighbour SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
LIGHT_TYPE=SET;
LIGHT_LEVEL=0;  // HISURROUNDING

[193] // Start light strobing SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
LIGHT_TYPE=STROBE;
LIGHT_BRIGHT_TIME=5T;
LIGHT_DARK_TIME=35T;

[194] // Lights to dimmest neighbour SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
LIGHT_TYPE=SET;
LIGHT_LEVEL=1;   // LOSURROUNDING

[195] // Player and Creature Teleport SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER, MONSTER;
COUNT=1;
SINGLESIDED=TRUE;
TELEPORT=TRUE;
TELEPORT_DELAY=18T;
TELEIN_EFFECTOBJ=TELEPORT_FLASH;
TELEOUT_EFFECTOBJ=TELEPORT_FLASH;

[196] // CLOSE DOOR 30 SR (Boom)
TYPE=PUSH;
ACTIVATORS=PLAYER;
CEILING.TYPE=MOVEWAITRETURN;
CEILING.SPEED_UP=2;
CEILING.SPEED_DOWN=2;
CEILING.DEST_REF=FLOOR;
CEILING.SFX_UP=DOROPN;
CEILING.SFX_DOWN=DORCLS;

[197] // EXIT LEVEL G1 (Boom)
TYPE=SHOOT;
ACTIVATORS=PLAYER;
ACTIVATE_SOUND="SWTCHX";
COUNT=1;
EXIT=NORMAL;

[198] // SECRET EXIT G1 (Boom)
TYPE=SHOOT;
ACTIVATORS=PLAYER;
ACTIVATE_SOUND="SWTCHX";
COUNT=1;
EXIT=NORMAL;

[199] // LOWER CEILING TO LOWEST NEIGHBOUR W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=LOSURROUNDINGCEILING;
CEILING.SFX_DOWN=STNMOV;

[200] // LOWER CEILING TO HIGHEST FLOOR W1 (Boom)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
CEILING.TYPE=MOVE;
CEILING.SPEED_DOWN=1;
CEILING.DEST_REF=HISURROUNDINGFLOOR;
CEILING.SFX_DOWN=STNMOV;</t>
<t tx="T2795">// EDGE SPECIAL LINE TYPES BELOW

[400] // EDGE Thick Extrafloor (dummy texture)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THICK;

[401] // EDGE Thick Extrafloor (master upper texture)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THICK,SIDE_UPPER;

[402] // EDGE Thick Extrafloor (master lower texture)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THICK,SIDE_LOWER;

[403] // EDGE Liquid Extrafloor (solid)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER;
TRANSLUCENCY=100%;

[404] // EDGE Liquid Extrafloor (20% Translucent)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER;
TRANSLUCENCY=80%;

[405] // EDGE Liquid Extrafloor (40% Translucent)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER;
TRANSLUCENCY=60%;

[406] // EDGE Liquid Extrafloor (60% Translucent)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER;
TRANSLUCENCY=40%;

[407] // EDGE Liquid Extrafloor (80% Translucent)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER;
TRANSLUCENCY=20%;

[408] // EDGE Liquid Extrafloor (Invisible) -NOTE: THIS ONE IS DIFFERENT! USED FOR VERTICLE LIGHTING EFFECTS!
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=LIQUID,SEE_THROUGH,SHOOT_THROUGH;
TRANSLUCENCY=0%;

[409] // EDGE Translucent Linedef (20%)
TYPE=PUSH;
ACTIVATORS=PLAYER;
TRANSLUCENCY=80%;

[410] // EDGE Translucent Linedef (40%)
TYPE=PUSH;
ACTIVATORS=PLAYER;
TRANSLUCENCY=60%;

[411] // EDGE Translucent Linedef (60%)
TYPE=PUSH;
ACTIVATORS=PLAYER;
TRANSLUCENCY=40%;

[412] // EDGE Translucent Linedef (80%)
TYPE=PUSH;
ACTIVATORS=PLAYER;
TRANSLUCENCY=20%;

[413] // EDGE Thin Extrafloor (opaque)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THIN;

[414] // EDGE Thin Extrafloor (20% Translucent)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THIN,SEE_THROUGH;
TRANSLUCENCY=80%;

[415] // EDGE Thin Extrafloor (40% Translucent)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THIN,SEE_THROUGH;
TRANSLUCENCY=60%;

[416] // EDGE Thin Extrafloor (60% Translucent)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THIN,SEE_THROUGH;
TRANSLUCENCY=40%;

[417] // EDGE Thin Extrafloor (80% Translucent)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
EXTRAFLOOR_TYPE=THIN,SEE_THROUGH;
TRANSLUCENCY=20%;

// NOTE: next 4 entries, see RTS Online's TAG function for implementation of your script

[418] // EDGE Enable Tagged RTS S1
TYPE=PUSH;
SINGLESIDED=TRUE;
ACTIVATORS=PLAYER;
COUNT=1;  
RADIUS_TRIGGER=ENABLE_TAGGED;

[419] // EDGE Enable Tagged RTS SR
TYPE=PUSH;
SINGLESIDED=TRUE;
ACTIVATORS=PLAYER;
COUNT=-1;  
RADIUS_TRIGGER=ENABLE_TAGGED;

[420] // EDGE Enable Tagged RTS W1
TYPE=WALK;
SINGLESIDED=TRUE;
ACTIVATORS=PLAYER;
COUNT=1;  
RADIUS_TRIGGER=ENABLE_TAGGED;

[421] // EDGE Enable Tagged RTS WR
TYPE=WALK;
SINGLESIDED=TRUE;
ACTIVATORS=PLAYER;
COUNT=-1;  
RADIUS_TRIGGER=ENABLE_TAGGED;

[422] // EDGE SCROLL RIGHT
SCROLL=RIGHT;
SCROLLING_SPEED=1;

[423] // EDGE SCROLL UP
SCROLL=UP;
SCROLLING_SPEED=1;

[424] // EDGE SCROLL DOWN
SCROLL=DOWN;
SCROLLING_SPEED=1;

[425] // EDGE SCROLL LEFT AND UP
SCROLL=LEFT,UP;
SCROLLING_SPEED=1;

[426] // EDGE SCROLL LEFT AND DOWN
SCROLL=LEFT,DOWN;
SCROLLING_SPEED=1;

[427] // EDGE SCROLL RIGHT AND UP
SCROLL=RIGHT,UP;
SCROLLING_SPEED=1;

[428] // EDGE SCROLL RIGHT AND DOWN
SCROLL=DOWN,RIGHT;
SCROLLING_SPEED=1;

[429]  // EDGE SCROLL FAST LOWER AND MIDDLE TEXTURE (LIQUID FALLS)
SCROLL_PARTS=RIGHT_LOWER,LEFT_LOWER,RIGHT_MIDDLE,LEFT_MIDDLE;
SCROLL_XSPEED=0.0;  // CENTERED 
SCROLL_YSPEED=-4.0; // DOWN

// NOTE: TYPES 430-433 USE THE UPPER MASTER TEXTURE FOR THE SIDE TEXTURE OF THE EXTRAFLOOR!
//       THEY ARE ONLY GOOD FOR MAKING FALLS, OR EDGES OF RIVERS THAT FALLS OFF A LEDGE!

[430] // EDGE THICK TRANSLUCENT LIQUID EXTRAFLOOR SCROLL DOWN (20% TRANSLUCENT)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SCROLL_PARTS=RIGHT;
SCROLL_XSPEED=0.0;  // CENTERED 
SCROLL_YSPEED=-3; // DOWN
TRANSLUCENCY=80%;
EXTRAFLOOR_TYPE=THICK,LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER,SIDE_UPPER;

[431] // EDGE THICK TRANSLUCENT LIQUID EXTRAFLOOR SCROLL DOWN (40% TRANSLUCENT)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SCROLL_PARTS=RIGHT;
SCROLL_XSPEED=0.0;  // CENTERED 
SCROLL_YSPEED=-3; // DOWN
TRANSLUCENCY=60%;
EXTRAFLOOR_TYPE=THICK,LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER,SIDE_UPPER;

[432] // EDGE THICK TRANSLUCENT LIQUID EXTRAFLOOR SCROLL DOWN (60% TRANSLUCENT)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SCROLL_PARTS=RIGHT;
SCROLL_XSPEED=0.0;  // CENTERED 
SCROLL_YSPEED=-3; // DOWN
TRANSLUCENCY=40%;
EXTRAFLOOR_TYPE=THICK,LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER,SIDE_UPPER;

[433] // EDGE THICK TRANSLUCENT LIQUID EXTRAFLOOR SCROLL DOWN (80% TRANSLUCENT)
TYPE=PUSH;
ACTIVATORS=PLAYER;
AUTO=TRUE;
SCROLL_PARTS=RIGHT;
SCROLL_XSPEED=0.0;  // CENTERED 
SCROLL_YSPEED=-3; // DOWN
TRANSLUCENCY=20%;
EXTRAFLOOR_TYPE=THICK,LIQUID,SEE_THROUGH,WATER,SHOOT_THROUGH,FLOODER,SIDE_UPPER;

[434] // EDGE SWITCH ONCE, RAISE FLOOR 2 UNITS (USE FOR RTS ONHEIGHT EVENTS)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
SPECIAL=SWITCH_SEPARATE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=2;

[435] // EDGE SWITCH REPEAT, RAISE FLOOR 2 UNITS (USE FOR RTS ONHEIGHT EVENTS)
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=-1;
SPECIAL=SWITCH_SEPARATE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=2;

[436] // EDGE WALK ONCE, RAISE FLOOR 2 UNITS (USE FOR RTS ONHEIGHT EVENTS)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=1;
SPECIAL=SWITCH_SEPARATE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=2;

[437] // EDGE WALK REPEAT, RAISE FLOOR 2 UNITS (USE FOR RTS ONHEIGHT EVENTS)
TYPE=WALK;
ACTIVATORS=PLAYER;
COUNT=-1;
SPECIAL=SWITCH_SEPARATE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=2;

[438] // EDGE SHOOT ONCE, RAISE FLOOR 2 UNITS (USE FOR RTS ONHEIGHT EVENTS)
TYPE=SHOOT;
ACTIVATORS=PLAYER,MISSILE;
COUNT=1;
SPECIAL=SWITCH_SEPARATE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=2;

[439] // EDGE SHOOT REPEAT, RAISE FLOOR 2 UNITS (USE FOR RTS ONHEIGHT EVENTS)
TYPE=SHOOT;
ACTIVATORS=PLAYER,MISSILE;
COUNT=-1;
SPECIAL=SWITCH_SEPARATE;
FLOOR.TYPE=MOVE;
FLOOR.SPEED_UP=1;
FLOOR.DEST_REF=FLOOR;
FLOOR.DEST_OFFSET=2;

[440] // EDGE Enable Tagged RTS SHOOT1
TYPE=SHOOT;
SINGLESIDED=TRUE;
ACTIVATORS=PLAYER;
COUNT=1;  
RADIUS_TRIGGER=ENABLE_TAGGED;

[441] // EDGE Enable Tagged RTS SHOOTR
TYPE=SHOOT;
SINGLESIDED=TRUE;
ACTIVATORS=PLAYER;
COUNT=-1;  
RADIUS_TRIGGER=ENABLE_TAGGED;

[442]  // EDGE Sliding door (LEFT), SR + MONSTERS
TYPE=PUSH;
ACTIVATORS=PLAYER,MONSTER;
SLIDER.TYPE=LEFT;

[443]  // EDGE Sliding door (LEFT), SR
TYPE=PUSH;
ACTIVATORS=PLAYER;
SLIDER.TYPE=LEFT;

[444]  // EDGE Sliding door (LEFT), SR + FAST
TYPE=PUSH;
ACTIVATORS=PLAYER;
SLIDER.TYPE=LEFT;
SLIDER.SPEED=8;

[445]  // EDGE Sliding door (LEFT), S1
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
SLIDER.TYPE=LEFT;
SLIDER.DISTANCE=100%;

[446]  // EDGE Sliding door (RIGHT), SR + MONSTERS
TYPE=PUSH;
ACTIVATORS=PLAYER,MONSTER;
SLIDER.TYPE=RIGHT;

[447]  // EDGE Sliding door (RIGHT), SR
TYPE=PUSH;
ACTIVATORS=PLAYER;
SLIDER.TYPE=RIGHT;

[448]  // EDGE Sliding door (RIGHT), SR + FAST
TYPE=PUSH;
ACTIVATORS=PLAYER;
SLIDER.TYPE=RIGHT;
SLIDER.SPEED=8;

[449]  // EDGE Sliding door (RIGHT), S1
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
SLIDER.TYPE=RIGHT;
SLIDER.DISTANCE=100%;

[450]  // EDGE Sliding door (CENTER), SR + MONSTERS
TYPE=PUSH;
ACTIVATORS=PLAYER,MONSTER;
SLIDER.TYPE=CENTER;

[451]  // EDGE Sliding door (CENTER), SR
TYPE=PUSH;
ACTIVATORS=PLAYER;
SLIDER.TYPE=CENTER;

[452]  // EDGE Sliding door (CENTER), SR + FAST
TYPE=PUSH;
ACTIVATORS=PLAYER;
SLIDER.TYPE=CENTER;
SLIDER.SPEED=8;

[453]  // EDGE Sliding door (CENTER), S1
TYPE=PUSH;
ACTIVATORS=PLAYER;
COUNT=1;
SLIDER.TYPE=CENTER;
SLIDER.DISTANCE=100%;</t>
<t tx="T2796">import leoImport
leoImport.importFiles("c:/prog/edge127", ".py")</t>
<t tx="T2797"></t>
<t tx="T2799"></t>
<t tx="T2800">@ --- Radius Trigger Actions -----------------------------------------------
@c

</t>
<t tx="T2801">// Don't process, if disabled
if (trig-&gt;disabled)
  continue;

// Handle repeat delay (from TAGGED_REPEATABLE).  This must be
// done *before* all the condition checks, and that's what makes
// it different from `wait_tics'.
if (trig-&gt;repeat_delay &gt; 0)
{
  trig-&gt;repeat_delay--;
  continue;
}

// Independent, means you don't have to stay within the trigger
// radius for it to operate, It will operate on it's own.
if (! (trig-&gt;info-&gt;tagged_independent &amp;&amp; trig-&gt;activated))
{
  &lt;&lt; handle trig &gt;&gt;
  trig-&gt;activated = true;
}

// If we are waiting, decrement count and skip it.
// Note that we must do this *after* all the condition checks.
if (trig-&gt;wait_tics &gt; 0)
{
  trig-&gt;wait_tics--;
  continue;
}

&lt;&lt; Execute the commands &gt;&gt;}
if (trig-&gt;state)
  continue;

// we've reached the end of the states.  Delete the trigger unless
// it is Tagged_Repeatable and has some more repeats left.
trig-&gt;repeats_left--;

if (trig-&gt;repeats_left &gt; 0)
{
  trig-&gt;state = trig-&gt;info-&gt;first_state;
  trig-&gt;wait_tics = trig-&gt;state-&gt;tics;
  trig-&gt;repeat_delay = trig-&gt;info-&gt;repeat_delay;
  continue;
}</t>
<t tx="T2802">// Immediate triggers are just that. Immediate.
// Not within range so skip it.
if (!trig-&gt;info-&gt;tagged_immediate &amp;&amp; 
    !RAD_WithinRadius(p-&gt;mo, trig-&gt;info))
  continue;

// Check for use key trigger.
if (trig-&gt;info-&gt;tagged_use &amp;&amp; !p-&gt;usedown)
  continue;

// height check...
if (trig-&gt;info-&gt;height_trig)
{
  s_onheight_t *cur;

  for (cur=trig-&gt;info-&gt;height_trig; cur; cur=cur-&gt;next)
    if (! RAD_CheckHeightTrig(trig, cur))
      break;
  
  // if they all succeeded, then cur will be NULL...
  if (cur)
    continue;
}

// ondeath check...
if (trig-&gt;info-&gt;boss_trig)
{
  s_ondeath_t *cur;

  for (cur=trig-&gt;info-&gt;boss_trig; cur; cur=cur-&gt;next)
    if (! RAD_CheckBossTrig(trig, cur))
      break;
  
  // if they all succeeded, then cur will be NULL...
  if (cur)
    continue;
}

// condition check...
if (trig-&gt;info-&gt;cond_trig)
{
  if (! G_CheckConditions(p-&gt;mo, trig-&gt;info-&gt;cond_trig))
    continue;
}</t>
<t tx="T2803">while (trig-&gt;wait_tics == 0)
{
  rts_state_t *state = trig-&gt;state;

  // move to next state.  We do this NOW since the action itself
  // may want to change the trigger's state (to support GOTO type
  // actions and other possibilities).
  trig-&gt;state = trig-&gt;state-&gt;next;

  (*state-&gt;action)(trig, p-&gt;mo, state-&gt;param);

  if (trig-&gt;state == NULL || trig-&gt;disabled)
    break;

  trig-&gt;wait_tics += trig-&gt;state-&gt;tics;</t>
<t tx="T2804">// This is from a different map!
if (strcmp(map_name, scr-&gt;mapid) != 0)
  continue;

// -AJA- 1999/09/25: Added skill checks.
if (! G_CheckWhenAppear(scr-&gt;appear))
  continue;

// -AJA- 2000/02/03: Added player num checks.
if (doomcom-&gt;numplayers &lt; scr-&gt;min_players ||
    doomcom-&gt;numplayers &gt; scr-&gt;max_players)
{
  continue;
}

// ignore empty scripts (e.g. path nodes)
if (! scr-&gt;first_state)
  continue;

// OK, spawn new dynamic trigger
trig = Z_ClearNew(rad_trigger_t, 1);

trig-&gt;info = scr;
trig-&gt;disabled = scr-&gt;tagged_disabled;
trig-&gt;repeats_left = (scr-&gt;repeat_count &gt; 0) ? 
    scr-&gt;repeat_count : (scr-&gt;repeat_count == 0) ? 1&lt;&lt;30 : 1;
trig-&gt;repeat_delay = 0;
trig-&gt;tip_slot = 0;

RAD_GroupTriggerTags(trig);

// initialise state machine
trig-&gt;state = scr-&gt;first_state;
trig-&gt;wait_tics = scr-&gt;first_state-&gt;tics;

// link it in
trig-&gt;next = r_triggers;
trig-&gt;prev = NULL;

if (r_triggers)
  r_triggers-&gt;prev = trig
  
r_triggers = trig;</t>
<t tx="T2805">@ VIDEO CONTEXT STUFF
@c

</t>
</tnodes>
</leo_file>
