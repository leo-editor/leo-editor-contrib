<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20181031045130.3"><vh>Flex study outline</vh></v>
<v t="ekr.20181031045138.2"><vh>@@clean flx.py</vh></v>
<v t="ekr.20181031045138.4"><vh>@@clean _config.py</vh>
<v t="ekr.20181031045138.5"><vh>Declarations </vh></v>
</v>
<v t="ekr.20181031045138.6"><vh>@@clean __init__.py</vh>
<v t="ekr.20181031045138.7"><vh>Declarations </vh></v>
</v>
<v t="ekr.20181031045138.8"><vh>@@clean __main__.py</vh>
<v t="ekr.20181031045138.10"><vh>class CLI</vh>
<v t="ekr.20181031045138.11"><vh>CLI.__init__</vh></v>
<v t="ekr.20181031045138.12"><vh>CLI.get_command_names</vh></v>
<v t="ekr.20181031045138.13"><vh>CLI.get_global_help</vh></v>
<v t="ekr.20181031045138.14"><vh>CLI.cmd_help</vh></v>
<v t="ekr.20181031045138.15"><vh>CLI.cmd_version</vh></v>
<v t="ekr.20181031045138.16"><vh>CLI.cmd_info</vh></v>
<v t="ekr.20181031045138.17"><vh>CLI.cmd_stop</vh></v>
<v t="ekr.20181031045138.18"><vh>CLI.cmd_log</vh></v>
</v>
<v t="ekr.20181031045138.19"><vh>class FetchError(Exception)</vh></v>
<v t="ekr.20181031045138.20"><vh>http_fetch </vh></v>
<v t="ekr.20181031045138.21"><vh>main </vh></v>
</v>
<v t="ekr.20181031045138.22"><vh>@path app</vh>
<v t="ekr.20181031045138.23"><vh>@@clean bsdf_lite.py</vh>
<v t="ekr.20181031045138.24"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.25"><vh>lencode </vh></v>
<v t="ekr.20181031045138.26"><vh>lendecode </vh></v>
<v t="ekr.20181031045138.27"><vh>encode_type_id </vh></v>
<v t="ekr.20181031045138.28"><vh>class BsdfLiteSerializer(object)</vh>
<v t="ekr.20181031045138.29"><vh>BsdfLiteSerializer.__init__</vh></v>
<v t="ekr.20181031045138.30"><vh>BsdfLiteSerializer._parse_options</vh></v>
<v t="ekr.20181031045138.31"><vh>BsdfLiteSerializer.add_extension</vh></v>
<v t="ekr.20181031045138.32"><vh>BsdfLiteSerializer.remove_extension</vh></v>
<v t="ekr.20181031045138.33"><vh>BsdfLiteSerializer._encode</vh></v>
<v t="ekr.20181031045138.34"><vh>BsdfLiteSerializer._decode</vh></v>
<v t="ekr.20181031045138.35"><vh>BsdfLiteSerializer.encode</vh></v>
<v t="ekr.20181031045138.36"><vh>BsdfLiteSerializer.save</vh></v>
<v t="ekr.20181031045138.37"><vh>BsdfLiteSerializer.decode</vh></v>
<v t="ekr.20181031045138.38"><vh>BsdfLiteSerializer.load</vh></v>
</v>
<v t="ekr.20181031045138.39"><vh>class Extension(object)</vh>
<v t="ekr.20181031045138.40"><vh>Extension.__repr__</vh></v>
<v t="ekr.20181031045138.41"><vh>Extension.match</vh></v>
<v t="ekr.20181031045138.42"><vh>Extension.encode</vh></v>
<v t="ekr.20181031045138.43"><vh>Extension.decode</vh></v>
</v>
<v t="ekr.20181031045138.44"><vh>class ComplexExtension(Extension)</vh>
<v t="ekr.20181031045138.45"><vh>ComplexExtension.encode</vh></v>
<v t="ekr.20181031045138.46"><vh>ComplexExtension.decode</vh></v>
</v>
<v t="ekr.20181031045138.47"><vh>class NDArrayExtension(Extension)</vh>
<v t="ekr.20181031045138.48"><vh>NDArrayExtension.__init__</vh></v>
<v t="ekr.20181031045138.49"><vh>NDArrayExtension.match</vh></v>
<v t="ekr.20181031045138.50"><vh>NDArrayExtension.encode</vh></v>
<v t="ekr.20181031045138.51"><vh>NDArrayExtension.decode</vh></v>
</v>
</v>
<v t="ekr.20181031045138.52"><vh>@@clean live_tester.py</vh>
<v t="ekr.20181031045138.53"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.54"><vh>launch </vh></v>
<v t="ekr.20181031045138.55"><vh>filter_stdout </vh></v>
<v t="ekr.20181031045138.56"><vh>run_live </vh></v>
</v>
<v t="ekr.20181031045138.57"><vh>@@clean _app.py</vh>
<v t="ekr.20181031045138.58"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.59"><vh>class ExporterWebSocketDummy</vh>
<v t="ekr.20181031045138.60"><vh>ExporterWebSocketDummy.__init__</vh></v>
<v t="ekr.20181031045138.61"><vh>ExporterWebSocketDummy.write_command</vh></v>
</v>
<v t="ekr.20181031045138.62"><vh>class App</vh>
<v t="ekr.20181031045138.63"><vh>App.__init__</vh></v>
<v t="ekr.20181031045138.64"><vh>App.__call__</vh></v>
<v t="ekr.20181031045138.65"><vh>App.__repr__</vh></v>
<v t="ekr.20181031045138.66"><vh>App.cls</vh></v>
<v t="ekr.20181031045138.67"><vh>App.is_served</vh></v>
<v t="ekr.20181031045138.68"><vh>App.url</vh></v>
<v t="ekr.20181031045138.69"><vh>App.name</vh></v>
<v t="ekr.20181031045138.70"><vh>App.serve</vh></v>
<v t="ekr.20181031045138.71"><vh>App.launch</vh></v>
<v t="ekr.20181031045138.72"><vh>App.dump</vh></v>
<v t="ekr.20181031045138.73"><vh>App.export</vh></v>
<v t="ekr.20181031045138.74"><vh>App.publish</vh></v>
</v>
<v t="ekr.20181031045138.75"><vh>valid_app_name </vh></v>
<v t="ekr.20181031045138.76"><vh>class AppManager(event.Component)</vh>
<v t="ekr.20181031045138.77"><vh>AppManager.__init__</vh></v>
<v t="ekr.20181031045138.78"><vh>AppManager.register_app</vh></v>
<v t="ekr.20181031045138.79"><vh>AppManager.create_default_session</vh></v>
<v t="ekr.20181031045138.80"><vh>AppManager.remove_default_session</vh></v>
<v t="ekr.20181031045138.81"><vh>AppManager.get_default_session</vh></v>
<v t="ekr.20181031045138.82"><vh>AppManager._clear_old_pending_sessions</vh></v>
<v t="ekr.20181031045138.83"><vh>AppManager.create_session</vh></v>
<v t="ekr.20181031045138.84"><vh>AppManager.connect_client</vh></v>
<v t="ekr.20181031045138.85"><vh>AppManager.disconnect_client</vh></v>
<v t="ekr.20181031045138.86"><vh>AppManager.has_app_name</vh></v>
<v t="ekr.20181031045138.87"><vh>AppManager.get_app_names</vh></v>
<v t="ekr.20181031045138.88"><vh>AppManager.get_session_by_id</vh></v>
<v t="ekr.20181031045138.89"><vh>AppManager.get_connections</vh></v>
<v t="ekr.20181031045138.90"><vh>AppManager.connections_changed</vh></v>
</v>
</v>
<v t="ekr.20181031045138.91"><vh>@@clean _asset.py</vh>
<v t="ekr.20181031045138.92"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.93"><vh>get_mod_name </vh></v>
<v t="ekr.20181031045138.94"><vh>module_is_package </vh></v>
<v t="ekr.20181031045138.95"><vh>solve_dependencies </vh></v>
<v t="ekr.20181031045138.96"><vh>class Asset</vh>
<v t="ekr.20181031045138.97"><vh>Asset.__init__</vh></v>
<v t="ekr.20181031045138.98"><vh>Asset.__repr__</vh></v>
<v t="ekr.20181031045138.99"><vh>Asset.name</vh></v>
<v t="ekr.20181031045138.100"><vh>Asset.source</vh></v>
<v t="ekr.20181031045138.101"><vh>Asset.remote</vh></v>
<v t="ekr.20181031045138.102"><vh>Asset.to_html</vh></v>
<v t="ekr.20181031045138.103"><vh>Asset.to_string</vh></v>
<v t="ekr.20181031045138.104"><vh>Asset._get_from_url</vh></v>
</v>
<v t="ekr.20181031045138.105"><vh>class Bundle(Asset)</vh>
<v t="ekr.20181031045138.106"><vh>Bundle.__init__</vh></v>
<v t="ekr.20181031045138.107"><vh>Bundle.__repr__</vh></v>
<v t="ekr.20181031045138.108"><vh>Bundle.add_asset</vh></v>
<v t="ekr.20181031045138.109"><vh>Bundle.add_module</vh></v>
<v t="ekr.20181031045138.110"><vh>Bundle.assets</vh></v>
<v t="ekr.20181031045138.111"><vh>Bundle.modules</vh></v>
<v t="ekr.20181031045138.112"><vh>Bundle.deps</vh></v>
<v t="ekr.20181031045138.113"><vh>Bundle.to_string</vh></v>
</v>
</v>
<v t="ekr.20181031045138.114"><vh>@@clean _assetstore.py</vh>
<v t="ekr.20181031045138.115"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.116"><vh>class AssetStore</vh>
<v t="ekr.20181031045138.117"><vh>AssetStore.__init__</vh></v>
<v t="ekr.20181031045138.118"><vh>AssetStore.__repr__</vh></v>
<v t="ekr.20181031045138.119"><vh>AssetStore.create_module_assets</vh></v>
<v t="ekr.20181031045138.120"><vh>AssetStore.modules</vh></v>
<v t="ekr.20181031045138.121"><vh>AssetStore.update_modules</vh></v>
<v t="ekr.20181031045138.122"><vh>AssetStore.get_asset</vh></v>
<v t="ekr.20181031045138.123"><vh>AssetStore.get_data</vh></v>
<v t="ekr.20181031045138.124"><vh>AssetStore.get_asset_names</vh></v>
<v t="ekr.20181031045138.125"><vh>AssetStore.get_data_names</vh></v>
<v t="ekr.20181031045138.126"><vh>AssetStore.add_shared_asset</vh></v>
<v t="ekr.20181031045138.127"><vh>AssetStore.associate_asset</vh></v>
<v t="ekr.20181031045138.128"><vh>AssetStore.get_associated_assets</vh></v>
<v t="ekr.20181031045138.129"><vh>AssetStore.add_shared_data</vh></v>
<v t="ekr.20181031045138.130"><vh>AssetStore._dump_data</vh></v>
<v t="ekr.20181031045138.131"><vh>AssetStore._dump_assets</vh></v>
</v>
</v>
<v t="ekr.20181031045138.132"><vh>@@clean _clientcore.py</vh>
<v t="ekr.20181031045138.133"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.134"><vh>class Flexx</vh>
<v t="ekr.20181031045138.135"><vh>Flexx.__init__</vh></v>
<v t="ekr.20181031045138.136"><vh>Flexx.init</vh></v>
<v t="ekr.20181031045138.137"><vh>Flexx._remove_querystring</vh></v>
<v t="ekr.20181031045138.138"><vh>Flexx.exit</vh></v>
<v t="ekr.20181031045138.139"><vh>Flexx.spin</vh></v>
<v t="ekr.20181031045138.140"><vh>Flexx.init_logging</vh></v>
<v t="ekr.20181031045138.141"><vh>Flexx.create_session</vh></v>
<v t="ekr.20181031045138.142"><vh>Flexx._validate_browser_capabilities</vh></v>
<v t="ekr.20181031045138.143"><vh>Flexx._handle_error</vh></v>
</v>
<v t="ekr.20181031045138.144"><vh>class JsSession</vh>
<v t="ekr.20181031045138.145"><vh>JsSession.__init__</vh></v>
<v t="ekr.20181031045138.146"><vh>JsSession.exit</vh></v>
<v t="ekr.20181031045138.147"><vh>JsSession.send_command</vh></v>
<v t="ekr.20181031045138.148"><vh>JsSession.instantiate_component</vh></v>
<v t="ekr.20181031045138.149"><vh>JsSession._register_component</vh></v>
<v t="ekr.20181031045138.150"><vh>JsSession._unregister_component</vh></v>
<v t="ekr.20181031045138.151"><vh>JsSession.get_component_instance</vh></v>
<v t="ekr.20181031045138.152"><vh>JsSession.init_socket</vh></v>
<v t="ekr.20181031045138.153"><vh>JsSession._process_commands</vh></v>
<v t="ekr.20181031045138.154"><vh>JsSession._receive_raw_command</vh></v>
<v t="ekr.20181031045138.155"><vh>JsSession._receive_command</vh></v>
<v t="ekr.20181031045138.156"><vh>JsSession.call_after_roundtrip</vh></v>
<v t="ekr.20181031045138.157"><vh>JsSession._send_ping</vh></v>
<v t="ekr.20181031045138.158"><vh>JsSession._receive_pong</vh></v>
<v t="ekr.20181031045138.159"><vh>JsSession.keep_checking_size_of</vh></v>
<v t="ekr.20181031045138.160"><vh>JsSession._check_size_of_objects</vh></v>
</v>
</v>
<v t="ekr.20181031045138.161"><vh>@@clean _component2.py</vh>
<v t="ekr.20181031045138.162"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.163"><vh>make_proxy_action </vh></v>
<v t="ekr.20181031045138.164"><vh>make_proxy_emitter </vh></v>
<v t="ekr.20181031045138.165"><vh>get_component_classes </vh></v>
<v t="ekr.20181031045138.166"><vh>meta_repr </vh></v>
<v t="ekr.20181031045138.167"><vh>class LocalProperty(Property)</vh></v>
<v t="ekr.20181031045138.168"><vh>class ComponentMetaJS(ComponentMeta)</vh>
<v t="ekr.20181031045138.169"><vh>ComponentMetaJS.__init__</vh></v>
</v>
<v t="ekr.20181031045138.170"><vh>class AppComponentMeta(ComponentMeta)</vh>
<v t="ekr.20181031045138.171"><vh>AppComponentMeta._init_hook1</vh></v>
<v t="ekr.20181031045138.172"><vh>AppComponentMeta._init_hook2</vh></v>
<v t="ekr.20181031045138.173"><vh>AppComponentMeta._make_js_proxy_class</vh></v>
<v t="ekr.20181031045138.174"><vh>AppComponentMeta._make_js_local_class</vh></v>
<v t="ekr.20181031045138.175"><vh>AppComponentMeta._get_js</vh></v>
<v t="ekr.20181031045138.176"><vh>AppComponentMeta._get_js_of_base_classes</vh></v>
</v>
<v t="ekr.20181031045138.177"><vh>class BaseAppComponent(Component)</vh>
<v t="ekr.20181031045138.178"><vh>BaseAppComponent._comp_init_app_component</vh></v>
</v>
<v t="ekr.20181031045138.179"><vh>class LocalComponent(BaseAppComponent)</vh>
<v t="ekr.20181031045138.180"><vh>LocalComponent._comp_init_property_values</vh></v>
<v t="ekr.20181031045138.181"><vh>LocalComponent._ensure_proxy_instance</vh></v>
<v t="ekr.20181031045138.182"><vh>LocalComponent.emit</vh></v>
<v t="ekr.20181031045138.183"><vh>LocalComponent._dispose</vh></v>
<v t="ekr.20181031045138.184"><vh>LocalComponent._flx_set_has_proxy</vh></v>
<v t="ekr.20181031045138.185"><vh>LocalComponent._flx_set_event_types_at_proxy</vh></v>
</v>
<v t="ekr.20181031045138.186"><vh>class ProxyComponent(BaseAppComponent)</vh>
<v t="ekr.20181031045138.187"><vh>ProxyComponent.__init__</vh></v>
<v t="ekr.20181031045138.188"><vh>ProxyComponent._comp_init_property_values</vh></v>
<v t="ekr.20181031045138.189"><vh>ProxyComponent._comp_apply_property_values</vh></v>
<v t="ekr.20181031045138.190"><vh>ProxyComponent._proxy_action</vh></v>
<v t="ekr.20181031045138.191"><vh>ProxyComponent._proxy_emitter</vh></v>
<v t="ekr.20181031045138.192"><vh>ProxyComponent._mutate</vh></v>
<v t="ekr.20181031045138.193"><vh>ProxyComponent._registered_reactions_hook</vh></v>
<v t="ekr.20181031045138.194"><vh>ProxyComponent._emit_at_proxy</vh></v>
<v t="ekr.20181031045138.195"><vh>ProxyComponent.dispose</vh></v>
<v t="ekr.20181031045138.196"><vh>ProxyComponent._dispose</vh></v>
</v>
<v t="ekr.20181031045138.197"><vh>class StubComponent(BaseAppComponent)</vh>
<v t="ekr.20181031045138.198"><vh>StubComponent.__init__</vh></v>
<v t="ekr.20181031045138.199"><vh>StubComponent.__repr__</vh></v>
</v>
<v t="ekr.20181031045138.200"><vh>class JsComponent</vh>
<v t="ekr.20181031045138.201"><vh>JsComponent.__repr__</vh></v>
<v t="ekr.20181031045138.202"><vh>JsComponent._addEventListener</vh></v>
<v t="ekr.20181031045138.203"><vh>JsComponent._dispose</vh></v>
</v>
<v t="ekr.20181031045138.204"><vh>class PyComponent</vh>
<v t="ekr.20181031045138.205"><vh>PyComponent.__repr__</vh></v>
</v>
<v t="ekr.20181031045138.206"><vh>class BsdfComponentExtension(bsdf.Extension)</vh>
<v t="ekr.20181031045138.207"><vh>BsdfComponentExtension.match</vh></v>
<v t="ekr.20181031045138.208"><vh>BsdfComponentExtension.encode</vh></v>
<v t="ekr.20181031045138.209"><vh>BsdfComponentExtension.decode</vh></v>
<v t="ekr.20181031045138.210"><vh>BsdfComponentExtension.match_js</vh></v>
<v t="ekr.20181031045138.211"><vh>BsdfComponentExtension.encode_js</vh></v>
<v t="ekr.20181031045138.212"><vh>BsdfComponentExtension.decode_js</vh></v>
</v>
</v>
<v t="ekr.20181031045138.213"><vh>@@clean _funcs.py</vh>
<v t="ekr.20181031045138.214"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.215"><vh>start </vh></v>
<v t="ekr.20181031045138.216"><vh>run </vh></v>
<v t="ekr.20181031045138.217"><vh>stop </vh></v>
<v t="ekr.20181031045138.218"><vh>_auto_closer </vh></v>
<v t="ekr.20181031045138.219"><vh>class NoteBookHelper</vh>
<v t="ekr.20181031045138.220"><vh>NoteBookHelper.__init__</vh></v>
<v t="ekr.20181031045138.221"><vh>NoteBookHelper.enable</vh></v>
<v t="ekr.20181031045138.222"><vh>NoteBookHelper.capture</vh></v>
<v t="ekr.20181031045138.223"><vh>NoteBookHelper.release</vh></v>
<v t="ekr.20181031045138.224"><vh>NoteBookHelper.write_command</vh></v>
</v>
<v t="ekr.20181031045138.225"><vh>init_notebook </vh></v>
<v t="ekr.20181031045138.226"><vh>serve </vh></v>
<v t="ekr.20181031045138.227"><vh>launch </vh></v>
<v t="ekr.20181031045138.228"><vh>export </vh></v>
</v>
<v t="ekr.20181031045138.229"><vh>@@clean _modules.py</vh>
<v t="ekr.20181031045138.230"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.231"><vh>mangle_dotted_vars </vh></v>
<v t="ekr.20181031045138.232"><vh>is_pscript_module </vh></v>
<v t="ekr.20181031045138.233"><vh>class JSModule</vh>
<v t="ekr.20181031045138.234"><vh>JSModule.__init__</vh></v>
<v t="ekr.20181031045138.235"><vh>JSModule.__repr__</vh></v>
<v t="ekr.20181031045138.236"><vh>JSModule._init_default_objects</vh></v>
<v t="ekr.20181031045138.237"><vh>JSModule.name</vh></v>
<v t="ekr.20181031045138.238"><vh>JSModule.filename</vh></v>
<v t="ekr.20181031045138.239"><vh>JSModule.deps</vh></v>
<v t="ekr.20181031045138.240"><vh>JSModule.component_classes</vh></v>
<v t="ekr.20181031045138.241"><vh>JSModule._import</vh></v>
<v t="ekr.20181031045138.242"><vh>JSModule.variables</vh></v>
<v t="ekr.20181031045138.243"><vh>JSModule.add_variable</vh></v>
<v t="ekr.20181031045138.244"><vh>JSModule._collect_dependencies</vh></v>
<v t="ekr.20181031045138.245"><vh>JSModule._name_ispropclass</vh></v>
<v t="ekr.20181031045138.246"><vh>JSModule._collect_dependencies_from_bases</vh></v>
<v t="ekr.20181031045138.247"><vh>JSModule._add_dep_from_event_module</vh></v>
<v t="ekr.20181031045138.248"><vh>JSModule.get_js</vh></v>
<v t="ekr.20181031045138.249"><vh>JSModule.get_css</vh></v>
</v>
</v>
<v t="ekr.20181031045138.250"><vh>@@clean _server.py</vh>
<v t="ekr.20181031045138.251"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.252"><vh>create_server </vh></v>
<v t="ekr.20181031045138.253"><vh>current_server </vh></v>
<v t="ekr.20181031045138.254"><vh>class AbstractServer</vh>
<v t="ekr.20181031045138.255"><vh>AbstractServer.__init__</vh></v>
<v t="ekr.20181031045138.256"><vh>AbstractServer._running</vh></v>
<v t="ekr.20181031045138.257"><vh>AbstractServer.start</vh></v>
<v t="ekr.20181031045138.258"><vh>AbstractServer.stop</vh></v>
<v t="ekr.20181031045138.259"><vh>AbstractServer.close</vh></v>
<v t="ekr.20181031045138.260"><vh>AbstractServer._open</vh></v>
<v t="ekr.20181031045138.261"><vh>AbstractServer._close</vh></v>
<v t="ekr.20181031045138.262"><vh>AbstractServer.serving</vh></v>
<v t="ekr.20181031045138.263"><vh>AbstractServer.protocol</vh></v>
</v>
</v>
<v t="ekr.20181031045138.264"><vh>@@clean _session.py</vh>
<v t="ekr.20181031045138.265"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.266"><vh>get_random_string </vh></v>
<v t="ekr.20181031045138.267"><vh>class Session</vh>
<v t="ekr.20181031045138.268"><vh>Session.__init__</vh></v>
<v t="ekr.20181031045138.269"><vh>Session.__repr__</vh></v>
<v t="ekr.20181031045138.270"><vh>Session.request</vh></v>
<v t="ekr.20181031045138.271"><vh>Session.id</vh></v>
<v t="ekr.20181031045138.272"><vh>Session.app_name</vh></v>
<v t="ekr.20181031045138.273"><vh>Session.app</vh></v>
<v t="ekr.20181031045138.274"><vh>Session.runtime</vh></v>
<v t="ekr.20181031045138.275"><vh>Session.status</vh></v>
<v t="ekr.20181031045138.276"><vh>Session.present_modules</vh></v>
<v t="ekr.20181031045138.277"><vh>Session.assets_to_ignore</vh></v>
<v t="ekr.20181031045138.278"><vh>Session.close</vh></v>
<v t="ekr.20181031045138.279"><vh>Session._set_ws</vh></v>
<v t="ekr.20181031045138.280"><vh>Session._set_cookies</vh></v>
<v t="ekr.20181031045138.281"><vh>Session._set_runtime</vh></v>
<v t="ekr.20181031045138.282"><vh>Session.get_cookie</vh></v>
<v t="ekr.20181031045138.283"><vh>Session.set_cookie</vh></v>
<v t="ekr.20181031045138.284"><vh>Session.add_data</vh></v>
<v t="ekr.20181031045138.285"><vh>Session.remove_data</vh></v>
<v t="ekr.20181031045138.286"><vh>Session.get_data_names</vh></v>
<v t="ekr.20181031045138.287"><vh>Session.get_data</vh></v>
<v t="ekr.20181031045138.288"><vh>Session._dump_data</vh></v>
<v t="ekr.20181031045138.289"><vh>Session._register_component</vh></v>
<v t="ekr.20181031045138.290"><vh>Session._unregister_component</vh></v>
<v t="ekr.20181031045138.291"><vh>Session.get_component_instance</vh></v>
<v t="ekr.20181031045138.292"><vh>Session._register_component_class</vh></v>
<v t="ekr.20181031045138.293"><vh>Session._register_module</vh></v>
<v t="ekr.20181031045138.294"><vh>Session.send_command</vh></v>
<v t="ekr.20181031045138.295"><vh>Session._receive_command</vh></v>
<v t="ekr.20181031045138.296"><vh>Session.keep_alive</vh></v>
<v t="ekr.20181031045138.297"><vh>Session.call_after_roundtrip</vh></v>
<v t="ekr.20181031045138.298"><vh>Session._get_ping_call_list</vh></v>
<v t="ekr.20181031045138.299"><vh>Session._receive_pong</vh></v>
</v>
<v t="ekr.20181031045138.300"><vh>send_ping_later </vh></v>
<v t="ekr.20181031045138.301"><vh>get_page </vh></v>
<v t="ekr.20181031045138.302"><vh>get_page_for_export </vh></v>
<v t="ekr.20181031045138.303"><vh>_get_page </vh></v>
</v>
<v t="ekr.20181031045138.304"><vh>@@clean _tornadoserver.py</vh>
<v t="ekr.20181031045138.305"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.306"><vh>is_main_thread </vh></v>
<v t="ekr.20181031045138.307"><vh>class TornadoServer(AbstractServer)</vh>
<v t="ekr.20181031045138.308"><vh>TornadoServer.__init__</vh></v>
<v t="ekr.20181031045138.309"><vh>TornadoServer._open</vh></v>
<v t="ekr.20181031045138.310"><vh>TornadoServer._close</vh></v>
<v t="ekr.20181031045138.311"><vh>TornadoServer.app</vh></v>
<v t="ekr.20181031045138.312"><vh>TornadoServer.server</vh></v>
<v t="ekr.20181031045138.313"><vh>TornadoServer.protocol</vh></v>
</v>
<v t="ekr.20181031045138.314"><vh>port_hash </vh></v>
<v t="ekr.20181031045138.315"><vh>class FlexxHandler(RequestHandler)</vh>
<v t="ekr.20181031045138.316"><vh>FlexxHandler.initialize</vh></v>
<v t="ekr.20181031045138.317"><vh>FlexxHandler.write_error</vh></v>
<v t="ekr.20181031045138.318"><vh>FlexxHandler.on_finish</vh></v>
</v>
<v t="ekr.20181031045138.319"><vh>class AppHandler(FlexxHandler)</vh>
<v t="ekr.20181031045138.320"><vh>AppHandler.get</vh></v>
<v t="ekr.20181031045138.321"><vh>AppHandler._get_index</vh></v>
<v t="ekr.20181031045138.322"><vh>AppHandler._get_app</vh></v>
</v>
<v t="ekr.20181031045138.323"><vh>class MainHandler(RequestHandler)</vh>
<v t="ekr.20181031045138.324"><vh>MainHandler._guess_mime_type</vh></v>
<v t="ekr.20181031045138.325"><vh>MainHandler.get</vh></v>
<v t="ekr.20181031045138.326"><vh>MainHandler._get_asset</vh></v>
<v t="ekr.20181031045138.327"><vh>MainHandler._get_info</vh></v>
<v t="ekr.20181031045138.328"><vh>MainHandler._get_cmd</vh></v>
</v>
<v t="ekr.20181031045138.329"><vh>class MessageCounter</vh>
<v t="ekr.20181031045138.330"><vh>MessageCounter.__init__</vh></v>
<v t="ekr.20181031045138.331"><vh>MessageCounter.trigger</vh></v>
<v t="ekr.20181031045138.332"><vh>MessageCounter._notify</vh></v>
<v t="ekr.20181031045138.333"><vh>MessageCounter.stop</vh></v>
</v>
<v t="ekr.20181031045138.334"><vh>class WSHandler(WebSocketHandler)</vh>
<v t="ekr.20181031045138.335"><vh>WSHandler.open</vh></v>
<v t="ekr.20181031045138.336"><vh>WSHandler.on_message</vh></v>
<v t="ekr.20181031045138.337"><vh>WSHandler.on_close</vh></v>
<v t="ekr.20181031045138.338"><vh>WSHandler.pinger1</vh></v>
<v t="ekr.20181031045138.339"><vh>WSHandler.on_pong</vh></v>
<v t="ekr.20181031045138.340"><vh>WSHandler.write_command</vh></v>
<v t="ekr.20181031045138.341"><vh>WSHandler.close</vh></v>
<v t="ekr.20181031045138.342"><vh>WSHandler.close_this</vh></v>
<v t="ekr.20181031045138.343"><vh>WSHandler.check_origin</vh></v>
</v>
</v>
<v t="ekr.20181031045138.344"><vh>@@clean __init__.py</vh>
<v t="ekr.20181031045138.345"><vh>Declarations </vh></v>
</v>
</v>
<v t="ekr.20181031045138.346"><vh>@path event</vh>
<v t="ekr.20181031045138.347"><vh>@@clean both_tester.py</vh>
<v t="ekr.20181031045138.348"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.349"><vh>class StdoutMismatchError(Exception)</vh></v>
<v t="ekr.20181031045138.350"><vh>class FakeStream</vh>
<v t="ekr.20181031045138.351"><vh>FakeStream.__init__</vh></v>
<v t="ekr.20181031045138.352"><vh>FakeStream.write</vh></v>
<v t="ekr.20181031045138.353"><vh>FakeStream.flush</vh></v>
<v t="ekr.20181031045138.354"><vh>FakeStream.getvalue</vh></v>
</v>
<v t="ekr.20181031045138.355"><vh>call_func_in_py </vh></v>
<v t="ekr.20181031045138.356"><vh>call_func_in_js </vh></v>
<v t="ekr.20181031045138.357"><vh>smart_compare </vh></v>
<v t="ekr.20181031045138.358"><vh>validate_text </vh></v>
<v t="ekr.20181031045138.359"><vh>_wrap </vh></v>
<v t="ekr.20181031045138.360"><vh>_zip </vh></v>
<v t="ekr.20181031045138.361"><vh>run_in_both </vh></v>
</v>
<v t="ekr.20181031045138.362"><vh>@@clean _action.py</vh>
<v t="ekr.20181031045138.363"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.364"><vh>action </vh></v>
<v t="ekr.20181031045138.365"><vh>class BaseDescriptor</vh>
<v t="ekr.20181031045138.366"><vh>BaseDescriptor.__repr__</vh></v>
<v t="ekr.20181031045138.367"><vh>BaseDescriptor.__set__</vh></v>
<v t="ekr.20181031045138.368"><vh>BaseDescriptor.__delete__</vh></v>
<v t="ekr.20181031045138.369"><vh>BaseDescriptor._format_doc</vh></v>
</v>
<v t="ekr.20181031045138.370"><vh>class ActionDescriptor(BaseDescriptor)</vh>
<v t="ekr.20181031045138.371"><vh>ActionDescriptor.__init__</vh></v>
<v t="ekr.20181031045138.372"><vh>ActionDescriptor.__get__</vh></v>
</v>
<v t="ekr.20181031045138.373"><vh>class Action</vh>
<v t="ekr.20181031045138.374"><vh>Action.__init__</vh></v>
<v t="ekr.20181031045138.375"><vh>Action.__repr__</vh></v>
<v t="ekr.20181031045138.376"><vh>Action._use_once</vh></v>
<v t="ekr.20181031045138.377"><vh>Action.__call__</vh></v>
</v>
</v>
<v t="ekr.20181031045138.378"><vh>@@clean _attribute.py</vh>
<v t="ekr.20181031045138.379"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.380"><vh>class Attribute(BaseDescriptor)</vh>
<v t="ekr.20181031045138.381"><vh>Attribute.__init__</vh></v>
<v t="ekr.20181031045138.382"><vh>Attribute._set_name</vh></v>
<v t="ekr.20181031045138.383"><vh>Attribute.__set__</vh></v>
<v t="ekr.20181031045138.384"><vh>Attribute.__get__</vh></v>
</v>
</v>
<v t="ekr.20181031045138.385"><vh>@@clean _component.py</vh>
<v t="ekr.20181031045138.386"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.387"><vh>with_metaclass </vh></v>
<v t="ekr.20181031045138.388"><vh>new_type </vh></v>
<v t="ekr.20181031045138.389"><vh>class ComponentMeta(type)</vh>
<v t="ekr.20181031045138.390"><vh>ComponentMeta.__init__</vh></v>
<v t="ekr.20181031045138.391"><vh>ComponentMeta._init_hook1</vh></v>
<v t="ekr.20181031045138.392"><vh>ComponentMeta._init_hook2</vh></v>
<v t="ekr.20181031045138.393"><vh>ComponentMeta._set_cls_attr</vh></v>
<v t="ekr.20181031045138.394"><vh>ComponentMeta._finish_properties</vh></v>
<v t="ekr.20181031045138.395"><vh>ComponentMeta._set_summaries</vh></v>
</v>
<v t="ekr.20181031045138.396"><vh>class Component</vh>
<v t="ekr.20181031045138.397"><vh>Component.__init__</vh></v>
<v t="ekr.20181031045138.398"><vh>Component.__repr__</vh></v>
<v t="ekr.20181031045138.399"><vh>Component._comp_init_property_values</vh></v>
<v t="ekr.20181031045138.400"><vh>Component._comp_apply_property_values</vh></v>
<v t="ekr.20181031045138.401"><vh>Component._comp_make_implicit_setter</vh></v>
<v t="ekr.20181031045138.402"><vh>Component._comp_init_reactions</vh></v>
<v t="ekr.20181031045138.403"><vh>Component._comp_stop_capturing_events</vh></v>
<v t="ekr.20181031045138.404"><vh>Component.__enter__</vh></v>
<v t="ekr.20181031045138.405"><vh>Component.__exit__</vh></v>
<v t="ekr.20181031045138.406"><vh>Component.__check_not_active</vh></v>
<v t="ekr.20181031045138.407"><vh>Component.init</vh></v>
<v t="ekr.20181031045138.408"><vh>Component.__del__</vh></v>
<v t="ekr.20181031045138.409"><vh>Component.dispose</vh></v>
<v t="ekr.20181031045138.410"><vh>Component._dispose</vh></v>
<v t="ekr.20181031045138.411"><vh>Component._registered_reactions_hook</vh></v>
<v t="ekr.20181031045138.412"><vh>Component._register_reaction</vh></v>
<v t="ekr.20181031045138.413"><vh>Component.disconnect</vh></v>
<v t="ekr.20181031045138.414"><vh>Component.emit</vh></v>
<v t="ekr.20181031045138.415"><vh>Component._mutate</vh></v>
<v t="ekr.20181031045138.416"><vh>Component.get_event_types</vh></v>
<v t="ekr.20181031045138.417"><vh>Component.get_event_handlers</vh></v>
<v t="ekr.20181031045138.418"><vh>Component.reaction</vh></v>
</v>
<v t="ekr.20181031045138.419"><vh>mutate_dict </vh></v>
<v t="ekr.20181031045138.420"><vh>_mutate_array_py </vh></v>
<v t="ekr.20181031045138.421"><vh>_mutate_array_js </vh></v>
</v>
<v t="ekr.20181031045138.422"><vh>@@clean _dict.py</vh>
<v t="ekr.20181031045138.423"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.424"><vh>isidentifier </vh></v>
<v t="ekr.20181031045138.425"><vh>class Dict(_dict)</vh>
<v t="ekr.20181031045138.426"><vh>Dict.__repr__</vh></v>
<v t="ekr.20181031045138.427"><vh>Dict.__getattribute__</vh></v>
<v t="ekr.20181031045138.428"><vh>Dict.__setattr__</vh></v>
<v t="ekr.20181031045138.429"><vh>Dict.__dir__</vh></v>
</v>
</v>
<v t="ekr.20181031045138.430"><vh>@@clean _emitter.py</vh>
<v t="ekr.20181031045138.431"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.432"><vh>emitter </vh></v>
<v t="ekr.20181031045138.433"><vh>class EmitterDescriptor(BaseDescriptor)</vh>
<v t="ekr.20181031045138.434"><vh>EmitterDescriptor.__init__</vh></v>
<v t="ekr.20181031045138.435"><vh>EmitterDescriptor.__get__</vh></v>
</v>
<v t="ekr.20181031045138.436"><vh>class Emitter</vh>
<v t="ekr.20181031045138.437"><vh>Emitter.__init__</vh></v>
<v t="ekr.20181031045138.438"><vh>Emitter.__repr__</vh></v>
<v t="ekr.20181031045138.439"><vh>Emitter._use_once</vh></v>
<v t="ekr.20181031045138.440"><vh>Emitter.__call__</vh></v>
</v>
</v>
<v t="ekr.20181031045138.441"><vh>@@clean _js.py</vh>
<v t="ekr.20181031045138.442"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.443"><vh>class MetaCollector</vh>
<v t="ekr.20181031045138.444"><vh>MetaCollector.__init__</vh></v>
<v t="ekr.20181031045138.445"><vh>MetaCollector.py2js</vh></v>
<v t="ekr.20181031045138.446"><vh>MetaCollector.update</vh></v>
<v t="ekr.20181031045138.447"><vh>MetaCollector.attach_meta</vh></v>
</v>
<v t="ekr.20181031045138.448"><vh>class LoopJS</vh>
<v t="ekr.20181031045138.449"><vh>LoopJS.__init__</vh></v>
<v t="ekr.20181031045138.450"><vh>LoopJS._call_soon_func</vh></v>
<v t="ekr.20181031045138.451"><vh>LoopJS._iter_callback</vh></v>
</v>
<v t="ekr.20181031045138.452"><vh>class ComponentJS</vh>
<v t="ekr.20181031045138.453"><vh>ComponentJS.__init__</vh></v>
<v t="ekr.20181031045138.454"><vh>ComponentJS._comp_init_property_values</vh></v>
<v t="ekr.20181031045138.455"><vh>ComponentJS._comp_make_implicit_setter</vh></v>
<v t="ekr.20181031045138.456"><vh>ComponentJS._comp_init_reactions</vh></v>
<v t="ekr.20181031045138.457"><vh>ComponentJS.reaction</vh></v>
<v t="ekr.20181031045138.458"><vh>ComponentJS.__create_action</vh></v>
<v t="ekr.20181031045138.459"><vh>ComponentJS.__create_attribute</vh></v>
<v t="ekr.20181031045138.460"><vh>ComponentJS.__create_property</vh></v>
<v t="ekr.20181031045138.461"><vh>ComponentJS.__create_emitter</vh></v>
<v t="ekr.20181031045138.462"><vh>ComponentJS.__create_reaction</vh></v>
<v t="ekr.20181031045138.463"><vh>ComponentJS.__create_reaction_ob</vh></v>
</v>
<v t="ekr.20181031045138.464"><vh>_create_js_class </vh></v>
<v t="ekr.20181031045138.465"><vh>create_js_component_class </vh></v>
<v t="ekr.20181031045138.466"><vh>gen_prop_classes </vh></v>
</v>
<v t="ekr.20181031045138.467"><vh>@@clean _loop.py</vh>
<v t="ekr.20181031045138.468"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.469"><vh>this_is_js </vh></v>
<v t="ekr.20181031045138.470"><vh>class Loop</vh>
<v t="ekr.20181031045138.471"><vh>Loop.__init__</vh></v>
<v t="ekr.20181031045138.472"><vh>Loop.reset</vh></v>
<v t="ekr.20181031045138.473"><vh>Loop.has_pending</vh></v>
<v t="ekr.20181031045138.474"><vh>Loop.__enter__</vh></v>
<v t="ekr.20181031045138.475"><vh>Loop.__exit__</vh></v>
<v t="ekr.20181031045138.476"><vh>Loop.can_mutate</vh></v>
<v t="ekr.20181031045138.477"><vh>Loop.get_active_components</vh></v>
<v t="ekr.20181031045138.478"><vh>Loop.get_active_component</vh></v>
<v t="ekr.20181031045138.479"><vh>Loop._activate_component</vh></v>
<v t="ekr.20181031045138.480"><vh>Loop._deactivate_component</vh></v>
<v t="ekr.20181031045138.481"><vh>Loop._schedule_iter</vh></v>
<v t="ekr.20181031045138.482"><vh>Loop.call_soon</vh></v>
<v t="ekr.20181031045138.483"><vh>Loop.add_action_invokation</vh></v>
<v t="ekr.20181031045138.484"><vh>Loop.add_reaction_event</vh></v>
<v t="ekr.20181031045138.485"><vh>Loop.register_prop_access</vh></v>
<v t="ekr.20181031045138.486"><vh>Loop._thread_match</vh></v>
<v t="ekr.20181031045138.487"><vh>Loop._iter_callback</vh></v>
<v t="ekr.20181031045138.488"><vh>Loop.iter</vh></v>
<v t="ekr.20181031045138.489"><vh>Loop._process_calls</vh></v>
<v t="ekr.20181031045138.490"><vh>Loop._process_actions</vh></v>
<v t="ekr.20181031045138.491"><vh>Loop._process_reactions</vh></v>
<v t="ekr.20181031045138.492"><vh>Loop.integrate</vh></v>
</v>
</v>
<v t="ekr.20181031045138.493"><vh>@@clean _property.py</vh>
<v t="ekr.20181031045138.494"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.495"><vh>class Property(BaseDescriptor)</vh>
<v t="ekr.20181031045138.496"><vh>Property.__init__</vh></v>
<v t="ekr.20181031045138.497"><vh>Property._consume_args</vh></v>
<v t="ekr.20181031045138.498"><vh>Property._set_name</vh></v>
<v t="ekr.20181031045138.499"><vh>Property._set_data</vh></v>
<v t="ekr.20181031045138.500"><vh>Property.__set__</vh></v>
<v t="ekr.20181031045138.501"><vh>Property.__get__</vh></v>
<v t="ekr.20181031045138.502"><vh>Property.make_mutator</vh></v>
<v t="ekr.20181031045138.503"><vh>Property.make_set_action</vh></v>
<v t="ekr.20181031045138.504"><vh>Property._validate_py</vh></v>
<v t="ekr.20181031045138.505"><vh>Property._validate</vh></v>
</v>
<v t="ekr.20181031045138.506"><vh>class AnyProp(Property)</vh></v>
<v t="ekr.20181031045138.507"><vh>class BoolProp(Property)</vh>
<v t="ekr.20181031045138.508"><vh>BoolProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.509"><vh>class TriStateProp(Property)</vh>
<v t="ekr.20181031045138.510"><vh>TriStateProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.511"><vh>class IntProp(Property)</vh>
<v t="ekr.20181031045138.512"><vh>IntProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.513"><vh>class FloatProp(Property)</vh>
<v t="ekr.20181031045138.514"><vh>FloatProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.515"><vh>class StringProp(Property)</vh>
<v t="ekr.20181031045138.516"><vh>StringProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.517"><vh>class TupleProp(Property)</vh>
<v t="ekr.20181031045138.518"><vh>TupleProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.519"><vh>class ListProp(Property)</vh>
<v t="ekr.20181031045138.520"><vh>ListProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.521"><vh>class DictProp(Property)</vh>
<v t="ekr.20181031045138.522"><vh>DictProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.523"><vh>class ComponentProp(Property)</vh>
<v t="ekr.20181031045138.524"><vh>ComponentProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.525"><vh>class FloatPairProp(Property)</vh>
<v t="ekr.20181031045138.526"><vh>FloatPairProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.527"><vh>class EnumProp(Property)</vh>
<v t="ekr.20181031045138.528"><vh>EnumProp._consume_args</vh></v>
<v t="ekr.20181031045138.529"><vh>EnumProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.530"><vh>class ColorProp(Property)</vh>
<v t="ekr.20181031045138.531"><vh>ColorProp._validate</vh></v>
</v>
</v>
<v t="ekr.20181031045138.532"><vh>@@clean _reaction.py</vh>
<v t="ekr.20181031045138.533"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.534"><vh>looks_like_method </vh></v>
<v t="ekr.20181031045138.535"><vh>reaction </vh></v>
<v t="ekr.20181031045138.536"><vh>class ReactionDescriptor(BaseDescriptor)</vh>
<v t="ekr.20181031045138.537"><vh>ReactionDescriptor.__init__</vh></v>
<v t="ekr.20181031045138.538"><vh>ReactionDescriptor.__get__</vh></v>
<v t="ekr.20181031045138.539"><vh>ReactionDescriptor.local_connection_strings</vh></v>
</v>
<v t="ekr.20181031045138.540"><vh>class Reaction</vh>
<v t="ekr.20181031045138.541"><vh>Reaction.__init__</vh></v>
<v t="ekr.20181031045138.542"><vh>Reaction._init</vh></v>
<v t="ekr.20181031045138.543"><vh>Reaction.__repr__</vh></v>
<v t="ekr.20181031045138.544"><vh>Reaction.get_mode</vh></v>
<v t="ekr.20181031045138.545"><vh>Reaction.get_name</vh></v>
<v t="ekr.20181031045138.546"><vh>Reaction.get_connection_info</vh></v>
<v t="ekr.20181031045138.547"><vh>Reaction._use_once</vh></v>
<v t="ekr.20181031045138.548"><vh>Reaction.__call__</vh></v>
<v t="ekr.20181031045138.549"><vh>Reaction.dispose</vh></v>
<v t="ekr.20181031045138.550"><vh>Reaction._update_implicit_connections</vh></v>
<v t="ekr.20181031045138.551"><vh>Reaction._clear_component_refs</vh></v>
<v t="ekr.20181031045138.552"><vh>Reaction.reconnect</vh></v>
<v t="ekr.20181031045138.553"><vh>Reaction._connect_and_disconnect</vh></v>
<v t="ekr.20181031045138.554"><vh>Reaction._seek_event_object</vh></v>
</v>
</v>
<v t="ekr.20181031045138.555"><vh>@@clean __init__.py</vh>
<v t="ekr.20181031045138.556"><vh>Declarations </vh></v>
</v>
</v>
<v t="ekr.20181031045138.557"><vh>@path resources</vh>
<v t="ekr.20181031045138.558"><vh>@@clean iconmaker.py</vh>
<v t="ekr.20181031045138.559"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.560"><vh>create_icon </vh></v>
<v t="ekr.20181031045138.561"><vh>create_icons </vh></v>
<v t="ekr.20181031045138.562"><vh>create_silly_icon </vh></v>
</v>
</v>
<v t="ekr.20181031045138.563"><vh>@path ui</vh>
<v t="ekr.20181031045138.564"><vh>@@clean _widget.py</vh>
<v t="ekr.20181031045138.565"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.566"><vh>create_element </vh></v>
<v t="ekr.20181031045138.567"><vh>class Widget(app.JsComponent)</vh>
<v t="ekr.20181031045138.568"><vh>Widget.set_icon</vh></v>
<v t="ekr.20181031045138.569"><vh>Widget.__init__</vh></v>
<v t="ekr.20181031045138.570"><vh>Widget._comp_init_property_values</vh></v>
<v t="ekr.20181031045138.571"><vh>Widget.init</vh></v>
<v t="ekr.20181031045138.572"><vh>Widget._create_dom</vh></v>
<v t="ekr.20181031045138.573"><vh>Widget._render_dom</vh></v>
<v t="ekr.20181031045138.574"><vh>Widget.__render</vh></v>
<v t="ekr.20181031045138.575"><vh>Widget.__render_resolve</vh></v>
<v t="ekr.20181031045138.576"><vh>Widget._repr_html_</vh></v>
<v t="ekr.20181031045138.577"><vh>Widget.dispose</vh></v>
<v t="ekr.20181031045138.578"><vh>Widget.apply_style</vh></v>
<v t="ekr.20181031045138.579"><vh>Widget.__css_class_changed</vh></v>
<v t="ekr.20181031045138.580"><vh>Widget.__title_changed</vh></v>
<v t="ekr.20181031045138.581"><vh>Widget.__icon_changed</vh></v>
<v t="ekr.20181031045138.582"><vh>Widget.__update_tabindex</vh></v>
<v t="ekr.20181031045138.583"><vh>Widget._update_minmaxsize</vh></v>
<v t="ekr.20181031045138.584"><vh>Widget._query_min_max_size</vh></v>
<v t="ekr.20181031045138.585"><vh>Widget.check_real_size</vh></v>
<v t="ekr.20181031045138.586"><vh>Widget.__size_may_have_changed</vh></v>
<v t="ekr.20181031045138.587"><vh>Widget._set_size</vh></v>
<v t="ekr.20181031045138.588"><vh>Widget.set_parent</vh></v>
<v t="ekr.20181031045138.589"><vh>Widget.__container_changed</vh></v>
<v t="ekr.20181031045138.590"><vh>Widget._release_child</vh></v>
<v t="ekr.20181031045138.591"><vh>Widget._registered_reactions_hook</vh></v>
<v t="ekr.20181031045138.592"><vh>Widget._init_events</vh></v>
<v t="ekr.20181031045138.593"><vh>Widget.pointer_down</vh></v>
<v t="ekr.20181031045138.594"><vh>Widget.pointer_up</vh></v>
<v t="ekr.20181031045138.595"><vh>Widget.pointer_cancel</vh></v>
<v t="ekr.20181031045138.596"><vh>Widget.pointer_click</vh></v>
<v t="ekr.20181031045138.597"><vh>Widget.pointer_double_click</vh></v>
<v t="ekr.20181031045138.598"><vh>Widget.pointer_move</vh></v>
<v t="ekr.20181031045138.599"><vh>Widget.pointer_wheel</vh></v>
<v t="ekr.20181031045138.600"><vh>Widget._create_pointer_event</vh></v>
<v t="ekr.20181031045138.601"><vh>Widget.key_down</vh></v>
<v t="ekr.20181031045138.602"><vh>Widget.key_up</vh></v>
<v t="ekr.20181031045138.603"><vh>Widget.key_press</vh></v>
<v t="ekr.20181031045138.604"><vh>Widget._create_key_event</vh></v>
</v>
</v>
<v t="ekr.20181031045138.605"><vh>@@clean __init__.py</vh>
<v t="ekr.20181031045138.606"><vh>Declarations </vh></v>
</v>
<v t="ekr.20181031045138.607"><vh>@path layouts</vh>
<v t="ekr.20181031045138.608"><vh>@@clean _form.py</vh>
<v t="ekr.20181031045138.609"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.610"><vh>class BaseTableLayout(Layout)</vh>
<v t="ekr.20181031045138.611"><vh>BaseTableLayout._apply_table_layout</vh></v>
<v t="ekr.20181031045138.612"><vh>BaseTableLayout._adapt_to_size_change</vh></v>
<v t="ekr.20181031045138.613"><vh>BaseTableLayout._apply_cell_layout</vh></v>
</v>
<v t="ekr.20181031045138.614"><vh>class FormLayout(BaseTableLayout)</vh>
<v t="ekr.20181031045138.615"><vh>FormLayout._create_dom</vh></v>
<v t="ekr.20181031045138.616"><vh>FormLayout._render_dom</vh></v>
<v t="ekr.20181031045138.617"><vh>FormLayout._apply_cell_layout</vh></v>
<v t="ekr.20181031045138.618"><vh>FormLayout._query_min_max_size</vh></v>
</v>
</v>
<v t="ekr.20181031045138.619"><vh>@@clean _hv.py</vh>
<v t="ekr.20181031045138.620"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.621"><vh>class OrientationProp(Property)</vh>
<v t="ekr.20181031045138.622"><vh>OrientationProp._validate</vh></v>
</v>
<v t="ekr.20181031045138.623"><vh>class HVLayout(Layout)</vh>
<v t="ekr.20181031045138.624"><vh>HVLayout.__init__</vh></v>
<v t="ekr.20181031045138.625"><vh>HVLayout.set_from_flex_values</vh></v>
<v t="ekr.20181031045138.626"><vh>HVLayout.set_splitter_positions</vh></v>
<v t="ekr.20181031045138.627"><vh>HVLayout.user_splitter_positions</vh></v>
<v t="ekr.20181031045138.628"><vh>HVLayout._query_min_max_size</vh></v>
<v t="ekr.20181031045138.629"><vh>HVLayout.__size_changed</vh></v>
<v t="ekr.20181031045138.630"><vh>HVLayout.__let_children_check_size</vh></v>
<v t="ekr.20181031045138.631"><vh>HVLayout.__set_mode</vh></v>
<v t="ekr.20181031045138.632"><vh>HVLayout.__set_orientation</vh></v>
<v t="ekr.20181031045138.633"><vh>HVLayout.__set_padding</vh></v>
<v t="ekr.20181031045138.634"><vh>HVLayout._release_child</vh></v>
<v t="ekr.20181031045138.635"><vh>HVLayout._render_dom</vh></v>
<v t="ekr.20181031045138.636"><vh>HVLayout._ensure_seps</vh></v>
<v t="ekr.20181031045138.637"><vh>HVLayout._rerender</vh></v>
<v t="ekr.20181031045138.638"><vh>HVLayout._set_box_child_flexes</vh></v>
<v t="ekr.20181031045138.639"><vh>HVLayout._set_box_spacing</vh></v>
<v t="ekr.20181031045138.640"><vh>HVLayout._get_available_size</vh></v>
<v t="ekr.20181031045138.641"><vh>HVLayout.__spacing_changed</vh></v>
<v t="ekr.20181031045138.642"><vh>HVLayout._set_split_from_flexes</vh></v>
<v t="ekr.20181031045138.643"><vh>HVLayout.__watch_splitter_positions</vh></v>
<v t="ekr.20181031045138.644"><vh>HVLayout.__apply_one_splitter_pos</vh></v>
<v t="ekr.20181031045138.645"><vh>HVLayout.__apply_positions</vh></v>
<v t="ekr.20181031045138.646"><vh>HVLayout.__render_positions</vh></v>
<v t="ekr.20181031045138.647"><vh>HVLayout.pointer_down</vh></v>
<v t="ekr.20181031045138.648"><vh>HVLayout.pointer_up</vh></v>
<v t="ekr.20181031045138.649"><vh>HVLayout.pointer_move</vh></v>
</v>
<v t="ekr.20181031045138.650"><vh>_applyBoxStyle </vh></v>
<v t="ekr.20181031045138.651"><vh>_get_min_max </vh></v>
<v t="ekr.20181031045138.652"><vh>class HBox(HVLayout)</vh></v>
<v t="ekr.20181031045138.653"><vh>class VBox(HVLayout)</vh></v>
<v t="ekr.20181031045138.654"><vh>class HFix(HVLayout)</vh></v>
<v t="ekr.20181031045138.655"><vh>class VFix(HVLayout)</vh></v>
<v t="ekr.20181031045138.656"><vh>class HSplit(HVLayout)</vh></v>
<v t="ekr.20181031045138.657"><vh>class VSplit(HVLayout)</vh></v>
</v>
<v t="ekr.20181031045138.658"><vh>@@clean _layout.py</vh>
<v t="ekr.20181031045138.659"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.660"><vh>class Layout(Widget)</vh></v>
</v>
<v t="ekr.20181031045138.661"><vh>@@clean _pinboard.py</vh>
<v t="ekr.20181031045138.662"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.663"><vh>class PinboardLayout(Layout)</vh></v>
</v>
<v t="ekr.20181031045138.664"><vh>@@clean _stack.py</vh>
<v t="ekr.20181031045138.665"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.666"><vh>class StackLayout(Layout)</vh>
<v t="ekr.20181031045138.667"><vh>StackLayout.set_current</vh></v>
<v t="ekr.20181031045138.668"><vh>StackLayout.__set_current_widget</vh></v>
</v>
</v>
<v t="ekr.20181031045138.669"><vh>@@clean _tabs.py</vh>
<v t="ekr.20181031045138.670"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.671"><vh>class TabLayout(StackLayout)</vh>
<v t="ekr.20181031045138.672"><vh>TabLayout._create_dom</vh></v>
<v t="ekr.20181031045138.673"><vh>TabLayout._render_dom</vh></v>
<v t="ekr.20181031045138.674"><vh>TabLayout.__update_tabs</vh></v>
<v t="ekr.20181031045138.675"><vh>TabLayout.__checks_sizes</vh></v>
<v t="ekr.20181031045138.676"><vh>TabLayout.user_current</vh></v>
<v t="ekr.20181031045138.677"><vh>TabLayout._tabbar_click</vh></v>
</v>
</v>
<v t="ekr.20181031045138.678"><vh>@@clean __init__.py</vh>
<v t="ekr.20181031045138.679"><vh>Declarations </vh></v>
</v>
</v>
<v t="ekr.20181031045138.680"><vh>@path widgets</vh>
<v t="ekr.20181031045138.681"><vh>@@clean _bokeh.py</vh>
<v t="ekr.20181031045138.682"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.683"><vh>_load_bokeh </vh></v>
<v t="ekr.20181031045138.684"><vh>_load_bokeh_js </vh></v>
<v t="ekr.20181031045138.685"><vh>_load_bokeh_css </vh></v>
<v t="ekr.20181031045138.686"><vh>make_bokeh_widget </vh></v>
<v t="ekr.20181031045138.687"><vh>class BokehWidget(Widget)</vh>
<v t="ekr.20181031045138.688"><vh>BokehWidget.from_plot</vh></v>
<v t="ekr.20181031045138.689"><vh>BokehWidget._render_dom</vh></v>
<v t="ekr.20181031045138.690"><vh>BokehWidget.set_plot_components</vh></v>
<v t="ekr.20181031045138.691"><vh>BokehWidget.__resize_plot</vh></v>
</v>
</v>
<v t="ekr.20181031045138.692"><vh>@@clean _button.py</vh>
<v t="ekr.20181031045138.693"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.694"><vh>class BaseButton(Widget)</vh>
<v t="ekr.20181031045138.695"><vh>BaseButton.__on_pointer_click</vh></v>
<v t="ekr.20181031045138.696"><vh>BaseButton.user_checked</vh></v>
</v>
<v t="ekr.20181031045138.697"><vh>class Button(BaseButton)</vh>
<v t="ekr.20181031045138.698"><vh>Button._create_dom</vh></v>
<v t="ekr.20181031045138.699"><vh>Button._render_dom</vh></v>
<v t="ekr.20181031045138.700"><vh>Button.__disabled_changed</vh></v>
</v>
<v t="ekr.20181031045138.701"><vh>class ToggleButton(BaseButton)</vh>
<v t="ekr.20181031045138.702"><vh>ToggleButton._create_dom</vh></v>
<v t="ekr.20181031045138.703"><vh>ToggleButton._render_dom</vh></v>
<v t="ekr.20181031045138.704"><vh>ToggleButton.__toggle_checked</vh></v>
<v t="ekr.20181031045138.705"><vh>ToggleButton.__check_changed</vh></v>
</v>
<v t="ekr.20181031045138.706"><vh>class RadioButton(BaseButton)</vh>
<v t="ekr.20181031045138.707"><vh>RadioButton._create_dom</vh></v>
<v t="ekr.20181031045138.708"><vh>RadioButton._render_dom</vh></v>
<v t="ekr.20181031045138.709"><vh>RadioButton.__update_group</vh></v>
<v t="ekr.20181031045138.710"><vh>RadioButton.__check_changed</vh></v>
<v t="ekr.20181031045138.711"><vh>RadioButton.pointer_click</vh></v>
</v>
<v t="ekr.20181031045138.712"><vh>class CheckBox(BaseButton)</vh>
<v t="ekr.20181031045138.713"><vh>CheckBox._create_dom</vh></v>
<v t="ekr.20181031045138.714"><vh>CheckBox._render_dom</vh></v>
<v t="ekr.20181031045138.715"><vh>CheckBox.__check_changed</vh></v>
<v t="ekr.20181031045138.716"><vh>CheckBox._check_changed_from_dom</vh></v>
</v>
</v>
<v t="ekr.20181031045138.717"><vh>@@clean _canvas.py</vh>
<v t="ekr.20181031045138.718"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.719"><vh>class CanvasWidget(Widget)</vh>
<v t="ekr.20181031045138.720"><vh>CanvasWidget._create_dom</vh></v>
<v t="ekr.20181031045138.721"><vh>CanvasWidget._prevent_default_event</vh></v>
<v t="ekr.20181031045138.722"><vh>CanvasWidget._create_pointer_event</vh></v>
<v t="ekr.20181031045138.723"><vh>CanvasWidget.pointer_wheel</vh></v>
<v t="ekr.20181031045138.724"><vh>CanvasWidget._update_canvas_size</vh></v>
</v>
</v>
<v t="ekr.20181031045138.725"><vh>@@clean _color.py</vh>
<v t="ekr.20181031045138.726"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.727"><vh>class ColorSelectWidget(Widget)</vh>
<v t="ekr.20181031045138.728"><vh>ColorSelectWidget._create_dom</vh></v>
<v t="ekr.20181031045138.729"><vh>ColorSelectWidget.user_color</vh></v>
<v t="ekr.20181031045138.730"><vh>ColorSelectWidget._color_changed</vh></v>
<v t="ekr.20181031045138.731"><vh>ColorSelectWidget._color_changed_from_dom</vh></v>
<v t="ekr.20181031045138.732"><vh>ColorSelectWidget.__disabled_changed</vh></v>
</v>
</v>
<v t="ekr.20181031045138.733"><vh>@@clean _dropdown.py</vh>
<v t="ekr.20181031045138.734"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.735"><vh>class BaseDropdown(Widget)</vh>
<v t="ekr.20181031045138.736"><vh>BaseDropdown.init</vh></v>
<v t="ekr.20181031045138.737"><vh>BaseDropdown.expand</vh></v>
<v t="ekr.20181031045138.738"><vh>BaseDropdown._create_dom</vh></v>
<v t="ekr.20181031045138.739"><vh>BaseDropdown._render_dom</vh></v>
<v t="ekr.20181031045138.740"><vh>BaseDropdown._but_click</vh></v>
<v t="ekr.20181031045138.741"><vh>BaseDropdown._submit_text</vh></v>
<v t="ekr.20181031045138.742"><vh>BaseDropdown._expand</vh></v>
<v t="ekr.20181031045138.743"><vh>BaseDropdown._collapse_maybe</vh></v>
<v t="ekr.20181031045138.744"><vh>BaseDropdown._collapse</vh></v>
<v t="ekr.20181031045138.745"><vh>BaseDropdown._check_expanded_pos</vh></v>
</v>
<v t="ekr.20181031045138.746"><vh>class ComboBox(BaseDropdown)</vh>
<v t="ekr.20181031045138.747"><vh>ComboBox.set_options</vh></v>
<v t="ekr.20181031045138.748"><vh>ComboBox.set_selected_index</vh></v>
<v t="ekr.20181031045138.749"><vh>ComboBox.set_selected_key</vh></v>
<v t="ekr.20181031045138.750"><vh>ComboBox.user_selected</vh></v>
<v t="ekr.20181031045138.751"><vh>ComboBox._create_dom</vh></v>
<v t="ekr.20181031045138.752"><vh>ComboBox._render_dom</vh></v>
<v t="ekr.20181031045138.753"><vh>ComboBox.__track_editable</vh></v>
<v t="ekr.20181031045138.754"><vh>ComboBox._ul_click</vh></v>
<v t="ekr.20181031045138.755"><vh>ComboBox._select_from_ul</vh></v>
<v t="ekr.20181031045138.756"><vh>ComboBox._key_down</vh></v>
<v t="ekr.20181031045138.757"><vh>ComboBox._expand</vh></v>
<v t="ekr.20181031045138.758"><vh>ComboBox._submit_text</vh></v>
</v>
<v t="ekr.20181031045138.759"><vh>class DropdownContainer(BaseDropdown)</vh>
<v t="ekr.20181031045138.760"><vh>DropdownContainer._render_dom</vh></v>
<v t="ekr.20181031045138.761"><vh>DropdownContainer._expand</vh></v>
</v>
</v>
<v t="ekr.20181031045138.762"><vh>@@clean _group.py</vh>
<v t="ekr.20181031045138.763"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.764"><vh>class GroupWidget(Widget)</vh>
<v t="ekr.20181031045138.765"><vh>GroupWidget._create_dom</vh></v>
<v t="ekr.20181031045138.766"><vh>GroupWidget._render_dom</vh></v>
<v t="ekr.20181031045138.767"><vh>GroupWidget._query_min_max_size</vh></v>
<v t="ekr.20181031045138.768"><vh>GroupWidget._title_changed</vh></v>
</v>
</v>
<v t="ekr.20181031045138.769"><vh>@@clean _iframe.py</vh>
<v t="ekr.20181031045138.770"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.771"><vh>class IFrame(Widget)</vh>
<v t="ekr.20181031045138.772"><vh>IFrame._create_dom</vh></v>
<v t="ekr.20181031045138.773"><vh>IFrame.__on_size</vh></v>
<v t="ekr.20181031045138.774"><vh>IFrame._update_url</vh></v>
</v>
</v>
<v t="ekr.20181031045138.775"><vh>@@clean _label.py</vh>
<v t="ekr.20181031045138.776"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.777"><vh>class Label(Widget)</vh>
<v t="ekr.20181031045138.778"><vh>Label.init</vh></v>
<v t="ekr.20181031045138.779"><vh>Label.set_text</vh></v>
<v t="ekr.20181031045138.780"><vh>Label.set_html</vh></v>
<v t="ekr.20181031045138.781"><vh>Label._wrap_changed</vh></v>
</v>
</v>
<v t="ekr.20181031045138.782"><vh>@@clean _lineedit.py</vh>
<v t="ekr.20181031045138.783"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.784"><vh>class LineEdit(Widget)</vh>
<v t="ekr.20181031045138.785"><vh>LineEdit._create_dom</vh></v>
<v t="ekr.20181031045138.786"><vh>LineEdit.user_text</vh></v>
<v t="ekr.20181031045138.787"><vh>LineEdit.user_done</vh></v>
<v t="ekr.20181031045138.788"><vh>LineEdit.submit</vh></v>
<v t="ekr.20181031045138.789"><vh>LineEdit.key_down</vh></v>
<v t="ekr.20181031045138.790"><vh>LineEdit.__text_changed</vh></v>
<v t="ekr.20181031045138.791"><vh>LineEdit.__password_mode_changed</vh></v>
<v t="ekr.20181031045138.792"><vh>LineEdit.__placeholder_text_changed</vh></v>
<v t="ekr.20181031045138.793"><vh>LineEdit.__autocomp_changed</vh></v>
<v t="ekr.20181031045138.794"><vh>LineEdit.__disabled_changed</vh></v>
</v>
</v>
<v t="ekr.20181031045138.795"><vh>@@clean _media.py</vh>
<v t="ekr.20181031045138.796"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.797"><vh>class ImageWidget(Widget)</vh>
<v t="ekr.20181031045138.798"><vh>ImageWidget._create_dom</vh></v>
<v t="ekr.20181031045138.799"><vh>ImageWidget.__resize_image</vh></v>
<v t="ekr.20181031045138.800"><vh>ImageWidget.__source_changed</vh></v>
</v>
<v t="ekr.20181031045138.801"><vh>class VideoWidget(Widget)</vh>
<v t="ekr.20181031045138.802"><vh>VideoWidget._create_dom</vh></v>
<v t="ekr.20181031045138.803"><vh>VideoWidget._render_dom</vh></v>
<v t="ekr.20181031045138.804"><vh>VideoWidget.__source_changed</vh></v>
</v>
<v t="ekr.20181031045138.805"><vh>class YoutubeWidget(Widget)</vh>
<v t="ekr.20181031045138.806"><vh>YoutubeWidget._create_dom</vh></v>
<v t="ekr.20181031045138.807"><vh>YoutubeWidget._update_canvas_size</vh></v>
<v t="ekr.20181031045138.808"><vh>YoutubeWidget.__source_changed</vh></v>
</v>
</v>
<v t="ekr.20181031045138.809"><vh>@@clean _plotly.py</vh>
<v t="ekr.20181031045138.810"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.811"><vh>class PlotlyWidget(Widget)</vh>
<v t="ekr.20181031045138.812"><vh>PlotlyWidget.__relayout</vh></v>
<v t="ekr.20181031045138.813"><vh>PlotlyWidget._init_plot</vh></v>
</v>
</v>
<v t="ekr.20181031045138.814"><vh>@@clean _plotwidget.py</vh>
<v t="ekr.20181031045138.815"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.816"><vh>class PlotWidget(CanvasWidget)</vh>
<v t="ekr.20181031045138.817"><vh>PlotWidget.set_data</vh></v>
<v t="ekr.20181031045138.818"><vh>PlotWidget.init</vh></v>
<v t="ekr.20181031045138.819"><vh>PlotWidget.update</vh></v>
<v t="ekr.20181031045138.820"><vh>PlotWidget._update</vh></v>
<v t="ekr.20181031045138.821"><vh>PlotWidget._get_ticks</vh></v>
</v>
</v>
<v t="ekr.20181031045138.822"><vh>@@clean _progressbar.py</vh>
<v t="ekr.20181031045138.823"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.824"><vh>class ProgressBar(Widget)</vh>
<v t="ekr.20181031045138.825"><vh>ProgressBar.set_value</vh></v>
<v t="ekr.20181031045138.826"><vh>ProgressBar.__keep_value_constrained</vh></v>
<v t="ekr.20181031045138.827"><vh>ProgressBar._render_dom</vh></v>
</v>
</v>
<v t="ekr.20181031045138.828"><vh>@@clean _slider.py</vh>
<v t="ekr.20181031045138.829"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.830"><vh>class Slider(Widget)</vh>
<v t="ekr.20181031045138.831"><vh>Slider.init</vh></v>
<v t="ekr.20181031045138.832"><vh>Slider.user_value</vh></v>
<v t="ekr.20181031045138.833"><vh>Slider.user_done</vh></v>
<v t="ekr.20181031045138.834"><vh>Slider.set_value</vh></v>
<v t="ekr.20181031045138.835"><vh>Slider.__keep_value_constrained</vh></v>
<v t="ekr.20181031045138.836"><vh>Slider._render_dom</vh></v>
<v t="ekr.20181031045138.837"><vh>Slider.pointer_down</vh></v>
<v t="ekr.20181031045138.838"><vh>Slider.pointer_up</vh></v>
<v t="ekr.20181031045138.839"><vh>Slider.pointer_move</vh></v>
<v t="ekr.20181031045138.840"><vh>Slider.__on_key</vh></v>
</v>
</v>
<v t="ekr.20181031045138.841"><vh>@@clean _tree.py</vh>
<v t="ekr.20181031045138.842"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.843"><vh>class TreeWidget(Widget)</vh>
<v t="ekr.20181031045138.844"><vh>TreeWidget.init</vh></v>
<v t="ekr.20181031045138.845"><vh>TreeWidget.get_all_items</vh></v>
<v t="ekr.20181031045138.846"><vh>TreeWidget._render_dom</vh></v>
<v t="ekr.20181031045138.847"><vh>TreeWidget.__check_listmode</vh></v>
<v t="ekr.20181031045138.848"><vh>TreeWidget.__max_selected_changed</vh></v>
<v t="ekr.20181031045138.849"><vh>TreeWidget._handle_item_clicked</vh></v>
<v t="ekr.20181031045138.850"><vh>TreeWidget.highlight_hide</vh></v>
<v t="ekr.20181031045138.851"><vh>TreeWidget.highlight_show_item</vh></v>
<v t="ekr.20181031045138.852"><vh>TreeWidget.highlight_show</vh></v>
<v t="ekr.20181031045138.853"><vh>TreeWidget.highlight_get</vh></v>
<v t="ekr.20181031045138.854"><vh>TreeWidget.highlight_toggle_selected</vh></v>
<v t="ekr.20181031045138.855"><vh>TreeWidget.highlight_toggle_checked</vh></v>
<v t="ekr.20181031045138.856"><vh>TreeWidget._de_highlight_and_get_highlighted_index</vh></v>
<v t="ekr.20181031045138.857"><vh>TreeWidget._get_all_items_annotated</vh></v>
</v>
<v t="ekr.20181031045138.858"><vh>class TreeItem(Widget)</vh>
<v t="ekr.20181031045138.859"><vh>TreeItem.user_selected</vh></v>
<v t="ekr.20181031045138.860"><vh>TreeItem.user_checked</vh></v>
<v t="ekr.20181031045138.861"><vh>TreeItem.user_collapsed</vh></v>
<v t="ekr.20181031045138.862"><vh>TreeItem.set_parent</vh></v>
<v t="ekr.20181031045138.863"><vh>TreeItem._create_dom</vh></v>
<v t="ekr.20181031045138.864"><vh>TreeItem._render_dom</vh></v>
<v t="ekr.20181031045138.865"><vh>TreeItem._render_title</vh></v>
<v t="ekr.20181031045138.866"><vh>TreeItem._render_text</vh></v>
<v t="ekr.20181031045138.867"><vh>TreeItem._on_click</vh></v>
<v t="ekr.20181031045138.868"><vh>TreeItem._on_double_click</vh></v>
</v>
</v>
<v t="ekr.20181031045138.869"><vh>@@clean __init__.py</vh>
<v t="ekr.20181031045138.870"><vh>Declarations </vh></v>
</v>
</v>
</v>
<v t="ekr.20181031045138.871"><vh>@path util</vh>
<v t="ekr.20181031045138.872"><vh>@@clean config.py</vh>
<v t="ekr.20181031045138.873"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.874"><vh>as_bool </vh></v>
<v t="ekr.20181031045138.875"><vh>get_tuple_validator </vh></v>
<v t="ekr.20181031045138.876"><vh>stack_sorter </vh></v>
<v t="ekr.20181031045138.877"><vh>class Config(object)</vh>
<v t="ekr.20181031045138.878"><vh>Config.__init__</vh></v>
<v t="ekr.20181031045138.879"><vh>Config.__repr__</vh></v>
<v t="ekr.20181031045138.880"><vh>Config.__str__</vh></v>
<v t="ekr.20181031045138.881"><vh>Config.__len__</vh></v>
<v t="ekr.20181031045138.882"><vh>Config.__iter__</vh></v>
<v t="ekr.20181031045138.883"><vh>Config.__dir__</vh></v>
<v t="ekr.20181031045138.884"><vh>Config.__getattr__</vh></v>
<v t="ekr.20181031045138.885"><vh>Config.__getitem__</vh></v>
<v t="ekr.20181031045138.886"><vh>Config.__setattr__</vh></v>
<v t="ekr.20181031045138.887"><vh>Config.__setitem__</vh></v>
<v t="ekr.20181031045138.888"><vh>Config._set</vh></v>
<v t="ekr.20181031045138.889"><vh>Config.load_from_file</vh></v>
<v t="ekr.20181031045138.890"><vh>Config.load_from_string</vh></v>
<v t="ekr.20181031045138.891"><vh>Config._load_from_string</vh></v>
</v>
<v t="ekr.20181031045138.892"><vh>is_valid_name </vh></v>
<v t="ekr.20181031045138.893"><vh>isidentifier </vh></v>
<v t="ekr.20181031045138.894"><vh>appdata_dir </vh></v>
</v>
<v t="ekr.20181031045138.895"><vh>@@clean getresource.py</vh>
<v t="ekr.20181031045138.896"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.897"><vh>get_resoure_path </vh></v>
<v t="ekr.20181031045138.898"><vh>get_resource </vh></v>
<v t="ekr.20181031045138.899"><vh>_fetch_file </vh></v>
</v>
<v t="ekr.20181031045138.900"><vh>@@clean logging.py</vh>
<v t="ekr.20181031045138.901"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.902"><vh>class _Formatter(logging.Formatter)</vh>
<v t="ekr.20181031045138.903"><vh>_Formatter.__init__</vh></v>
<v t="ekr.20181031045138.904"><vh>_Formatter.format</vh></v>
</v>
<v t="ekr.20181031045138.905"><vh>class _Handler(logging.StreamHandler)</vh>
<v t="ekr.20181031045138.906"><vh>_Handler.emit</vh></v>
</v>
<v t="ekr.20181031045138.907"><vh>class _MatchFilter</vh>
<v t="ekr.20181031045138.908"><vh>_MatchFilter.__init__</vh></v>
<v t="ekr.20181031045138.909"><vh>_MatchFilter.filter</vh></v>
</v>
<v t="ekr.20181031045138.910"><vh>class _CaptureFilter</vh>
<v t="ekr.20181031045138.911"><vh>_CaptureFilter.__init__</vh></v>
<v t="ekr.20181031045138.912"><vh>_CaptureFilter.filter</vh></v>
</v>
<v t="ekr.20181031045138.913"><vh>set_log_level </vh></v>
<v t="ekr.20181031045138.914"><vh>class capture_log</vh>
<v t="ekr.20181031045138.915"><vh>capture_log.__init__</vh></v>
<v t="ekr.20181031045138.916"><vh>capture_log.__enter__</vh></v>
<v t="ekr.20181031045138.917"><vh>capture_log.__exit__</vh></v>
</v>
</v>
<v t="ekr.20181031045138.918"><vh>@@clean minify.py</vh>
<v t="ekr.20181031045138.919"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.920"><vh>minify </vh></v>
<v t="ekr.20181031045138.921"><vh>remove_comments </vh></v>
<v t="ekr.20181031045138.922"><vh>remove_all_whitespace </vh></v>
<v t="ekr.20181031045138.923"><vh>remove_empty_lines </vh></v>
<v t="ekr.20181031045138.924"><vh>remove_trailing_whitespace </vh></v>
<v t="ekr.20181031045138.925"><vh>tabbify </vh></v>
</v>
<v t="ekr.20181031045138.926"><vh>@@clean screenshot.py</vh>
<v t="ekr.20181031045138.927"><vh>Declarations </vh></v>
</v>
<v t="ekr.20181031045138.928"><vh>@@clean testing.py</vh>
<v t="ekr.20181031045138.929"><vh>Declarations </vh></v>
<v t="ekr.20181031045138.930"><vh>run_tests_if_main </vh></v>
<v t="ekr.20181031045138.931"><vh>_enable_faulthandler </vh></v>
<v t="ekr.20181031045138.932"><vh>_clear_our_modules </vh></v>
</v>
<v t="ekr.20181031045138.933"><vh>@@clean __init__.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20181031045130.3"></t>
<t tx="ekr.20181031045138.10">class CLI:
    """ Command line interface class. Commands are simply defined as methods.
    """

    @others
</t>
<t tx="ekr.20181031045138.100">@property
def source(self):
    """ The source for this asset. Can be str, URL or callable.
    """
    return self._source

</t>
<t tx="ekr.20181031045138.101">@property
def remote(self):
    """ Whether the asset is remote (client will load it from elsewhere).
    If True, the source specifies the URL.
    """
    return self._remote

</t>
<t tx="ekr.20181031045138.102">def to_html(self, path='{}', link=3):
    """ Get HTML element tag to include in the document.

    Parameters:
        path (str): the path of this asset, in which '{}' can be used as
            a placeholder for the asset name.
        link (int): whether to link to this asset:

            * 0: the asset is embedded.
            * 1: normal assets are embedded, remote assets remain remote.
            * 2: the asset is linked (and served by our server).
            * 3: (default) normal assets are linked, remote assets remain remote.
    """
    path = path.replace('{}', self.name)

    if self.name.lower().endswith('.js'):
        if self.remote and link in (1, 3):
            return "&lt;script src='%s' id='%s'&gt;&lt;/script&gt;" % (self.source, self.name)
        elif link in (0, 1):
            code = self.to_string()
            s = '\n' if ('\n' in code) else ''
            return "&lt;script id='%s'&gt;%s%s%s&lt;/script&gt;" % (self.name, s, code, s)
        else:
            return "&lt;script src='%s' id='%s'&gt;&lt;/script&gt;" % (path, self.name)
    elif self.name.lower().endswith('.css'):
        if self.remote and link in (1, 3):
            t = "&lt;link rel='stylesheet' type='text/css' href='%s' id='%s' /&gt;"
            return t % (self.source, self.name)
        elif link in (0, 1):
            code = self.to_string()
            s = '\n' if ('\n' in code) else ''
            return "&lt;style id='%s'&gt;%s%s%s&lt;/style&gt;" % (self.name, s, code, s)
        else:
            t = "&lt;link rel='stylesheet' type='text/css' href='%s' id='%s' /&gt;"
            return t % (path, self.name)
    else:  # pragma: no cover
        raise NameError('Assets must be .js or .css')

</t>
<t tx="ekr.20181031045138.103">def to_string(self):
    """ Get the string code for this asset. Even for remote assets.
    """
    if self._source_str is None:
        if callable(self._source):
            self._source_str = self._source()
            if not isinstance(self._source_str, str):
                t = 'Source function of asset %r did not return a str, but a %s.'
                raise ValueError(t % (self.name, self._source.__class__.__name__))
        elif self._remote:
            self._source_str = self._get_from_url(self._source)
        else:  # pragma: no cover
            assert False, 'This should not happen'
    return self._source_str

</t>
<t tx="ekr.20181031045138.104">def _get_from_url(self, url):
    if url.startswith(url_starts):
        req = Request(url, headers={'User-Agent': 'flexx'})
        return urlopen(req, timeout=5.0).read().decode()
    else:  # pragma: no cover
        raise ValueError('_get_from_url() needs a URL string.')


</t>
<t tx="ekr.20181031045138.105">class Bundle(Asset):
    """ A bundle is an asset that represents a collection of Asset objects
    and JSModule objects. In the output, the source for the modules occurs
    after the sources of the assets. Dependency resolution is honoured for
    the modules, and the bundle exposes an aggregate of the dependencies,
    so that bundles can themselves be sorted.
    """

    @others
</t>
<t tx="ekr.20181031045138.106">def __init__(self, name):
    super().__init__(name, '')
    self._assets = []
    self._module_name = name.rsplit('.', 1)[0].split('-')[0]
    self._modules = []
    self._deps = set()
    self._need_sort = False

</t>
<t tx="ekr.20181031045138.107">def __repr__(self):
    t = '&lt;%s %r with %i assets and %i modules at 0x%0x&gt;'
    return t % (self.__class__.__name__, self._name,
                len(self._assets), len(self._modules), id(self))

</t>
<t tx="ekr.20181031045138.108">def add_asset(self, a):
    """ Add an asset to the bundle. Assets added this way occur before the
    code for the modules in this bundle.
    """
    if not isinstance(a, Asset):
        raise TypeError('Bundles.add_asset() needs an Asset, not %s.' %
                        a.__class__.__name__)
    if isinstance(a, Bundle):
        raise TypeError('Bundles can contain assets and modules, but not bundles.')
    self._assets.append(a)

</t>
<t tx="ekr.20181031045138.109">def add_module(self, m):
    """ Add a module to the bundle. This will (lazily) invoke a
    sort of the list of modules, and define dependencies to other
    bundles, so that bundles themselves can be sorted.
    """

    ext = '.' + self.name.rsplit('.')[-1].lower()

    # Check if module belongs here
    if not m.name.startswith(self._module_name):
        raise ValueError('Module %s does not belong in bundle %s.' %
                         (m.name, self.name))

    # Add module
    self._modules.append(m)
    self._need_sort = True

    # Add deps for this module
    deps = set()
    for dep in m.deps:
        while '.' in dep:
            deps.add(dep)
            dep = dep.rsplit('.', 1)[0]
        deps.add(dep)

    # Clear deps that are represented by this bundle
    for dep in deps:
        if not (dep.startswith(self._module_name) or
                self._module_name.startswith(dep + '.')):
            self._deps.add(dep + ext)

</t>
<t tx="ekr.20181031045138.11">def __init__(self, args=None):
    if args is None:
        return

    command = args[0] if args else 'help'
    command = ALIASES.get(command, command)

    if command not in self.get_command_names():
        raise RuntimeError('Invalid command %r' % command)

    func = getattr(self, 'cmd_' + command)
    func(*args[1:])

</t>
<t tx="ekr.20181031045138.110">@property
def assets(self):
    """ The list of assets in this bundle (excluding modules).
    """
    return tuple(self._assets)

</t>
<t tx="ekr.20181031045138.111">@property
def modules(self):
    """ The list of modules, sorted by name and dependencies.
    """
    if self._need_sort:
        f = lambda m: m.name
        self._modules = solve_dependencies(sorted(self._modules, key=f))
    return tuple(self._modules)

</t>
<t tx="ekr.20181031045138.112">@property
def deps(self):
    """ The set of dependencies for this bundle, expressed in module names.
    """
    return self._deps

</t>
<t tx="ekr.20181031045138.113">def to_string(self):
    # Concatenate code strings and add TOC. Module objects do/cache the work.
    isjs = self.name.lower().endswith('.js')
    toc = []
    source = []
    for a in self.assets:
        toc.append('- asset ' + a.name)
        source.append('/* ' + (' %s ' % a.name).center(70, '=') + '*/')
        source.append(a.to_string())
    for m in self.modules:
        s = m.get_js() if isjs else m.get_css()
        toc.append('- module ' + m.name)
        source.append('/* ' + (' %s ' % m.name).center(70, '=') + '*/')
        source.append(HEADER)
        source.append(s)
    if len(self.assets + self.modules) &gt; 1:
        source.insert(0, '/* Bundle contents:\n' + '\n'.join(toc) + '\n*/\n')
    #if isjs:
    #    source.append('window.flexx.spin(%i);' % len(self.modules))
    return '\n\n'.join(source)
</t>
<t tx="ekr.20181031045138.114">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.115">"""
Flexx asset and data management system. The purpose of this class
is to provide the assets (JavaScript and CSS files) and data (images,
etc.) needed by the applications.
"""

from pscript import create_js_module, get_all_std_names, get_full_std_lib
from pscript.stdlib import FUNCTION_PREFIX, METHOD_PREFIX

from ..event import _property
from ..event._js import JS_EVENT
from ..util.getresource import get_resoure_path

from ._component2 import AppComponentMeta
from ._asset import Asset, Bundle, HEADER
from ._modules import JSModule
from . import logger


INDEX = """
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width,user-scalable=no"&gt;
    &lt;title&gt;Flexx UI&lt;/title&gt;
&lt;/head&gt;

&lt;body id='body'&gt;

&lt;noscript&gt; This Flexx application needs JavaScript to be turned on. &lt;/noscript&gt;

&lt;div id='flexx-spinner' class='flx-spinner' style='position:fixed; top:0; bottom:0;
left:0; right:0; background:#fff; color:#555; text-align:center; z-index:9999;
word-break: break-all; padding:0.5em;'&gt;
&lt;div&gt;Starting Flexx app&lt;/div&gt; &lt;div style='font-size:50%; color:#66A;'&gt;&lt;/div&gt;
&lt;/div&gt;

ASSET-HOOK

&lt;/body&gt;
&lt;/html&gt;
""".lstrip()

# This is our loader for AMD modules. It invokes the modules immediately and
# does not resolve dependency order, since the server takes care of that and
# we want Flexx to be ready to use so we can execute commands via the
# websocket. It also allows redefining modules so that one can interactively
# (re)define module classes. The loader is itself wrapped in a IIFE to
# create a private namespace. The modules must follow this pattern:
# define(name, dep_strings, function (name1, name2) {...});


# todo: have loaders per session, or allow prefixing with session id, so that
# each session can bring their own assets and not clash.

LOADER = """
/*Flexx module loader. Licensed by BSD-2-clause.*/

(function(){

if (typeof window === 'undefined' &amp;&amp; typeof module == 'object') {
    throw Error('flexx.app does not run on NodeJS!');
}
if (typeof flexx == 'undefined') {
    window.flexx = {};
}

var modules = {};
function define (name, deps, factory) {
    if (arguments.length == 1) {
        factory = name;
        deps = [];
        name = null;
    }
    if (arguments.length == 2) {
        factory = deps;
        deps = name;
        name = null;
    }
    // Get dependencies - in current implementation, these must be loaded
    var dep_vals = [];
    for (var i=0; i&lt;deps.length; i++) {
        if (modules[deps[i]] === undefined) {
            throw Error('Unknown dependency: ' + deps[i]);
        }
        dep_vals.push(modules[deps[i]]);
    }
    // Load the module and store it if is not anonymous
    var mod = factory.apply(null, dep_vals);
    if (name) {
        modules[name] = mod;
    }
}
define.amd = true;
define.flexx = true;

function require (name) {
    if (name.slice(0, 9) == 'phosphor/') {
        if (window.jupyter &amp;&amp; window.jupyter.lab &amp;&amp; window.jupyter.lab.loader) {
            var path = 'phosphor@*/' + name.slice(9);
            if (!path.slice(-3) == '.js') { path = path + '.js'; }
            return window.jupyter.lab.loader.require(path);
        } else {
            return window.require_phosphor(name);  // provided by our Phosphor-all
        }
    }
    if (modules[name] === undefined) {
        throw Error('Unknown module: ' + name);
    }
    return modules[name];
}

// Expose this
window.flexx.define = define;
window.flexx.require = require;
window.flexx._modules = modules;

})();
""".lstrip()

RESET = """
/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */
html
{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,
section,summary{display:block}
audio,canvas,progress,video{display:inline-block;vertical-align:baseline}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
a{background-color:transparent}
a:active,a:hover{outline:0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
h1{font-size:2em;margin:.67em 0}
mark{background:#ff0;color:#000}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-0.5em}
sub{bottom:-0.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:1em 40px}
hr{box-sizing:content-box;height:0}
pre{overflow:auto}
code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}
button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}
button{overflow:visible}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]
{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
input{line-height:normal}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button{height:auto}
input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
textarea{overflow:auto}
optgroup{font-weight:bold}
table{border-collapse:collapse;border-spacing:0}
td,th{padding:0}
""".lstrip()


</t>
<t tx="ekr.20181031045138.116">class AssetStore:
    """
    Provider of shared assets (CSS, JavaScript) and data (images, etc.).
    Keeps track of JSModules and makes them available via asset bundles.
    The global asset store object can be found at ``flexx.app.assets``.
    Assets and data in the asset store can be used by all sessions.
    Each session object also keeps track of data.

    Assets with additional JS or CSS to load can be used simply by
    creating/importing them in a module that defines the JsComponent class
    that needs the asset.
    """

    @others
assets = AssetStore()
</t>
<t tx="ekr.20181031045138.117">def __init__(self):
    self._known_component_classes = set()
    self._modules = {}
    self._assets = {}
    self._associated_assets = {}
    self._data = {}
    self._used_assets = set()  # between all sessions (for dump)

    # Create asset to reset CSS
    asset_reset = Asset('reset.css', RESET)
    # Create asset to bootstrap Flexx
    asset_loader = Asset('flexx-loader.js', LOADER)
    # Create asset for PScript std
    func_names, method_names = get_all_std_names()
    mod = create_js_module('pscript-std.js', get_full_std_lib(),
                           [], func_names + method_names, 'amd-flexx')
    asset_pscript = Asset('pscript-std.js', HEADER + mod)
    # Create asset for the even system
    pre1 = ', '.join(['%s%s = _py.%s%s' % (FUNCTION_PREFIX, n, FUNCTION_PREFIX, n)
                      for n in JS_EVENT.meta['std_functions']])
    pre2 = ', '.join(['%s%s = _py.%s%s' % (METHOD_PREFIX, n, METHOD_PREFIX, n)
                      for n in JS_EVENT.meta['std_methods']])
    mod = create_js_module('flexx.event.js',
                           'var %s;\nvar %s;\n%s' % (pre1, pre2, JS_EVENT),
                           ['pscript-std.js as _py'],
                           ['Component', 'loop', 'logger'] + _property.__all__,
                           'amd-flexx')
    asset_event = Asset('flexx.event.js', HEADER + mod)
    # Create asset for bsdf - we replace the UMD loader code with flexx.define()
    code = open(get_resoure_path('bsdf.js'), 'rb').read().decode().replace('\r', '')
    code = code.split('"use strict";\n', 1)[1]  # put in the Flexx loader instead
    code = 'flexx.define("bsdf", [], (function () {\n"use strict";\n' + code
    asset_bsdf = Asset('bsdf.js', code)
    # Create asset for bb64 - we replace the UMD loader code with flexx.define()
    code = open(get_resoure_path('bb64.js'), 'rb').read().decode().replace('\r', '')
    code = code.split('"use strict";\n', 1)[1]  # put in the Flexx loader instead
    code = 'flexx.define("bb64", [], (function () {\n"use strict";\n' + code
    asset_bb64 = Asset('bb64.js', code)

    # Add them
    for a in [asset_reset, asset_loader, asset_pscript]:
        self.add_shared_asset(a)

    if getattr(self, '_test_mode', False):
        return

    # Create flexx-core bootstrap bundle
    self.update_modules()  # to collect _component2 and _clientcore
    asset_core = Bundle('flexx-core.js')
    asset_core.add_asset(asset_loader)
    asset_core.add_asset(asset_bsdf)
    asset_core.add_asset(asset_bb64)
    asset_core.add_asset(asset_pscript)
    asset_core.add_asset(asset_event)
    asset_core.add_module(self.modules['flexx.app._clientcore'])
    asset_core.add_module(self.modules['flexx.app._component2'])
    self.add_shared_asset(asset_core)

</t>
<t tx="ekr.20181031045138.118">def __repr__(self):
    t = '&lt;AssetStore with %i assets, and %i data&gt;'
    return t % (len(self._assets), len(self._data))

</t>
<t tx="ekr.20181031045138.119">def create_module_assets(self, *args, **kwargs):
    # Backward compatibility
    raise RuntimeError('create_module_assets is deprecated and no '
                       'longer necessary.')

</t>
<t tx="ekr.20181031045138.12">def get_command_names(self):
    commands = [d[4:] for d in dir(self) if d.startswith('cmd_')]
    commands.sort()
    return commands

</t>
<t tx="ekr.20181031045138.120">@property
def modules(self):
    """ The JSModule objects known to the asset store. Each module
    corresponds to a Python module.
    """
    return self._modules

</t>
<t tx="ekr.20181031045138.121">def update_modules(self):
    """ Collect and update the JSModule instances that correspond
    to Python modules that define Component classes. Any newly created
    modules get added to all corresponding assets bundles (creating
    them if needed).

    It is safe (and pretty fast) to call this more than once since
    only missing modules are added. This gets called automatically
    by the Session object.
    """

    # Dependencies can drag in more modules, therefore we store
    # what modules we know of beforehand.
    current_module_names = set(self._modules)

    # Track all known (i.e. imported) Component classes. We keep track
    # of what classes we've registered, so this is pretty efficient. This
    # works also if a module got a new or renewed Component class.
    for cls in AppComponentMeta.CLASSES:
        if cls not in self._known_component_classes:
            self._known_component_classes.add(cls)
            if cls.__jsmodule__ not in self._modules:
                JSModule(cls.__jsmodule__, self._modules)  # auto-registers
            self._modules[cls.__jsmodule__].add_variable(cls.__name__)

    # Deal with new modules: store asset deps and bundle the modules
    mcount = 0
    bcount = 0
    for name in set(self._modules).difference(current_module_names):
        mod = self.modules[name]
        mcount += 1
        # Get names of bundles to add this module to
        bundle_names = []
        bundle_names.append(name)  # bundle of exactly this one module
        while '.' in name:
            name = name.rsplit('.', 1)[0]
            bundle_names.append(name)
        bcount += len(bundle_names)
        # Add to bundles, create bundle if necesary
        for name in bundle_names:
            for suffix in ['.js', '.css']:
                bundle_name = name + suffix
                if bundle_name not in self._assets:
                    self._assets[bundle_name] = Bundle(bundle_name)
                self._assets[bundle_name].add_module(mod)

    if mcount:
        logger.info('Asset store collected %i new modules.' % mcount)

</t>
<t tx="ekr.20181031045138.122">def get_asset(self, name):
    """ Get the asset instance corresponding to the given name or None
    if it not known.
    """
    if not name.lower().endswith(('.js', '.css')):
        raise ValueError('Asset names always end in .js or .css')
    try:
        asset = self._assets[name]
    except KeyError:
        raise KeyError('Asset %r is not available in the store.' % name)
    self._used_assets.add(asset.name)
    return asset

</t>
<t tx="ekr.20181031045138.123">def get_data(self, name):
    """ Get the data (as bytes) corresponding to the given name or None
    if it not known.
    """
    return self._data.get(name, None)

</t>
<t tx="ekr.20181031045138.124">def get_asset_names(self):
    """ Get a list of all asset names.
    """
    return list(self._assets.keys())

</t>
<t tx="ekr.20181031045138.125">def get_data_names(self):
    """ Get a list of all data names.
    """
    return list(self._data.keys())

</t>
<t tx="ekr.20181031045138.126">def add_shared_asset(self, asset_name, source=None):
    """ Add an asset to the store so that the client can load it from the
    server. Users typically only need this to provide an asset without
    loading it in the main page, e.g. when the asset is loaded by a
    secondary page, a web worker, or AJAX.

    Parameters:
        name (str): the asset name, e.g. 'foo.js' or 'bar.css'. Can contain
            slashes to emulate a file system. e.g. 'spam/foo.js'. If a URL
            is given, both name and source are implicitly set (and its
            a remote asset).
        source (str, function): the source for this asset. Can be:

            * The source code.
            * A URL (str starting with 'http://' or 'https://'),
              making this a "remote asset". Note that ``App.export()``
              provides control over how (remote) assets are handled.
            * A funcion that should return the source code, and which is
              called only when the asset is used. This allows defining
              assets without causing side effects when they're not used.

    Returns:
        str: the (relative) url at which the asset can be retrieved.

    """
    if isinstance(asset_name, Asset):
        # undocumented feature; users will rarely use Asset objects
        asset = asset_name
    else:
        asset = Asset(asset_name, source)
    if asset.name in self._assets:
        raise ValueError('Asset %r already registered.' % asset.name)
    self._assets[asset.name] = asset
    # Returned url is relative so that it also works in exported apps.
    return 'flexx/assets/shared/' + asset.name

</t>
<t tx="ekr.20181031045138.127">def associate_asset(self, mod_name, asset_name, source=None):
    """ Associate an asset with the given module.
    The assets will be loaded when the module that it is associated with
    is used by JavaScript. Multiple assets can be associated with
    a module, and an asset can be associated with multiple modules.

    The intended usage is to write the following inside a module that needs
    the asset: ``app.assets.associate_asset(__name__, ...)``.

    Parameters:
        mod_name (str): The name of the module to associate the asset with.
        asset_name (str): The name of the asset to associate. Can be an
            already registered asset, or a new asset.
        source (str, callable, optional): The source for a new asset. See
            ``add_shared_asset()`` for details. It is an error to supply a
            source if the asset_name is already registered.

    Returns:
        str: the (relative) url at which the asset can be retrieved.
    """
    # Get or create asset
    if asset_name in self._assets:
        asset = self._assets[asset_name]
        if source is not None:
            t = 'associate_asset() for %s got source, but asset %r already exists.'
            raise TypeError(t % (mod_name, asset_name))
    else:
        asset = Asset(asset_name, source)
        self.add_shared_asset(asset)
    # Add to the list of assets for this module
    assets = self._associated_assets.setdefault(mod_name, [])
    if asset.name not in [a.name for a in assets]:
        assets.append(asset)
        assets.sort(key=lambda x: x.i)  # sort by instantiation time
    return 'flexx/assets/shared/' + asset.name

</t>
<t tx="ekr.20181031045138.128">def get_associated_assets(self, mod_name):
    """ Get the names of the assets associated with the given module name.
    Sorted by instantiation time.
    """
    assets = self._associated_assets.get(mod_name, [])
    return tuple([a.name for a in assets])

</t>
<t tx="ekr.20181031045138.129">def add_shared_data(self, name, data):
    """ Add data to serve to the client (e.g. images), which is shared
    between sessions. It is an error to add data with a name that is
    already registered. See ``Session.add_data()`` to set data per-session
    and use actions to send data to JsComponent objects directly.

    Parameters:
        name (str): the name of the data, e.g. 'icon.png'.
        data (bytes): the data blob.

    Returns:
        str: the (relative) url at which the data can be retrieved.

    """
    if not isinstance(name, str):
        raise TypeError('add_shared_data() name must be a str.')
    if name in self._data:
        raise ValueError('add_shared_data() got existing name %r.' % name)
    if not isinstance(data, bytes):
        raise TypeError('add_shared_data() data must be bytes.')
    self._data[name] = data
    return 'flexx/data/shared/%s' % name  # relative path so it works /w export

</t>
<t tx="ekr.20181031045138.13">def get_global_help(self):
    lines = []
    lines.append('Flexx command line interface')
    lines.append('  python -m flexx &lt;command&gt; [args]')
    lines.append('')
    for command in self.get_command_names():
        doc = getattr(self, 'cmd_' + command).__doc__
        if doc:
            summary = doc.strip().splitlines()[0]
            lines.append('%s %s' % (command.ljust(15), summary))
    return '\n'.join(lines)

</t>
<t tx="ekr.20181031045138.130">def _dump_data(self):
    """ Get a dictionary that contains all shared data. The keys
    represent relative paths, the values are all bytes.
    Used by App.dump().
    """
    d = {}
    for fname in self.get_data_names():
        d['flexx/data/shared/' + fname] = self.get_data(fname)
    return d

</t>
<t tx="ekr.20181031045138.131">def _dump_assets(self, also_remote=True):
    """ Get a dictionary that contains assets used by any session.
    The keys represent relative paths, the values are all bytes.
    Used by App.dump().
    """
    d = {}
    for name in self._used_assets:
        asset = self._assets[name]
        if asset.remote and not also_remote:
            continue
        d['flexx/assets/shared/' + asset.name] = asset.to_string().encode()
    return d


\\-4.# Our singleton asset store
</t>
<t tx="ekr.20181031045138.132">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.133">"""
The client's core Flexx engine, implemented in PScript.
"""

from pscript import this_is_js, RawJS
from pscript.stubs import window, undefined, time, console, JSON

# This module gets transpiled to JavaScript as a whole
__pscript__ = True


</t>
<t tx="ekr.20181031045138.134">class Flexx:
    """ JavaScript Flexx module. This provides the connection between
    the Python and JS (via a websocket).
    """

    @others
</t>
<t tx="ekr.20181031045138.135">def __init__(self):

    if window.flexx.init:
        raise RuntimeError('Should not create global Flexx object more than once.')

    # Init (overloadable) variables. These can be set by creating
    # a window.flexx object *before* instantiating this class, or by
    # setting them on this object before the init() is called.
    self.is_notebook = False
    self.is_exported = False

    # Copy attributes from temporary object (e.g. is_notebook, require, ...)
    for key in window.flexx.keys():
        self[key] = window.flexx[key]

    # We need a global main widget (shared between sessions)
    self.need_main_widget = True  # Used/set in ui/_widget.py

    # Keep track of sessions
    self._session_count = 0
    self.sessions = {}

    # Note: flexx.init() is not auto-called when Flexx is embedded
    window.addEventListener('load', self.init, False)
    window.addEventListener('unload', self.exit, False)  # not beforeunload

</t>
<t tx="ekr.20181031045138.136">def init(self):
    """ Called after document is loaded. """
    # Create div to put dynamic CSS assets in
    self.asset_node = window.document.createElement("div")
    self.asset_node.id = 'Flexx asset container'
    window.document.body.appendChild(self.asset_node)

    if self.is_exported:
        if self.is_notebook:
            print('Flexx: I am in an exported notebook!')
        else:
            print('Flexx: I am in an exported app!')
            self.run_exported_app()
    else:
        print('Flexx: Initializing')
        if not self.is_notebook:
            self._remove_querystring()
        self.init_logging()

</t>
<t tx="ekr.20181031045138.137">def _remove_querystring(self):
    # remove querystring ?session=x
    try:
        window.history.replaceState(window.history.state, '',
                                    window.location.pathname)
    except Exception:
        pass  # e.g. firefox-app/nw

</t>
<t tx="ekr.20181031045138.138">def exit(self):
    """ Called when runtime is about to quit. """
    for session in self.sessions.values():
        session.exit()

</t>
<t tx="ekr.20181031045138.139">def spin(self, n=1):
    RawJS("""
    var el = window.document.getElementById('flexx-spinner');
    if (el) {
        if (n === null) {  // Hide the spinner overlay, now or in a bit
            if (el.children[0].innerHTML.indexOf('limited') &gt; 0) {
                setTimeout(function() { el.style.display = 'none'; }, 2000);
            } else {
                el.style.display = 'none';
            }
        } else {
            for (var i=0; i&lt;n; i++) { el.children[1].innerHTML += '&amp;#9632'; }
        }
    }
    """)

</t>
<t tx="ekr.20181031045138.14">def cmd_help(self, command=None):
    """ show information on how to use this command.
    """

    if command:
        if command not in self.get_command_names():
            raise RuntimeError('Invalid command %r' % command)
        doc = getattr(self, 'cmd_' + command).__doc__
        if doc:
            lines = doc.strip().splitlines()
            doc = '\n'.join([lines[0]] + [line[8:] for line in lines[1:]])
            print('%s - %s' % (command, doc))
        else:
            print('%s - no docs' % command)
    else:
        print(self.get_global_help())

</t>
<t tx="ekr.20181031045138.140">def init_logging(self):
    """ Setup logging so that messages are proxied to Python.
    """
    if window.console.ori_log:
        return  # already initialized the loggers
    # Keep originals
    window.console.ori_log = window.console.log
    window.console.ori_info = window.console.info or window.console.log
    window.console.ori_warn = window.console.warn or window.console.log
    window.console.ori_error = window.console.error or window.console.log

    def log(msg):
        window.console.ori_log(msg)
        for session in self.sessions.values():
            session.send_command("PRINT", str(msg))
    def info(msg):
        window.console.ori_info(msg)
        for session in self.sessions.values():
            session.send_command("INFO", str(msg))
    def warn(msg):
        window.console.ori_warn(msg)
        for session in self.sessions.values():
            session.send_command("WARN", str(msg))
    def error(msg):
        evt = dict(message=str(msg), error=msg, preventDefault=lambda: None)
        on_error(evt)
    def on_error(evt):
        self._handle_error(evt)
    on_error = on_error.bind(self)
    # Set new versions
    window.console.log = log
    window.console.info = info
    window.console.warn = warn
    window.console.error = error
    # Create error handler, so that JS errors get into Python
    window.addEventListener('error', on_error, False)

</t>
<t tx="ekr.20181031045138.141">def create_session(self, app_name, session_id, ws_url):
    # The call to this method is embedded by get_page(),
    # or injected by init_notebook().
    # Can be called before init() is called.
    
    if self._validate_browser_capabilities():
        s = JsSession(app_name, session_id, ws_url)
        self._session_count += 1
        self['s' + self._session_count] = s
        self.sessions[session_id] = s

</t>
<t tx="ekr.20181031045138.142">def _validate_browser_capabilities(self):
    # We test a handful of features here, and assume that if these work,
    # all of Flexx works. It is not a hard guarantee, of course, because
    # the user can use modern features in an application.
    RawJS("""
    var el = window.document.getElementById('flexx-spinner');
    if (    window.WebSocket === undefined || // IE10+
            Object.keys === undefined || // IE9+
            false
       ) {
        var msg = ('Flexx does not support this browser.&lt;br&gt;' +
                   'Try Firefox, Chrome, ' +
                   'or a more recent version of the current browser.');
        if (el) { el.children[0].innerHTML = msg; }
        else { window.alert(msg); }
        return false;
    } else if (''.startsWith === undefined) { // probably IE
        var msg = ('Flexx support for this browser is limited.&lt;br&gt;' +
                   'Consider using Firefox, Chrome, or maybe Edge.');
        if (el) { el.children[0].innerHTML = msg; }
        return true;
    } else {
        return true;
    }
    """)

</t>
<t tx="ekr.20181031045138.143">def _handle_error(self, evt):
    msg = short_msg = evt.message
    if not window.evt:
        window.evt = evt
    if evt.error and evt.error.stack:  # evt.error can be None for syntax err
        stack = evt.error.stack.splitlines()
        # Some replacements
        session_needle = '?session_id=' + self.id
        for i in range(len(stack)):
            stack[i] = stack[i].replace('@', ' @ ').replace(session_needle, '')
        # Strip items from the start
        for x in [evt.message, '_pyfunc_op_error']:
            if x in stack[0]:
                stack.pop(0)
        # Truncate the stack
        for i in range(len(stack)):
            for x in ['_process_actions', '_process_reactions', '_process_calls']:
                if ('Loop.' + x) in stack[i]:
                    stack = stack[:i]
                    break
        # Pop items from in between
        for i in reversed(range(len(stack))):
            for x in ['flx_action ']:
                if stack[i] and stack[i].count(x):
                    stack.pop(i)
        # Combine and tweak the message some more
        msg += '\n' + '\n'.join(stack)
    elif evt.message and evt.lineno:  # message, url, linenumber
        msg += "\nIn %s:%i" % (evt.filename, evt.lineno)
    # Handle error
    evt.preventDefault()  # Don't do the standard error
    window.console.ori_error(msg)
    for session in self.sessions.values():
        session.send_command("ERROR", short_msg)

</t>
<t tx="ekr.20181031045138.144">class JsSession:

    @others
if this_is_js():
    # Include bsdf.js
    window.flexx = Flexx()
    bsdf = RawJS("flexx.require('bsdf')")
    serializer = bsdf.BsdfSerializer()
    window.flexx.serializer = serializer
else:
    # Import vendored bsdf lite module
    from . import bsdf_lite as bsdf
    serializer = bsdf.BsdfLiteSerializer()
    serializer.__module__ = __name__
</t>
<t tx="ekr.20181031045138.145">def __init__(self, app_name, id, ws_url=None):
    self.app = None  # the root component (can be a PyComponent)
    self.app_name = app_name
    self.id = id
    self.status = 1
    self.ws_url = ws_url
    self._component_counter = 0
    self._disposed_ob = {'_disposed': True}

    # Maybe this is JLab
    if not self.id:
        jconfig = window.document.getElementById('jupyter-config-data')
        if jconfig:
            try:
                config = JSON.parse(jconfig.innerText)
                self.id = config.flexx_session_id
                self.app_name = config.flexx_app_name
            except Exception as err:
                print(err)

    # Init internal variables
    self._init_time = time()
    self._pending_commands = []  # to pend raw commands during init
    self._asset_count = 0
    self._ws = None
    self.last_msg = None
    # self.classes = {}
    self.instances = {}
    self.instances_to_check_size = {}

    if not window.flexx.is_exported:
        self.init_socket()

    # Initiate service to track resize
    window.addEventListener('resize', self._check_size_of_objects, False)
    window.setInterval(self._check_size_of_objects, 1000)

</t>
<t tx="ekr.20181031045138.146">def exit(self):
    if self._ws:  # is not null or undefined
        self._ws.close()
        self._ws = None
        self.status = 0
        # flexx.instances.sessions.pop(self) might be good,
        # but perhaps not that much need, and leaving is nice for debugging.

</t>
<t tx="ekr.20181031045138.147">def send_command(self, *command):
    if self._ws is not None:
        try:
            bb = serializer.encode(command)
        except Exception as err:
            print('Command that failed to encode:')
            print(command)
            raise err
        self._ws.send(bb)

</t>
<t tx="ekr.20181031045138.148">def instantiate_component(self, module, cname, id, args, kwargs, active_components):
    # Maybe we still have the instance?
    c = self.instances.get(id, None)
    if c is not None and c._disposed is False:
        return c
    # Find the class
    m = window.flexx.require(module)
    Cls = m[cname]  # noqa
    # Instantiate. If given, replicate the active components by which the
    # JsComponent was instantiated in Python.
    kwargs['flx_session'] = self
    kwargs['flx_id'] = id
    active_components = active_components or []
    for ac in active_components:
        ac.__enter__()
    try:
        c = Cls(*args, **kwargs)
    finally:
        for ac in reversed(active_components):
            ac.__exit__()
    return c

</t>
<t tx="ekr.20181031045138.149">def _register_component(self, c, id=None):
    if self.app is None:
        self.app = c  # Set our root component; is the first to register
    if id is None:
        self._component_counter += 1
        id = c.__name__ + '_' + str(self._component_counter) + 'js'
    c._id = id
    c._uid = self.id + '_' + id
    self.instances[c._id] = c

</t>
<t tx="ekr.20181031045138.15">def cmd_version(self):
    """ print the version number
    """
    import sys
    try:
        import flexx
    except ImportError:
        sys.path.insert(0, '.')
        import flexx
    print(flexx.__version__)

</t>
<t tx="ekr.20181031045138.150">def _unregister_component(self, c):
    self.instances_to_check_size.pop(c.id, None)
    pass  # c gets popped from self.instances by DISPOSE_ACK command

</t>
<t tx="ekr.20181031045138.151">def get_component_instance(self, id):
    """ Get instance of a Component class, or None. Or the document body
    if "body" is given.
    """
    if id == 'body':
        return window.document.body
    else:
        return self.instances.get(id, None)

</t>
<t tx="ekr.20181031045138.152">def init_socket(self):
    """ Make the connection to Python.
    """
    # Check WebSocket support
    WebSocket = window.WebSocket
    if (WebSocket is undefined):
        window.document.body.textContent = 'Browser does not support WebSockets'
        raise "FAIL: need websocket"

    # Construct ws url
    if not self.ws_url:
        proto = 'ws'
        if window.location.protocol == 'https:':
            proto = 'wss'
        address = window.location.hostname
        if window.location.port:
            address += ':' + window.location.port
        self.ws_url = '%s://%s/flexx/ws/%s' % (proto, address, self.app_name)
    # Resolve public hostname
    self.ws_url = self.ws_url.replace('0.0.0.0', window.location.hostname)
    # Open web socket in binary mode
    self._ws = ws = WebSocket(self.ws_url)
    ws.binaryType = "arraybuffer"
    self.status = 2

    def on_ws_open(evt):
        window.console.info('Socket opened with session id ' + self.id)
        self.send_command('HI_FLEXX', self.id)
    def on_ws_message(evt):
        msg = evt.data  # bsdf-encoded command
        if not msg:
            pass  # ? drop glitchy message :/
        elif self._pending_commands is None:
            # Direct mode
            self._receive_raw_command(msg)
        else:
            # Indirect mode, to give browser draw-time during loading
            if len(self._pending_commands) == 0:
                window.setTimeout(self._process_commands, 0)
            self._pending_commands.push(msg)
    def on_ws_close(evt):
        self._ws = None
        self.status = 0
        msg = 'Lost connection with server'
        if evt and evt.reason:
            msg += ': %s (%i)' % (evt.reason, evt.code)
        if not window.flexx.is_notebook:
            # todo: show modal or cooky-like dialog instead of killing whole page
            window.document.body.textContent = msg
        else:
            window.console.info(msg)
    def on_ws_error(self, evt):
        self._ws = None
        self.status = 0
        window.console.error('Socket error')

    # Connect
    ws.onopen = on_ws_open
    ws.onmessage = on_ws_message
    ws.onclose = on_ws_close
    ws.onerror = on_ws_error

</t>
<t tx="ekr.20181031045138.153">def _process_commands(self):
    """ A less direct way to process commands, which gives the
    browser time to draw about every other JS asset. This is a
    tradeoff between a smooth spinner and fast load time.
    """
    while self._pending_commands is not None and len(self._pending_commands) &gt; 0:
        msg = self._pending_commands.pop(0)
        try:
            command = self._receive_raw_command(msg)
        except Exception as err:
            window.setTimeout(self._process_commands, 0)
            raise err
        if command[0] == 'DEFINE':
            self._asset_count += 1
            if (self._asset_count % 3) == 0:
                if len(self._pending_commands):
                    window.setTimeout(self._process_commands, 0)
                break

</t>
<t tx="ekr.20181031045138.154">def _receive_raw_command(self, msg):
    return self._receive_command(serializer.decode(msg))

</t>
<t tx="ekr.20181031045138.155">def _receive_command(self, command):
    """ Process a command send from the server.
    """
    cmd = command[0]
    if cmd == 'PING':
        # Used for roundtrip stuff, do at least one iter loop here ...
        window.setTimeout(self.send_command, 10, 'PONG', command[1])
    elif cmd == 'INIT_DONE':
        window.flexx.spin(None)
        while len(self._pending_commands):
            self._receive_raw_command(self._pending_commands.pop(0))
        self._pending_commands = None
        # print('init took', time() - self._init_time)
    elif cmd == 'PRINT':
        (window.console.ori_log or window.console.log)(command[1])
    elif cmd == 'EXEC':
        eval(command[1])
    elif cmd == 'EVAL':
        x = None
        if len(command) == 2:
            x = eval(command[1])
        elif len(command) == 3:
            x = eval('this.instances.' + command[1] + '.' + command[2])
        console.log(str(x))  # print (and thus also sends back result)
    elif cmd == 'EVALANDRETURN':
        try:
            x = eval(command[1])
        except Exception as err:
            x = str(err)
        eval_id = command[2]  # to identify the result in Python
        self.send_command("EVALRESULT", x, eval_id)
    elif cmd == 'INVOKE':
        id, name, args = command[1:]
        ob = self.instances.get(id, None)
        if ob is None:
            console.warn('Cannot invoke %s.%s; '
                         'session does not know it (anymore).' % (id, name))
        elif ob._disposed is True:
            pass  # deleted, but other end might not be aware when command was send
        else:
            ob[name](*args)
    elif cmd == 'INSTANTIATE':
        self.instantiate_component(*command[1:])  # module, cname, id, args, kwargs
    elif cmd == 'DISPOSE':
        id = command[1]
        c = self.instances.get(id, None)
        if c is not None and c._disposed is False:  # else: no need to warn
            c._dispose()
        self.send_command('DISPOSE_ACK', command[1])
        self.instances.pop(id, None)  # Drop local reference now
    elif cmd == 'DISPOSE_ACK':
        self.instances.pop(command[1], None)  # Drop reference
    elif cmd == 'DEFINE':
        #and command[1] == 'JS' or command[1] == 'DEFINE-JS-EVAL '):
        kind, name, code = command[1:]
        window.flexx.spin()
        address = window.location.protocol + '//' + self.ws_url.split('/')[2]
        code += '\n//# sourceURL=%s/flexx/assets/shared/%s\n' % (address, name)
        if kind == 'JS-EVAL':
            eval(code)
        elif kind == 'JS':
            # With this method, sourceURL does not work on Firefox,
            # but eval might not work for assets that don't "use strict"
            # (e.g. Bokeh). Note, btw, that creating links to assets does
            # not work because these won't be loaded on time.
            el = window.document.createElement("script")
            el.id = name
            el.innerHTML = code
            window.flexx.asset_node.appendChild(el)
        elif kind == 'CSS':
            el = window.document.createElement("style")
            el.type = "text/css"
            el.id = name
            el.innerHTML = code
            window.flexx.asset_node.appendChild(el)
        else:
            window.console.error('Dont know how to DEFINE ' +
                                 name + ' with "' + kind + '".')
    elif cmd == 'OPEN':
        window.win1 = window.open(command[1], 'new', 'chrome')
    else:
        window.console.error('Invalid command: "' + cmd + '"')
    return command

</t>
<t tx="ekr.20181031045138.156">def call_after_roundtrip(self, callback, *args):
    ping_to_schedule_at = self._ping_counter + 1
    if len(self._ping_calls) == 0 or self._ping_calls[-1][0] &lt; ping_to_schedule_at:
        window.setTimeout(self._send_ping, 0)
    self._ping_calls.push((ping_to_schedule_at, callback, args))

</t>
<t tx="ekr.20181031045138.157">def _send_ping(self):
    self._ping_counter += 1
    self.send_command('PING', self._ping_counter)

</t>
<t tx="ekr.20181031045138.158">def _receive_pong(self, count):
    while len(self._ping_calls) &gt; 0 and self._ping_calls[0][0] &lt;= count:
        _, callback, args = self._ping_calls.pop(0)
        window.setTimeout(callback, 0, *args)

</t>
<t tx="ekr.20181031045138.159">def keep_checking_size_of(self, ob, check=True):
    """ This is a service that the session provides.
    """
    if check:
        self.instances_to_check_size[ob.id] = ob
    else:
        self.instances_to_check_size.pop(ob.id, None)

</t>
<t tx="ekr.20181031045138.16">def cmd_info(self, port=None):
    """ show info on flexx server process corresponding to given port,
    e.g. flexx info 8080
    The kind of info that is provided is not standardized/documented yet.
    """
    if port is None:
        return self.cmd_help('info')
    port = int(port)
    try:
        print(http_fetch('http://localhost:%i/flexx/cmd/info' % port))
    except FetchError:
        print('There appears to be no local server at port %i' % port)

</t>
<t tx="ekr.20181031045138.160">def _check_size_of_objects(self):
    for ob in self.instances_to_check_size.values():
        if ob._disposed is False:
            ob.check_real_size()


\\-4.# In Python, we need some extras for the serializer to work
</t>
<t tx="ekr.20181031045138.161">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.162">"""
Implementation of the app Component classes (LocalComponent,
ProxyComponent, StubComponent), which form the basis for the
PyComponent and JsComponent classes (and their proxies).
"""

import sys

from pscript import window, JSString, this_is_js

from .. import event

from ..event import Component, loop, Dict
from ..event._component import (with_metaclass, ComponentMeta)

from ..event._property import Property
from ..event._emitter import EmitterDescriptor
from ..event._action import ActionDescriptor
from ..event._js import create_js_component_class

from ._asset import get_mod_name
from . import logger


# The clientcore module is a PScript module that forms the core of the
# client-side of Flexx. We import the serializer instance, and can use
# that name in both Python and JS. Of course, in JS it's just the
# corresponding instance from the module that's being used.
# By using something from clientcore in JS here, we make clientcore a
# dependency of the the current module.
from ._clientcore import serializer, bsdf

manager = None  # Set by __init__ to prevent circular dependencies


</t>
<t tx="ekr.20181031045138.163">def make_proxy_action(action):
    # Note: the flx_prefixes are picked up by the code in flexx.event that
    # compiles component classes, so it can fix /insert the name for JS.
    flx_name = action._name
    def flx_proxy_action(self, *args):
        self._proxy_action(flx_name, *args)
        return self
    flx_proxy_action.__doc__ = action.__doc__
    flx_proxy_action.__qualname__ = 'flx_proxy_action'
    return flx_proxy_action  # ActionDescriptor(flx_proxy_action, flx_name, '')


</t>
<t tx="ekr.20181031045138.164">def make_proxy_emitter(emitter):
    # Note: the flx_prefixes are picked up by the code in flexx.event that
    # compiles component classes, so it can fix /insert the name for JS.
    flx_name = emitter._name
    def flx_proxy_emitter(self, *args):
        self._proxy_emitter(flx_name, *args)
    flx_proxy_emitter.__doc__ = emitter.__doc__
    flx_proxy_emitter.__qualname__ = 'flx_proxy_emitter'
    return flx_proxy_emitter  # EmitterDescriptor(flx_proxy_emitter, flx_name, '')


</t>
<t tx="ekr.20181031045138.165">def get_component_classes():
    """ Get a list of all known PyComponent and JsComponent subclasses.
    """
    return [c for c in AppComponentMeta.CLASSES]


</t>
<t tx="ekr.20181031045138.166">def meta_repr(cls):
    """ A repr function to provide some context on the purpose of a class.
    """
    if issubclass(cls, PyComponent):
        prefix = 'PyComponent class'
    elif issubclass(cls, PyComponent.JS):
        prefix = 'proxy PyComponent class for JS '
    elif issubclass(cls, JsComponent):
        prefix = 'proxy JsComponent class'
    elif issubclass(cls, JsComponent.JS):
        prefix = 'JsComponent class for JS'
    else:
        prefix = 'class'
    return "&lt;%s '%s.%s'&gt;" % (prefix, cls.__module__, cls.__name__)


</t>
<t tx="ekr.20181031045138.167">class LocalProperty(Property):
    """ A generic property that is only present at the local side of
    the component, i.e. not at the proxy. Intended for properties that
    the other side should not care about, and/or for wich syncing would be
    problematic, e.g. for performance or because it contains components
    that we want to keep local.
    """


</t>
<t tx="ekr.20181031045138.168">class ComponentMetaJS(ComponentMeta):
    """ Meta class for autogenerated classes intended for JavaScript:
    Proxy PyComponent and local JsComponents.
    """

    __repr__ = meta_repr

    @others
</t>
<t tx="ekr.20181031045138.169">def __init__(cls, name, *args):
    name = name.encode() if sys.version_info[0] == 2 else name
    return super().__init__(name, *args)


</t>
<t tx="ekr.20181031045138.17">def cmd_stop(self, port=None):
    """ stop the flexx server process corresponding to the given port.
    """
    if port is None:
        return self.cmd_help('stop')
    port = int(port)
    try:
        print(http_fetch('http://localhost:%i/flexx/cmd/stop' % port))
        print('stopped server at %i' % port)
    except FetchError:
        print('There appears to be no local server at port %i' % port)

</t>
<t tx="ekr.20181031045138.170">class AppComponentMeta(ComponentMeta):
    """ Meta class for PyComponent and JsComponent
    that generate a matching class for JS.
    """

    # Keep track of all subclasses
    CLASSES = []

    __repr__ = meta_repr

    @others
</t>
<t tx="ekr.20181031045138.171">def _init_hook1(cls, cls_name, bases, dct):

    # cls is the class to be
    # cls.__dict__ is its current dict, which may contain inherited items
    # dct is the dict represented by exactly this class (no inheritance)

    # Get CSS from the class now
    CSS = dct.get('CSS', '')

    # Create corresponding class for JS
    if issubclass(cls, LocalComponent):
        cls._make_js_proxy_class(cls_name, bases, dct)
    elif issubclass(cls, ProxyComponent):
        cls._make_js_local_class(cls_name, bases, dct)
    else:  # pragma: no cover
        raise TypeError('Expected class to inherit from '
                        'LocalComponent or ProxyComponent.')

    # Write __jsmodule__; an optimization for our module/asset system
    cls.__jsmodule__ = get_mod_name(sys.modules[cls.__module__])
    cls.JS.__jsmodule__ = cls.__jsmodule__  # need it in JS too
    cls.JS.__module__ = cls.__module__

    # Set CSS
    cls.CSS = CSS
    try:
        delattr(cls.JS, 'CSS')
    except AttributeError:
        pass

</t>
<t tx="ekr.20181031045138.172">def _init_hook2(cls, cls_name, bases, dct):

    # Set __proxy_properties__ and __emitters__
    if issubclass(cls, LocalComponent):
        cls.__proxy_properties__ = cls.JS.__properties__
        cls.JS.__emitters__ = cls.__emitters__
    else:
        cls.JS.__proxy_properties__ = cls.__properties__
        cls.__emitters__ = cls.JS.__emitters__

    # Set JS on the JS class
    cls.JS.CODE = cls._get_js()

    # Register this class. The classes in this list will be automatically
    # "pushed to JS" in a JIT fashion. We have to make sure that we include
    # the code for base classes not in this list, which we do in _get_js().
    AppComponentMeta.CLASSES.append(cls)

</t>
<t tx="ekr.20181031045138.173">def _make_js_proxy_class(cls, cls_name, bases, dct):

    for c in bases:
        assert not issubclass(cls, ProxyComponent)

    # Fix inheritance for JS variant
    jsbases = [getattr(b, 'JS') for b in cls.__bases__ if hasattr(b, 'JS')]
    if not jsbases:
        jsbases.append(ProxyComponent)
    jsdict = {}

    # Copy properties from this class to the JS proxy class.
    # in Python 3.6 we iterate in the order in which the items are defined,
    for name, val in dct.items():
        if name.startswith('__') and name.endswith('__'):
            continue
        elif isinstance(val, LocalProperty):
            pass  # do not copy over
        elif isinstance(val, Property):
            jsdict[name] = val  # properties are the same
        elif isinstance(val, EmitterDescriptor):
            jsdict[name] = make_proxy_emitter(val)  # proxy emitter
        elif isinstance(val, ActionDescriptor):
            jsdict[name] = make_proxy_action(val)  # proxy actions
        else:
            pass  # no reactions/functions/class attributes on the proxy side

    # Create JS class
    cls.JS = ComponentMetaJS(cls_name, tuple(jsbases), jsdict)

</t>
<t tx="ekr.20181031045138.174">def _make_js_local_class(cls, cls_name, bases, dct):

    for c in bases:
        assert not issubclass(cls, LocalComponent)

    # Fix inheritance for JS variant
    jsbases = [getattr(b, 'JS') for b in cls.__bases__ if hasattr(b, 'JS')]
    if not jsbases:
        jsbases.append(LocalComponent)
    jsdict = {}

    # Names that should stay in Python in addition to magic methods
    py_only = ['_repr_html_']

    # Copy properties from this class to the JS proxy class.
    # in Python 3.6 we iterate in the order in which the items are defined,
    for name, val in list(dct.items()):
        # Skip?
        if isinstance(val, classmethod):
            continue
        elif name in py_only or name.startswith('__') and name.endswith('__'):
            if name not in ('__init__', '__linenr__'):
                continue
        # Move over to JS
        if (isinstance(val, Property) or (callable(val) and
              name.endswith('_validate'))):
            jsdict[name] = val  # properties are the same
            if isinstance(val, LocalProperty):
                delattr(cls, name)
                dct.pop(name, None)
        elif isinstance(val, EmitterDescriptor):
            # JS part gets the proper emitter, Py side gets a proxy
            jsdict[name] = val
            setattr(cls, name, make_proxy_emitter(val))
        elif isinstance(val, ActionDescriptor):
            # JS part gets the proper action, Py side gets a proxy
            jsdict[name] = val
            setattr(cls, name, make_proxy_action(val))
        else:
            # Move attribute from the Py class to the JS class
            jsdict[name] = val
            delattr(cls, name)
            dct.pop(name, None)  # is this necessary?

    # Create JS class
    cls.JS = ComponentMetaJS(cls_name, tuple(jsbases), jsdict)

</t>
<t tx="ekr.20181031045138.175">def _get_js(cls):
    """ Get source code for this class plus the meta info about the code.
    """
    # Since classes are defined in a module, we can safely name the classes
    # by their plain name.
    cls_name = cls.__name__
    base_class = cls.JS.mro()[1]
    base_class_name = '%s.prototype' % base_class.__name__
    code = []

    # Add this class
    c = create_js_component_class(cls.JS, cls_name, base_class_name)
    meta = c.meta
    code.append(c)
    # code.append(c.replace('var %s =' % cls_name,
    #                   'var %s = flexx.classes.%s =' % (cls_name, cls_name), 1))

    # Add JS version of the base classes - but only once
    if cls.__name__ == 'JsComponent':
        c = cls._get_js_of_base_classes()
        for k in ['vars_unknown', 'vars_global', 'std_functions', 'std_methods']:
            meta[k].update(c.meta[k])
        code.insert(0, c)

    # Return with meta info
    js = JSString('\n'.join(code))
    js.meta = meta
    return js

</t>
<t tx="ekr.20181031045138.176">def _get_js_of_base_classes(cls):
    """ Get JS for BaseAppComponent, LocalComponent, and ProxyComponent.
    """
    c1 = create_js_component_class(BaseAppComponent, 'BaseAppComponent',
                                   'Component.prototype')
    c2 = create_js_component_class(LocalComponent, 'LocalComponent',
                                   'BaseAppComponent.prototype')
    c3 = create_js_component_class(ProxyComponent, 'ProxyComponent',
                                   'BaseAppComponent.prototype')
    c4 = create_js_component_class(StubComponent, 'StubComponent',
                                   'BaseAppComponent.prototype')
    meta = c1.meta
    for k in ['vars_unknown', 'vars_global', 'std_functions', 'std_methods']:
        for c in (c2, c3, c4):
            meta[k].update(c.meta[k])
    js = JSString('\n'.join([c1, c2, c3, c4]))
    js.meta = meta
    return js


</t>
<t tx="ekr.20181031045138.177">class BaseAppComponent(Component):
    """ Inherits from :class:`Component &lt;flexx.event.Component&gt;`
    
    Abstract class for Component classes that can be "shared" between
    Python and JavaScript. The concrete implementations are:

    * The ``PyComponent`` class, which operates in Python, but has a proxy
      object in JavaSript to which properties are synced and from which actions
      can be invoked.
    * The ``JsComponent`` class, which operates in JavaScript, but can have a proxy
      object in Python to which properties are synced and from which actions
      can be invoked.
    * The ``StubComponent`` class, which represents a component class that is
      somewhere else, perhaps in another session. It does not have any
      properties, nor actions. But it can be "moved around".
    """

    session = event.Attribute(doc="""
        The session to which this component belongs. The component id
        is unique within its session.
        """)

    root = event.Attribute(doc="""
        The component that represents the root of the application. Alias for
        session.app.
        """)

    uid = event.Attribute(doc="""
        A unique identifier for this component; a combination of the
        session and component id's.
        """)

    @others
</t>
<t tx="ekr.20181031045138.178">def _comp_init_app_component(self, property_values):
    # Pop special attribute
    property_values.pop('flx_is_app', None)
    # Pop and apply id if given
    custom_id = property_values.pop('flx_id', None)
    # Pop session or derive from active component
    self._session = None
    session = property_values.pop('flx_session', None)
    if session is not None:
        self._session = session
    else:
        active = loop.get_active_components()  # Note that self is active too
        active = active[-2] if len(active) &gt; 1 else None
        if active is not None:
            self._session = active._session
        else:
            if not this_is_js():
                self._session = manager.get_default_session()

    # Register this component with the session (sets _id and _uid)
    if self._session is None:
        raise RuntimeError('%s needs a session!' % (custom_id or self._id))
    self._session._register_component(self, custom_id)
    self._root = self._session.app

    # Return whether this instance was instantiated locally
    return custom_id is None


</t>
<t tx="ekr.20181031045138.179">class LocalComponent(BaseAppComponent):
    """
    Base class for PyComponent in Python and JsComponent in JavaScript.
    """

    @others
</t>
<t tx="ekr.20181031045138.18">def cmd_log(self, port=None, level='info'):
    """ Start listening to log messages from a server process - STUB
    flexx log port level
    """
    if port is None:
        return self.cmd_help('log')
    print('not yet implemented')
    #print(http_fetch('http://localhost:%i/flexx/cmd/log' % int(port)))


</t>
<t tx="ekr.20181031045138.180">def _comp_init_property_values(self, property_values):
    # This is a good time to register with the session, and
    # instantiate the proxy class. Property values have been set at this
    # point, but init() has not yet been called.

    # Keep track of what events are registered at the proxy
    self.__event_types_at_proxy = []

    # Init more
    self._comp_init_app_component(property_values)  # pops items

    # Pop whether this local instance has a proxy at the other side
    self._has_proxy = property_values.pop('flx_has_proxy', False)

    # Call original method
    super()._comp_init_property_values(property_values)

    if this_is_js():
        # This is a local JsComponent in JavaScript
        self._event_listeners = []
    else:
        # This is a local PyComponent in Python
        # A PyComponent always has a corresponding proxy in JS
        self._ensure_proxy_instance(False)

</t>
<t tx="ekr.20181031045138.181">def _ensure_proxy_instance(self, include_props=True):
    """ Make the other end instantiate a proxy if necessary. This is e.g.
    called by the BSDF serializer when a LocalComponent gets serialized.

    A PyComponent always has a Proxy component, and we should not
    dispose or delete it until the local component is disposed.

    A JsComponent may be instantiated (as its proxy) from Python, in which
    case we receive the flx_has_proxy kwarg. Still, Python can "loose" the
    proxy class. To ensure that it exists in Python when needed, the BSDF
    serializer will ensure it (by calling this method) when it gets
    serialized.

    In certain cases, it might be that the other end *does* have a proxy
    while this end's _has_proxy is False. In that case the INSTANTIATE
    command is send, but when handled, will be a no-op.

    In certain cases, it might be that the other end just lost its
    reference; this end's _has_proxy is True, and a new reference to this
    component will fail to resolve. This is countered by keeping hold
    of JsComponent proxy classes for at least one roundtrip (upon
    initialization as well as disposal).
    """
    if self._has_proxy is False and self._disposed is False:
        if self._session.status &gt; 0:
            props = {}
            if include_props:
                for name in self.__proxy_properties__:
                    props[name] = getattr(self, name)
            self._session.send_command('INSTANTIATE', self.__jsmodule__,
                                       self.__class__.__name__,
                                       self._id, [], props)
            self._has_proxy = True

</t>
<t tx="ekr.20181031045138.182">def emit(self, type, info=None):
    # Overload emit() to send events to the proxy object at the other end
    ev = super().emit(type, info)
    isprop = type in self.__proxy_properties__
    if self._has_proxy is True and self._session.status &gt; 0:
        # implicit: and self._disposed is False:
        if isprop or type in self.__event_types_at_proxy:
            self._session.send_command('INVOKE', self._id,
                                       '_emit_at_proxy', [ev])

</t>
<t tx="ekr.20181031045138.183">def _dispose(self):
    # Let proxy side know that we no longer exist, and that it should
    # dispose too. Send regardless of whether we have a proxy!
    was_disposed = self._disposed
    super()._dispose()
    self._has_proxy = False  # because we will tell it to dispose
    if was_disposed is False and self._session is not None:
        self._session._unregister_component(self)
        if self._session.status &gt; 0:
            self._session.send_command('DISPOSE', self._id)

</t>
<t tx="ekr.20181031045138.184">def _flx_set_has_proxy(self, has_proxy):
    self._has_proxy = has_proxy

</t>
<t tx="ekr.20181031045138.185">def _flx_set_event_types_at_proxy(self, event_types):
    self.__event_types_at_proxy = event_types


</t>
<t tx="ekr.20181031045138.186">class ProxyComponent(BaseAppComponent):
    """
    Base class for JSComponent in Python and PyComponent in JavaScript.
    """

    @others
</t>
<t tx="ekr.20181031045138.187">def __init__(self, *init_args, **kwargs):
    # Need to overload this to handle init_args

    if this_is_js():
        # This is a proxy PyComponent in JavaScript.
        # Always instantiated via an INSTANTIATE command from Python.
        assert len(init_args) == 0
        if 'flx_id' not in kwargs:
            raise RuntimeError('Cannot instantiate a PyComponent from JS.')
        super().__init__(**kwargs)
    else:
        # This is a proxy JsComponent in Python.
        # Can be instantiated in Python,
        self._flx_init_args = init_args
        super().__init__(**kwargs)

</t>
<t tx="ekr.20181031045138.188">def _comp_init_property_values(self, property_values):

    # Init more
    local_inst = self._comp_init_app_component(property_values)  # pops items

    # Call original method, only set props if this is instantiated "by the local"
    props2set = {} if local_inst else property_values
    super()._comp_init_property_values(props2set)

    if this_is_js():
        # This is a proxy PyComponent in JavaScript
        assert len(property_values.keys()) == 0
    else:
        # This is a proxy JsComponent in Python
        # Instantiate JavaScript version of this class
        if local_inst is True:  # i.e. only if Python "instantiated" it
            property_values['flx_has_proxy'] = True
            active_components = [c for c in loop.get_active_components()[:-1]
                                 if isinstance(c, (PyComponent, JsComponent))]
            self._session.send_command('INSTANTIATE', self.__jsmodule__,
                                       self.__class__.__name__, self._id,
                                       self._flx_init_args, property_values,
                                       active_components)
        del self._flx_init_args

</t>
<t tx="ekr.20181031045138.189">def _comp_apply_property_values(self, values):
    # Apply props in silence
    for name, value in values:
        setattr(self, '_' + name + '_value', value)

</t>
<t tx="ekr.20181031045138.19">class FetchError(Exception):
    pass

</t>
<t tx="ekr.20181031045138.190">def _proxy_action(self, name, *args, **kwargs):
    """ To invoke actions on the real object.
    """
    assert not kwargs
    # if self._session.status &gt; 0, mmm, or rather error?
    self._session.send_command('INVOKE', self._id, name, args)

</t>
<t tx="ekr.20181031045138.191">def _proxy_emitter(self, name, *args, **kwargs):
    """ To handle use of placeholder emitters.
    """
    # todo: I am not sure yet whether to allow or disallow it. We disallow now;
    # we can always INVOKE the emitter at the other side if that proves needed
    if this_is_js():
        logger.error('Cannot use emitters of a PyComponent in JS.')
    else:
        logger.error('Cannot use emitters of a JsComponent in Py.')

</t>
<t tx="ekr.20181031045138.192">def _mutate(self, *args, **kwargs):  # pragma: no cover
    """ Disable mutations on the proxy class.
    """
    raise RuntimeError('Cannot mutate properties from a proxy class.')
    # Reference objects to get them collected into the JS variant of this
    # module. Do it here, in a place where it wont hurt.
    serializer  # to bring in _clientcore as a way of bootstrapping
    BsdfComponentExtension

</t>
<t tx="ekr.20181031045138.193">def _registered_reactions_hook(self):
    """ Keep the local component informed about what event types this proxy
    is interested in. This way, the trafic can be minimized, e.g. not send
    mouse move events if they're not used anyway.
    """
    event_types = super()._registered_reactions_hook()
    try:
        if self._disposed is False and self._session.status &gt; 0:
            self._session.send_command('INVOKE', self._id,
                                       '_flx_set_event_types_at_proxy',
                                       [event_types])
    finally:
        return event_types

</t>
<t tx="ekr.20181031045138.194">@event.action
def _emit_at_proxy(self, ev):
    """ Action used by the local component to push an event to the proxy
    component. If the event represents a property-update, the mutation
    is applied, otherwise the event is emitted here.
    """
    if not this_is_js():
        ev = Dict(ev)
    if ev.type in self.__properties__ and hasattr(ev, 'mutation'):
        # Mutate the property - this will cause an emit
        if ev.mutation == 'set':
            super()._mutate(ev.type, ev.new_value)
        else:
            super()._mutate(ev.type, ev.objects, ev.mutation, ev.index)
    else:
        self.emit(ev.type, ev)

</t>
<t tx="ekr.20181031045138.195">def dispose(self):
    if this_is_js():
        # The server is leading ...
        raise RuntimeError('Cannot dispose a PyComponent from JS.')
    else:
        # Disposing a JsComponent from JS is like invoking an action;
        # we don't actually dispose ourselves just yet.
        if self._session.status &gt; 0:
            self._session.send_command('INVOKE', self._id, 'dispose', [])
        else:
            super().dispose()

</t>
<t tx="ekr.20181031045138.196">def _dispose(self):
    # This gets called by the session upon a DISPOSE command,
    # or on Python from __delete__ (via call_soon).
    was_disposed = self._disposed
    super()._dispose()
    if was_disposed is False and self._session is not None:
        self._session._unregister_component(self)
        if self._session.status &gt; 0:
            # Let other side know that we no longer exist.
            self._session.send_command('INVOKE', self._id,
                                       '_flx_set_has_proxy', [False])


</t>
<t tx="ekr.20181031045138.197">class StubComponent(BaseAppComponent):
    """
    Class to represent stub proxy components to take the place of components
    that do not belong to the current session, or that do not exist
    for whatever reason. These objects cannot really be used, but they can
    be moved around.
    """

    @others
LocalComponent.__jsmodule__ = __name__
ProxyComponent.__jsmodule__ = __name__
StubComponent.__jsmodule__ = __name__


</t>
<t tx="ekr.20181031045138.198">def __init__(self, session, id):
    super().__init__()
    self._session = session
    self._id = id
    self._uid = session.id + '_' + id

</t>
<t tx="ekr.20181031045138.199">def __repr__(self):
    return ("&lt;StubComponent for '%s' in session '%s' at 0x%x&gt;" %
            (self._id, self._session.id, id(self)))


\\-4.# LocalComponent and ProxyComponent need __jsmodule__, but they do not
\\-4.# participate in the AppComponentMeta class, so we add it here.
</t>
<t tx="ekr.20181031045138.2">@path C:/Anaconda3/Lib/site-packages/flexx/
"""
The flexx.flx module provides a namspace combining all the things from
flexx.app, flexx.event, and flexx.ui.
"""

# flake8: noqa

from . import __version__, config, set_log_level
from .event import *
from .app import *
from .ui import *

@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.20">def http_fetch(url):
    """ Perform an HTTP request.
    """
    from tornado.httpclient import HTTPClient
    http_client = HTTPClient()
    try:
        response = http_client.fetch(url)
    except Exception as err:
        raise FetchError('http fetch failed: %s' % str(err))
    finally:
        http_client.close()
    return response.body.decode()


# Prepare docss
_cli_docs = CLI().get_global_help().splitlines()
__doc__ += '\n'.join(['    ' + line for line in _cli_docs])


</t>
<t tx="ekr.20181031045138.200">class JsComponent(with_metaclass(AppComponentMeta, ProxyComponent)):
    """ Inherits from :class:`BaseAppComponent &lt;flexx.app.BaseAppComponent&gt;`
    
    Base component class that operates in JavaScript, but is accessible
    in Python, where its properties and events can be observed,
    and actions can be invoked.

    JsComponents can be instantiated from both JavaScript and Python. A
    corresponding proxy component is not necessarily present in Python. It
    is created automatically when needed (e.g. when referenced by a property).
    A JsComponent can be explicitly disposed from both Python and JavaScript.
    When the Python garbage collector collects a JsComponent (or really, the
    proxy thereof), only the Python side proxy is disposed; the JsComponent
    in JS itself will be unaffected. Make sure to call ``dispose()`` when
    needed!

    """

    # The meta class will generate a JsComponent local class for JS
    # and move all props, actions, etc. to it.

    @others
</t>
<t tx="ekr.20181031045138.201">def __repr__(self):
    d = ' (disposed)' if self._disposed else ''
    return "&lt;JsComponent '%s'%s at 0x%x&gt;" % (self._id, d, id(self))

</t>
<t tx="ekr.20181031045138.202">def _addEventListener(self, node, type, callback, capture=False):
    """ Register events with DOM nodes, to be automatically cleaned up
    when this object is disposed.
    """
    node.addEventListener(type, callback, capture)
    self._event_listeners.append((node, type, callback, capture))

</t>
<t tx="ekr.20181031045138.203">def _dispose(self):
    super()._dispose()
    while len(self._event_listeners) &gt; 0:
        try:
            node, type, callback, capture = self._event_listeners.pop()
            node.removeEventListener(type, callback, capture)
        except Exception as err:
            print(err)


\\-4.# Note: positioned below JSComponent, because linenr is used to sort JS defs,
\\-4.# and the JS for the base component classes is attached to JSComponent.

</t>
<t tx="ekr.20181031045138.204">class PyComponent(with_metaclass(AppComponentMeta, LocalComponent)):
    """ Inherits from :class:`BaseAppComponent &lt;flexx.app.BaseAppComponent&gt;`
    
    Base component class that operates in Python, but is accessible
    in JavaScript, where its properties and events can be observed,
    and actions can be invoked.

    PyComponents can only be instantiated in Python, and always have
    a corresponding proxy object in JS. PyComponents can be disposed only
    from Python. Disposal also happens if the Python garbage collector
    collects a PyComponent.

    """

    # The meta class generates a PyComponent proxy class for JS.

    @others
</t>
<t tx="ekr.20181031045138.205">def __repr__(self):
    d = ' (disposed)' if self._disposed else ''
    return "&lt;PyComponent '%s'%s at 0x%x&gt;" % (self._id, d, id(self))


</t>
<t tx="ekr.20181031045138.206">class BsdfComponentExtension(bsdf.Extension):
    """ A BSDF extension to encode flexx.app Component objects based on their
    session id and component id.
    """

    name = 'flexx.app.component'
    cls = BaseAppComponent  # PyComponent, JsComponent, StubComponent

    @others
serializer.add_extension(BsdfComponentExtension)
</t>
<t tx="ekr.20181031045138.207">def match(self, s, c):
    # This is actually the default behavior, but added for completenes
    return isinstance(c, self.cls)

</t>
<t tx="ekr.20181031045138.208">def encode(self, s, c):
    if isinstance(c, PyComponent):  # i.e. LocalComponent in Python
        c._ensure_proxy_instance()
    return dict(session_id=c._session.id, id=c._id)

</t>
<t tx="ekr.20181031045138.209">def decode(self, s, d):
    c = None
    session = manager.get_session_by_id(d['session_id'])
    if session is None:
        # object from other session
        session = object()
        session.id = d['session_id']
        c = StubComponent(session, d['id'])
    else:
        c = session.get_component_instance(d['id'])
        if c is None:  # This should probably not happen
            logger.warn('Using stub component for %s.' % d['id'])
            c = StubComponent(session, d['id'])
        else:
            # Keep it alive for a bit
            session.keep_alive(c)
    return c

# The name and below methods get collected to produce a JS BSDF extension

</t>
<t tx="ekr.20181031045138.21">def main():
    # Main entry point (see setup.py)
    CLI(sys.argv[1:])


</t>
<t tx="ekr.20181031045138.210">def match_js(self, s, c):  # pragma: no cover
    return isinstance(c, BaseAppComponent)

</t>
<t tx="ekr.20181031045138.211">def encode_js(self, s, c):  # pragma: no cover
    if isinstance(c, JsComponent):  # i.e. LocalComponent in JS
        c._ensure_proxy_instance()
    return dict(session_id=c._session.id, id=c._id)

</t>
<t tx="ekr.20181031045138.212">def decode_js(self, s, d):  # pragma: no cover
    c = None
    session = window.flexx.sessions.get(d['session_id'], None)
    if session is None:
        session = dict(id=d['session_id'])
        c = StubComponent(session, d['id'])
    else:
        c = session.get_component_instance(d['id'])
        if c is None:
            logger.warn('Using stub component for %s.' % d['id'])
            c = StubComponent(session, d['id'])
    return c


\\-4.# todo: can the mechanism for defining BSDF extensions be simplified?  (issue #429)
\\-4.# Add BSDF extension for serializing components. The JS variant of the
\\-4.# serializer is added by referencing the extension is JS code.
</t>
<t tx="ekr.20181031045138.213">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.214">"""
Functional API for flexx.app
"""

import json
import base64

import webruntime

from .. import config, set_log_level

from ._app import App, manager
from ._component2 import PyComponent, JsComponent
from ._server import current_server
from ._assetstore import assets
from ._clientcore import serializer
from . import logger

reprs = json.dumps

## Main loop functions


</t>
<t tx="ekr.20181031045138.215">def start():
    """
    Start the server and event loop. This function generally does not
    return until the application is stopped (although it may in
    interactive environments (e.g. Pyzo)).

    In more detail, this calls ``run_forever()`` on the asyncio event loop
    associated with the current server.
    """
    server = current_server()
    logger.info('Starting Flexx event loop.')
    server.start()


</t>
<t tx="ekr.20181031045138.216">def run():
    """
    Start the event loop in desktop app mode; the server will close
    down when there are no more connections.
    """
    server = current_server()
    server._auto_stop = True
    return start()


</t>
<t tx="ekr.20181031045138.217">def stop():
    """
    Stop the event loop. This function is thread safe (it can be used
    even if ``app.start()`` was called from another thread).
    The server can be restarted after it has been stopped. Note that
    calling ``stop()`` too often will cause a subsequent call to ``start()``
    to return almost immediately.
    """
    server = current_server()
    server.stop()


</t>
<t tx="ekr.20181031045138.218">@manager.reaction('connections_changed')
def _auto_closer(*events):
    server = current_server()
    if not getattr(server, '_auto_stop', False):
        return
    for name in manager.get_app_names():
        proxies = manager.get_connections(name)
        if proxies:
            return
    else:
        logger.info('Stopping Flexx event loop.')
        server.stop()


## App functions


</t>
<t tx="ekr.20181031045138.219">class NoteBookHelper:
    """ Object that captures commands send to the websocket during the
    execution of a cell, and then applies these commands using a script
    node. This way, Flexx widgets keep working in the exported notebook.
    """

    close_code = None

    @others
</t>
<t tx="ekr.20181031045138.22"></t>
<t tx="ekr.20181031045138.220">def __init__(self, session):
    self._session = session
    self._real_ws = None
    self._commands = []
    self.enable()

</t>
<t tx="ekr.20181031045138.221">def enable(self):
    from IPython import get_ipython
    ip = get_ipython()
    ip.events.register('pre_execute', self.capture)
    ip.events.register('post_execute', self.release)

</t>
<t tx="ekr.20181031045138.222">def capture(self):
    if self._real_ws is not None:
        logger.warn('Notebookhelper already is in capture mode.')
    else:
        if self._session._ws is None:
            raise RuntimeError(
                'Session is missing a websocket connection. If you are '
                'running in JupyterLab, this could be due to '
                'https://github.com/jupyterlab/jupyterlab/issues/3118')
        self._real_ws = self._session._ws
        self._session._ws = self

</t>
<t tx="ekr.20181031045138.223">def release(self):
    if self._session._ws is self:
        self._session._ws = self._real_ws
    self._real_ws = None
    if self._commands:
        from IPython.display import display, Javascript
        lines = []
        lines.append('var bb64 =  flexx.require("bb64");')
        lines.append('function cmd(c) {'
                        'flexx.s1._receive_command('
                        'flexx.serializer.decode('
                        'bb64.decode(c)));}')
        for command in self._commands:  # also DEFINE commands!
            command_str = base64.encodebytes(serializer.encode(command)).decode()
            lines.append('cmd("' + command_str.replace('\n', '') + '");')
        self._commands = []
        display(Javascript('\n'.join(lines)))

</t>
<t tx="ekr.20181031045138.224">def write_command(self, cmd):
    assert isinstance(cmd, tuple) and len(cmd) &gt;= 1
    self._commands.append(cmd)


</t>
<t tx="ekr.20181031045138.225">def init_notebook():
    """ Initialize the Jupyter notebook by injecting the necessary CSS
    and JS into the browser. Note that any Flexx-based libraries that
    you plan to use should probably be imported *before* calling this.

    Does not currently work in JupyterLab because
    https://github.com/jupyterlab/jupyterlab/issues/3118.
    """

    # Note: not using IPython Comm objects yet, since they seem rather
    # undocumented and I could not get them to work when I tried for a bit.
    # This means though, that flexx in the notebook only works on localhost.

    from IPython.display import display, clear_output, HTML
    # from .. import ui  # noqa - make ui assets available

    # Make default log level warning instead of "info" to avoid spamming
    # This preserves the log level set by the user
    config.load_from_string('log_level = warning', 'init_notebook')
    set_log_level(config.log_level)

    # Get session or create new
    session = manager.get_default_session()
    if session is None:
        session = manager.create_default_session()

    # Check if already loaded, if so, re-connect
    if not getattr(session, 'init_notebook_done', False):
        session.init_notebook_done = True
    else:
        display(HTML("&lt;i&gt;Flexx already loaded (the notebook cannot export now)&lt;/i&gt;"))
        return  # Don't inject Flexx twice

    # Open server - the notebook helper takes care of the JS resulting
    # from running a cell, but any interaction goes over the websocket.
    server = current_server()
    host, port = server.serving

    # Install helper to make things work in exported notebooks
    NoteBookHelper(session)

    proto = 'wss' if server.protocol == 'https' else 'ws'

    url = '%s://%s:%i/flexx/ws/%s' % (proto, host, port, session.app_name)

    # Determine JS snippets to run before and after init. The former is only
    # run in live notebooks.
    flexx_pre_init = "&lt;script&gt;window.flexx = {is_live_notebook: true};&lt;/script&gt;"
    flexx_post_init = """&lt;script&gt;
            flexx.is_notebook = true;
            flexx.is_exported = !flexx.is_live_notebook;
            /* If Phosphor is already loaded, disable our Phosphor CSS. */
            if (window.jupyter &amp;&amp; window.jupyter.lab) {
                document.getElementById('phosphor-all.css').disabled = true;
            }
            flexx.init();
            flexx.create_session("%s", "%s", "%s");
            &lt;/script&gt;""" % (session.app_name, session.id, url)
    # Compose HTML to inject
    t = assets.get_asset('flexx-core.js').to_html('{}', 0)
    t += flexx_post_init
    t += "&lt;i&gt;Flexx is ready for use&lt;/i&gt;\n"

    display(HTML(flexx_pre_init))  # Create initial Flexx info dict
    clear_output()  # Make sure the info dict is gone in exported notebooks
    display(HTML(t))

    # Note: the Widget._repr_html_() method is responsible for making
    # the widget show up in the notebook output area.

    # Note: asyncio will need to be enabled via %gui asyncio


# Keep serve and launch, they are still quite nice shorthands to quickly
# get something done.

</t>
<t tx="ekr.20181031045138.226">def serve(cls, name=None, properties=None):
    """ Shorthand for ``app.App(cls).serve(name)``.
    """
    if properties is not None:
        raise RuntimeError('serve(... properties) is deprecated, '
                           'use app.App().serve() instead.')
    # Note: this talks to the manager; it has nothing to do with the server
    assert (isinstance(cls, type) and issubclass(cls, (PyComponent, JsComponent)))
    a = App(cls)
    a.serve(name)
    return cls


</t>
<t tx="ekr.20181031045138.227">def launch(cls, runtime=None, properties=None, **runtime_kwargs):
    """ Shorthand for ``app.App(cls).launch(runtime, **runtime_kwargs)``.
    """
    if properties is not None:
        raise RuntimeError('launch(... properties) is deprecated, '
                           'use app.App().launch() instead.')
    if isinstance(cls, str):
        return webruntime.launch(cls, runtime, **runtime_kwargs)
    assert (isinstance(cls, type) and issubclass(cls, (PyComponent, JsComponent)))
    a = App(cls)
    return a.launch(runtime, **runtime_kwargs)


</t>
<t tx="ekr.20181031045138.228">def export(cls, filename, properties=None, **kwargs):
    """ Shorthand for ``app.App(cls).export(filename, ...)``.
    """
    if properties is not None:
        raise RuntimeError('export(... properties) is deprecated, '
                           'use app.App(...).export() instead.')
    assert (isinstance(cls, type) and issubclass(cls, (PyComponent, JsComponent)))
    a = App(cls)
    return a.export(filename, **kwargs)
</t>
<t tx="ekr.20181031045138.229">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.23">@path C:/Anaconda3/Lib/site-packages/flexx/app/
# This file is distributed under the terms of the 2-clause BSD License.
# Copyright (c) 2017, Almar Klein

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.230">"""
The JSModule class represents the JS module corresponding to a Python module.
The code here resolves dependencies of names used in the JS code, either
by including more JS or by adding a dependency on another JSModule.
"""

import re
import sys
import json
import time
import types
import logging

from pscript import (py2js, JSString, RawJS, JSConstant, create_js_module,
                        get_all_std_names)
from pscript.stdlib import FUNCTION_PREFIX, METHOD_PREFIX

from .. import event
from ..event import Component, Property, loop
from ..event._js import create_js_component_class

from ._clientcore import bsdf
from ._component2 import BaseAppComponent, PyComponent, JsComponent, StubComponent
from ._asset import Asset, get_mod_name, module_is_package
from . import logger


pscript_types = type, types.FunctionType  # class or function

if sys.version_info &gt; (3, ):
    json_types = None.__class__, bool, int, float, str, tuple, list, dict
else:  # pragma: no cover
    json_types = None.__class__, bool, int, float, basestring, tuple, list, dict  # noqa, bah

# In essense, the idea of modules is all about propagating dependencies:
#
# * In PScript we detect unresolved dependencies in JS code, and move these up
#   the namespace stack.
# * The create_js_component_class() function and AppComponentMeta class collect the
#   dependencies from the different code pieces.
# * In JSModule we resolve some dependencies and let other propagate into
#   module dependencies.
# * In the Bundle class, again some dependencies are resolved due to bundling,
#   and others propagate to dependencies between bundles.


</t>
<t tx="ekr.20181031045138.231">def mangle_dotted_vars(jscode, names_to_mangle):
    """ Mangle the names of unknown variables that have dots in them, so that
    they become simple identifiers. We use $ because thats not valid in Python
    (i.e. no name clashes).
    """
    for name in list(names_to_mangle):
        if '.' in name:
            # Replace dots with $
            name1 = name.replace('.', r'\.')
            name2 = name.replace('.', '$')
            jscode = re.sub(r"\b(" + name1 + r")\b", name2, jscode,
                            flags=re.UNICODE | re.MULTILINE)
            # Fix calls with *args to funcs that have dots in name
            jscode = jscode.replace(
                name2 + '.apply(' + name2.rsplit('$', 1)[0] + ', [].concat',
                name2 + '.apply(null, [].concat')
    return jscode


</t>
<t tx="ekr.20181031045138.232">def is_pscript_module(m):
    return (getattr(m, '__pscript__', False) or
            getattr(m, '__pyscript__', False))


</t>
<t tx="ekr.20181031045138.233">class JSModule:
    """
    A JSModule object represents the JavaScript (and CSS) corresponding
    to a Python module, which either defines one or more
    PyComponent/JsCompontent classes, or PScript transpilable functions or
    classes. Intended for internal use only.

    Modules are collected in a "store" which is simply a dictionary. The
    flexx asset system has this dict in ``app.assets.modules``.

    The module contains the JS corresponding to the variables that are
    marked as used (by calling the ``add_variable()`` method), and the
    variables that are used by the included JavaScript.

    The JS code includes:

    * The JS code corresponding to all used Component classes defined in the module.
    * The transpiled JS from (PySript compatible) functions and classes that
      are defined in this module and marked as used.
    * Variables with json-compatible values that are used by JS in this module.
    * Imports of names from other modules.
    * ... unless this module defines ``__pscript__ = True``, in which case
      the module is transpiled as a whole.

    A module can also have dependencies:

    * The modules that define the base classes of the classes defined
      in this module.
    * The modules that define functions/classes that are used by this module.
    * Assets that are present in the module.

    Notes on how the Flexx asset system uses modules:

    The asset system will generate JSModule objects for all Python modules
    that define PyComponent or JsComponent subclasses. The session is aware of
    the Component classes that it uses (and their base classes), and can
    therefore determine what modules (and assets) need to be loaded.
    """

    @others
</t>
<t tx="ekr.20181031045138.234">def __init__(self, name, store):
    if not isinstance(name, str):
        raise TypeError('JSModule needs a str name.')
    if not isinstance(store, dict):
        raise TypeError('JSModule needs a dict store.')

    # Resolve name of Python module
    py_name = name
    if name.endswith('.__init__'):
        py_name = name.rsplit('.', 1)[0]
    if py_name not in sys.modules:
        raise ValueError("Cannot find Python module coresponding to %s." % name)

    # Store module and name
    self._pymodule = sys.modules[py_name]
    self._name = get_mod_name(self._pymodule)

    # Check if name matches the kind of module
    is_package = module_is_package(self._pymodule)
    if is_package and not name.endswith('.__init__'):
        raise ValueError('Modules representing the __init__ of a package '
                         'should end with ".__init__".')
    elif not is_package and name.endswith('.__init__'):
        raise ValueError('Plain modules should not end with ".__init__".')

    # Self-register
    self._store = store
    if self.name in self._store:
        raise RuntimeError('Module %s already exists!' % self.name)
    self._store[self.name] = self

    # Bookkeeping content of the module
    self._provided_names = set()
    self._imported_names = set()
    # Stuff defined in this module (in JS)
    # We use dicts so that we can "overwrite" them in interactive mode
    self._component_classes = {}
    self._pscript_code = {}
    self._js_values = {}
    # Dependencies
    self._deps = {}  # mod_name -&gt; [mod_as_name, *imports]
    # Caches
    self._js_cache = None
    self._css_cache = None

    if is_pscript_module(self._pymodule):
        # PScript module; transpile as a whole
        js = py2js(self._pymodule, inline_stdlib=False, docstrings=False)
        self._pscript_code['__all__'] = js
        self._provided_names.update([n for n in js.meta['vars_defined']
                                     if not n.startswith('_')])
    else:
        self._init_default_objects()

</t>
<t tx="ekr.20181031045138.235">def __repr__(self):
    return '&lt;%s %s with %i definitions&gt;' % (self.__class__.__name__,
                                            self.name,
                                            len(self._provided_names))

</t>
<t tx="ekr.20181031045138.236">def _init_default_objects(self):
    # Component classes
    # Add property classes ...
    for name, val in self._pymodule.__dict__.items():
        if isinstance(val, type) and issubclass(val, Property):
            self.add_variable(name)

</t>
<t tx="ekr.20181031045138.237">@property
def name(self):
    """ The (qualified) name of this module.
    """
    return self._name

</t>
<t tx="ekr.20181031045138.238">@property
def filename(self):
    """ The filename of the Python file that defines
    (the contents of) this module. Can be '__main__'.
    """
    # E.g. __main__ does not have __file__
    return getattr(self._pymodule, '__file__', self.name)

</t>
<t tx="ekr.20181031045138.239">@property
def deps(self):
    """ The (unsorted) set of dependencies (names of other modules) for
    this module.
    """
    return set(self._deps.keys())

</t>
<t tx="ekr.20181031045138.24">"""
Python implementation of the Binary Structured Data Format (BSDF).

BSDF is a binary format for serializing structured (scientific) data.
See http://bsdf.io for more information.

This is a lite (i.e minimal) variant of the Python implementation. Intended for
easy incorporation in projects, and as a demonstration how simple
a BSDF implementation can be.

This module has no dependencies and works on Python 3.4+.
"""

import bz2
import hashlib
import logging
import struct
import sys
import zlib
from io import BytesIO

logger = logging.getLogger(__name__)


VERSION = 2, 2, 0
__version__ = '.'.join(str(i) for i in VERSION)


# %% The encoder and decoder implementation


# Shorthands
spack = struct.pack
strunpack = struct.unpack


</t>
<t tx="ekr.20181031045138.240">@property
def component_classes(self):
    """ The PyComponent and JsComponent classes defined in this module.
    """
    return set(self._component_classes.values())

</t>
<t tx="ekr.20181031045138.241">def _import(self, mod_name, name, as_name):
    """ Import a name from another module. This also ensures that the
    other module exists.
    """
    # Create module, if we must
    if mod_name == self.name:
        return self
    elif mod_name not in self._deps:
        if mod_name not in self._store:
            JSModule(mod_name, store=self._store)
    m = self._store[mod_name]
    # Define imports and if necessary, the name that we import
    imports = self._deps.setdefault(mod_name, [mod_name])
    if name:
        self._imported_names.add(as_name)
        m.add_variable(name)
        line = '%s as %s' % (name, as_name)
        if line not in imports:
            imports.append(line)
    return m

</t>
<t tx="ekr.20181031045138.242">@property
def variables(self):
    """ The names of variables provided by this module.
    A name passed to add_variable, might not end up in this list
    if its imported into this module rather than defined here.
    """
    return self._provided_names

</t>
<t tx="ekr.20181031045138.243">def add_variable(self, name, is_global=False, _dep_stack=None):
    """ Mark the variable with the given name as used by JavaScript.
    The corresponding object must be a module, Component, class or function,
    or a json serializable value.

    If the object is defined here (or a json value) it will add JS to
    this module. Otherwise this module will import the name from
    another module.

    If ``is_global``, the name is considered global; it may be declared in
    this module, but it may also be a JS global. So we try to resolve the
    name, but do not care if it fails.
    """
    _dep_stack = _dep_stack or []
    if name in self._imported_names:
        return
    elif name in _dep_stack:
        return  # avoid dependency recursion
    elif name in ('Infinity', 'NaN'):
        return  # stubs
    elif name in self._provided_names and self.name != '__main__':
        return  # in __main__ we allow redefinitions
    if is_pscript_module(self._pymodule):
        return  # everything is transpiled and exported already
    _dep_stack.append(name)

    # Try getting value. We warn if there is no variable to match, but
    # if we do find a value we're either including it or raising an error
    try:
        val = self._pymodule
        nameparts = name.split('.')
        for i in range(len(nameparts)):
            val = getattr(val, nameparts[i])
            # Maybe we "know" (this kind of) value ...
            if isinstance(val, json_types):
                name = '.'.join(nameparts[:i+1])
                break
            elif isinstance(val, type) and issubclass(val, JsComponent):
                name = '.'.join(nameparts[:i+1])
                break
            elif val is loop and i == 0:
                return self._add_dep_from_event_module('loop', nameparts[0])
            elif isinstance(val, (JSConstant, Asset)):
                return  # stubs
            elif isinstance(val, logging.Logger) and i == 0:
                # todo: hehe, we can do more here (issue #179)
                return self._add_dep_from_event_module('logger', nameparts[0])
    except AttributeError:
        msg = 'JS in "%s" uses undefined variable %r.' % (self.filename, name)
        if is_global:
            pass  # it may be a JS-global
        elif val is self._pymodule:
            # Did not resolve first part of the name, so cannot be a JS global
            logger.warn(msg)
        else:
            raise RuntimeError(msg)  # E.g. typo in ui.Buttom
        return

    # Mark dirty
    self._changed_time = time.time()
    self._js_cache = self._css_cache = None

    if isinstance(val, types.ModuleType):
        # Modules as a whole can be converted if its a PScript module
        if is_pscript_module(val):
            self._import(val.__name__, None, None)
            self._deps[val.__name__][0] = name  # set/overwrite as-name
        else:
            t = 'JS in "%s" cannot use module %s directly unless it defines %s.'
            raise ValueError(t % (self.filename, val.__name__, '"__pscript__"'))

    elif isinstance(val, type) and issubclass(val, Component):
        if val is Component:
            return self._add_dep_from_event_module('Component')
        elif val is BaseAppComponent or val.mro()[1] is BaseAppComponent:
            # BaseAppComponent, PyComponent, JsComponent or StubComponent
            # are covered in _component2.py
            return
        elif issubclass(val, (PyComponent, JsComponent)):
            # App Component class; we know that we can get the JS for this
            if val.__jsmodule__ == self.name:
                # Define here
                self._provided_names.add(name)
                self._component_classes[name] = val
                # Recurse
                self._collect_dependencies_from_bases(val)
                self._collect_dependencies(val.JS.CODE, _dep_stack)
            else:
                # Import from another module
                self._import(val.__jsmodule__, val.__name__, name)
        else:
            # Regular Component, similar to other classes,
            # but using create_js_component_class()
            mod_name = get_mod_name(val)
            if mod_name == self.name:
                # Define here
                js = create_js_component_class(val, val.__name__)
                self._provided_names.add(name)
                self._pscript_code[name] = js
                # Recurse
                self._collect_dependencies_from_bases(val)
                self._collect_dependencies(js, _dep_stack)
            else:
                # Import from another module
                self._import(mod_name, val.__name__, name)

    elif isinstance(val, type) and issubclass(val, bsdf.Extension):
        # A bit hacky mechanism to define BSDF extensions that also work in JS.
        # todo: can we make this better? See also app/_component2.py (issue #429)
        js = 'var %s = {name: "%s"' % (name, val.name)
        for mname in ('match', 'encode', 'decode'):
            func = getattr(val, mname + '_js')
            funccode = py2js(func, indent=1, inline_stdlib=False, docstrings=False)
            js += ',\n    ' + mname + ':' + funccode.split('=', 1)[1].rstrip(' \n;')
            self._collect_dependencies(funccode, _dep_stack)
        js += '};\n'
        js += 'serializer.add_extension(%s);\n' % name
        js = JSString(js)
        js.meta = funccode.meta
        self._pscript_code[name] = js
        self._deps.setdefault('flexx.app._clientcore',
                             ['flexx.app._clientcore']).append('serializer')

    elif isinstance(val, pscript_types) and hasattr(val, '__module__'):
        # Looks like something we can convert using PScript
        mod_name = get_mod_name(val)
        if mod_name == self.name:
            # Define here
            try:
                js = py2js(val, inline_stdlib=False, docstrings=False)
            except Exception as err:
                t = 'JS in "%s" uses %r but cannot transpile it with PScript:\n%s'
                raise ValueError(t % (self.filename, name, str(err)))
            self._provided_names.add(name)
            self._pscript_code[name] = js
            # Recurse
            if isinstance(val, type):
                self._collect_dependencies_from_bases(val)
            self._collect_dependencies(js, _dep_stack)
        elif mod_name.endswith('.event._property'):
            return self._add_dep_from_event_module(name.split('.')[-1], name)
        else:
            # Import from another module
            self._import(mod_name, val.__name__, name)

    elif isinstance(val, RawJS):
        # Verbatim JS
        if val.__module__ == self.name:
            self._provided_names.add(name)
            self._js_values[name] = val.get_code()
        else:
            self._import(val.__module__, val.get_defined_name(name), name)

    elif isinstance(val, json_types):
        # Looks like something we can serialize
        # Unlike with RawJS, we have no way to determine where it is defined
        try:
            js = json.dumps(val)
        except Exception as err:
            t = 'JS in "%s" uses %r but cannot serialize that value:\n%s'
            raise ValueError(t % (self.filename, name, str(err)))
        self._provided_names.add(name)
        self._js_values[name] = js

    elif (getattr(val, '__module__', None) and
          is_pscript_module(sys.modules[val.__module__]) and
          val is getattr(sys.modules[val.__module__], name, 'unlikely-val')):
        # An instance from a pscript module!
        # We cannot know the "name" as its known in the module, but
        # we assume that its the same as as_name and test whether
        # it matches in the test above.
        self._import(val.__module__, name, name)

    else:
        # Cannot convert to JS
        t = 'JS in "%s" uses %r but cannot convert %s to JS.'
        raise ValueError(t % (self.filename, name, val.__class__))

</t>
<t tx="ekr.20181031045138.244">def _collect_dependencies(self, js, _dep_stack):
    """
    Collect dependencies corresponding to names used in the JS.
    """
    vars_unknown = js.meta['vars_unknown']
    vars_global = js.meta['vars_global']
    for name in reversed(sorted(vars_unknown)):
        if name.startswith('event.'):
            self._deps.setdefault('flexx.event.js', ['event'])
        elif self._name_ispropclass(name):
            self._add_dep_from_event_module(name, name)
        else:
            self.add_variable(name, _dep_stack=_dep_stack)
    for name in reversed(sorted(vars_global)):
        self.add_variable(name, True, _dep_stack=_dep_stack)

</t>
<t tx="ekr.20181031045138.245">def _name_ispropclass(self, name):
    ob = getattr(event._property, name, None)
    if ob is not None:
        return isinstance(ob, type) and issubclass(ob, Property)
    return False

</t>
<t tx="ekr.20181031045138.246">def _collect_dependencies_from_bases(self, cls):
    """
    Collect dependencies based on the base classes of a class.
    """
    if len(cls.__bases__) != 1:  # pragma: no cover
        raise TypeError('PScript classes do not (yet) support '
                        'multiple inheritance.')
    if cls is PyComponent or cls is JsComponent or cls is StubComponent:
        return self._add_dep_from_event_module('Component')
    for base_cls in cls.__bases__:
        if base_cls is object:
            return
        elif base_cls is Component:
            return self._add_dep_from_event_module('Component')
        elif base_cls.__module__.endswith('.event._property'):  # base properties
            return self._add_dep_from_event_module(cls.__name__)
        m = self._import(get_mod_name(base_cls),
                         base_cls.__name__, base_cls.__name__)
        m.add_variable(base_cls.__name__)  # note: m can be self, which is ok

</t>
<t tx="ekr.20181031045138.247">def _add_dep_from_event_module(self, name, asname=None):
    asname = asname or name
    entry = '%s as %s' % (name, asname)
    imports = self._deps.setdefault('flexx.event.js', ['event'])
    self._imported_names.add(asname)
    if entry not in imports:
        imports.append(entry)

</t>
<t tx="ekr.20181031045138.248">def get_js(self):
    """ Get the JS code for this module.
    """
    if self._js_cache is None:
        # Collect JS and sort by linenr
        js = [cls.JS.CODE for cls in self._component_classes.values()]
        js += list(self._pscript_code.values())
        js.sort(key=lambda x: x.meta['linenr'])
        used_std_functions, used_std_methods = set(), set()
        for code in js:
            used_std_functions.update(code.meta['std_functions'])
            used_std_methods.update(code.meta['std_methods'])
        # Mangle dotted names
        for i in range(len(js)):
            js[i] = mangle_dotted_vars(js[i], self._imported_names)
        # Insert serialized values
        value_lines = []
        for name in sorted(self._js_values):
            if '.' in name:
                for i in range(len(js)):
                    js[i] = mangle_dotted_vars(js[i], [name])
            value_lines.append('var %s = %s;' % (name.replace('.', '$'),
                                                 self._js_values[name]))
        js.insert(0, '')
        js.insert(0, '\n'.join(value_lines))
        # Prepare imports and exports
        exports = tuple(sorted(n for n in self._provided_names if '.' not in n))
        imports = ['pscript-std.js as _py']
        # Handle dependency imports
        for dep_name in reversed(sorted(self._deps)):
            names = self._deps[dep_name]
            mod_name = names[0].replace('.', '$')  # mangle module name
            imports.append(dep_name + ' as ' + mod_name)
            for name in names[1:]:
                as_name = name
                if ' as ' in name:
                    name, _, as_name = name.partition(' as ')
                    as_name = as_name.replace('.', '$')  # mangle dotted name
                pieces = ['%s = %s.%s' % (as_name, mod_name, name)]
                js.insert(0, 'var ' + (', '.join(pieces)) + ';')
        # Import stdlib
        func_names, method_names = get_all_std_names()
        pre1 = ', '.join(['%s%s = _py.%s%s' %
                          (FUNCTION_PREFIX, n, FUNCTION_PREFIX, n)
                          for n in sorted(used_std_functions)])
        pre2 = ', '.join(['%s%s = _py.%s%s' %
                          (METHOD_PREFIX, n, METHOD_PREFIX, n)
                          for n in sorted(used_std_methods)])
        if pre2:
            js.insert(0, 'var %s;' % pre2)
        if pre1:
            js.insert(0, 'var %s;' % pre1)
        # Create module
        self._js_cache = create_js_module(self.name, '\n\n'.join(js),
                                          imports, exports, 'amd-flexx')
        self._js_cache = self._js_cache
    return self._js_cache

</t>
<t tx="ekr.20181031045138.249">def get_css(self):
    """ Get the CSS code for this module.
    """
    if self._css_cache is None:
        css = []
        sorter = lambda x: x.JS.CODE.meta['linenr']
        for cls in sorted(self._component_classes.values(), key=sorter):
            css.append(cls.CSS)
        self._css_cache = '\n\n'.join(css)
    return self._css_cache
</t>
<t tx="ekr.20181031045138.25">def lencode(x):
    """ Encode an unsigned integer into a variable sized blob of bytes.
    """
    # We could support 16 bit and 32 bit as well, but the gain is low, since
    # 9 bytes for collections with over 250 elements is marginal anyway.
    if x &lt;= 250:
        return spack('&lt;B', x)
    else:
        return spack('&lt;BQ', 253, x)


# Include len decoder for completeness; we've inlined it for performance.
</t>
<t tx="ekr.20181031045138.250">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.251">"""
High level code related to the server that provides a mainloop and
serves the pages and websocket.
"""

import asyncio

from ..event import _loop
from .. import config


# There is always a single current server (except initially there is None)
_current_server = None


</t>
<t tx="ekr.20181031045138.252">def create_server(host=None, port=None, loop=None, backend='tornado',
                  **server_kwargs):
    """
    Create a new server object. This is automatically called; users generally
    don't need this, unless they want to explicitly specify host/port,
    create a fresh server in testing scenarios, or run Flexx in a thread.

    Flexx uses the notion of a single current server object. This function
    (re)creates that object. If there already was a server object, it is
    replaced. It is an error to call this function if the current server
    is still running.

    Arguments:
        host (str): The hostname to serve on. By default
            ``flexx.config.hostname`` is used. If ``False``, do not listen
            (e.g. when integrating with an existing Tornado application).
        port (int, str): The port number. If a string is given, it is
            hashed to an ephemeral port number. By default
            ``flexx.config.port`` is used.
        loop: A fresh (asyncio) event loop, default None (use current).
        backend (str): Stub argument; only Tornado is currently supported.
        **server_kwargs: keyword arguments passed to the server constructor.

    Returns:
        AbstractServer: The server object, see ``current_server()``.
    """
    # Lazy load tornado, so that we can use anything we want there without
    # preventing other parts of flexx.app from using *this* module.
    from ._tornadoserver import TornadoServer  # noqa - circular dependency

    global _current_server
    if backend.lower() != 'tornado':
        raise RuntimeError('Flexx server can only run on Tornado (for now).')
    # Handle defaults
    if host is None:
        host = config.hostname
    if port is None:
        port = config.port
    # Stop old server
    if _current_server:
        _current_server.close()
    # Start hosting
    _current_server = TornadoServer(host, port, loop, **server_kwargs)
    assert isinstance(_current_server, AbstractServer)
    return _current_server


</t>
<t tx="ekr.20181031045138.253">def current_server(create=True):
    """
    Get the current server object. Creates a server if there is none
    and the ``create`` arg is True. Currently, this is always a
    TornadoServer object, which has properties:

    * serving: a tuple ``(hostname, port)`` specifying the location
      being served (or ``None`` if the server is closed).
    * protocol: the protocol (e.g. "http") being used.
    * app: the ``tornado.web.Application`` instance
    * server: the ``tornado.httpserver.HttpServer`` instance

    """
    if create and not _current_server:
        create_server()
    return _current_server


## Server class


</t>
<t tx="ekr.20181031045138.254">class AbstractServer:
    """ This is an attempt to generalize the server, so that in the
    future we may have e.g. a Flask or Pyramid server.

    A server must implement this, and use the manager to instantiate,
    connect and disconnect sessions. The assets object must be used to
    server assets to the client.

    Arguments:
        host (str): the hostname to serve at
        port (int): the port to serve at. None or 0 mean to autoselect a port.
    """

    @others
</t>
<t tx="ekr.20181031045138.255">def __init__(self, host, port, loop=None, **kwargs):
    # First off, create new event loop and integrate event.loop
    if loop is None:
        self._loop = asyncio.get_event_loop()
    else:
        assert isinstance(loop, asyncio.AbstractEventLoop)
        self._loop = loop
    asyncio.set_event_loop(self._loop)
    _loop.loop.integrate(self._loop, reset=False)

    self._serving = None
    if host is not False:
        self._open(host, port, **kwargs)
        assert self._serving  # Check that subclass set private variable

</t>
<t tx="ekr.20181031045138.256">@property
def _running(self):
    return self._loop.is_running()

</t>
<t tx="ekr.20181031045138.257">def start(self):
    """ Start the event loop. """
    if not self._serving:
        raise RuntimeError('Cannot start a closed or non-serving server!')
    if self._running:
        raise RuntimeError('Cannot start a running server.')
    if asyncio.get_event_loop() is not self._loop:
        raise RuntimeError('Can only start server in same thread that created it.')
    # Make use of the semi-standard defined by IPython to determine
    # if the ioloop is "hijacked" (e.g. in Pyzo).
    if not getattr(self._loop, '_in_event_loop', False):
        self._loop.run_forever()

</t>
<t tx="ekr.20181031045138.258">def stop(self):
    """ Stop the event loop. This does not close the connection; the server
    can be restarted. Thread safe. """
    self._loop.call_soon_threadsafe(self._loop.stop)

</t>
<t tx="ekr.20181031045138.259">def close(self):
    """ Close the connection. A closed server cannot be used again. """
    if self._running:
        raise RuntimeError('Cannot close a running server; need to stop first.')
    self._serving = None
    self._close()
    # self._loop.close()

</t>
<t tx="ekr.20181031045138.26">def lendecode(f):
    """ Decode an unsigned integer from a file.
    """
    n = strunpack('&lt;B', f.read(1))[0]
    if n == 253: n = strunpack('&lt;Q', f.read(8))[0]  # noqa
    return n


</t>
<t tx="ekr.20181031045138.260">def _open(self, host, port, **kwargs):
    raise NotImplementedError()

</t>
<t tx="ekr.20181031045138.261">def _close(self):
    raise NotImplementedError()

</t>
<t tx="ekr.20181031045138.262">@property
def serving(self):
    """ Get a tuple (hostname, port) that is being served.
    Or None if the server is not serving (anymore).
    """
    return self._serving

</t>
<t tx="ekr.20181031045138.263">@property
def protocol(self):
    """ Get a string representing served protocol
    """
    raise NotImplementedError
</t>
<t tx="ekr.20181031045138.264">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.265">"""
Definition of the Session class.
"""

import re
import sys
import time
import json
import base64
import random
import hashlib
import asyncio
import weakref
import datetime
from http.cookies import SimpleCookie

from ..event._component import new_type

from ._component2 import PyComponent, JsComponent, AppComponentMeta
from ._asset import Asset, Bundle, solve_dependencies
from ._assetstore import AssetStore, INDEX
from ._assetstore import assets as assetstore
from ._clientcore import serializer
from . import logger

from .. import config

reprs = json.dumps


# Use the system PRNG for session id generation (if possible)
# NOTE: secure random string generation implementation is adapted
#       from the Django project.

</t>
<t tx="ekr.20181031045138.266">def get_random_string(length=24, allowed_chars=None):
    """ Produce a securely generated random string.

    With a length of 12 with the a-z, A-Z, 0-9 character set returns
    a 71-bit value. log_2((26+26+10)^12) =~ 71 bits
    """
    allowed_chars = allowed_chars or ('abcdefghijklmnopqrstuvwxyz' +
                                      'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
    try:
        srandom = random.SystemRandom()
    except NotImplementedError:  # pragma: no cover
        srandom = random
        logger.warn('Falling back to less secure Mersenne Twister random string.')
        bogus = "%s%s%s" % (random.getstate(), time.time(), 'sdkhfbsdkfbsdbhf')
        random.seed(hashlib.sha256(bogus.encode()).digest())

    return ''.join(srandom.choice(allowed_chars) for i in range(length))


</t>
<t tx="ekr.20181031045138.267">class Session:
    """ A connection between Python and the client runtime (JavaScript).

    The session is what holds together the app widget, the web runtime,
    and the websocket instance that connects to it.

    Responsibilities:

    * Send messages to the client and process messages received by the client.
    * Keep track of PyComponent instances used by the session.
    * Keep track of JsComponent instances associated with the session.
    * Ensure that the client has all the module definitions it needs.

    """

    STATUS = new_type('Enum', (), {'PENDING': 1, 'CONNECTED': 2, 'CLOSED': 0})

    @others
</t>
<t tx="ekr.20181031045138.268">def __init__(self, app_name, store=None,
             request=None):  # Allow custom store for testing
    self._store = store if (store is not None) else assetstore
    assert isinstance(self._store, AssetStore)

    self._creation_time = time.time()  # used by app manager

    # Id and name of the app
    self._id = get_random_string()
    self._app_name = app_name

    # To keep track of what modules are defined at the client
    self._present_classes = set()  # Component classes known by the client
    self._present_modules = set()  # module names that, plus deps
    self._present_assets = set()  # names of used associated assets
    self._assets_to_ignore = set()  # user settable

    # Data for this session (in addition to the data provided by the store)
    self._data = {}

    # More vars
    self._runtime = None  # init web runtime, will be set when used
    self._ws = None  # init websocket, will be set when a connection is made
    self._closing = False  # Flag to help with shutdown

    # PyComponent or JsComponent instance, can be None if app_name is __default__
    self._component = None

    # The session assigns component id's and keeps track of component objects
    self._component_counter = 0
    self._component_instances = weakref.WeakValueDictionary()
    self._dead_component_ids = set()

    # Keep track of roundtrips. The _ping_calls elements are:
    # [ping_count, {objects}, *(callback, args)]
    self._ping_calls = []
    self._ping_counter = 0
    self._eval_result = {}
    self._eval_count = 0

    # While the client is not connected, we keep a queue of
    # commands, which are send to the client as soon as it connects
    self._pending_commands = []

    # request related information
    self._request = request
    if request and request.cookies:
        cookies = request.cookies
    else:
        cookies = {}
    self._set_cookies(cookies)

</t>
<t tx="ekr.20181031045138.269">def __repr__(self):
    t = '&lt;%s for %r (%i) at 0x%x&gt;'
    return t % (self.__class__.__name__, self.app_name, self.status, id(self))

</t>
<t tx="ekr.20181031045138.27">def encode_type_id(b, ext_id):
    """ Encode the type identifier, with or without extension id.
    """
    if ext_id is not None:
        bb = ext_id.encode('UTF-8')
        return b.upper() + lencode(len(bb)) + bb  # noqa
    else:
        return b  # noqa


</t>
<t tx="ekr.20181031045138.270">@property
def request(self):
    """The tornado request that was at the origin of this session.
    """
    return self._request

</t>
<t tx="ekr.20181031045138.271">@property
def id(self):
    """ The unique identifier of this session.
    """
    return self._id

</t>
<t tx="ekr.20181031045138.272">@property
def app_name(self):
    """ The name of the application that this session represents.
    """
    return self._app_name

</t>
<t tx="ekr.20181031045138.273">@property
def app(self):
    """ The root PyComponent or JsComponent instance that represents the app.
    """
    return self._component

</t>
<t tx="ekr.20181031045138.274">@property
def runtime(self):
    """ The runtime that is rendering this app instance. Can be
    None if the client is a browser.
    """
    return self._runtime

</t>
<t tx="ekr.20181031045138.275">@property
def status(self):
    """ The status of this session.
    The lifecycle for each session is:

    * status 1: pending
    * status 2: connected
    * status 0: closed
    """
    if self._ws is None:
        return self.STATUS.PENDING  # not connected yet
    elif self._ws.close_code is None:
        return self.STATUS.CONNECTED  # alive and kicking
    else:
        return self.STATUS.CLOSED  # connection closed

</t>
<t tx="ekr.20181031045138.276">@property
def present_modules(self):
    """ The set of module names that is (currently) available at the client.
    """
    return set(self._present_modules)

</t>
<t tx="ekr.20181031045138.277">@property
def assets_to_ignore(self):
    """ The set of names of assets that should *not* be pushed to
    the client, e.g. because they are already present on the page.
    Add names to this set to prevent them from being loaded.
    """
    return self._assets_to_ignore

</t>
<t tx="ekr.20181031045138.278">def close(self):
    """ Close the session: close websocket, close runtime, dispose app.
    """
    # Stop guarding objects to break down any circular refs
    self._ping_calls = []
    self._closing = True  # suppress warnings for session being closed.
    try:
        # Close the websocket
        if self._ws:
            self._ws.close_this()
        # Close the runtime
        if self._runtime:
            self._runtime.close()
        # Dispose the component and break the circular reference
        if self._component is not None:
            self._component.dispose()
            self._component = None
        # Discard data
        self._data = {}
    finally:
        self._closing = False

## Hooking up with app, websocket, runtime

</t>
<t tx="ekr.20181031045138.279">def _set_ws(self, ws):
    """ A session is always first created, so we know what page to
    serve. The client will connect the websocket, and communicate
    the session_id so it can be connected to the correct Session
    via this method
    """
    if self._ws is not None:
        raise RuntimeError('Session is already connected.')
    # Set websocket object - this is what changes the status to CONNECTED
    self._ws = ws
    self._ws.write_command(("PRINT", "Flexx session says hi"))
    # Send pending commands
    for command in self._pending_commands:
        self._ws.write_command(command)
    self._ws.write_command(('INIT_DONE', ))

</t>
<t tx="ekr.20181031045138.28">class BsdfLiteSerializer(object):
    """ Instances of this class represent a BSDF encoder/decoder.

    This is a lite variant of the Python BSDF serializer. It does not support
    lazy loading or streaming, but is otherwise fully functional, including
    support for custom extensions.

    It acts as a placeholder for a set of extensions and encoding/decoding
    options. Options for encoding:

    * compression (int or str): ``0`` or "no" for no compression (default),
      ``1`` or "zlib" for Zlib compression (same as zip files and PNG), and
      ``2`` or "bz2" for Bz2 compression (more compact but slower writing).
      Note that some BSDF implementations (e.g. JavaScript) may not support
      compression.
    * use_checksum (bool): whether to include a checksum with binary blobs.
    * float64 (bool): Whether to write floats as 64 bit (default) or 32 bit.

    """

    @others
</t>
<t tx="ekr.20181031045138.280">def _set_cookies(self, cookies=None):
    """ To set cookies, must be an http.cookie.SimpleCookie object.
    When the app is loaded as a web app, the cookies are set *before* the
    main component is instantiated. Otherwise they are set when the websocket
    is connected.
    """
    self._cookies = cookies if cookies else SimpleCookie()

</t>
<t tx="ekr.20181031045138.281">def _set_runtime(self, runtime):
    if self._runtime is not None:
        raise RuntimeError('Session already has a runtime.')
    self._runtime = runtime

## Cookies, mmm

</t>
<t tx="ekr.20181031045138.282">def get_cookie(self, name, default=None, max_age_days=31, min_version=None):
    """ Gets the value of the cookie with the given name, else default.
    Note that cookies only really work for web apps.
    """
    from tornado.web import decode_signed_value
    if name in self._cookies:
        value = self._cookies[name].value
        value = decode_signed_value(config.cookie_secret,
                                   name, value, max_age_days=max_age_days,
                                   min_version=min_version)
        return value.decode()
    else:
        return default

</t>
<t tx="ekr.20181031045138.283">def set_cookie(self, name, value, expires_days=30, version=None,
               domain=None, expires=None, path="/", **kwargs):
    """ Sets the given cookie name/value with the given options. Set value
    to None to clear. The cookie value is secured using
    `flexx.config.cookie_secret`; don't forget to set that config
    value in your server. Additional keyword arguments are set on
    the Cookie.Morsel directly.
    """
    # This code is taken (in modified form) from the Tornado project
    # Copyright 2009 Facebook
    # Licensed under the Apache License, Version 2.0

    # Assume tornado is available ...
    from tornado.escape import native_str
    from tornado.httputil import format_timestamp
    from tornado.web import create_signed_value

    # Clear cookie?
    if value is None:
        value = ""
        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)
    else:
        secret = config.cookie_secret
        value = create_signed_value(secret, name, value, version=version,
                                    key_version=None)

    # The cookie library only accepts type str, in both python 2 and 3
    name = native_str(name)
    value = native_str(value)
    if re.search(r"[\x00-\x20]", name + value):
        # Don't let us accidentally inject bad stuff
        raise ValueError("Invalid cookie %r: %r" % (name, value))
    if name in self._cookies:
        del self._cookies[name]
    self._cookies[name] = value
    morsel = self._cookies[name]
    if domain:
        morsel["domain"] = domain
    if expires_days is not None and not expires:
        expires = datetime.datetime.utcnow() + datetime.timedelta(
            days=expires_days)
    if expires:
        morsel["expires"] = format_timestamp(expires)
    if path:
        morsel["path"] = path
    for k, v in kwargs.items():
        if k == 'max_age':
            k = 'max-age'
        # skip falsy values for httponly and secure flags because
        # SimpleCookie sets them regardless
        if k in ['httponly', 'secure'] and not v:
            continue
        morsel[k] = v

    self.send_command('EXEC', 'document.cookie = "%s";' %
               morsel.OutputString().replace('"', '\\"'))

## Data

</t>
<t tx="ekr.20181031045138.284">def add_data(self, name, data):
    """ Add data to serve to the client (e.g. images), specific to this
    session. Returns the link at which the data can be retrieved.
    Note that actions can be used to send (binary) data directly
    to the client (over the websocket).

    Parameters:
        name (str): the name of the data, e.g. 'icon.png'. If data has
            already been set on this name, it is overwritten.
        data (bytes): the data blob.

    Returns:
        str: the (relative) url at which the data can be retrieved.
    """
    if not isinstance(name, str):
        raise TypeError('Session.add_data() name must be a str.')
    if name in self._data:
        raise ValueError('Session.add_data() got existing name %r.' % name)
    if not isinstance(data, bytes):
        raise TypeError('Session.add_data() data must be bytes.')
    self._data[name] = data
    return 'flexx/data/%s/%s' % (self.id, name)  # relative path for  export

</t>
<t tx="ekr.20181031045138.285">def remove_data(self, name):
    """ Remove the data associated with the given name. If you need this,
    consider using actions instead. Note that data is automatically
    released when the session is closed.
    """
    self._data.pop(name, None)

</t>
<t tx="ekr.20181031045138.286">def get_data_names(self):
    """ Get a list of names of the data provided by this session.
    """
    return list(self._data.keys())

</t>
<t tx="ekr.20181031045138.287">def get_data(self, name):
    """ Get the data corresponding to the given name. This can be
    data local to the session, or global data. Returns None if data
    by that name is unknown.
    """
    if True:
        data = self._data.get(name, None)
    if data is None:
        data = self._store.get_data(name)
    return data

</t>
<t tx="ekr.20181031045138.288">def _dump_data(self):
    """ Get a dictionary that contains all data specific to this session.
    The keys represent relative paths, the values are all bytes.
    Private method, used by App.dump().
    """
    d = {}
    for fname in self.get_data_names():
        d['flexx/data/{}/{}'.format(self.id, fname)] = self.get_data(fname)
    return d

## Keeping track of component objects

</t>
<t tx="ekr.20181031045138.289">def _register_component(self, component, id=None):
    """ Called by PyComponent and JsComponent to give them an id
    and register with the session.
    """
    assert isinstance(component, (PyComponent, JsComponent))
    assert component.session is self
    cls = component.__class__
    if self._component is None:
        self._component = component  # register root component (i.e. the app)
    # Set id
    if id is None:
        self._component_counter += 1
        id = cls.__name__ + '_' + str(self._component_counter)
    component._id = id
    component._uid = self.id + '_' + id
    # Register the instance using a weakref
    self._component_instances[component._id] = component
    # Register the class to that the client has the needed definitions
    self._register_component_class(cls)
    self.keep_alive(component)

</t>
<t tx="ekr.20181031045138.29">def __init__(self, extensions=None, **options):
    self._extensions = {}  # name -&gt; extension
    self._extensions_by_cls = {}  # cls -&gt; (name, extension.encode)
    if extensions is None:
        extensions = standard_extensions
    for extension in extensions:
        self.add_extension(extension)
    self._parse_options(**options)

</t>
<t tx="ekr.20181031045138.290">def _unregister_component(self, component):
    self._dead_component_ids.add(component.id)
    # self.keep_alive(component)  # does not work on pypy; deletion in final
    # Because we use weak refs, and we want to be able to keep (the id of)
    # the object so that INVOKE on it can be silently ignored (because it
    # is disposed). The object id gets removed by the DISPOSE_ACK command.

</t>
<t tx="ekr.20181031045138.291">def get_component_instance(self, id):
    """ Get PyComponent or JsComponent instance that is associated with
    this session and has the corresponding id. The returned value can be
    None if it does not exist, and a returned component can be disposed.
    """
    return self._component_instances.get(id, None)

## JIT asset definitions

</t>
<t tx="ekr.20181031045138.292">def _register_component_class(self, cls):
    """ Mark the given PyComponent or JsComponent class as used; ensure
    that the client knows about the module that it is defined in,
    dependencies of this module, and associated assets of any of these
    modules.
    """
    if not (isinstance(cls, type) and issubclass(cls, (PyComponent, JsComponent))):
        raise TypeError('_register_component_class() needs a PyComponent '
                        'or JsComponent class')
    # Early exit if we know the class already
    if cls in self._present_classes:
        return

    # Make sure that no two Component classes have the same name, or we get problems
    # that are difficult to debug. Unless classes are defined interactively.
    # The modules of classes that are re-registered are re-defined. The base
    # class of such a component is assumed to be either unchanged or defined
    # in the same module. It can also happen that a class is registered for
    # which the module was defined earlier (e.g. ui.html). Such modules
    # are redefined as well.
    same_name = [c for c in self._present_classes if c.__name__ == cls.__name__]
    if same_name:
        is_interactive = self._app_name == '__default__'
        same_name.append(cls)
        is_dynamic_cls = all([c.__module__ == '__main__' for c in same_name])
        if not (is_interactive and is_dynamic_cls):
            raise RuntimeError('Cannot have multiple Component classes with '
                               'the same name unless using interactive session '
                               'and the classes are dynamically defined: %r'
                               % same_name)

    # Mark the class and the module as used
    logger.debug('Registering Component class %r' % cls.__name__)
    self._register_module(cls.__jsmodule__)

</t>
<t tx="ekr.20181031045138.293">def _register_module(self, mod_name):
    """ Register a module with the client, as well as its
    dependencies, and associated assests of the module and its
    dependencies. If the module was already defined, it is
    re-defined.
    """

    if (mod_name.startswith(('flexx.app', 'flexx.event')) and
                                            '.examples' not in mod_name):
        return  # these are part of flexx core assets

    modules = set()
    assets = []

    def collect_module_and_deps(mod):
        if mod.name.startswith(('flexx.app', 'flexx.event')):
            return  # these are part of flexx core assets
        if mod.name not in self._present_modules:
            self._present_modules.add(mod.name)
            for dep in mod.deps:
                if dep.startswith(('flexx.app', 'flexx.event')):
                    continue
                submod = self._store.modules[dep]
                collect_module_and_deps(submod)
            modules.add(mod)

    # Collect module and dependent modules that are not yet defined
    self._store.update_modules()  # Ensure up-to-date module definition
    mod = self._store.modules[mod_name]
    collect_module_and_deps(mod)
    f = lambda m: (m.name.startswith('__main__'), m.name)
    modules = solve_dependencies(sorted(modules, key=f))

    # Collect associated assets
    for mod in modules:
        for asset_name in self._store.get_associated_assets(mod.name):
            if asset_name not in self._present_assets:
                self._present_assets.add(asset_name)
                assets.append(self._store.get_asset(asset_name))
    # If the module was already defined and thus needs to be re-defined,
    # we only redefine *this* module, no deps and no assoctated assets.
    if not modules:
        modules.append(mod)
    # Collect CSS and JS assets
    for mod in modules:
        if mod.get_css().strip():
            assets.append(self._store.get_asset(mod.name + '.css'))
    for mod in modules:
        assets.append(self._store.get_asset(mod.name + '.js'))

    # Mark classes as used
    for mod in modules:
        for cls in mod.component_classes:
            self._present_classes.add(cls)

    # Push assets over the websocket. Note how this works fine with the
    # notebook because we turn ws commands into display(HTML()).
    # JS can be defined via eval() or by adding a &lt;script&gt; to the DOM.
    # The latter allows assets that do not use strict mode, but sourceURL
    # does not work on FF. So we only want to eval our own assets.
    for asset in assets:
        if asset.name in self._assets_to_ignore:
            continue
        logger.debug('Loading asset %s' % asset.name)
        # Determine command suffix. All our sources come in bundles,
        # for which we use eval because it makes sourceURL work on FF.
        # (It does not work in Chrome in either way.)
        suffix = asset.name.split('.')[-1].upper()
        if suffix == 'JS' and isinstance(asset, Bundle):
            suffix = 'JS-EVAL'
        self.send_command('DEFINE', suffix, asset.name, asset.to_string())

## Communication with the client

</t>
<t tx="ekr.20181031045138.294">def send_command(self, *command):
    """ Send a command to the other side. Commands consists of at least one
    argument (a string representing the type of command).
    """
    assert len(command) &gt;= 1
    if self._closing:
        pass
    elif self.status == self.STATUS.CONNECTED:
        self._ws.write_command(command)
    elif self.status == self.STATUS.PENDING:
        self._pending_commands.append(command)
    else:
        #raise RuntimeError('Cannot send commands; app is closed')
        logger.warn('Cannot send commands; app is closed')

</t>
<t tx="ekr.20181031045138.295">def _receive_command(self, command):
    """ Received a command from JS.
    """
    cmd = command[0]
    if cmd == 'EVALRESULT':
        self._eval_result[command[2]] = command[1]
    elif cmd == 'PRINT':
        print('JS:', command[1])
    elif cmd == 'INFO':
        logger.info('JS: ' + command[1])
    elif cmd == 'WARN':
        logger.warn('JS: ' + command[1])
    elif cmd == 'ERROR':
        logger.error('JS: ' + command[1] +
                     ' - stack trace in browser console (hit F12).')
    elif cmd == 'INVOKE':
        id, name, args = command[1:]
        ob = self.get_component_instance(id)
        if ob is None:
            if id not in self._dead_component_ids:
                t = 'Cannot invoke %s.%s; session does not know it (anymore).'
                logger.warn(t % (id, name))
        elif ob._disposed:
            pass  # JS probably send something before knowing the object was dead
        else:
            func = getattr(ob, name, None)
            if func:
                func(*args)
    elif cmd == 'PONG':
        self._receive_pong(command[1])
    elif cmd == 'INSTANTIATE':
        modulename, cname, id, args, kwargs = command[1:]
        # Maybe we still have the instance?
        c = self.get_component_instance(id)
        if c and not c._disposed:
            self.keep_alive(c)
            return
        # Try to find the class
        m, cls, e = None, None, 0
        if modulename in assetstore.modules:
            m = sys.modules[modulename]
            cls = getattr(m, cname, None)
            if cls is None:
                e = 1
            elif not (isinstance(cls, type) and issubclass(cls, JsComponent)):
                cls, e = None, 2
            elif cls not in AppComponentMeta.CLASSES:
                cls, e = None, 3
        if cls is None:
            raise RuntimeError('Cannot INSTANTIATE %s.%s (%i)' %
                               (modulename, cname, e))
        # Instantiate
        kwargs['flx_session'] = self
        kwargs['flx_id'] = id
        assert len(args) == 0
        c = cls(**kwargs)  # calls keep_alive via _register_component()
    elif cmd == 'DISPOSE':  # Gets send from local to proxy
        id = command[1]
        c = self.get_component_instance(id)
        if c and not c._disposed:  # no need to warn if component does not exist
            c._dispose()
        self.send_command('DISPOSE_ACK', command[1])
        self._component_instances.pop(id, None)  # Drop local ref now
    elif cmd == 'DISPOSE_ACK':  # Gets send from proxy to local
        self._component_instances.pop(command[1], None)
        self._dead_component_ids.discard(command[1])
    else:
        logger.error('Unknown command received from JS:\n%s' % command)

</t>
<t tx="ekr.20181031045138.296">def keep_alive(self, ob, iters=1):
    """ Keep an object alive for a certain amount of time, expressed
    in Python-JS ping roundtrips. This is intended for making JsComponent
    (i.e. proxy components) survice the time between instantiation
    triggered from JS and their attachement to a property, though any type
    of object can be given.
    """
    ping_to_schedule_at = self._ping_counter + iters
    el = self._get_ping_call_list(ping_to_schedule_at)
    el[1][id(ob)] = ob  # add to dict of objects to keep alive

</t>
<t tx="ekr.20181031045138.297">def call_after_roundtrip(self, callback, *args):
    """ A variant of ``call_soon()`` that calls a callback after
    a py-js roundrip. This can be convenient to delay an action until
    after other things have settled down.
    """
    # The ping_counter represents the ping count that is underway.
    # Since we want at least a full ping, we want one count further.
    ping_to_schedule_at = self._ping_counter + 1
    el = self._get_ping_call_list(ping_to_schedule_at)
    el.append((callback, args))

async def co_roundtrip(self):
    """ Coroutine to wait for one Py-JS-Py roundtrip.
    """
    count = 0
    def up():
        nonlocal count
        count += 1
    self.call_after_roundtrip(up)
    while count &lt; 1:
        await asyncio.sleep(0.02)

async def co_eval(self, js):
    """ Coroutine to evaluate JS in the client, wait for the result,
    and then return it. It is recomended to use this method only
    for testing purposes.
    """
    id = self._eval_count
    self._eval_count += 1
    self.send_command('EVALANDRETURN', js, id)
    while id not in self._eval_result:
        await asyncio.sleep(0.2)
    return self._eval_result.pop(id)

</t>
<t tx="ekr.20181031045138.298">def _get_ping_call_list(self, ping_count):
    """ Get an element from _ping_call for the specified ping_count.
    The element is a list [ping_count, {objects}, *(callback, args)]
    """
    # No pending ping_calls?
    if len(self._ping_calls) == 0:
        # Start pinging
        send_ping_later(self)
        # Append element
        el = [ping_count, {}]
        self._ping_calls.append(el)
        return el

    # Try to find existing element, or insert it
    for i in reversed(range(len(self._ping_calls))):
        el = self._ping_calls[i]
        if el[0] == ping_count:
            return el
        elif el[0] &lt; ping_count:
            el = [ping_count, {}]
            self._ping_calls.insert(i + 1, el)
            return el
    else:
        el = [ping_count, {}]
        self._ping_calls.insert(0, el)
        return el

</t>
<t tx="ekr.20181031045138.299">def _receive_pong(self, count):
    # Process ping calls
    while len(self._ping_calls) &gt; 0 and self._ping_calls[0][0] &lt;= count:
        _, objects, *callbacks = self._ping_calls.pop(0)
        objects.clear()
        del objects
        for callback, args in callbacks:
            asyncio.get_event_loop().call_soon(callback, *args)
    # Continue pinging?
    if len(self._ping_calls) &gt; 0:
        send_ping_later(self)

</t>
<t tx="ekr.20181031045138.30">def _parse_options(self, compression=0, use_checksum=False, float64=True):

    # Validate compression
    if isinstance(compression, str):
        m = {'no': 0, 'zlib': 1, 'bz2': 2}
        compression = m.get(compression.lower(), compression)
    if compression not in (0, 1, 2):
        raise TypeError('Compression must be 0, 1, 2, '
                        '"no", "zlib", or "bz2"')
    self._compression = compression

    # Other encoding args
    self._use_checksum = bool(use_checksum)
    self._float64 = bool(float64)

</t>
<t tx="ekr.20181031045138.300">def send_ping_later(session):
    # This is to prevent the prevention of the session from being discarded due
    # to a ref lingering in an asyncio loop.
    def x(weaksession):
        s = weaksession()
        if s is not None and s.status &gt; 0:
            s._ping_counter += 1
            s.send_command('PING', s._ping_counter)
    # asyncio.get_event_loop().call_soon(x, weakref.ref(session))
    asyncio.get_event_loop().call_later(0.01, x, weakref.ref(session))


## Functions to get page
# These could be methods, but are only for internal use

</t>
<t tx="ekr.20181031045138.301">def get_page(session):
    """ Get the string for the HTML page to render this session's app.
    Not a lot; all other JS and CSS assets are pushed over the websocket.
    """
    css_assets = [assetstore.get_asset('reset.css')]
    js_assets = [assetstore.get_asset('flexx-core.js')]
    return _get_page(session, js_assets, css_assets, 3, False)


</t>
<t tx="ekr.20181031045138.302">def get_page_for_export(session, commands, link=0):
    """ Get the string for an exported HTML page (to run without a server).
    In this case, there is no websocket to push JS/CSS assets over; these
    need to be included inside or alongside the main html page.
    """
    # This function basically collects all assets that the session needs,
    # creates a special -export.js asset that executes the given commands,
    # and puts it al together using _get_page().

    # We start as a normal page ...
    css_assets = [assetstore.get_asset('reset.css')]
    js_assets = [assetstore.get_asset('flexx-core.js')]

    # Get all the used modules
    modules = [assetstore.modules[name] for name in session.present_modules]
    f = lambda m: (m.name.startswith('__main__'), m.name)
    modules = solve_dependencies(sorted(modules, key=f))
    # First the associated assets
    asset_names = set()
    for mod in modules:
        for asset_name in assetstore.get_associated_assets(mod.name):
            if asset_name not in asset_names:
                asset_names.add(asset_name)
                asset = assetstore.get_asset(asset_name)
                if asset.name.lower().endswith('.js'):
                    js_assets.append(asset)
                else:
                    css_assets.append(asset)
    # Then the modules themselves
    for mod in modules:
        if mod.get_css().strip():
            css_assets.append(assetstore.get_asset(mod.name + '.css'))
    for mod in modules:
        js_assets.append(assetstore.get_asset(mod.name + '.js'))

    # Create asset for launching the app (commands that normally get send
    # over the websocket)
    lines = []
    lines.append('flexx.is_exported = true;\n')
    lines.append('flexx.run_exported_app = function () {')
    lines.append('    var commands_b64 = [')
    for command in commands:
        if command[0] != 'DEFINE':
            command_str = base64.encodebytes(serializer.encode(command)).decode()
            lines.append('        "' + command_str.replace('\n', '') + '",')
    lines.append('        ];')
    lines.append('    bb64 =  flexx.require("bb64");')
    lines.append('    for (var i=0; i&lt;commands_b64.length; i++) {')
    lines.append('        var command = flexx.serializer.decode('
                                            'bb64.decode(commands_b64[i]));')
    lines.append('        flexx.s1._receive_command(command);')
    lines.append('    }\n};\n')
    # Create a session asset for it, "-export.js" is always embedded
    export_asset = Asset('flexx-export.js', '\n'.join(lines))
    js_assets.append(export_asset)

    # Combine it all
    return _get_page(session, js_assets, css_assets, link, True)


</t>
<t tx="ekr.20181031045138.303">def _get_page(session, js_assets, css_assets, link, export):
    """ Compose index page. Depending on the value of link and the types
    of assets, the assets are either embedded or linked.
    """
    pre_path = 'flexx/assets' if export else '/flexx/assets'  # relative / abs

    codes = []

    for assets in [css_assets, js_assets]:
        for asset in assets:
            if link in (0, 1):
                html = asset.to_html('{}', link)
            else:
                if asset.name.endswith(('-info.js', '-export.js')):
                    # Special case, is always embedded, see get_page_for_export()
                    html = asset.to_html('', 0)
                else:
                    html = asset.to_html(pre_path + '/shared/{}', link)
            codes.append(html)
            if export and assets is js_assets:
                codes.append('&lt;script&gt;window.flexx.spin();&lt;/script&gt;')
        codes.append('')  # whitespace between css and js assets

    codes.append('&lt;script&gt;flexx.create_session("%s", "%s");&lt;/script&gt;\n' %
                 (session.app_name, session.id))

    src = INDEX
    if link in (0, 1):
        asset_names = [a.name for a in css_assets + js_assets]
        toc = '&lt;!-- Contents:\n\n- ' + '\n- '.join(asset_names) + '\n\n--&gt;'
        codes.insert(0, toc)
        src = src.replace('ASSET-HOOK', '\n\n\n'.join(codes))
    else:
        src = src.replace('ASSET-HOOK', '\n'.join(codes))

    return src
</t>
<t tx="ekr.20181031045138.304">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.305">"""
Serve web page and handle web sockets using Tornado.
"""

import json
import time
import asyncio
import socket
import mimetypes
import traceback
import threading
from urllib.parse import urlparse
# from concurrent.futures import ThreadPoolExecutor

import tornado
from tornado import gen, netutil
from tornado.web import Application, RequestHandler
from tornado.ioloop import IOLoop
from tornado.websocket import WebSocketHandler, WebSocketClosedError
from tornado.httpserver import HTTPServer
from tornado.platform.asyncio import AsyncIOMainLoop

from ._app import manager
from ._session import get_page
from ._server import AbstractServer
from ._assetstore import assets
from ._clientcore import serializer

from . import logger
from .. import config

if tornado.version_info &lt; (4, ):
    raise RuntimeError('Flexx requires Tornado v4.0 or higher.')

# todo: generalize -&gt; Make Tornado mnore of an implementation detail.
# So we can use e.g. https://github.com/aaugustin/websockets

# todo: threading, or even multi-process
#executor = ThreadPoolExecutor(4)

IMPORT_TIME = time.time()


</t>
<t tx="ekr.20181031045138.306">def is_main_thread():
    """ Get whether this is the main thread. """
    return isinstance(threading.current_thread(), threading._MainThread)


</t>
<t tx="ekr.20181031045138.307">class TornadoServer(AbstractServer):
    """ Flexx Server implemented in Tornado.
    """

    @others
</t>
<t tx="ekr.20181031045138.308">def __init__(self, *args, **kwargs):
    self._app = None
    self._server = None
    super().__init__(*args, **kwargs)

</t>
<t tx="ekr.20181031045138.309">def _open(self, host, port, **kwargs):
    # Note: does not get called if host is False. That way we can
    # run Flexx in e.g. JLab's application.

    # Hook Tornado up with asyncio. Flexx' BaseServer makes sure
    # that the correct asyncio event loop is current (for this thread).
    # http://www.tornadoweb.org/en/stable/asyncio.html
    # todo: Since Tornado v5.0 asyncio is autom used, deprecating AsyncIOMainLoop
    self._io_loop = AsyncIOMainLoop()
    # I am sorry for this hack, but Tornado wont work otherwise :(
    # I wonder how long it will take before this will bite me back. I guess
    # we will be alright as long as there is no other Tornado stuff going on.
    IOLoop._current.instance = None
    self._io_loop.make_current()

    # handle ssl, wether from configuration or given args
    if config.ssl_certfile:
        if 'ssl_options' not in kwargs:
            kwargs['ssl_options'] = {}
        if 'certfile' not in kwargs['ssl_options']:
            kwargs['ssl_options']['certfile'] = config.ssl_certfile

    if config.ssl_keyfile:
        if 'ssl_options' not in kwargs:
            kwargs['ssl_options'] = {}
        if 'keyfile' not in kwargs['ssl_options']:
            kwargs['ssl_options']['keyfile'] = config.ssl_keyfile

    if config.tornado_debug:
        app_kwargs = dict(debug=True)
    else:
        app_kwargs = dict()
    # Create tornado application
    self._app = Application([(r"/flexx/ws/(.*)", WSHandler),
                             (r"/flexx/(.*)", MainHandler),
                             (r"/(.*)", AppHandler), ], **app_kwargs)
    self._app._io_loop = self._io_loop
    # Create tornado server, bound to our own ioloop
    if tornado.version_info &lt; (5, ):
        kwargs['io_loop'] = self._io_loop
    self._server = HTTPServer(self._app, **kwargs)

    # Start server (find free port number if port not given)
    if port:
        # Turn port into int, use hashed port number if a string was given
        try:
            port = int(port)
        except ValueError:
            port = port_hash(port)
        self._server.listen(port, host)
    else:
        # Try N ports in a repeatable range (easier, browser history, etc.)
        prefered_port = port_hash('Flexx')
        for i in range(8):
            port = prefered_port + i
            try:
                self._server.listen(port, host)
                break
            except (OSError, IOError):
                pass  # address already in use
        else:
            # Ok, let Tornado figure out a port
            [sock] = netutil.bind_sockets(None, host, family=socket.AF_INET)
            self._server.add_sockets([sock])
            port = sock.getsockname()[1]

    # Notify address, so its easy to e.g. copy and paste in the browser
    self._serving = self._app._flexx_serving = host, port
    proto = 'http'
    if 'ssl_options' in kwargs:
        proto = 'https'
    logger.info('Serving apps at %s://%s:%i/' % (proto, host, port))

</t>
<t tx="ekr.20181031045138.31">def add_extension(self, extension_class):
    """ Add an extension to this serializer instance, which must be
    a subclass of Extension. Can be used as a decorator.
    """
    # Check class
    if not (isinstance(extension_class, type) and
            issubclass(extension_class, Extension)):
        raise TypeError('add_extension() expects a Extension class.')
    extension = extension_class()

    # Get name
    name = extension.name
    if not isinstance(name, str):
        raise TypeError('Extension name must be str.')
    if len(name) == 0 or len(name) &gt; 250:
        raise NameError('Extension names must be nonempty and shorter '
                        'than 251 chars.')
    if name in self._extensions:
        logger.warn('BSDF warning: overwriting extension "%s", '
                    'consider removing first' % name)

    # Get classes
    cls = extension.cls
    if not cls:
        clss = []
    elif isinstance(cls, (tuple, list)):
        clss = cls
    else:
        clss = [cls]
    for cls in clss:
        if not isinstance(cls, type):
            raise TypeError('Extension classes must be types.')

    # Store
    for cls in clss:
        self._extensions_by_cls[cls] = name, extension.encode
    self._extensions[name] = extension
    return extension_class

</t>
<t tx="ekr.20181031045138.310">def _close(self):
    self._server.stop()

</t>
<t tx="ekr.20181031045138.311">@property
def app(self):
    """ The Tornado Application object being used."""
    return self._app

</t>
<t tx="ekr.20181031045138.312">@property
def server(self):
    """ The Tornado HttpServer object being used."""
    return self._server

</t>
<t tx="ekr.20181031045138.313">@property
def protocol(self):
    """ Get a string representing served protocol."""
    if self._server.ssl_options is not None:
        return 'https'

    return 'http'

</t>
<t tx="ekr.20181031045138.314">def port_hash(name):
    """ Given a string, returns a port number between 49152 and 65535

    This range (of 2**14 posibilities) is the range for dynamic and/or
    private ports (ephemeral ports) specified by iana.org. The algorithm
    is deterministic.
    """
    fac = 0xd2d84a61
    val = 0
    for c in name:
        val += (val &gt;&gt; 3) + (ord(c) * fac)
    val += (val &gt;&gt; 3) + (len(name) * fac)
    return 49152 + (val % 2**14)


</t>
<t tx="ekr.20181031045138.315">class FlexxHandler(RequestHandler):
    """ Base class for Flexx' Tornado request handlers.
    """

    @others
</t>
<t tx="ekr.20181031045138.316">def initialize(self, **kwargs):
    # kwargs == dict set as third arg in url spec
    pass

</t>
<t tx="ekr.20181031045138.317">def write_error(self, status_code, **kwargs):
    if status_code == 404:  # does not work?
        self.write('flexx.ui wants you to connect to root (404)')
    else:
        if config.browser_stacktrace:
            msg = 'Flexx.ui encountered an error: &lt;br /&gt;&lt;br /&gt;'
            try:  # try providing a useful message; tough luck if this fails
                type, value, tb = kwargs['exc_info']
                tb_str = ''.join(traceback.format_tb(tb))
                msg += '&lt;pre&gt;%s\n%s&lt;/pre&gt;' % (tb_str, str(value))
            except Exception:
                pass
            self.write(msg)
        super().write_error(status_code, **kwargs)

</t>
<t tx="ekr.20181031045138.318">def on_finish(self):
    pass


</t>
<t tx="ekr.20181031045138.319">class AppHandler(FlexxHandler):
    """ Handler for http requests to get apps.
    """

    @others
</t>
<t tx="ekr.20181031045138.32">def remove_extension(self, name):
    """ Remove a converted by its unique name.
    """
    if not isinstance(name, str):
        raise TypeError('Extension name must be str.')
    if name in self._extensions:
        self._extensions.pop(name)
    for cls in list(self._extensions_by_cls.keys()):
        if self._extensions_by_cls[cls][0] == name:
            self._extensions_by_cls.pop(cls)

</t>
<t tx="ekr.20181031045138.320">@gen.coroutine
def get(self, full_path):

    logger.debug('Incoming request at %r' % full_path)

    ok_app_names = '__main__', '__default__', '__index__'
    parts = [p for p in full_path.split('/') if p]

    # Try getting regular app name
    # Note: invalid part[0] can mean its a path relative to the main app
    app_name = None
    path = '/'.join(parts)
    if parts:
        if path.lower() == 'flexx':  # reserved, redirect to other handler
            return self.redirect('/flexx/')
        if parts[0] in ok_app_names or manager.has_app_name(parts[0]):
            app_name = parts[0]
            path = '/'.join(parts[1:])

    # If it does not look like an app, it might be that the request is for
    # the main app. The main app can have sub-paths, but lets try to filter
    # out cases that might make Flexx unnecessarily instantiate an app.
    # In particular "favicon.ico" that browsers request by default (#385).
    if app_name is None:
        if len(parts) == 1 and '.' in full_path:
            return self.redirect('/flexx/data/' + full_path)
        # If we did not return ... assume this is the default app
        app_name = '__main__'

    # Try harder to produce an app
    if app_name == '__main__':
        app_name = manager.has_app_name('__main__')
    elif '/' not in full_path:
        return self.redirect('/%s/' % app_name)  # ensure slash behind name

    # Maybe the user wants an index? Otherwise error.
    if not app_name:
        if not parts:
            app_name = '__index__'
        else:
            name = parts[0] if parts else '__main__'
            return self.write('No app "%s" is currently hosted.' % name)

    # We now have:
    # * app_name: name of the app, must be a valid identifier, names
    #   with underscores are reserved for special things like assets,
    #   commands, etc.
    # * path: part (possibly with slashes) after app_name
    if app_name == '__index__':
        self._get_index(app_name, path)  # Index page
    else:
        self._get_app(app_name, path)  # An actual app!

</t>
<t tx="ekr.20181031045138.321">def _get_index(self, app_name, path):
    if path:
        return self.redirect('/flexx/__index__')
    all_apps = ['&lt;li&gt;&lt;a href="%s/"&gt;%s&lt;/a&gt;&lt;/li&gt;' % (name, name) for name in
                manager.get_app_names()]
    the_list = '&lt;ul&gt;%s&lt;/ul&gt;' % ''.join(all_apps) if all_apps else 'no apps'
    self.write('Index of available apps: ' + the_list)

</t>
<t tx="ekr.20181031045138.322">def _get_app(self, app_name, path):
    # Allow serving data/assets relative to app so that data can use
    # relative paths just like exported apps.
    if path.startswith(('flexx/data/', 'flexx/assets/')):
        return self.redirect('/' + path)

    # Get case-corrected app name if the app is known
    correct_app_name = manager.has_app_name(app_name)

    # Error or redirect if app name is not right
    if not correct_app_name:
        return self.write('No app "%s" is currently hosted.' % app_name)
    if correct_app_name != app_name:
        return self.redirect('/%s/%s' % (correct_app_name, path))

    # Should we bind this app instance to a pre-created session?
    session_id = self.get_argument('session_id', '')

    if session_id:
        # If session_id matches a pending app, use that session
        session = manager.get_session_by_id(session_id)
        if session and session.status == session.STATUS.PENDING:
            self.write(get_page(session).encode())
        else:
            self.redirect('/%s/' % app_name)  # redirect for normal serve
    else:
        # Create session - websocket will connect to it via session_id
        session = manager.create_session(app_name, request=self.request)
        self.write(get_page(session).encode())


</t>
<t tx="ekr.20181031045138.323">class MainHandler(RequestHandler):
    """ Handler for assets, commands, etc. Basically, everything for
    which te path is clear.
    """

    @others
</t>
<t tx="ekr.20181031045138.324">def _guess_mime_type(self, fname):
    """ Set the mimetype if we can guess it from the filename.
    """
    guess = mimetypes.guess_type(fname)[0]
    if guess:
        self.set_header("Content-Type", guess)

</t>
<t tx="ekr.20181031045138.325">@gen.coroutine
def get(self, full_path):

    logger.debug('Incoming request at %s' % full_path)

    # Analyze path to derive components
    # Note: invalid app name can mean its a path relative to the main app
    parts = [p for p in full_path.split('/') if p]
    if not parts:
        return self.write('Root url for flexx: assets, assetview, data, cmd')
    selector = parts[0]
    path = '/'.join(parts[1:])

    if selector in ('assets', 'assetview', 'data'):
        self._get_asset(selector, path)  # JS, CSS, or data
    elif selector == 'info':
        self._get_info(selector, path)
    elif selector == 'cmd':
        self._get_cmd(selector, path)  # Execute (or ignore) command
    else:
        return self.write('Invalid url path "%s".' % full_path)

</t>
<t tx="ekr.20181031045138.326">def _get_asset(self, selector, path):

    # Get session id and filename
    session_id, _, filename = path.partition('/')
    session_id = '' if session_id == 'shared' else session_id

    # Get asset provider: store or session
    asset_provider = assets
    if session_id and selector != 'data':
        return self.write('Only supports shared assets, not ' % filename)
    elif session_id:
        asset_provider = manager.get_session_by_id(session_id)

    # Checks
    if asset_provider is None:
        return self.write('Invalid session %r' % session_id)
    if not filename:
        return self.write('Root dir for %s/%s' % (selector, path))

    if selector == 'assets':

        # If colon: request for a view of an asset at a certain line
        if '.js:' in filename or '.css:' in filename or filename[0] == ':':
            fname, where = filename.split(':')[:2]
            return self.redirect('/flexx/assetview/%s/%s#L%s' %
                (session_id or 'shared', fname.replace('/:', ':'), where))

        # Retrieve asset
        try:
            res = asset_provider.get_asset(filename)
        except KeyError:
            self.write('Could not load asset %r' % filename)
        else:
            self._guess_mime_type(filename)
            self.write(res.to_string())

    elif selector == 'assetview':

        # Retrieve asset
        try:
            res = asset_provider.get_asset(filename)
        except KeyError:
            return self.write('Could not load asset %r' % filename)
        else:
            res = res.to_string()

        # Build HTML page
        style = ('pre {display:block; width: 100%; padding:0; margin:0;} '
                'a {text-decoration: none; color: #000; background: #ddd;} '
                ':target {background:#ada;} ')
        lines = ['&lt;html&gt;&lt;head&gt;&lt;style&gt;%s&lt;/style&gt;&lt;/head&gt;&lt;body&gt;' % style]
        for i, line in enumerate(res.splitlines()):
            table = {ord('&amp;'): '&amp;amp;', ord('&lt;'): '&amp;lt;', ord('&gt;'): '&amp;gt;'}
            line = line.translate(table).replace('\t', '    ')
            lines.append('&lt;pre id="L%i"&gt;&lt;a href="#L%i"&gt;%s&lt;/a&gt;  %s&lt;/pre&gt;' %
                         (i+1, i+1, str(i+1).rjust(4).replace(' ', '&amp;nbsp'), line))
        lines.append('&lt;/body&gt;&lt;/html&gt;')
        return self.write('\n'.join(lines))

    elif selector == 'data':
        # todo: can/do we async write in case the data is large?

        # Retrieve data
        res = asset_provider.get_data(filename)
        if res is None:
            return self.send_error(404)
        else:
            self._guess_mime_type(filename)  # so that images show up
            return self.write(res)

    else:
        raise RuntimeError('Invalid asset type %r' % selector)

</t>
<t tx="ekr.20181031045138.327">def _get_info(self, selector, info):
    """ Provide some rudimentary information about the server.
    Note that this is publicly accesible.
    """
    runtime = time.time() - IMPORT_TIME
    napps = len(manager.get_app_names())
    nsessions = sum([len(manager.get_connections(x))
                     for x in manager.get_app_names()])

    info = []
    info.append('Runtime: %1.1f s' % runtime)
    info.append('Number of apps: %i' % napps)
    info.append('Number of sessions: %i' % nsessions)

    info = '\n'.join(['&lt;li&gt;%s&lt;/li&gt;' % i for i in info])
    self.write('&lt;ul&gt;' + info + '&lt;/ul&gt;')

</t>
<t tx="ekr.20181031045138.328">def _get_cmd(self, selector, path):
    """ Allow control of the server using http, but only from localhost!
    """
    if not self.request.host.startswith('localhost:'):
        self.write('403')
        return

    if not path:
        self.write('No command given')
    elif path == 'info':
        info = dict(address=self.application._flexx_serving,
                    app_names=manager.get_app_names(),
                    nsessions=sum([len(manager.get_connections(x))
                                    for x in manager.get_app_names()]),
                    )
        self.write(json.dumps(info))
    elif path == 'stop':
        asyncio.get_event_loop().stop()
        # loop = IOLoop.current()
        # loop.add_callback(loop.stop)
        self.write("Stopping event loop.")
    else:
        self.write('unknown command %r' % path)


</t>
<t tx="ekr.20181031045138.329">class MessageCounter:
    """ Simple class to count incoming messages and periodically log
    the number of messages per second.
    """

    @others
</t>
<t tx="ekr.20181031045138.33">def _encode(self, f, value, ext_id):
    """ Main encoder function.
    """

    x = encode_type_id

    if value is None:
        f.write(x(b'v', ext_id))  # V for void
    elif value is True:
        f.write(x(b'y', ext_id))  # Y for yes
    elif value is False:
        f.write(x(b'n', ext_id))  # N for no
    elif isinstance(value, int):
        if -32768 &lt;= value &lt;= 32767:
            f.write(x(b'h', ext_id) + spack('h', value))  # H for ...
        else:
            f.write(x(b'i', ext_id) + spack('&lt;q', value))  # I for int
    elif isinstance(value, float):
        if self._float64:
            f.write(x(b'd', ext_id) + spack('&lt;d', value))  # D for double
        else:
            f.write(x(b'f', ext_id) + spack('&lt;f', value))  # f for float
    elif isinstance(value, str):
        bb = value.encode('UTF-8')
        f.write(x(b's', ext_id) + lencode(len(bb)))  # S for str
        f.write(bb)
    elif isinstance(value, (list, tuple)):
        f.write(x(b'l', ext_id) + lencode(len(value)))  # L for list
        for v in value:
            self._encode(f, v, None)
    elif isinstance(value, dict):
        f.write(x(b'm', ext_id) + lencode(len(value)))  # M for mapping
        for key, v in value.items():
            assert isinstance(key, str)
            name_b = key.encode('UTF-8')
            f.write(lencode(len(name_b)))
            f.write(name_b)
            self._encode(f, v, None)
    elif isinstance(value, bytes):
        f.write(x(b'b', ext_id))  # B for blob
        # Compress
        compression = self._compression
        if compression == 0:
            compressed = value
        elif compression == 1:
            compressed = zlib.compress(value, 9)
        elif compression == 2:
            compressed = bz2.compress(value, 9)
        else:
            assert False, 'Unknown compression identifier'
        # Get sizes
        data_size = len(value)
        used_size = len(compressed)
        extra_size = 0
        allocated_size = used_size + extra_size
        # Write sizes - write at least in a size that allows resizing
        if allocated_size &lt;= 250 and compression == 0:
            f.write(spack('&lt;B', allocated_size))
            f.write(spack('&lt;B', used_size))
            f.write(lencode(data_size))
        else:
            f.write(spack('&lt;BQ', 253, allocated_size))
            f.write(spack('&lt;BQ', 253, used_size))
            f.write(spack('&lt;BQ', 253, data_size))
        # Compression and checksum
        f.write(spack('B', compression))
        if self._use_checksum:
            f.write(b'\xff' + hashlib.md5(compressed).digest())
        else:
            f.write(b'\x00')
        # Byte alignment (only necessary for uncompressed data)
        if compression == 0:
            alignment = 8 - (f.tell() + 1) % 8  # +1 for the byte to write
            f.write(spack('&lt;B', alignment))  # padding for byte alignment
            f.write(b'\x00' * alignment)
        else:
            f.write(spack('&lt;B', 0))
        # The actual data and extra space
        f.write(compressed)
        f.write(b'\x00' * (allocated_size - used_size))
    else:
        if ext_id is not None:
            raise ValueError(
                'Extension %s wronfully encodes object to another '
                'extension object (though it may encode to a list/dict '
                'that contains other extension objects).' % ext_id)
        # Try if the value is of a type we know
        ex = self._extensions_by_cls.get(value.__class__, None)
        # Maybe its a subclass of a type we know
        if ex is None:
            for name, c in self._extensions.items():
                if c.match(self, value):
                    ex = name, c.encode
                    break
            else:
                ex = None
        # Success or fail
        if ex is not None:
            ext_id2, extension_encode = ex
            self._encode(f, extension_encode(self, value), ext_id2)
        else:
            t = ('Class %r is not a valid base BSDF type, nor is it '
                 'handled by an extension.')
            raise TypeError(t % value.__class__.__name__)

</t>
<t tx="ekr.20181031045138.330">def __init__(self):
    self._collect_interval = 0.2  # period over which to collect messages
    self._notify_interval = 3.0  # period on which to log the mps
    self._window_interval = 4.0  # size of sliding window

    self._mps = [(time.time(), 0)]  # tuples of (time, count)
    self._collect_count = 0
    self._collect_stoptime = 0

    self._stop = False
    self._notify()

</t>
<t tx="ekr.20181031045138.331">def trigger(self):
    t = time.time()
    if t &lt; self._collect_stoptime:
        self._collect_count += 1
    else:
        self._mps.append((self._collect_stoptime, self._collect_count))
        self._collect_count = 1
        self._collect_stoptime = t + self._collect_interval

</t>
<t tx="ekr.20181031045138.332">def _notify(self):
    mintime = time.time() - self._window_interval
    self._mps = [x for x in self._mps if x[0] &gt; mintime]
    if self._mps:
        n = sum([x[1] for x in self._mps])
        T = self._mps[-1][0] - self._mps[0][0] + self._collect_interval
    else:
        n, T = 0, self._collect_interval
    logger.debug('Websocket messages per second: %1.1f' % (n / T))

    if not self._stop:
        loop = asyncio.get_event_loop()
        loop.call_later(self._notify_interval, self._notify)

</t>
<t tx="ekr.20181031045138.333">def stop(self):
    self._stop = True


</t>
<t tx="ekr.20181031045138.334">class WSHandler(WebSocketHandler):
    """ Handler for websocket.
    """

    # https://tools.ietf.org/html/rfc6455#section-7.4.1
    known_reasons = {1000: 'client done',
                     1001: 'client closed',
                     1002: 'protocol error',
                     1003: 'could not accept data',
                     }

    # --- callbacks

    @others
</t>
<t tx="ekr.20181031045138.335">def open(self, path=None):
    """ Called when a new connection is made.
    """
    if not hasattr(self, 'close_code'):  # old version of Tornado?
        self.close_code, self.close_reason = None, None

    self._session = None
    self._mps_counter = MessageCounter()

    # Don't collect messages to send them more efficiently, just send asap
    # self.set_nodelay(True)

    if isinstance(path, bytes):
        path = path.decode()
    self.app_name = path.strip('/')

    logger.debug('New websocket connection %s' % path)
    if manager.has_app_name(self.app_name):
        self.application._io_loop.spawn_callback(self.pinger1)
    else:
        self.close(1003, "Could not associate socket with an app.")

# todo: @gen.coroutine?
</t>
<t tx="ekr.20181031045138.336">def on_message(self, message):
    """ Called when a new message is received from JS.

    This handles one message per event loop iteration.

    We now have a very basic protocol for receiving messages,
    we should at some point define a real formalized protocol.
    """
    self._mps_counter.trigger()

    try:
        command = serializer.decode(message)
    except Exception as err:
        err.skip_tb = 1
        logger.exception(err)

    self._pongtime = time.time()
    if self._session is None:
        if command[0] == 'HI_FLEXX':
            session_id = command[1]
            try:
                self._session = manager.connect_client(self, self.app_name,
                                                       session_id,
                                                       cookies=self.cookies)
            except Exception as err:
                self.close(1003, "Could not launch app: %r" % err)
                raise
    else:
        try:
            self._session._receive_command(command)
        except Exception as err:
            err.skip_tb = 1
            logger.exception(err)

</t>
<t tx="ekr.20181031045138.337">def on_close(self):
    """ Called when the connection is closed.
    """
    self.close_code = code = self.close_code or 0
    reason = self.close_reason or self.known_reasons.get(code, '')
    logger.debug('Websocket closed: %s (%i)' % (reason, code))
    self._mps_counter.stop()
    if self._session is not None:
        manager.disconnect_client(self._session)
        self._session = None  # Allow cleaning up

</t>
<t tx="ekr.20181031045138.338">@gen.coroutine
def pinger1(self):
    """ Check for timeouts. This helps remove lingering false connections.

    This uses the websocket's native ping-ping mechanism. On the
    browser side, pongs work even if JS is busy. On the Python side
    we perform a check whether we were really waiting or whether Python
    was too busy to detect the pong.
    """
    self._pongtime = time.time()
    self._pingtime = pingtime = 0

    while self.close_code is None:
        dt = config.ws_timeout

        # Ping, but don't spam
        if pingtime &lt;= self._pongtime:
            self.ping(b'x')
            pingtime = self._pingtime = time.time()
            iters_since_ping = 0

        yield gen.sleep(dt / 5)

        # Check pong status
        iters_since_ping += 1
        if iters_since_ping &lt; 5:
            pass  # we might have missed the pong
        elif time.time() - self._pongtime &gt; dt:
            # Delay is so big that connection probably dropped.
            # Note that a browser sends a pong even if JS is busy
            logger.warn('Closing connection due to lack of pong')
            self.close(1000, 'Conection timed out (no pong).')
            return

</t>
<t tx="ekr.20181031045138.339">def on_pong(self, data):
    """ Implement the ws's on_pong() method. Called when our ping
    is returned by the browser.
    """
    self._pongtime = time.time()

# --- methods

</t>
<t tx="ekr.20181031045138.34">def _decode(self, f):
    """ Main decoder function.
    """

    # Get value
    char = f.read(1)
    c = char.lower()

    # Conversion (uppercase value identifiers signify converted values)
    if not char:
        raise EOFError()
    elif char != c:
        n = strunpack('&lt;B', f.read(1))[0]
        # if n == 253: n = strunpack('&lt;Q', f.read(8))[0]  # noqa - noneed
        ext_id = f.read(n).decode('UTF-8')
    else:
        ext_id = None

    if c == b'v':
        value = None
    elif c == b'y':
        value = True
    elif c == b'n':
        value = False
    elif c == b'h':
        value = strunpack('&lt;h', f.read(2))[0]
    elif c == b'i':
        value = strunpack('&lt;q', f.read(8))[0]
    elif c == b'f':
        value = strunpack('&lt;f', f.read(4))[0]
    elif c == b'd':
        value = strunpack('&lt;d', f.read(8))[0]
    elif c == b's':
        n_s = strunpack('&lt;B', f.read(1))[0]
        if n_s == 253: n_s = strunpack('&lt;Q', f.read(8))[0]  # noqa
        value = f.read(n_s).decode('UTF-8')
    elif c == b'l':
        n = strunpack('&lt;B', f.read(1))[0]
        if n &gt;= 254:
            # Streaming
            closed = n == 254
            n = strunpack('&lt;Q', f.read(8))[0]
            if closed:
                value = [self._decode(f) for i in range(n)]
            else:
                value = []
                try:
                    while True:
                        value.append(self._decode(f))
                except EOFError:
                    pass
        else:
            # Normal
            if n == 253: n = strunpack('&lt;Q', f.read(8))[0]  # noqa
            value = [self._decode(f) for i in range(n)]
    elif c == b'm':
        value = dict()
        n = strunpack('&lt;B', f.read(1))[0]
        if n == 253: n = strunpack('&lt;Q', f.read(8))[0]  # noqa
        for i in range(n):
            n_name = strunpack('&lt;B', f.read(1))[0]
            if n_name == 253: n_name = strunpack('&lt;Q', f.read(8))[0]  # noqa
            assert n_name &gt; 0
            name = f.read(n_name).decode('UTF-8')
            value[name] = self._decode(f)
    elif c == b'b':
        # Read blob header data (5 to 42 bytes)
        # Size
        allocated_size = strunpack('&lt;B', f.read(1))[0]
        if allocated_size == 253: allocated_size = strunpack('&lt;Q', f.read(8))[0]  # noqa
        used_size = strunpack('&lt;B', f.read(1))[0]
        if used_size == 253: used_size = strunpack('&lt;Q', f.read(8))[0]  # noqa
        data_size = strunpack('&lt;B', f.read(1))[0]
        if data_size == 253: data_size = strunpack('&lt;Q', f.read(8))[0]  # noqa
        # Compression and checksum
        compression = strunpack('&lt;B', f.read(1))[0]
        has_checksum = strunpack('&lt;B', f.read(1))[0]
        if has_checksum:
            checksum = f.read(16)  # noqa - not used yet
        # Skip alignment
        alignment = strunpack('&lt;B', f.read(1))[0]
        f.read(alignment)
        # Get data
        compressed = f.read(used_size)
        # Skip remaining space
        f.read(allocated_size - used_size)
        # Decompress
        if compression == 0:
            value = compressed
        elif compression == 1:
            value = zlib.decompress(compressed)
        elif compression == 2:
            value = bz2.decompress(compressed)
        else:
            raise RuntimeError('Invalid compression %i' % compression)
    else:
        raise RuntimeError('Parse error %r' % char)

    # Convert value if we have a nextension for it
    if ext_id is not None:
        extension = self._extensions.get(ext_id, None)
        if extension is not None:
            value = extension.decode(self, value)
        else:
            logger.warn('BSDF warning: no extension found for %r' % ext_id)

    return value

</t>
<t tx="ekr.20181031045138.340">def write_command(self, cmd):
    assert isinstance(cmd, tuple) and len(cmd) &gt;= 1
    bb = serializer.encode(cmd)
    try:
        self.write_message(bb, binary=True)
    except WebSocketClosedError:
        self.close(1000, 'closed by client')

</t>
<t tx="ekr.20181031045138.341">def close(self, *args):
    try:
        WebSocketHandler.close(self, *args)
    except TypeError:
        WebSocketHandler.close(self)  # older Tornado

</t>
<t tx="ekr.20181031045138.342">def close_this(self):
    """ Call this to close the websocket
    """
    self.close(1000, 'closed by server')

</t>
<t tx="ekr.20181031045138.343">def check_origin(self, origin):
    """ Handle cross-domain access; override default same origin policy.
    """
    # http://www.tornadoweb.org/en/stable/_modules/tornado/websocket.html
    #WebSocketHandler.check_origin

    serving_host = self.request.headers.get("Host")
    serving_hostname, _, serving_port = serving_host.partition(':')
    connecting_host = urlparse(origin).netloc
    connecting_hostname, _, connecting_port = connecting_host.partition(':')

    serving_port = serving_port or '80'
    connecting_port = connecting_port or '80'

    if serving_hostname == 'localhost':
        return True  # Safe
    elif serving_host == connecting_host:
        return True  # Passed most strict test, hooray!
    elif serving_hostname == '0.0.0.0' and serving_port == connecting_port:
        return True  # host on all addressses; best we can do is check port
    elif connecting_host in config.host_whitelist:
        return True
    else:
        logger.warn('Connection refused from %s' % origin)
        return False
</t>
<t tx="ekr.20181031045138.344">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.345">"""
The Flexx application system.

The app module implements the connection between Python and JavaScript.
It runs a web server and websocket server based on Tornado, provides
an asset (and data) management system, and provides the PyComponent and
JsComponent classes, which form the basis for e.g. Widgets.
"""

_DEV_NOTES = """
Overview of classes:

* PyComponent and JsComponent: the base class for creating Python/JS component.
* JSModule: represents a module in JS that corresponds to a Python module.
* Asset: represents an asset.
* Bundle: an Asset subclass to represent a collecton of JSModule's in one asset.
* AssetStore: one instance of this class is used to provide all client
  assets in this process (JS, CSS, images, etc.). It also keeps track
  of modules.
* SessionAssets: base class for Session that implements the assets/data part.
* Session: object that handles connection between Python and JS. Has a
  websocket, and optionally a reference to the runtime.
* WebSocket: tornado WS handler.
* AppManager: keeps track of what apps are registered. Has functionality
  to instantiate apps and connect the websocket to them.
* Server: handles http requests. Uses manager to create new app
  instances or get the page for a pending session. Hosts assets by using
  the global asset store.
* Flexx class (in _clientcore.py): more or less the JS side of a session.

"""

import logging
logger = logging.getLogger(__name__)
del logging

# flake8: noqa
from ._app import App, manager
from ._asset import Asset, Bundle
from ._component2 import BaseAppComponent, LocalComponent, ProxyComponent
from ._component2 import PyComponent, JsComponent, StubComponent
from ._component2 import get_component_classes, LocalProperty

from ._funcs import run, start, stop
from ._funcs import init_notebook, serve, launch, export
from ._server import create_server, current_server
from ._session import Session
from ._modules import JSModule
from ._assetstore import assets
from ._clientcore import serializer

# Resolve cyclic dependencies, and explicit exports to help cx_Freeze
# from . import _tornadoserver -- no, we don't want Tornado unless really needed
from . import _component2
_component2.manager = manager
</t>
<t tx="ekr.20181031045138.346"></t>
<t tx="ekr.20181031045138.347">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.348">"""
This module defines a utility to write tests (for e.g. flexx.event)
that run both in Python and JS.

This is part of flexx.event and not in flexx/event/tests because of (re)imports
during tests.
"""

import sys

from pscript.functions import py2js, evaljs
from pscript.stdlib import get_std_info, get_partial_std_lib

from ._loop import loop, this_is_js  # noqa - import from here by tests
from ._component import Component
from ._property import Property
from ._js import create_js_component_class, JS_EVENT


</t>
<t tx="ekr.20181031045138.349">class StdoutMismatchError(Exception):
    """ Raised when the stdout mismatches.
    """
    pass


</t>
<t tx="ekr.20181031045138.35">def encode(self, ob):
    """ Save the given object to bytes.
    """
    f = BytesIO()
    self.save(f, ob)
    return f.getvalue()

</t>
<t tx="ekr.20181031045138.350">class FakeStream:
    """ To capture Pythons stdout and stderr during the both-tests.
    """

    @others
</t>
<t tx="ekr.20181031045138.351">def __init__(self):
    self._parts = []

</t>
<t tx="ekr.20181031045138.352">def write(self, msg):
    # Keep single messages together, so that errors are compared as one "line"
    msg2 = msg.replace('\n', '\r')
    if msg.endswith('\n'):
        self._parts.append(msg2[:-1] + '\n')
    else:
        self._parts.append(msg2)

</t>
<t tx="ekr.20181031045138.353">def flush(self):
    pass

</t>
<t tx="ekr.20181031045138.354">def getvalue(self):
    return ''.join(self._parts)


</t>
<t tx="ekr.20181031045138.355">def call_func_in_py(func):
    """ Call a function and capture ints stdout.
    """
    loop.integrate(reset=True)
    orig_stdout = sys.stdout
    orig_stderr = sys.stderr
    fake_stdout = FakeStream()
    sys.stdout = sys.stderr = fake_stdout
    try:
        func()
    except Exception as err:
        raise  # fall through
    finally:
        sys.stdout = orig_stdout
        sys.stderr = orig_stderr
    loop.reset()
    return fake_stdout.getvalue().rstrip()


</t>
<t tx="ekr.20181031045138.356">def call_func_in_js(func, classes, extra_nodejs_args=None):
    # Collect base classes
    all_classes = []
    for cls in classes:
        for c in cls.mro():
            if c is Component or c is Property or c in all_classes:
                break
            all_classes.append(c)
    # Generate JS code
    code = JS_EVENT
    for c in reversed(all_classes):
        code += create_js_component_class(c, c.__name__,
                                          c.__bases__[0].__name__+'.prototype')
    code += py2js(func, 'test', inline_stdlib=False, docstrings=False)
    code += 'test();loop.reset();'
    nargs, function_deps, method_deps = get_std_info(code)
    code = get_partial_std_lib(function_deps, method_deps, []) + code
    # Call (allow using file)
    return evaljs(code, print_result=False, extra_nodejs_args=extra_nodejs_args)


</t>
<t tx="ekr.20181031045138.357">def smart_compare(func, *comparations):
    """ Compare multiple text-pairs, raising an error that shows where
    the texts differ for each of the mismatching pairs.
    Each comparison should be (name, text, reference).
    """
    err_msgs = []
    has_errors = False
    for comp in comparations:
        err_msg = validate_text(*comp)
        if err_msg:
            has_errors = True
            err_msgs.append(err_msg)
        else:
            err_msgs.append(' ' * 8 + comp[0] + ' matches the reference\n')

    if has_errors:
        j = '_' * 79 + '\n'
        err_msgs = [''] + err_msgs + ['']
        t = 'Text mismatch in\nFile "%s", line %i, in %s:\n%s'
        raise StdoutMismatchError(t % (func.__code__.co_filename,
                                       func.__code__.co_firstlineno,
                                       func.__name__,
                                       j.join(err_msgs)))

</t>
<t tx="ekr.20181031045138.358">def validate_text(name, text, reference):
    """ Compare text with a reference. Returns None if they match, and otherwise
    an error message that outlines where they differ.
    """

    lines1 = text.split('\n')
    lines2 = reference.split('\n')
    n = max(len(lines1), len(lines2))

    for i in range(len(lines1)):
        if lines1[i].startswith(('[E ', '[W ', '[I ')):
            lines1[i] = lines1[i].split(']', 1)[-1].lstrip()  # remove log prefix

    while len(lines1) &lt; n:
        lines1.append('')
    while len(lines2) &lt; n:  # pragma: no cover
        lines2.append('')

    nchars = 35  # 2*35 + 8 for prefix and 1 spacing = 79

    for i in range(n):
        line1, line2 = lines1[i], lines2[i]
        line1 = line1.lower()
        line2 = line2.lower()
        if line2.startswith('?'):
            equal_enough = line2[1:].strip() in line1
        else:
            equal_enough = line1 == line2
        if not equal_enough:
            i1 = max(0, i - 16)
            i2 = min(n, i + 16)
            msg = ' '*8 + name.ljust(nchars) + ' ' + 'Reference'.ljust(nchars) + '\n'
            for j in range(i1, i2):
                linenr = str(j + 1).rjust(3, '0')
                prefix = ' &gt;&gt; ' if j == i else '    '
                msg += '{}{} '.format(prefix, linenr)
                msg += _zip(_wrap(lines1[j], nchars, 3), _wrap(lines2[j], nchars, 3), 8)
                # line1 = lines1[j].ljust(nchars, '\xb7')
                # line2 = lines2[j].ljust(nchars, '\xb7')
                # line1 = line1 if len(line1) &lt;= nchars else line1[:nchars-1] + ''
                # line2 = line2 if len(line2) &lt;= nchars else line2[:nchars-1] + ''
                # msg += '{}{} {} {}\n'.format(prefix, linenr, line1, line2)
            return msg

</t>
<t tx="ekr.20181031045138.359">def _wrap(line, nchars, maxlines):
    line = line.replace('\n', '\\n').replace('\r', '\\r')
    lines = []
    while line:
        lines.append(line[:nchars])
        line = line[nchars:].lstrip()
    if not lines:
        lines.append('\xb7' * nchars)
    elif len(lines) == 1:
        lines[-1] = lines[-1].ljust(nchars, '\xb7')
    elif len(lines) &lt;= maxlines:
        lines[-1] = lines[-1].ljust(nchars, ' ')
    else:
        lines = lines[:maxlines]
        lines[-1] = lines[-1][:-1] + ''

    return lines

</t>
<t tx="ekr.20181031045138.36">def save(self, f, ob):
    """ Write the given object to the given file object.
    """
    f.write(b'BSDF')
    f.write(struct.pack('&lt;B', VERSION[0]))
    f.write(struct.pack('&lt;B', VERSION[1]))

    self._encode(f, ob, None)

</t>
<t tx="ekr.20181031045138.360">def _zip(lines1, lines2, offset):
    n = max(len(lines1), len(lines2))
    nchars = len(lines1[0])
    while len(lines1) &lt; n:
        lines1.append(' ' * nchars)
    while len(lines2) &lt; n:  # pragma: no cover
        lines2.append(' ' * nchars)
    text = ''
    i = 0
    for line1, line2 in zip(lines1, lines2):
        if i &gt; 0:
            text += ' ' * offset
        i += 1
        text += line1 + ' ' + line2 + '\n'
    return text


</t>
<t tx="ekr.20181031045138.361">def run_in_both(*classes, js=True, py=True, extra_nodejs_args=None):
    """ Decorator to run a test in both Python and JS.

    The decorator should be provided with any Component classes that
    you want to use in the test.

    The function docstring should match the stdout + stderr of the test (case
    insensitive). To provide separate reference outputs for Python and
    JavaScript, use a delimiter of at least 10 '-' characters. Use "? xx"
    to test that "xx" is present on a line (useful for logged exceptions).
    """

    def wrapper(func):
        reference = '\n'.join(line[4:] for line in func.__doc__.splitlines())
        parts = reference.split('-'*10)
        pyref = parts[0].strip(' \n')
        jsref = parts[-1].strip(' \n-')

        def runner1():
            # One level of indirection to make cleaner error reporting by pytest
            err = None
            try:
                return runner2()
            except Exception as e:
                err = e
            if isinstance(err, StdoutMismatchError):
                raise StdoutMismatchError(err)
            elif isinstance(err, RuntimeError):
                raise RuntimeError(err)
            else:
                raise err

        def runner2():
            # Run in Python
            if py:
                pyresult = call_func_in_py(func)
                pyresult = pyresult.replace('"', "'").replace("\\'", "'")
                pyresult = pyresult.split('!!!!')[-1]
                #print('Py:\n' + pyresult)
            # Run in JS
            if js:
                jsresult = call_func_in_js(func, classes, extra_nodejs_args)
                jsresult = jsresult.replace('[ ', '[').replace(' ]', ']')
                jsresult = jsresult.replace('\n  ', ' ')
                jsresult = jsresult.replace('"', "'").split('!!!!')[-1]
                jsresult = jsresult.replace('null', 'None')
                #print('JS:\n' + jsresult)
            args = [func]
            if py:
                args.append(('Python', pyresult, pyref))
            if js:
                args.append(('JavaScript', jsresult, jsref))
            smart_compare(*args)
            print(func.__name__, 'ok')
            return True
        return runner1
    return wrapper
</t>
<t tx="ekr.20181031045138.362">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.363">"""
Implements the action decorator, class and desciptor.
"""

import weakref
import inspect

from ._loop import loop
from . import logger


</t>
<t tx="ekr.20181031045138.364">def action(func):
    """ Decorator to turn a method of a Component into an
    :class:`Action &lt;flexx.event.Action&gt;`.

    Actions change the state of the application by
    :func:`mutating &lt;flexx.event.Component._mutate&gt;`
    :class:`properties &lt;flexx.event.Property&gt;`.
    In fact, properties can only be changed via actions.

    Actions are asynchronous and thread-safe. Invoking an action will not
    apply the changes directly; the action is queued and handled at a later
    time. The one exception is that when an action is invoked from anoher
    action, it is handled directly.

    Although setting properties directly might seem nice, their use would mean
    that the state of the application can change while the app is *reacting*
    to changes in the state. This might be managable for small applications,
    but as an app grows this easily results in inconsistencies and bugs.
    Separating actions (which modify state) and reactions (that react to it)
    makes apps easier to understand and debug. This is the core idea behind
    frameworks such as Elm, React and Veux. And Flexx adopts it as well.

    Example usage:

    .. code-block:: py

        class MyComponent(event.Component):

            count = event.IntProp(0)

            @action
            def increase_counter(self):
                self._mutate_count(self.count + 1)  # call mutator function

    """
    if not callable(func):
        raise TypeError('The event.action() decorator needs a function.')
    if getattr(func, '__self__', None) is not None:  # builtin funcs have __self__
        raise TypeError('Invalid use of action decorator.')
    return ActionDescriptor(func, func.__name__, func.__doc__ or func.__name__)


</t>
<t tx="ekr.20181031045138.365">class BaseDescriptor:
    """ Base descriptor class for some commonalities.
    """

    @others
</t>
<t tx="ekr.20181031045138.366">def __repr__(self):
    t = '&lt;%s %r (this should be a class attribute) at 0x%x&gt;'
    return t % (self.__class__.__name__, self._name, id(self))

</t>
<t tx="ekr.20181031045138.367">def __set__(self, obj, value):
    cname = self.__class__.__name__
    cname = cname[:-10] if cname.endswith('Descriptor') else cname
    raise AttributeError('Cannot overwrite %s %r.' % (cname, self._name))

</t>
<t tx="ekr.20181031045138.368">def __delete__(self, obj):
    cname = self.__class__.__name__
    cname = cname[:-10] if cname.endswith('Descriptor') else cname
    raise AttributeError('Cannot delete %s %r.' % (cname, self._name))

</t>
<t tx="ekr.20181031045138.369">@staticmethod
def _format_doc(kind, name, doc, func=None):
    prefix, betweenfix = '', ' '

    doc = (doc or '').strip()
    # Prevent Sphinx doing something weird when it sees a colon on first line
    if doc.count('\n') and doc.split('\n')[0].strip().count(':'):
        line2 = doc.split('\n')[1]
        betweenfix = '\n' + ' ' * (len(line2) - len(line2.lstrip()))
    if doc:
        if func:
            sig = str(inspect.signature(func))
            sig = '(' + sig[5:].lstrip(', ') if sig.startswith('(self') else sig
            prefix = '{}{}\n'.format(name, sig)
        return '{}*{}* {}{}\n'.format(prefix, kind, betweenfix, doc or name)


</t>
<t tx="ekr.20181031045138.37">def decode(self, bb):
    """ Load the data structure that is BSDF-encoded in the given bytes.
    """
    f = BytesIO(bb)
    return self.load(f)

</t>
<t tx="ekr.20181031045138.370">class ActionDescriptor(BaseDescriptor):
    """ Class descriptor for actions.
    """

    @others
</t>
<t tx="ekr.20181031045138.371">def __init__(self, func, name, doc):
    self._func = func
    self._name = name
    self.__doc__ = self._format_doc('action', name, doc, func)

</t>
<t tx="ekr.20181031045138.372">def __get__(self, instance, owner):
    # Return Action object, which we cache on the instance
    if instance is None:
        return self

    private_name = '_' + self._name + '_action'
    try:
        action = getattr(instance, private_name)
    except AttributeError:
        action = Action(instance, self._func, self._name, self.__doc__)
        setattr(instance, private_name, action)

    # Make the action use *our* func one time. In most situations
    # this is the same function that the action has, but not when
    # using super(); i.e. this allows an action to call the same
    # action of its super class.
    action._use_once(self._func)
    return action


</t>
<t tx="ekr.20181031045138.373">class Action:
    """ Action objects are wrappers around Component methods. They take
    care of queueing action invokations rather than calling the function
    directly, unless the action is called from another action (in this
    case it would a direct call). This class should not be instantiated
    directly; use ``event.action()`` instead.
    """

    @others
</t>
<t tx="ekr.20181031045138.374">def __init__(self, ob, func, name, doc):
    assert callable(func)

    # Store func, name, and docstring (e.g. for sphinx docs)
    self._ob1 = weakref.ref(ob)
    self._func = func
    self._func_once = func
    self._name = name
    self.__doc__ = doc
    self.is_autogenerated = func.__name__ == 'flx_setter'  # also see _js.py

</t>
<t tx="ekr.20181031045138.375">def __repr__(self):
    cname = self.__class__.__name__
    return '&lt;%s %r at 0x%x&gt;' % (cname, self._name, id(self))

</t>
<t tx="ekr.20181031045138.376">def _use_once(self, func):
    """ To support super().
    """
    self._func_once = func

</t>
<t tx="ekr.20181031045138.377">def __call__(self, *args):
    """ Invoke the action.
    """
    ob = self._ob1()
    if loop.can_mutate(ob):
        func = self._func_once
        self._func_once = self._func
        if ob is not None:
            res = func(ob, *args)
            if res is not None:
                logger.warn('Action (%s) is not supposed to return a value' %
                            self._name)
    else:
        loop.add_action_invokation(self, args)

    return ob  # 'Actions are invoked asynchronously'
</t>
<t tx="ekr.20181031045138.378">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.379">"""
Implements the attribute class.
"""

from ._action import BaseDescriptor


</t>
<t tx="ekr.20181031045138.38">def load(self, f):
    """ Load a BSDF-encoded object from the given file object.
    """
    # Check magic string
    if f.read(4) != b'BSDF':
        raise RuntimeError('This does not look a BSDF file.')
    # Check version
    major_version = strunpack('&lt;B', f.read(1))[0]
    minor_version = strunpack('&lt;B', f.read(1))[0]
    file_version = '%i.%i' % (major_version, minor_version)
    if major_version != VERSION[0]:  # major version should be 2
        t = ('Reading file with different major version (%s) '
             'from the implementation (%s).')
        raise RuntimeError(t % (file_version, __version__))
    if minor_version &gt; VERSION[1]:  # minor should be &lt; ours
        t = ('BSDF warning: reading file with higher minor version (%s) '
             'than the implementation (%s).')
        logger.warn(t % (file_version, __version__))

    return self._decode(f)


\\-4.# %% Standard extensions

\\-4.# Defining extensions as a dict would be more compact and feel lighter, but
\\-4.# that would only allow lambdas, which is too limiting, e.g. for ndarray
\\-4.# extension.

</t>
<t tx="ekr.20181031045138.380">class Attribute(BaseDescriptor):
    """ Attributes are (readonly, and usually static) values associated with
    Component classes. They expose and document a value without
    providing means of observing changes like ``Property`` does. (The
    actual value is taken from ``component._xx``, with "xx" the name
    of the attribute.)

    """

    @others
</t>
<t tx="ekr.20181031045138.381">def __init__(self, doc=''):
    # Set doc
    if not isinstance(doc, str):
        raise TypeError('event.Attribute() doc must be a string.')
    self._doc = doc
    self._set_name('anonymous_attribute')

</t>
<t tx="ekr.20181031045138.382">def _set_name(self, name):
    self._name = name  # or func.__name__
    self.__doc__ = self._format_doc('attribute', name, self._doc)

</t>
<t tx="ekr.20181031045138.383">def __set__(self, instance, value):
    t = 'Cannot set attribute %r.'
    raise AttributeError(t % self._name)

</t>
<t tx="ekr.20181031045138.384">def __get__(self, instance, owner):
    if instance is None:
        return self
    return getattr(instance, '_' + self._name)
</t>
<t tx="ekr.20181031045138.385">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.386">"""
Implements the Component class; the core class that has properties,
actions that mutate the properties, and reactions that react to the
events and changes in properties.
"""

import sys

from ._dict import Dict
from ._attribute import Attribute
from ._action import ActionDescriptor, Action
from ._reaction import ReactionDescriptor, Reaction, looks_like_method
from ._property import Property
from ._emitter import EmitterDescriptor
from ._loop import loop, this_is_js
from . import logger


setTimeout = console = None


# From six.py
</t>
<t tx="ekr.20181031045138.387">def with_metaclass(meta, *bases):
    """Create a base class with a metaclass."""
    # This requires a bit of explanation: the basic idea is to make a dummy
    # metaclass for one level of class instantiation that replaces itself with
    # the actual metaclass.
    # On Python 2.7, the name cannot be unicode :/
    tmp_name = b'tmp_class' if sys.version_info[0] == 2 else 'tmp_class'
    class metaclass(meta):
        def __new__(cls, name, this_bases, d):
            return meta(name, bases, d)
    return type.__new__(metaclass, tmp_name, (), {})


</t>
<t tx="ekr.20181031045138.388">def new_type(name, *args, **kwargs):  # pragma: no cover
    """ Alternative for type(...) to be legacy-py compatible.
    """
    name = name.encode() if sys.version_info[0] == 2 else name
    return type(name, *args, **kwargs)


</t>
<t tx="ekr.20181031045138.389">class ComponentMeta(type):
    """ Meta class for Component
    * Set the name of property desciptors.
    * Set __actions__, __reactions__, __emitters__ and __properties__ class attributes.
    * Create private methods (e.g. mutator functions and prop validators).
    """

    @others
</t>
<t tx="ekr.20181031045138.39">class Extension(object):
    """ Base class to implement BSDF extensions for special data types.

    Extension classes are provided to the BSDF serializer, which
    instantiates the class. That way, the extension can be somewhat dynamic:
    e.g. the NDArrayExtension exposes the ndarray class only when numpy
    is imported.

    A extension instance must have two attributes. These can be attribiutes of
    the class, or of the instance set in ``__init__()``:

    * name (str): the name by which encoded values will be identified.
    * cls (type): the type (or list of types) to match values with.
      This is optional, but it makes the encoder select extensions faster.

    Further, it needs 3 methods:

    * `match(serializer, value) -&gt; bool`: return whether the extension can
      convert the given value. The default is ``isinstance(value, self.cls)``.
    * `encode(serializer, value) -&gt; encoded_value`: the function to encode a
      value to more basic data types.
    * `decode(serializer, encoded_value) -&gt; value`: the function to decode an
      encoded value back to its intended representation.

    """

    name = ''
    cls = ()

    @others
</t>
<t tx="ekr.20181031045138.390">def __init__(cls, name, bases, dct):
    cls._finish_properties(dct)
    cls._init_hook1(name, bases, dct)
    cls._set_summaries()
    cls._init_hook2(name, bases, dct)
    type.__init__(cls, name, bases, dct)

</t>
<t tx="ekr.20181031045138.391">def _init_hook1(cls, name, bases, dct):
    """ Overloaded in flexx.app.AppComponentMeta.
    """
    pass

</t>
<t tx="ekr.20181031045138.392">def _init_hook2(cls, name, bases, dct):
    """ Overloaded in flexx.app.AppComponentMeta.
    """
    pass

</t>
<t tx="ekr.20181031045138.393">def _set_cls_attr(cls, dct, name, att):
    dct[name] = att
    setattr(cls, name, att)

</t>
<t tx="ekr.20181031045138.394">def _finish_properties(cls, dct):
    """ Finish properties:

    * Create a mutator function for convenience.
    * Create validator function.
    * If needed, create a corresponding set_xx action.
    """
    for name in list(dct.keys()):
        if name.startswith('__'):
            continue
        val = getattr(cls, name)
        if isinstance(val, type) and issubclass(val, (Attribute, Property)):
            raise TypeError('Attributes and Properties should be instantiated, '
                            'use ``foo = IntProp()`` instead of ``foo = IntProp``.')
        elif isinstance(val, Attribute):
            val._set_name(name)  # noqa
        elif isinstance(val, Property):
            val._set_name(name)  # noqa
            # Create validator method
            cls._set_cls_attr(dct, '_' + name + '_validate', val._validate_py)
            # Create mutator method
            cls._set_cls_attr(dct, '_mutate_' + name, val.make_mutator())
            # Create setter action?
            action_name = ('_set' if name.startswith('_') else 'set_') + name
            if val._settable and not hasattr(cls, action_name):
                action_des = ActionDescriptor(val.make_set_action(), action_name,
                                              'Setter for the %r property.' % name)
                cls._set_cls_attr(dct, action_name, action_des)

</t>
<t tx="ekr.20181031045138.395">def _set_summaries(cls):
    """ Analyse the class and set lists __actions__, __emitters__,
    __properties__, and __reactions__.
    """

    attributes = {}
    properties = {}
    actions = {}
    emitters = {}
    reactions = {}

    for name in dir(cls):
        if name.startswith('__'):
            continue
        val = getattr(cls, name)
        if isinstance(val, Attribute):
            attributes[name] = val
        elif isinstance(val, Property):
            properties[name] = val
        elif isinstance(val, ActionDescriptor):
            actions[name] = val
        elif isinstance(val, ReactionDescriptor):
            reactions[name] = val
        elif isinstance(val, EmitterDescriptor):
            emitters[name] = val
        elif isinstance(val, (Action, Reaction)):  # pragma: no cover
            raise RuntimeError('Class methods can only be made actions or '
                               'reactions using the corresponding decorators '
                               '(%r)' % name)
    # Cache names
    cls.__attributes__ = [name for name in sorted(attributes.keys())]
    cls.__properties__ = [name for name in sorted(properties.keys())]
    cls.__actions__ = [name for name in sorted(actions.keys())]
    cls.__emitters__ = [name for name in sorted(emitters.keys())]
    cls.__reactions__ = [name for name in sorted(reactions.keys())]


</t>
<t tx="ekr.20181031045138.396">class Component(with_metaclass(ComponentMeta, object)):
    """ The base component class.

    Components have attributes to represent static values, properties
    to represent state, actions that can mutate properties, and
    reactions that react to events such as property changes.

    Initial values of properties can be provided by passing them
    as keyword arguments.

    Subclasses can use :class:`Property &lt;flexx.event.Property&gt;` (or one
    of its subclasses) to define properties, and the
    :func:`action &lt;flexx.event.action&gt;`, :func:`reaction &lt;flexx.event.reaction&gt;`,
    and :func:`emitter &lt;flexx.event.emitter&gt;` decorators to create actions,
    reactions. and emitters, respectively.

    .. code-block:: python

        class MyComponent(event.Component):

            foo = event.FloatProp(7, settable=True)
            spam = event.Attribute()

            @event.action
            def inrease_foo(self):
                self._mutate_foo(self.foo + 1)

            @event.reaction('foo')
            def on_foo(self, *events):
                print('foo was set to', self.foo)

            @event.reaction('bar')
            def on_bar(self, *events):
                for ev in events:
                    print('bar event was emitted')

            @event.emitter
            def bar(self, v):
                return dict(value=v)  # the event to emit

    """

    _IS_COMPONENT = True
    _COUNT = 0

    id = Attribute(doc='The string by which this component is identified.')

    @others
</t>
<t tx="ekr.20181031045138.397">def __init__(self, *init_args, **property_values):

    Component._COUNT += 1
    self._id = self.__class__.__name__ + str(Component._COUNT)
    self._disposed = False

    # Init some internal variables. Note that __reactions__ is a list of
    # reaction names for this class, and __handlers a dict of reactions
    # registered to events of this object.
    # The __pending_events makes that reactions that connect to this
    # component right after it initializes get the initial events.
    self.__handlers = {}
    self.__pending_events = []
    self.__anonymous_reactions = []
    self.__initial_mutation = False

    # Prepare handlers with event types that we know
    for name in self.__emitters__:
        self.__handlers.setdefault(name, [])
    for name in self.__properties__:
        self.__handlers.setdefault(name, [])

    # With self as the active component (and thus mutatable), init the
    # values of all properties, and apply user-defined initialization
    with self:
        self._comp_init_property_values(property_values)
        self.init(*init_args)

    # Connect reactions and fire initial events
    self._comp_init_reactions()

</t>
<t tx="ekr.20181031045138.398">def __repr__(self):
    return "&lt;Component '%s' at 0x%x&gt;" % (self._id, id(self))

</t>
<t tx="ekr.20181031045138.399">def _comp_init_property_values(self, property_values):
    """ Initialize property values, combining given kwargs (in order)
    and default values.
    """
    values = []
    # First collect default property values (they come first)
    for name in self.__properties__:  # is sorted by name
        prop = getattr(self.__class__, name)
        setattr(self, '_' + name + '_value', prop._default)
        if name not in property_values:
            values.append((name, prop._default))
    # Then collect user-provided values
    for name, value in property_values.items():  # is sorted by occurance in py36
        if name not in self.__properties__:
            if name in self.__attributes__:
                raise AttributeError('%s.%s is an attribute, not a property' %
                                     (self._id, name))
            else:
                raise AttributeError('%s does not have property %s.' %
                                     (self._id, name))
        if callable(value):
            self._comp_make_implicit_setter(name, value)
            continue
        values.append((name, value))
    # Then process all property values
    self._comp_apply_property_values(values)

</t>
<t tx="ekr.20181031045138.4">@path C:/Anaconda3/Lib/site-packages/flexx/
# fmt: off
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.40">def __repr__(self):
    return '&lt;BSDF extension %r at 0x%s&gt;' % (self.name, hex(id(self)))

</t>
<t tx="ekr.20181031045138.400">def _comp_apply_property_values(self, values):
    """ Apply given property values, prefer using a setter, mutate otherwise.
    """
    self.__initial_mutation = True
    # First mutate all properties. Mutations validate input, but are always
    # independent.
    for name, value in values:
        self._mutate(name, value)
    # Now that all properties have a good initial value, invoke the setters
    # of properties that have one (and that is not auto-generated)
    for name, value in values:
        setter_name = ('_set' if name.startswith('_') else 'set_') + name
        setter = getattr(self, setter_name, None)
        if setter is not None:
            if getattr(setter, 'is_autogenerated', None) is False:
                # This is an action, and one that the user wrote
                setter(value)
    self.__initial_mutation = False

</t>
<t tx="ekr.20181031045138.401">def _comp_make_implicit_setter(self, prop_name, func):
    setter_func = getattr(self, 'set_' + prop_name, None)
    if setter_func is None:
        t = '%s does not have a set_%s() action for property %s.'
        raise TypeError(t % (self._id, prop_name, prop_name))
    setter_reaction = lambda: setter_func(func())
    reaction = Reaction(self, setter_reaction, 'auto', [])
    self.__anonymous_reactions.append(reaction)

</t>
<t tx="ekr.20181031045138.402">def _comp_init_reactions(self):
    """ Create our own reactions. These will immediately connect.
    """
    if self.__pending_events is not None:
        self.__pending_events.append(None)  # marker
        loop.call_soon(self._comp_stop_capturing_events)

    # Instantiate reactions by referencing them, Connections are resolved now.
    # Implicit (auto) reactions need to be invoked to initialize connections.
    for name in self.__reactions__:
        reaction = getattr(self, name)
        if reaction.get_mode() == 'auto':
            ev = Dict(source=self, type='', label='')
            loop.add_reaction_event(reaction, ev)
    # Also invoke the anonymouse auto-reactions
    for reaction in self.__anonymous_reactions:
        if reaction.get_mode() == 'auto':
            ev = Dict(source=self, type='', label='')
            loop.add_reaction_event(reaction, ev)

</t>
<t tx="ekr.20181031045138.403">def _comp_stop_capturing_events(self):
    """ Stop capturing events and flush the captured events.
    This gets scheduled to be called asap after initialization. But
    components created in our init() go first.
    """
    events = self.__pending_events
    self.__pending_events = None

    # The allow_reconnect stuff is to avoid reconnecting for properties
    # that we know did not change since the reaction connected.
    allow_reconnect = False
    for ev in events:
        if ev is None:
            allow_reconnect = True
            continue
        ev.allow_reconnect = allow_reconnect
        self.emit(ev.type, ev)

</t>
<t tx="ekr.20181031045138.404">def __enter__(self):
    loop._activate_component(self)
    loop.call_soon(self.__check_not_active)
    return self

</t>
<t tx="ekr.20181031045138.405">def __exit__(self, type, value, traceback):
    loop._deactivate_component(self)

</t>
<t tx="ekr.20181031045138.406">def __check_not_active(self):
    # Note: this adds overhead, especially during initialization, but it
    # is a valuable check ... it is something that could potentially be
    # disabled in "production mode".
    active_components = loop.get_active_components()
    if self in active_components:
        raise RuntimeError('It seems that the event loop is processing '
                           'events while a Component is active. This has a '
                           'high risk on race conditions.')

</t>
<t tx="ekr.20181031045138.407">def init(self):
    """ Initializer method. This method can be overloaded when
    creating a custom class. It is called with this component as a
    context manager (i.e. it is the active component), and it receives
    any positional arguments that were passed to the constructor.
    """
    pass

</t>
<t tx="ekr.20181031045138.408">def __del__(self):
    if not self._disposed:
        loop.call_soon(self._dispose)

</t>
<t tx="ekr.20181031045138.409">def dispose(self):
    """ Use this to dispose of the object to prevent memory leaks.
    Make all subscribed reactions forget about this object, clear
    all references to subscribed reactions, and disconnect all reactions
    defined on this object.
    """
    self._dispose()

</t>
<t tx="ekr.20181031045138.41">def match(self, s, v):
    return isinstance(v, self.cls)

</t>
<t tx="ekr.20181031045138.410">def _dispose(self):
    # Distinguish between private and public method to allow disposing
    # flexx.app.ProxyComponent without disposing its local version.

    self._disposed = True
    if not this_is_js():
        logger.debug('Disposing Component %r' % self)
    for name, reactions in self.__handlers.items():
        for i in range(len(reactions)):
            reactions[i][1]._clear_component_refs(self)
        while len(reactions):
            reactions.pop()  # no list.clear on legacy py
    for i in range(len(self.__reactions__)):
        getattr(self, self.__reactions__[i]).dispose()

</t>
<t tx="ekr.20181031045138.411">def _registered_reactions_hook(self):
    """ This method is called when the reactions change, can be overloaded
    in subclasses. The original method returns a list of event types for
    which there is at least one registered reaction. Overloaded methods
    should return this list too.
    """
    used_event_types = []
    for key, reactions in self.__handlers.items():
        if len(reactions) &gt; 0:
            used_event_types.append(key)
    return used_event_types

</t>
<t tx="ekr.20181031045138.412">def _register_reaction(self, event_type, reaction, force=False):
    # Register a reaction for the given event type. The type
    # can include a label, e.g. 'pointer_down:foo'.
    # This is called from Reaction objects at initialization and when
    # they reconnect (dynamism).
    type, _, label = event_type.partition(':')
    label = label or reaction._name
    reactions = self.__handlers.get(type, None)
    if reactions is None:  # i.e. type not in self.__handlers
        reactions = []
        self.__handlers[type] = reactions
        if force:
            pass
        elif type.startswith('mouse_'):
            t = 'The event "{}" has been renamed to "pointer{}".'
            logger.warn(t.format(type, type[5:]))
        else:  # ! means force
            msg = ('Event type "{type}" does not exist on component {id}. ' +
                   'Use "!{type}" or "!xx.yy.{type}" to suppress this warning.')
            msg = msg.replace('{type}', type).replace('{id}', self._id)
            logger.warn(msg)

    # Insert reaction in good place (if not already in there) - sort as we add
    comp1 = label + '-' + reaction._id
    for i in range(len(reactions)):
        comp2 = reactions[i][0] + '-' + reactions[i][1]._id
        if comp1 &lt; comp2:
            reactions.insert(i, (label, reaction))
            break
        elif comp1 == comp2:
            break  # already in there
    else:
        reactions.append((label, reaction))

    # Call hook to keep (subclasses of) the component up to date
    self._registered_reactions_hook()

</t>
<t tx="ekr.20181031045138.413">def disconnect(self, type, reaction=None):
    """ Disconnect reactions.

    Parameters:
        type (str): the type for which to disconnect any reactions.
            Can include the label to only disconnect reactions that
            were registered with that label.
        reaction (optional): the reaction object to disconnect. If given,
           only this reaction is removed.
    """
    # This is called from Reaction objects when they dispose and when
    # they reconnect (dynamism).
    type, _, label = type.partition(':')
    reactions = self.__handlers.get(type, ())
    for i in range(len(reactions)-1, -1, -1):
        entry = reactions[i]
        if not ((label and label != entry[0]) or
                (reaction and reaction is not entry[1])):
            reactions.pop(i)
    self._registered_reactions_hook()

</t>
<t tx="ekr.20181031045138.414">def emit(self, type, info=None):
    """ Generate a new event and dispatch to all event reactions.

    Arguments:
        type (str): the type of the event. Should not include a label.
        info (dict): Optional. Additional information to attach to
            the event object. Note that the actual event is a Dict object
            that allows its elements to be accesses as attributes.
    """
    info = {} if info is None else info
    type, _, label = type.partition(':')
    if len(label):
        raise ValueError('The type given to emit() should not include a label.')
    # Prepare event
    if not isinstance(info, dict):
        raise TypeError('Info object (for %r) must be a dict, not %r' %
                        (type, info))
    ev = Dict(info)  # make copy and turn into nicer Dict on py
    ev.type = type
    ev.source = self
    # Push the event to the reactions (reactions use labels for dynamism)
    if self.__pending_events is not None:
        # Register pending reactions
        self.__pending_events.append(ev)
    else:
        # Reaction reconnections are applied directly; before a new event
        # occurs that the reaction might be subscribed to after the reconnect.
        reactions = self.__handlers.get(ev.type, ())
        for i in range(len(reactions)):
            label, reaction = reactions[i]
            if label.startswith('reconnect_'):
                if getattr(ev, 'allow_reconnect', True) is True:
                    index = int(label.split('_')[-1])
                    reaction.reconnect(index)
            else:
                loop.add_reaction_event(reaction, ev)
    return ev

</t>
<t tx="ekr.20181031045138.415">def _mutate(self, prop_name, value, mutation='set', index=-1):
    """ Mutate a :class:`property &lt;flexx.event.Property&gt;`.
    Can only be called from an :class:`action &lt;flexx.event.action&gt;`.

    Each Component class will also have an auto-generated mutator function
    for each property: e.g. property ``foo`` can be mutated with
    ``c._mutate('foo', ..)`` or ``c._mutate_foo(..)``.

    Arguments:
        prop_name (str): the name of the property being mutated.
        value: the new value, or the partial value for partial mutations.
        mutation (str): the kind of mutation to apply. Default is 'set'.
           Partial mutations to list-like
           :class:`properties &lt;flexx.event.Property&gt;` can be applied by using
           'insert', 'remove', or 'replace'. If other than 'set', index must
           be specified, and &gt;= 0. If 'remove', then value must be an int
           specifying the number of items to remove.
        index: the index at which to insert, remove or replace items. Must
            be an int for list properties.

    The 'replace' mutation also supports multidensional (numpy) arrays.
    In this case ``value`` can be an ndarray to patch the data with, and
    ``index`` a tuple of elements.
    """
    if not isinstance(prop_name, str):
        raise TypeError("_mutate's first arg must be str, not %s" %
                         prop_name.__class__)
    if prop_name not in self.__properties__:
        cname = self.__class__.__name__
        raise AttributeError('%s object has no property %r' % (cname, prop_name))

    if loop.can_mutate(self) is False:
        raise AttributeError('Trying to mutate property %s outside '
                             'of an action or context.' % prop_name)

    # Prepare
    private_name = '_' + prop_name + '_value'
    validator_name = '_' + prop_name + '_validate'

    # Set / Emit
    old = getattr(self, private_name)

    if mutation == 'set':
        # Normal setting of a property
        value2 = getattr(self, validator_name)(value)
        setattr(self, private_name, value2)
        # Emit?
        if this_is_js():  # pragma: no cover
            is_equal = old == value2
        elif hasattr(old, 'dtype') and hasattr(value2, 'dtype'):  # pragma: no cover
            import numpy as np
            is_equal = np.array_equal(old, value2)
        else:
            is_equal = type(old) == type(value2) and old == value2
        if self.__initial_mutation is True:
            old = value2
            is_equal = False  # well, they are, but we want an event!
        if not is_equal:
            self.emit(prop_name,
                      dict(new_value=value2, old_value=old, mutation=mutation))
            return True
    else:
        # Array mutations - value is assumed to be a sequence, or int for 'remove'
        ev = Dict()
        ev.objects = value
        ev.mutation = mutation
        ev.index = index
        if isinstance(old, dict):
            if index != -1:
                raise IndexError('For in-place dict mutations, '
                                 'the index is not used, and must be -1.')
            mutate_dict(old, ev)
        else:
            if index &lt; 0:
                raise IndexError('For insert, remove, and replace mutations, '
                                 'the index must be &gt;= 0.')
            mutate_array(old, ev)
        self.emit(prop_name, ev)
        return True

</t>
<t tx="ekr.20181031045138.416">def get_event_types(self):
    """ Get the known event types for this component. Returns
    a list of event type names, for which there is a
    property/emitter or for which any reactions are registered.
    Sorted alphabetically. Intended mostly for debugging purposes.
    """
    types = list(self.__handlers)  # avoid using sorted (one less stdlib func)
    types.sort()
    return types

</t>
<t tx="ekr.20181031045138.417">def get_event_handlers(self, type):
    """ Get a list of reactions for the given event type. The order
    is the order in which events are handled: alphabetically by
    label. Intended mostly for debugging purposes.

    Parameters:
        type (str): the type of event to get reactions for. Should not
            include a label.

    """
    if not type:  # pragma: no cover - this is mostly since js allows missing args
        raise TypeError('get_event_handlers() missing "type" argument.')
    type, _, label = type.partition(':')
    if len(label):
        raise ValueError('The type given to get_event_handlers() '
                         'should not include a label.')
    reactions = self.__handlers.get(type, ())
    return [h[1] for h in reactions]

</t>
<t tx="ekr.20181031045138.418">def reaction(self, *connection_strings):
    """ Create a reaction by connecting a function to one or more events of
    this instance. Can also be used as a decorator. See the
    :func:`reaction &lt;flexx.event.reaction&gt;` decorator, and the intro
    docs for more information.
    """
    mode = 'normal'
    if (not connection_strings) or (len(connection_strings) == 1 and
                                    callable(connection_strings[0])):
        raise RuntimeError('Component.reaction() '
                            'needs one or more connection strings.')

    func = None
    if callable(connection_strings[0]):
        func = connection_strings[0]
        connection_strings = connection_strings[1:]
    elif callable(connection_strings[-1]):
        func = connection_strings[-1]
        connection_strings = connection_strings[:-1]

    for s in connection_strings:
        if not (isinstance(s, str) and len(s) &gt; 0):
            raise ValueError('Connection string must be nonempty string.')

    def _react(func):
        if not callable(func):  # pragma: no cover
            raise TypeError('Component.reaction() decorator requires a callable.')
        if looks_like_method(func):
            return ReactionDescriptor(func, mode, connection_strings, self)
        else:
            return Reaction(self, func, mode, connection_strings)

    if func is not None:
        return _react(func)
    else:
        return _react


</t>
<t tx="ekr.20181031045138.419">def mutate_dict(d, ev):
    """ Function to mutate an dict property in-place.
    Used by Component. The ``ev`` must be a dict with elements:

    * mutation: 'set', 'insert', 'remove' or 'replace'.
    * objects: the dict to set/insert/replace, or a list if keys to remove.
    * index: not used.
    """
    mutation = ev['mutation']
    objects = ev['objects']

    if mutation == 'set':
        d.clear()
    elif mutation in ('set', 'insert', 'replace'):
        assert isinstance(objects, dict)
        for key, val in objects.items():
            d[key] = val
    elif mutation == 'remove':
        assert isinstance(objects, (tuple, list))
        for key in objects:
            d.pop(key)
    else:
        raise NotImplementedError(mutation)


</t>
<t tx="ekr.20181031045138.42">def encode(self, s, v):
    raise NotImplementedError()

</t>
<t tx="ekr.20181031045138.420">def _mutate_array_py(array, ev):
    """ Function to mutate a list- or array-like property in-place.
    Used by Component. The ``ev`` must be a dict with elements:

    * mutation: 'set', 'insert', 'remove' or 'replace'.
    * objects: the values to set/insert/replace, or the number of iterms to remove.
    * index: the (non-negative) index to insert/replace/remove at.
    """
    is_nd = hasattr(array, 'shape') and hasattr(array, 'dtype')
    mutation = ev['mutation']
    index = ev['index']
    objects = ev['objects']

    if is_nd:
        if mutation == 'set':  # pragma: no cover
            raise NotImplementedError('Cannot set numpy array in-place')
        elif mutation in ('insert', 'remove'):  # pragma: no cover
            raise NotImplementedError('Cannot resize numpy arrays')
        elif mutation == 'replace':
            if isinstance(index, tuple):  # nd-replacement
                slices = tuple(slice(index[i], index[i] + objects.shape[i], 1)
                               for i in range(len(index)))
                array[slices] = objects
            else:
                array[index:index+len(objects)] = objects
    else:
        if mutation == 'set':
            array[:] = objects
        elif mutation == 'insert':
            array[index:index] = objects
        elif mutation == 'remove':
            assert isinstance(objects, int)  # objects must be a count in this case
            array[index:index+objects] = []
        elif mutation == 'replace':
            array[index:index+len(objects)] = objects
        else:
            raise NotImplementedError(mutation)


</t>
<t tx="ekr.20181031045138.421">def _mutate_array_js(array, ev):  # pragma: no cover
    """ Logic to mutate an list-like or array-like property in-place, in JS.
    """
    is_nd = hasattr(array, 'shape') and hasattr(array, 'dtype')
    mutation = ev.mutation
    index = ev.index
    objects = ev.objects

    if is_nd is True:
        if mutation == 'set':
            raise NotImplementedError('Cannot set nd array in-place')
        elif mutation in ('extend', 'insert', 'remove'):
            raise NotImplementedError('Cannot resize nd arrays')
        elif mutation == 'replace':
            raise NotImplementedError('Cannot replace items in nd array')
    else:
        if mutation == 'remove':
            assert isinstance(objects, float)  # objects must be a count in this case
        elif not isinstance(objects, list):
            raise TypeError('Inplace list/array mutating requires a list of objects.')
        if mutation == 'set':
            array.splice(0, len(array), *objects)
        elif mutation == 'insert':
            array.splice(index, 0, *objects)
        elif mutation == 'remove':
            array.splice(index, objects)
        elif mutation == 'replace':
            array.splice(index, len(objects), *objects)
        else:
            raise NotImplementedError(mutation)


mutate_array = _mutate_array_py
_mutate_dict_js = _mutate_dict_py = mutate_dict
</t>
<t tx="ekr.20181031045138.422">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.423">"""
Implementation of a dict class with attribute access.
"""

import re

try:  # pragma: no cover
    from collections import OrderedDict as _dict
except ImportError:
    _dict = dict


</t>
<t tx="ekr.20181031045138.424">def isidentifier(s):
    # http://stackoverflow.com/questions/2544972/
    if not isinstance(s, str):
        return False
    return re.match(r'^\w+$', s, re.UNICODE) and re.match(r'^[0-9]', s) is None


</t>
<t tx="ekr.20181031045138.425">class Dict(_dict):
    """ A dict in which the items can be get/set as attributes.

    This provides a lean way to represent structured data, and works
    well in combination with autocompletion. Keys can be anything that
    are otherwise valid keys, but keys that are not valid identifiers
    or that are methods of the dict class (e.g. 'items' or 'copy')
    can only be get/set in the classic way.

    Example:

    .. code-block:: python

        &gt;&gt; d = Dict(foo=3)
        &gt;&gt; d.foo
        3
        &gt;&gt; d['foo'] = 4
        &gt;&gt; d.foo
        4
        &gt;&gt; d.bar = 5
        &gt;&gt; d.bar
        5

    """

    __reserved_names__ = dir(_dict())  # Also from OrderedDict
    __pure_names__ = dir(dict())

    __slots__ = []

    @others
</t>
<t tx="ekr.20181031045138.426">def __repr__(self):
    identifier_items = []
    nonidentifier_items = []
    for key, val in self.items():
        if isidentifier(key):
            identifier_items.append('%s=%r' % (key, val))
        else:
            nonidentifier_items.append('(%r, %r)' % (key, val))
    if nonidentifier_items:
        return 'Dict([%s], %s)' % (', '.join(nonidentifier_items),
                                   ', '.join(identifier_items))
    else:
        return 'Dict(%s)' % (', '.join(identifier_items))

</t>
<t tx="ekr.20181031045138.427">def __getattribute__(self, key):
    try:
        return object.__getattribute__(self, key)
    except AttributeError:
        if key in self:
            return self[key]
        else:
            raise

</t>
<t tx="ekr.20181031045138.428">def __setattr__(self, key, val):
    if key in Dict.__reserved_names__:
        # Either let OrderedDict do its work, or disallow
        if key not in Dict.__pure_names__:  # pragma: no cover
            return _dict.__setattr__(self, key, val)
        else:
            raise AttributeError('Reserved name, this key can only ' +
                                 'be set via ``d[%r] = X``' % key)
    else:
        # if isinstance(val, dict): val = Dict(val) -&gt; no, makes a copy!
        self[key] = val

</t>
<t tx="ekr.20181031045138.429">def __dir__(self):
    names = [k for k in self.keys() if isidentifier(k)]
    return Dict.__reserved_names__ + names
</t>
<t tx="ekr.20181031045138.43">def decode(self, s, v):
    raise NotImplementedError()


</t>
<t tx="ekr.20181031045138.430">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.431">"""
Implements the emitter decorator, class and desciptor.
"""

import weakref

from ._action import BaseDescriptor


</t>
<t tx="ekr.20181031045138.432">def emitter(func):
    """ Decorator to turn a method of a Component into an
    :class:`Emitter &lt;flexx.event.Emitter&gt;`.

    An emitter makes it easy to emit specific events, and is also a
    placeholder for documenting an event.

    .. code-block:: python

        class MyObject(event.Component):

           @emitter
           def spam(self, v):
                return dict(value=v)

        m = MyObject()
        m.spam(42)  # emit the spam event

    The method being decorated can have any number of arguments, and
    should return a dictionary that represents the event to generate.
    The method's docstring is used as the emitter's docstring.
    """
    if not callable(func):
        raise TypeError('The event.emitter() decorator needs a function.')
    if getattr(func, '__self__', None) is not None:  # builtin funcs have __self__
        raise TypeError('Invalid use of emitter decorator.')
    return EmitterDescriptor(func, func.__name__, func.__doc__)


</t>
<t tx="ekr.20181031045138.433">class EmitterDescriptor(BaseDescriptor):
    """ Placeholder for documentation and easy emitting of the event.
    """

    @others
</t>
<t tx="ekr.20181031045138.434">def __init__(self, func, name, doc):
    self._func = func
    self._name = name
    self.__doc__ = self._format_doc('emitter', name, doc, func)

</t>
<t tx="ekr.20181031045138.435">def __get__(self, instance, owner):
    if instance is None:
        return self

    private_name = '_' + self._name + '_emitter'
    try:
        emitter = getattr(instance, private_name)
    except AttributeError:
        emitter = Emitter(instance, self._func, self._name, self.__doc__)
        setattr(instance, private_name, emitter)

    emitter._use_once(self._func)  # make super() work, see _action.py
    return emitter


</t>
<t tx="ekr.20181031045138.436">class Emitter:
    """ Emitter objects are wrappers around Component methods. They take
    care of emitting an event when called and function as a placeholder
    for documenting an event. This class should not be instantiated
    directly; use ``event.emitter()`` instead.
    """

    @others
</t>
<t tx="ekr.20181031045138.437">def __init__(self, ob, func, name, doc):
    assert callable(func)

    # Store func, name, and docstring (e.g. for sphinx docs)
    self._ob1 = weakref.ref(ob)
    self._func = func
    self._func_once = func
    self._name = name
    self.__doc__ = doc

</t>
<t tx="ekr.20181031045138.438">def __repr__(self):
    cname = self.__class__.__name__
    return '&lt;%s %r at 0x%x&gt;' % (cname, self._name, id(self))

</t>
<t tx="ekr.20181031045138.439">def _use_once(self, func):
    """ To support super().
    """
    self._func_once = func

</t>
<t tx="ekr.20181031045138.44">class ComplexExtension(Extension):

    name = 'c'
    cls = complex

    @others
</t>
<t tx="ekr.20181031045138.440">def __call__(self, *args):
    """ Emit the event.
    """
    func = self._func_once
    self._func_once = self._func
    ob = self._ob1()
    if ob is not None:
        ev = func(ob, *args)
        if ev is not None:
            ob.emit(self._name, ev)
</t>
<t tx="ekr.20181031045138.441">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
if __name__ == '__main__':

    # Testing ...
    from flexx import event

    class Foo(Component):

        __x = 3
        foo = event.StringProp('asd', settable=True)

        @event.action
        def do_bar(self, v=0):
            print(v)

        @event.reaction
        def react2foo(self):
            print(self.foo)

        def __xx(self):
            pass


    toprint = JS_EVENT  # or JS_LOOP JS_COMPONENT JS_EVENT
    print('-' * 80)
    print(toprint)
    print('-' * 80)
    print(len(toprint), 'of', len(JS_EVENT), 'bytes in total')  # 29546 before refactor
    print('-' * 80)

    print(create_js_component_class(Foo, 'Foo'))
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.442">"""
Implementation of flexx.event in JS via PScript.

In this module we compile the flexx event system to JavaScript. Most
code is generated by transpiling methods from the Python classes. This
module implements a JS variant of some classes to overload certain
behavior in JS. E.g. the JS implementation of the Component class has
some boilerplate code to create actions, reactions, emitters and
properties.

By reusing as much code as possible, we reduce maintencance costs, and
make it easier to realize that the Python and JS implementation of this
event system have the same API and behavior.

"""

import re
import sys
import json
import inspect

from pscript import JSString, RawJS, py2js
from pscript.parser2 import get_class_definition

from flexx.event import _property
from flexx.event._loop import Loop
from flexx.event._action import ActionDescriptor
from flexx.event._reaction import ReactionDescriptor, Reaction
from flexx.event._attribute import Attribute
from flexx.event._property import Property
from flexx.event._emitter import EmitterDescriptor
from flexx.event._component import Component, _mutate_array_js, _mutate_dict_js


Object = console = setTimeout = loop = logger = arguments = None  # fool pyflake
undefined = 'UNDEFINED'
reprs = json.dumps


</t>
<t tx="ekr.20181031045138.443">class MetaCollector:

    @others


## The JS class variants


# Easiest to implement this directly in JS
JS_LOGGER = """
var Logger = function () {
    this.level = 25;
}
var $Logger = Logger.prototype;
$Logger.debug = function (msg) {
    if (this.level &lt;= 10) { console.info(msg); }
};
$Logger.info = function (msg) {
    if (this.level &lt;= 20) { console.info(msg); }
};
$Logger.warn = function (msg) {
    if (this.level &lt;= 30) { console.warn(msg); }
};
$Logger.exception = function (msg) {
    console.error(msg);
};
$Logger.error = function (msg) {
    console.error(msg);
};
var logger = new Logger();
"""


</t>
<t tx="ekr.20181031045138.444">def __init__(self, cls=None):
    filename = None
    linenr = 1e9
    if cls is not None:
        filename = getattr(sys.modules[cls.__module__], '__file__', None)
        if hasattr(cls, '__linenr__'):
            linenr = cls.__linenr__
        else:
            try:
                linenr = inspect.findsource(cls)[1]
            except Exception:  # e.g. in the notebook
                pass
    self.meta = {'vars_unknown': set(), 'vars_global': set(),
                 'std_functions': set(), 'std_methods': set(),
                 'filename': filename, 'linenr': linenr}

</t>
<t tx="ekr.20181031045138.445">def py2js(self, *args, **kwargs):
    kwargs['inline_stdlib'] = False
    kwargs['docstrings'] = False
    code = py2js(*args, **kwargs)
    return self.update(code)

</t>
<t tx="ekr.20181031045138.446">def update(self, code):
    for key in self.meta:
        if key in ('filename', 'linenr'):
            continue
        self.meta[key].update(code.meta[key])
    return code

</t>
<t tx="ekr.20181031045138.447">def attach_meta(self, s):
    s = JSString(s)
    s.meta = self.meta
    return s
</t>
<t tx="ekr.20181031045138.448">class LoopJS:  # pragma: no cover
    """ JS variant of the Loop class.
    """

    # Hide a couple of methods
    integrate = undefined
    integrate_tornado = undefined
    integrate_pyqt4 = undefined
    integrate_pyside = undefined
    _integrate_qt = undefined
    _thread_match = undefined

    @others
</t>
<t tx="ekr.20181031045138.449">def __init__(self):
    self._active_components = []
    self.reset()

</t>
<t tx="ekr.20181031045138.45">def encode(self, s, v):
    return (v.real, v.imag)

</t>
<t tx="ekr.20181031045138.450">def _call_soon_func(self, func):
    setTimeout(func, 0)

</t>
<t tx="ekr.20181031045138.451">def _iter_callback(self):
    self._scheduled_call_to_iter = False
    return self.iter()


</t>
<t tx="ekr.20181031045138.452">class ComponentJS:  # pragma: no cover
    """ JS variant of the Component class.
    """

    _IS_COMPONENT = True
    _COUNT = 0
    _REACTION_COUNT = 0

    @others

## Compile functions

OK_MAGICS = (
             # Specific to Flexx
             '__attributes__', '__properties__', '__actions__',
             '__emitters__', '__reactions__', '__jsmodule__',
             # Functions that make sense
             '__init__', '__enter__', '__exit__',
             # For flexx.ui
             '__proxy_properties__',
             )


</t>
<t tx="ekr.20181031045138.453">def __init__(self, *init_args, **property_values):

    RawJS('Component.prototype._COUNT += 1')
    self._id = RawJS("this.__name__ + Component.prototype._COUNT")
    self._disposed = False

    # Init some internal variables
    self.__handlers = {}  # reactions connecting to this component
    self.__pending_events = []
    self.__anonymous_reactions = []
    self.__initial_mutation = False

    # Create actions
    for i in range(len(self.__actions__)):
        name = self.__actions__[i]
        self.__create_action(self[name], name)
    # Create emitters
    for i in range(len(self.__emitters__)):
        name = self.__emitters__[i]
        self.__handlers[name] = []
        self.__create_emitter(self[name], name)
    # Create properties
    for i in range(len(self.__properties__)):
        name = self.__properties__[i]
        self.__handlers[name] = []
        self.__create_property(name)
    # Create attributes
    for i in range(len(self.__attributes__)):
        name = self.__attributes__[i]
        self.__create_attribute(name)

    # With self as the active component (and thus mutatable), init the
    # values of all properties, and apply user-defined initialization
    with self:
        self._comp_init_property_values(property_values)
        self.init(*init_args)

    # Connect reactions and fire initial events
    self._comp_init_reactions()

</t>
<t tx="ekr.20181031045138.454">def _comp_init_property_values(self, property_values):
    values = []
    # First collect default property values (they come first)
    for i in range(len(self.__properties__)):
        name = self.__properties__[i]
        if name not in property_values:
            values.append((name, self['_' + name + '_value']))
    # Then collect user-provided values
    for name, value in property_values.items():  # is sorted by occurance in py36
        if name not in self.__properties__:
            if name in self.__attributes__:
                raise AttributeError('%s.%s is an attribute, not a property' %
                                     (self._id, name))
            else:
                raise AttributeError('%s does not have property %s.' %
                                     (self._id, name))
        if callable(value):
            self._comp_make_implicit_setter(name, value)
            continue
        values.append((name, value))
    # Then process all property values
    self._comp_apply_property_values(values)

</t>
<t tx="ekr.20181031045138.455">def _comp_make_implicit_setter(self, prop_name, func):
    setter_func = getattr(self, 'set_' + prop_name, None)
    if setter_func is None:
        t = '%s does not have a set_%s() action for property %s.'
        raise TypeError(t % (self._id, prop_name, prop_name))
    setter_reaction = lambda: setter_func(func())
    reaction = self.__create_reaction(setter_reaction,
                                      'auto-' + prop_name, 'auto', [])
    self.__anonymous_reactions.append(reaction)

</t>
<t tx="ekr.20181031045138.456">def _comp_init_reactions(self):
    if self.__pending_events is not None:
        self.__pending_events.append(None)  # marker
        loop.call_soon(self._comp_stop_capturing_events)

    # Create (and connect) reactions.
    # Implicit reactions need to be invoked to initialize connections.
    for i in range(len(self.__reactions__)):
        name = self.__reactions__[i]
        func = self[name]
        r = self.__create_reaction(func, name, func._mode,
                                   func._connection_strings or ())
        if r.get_mode() == 'auto':
            ev = dict(source=self, type='', label='')
            loop.add_reaction_event(r, ev)
    # Also invoke the anonymouse implicit reactions
    for i in range(len(self.__anonymous_reactions)):
        r = self.__anonymous_reactions[i]
        if r.get_mode() == 'auto':
            ev = dict(source=self, type='', label='')
            loop.add_reaction_event(r, ev)

</t>
<t tx="ekr.20181031045138.457">def reaction(self, *connection_strings):
    # The JS version (no decorator functionality)

    if len(connection_strings) &lt; 2:
        raise RuntimeError('Component.reaction() (js) needs a function and '
                           'one or more connection strings.')

    # Get callable
    if callable(connection_strings[0]):
        func = connection_strings[0]
        connection_strings = connection_strings[1:]
    elif callable(connection_strings[-1]):
        func = connection_strings[-1]
        connection_strings = connection_strings[:-1]
    else:
        raise TypeError('Component.reaction() requires a callable.')

    # Verify connection strings
    for i in range(len(connection_strings)):
        s = connection_strings[i]
        if not (isinstance(s, str) and len(s)):
            raise ValueError('Connection string must be nonempty strings.')

    # Get function name (Flexx sets __name__ on methods)
    name = RawJS("func.__name__ || func.name || 'anonymous'")
    # name = name.split(' ')[-1].split('flx_')[-1]
    nameparts = RawJS("name.split(' ')")
    nameparts = RawJS("nameparts[nameparts.length-1].split('flx_')")
    name = nameparts[-1]
    mode = 'normal'
    return self.__create_reaction_ob(func, name, mode, connection_strings)

</t>
<t tx="ekr.20181031045138.458">def __create_action(self, action_func, name):
    # Keep a ref to the action func, which is a class attribute. The object
    # attribute with the same name will be overwritten with the property below.
    # Because the class attribute is the underlying function, super() works.
    def action():  # this func should return None, so super() works correct
        if loop.can_mutate(self) is True:
            res = action_func.apply(self, arguments)
            if res is not None:
                logger.warn('Action (%s) is not supposed to return a value' % name)
        else:
            loop.add_action_invokation(action, arguments)
        return self
    action.is_autogenerated = action_func.name == 'flx_setter'  # also _action.py
    def getter():
        return action
    def setter(x):
        raise AttributeError('Action %s is not settable' % name)
    opts = {'enumerable': True, 'configurable': True,  # i.e. overloadable
            'get': getter, 'set': setter}
    Object.defineProperty(self, name, opts)

</t>
<t tx="ekr.20181031045138.459">def __create_attribute(self, name):
    def getter():
        return self['_' + name]
    def setter(x):
        raise AttributeError('Cannot set attribute %r' % name)
    opts = {'enumerable': False, 'configurable': False,
            'get': getter, 'set': setter}
    Object.defineProperty(self, name, opts)

</t>
<t tx="ekr.20181031045138.46">def decode(self, s, v):
    return complex(v[0], v[1])


</t>
<t tx="ekr.20181031045138.460">def __create_property(self, name):
    private_name = '_' + name + '_value'
    def getter():
        loop.register_prop_access(self, name)
        return self[private_name]
    def setter(x):
        raise AttributeError('Cannot set property %r; properties can only '
                             'be mutated by actions.' % name)
    opts = {'enumerable': True, 'configurable': True,  # i.e. overloadable
            'get': getter, 'set': setter}
    Object.defineProperty(self, name, opts)

</t>
<t tx="ekr.20181031045138.461">def __create_emitter(self, emitter_func, name):
    # Keep a ref to the emitter func, see comment in __create_action()
    def func():  # this func should return None, so super() works correct
        ev = emitter_func.apply(self, arguments)
        if ev is not None:
            self.emit(name, ev)
    def getter():
        return func
    def setter(x):
        raise AttributeError('Emitter %s is not settable' % name)
    opts = {'enumerable': True, 'configurable': True,  # i.e. overloadable
            'get': getter, 'set': setter}
    Object.defineProperty(self, name, opts)

</t>
<t tx="ekr.20181031045138.462">def __create_reaction(self, reaction_func, name, mode, c_strings):
    reaction = self.__create_reaction_ob(reaction_func, name, mode, c_strings)
    def getter():
        return reaction
    def setter(x):
        raise AttributeError('Reaction %s is not settable' % name)
    opts = {'enumerable': True, 'configurable': True,  # i.e. overloadable
            'get': getter, 'set': setter}
    Object.defineProperty(self, name, opts)
    return reaction

</t>
<t tx="ekr.20181031045138.463">def __create_reaction_ob(self, reaction_func, name, mode, connection_strings):
    # Keep ref to the reaction function, see comment in create_action().

    # Create function that becomes our "reaction object"
    def reaction():
        return reaction_func.apply(self, arguments)  # arguments == events

    # Attach methods to the function object (this gets replaced)
    REACTION_METHODS_HOOK  # noqa

    # Init reaction
    that = self
    RawJS("Component.prototype._REACTION_COUNT += 1")
    reaction._id = RawJS("'r' + Component.prototype._REACTION_COUNT")
    reaction._name = name
    reaction._mode = mode
    reaction._ob1 = lambda : that  # no weakref in JS
    reaction._init(connection_strings, self)

    return reaction


</t>
<t tx="ekr.20181031045138.464">def _create_js_class(PyClass, JSClass):
    """ Create the JS code for Loop, Reaction and Component based on their
    Python and JS variants.
    """
    mc = MetaCollector(PyClass)
    cname = PyClass.__name__
    # Start with our special JS version
    jscode = [mc.py2js(JSClass, cname)]
    jscode[0] = jscode[0].replace('}\n',
                                  '}\nvar $%s = %s.prototype;\n' % (cname, cname),
                                  1
                        ).replace('%s.prototype.' % cname,
                                  '$%s.' % cname)
    # Add the Python class methods
    for name, val in sorted(PyClass.__dict__.items()):
        nameok = name in OK_MAGICS or not name.startswith('__')
        if nameok and not hasattr(JSClass, name):
            if callable(val):
                jscode.append(mc.py2js(val, '$' + cname + '.' + name))
            elif name in OK_MAGICS:
                jscode.append('$' + cname + '.' + name + ' = ' + json.dumps(val))
    # Compose
    jscode = '\n'.join(jscode)
    # Add the reaction methods to component
    if PyClass is Component:
        code = '\n'
        for name, val in sorted(Reaction.__dict__.items()):
            if not name.startswith('__') and callable(val):
                code += mc.py2js(val, 'reaction.' + name, indent=1)[4:] + '\n'
        jscode = jscode.replace('REACTION_METHODS_HOOK', code)
    # Optimizations, e.g. remove threading lock context in Loop
    if PyClass is Loop:
        p = r"this\._lock\.__enter.+?try {(.+?)} catch.+?else.+?exit__.+?}"
        jscode= re.sub(p, r'{/* with lock */\1}', jscode, 0,
                       re.MULTILINE | re.DOTALL)
        jscode= re.sub(r'\$Loop\..+? = undefined;\n', r'', jscode, 0,
                       re.MULTILINE | re.DOTALL)
        jscode = jscode.replace('this._ensure_thread_', '//this._ensure_thread_')
        jscode = jscode.replace('threading.get_ident()', '0')
        jscode = jscode.replace('._local.', '.')
        jscode = jscode.replace('this._thread_match(true);\n', '')
        jscode = jscode.replace('if (_pyfunc_truthy(this._thread_match(false)))', '')
    # Almost done
    jscode = jscode.replace('new Dict()', '{}').replace('new Dict(', '_pyfunc_dict(')
    mc.meta['std_functions'].add('dict')
    return mc.attach_meta(jscode)


</t>
<t tx="ekr.20181031045138.465">def create_js_component_class(cls, cls_name, base_class='Component.prototype'):
    """ Create the JS equivalent of a subclass of the Component class.

    Given a Python class with actions, properties, emitters and reactions,
    this creates the code for the JS version of the class. It also supports
    class constants that are int/float/str, or a tuple/list thereof.
    The given class does not have to be a subclass of Component.

    This more or less does what ComponentMeta does, but for JS.
    """

    assert cls_name != 'Component'  # we need this special class above instead

    # Collect meta information of all code pieces that we collect
    mc = MetaCollector(cls)
    mc.meta['std_functions'].add('op_instantiate')  # b/c we use get_class_definition

    total_code = []
    funcs_code = []  # functions and emitters go below class constants
    const_code = []
    err = ('Objects on JS Component classes can only be int, float, str, '
           'or a list/tuple thereof. Not %s -&gt; %r.')

    total_code.append('\n'.join(get_class_definition(cls_name, base_class)).rstrip())
    prefix = '' if cls_name.count('.') else 'var '
    total_code[0] = prefix + total_code[0]
    prototype_prefix = '$' + cls_name.split('.')[-1] + '.'
    total_code.append('var %s = %s.prototype;' % (prototype_prefix[:-1], cls_name))

    # Process class items in original order or sorted by name if we cant
    class_items = cls.__dict__.items()
    if sys.version_info &lt; (3, 6):  # pragma: no cover
        class_items = sorted(class_items)

    for name, val in class_items:
        if isinstance(val, ActionDescriptor):
            # Set underlying function as class attribute. This is overwritten
            # by the instance, but this way super() works.
            funcname = name
            # Add function def
            code = mc.py2js(val._func, prototype_prefix + funcname)
            code = code.replace('super()', base_class)  # fix super
            # Tweak if this was an autogenerated action
            # we use flx_ prefixes to indicate autogenerated functions
            if val._func.__name__.startswith('flx_'):
                subname = name
                if name.startswith('set_') or name.startswith('_set_'):
                    subname = name[4:]
                code = code.replace("flx_name", "'%s'" % subname)
            code = code.replace('function (', 'function %s (' % val._func.__name__)
            funcs_code.append(code.rstrip())
            # Mark to not bind the func
            funcs_code.append(prototype_prefix + funcname + '.nobind = true;')
            funcs_code.append('')
        elif isinstance(val, ReactionDescriptor):
            funcname = name  # funcname is simply name, so that super() works
            # Add function def
            code = mc.py2js(val._func, prototype_prefix + funcname)
            code = code.replace('super()', base_class)  # fix super
            funcs_code.append(code.rstrip())
            # Mark to not bind the func
            funcs_code.append(prototype_prefix + funcname + '.nobind = true;')
            # Add mode and connection strings
            funcs_code.append(prototype_prefix + funcname +
                              '._mode = ' + reprs(val._mode))
            if val._connection_strings:
                funcs_code.append(prototype_prefix + funcname +
                                  '._connection_strings = ' +
                                  reprs(val._connection_strings))
            funcs_code.append('')
        elif isinstance(val, EmitterDescriptor):
            funcname = name
            # Add function def
            code = mc.py2js(val._func, prototype_prefix + funcname)
            code = code.replace('super()', base_class)  # fix super
            funcs_code.append(code.rstrip())
            # Mark to not bind the func
            funcs_code.append(prototype_prefix + funcname + '.nobind = true;')
            funcs_code.append('')
        elif isinstance(val, Attribute):
            pass
        elif isinstance(val, Property):
            # Mutator and validator functions are picked up as normal functions.
            # Set default value on class.
            default_val = json.dumps(val._default)
            t = '%s_%s_value = %s;'
            const_code.append(t % (prototype_prefix, name, default_val))
        elif isinstance(val, classmethod):
            pass  # ignore, like magics
        elif (name.startswith('__') and name not in OK_MAGICS and
                not name.endswith('_validate')):
            # These are only magics, since class attributes with double-underscores
            # have already been mangled. Note that we need to exclude validator
            # funcs of private properties though.
            pass
        elif (name.endswith('_validate') and hasattr(val, '__self__') and
                    isinstance(val.__self__, Property)):
            # Proxy the validator functions (not inline).
            prop_class = val.__self__.__class__
            mod_name_parts = prop_class.__module__.split('.')
            module_ns = sys.modules[cls.__module__].__dict__
            # Get canonical class name, included part of the module name, as
            # needed, depending on what names exist in the component module.
            prop_class_name = prop_class.__name__
            if prop_class_name not in module_ns:
                if 'flx' in module_ns and mod_name_parts[0] == 'flexx':
                    prop_class_name = 'flx.' + prop_class_name
                else:
                    for ip in reversed(range(0, len(mod_name_parts))):
                        if mod_name_parts[ip] in module_ns:
                            m = sys.modules['.'.join(mod_name_parts[:ip+1])]
                            if m is module_ns[mod_name_parts[ip]]:
                                for ip2 in range(ip, len(mod_name_parts)):
                                    m = sys.modules['.'.join(mod_name_parts[:ip2+1])]
                                    if getattr(m, prop_class_name, None) is prop_class:
                                        break
                                prop_class_name = ('.'.join(mod_name_parts[ip:ip2+1]) +
                                                   '.' + prop_class_name)
                                break
            # Create function that calls the _validate function
            t = ' = function (value) { return %s(value, %s, %s); }\n'
            code = prototype_prefix + name + t % (
                prop_class_name + '.prototype._validate',
                json.dumps(name[1:-9]),
                json.dumps(val.__self__._data))
            funcs_code.append(code)
            mc.meta['vars_unknown'].add(prop_class_name)
        elif callable(val):
            # Functions, including methods attached by the meta class
            code = mc.py2js(val, prototype_prefix + name)
            code = code.replace('super()', base_class)  # fix super
            if val.__name__.startswith('flx_'):
                subname = name[8:] if name.startswith('_mutate_') else name
                code = code.replace("flx_name", "'%s'" % subname)
            funcs_code.append(code.rstrip())
            funcs_code.append('')
        else:
            # Static simple (json serializable) attributes, e.g. __actions__ etc.
            try:
                serialized = json.dumps(val)
            except Exception as err:  # pragma: no cover
                raise ValueError('Attributes on JS Component class must be '
                                 'JSON compatible.\n%s' % str(err))
            const_code.append(prototype_prefix + name + ' = ' + serialized)

    if const_code:
        total_code.append('')
        total_code.extend(const_code)
    if funcs_code:
        total_code.append('')
        total_code.extend(funcs_code)
    total_code.append('')

    # Return string with meta info (similar to what py2js returns)
    mc.meta['vars_unknown'].discard('flx_name')
    return mc.attach_meta('\n'.join(total_code))


</t>
<t tx="ekr.20181031045138.466">def gen_prop_classes(mc):
    """ Generate stub Property classes with _validate() methods.
    """
    total_code = []
    # Add JS-specific base Property class
    total_code.append('var Property = function () {};')
    total_code.append('Property.prototype._validate = '
                      'function(value, name, data) {return value;};')
    # Add code for all other props
    names = ['Property']
    for name in dir(_property):
        val = getattr(_property, name)
        if isinstance(val, type) and issubclass(val, Property) and val is not Property:
            names.append(name)
            total_code.append(mc.py2js(val))
    # Add event.xx shortcuts for use without flexx.app's binding mechanics.
    total_code.append('var event = {}; // convenience "module emulator"')
    for name in names:
        total_code.append('event.%s = %s;' % (name, name))

    return '\n'.join(total_code)


# Generate the code
mc = MetaCollector()
JS_FUNCS = (mc.py2js(_mutate_array_js) + '\nvar mutate_array = _mutate_array_js;\n' +
            mc.py2js(_mutate_dict_js))
JS_LOOP = mc.update(_create_js_class(Loop, LoopJS)) + '\nvar loop = new Loop();\n'
JS_COMPONENT = mc.update(_create_js_class(Component, ComponentJS))
JS_PROP = gen_prop_classes(mc)
JS_EVENT = JS_FUNCS + JS_LOGGER + JS_LOOP + JS_COMPONENT + JS_PROP
JS_EVENT = mc.attach_meta(JS_EVENT.replace('    ', '\t'))
del mc
assert JS_LOOP.count('._scheduled_call_to_iter') &gt; 2  # prevent error after refactor


</t>
<t tx="ekr.20181031045138.467">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.468">"""
Implementation of Flexx' event loop based on asyncio.
"""

# Note: there are some unusual constructs here, such as ``if xx is True``.
# These are there to avoid inefficient JS code as this code is transpiled
# using PScript. This code is quite performance crirical.

import asyncio
import threading

from . import logger

</t>
<t tx="ekr.20181031045138.469">def this_is_js():
    return False


</t>
<t tx="ekr.20181031045138.47">class NDArrayExtension(Extension):

    name = 'ndarray'

    @others
standard_extensions = [ComplexExtension, NDArrayExtension]
</t>
<t tx="ekr.20181031045138.470">class Loop:
    """ The singleton Flexx event loop at ``flexx.event.loop``. This holds
    the queue of pending calls, actions, and reactions. These are queued
    separately to realize a consistent one-way data-flow. Further, this
    object keeps track of (per thread) active components (i.e. the components
    whose context manager is currently active).

    Users typically do not need to be aware of the loop object, as it is
    used internally by Flexx, though it can be useful during debugging.

    This event system integrates with Python's builtin asyncio system,
    configurable via ``Loop.integrate()``. This system can run in a separate
    thread, but there can be only one active flexx event loop per process.

    This object can also be used as a context manager; an event loop
    iteration takes place when the context exits.
    """

    @others
loop = Loop()
</t>
<t tx="ekr.20181031045138.471">def __init__(self):
    self._lock = threading.RLock()
    self._thread_id = threading.get_ident()
    # self._call_soon_func = lambda x: None

    # Keep track of a stack of "active" components for use within Component
    # context manager. We have one list for each thread. Note that we should
    # limit its use to context managers, and execution should never be
    # handed back to the event loop while inside a context.
    self._local = threading.local()
    self.reset()
    self.integrate()

</t>
<t tx="ekr.20181031045138.472">def reset(self):
    """ Reset the loop, purging all pending calls, actions and reactions.
    This is mainly intended for test-related code.
    """
    self._in_iter = False
    self._scheduled_call_to_iter = False

    self._processing_action = None
    self._processing_reaction = None
    self._prop_access = {}
    self._pending_calls = []
    self._pending_actions = []
    self._pending_reactions = []
    self._pending_reaction_ids = {}

</t>
<t tx="ekr.20181031045138.473">def has_pending(self):
    """ Get whether there are any pending actions, reactions, or calls.
    """
    return (len(self._pending_reactions) &gt; 0 or
            len(self._pending_actions) &gt; 0 or
            len(self._pending_calls) &gt; 0)

</t>
<t tx="ekr.20181031045138.474">def __enter__(self):
    return self

</t>
<t tx="ekr.20181031045138.475">def __exit__(self, type, value, traceback):
    self.iter()

</t>
<t tx="ekr.20181031045138.476">def can_mutate(self, component=None):
    """ Whether mutations can be done to the given component,
    and whether invoked actions on the component are applied directly.
    """
    # When there is an active component, only that one can be mutated
    # (so that behavior of an init() is the same regardless whether a
    # component is instantiated from an action), it must the current one.
    # Otherwise we must be in an action.
    active = self.get_active_component()
    if active is not None:
        return active is component
    else:
        return self._processing_action is not None

## Active components

</t>
<t tx="ekr.20181031045138.477">def get_active_components(self):
    """ Get a tuple that represents the stack of "active" components.
    Each thread has its own stack. Should only be used directly inside
    a Component context manager.
    """
    return tuple(self._local._active_components)

</t>
<t tx="ekr.20181031045138.478">def get_active_component(self):
    """ Get the currently "active" component (for this thread), or None.
    """
    if len(self._local._active_components) &gt; 0:
        return self._local._active_components[-1]

</t>
<t tx="ekr.20181031045138.479">def _activate_component(self, component):
    """ Friend method of Component. """
    self._local._active_components.append(component)

</t>
<t tx="ekr.20181031045138.48">def __init__(self):
    if 'numpy' in sys.modules:
        import numpy as np
        self.cls = np.ndarray

</t>
<t tx="ekr.20181031045138.480">def _deactivate_component(self, component):
    """ Friend method of Component. """
    top = self._local._active_components.pop(-1)
    if top is not component:
        raise RuntimeError('loop._deactivate_component: %s is not %s' %
                           (component.id, top and top.id))

## Adding to queues

</t>
<t tx="ekr.20181031045138.481">def _schedule_iter(self):
    # Make sure to call this with the lock
    if self._scheduled_call_to_iter is False:
        self._scheduled_call_to_iter = True
        self._call_soon_func(self._iter_callback)

</t>
<t tx="ekr.20181031045138.482">def call_soon(self, func, *args):
    """ Arrange for a callback to be called as soon as possible.
    The callback is called after ``call_soon()`` returns, when control
    returns to the event loop.

    This operates as a FIFO queue, callbacks are called in the order in
    which they are registered. Each callback will be called exactly once.

    Any positional arguments after the callback will be passed to
    the callback when it is called.

    This method is thread-safe: the callback will be called in the thread
    corresponding with the loop. It is therefore actually more similar to
    asyncio's ``call_soon_threadsafe()``.

    Also see ``asyncio.get_event_loop().call_soon()`` and
    ``asyncio.get_event_loop().call_later()``.
    """
    # We keep track of pending calls locally to our event system, which
    # gives more control, e.g. during testing.
    with self._lock:
        self._pending_calls.append((func, args))
        self._schedule_iter()

# def call_later(self, delay, func, *args)
# This would be nice, but we'd have to implement more sophisticated
# scheduling. Unless we'd just call asyncio's call_later, but I am
# reluctant to do that while this code is still more or less independent of
# asyncio.

</t>
<t tx="ekr.20181031045138.483">def add_action_invokation(self, action, args):
    """ Schedule the handling of an action. Automatically called when
    an action object is called.
    """
    with self._lock:
        self._pending_actions.append((action, args))
        self._schedule_iter()

</t>
<t tx="ekr.20181031045138.484">def add_reaction_event(self, reaction, ev):
    """ Schulde the handling of a reaction. Automatically called by
    components.
    """

    # In principal, the mechanics of adding items to the queue is not complex,
    # but this code is performance critical, so we apply several tricks
    # to make this code run fast.
    # _pending_reactions is a list of tuples (reaction, representing event, events)

    pending_reactions = self._pending_reactions

    mode = reaction.get_mode()


    with self._lock:
        self._thread_match(True)

        if mode == 'normal':
            # Normally, we try to consolidate the events by
            # appending the event to the existing item in the queue, but
            # we don't want to break the order, i.e. we can only skip over
            # events that are the same as the current. Each queue item has
            # a reference event to make this skipping more efficient.
            i = len(pending_reactions)
            while i &gt; 0:
                i -= 1
                ev2 = pending_reactions[i][1]  # representing event
                if pending_reactions[i][0] is reaction:
                    # We can simply append the event
                    pending_reactions[i][2].append(ev)
                    if not (ev2['source'] is ev['source'] and
                            ev2['type'] == ev['type']):
                        # Mark that the events are heterogeneous
                        pending_reactions[i][1] = {'source': None}
                    return
                # Only continue if all events of the next item match the current
                if not (ev2 is None or
                        (ev2['source'] is ev['source'] and ev2.type == ev.type)):
                    break

        else:
            # For greedy and auto reactions, we consolidate by not adding
            # to the queue if the corresponding reaction is already
            # present. We use _pending_reaction_ids for this.
            # We even omit the event objects themselves when we think they
            # don't matter (when the number of connection strings is zero).
            if reaction._id in self._pending_reaction_ids:
                if len(reaction._connections) &gt; 0:
                    self._pending_reaction_ids[reaction._id][2].append(ev)
                return

        # Add new item to queue
        if len(reaction._connections) &gt; 0:
            new_item = [reaction, ev, [ev]]
        else:
            new_item = [reaction, None, []]
        pending_reactions.append(new_item)
        self._pending_reaction_ids[reaction._id] = new_item

        self._schedule_iter()

</t>
<t tx="ekr.20181031045138.485">def register_prop_access(self, component, prop_name):
    """ Register access of a property, to keep track of automatic reactions.
    """
    # Notes on auto-reactions. Like any reactions, these are
    # connected to events, such that add_reaction_event() will get called
    # for the reaction when a property that the reaction uses changes.
    # This wil always result in the invokation of the reaction.
    #
    # During the invokation of a reaction, the register_prop_access()
    # method is used to track property access by the reaction. That way,
    # connections can be updated as needed.

    # Note that we use a dict here, but for the event reconnecting to
    # be efficient, the order of connections is imporant, so auto
    # reactions have really poor performance on Python &lt; 3.6
    # Make sure not to count access from other threads
    if self._processing_reaction is not None:
        if self._processing_reaction.get_mode() == 'auto':
            if self._thread_match(False):
                if component._id not in self._prop_access:
                    d = {}
                    self._prop_access[component._id] = component, d
                else:
                    d = self._prop_access[component._id][1]
                d[prop_name] = True

## Queue processing

</t>
<t tx="ekr.20181031045138.486">def _thread_match(self, fail):
    # Check that event loop is not run from multiple threads at once
    tid = threading.get_ident()
    if self._thread_id != tid:  # pragma: no cover
        if not fail:
            return False
        raise RuntimeError('Flexx is supposed to run a single event loop a once.')
    return True

</t>
<t tx="ekr.20181031045138.487">def _iter_callback(self):
    if threading.get_ident() != self._thread_id:
        return  # probably an old pending callback
    self._scheduled_call_to_iter = False
    self.iter()

# We need a way to run our own little event system, because we cannot do
# async in JavaScript. Therefore this is public, and therefore call_soon()
# invokations are queued locally instead of being delegated to asyncio.
</t>
<t tx="ekr.20181031045138.488">def iter(self):
    """ Do one event loop iteration; process pending calls,
    actions and reactions. These tree types of items are each queued
    in separate queues, and are handled in the aforementioned order.
    """
    with self._lock:
        self._thread_match(True)

    # Guard against inproper use
    if self._in_iter is True:
        raise RuntimeError('Cannot call flexx.event.loop.iter() while it '
                           'is processing.')

    self._in_iter = True
    try:
        self._process_calls()
        self._process_actions()
        self._process_reactions()
    finally:
        self._in_iter = False

</t>
<t tx="ekr.20181031045138.489">def _process_calls(self):
    """ Process pending function calls.
    """
    # Select pending
    with self._lock:
        self._thread_match(True)
        pending_calls = self._pending_calls
        self._pending_calls = []

    # Process
    for i in range(len(pending_calls)):
        func, args = pending_calls[i]
        try:
            func(*args)
        except Exception as err:
            logger.exception(err)

</t>
<t tx="ekr.20181031045138.49">def match(self, s, v):  # e.g. for nd arrays in JS
    return (hasattr(v, 'shape') and
            hasattr(v, 'dtype') and
            hasattr(v, 'tobytes'))

</t>
<t tx="ekr.20181031045138.490">def _process_actions(self, n=None):
    """ Process all (or just one) pending actions.
    """
    # Select pending
    with self._lock:
        self._thread_match(True)
        if n is None:
            pending_actions = self._pending_actions
            self._pending_actions = []
        else:
            pending_actions = self._pending_actions[:n]
            self._pending_actions = self._pending_actions[n:]

    # Process
    for i in range(len(pending_actions)):
        action, args = pending_actions[i]
        self._processing_action = action
        try:
            action(*args)
        except Exception as err:
            logger.exception(err)
        finally:
            self._processing_action = None

</t>
<t tx="ekr.20181031045138.491">def _process_reactions(self):
    """ Process all pending reactions.
    """
    # Select pending
    with self._lock:
        self._thread_match(True)
        pending_reactions = self._pending_reactions
        self._pending_reactions = []
        self._pending_reaction_ids = {}

    # Process
    for ir in range(len(pending_reactions)):
        reaction, _, events = pending_reactions[ir]
        # Call reaction
        if len(events) &gt; 0 or reaction.get_mode() == 'auto':
            self._prop_access = {}
            self._processing_reaction = reaction
            try:
                reaction(*events)
            except Exception as err:
                logger.exception(err)
            finally:
                self._processing_reaction = None
        # Reconnect auto reaction. The _update_implicit_connections()
        # method is pretty efficient if connections has not changed.
        try:
            if reaction.get_mode() == 'auto':
                connections = []
                for component_names in self._prop_access.values():
                    component = component_names[0]
                    for name in component_names[1].keys():
                        connections.append((component, name))
                reaction._update_implicit_connections(connections)
        except Exception as err:  # pragma: no cover
            logger.exception(err)
        finally:
            self._prop_access = {}

## Integration

</t>
<t tx="ekr.20181031045138.492">def integrate(self, loop=None, reset=True):
    """ Integrate the Flexx event system with the given asyncio
    event loop (or the default one). Also binds the event system
    to the current thread.

    From this point, any (pending) calls to the iter callback by the
    previous thread will be ignored.

    By calling this without calling reset(), it should be possible
    to hot-swap the system from one loop (and/or thread) to another
    (though this is currently not tested).
    """
    if loop is None:
        loop = asyncio.get_event_loop()
    with self._lock:
        self._thread_id = threading.get_ident()
        self._local._active_components = []
        self._call_soon_func = loop.call_soon_threadsafe
        self._call_soon_func(self._iter_callback)
        if reset:
            self.reset()


# Below is deprecated, but I leavae it here for a bit; we may want to
# revive some of it.
#
# def integrate(self, call_soon_func=None, raise_on_fail=True):
#     """ Integrate with an existing event loop system.
#
#     Params:
#         call_soon_func (func): a function that can be called to
#             schedule the calling of a given function. If not given,
#             will try to connect to Tornado or Qt event loop, but only
#             if either library is already imported.
#         raise_on_fail (bool): whether to raise an error when the
#             integration could not be performed.
#     """
#     if call_soon_func is not None:
#         if callable(call_soon_func):
#             self._call_soon_func = call_soon_func
#             self._call_soon_func(self.iter)
#         else:
#             raise ValueError('call_soon_func must be a function')
#     elif 'tornado' in sys.modules:  # pragma: no cover
#         self.integrate_tornado()
#     elif 'PyQt4.QtGui' in sys.modules:  # pragma: no cover
#         self.integrate_pyqt4()
#     elif 'PySide.QtGui' in sys.modules:  # pragma: no cover
#         self.integrate_pyside()
#     elif raise_on_fail:  # pragma: no cover
#         raise RuntimeError('Could not integrate flexx.event loop')
#
# def integrate_tornado(self):  # pragma: no cover
#     """ Integrate with tornado.
#     """
#     import tornado.ioloop
#     loop = tornado.ioloop.IOLoop.current()
#     self._call_soon_func = loop.add_callback
#     self._call_soon_func(self.iter)
#     logger.debug('Flexx event loop integrated with Tornado')
#
# def integrate_pyqt4(self):  # pragma: no cover
#     """ Integrate with PyQt4.
#     """
#     from PyQt4 import QtCore, QtGui
#     self._integrate_qt(QtCore, QtGui)
#     logger.debug('Flexx event loop integrated with PyQt4')
#
# def integrate_pyside(self):  # pragma: no cover
#     """ Integrate with PySide.
#     """
#     from PySide import QtCore, QtGui
#     self._integrate_qt(QtCore, QtGui)
#     logger.debug('Flexx event loop integrated with PySide')
#
# def _integrate_qt(self, QtCore, QtGui):  # pragma: no cover
#     from queue import Queue, Empty
#
#     class _CallbackEventHandler(QtCore.QObject):
#
#         def __init__(self):
#             QtCore.QObject.__init__(self)
#             self.queue = Queue()
#
#         def customEvent(self, event):
#             while True:
#                 try:
#                     callback, args = self.queue.get_nowait()
#                 except Empty:
#                     break
#                 try:
#                     callback(*args)
#                 except Exception as why:
#                     logger.warn('callback failed: {}:\n{}'.format(callback, why))
#
#         def postEventWithCallback(self, callback, *args):
#             self.queue.put((callback, args))
#             QtGui.qApp.postEvent(self, QtCore.QEvent(QtCore.QEvent.User))
#
#     _callbackEventHandler = _CallbackEventHandler()
#     self._call_soon_func = _callbackEventHandler.postEventWithCallback
#     self._call_soon_func(self.iter)


</t>
<t tx="ekr.20181031045138.493">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.494">"""
Implements the property class and subclasses.
"""

from ._loop import loop, this_is_js
from ._action import BaseDescriptor
from ._dict import Dict

undefined = None


</t>
<t tx="ekr.20181031045138.495">class Property(BaseDescriptor):
    """ Base property class. Properties are (readonly) attributes associated
    with :class:`Component &lt;flexx.event.Component&gt;` classes, which can be
    :func:`mutated &lt;flexx.event.Component._mutate&gt;` only by
    :class:`actions &lt;flexx.event.Action&gt;`.
    The base ``Property`` class can have any value, the subclasses
    validate/convert the value when it is mutated.

    Arguments:
        initial_value: The initial value for the property. If omitted,
            a default value is used (specific for the type of property).
        settable (bool): If True, a corresponding setter action is
            automatically created that can be used to set the property.
            Default False.
        doc (str): The documentation string for this property (optional).

    Example usage:

    .. code-block:: python

        class MyComponent(event.Component):

            foo = event.AnyProp(7, doc="A property that can be anything")
            bar = event.StringProp(doc='A property that can only be string')
            spam = event.IntProp(8, settable=True)

        &gt;&gt; c = MyComponent()
        &gt;&gt; c.set_spam(9)  # use auto-generated setter action

    One can also implement custom properties:

    .. code-block:: python

        class MyCustomProp(event.Property):
            ''' A property that can only be 'a', 'b' or 'c'. '''

            _default = 'a'

            def _validate(self, value, name, data):
                if value not in 'abc':
                    raise TypeError('MyCustomProp %r must be "a", "b" or "c".' % name)
                return value

    """

    _default = None
    _data = None  # Configurable data

    @others
</t>
<t tx="ekr.20181031045138.496">def __init__(self, *args, doc='', settable=False):
    self._consume_args(*args)
    # Set doc
    if not isinstance(doc, str):
        raise TypeError('event.Property() doc must be a string.')
    self._doc = doc
    # Set settable
    self._settable = bool(settable)

    self._set_name('anonymous_property')

</t>
<t tx="ekr.20181031045138.497">def _consume_args(self, *args):
    # Set initial value
    if len(args) &gt; 1:
        raise TypeError('event.Property() accepts at most 1 positional argument.')
    elif len(args) == 1:
        self._default = args[0]
        if callable(self._default):
            raise TypeError('event.Property() is not a decorator (anymore).')

</t>
<t tx="ekr.20181031045138.498">def _set_name(self, name):
    self._name = name  # or func.__name__
    self.__doc__ = self._format_doc(self.__class__.__name__, name, self._doc)

</t>
<t tx="ekr.20181031045138.499">def _set_data(self, data):
    # Callable in __init__
    self._data = data

</t>
<t tx="ekr.20181031045138.5">from .util.config import Config

config = Config('flexx', '~appdata/.flexx.cfg',

        # General
        log_level=('info', str, 'The log level to use (DEBUG, INFO, WARNING, ERROR)'),
        browser_stacktrace=(True, bool, 'Show server stack traces in browser window'),

        # flexx.app
        hostname=('localhost', str, 'The default hostname to serve apps.'),
        port=(0, int, 'The default port to serve apps. Zero means auto-select.'),
        host_whitelist=('', str, 'Comma separated list of allowed &lt;host&gt;:&lt;port&gt; '
                        'values to pass cross-origin checks.'),
        ws_timeout=(20, int, 'If the websocket is idle for this amount of seconds, '
                 'it is closed.'),
        ssl_certfile=('', str, 'The cert file for https server.'),
        ssl_keyfile=('', str, 'The key file for https server.'),
        cookie_secret=('flexx_secret', str, 'The secret key to encode cookies.'),

        # flexx.webruntime
        webruntime=('', str, 'The default web runtime to use. '
                    'Default is "app or browser".'),

        # tornado
        tornado_debug=('false', bool, 'Setting the tornado application debug flag '
                       'allows autoreload and other debugging features.'),
        )
</t>
<t tx="ekr.20181031045138.50">def encode(self, s, v):
    return dict(shape=v.shape,
                dtype=str(v.dtype),
                data=v.tobytes())

</t>
<t tx="ekr.20181031045138.500">def __set__(self, instance, value):
    t = 'Cannot set property %r; properties can only be mutated by actions.'
    raise AttributeError(t % self._name)

</t>
<t tx="ekr.20181031045138.501">def __get__(self, instance, owner):
    if instance is None:
        return self
    private_name = '_' + self._name + '_value'
    loop.register_prop_access(instance, self._name)
    return getattr(instance, private_name)

</t>
<t tx="ekr.20181031045138.502">def make_mutator(self):
    flx_name = self._name
    def flx_mutator(self, *args):
        return self._mutate(flx_name, *args)
    return flx_mutator

</t>
<t tx="ekr.20181031045138.503">def make_set_action(self):
    flx_name = self._name
    def flx_setter(self, *val):
        self._mutate(flx_name, val[0] if len(val) == 1 else val)
    return flx_setter

</t>
<t tx="ekr.20181031045138.504">def _validate_py(self, value):
    # Called from Python
    return self._validate(value, self._name, self._data)

</t>
<t tx="ekr.20181031045138.505">def _validate(self, value, name, data):
    return value


\\-4.## Basic properties

</t>
<t tx="ekr.20181031045138.506">class AnyProp(Property):
    """ A property that can be anything (like Property). Default None.
    """


</t>
<t tx="ekr.20181031045138.507">class BoolProp(Property):
    """ A property who's values are converted to bool. Default False.
    """

    _default = False

    @others
</t>
<t tx="ekr.20181031045138.508">def _validate(self, value, name, data):
    return bool(value)


</t>
<t tx="ekr.20181031045138.509">class TriStateProp(Property):
    """ A property who's values can be False, True and None.
    """

    _default = None

    @others
</t>
<t tx="ekr.20181031045138.51">def decode(self, s, v):
    try:
        import numpy as np
    except ImportError:
        return v
    a = np.frombuffer(v['data'], dtype=v['dtype'])
    a.shape = v['shape']
    return a


</t>
<t tx="ekr.20181031045138.510">def _validate(self, value, name, data):
    if value is None:
        return None
    return bool(value)


</t>
<t tx="ekr.20181031045138.511">class IntProp(Property):
    """ A propery who's values are integers. Floats and strings are converted.
    Default 0.
    """

    _default = 0

    @others
</t>
<t tx="ekr.20181031045138.512">def _validate(self, value, name, data):
    if (isinstance(value, (int, float)) or isinstance(value, bool) or
                                           isinstance(value, str)):
        return int(value)
    else:
        raise TypeError('Int property %r cannot accept %r.' % (name, value))


</t>
<t tx="ekr.20181031045138.513">class FloatProp(Property):
    """ A propery who's values are floats. Integers and strings are converted.
    Default 0.0.
    """

    _default = 0.0

    @others
</t>
<t tx="ekr.20181031045138.514">def _validate(self, value, name, data):
    if isinstance(value, (int, float)) or isinstance(value, str):
        return float(value)
    else:
        raise TypeError('Float property %r cannot accept %r.' % (name, value))


</t>
<t tx="ekr.20181031045138.515">class StringProp(Property):
    """ A propery who's values are strings. Default empty string.
    """

    _default = ''

    @others
</t>
<t tx="ekr.20181031045138.516">def _validate(self, value, name, data):
    if not isinstance(value, str):
        raise TypeError('String property %r cannot accept %r.' % (name, value))
    return value


</t>
<t tx="ekr.20181031045138.517">class TupleProp(Property):
    """ A propery who's values are tuples. In JavaScript the values are Array
    objects that have some of their methods disabled. Default empty tuple.
    """

    _default = ()

    @others
</t>
<t tx="ekr.20181031045138.518">def _validate(self, value, name, data):
    if not isinstance(value, (tuple, list)):
        raise TypeError('Tuple property %r cannot accept %r.' % (name, value))
    value = tuple(value)
    if this_is_js():  # pragma: no cover
        # Cripple the object so in-place changes are harder. Note that we
        # cannot prevent setting or deletion of items.
        value.push = undefined
        value.splice = undefined
        value.push = undefined
        value.reverse = undefined
        value.sort = undefined
    return value


</t>
<t tx="ekr.20181031045138.519">class ListProp(Property):
    """ A propery who's values are lists. Default empty list. The value is
    always copied upon setting, so one can safely provide an initial list.

    Warning: updating the list in-place (e.g. use ``append()``) will not
    trigger update events! In-place updates can be done via the
    :func:`_mutate &lt;flexx.event.Component._mutate&gt;` method.
    """

    _default = []

    @others
</t>
<t tx="ekr.20181031045138.52">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.520">def _validate(self, value, name, data):
    if not isinstance(value, (tuple, list)):
        raise TypeError('List property %r cannot accept %r.' % (name, value))
    return list(value)


</t>
<t tx="ekr.20181031045138.521">class DictProp(Property):
    """ A property who's values are dicts. Default empty dict. The value is
    always copied upon setting, so one can safely provide an initial dict.

    Warning: updating the dict in-place (e.g. use ``update()``) will not
    trigger update events! In-place updates can be done via the
    :func:`_mutate &lt;flexx.event.Component._mutate&gt;` method.
    """

    _default = {}

    @others
</t>
<t tx="ekr.20181031045138.522">def _validate(self, value, name, data):
    if not isinstance(value, dict):
        raise TypeError('Dict property %r cannot accept %r.' % (name, value))
    return value.copy()


</t>
<t tx="ekr.20181031045138.523">class ComponentProp(Property):
    """ A propery who's values are Component instances or None. Default None.
    """

    _default = None

    @others
</t>
<t tx="ekr.20181031045138.524">def _validate(self, value, name, data):
    if not (value is None or hasattr(value, '_IS_COMPONENT')):
        raise TypeError('Component property %r cannot accept %r.' % (name, value))
    return value

\\-4.## Advanced properties


</t>
<t tx="ekr.20181031045138.525">class FloatPairProp(Property):
    """ A property that represents a pair of float values, which can also be
    set using a scalar.
    """

    _default = (0.0, 0.0)

    @others
</t>
<t tx="ekr.20181031045138.526">def _validate(self, value, name, data):
    if not isinstance(value, (tuple, list)):
        value = value, value
    if len(value) != 2:
        raise TypeError('FloatPair property %r needs a scalar '
                        'or two values, not %i' % (name, len(value)))
    if not isinstance(value[0], (int, float)):
        raise TypeError('FloatPair %r 1st value cannot be %r.' % (name, value[0]))
    if not isinstance(value[1], (int, float)):
        raise TypeError('FloatPair %r 2nd value cannot be %r.' % (name, value[1]))
    value = float(value[0]), float(value[1])
    if this_is_js():  # pragma: no cover
        # Cripple the object so in-place changes are harder. Note that we
        # cannot prevent setting or deletion of items.
        value.push = undefined
        value.splice = undefined
        value.push = undefined
        value.reverse = undefined
        value.sort = undefined
    return value


</t>
<t tx="ekr.20181031045138.527">class EnumProp(Property):
    """ A property that represents a choice between a fixed set of (string) values.

    Useage: ``foo = EnumProp(['optionA', 'optionB', ...], 'default', ...)``.
    If no initial value is provided, the first option is used.
    """

    _default = ''

    @others
</t>
<t tx="ekr.20181031045138.528">def _consume_args(self, options, *args):
    if not isinstance(options, (list, tuple)):
        raise TypeError('EnumProp needs list of options')
    if not all([isinstance(i, str) for i in options]):
        raise TypeError('EnumProp options must be str')
    if not args:
        args = (options[0], )

    self._set_data([option.upper() for option in options])
    super()._consume_args(*args)

</t>
<t tx="ekr.20181031045138.529">def _validate(self, value, name, data):
    if not isinstance(value, str):
        raise TypeError('EnumProp %r value must be str.' % name)
    value = value.upper()
    if value.upper() not in data:
        raise ValueError('Invalid value for enum %r: %s' % (name, value))
    return value


</t>
<t tx="ekr.20181031045138.53">"""
Logic to run live tests.
"""

import gc
import sys
import time
import asyncio

from flexx.event import loop
from flexx import app

from flexx.event.both_tester import FakeStream, smart_compare


async def roundtrip(*sessions):
    """ Coroutine to await a roundtrip to all given sessions.
    """
    ok = []
    def up():
        ok.append(1)
    for session in sessions:
        session.call_after_roundtrip(up)
    # timeout = time.time() + 5.0
    while len(ok) &lt; len(sessions):
        await asyncio.sleep(0.02)
    loop.iter()


</t>
<t tx="ekr.20181031045138.530">class ColorProp(Property):
    """ A property that represents a color. The value is represented as a
    (dict-like) object that has the following attributes:

    * t: a 4-element tuple (RGBA) with values between 0 and 1.
    * css: a CSS string in the form 'rgba(r,g,b,a)'.
    * hex: a hex RGB color in the form '#rrggbb' (no transparency).
    * alpha: a scalar between 0 and 1 indicating the transparency.

    The color can be set using:

    * An object as described above.
    * A tuple (length 3 or 4) with floats between 0 and 1.
    * A hex RGB color like '#f00' or '#aa7711'.
    * A hex RGBA color like '#f002' or '#ff000022'.
    * A CSS string "rgb(...)" or "rgba(...)"
    * Simple Matlab-like names like 'k', 'w', 'r', 'g', 'b', etc.
    * A few common color names like 'red', 'yellow', 'cyan'.
    * Further, string colors can be prefixed with "light", "lighter",
      "dark" and "darker".
    * Setting to None or "" results in fully transparent black.
    """

    _default = '#000'  # Black

    @others
__all__ = []
for name, cls in list(globals().items()):
    if isinstance(cls, type) and issubclass(cls, Property):
        __all__.append(name)

del name, cls
</t>
<t tx="ekr.20181031045138.531">def _validate(self, value, name, data):

    # We first convert to a tuple, and then derive the other values ...
    val = value

    common_colors = {  # A set of Matlab/Matplotlib colors and small CSS subset
        "k": '#000000', "black": "#000000",
        "w": '#ffffff', "white": '#ffffff',
        "r": '#ff0000', "red": '#ff0000',
        "g": '#00ff00', "green": '#00ff00', "lime": "#00ff00",
        "b": '#0000ff', "blue": '#0000ff',
        "y": '#ffff00', "yellow": '#ffff00',
        "m": '#ff00ff', "magenta": '#ff00ff', "fuchsia": "#ff00ff",
        "c": '#00ffff', "cyan": "#00ffff", "aqua": "#00ffff",
        "gray": "#808080", "grey": "#808080",
        }
    common_colors[''] = '#0000'  # empty string resolves to alpha 0, like None
    M = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
         '8': 8, '9': 9, 'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15}
    Mi = '0123456789abcdef'

    # Convert from str
    if isinstance(val, str):
        val = val.lower()
        # Darker / lighter
        whitefactor = 0.0
        blackfactor = 0.0
        if val.startswith('darker'):
            blackfactor, val = 0.66, val[6:]
        elif val.startswith('dark'):
            blackfactor, val = 0.33, val[4:]
        elif val.startswith('lighter'):
            whitefactor, val = 0.66, val[7:]
        elif val.startswith('light'):
            whitefactor, val = 0.33, val[5:]
        # Map common colors
        val = common_colors.get(val, val)
        # Resolve CSS
        if val.startswith('#') and len(val) == 4 or len(val) == 5:
            val = [M.get(val[i], 0) * 17
                     for i in range(1, len(val), 1)]
        elif val.startswith('#') and len(val) == 7 or len(val) == 9:
            val = [M.get(val[i], 0) * 16 + M.get(val[i+1], 0)
                     for i in range(1, len(val), 2)]
        elif val.startswith('rgb(') or val.startswith('rgba('):
            val = [float(x.strip(' ,();')) for x in val[4:-1].split(',')]
            if len(val) == 4:
                val[-1] = val[-1] * 255
        else:
            raise ValueError('ColorProp %r got invalid color: %r' % (name, value))
        # All values above are in 0-255
        val = [v / 255 for v in val]
        # Pull towards black/white (i.e. darken or lighten)
        for i in range(3):
            val[i] = (1.0 - whitefactor) * val[i] + whitefactor
            val[i] = (1.0 - blackfactor) * val[i] + 0

    # More converts / checks
    if val is None:
        val = [0, 0, 0, 0]  # zero alpha
    elif isinstance(val, dict) and 't' in val:
        val = val['t']

    # By now, the value should be a tuple/list
    if not isinstance(val, (tuple, list)):
        raise TypeError('ColorProp %r value must be str or tuple.' % name)

    # Resolve to RGBA if RGB is given
    val = [max(min(float(v), 1.0), 0.0) for v in val]
    if len(val) == 3:
        val = val + [1.0]
    elif len(val) != 4:
        raise ValueError('ColorProp %r value must have 3 or 4 elements, not %i' %
                         (name, len(val)))

    # Wrap up the tuple value
    val = tuple(val)
    if this_is_js():  # pragma: no cover
        # Cripple the object so in-place changes are harder. Note that we
        # cannot prevent setting or deletion of items.
        val.push = undefined
        val.splice = undefined
        val.push = undefined
        val.reverse = undefined
        val.sort = undefined

    # Now compose final object
    if this_is_js():
        d = {}
    else:
        d = Dict()
    d.t = val
    d.alpha = val[3]
    hex = [int(c * 255) for c in val[:3]]
    d.hex = '#' + ''.join([Mi[int(c / 16)] + Mi[c % 16] for c in hex])
    d.css = 'rgba({:.0f},{:.0f},{:.0f},{:g})'.format(
        val[0]*255, val[1]*255, val[2]*255, val[3])
    return d


\\-4.# todo: For more complex stuff, maybe introduce an EitherProp, e.g. String or None.
\\-4.# EiterProp would be nice, like Bokeh has. Though perhaps its already fine if
\\-4.# props can be nullable. Note that people can also use AnyProp as a fallback.
\\-4.#
\\-4.# class NullProp(Property):
\\-4.#
\\-4.#     def _validate(self, value, name, data):
\\-4.#         if not value is None:
\\-4.#             raise TypeError('Null property can only be None.')
\\-4.#
\\-4.# class EitherProp(Property):
\\-4.#
\\-4.#     def __init__(self, *prop_classes, **kwargs):
\\-4.#         self._sub_classes = prop_classes
\\-4.#
\\-4.#     def _validate(self, value, name, data):
\\-4.#         for cls in self._sub_classes:
\\-4.#             try:
\\-4.#                 return cls._validate(self, value)
\\-4.#             except TypeError:
\\-4.#                 pass
\\-4.#             raise TypeError('This %s property cannot accept %s.' %
\\-4.#                             (self.__class__.__name__, value.__class__.__name__))

\\-4.# todo: more special properties
\\-4.# class Auto -&gt; Bokeh has special prop to indicate "automatic" value
\\-4.# class Date, DateTime
\\-4.# class Either
\\-4.# class Instance
\\-4.# class Array


</t>
<t tx="ekr.20181031045138.532">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.533">"""
Implements the reaction decorator, class and desciptor.
"""

# Note: there are some unusual constructs here, such as ``if xx is True``.
# These are there to avoid inefficient JS code as this code is transpiled
# using PScript. This code is quite performance crirical.

import weakref
import inspect

from ._loop import this_is_js
from ._action import BaseDescriptor
from ._dict import Dict
from . import logger


window = None
console = logger


</t>
<t tx="ekr.20181031045138.534">def looks_like_method(func):
    if hasattr(func, '__func__'):
        return False  # this is a bound method
    try:
        return inspect.getargspec(func)[0][0] in ('self', 'this')
    except (TypeError, IndexError):
        return False


</t>
<t tx="ekr.20181031045138.535">def reaction(*connection_strings, mode='normal'):
    """ Decorator to turn a method of a Component into a
    :class:`Reaction &lt;flexx.event.Reaction&gt;`.

    A reaction can be connected to multiple event types. Each connection
    string represents an event type to connect to.

    Also see the
    :func:`Component.reaction() &lt;flexx.event.Component.reaction&gt;` method.

    .. code-block:: py

        class MyObject(event.Component):

            @event.reaction('first_name', 'last_name')
            def greet(self, *events):
                print('hello %s %s' % (self.first_name, self.last_name))

    A reaction can operate in a few different modes. By not specifying any
    connection strings, the mode is "auto": the reaction will automatically
    trigger when any of the properties used in the function changes.
    See :func:`get_mode() &lt;flexx.event.Reaction.get_mode&gt;` for details.
    
    Connection string follow the following syntax rules:
    
    * Connection strings consist of parts separated by dots, thus forming a path.
      If an element on the path is a property, the connection will automatically
      reset when that property changes (a.k.a. dynamism, more on this below).
    * Each part can end with one star ('*'), indicating that the part is a list
      and that a connection should be made for each item in the list.
    * With two stars, the connection is made *recursively*, e.g. "children**"
      connects to "children" and the children's children, etc.
    * Stripped of '*', each part must be a valid identifier (ASCII).
    * The total string optionally has a label suffix separated by a colon. The
      label itself may consist of any characters.
    * The string can have a "!" at the very start to suppress warnings for
      connections to event types that Flexx is not aware of at initialization
      time (i.e. not corresponding to a property or emitter).
    
    An extreme example could be ``"!foo.children**.text:mylabel"``, which connects
    to the "text" event of the children (and their children, and their children's
    children etc.) of the ``foo`` attribute. The "!" is common in cases like
    this to suppress warnings if not all children have a ``text`` event/property.
    
    """
    if (not connection_strings):
        raise TypeError('reaction() needs one or more arguments.')

    # Validate mode parameter
    mode = mode or 'normal'  # i.e. allow None
    if not isinstance(mode, str):
        raise TypeError('Reaction mode must be a string.')
    mode = mode.lower()
    if mode not in ('normal', 'greedy', 'auto'):
        raise TypeError('Reaction mode must "normal", "greedy" or "auto".')

    # Extract function if we can
    func = None
    if len(connection_strings) == 1 and callable(connection_strings[0]):
        func = connection_strings[0]
        connection_strings = []

    for s in connection_strings:
        if not (isinstance(s, str) and len(s) &gt; 0):
            raise TypeError('Connection string must be nonempty strings.')

    def _connect(func):
        if not callable(func):
            raise TypeError('reaction() decorator requires a callable.')
        if not looks_like_method(func):
            raise TypeError('reaction() decorator requires a method '
                            '(first arg must be self).')
        return ReactionDescriptor(func, mode, connection_strings)

    if func is not None:
        return _connect(func)
    else:
        return _connect


</t>
<t tx="ekr.20181031045138.536">class ReactionDescriptor(BaseDescriptor):
    """ Class descriptor for reactions.
    """

    @others
</t>
<t tx="ekr.20181031045138.537">def __init__(self, func, mode, connection_strings, ob=None):
    self._name = func.__name__
    self._func = func
    self._mode = mode
    if len(connection_strings) == 0:
        self._mode = 'auto'
    self._connection_strings = connection_strings
    self._ob = None if ob is None else weakref.ref(ob)
    self.__doc__ = self._format_doc('reaction', self._name, func.__doc__)

</t>
<t tx="ekr.20181031045138.538">def __get__(self, instance, owner):
    if instance is None:
        return self

    private_name = '_' + self._name + '_reaction'
    try:
        reaction = getattr(instance, private_name)
    except AttributeError:
        reaction = Reaction(instance if self._ob is None else self._ob(),
                            (self._func, instance),
                            self._mode,
                            self._connection_strings)
        setattr(instance, private_name, reaction)

    # Make the reaction use *our* func one time. In most situations
    # this is the same function that the reaction has, but not when
    # using super(); i.e. this allows a reaction to call the same
    # reaction of its super class.
    reaction._use_once(self._func)
    return reaction

</t>
<t tx="ekr.20181031045138.539">@property
def local_connection_strings(self):
    """ List of connection strings that are local to the object.
    """
    # This is used in e.g. flexx.app
    return [s for s in self._connection_strings if '.' not in s]


</t>
<t tx="ekr.20181031045138.54">def launch(cls, *args, **kwargs):
    """ Shorthand for app.launch() that also returns session.
    """
    # from flexx import app
    c = app.App(cls, *args, **kwargs).launch('firefox-app')
    return c, c.session


</t>
<t tx="ekr.20181031045138.540">class Reaction:
    """ Reaction objects are wrappers around Component methods. They connect
    to one or more events. This class should not be instantiated directly;
    use ``event.reaction()`` or ``Component.reaction()`` instead.
    """

    _count = 0

    @others
</t>
<t tx="ekr.20181031045138.541">def __init__(self, ob, func, mode, connection_strings):
    Reaction._count += 1
    self._id = 'r%i' % Reaction._count  # to ensure a consistent event order

    # Store objects using a weakref.
    # - ob1 is the Component object of which the connect() method was called
    #   to create the reaction. Connection strings are relative to this object.
    # - ob2 is the object to be passed to func (if it is a method). Is often
    #   the same as ob1, but not per see. Can be None.
    self._ob1 = weakref.ref(ob)

    # Get unbounded version of bound methods.
    self._ob2 = None  # if None, its regarded a regular function
    if isinstance(func, tuple):
        self._ob2 = weakref.ref(func[1])
        func = func[0]
    if getattr(func, '__self__', None) is not None:  # builtin funcs have __self__
        if getattr(func, '__func__', None) is not None:
            self._ob2 = weakref.ref(func.__self__)
            func = func.__func__

    # Store func, name, and docstring (e.g. for sphinx docs)
    assert callable(func)
    assert mode in ('normal', 'greedy', 'auto')
    self._func = func
    self._func_once = func
    self._mode = mode
    self._name = func.__name__
    self.__doc__ = BaseDescriptor._format_doc('reaction', self._name, func.__doc__)

    self._init(connection_strings)

</t>
<t tx="ekr.20181031045138.542">def _init(self, connection_strings):
    """ Init of this reaction that is compatible with PScript.
    """

    ichars = '0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

    # Init explicit connections: (connection-object, type) tuples
    self._connections = []
    # Init implicit connections: (component, type) tuples
    self._implicit_connections = []

    # Notes on connection strings:
    # * The string can have a "!" at the start to suppress warnings for
    #   connections to unknown event types.
    # * The string can have a label suffix separated by a colon. The
    #   label may consist of any chars.
    # * Connection strings consist of parts separated by dots.
    # * Each part can end with one star ('*'), indicating that connections
    #   should be made for each item in the list, or two stars, indicating
    #   that connections should be made *recursively* for each item in the
    #   list (a.k.a. a deep connector).
    # * Stripped of '*', each part must be a valid identifier.
    # * An extreme example: "!foo.bar*.spam.eggs**:meh"
    for ic in range(len(connection_strings)):
        fullname = connection_strings[ic]
        # Separate label and exclamation mark from the string path
        force = fullname.startswith('!')
        s, _, label = fullname.lstrip('!').partition(':')
        s0 = s
        # Backwards compat: "foo.*.bar* becomes "foo*.bar"
        if '.*.' in s + '.':
            s = s.replace('.*', '*')
            console.warn('Connection string syntax "foo.*.bar" is deprecated, '
                         'use "%s" instead of "%s":.' % (s, s0))
        # Help put exclamation at the start
        if '!' in s:
            s = s.replace('!', '')
            force = True
            console.warn('Exclamation marks in connection strings must come at '
                         'the very start, use "!%s" instead of "%s".' % (s, s0))
        # Check that all parts are identifiers
        parts = s.split('.')
        for ipart in range(len(parts)):
            part = parts[ipart].rstrip('*')
            is_identifier = len(part) &gt; 0
            for i in range(len(part)):
                is_identifier = is_identifier and (part[i] in ichars)
            if is_identifier is False:
                raise ValueError('Connection string %r contains '
                                 'non-identifier part %r' % (s, part))
        # Init connection
        d = Dict()  # don't do Dict(foo=x) bc PScript only supports that for dict
        self._connections.append(d)
        d.fullname = fullname  # original, used in logs, so is searchable
        d.parts = parts
        d.type = parts[-1].rstrip('*') + ':' + (label or self._name)
        d.force = force
        d.objects = []

    # Connect
    for ic in range(len(self._connections)):
        self.reconnect(ic)

</t>
<t tx="ekr.20181031045138.543">def __repr__(self):
    c = '+'.join([str(len(c.objects)) for c in self._connections])
    cname = self.__class__.__name__
    t = '&lt;%s %r (%s) with %s connections at 0x%x&gt;'
    return t % (cname, self._name, self._mode, c, id(self))

</t>
<t tx="ekr.20181031045138.544">def get_mode(self):
    """ Get the mode for this reaction:

    * 'normal': events are handled in the order that they were emitted.
      Consequently, there can be multiple calls per event loop iteration
      if other reactions were triggered as well.
    * 'greedy': this reaction receives all its events (since the last event
      loop iteration) in a single call (even if this breaks the order of
      events with respect to other reactions). Use this when multiple related
      events must be handled simultenously (e.g. when syncing properties).
    * 'auto': this reaction tracks what properties it uses, and is
      automatically triggered when any of these properties changes. Like
      'greedy' there is at most one call per event loop iteration.
      Reactions with zero connection strings always have mode 'auto'.

    The 'normal' mode generally offers the most consistent behaviour.
    The 'greedy' mode allows the event system to make some optimizations.
    Combined with the fact that there is at most one call per event loop
    iteration, this can provide higher performance where it matters.
    Reactions with mode 'auto' can be a convenient way to connect things
    up. Although it allows the event system to make the same optimizations
    as 'greedy', it also needs to reconnect the reaction after each time
    it is called, which can degregade performance especially if many
    properties are accessed by the reaction.
    """
    return self._mode

</t>
<t tx="ekr.20181031045138.545">def get_name(self):
    """ Get the name of this reaction, usually corresponding to the name
    of the function that this reaction wraps.
    """
    return self._name

</t>
<t tx="ekr.20181031045138.546">def get_connection_info(self):
    """ Get a list of tuples (name, connection_names), where
    connection_names is a list of type names (including label) for
    the made connections.
    """
    return [(c.fullname, [u[1] for u in c.objects])
            for c in self._connections]

## Calling / handling

</t>
<t tx="ekr.20181031045138.547">def _use_once(self, func):
    self._func_once = func

</t>
<t tx="ekr.20181031045138.548">def __call__(self, *events):
    """ Call the reaction function.
    """
    func = self._func_once
    self._func_once = self._func
    if self._ob2 is not None:
        if self._ob2() is not None:
            res = func(self._ob2(), *events)
        else:  # pragma: no cover
            # We detected that the object that wants the events no longer exist
            self.dispose()
            return
    else:
        res = func(*events)
    return res

## Connecting

</t>
<t tx="ekr.20181031045138.549">def dispose(self):
    """ Disconnect all connections so that there are no more references
    to components.
    """
    if len(self._connections) == 0 and len(self._implicit_connections) == 0:
        return
    if not this_is_js():
        self._ob1 = lambda: None
        logger.debug('Disposing reaction %r ' % self)
    while len(self._implicit_connections):
        ob, type = self._implicit_connections.pop(0)
        ob.disconnect(type, self)
    for ic in range(len(self._connections)):
        connection = self._connections[ic]
        while len(connection.objects) &gt; 0:
            ob, type = connection.objects.pop(0)
            ob.disconnect(type, self)
    self._connections = []

</t>
<t tx="ekr.20181031045138.55">def filter_stdout(text):
    py_lines = []
    js_lines = []
    for line in text.strip().splitlines():
        if 'JS: ' in line:
            js_lines.append(line.split('JS: ', 1)[1])
        elif not line.startswith(('[I', '[D')):
            py_lines.append(line)
    return '\n'.join(py_lines), '\n'.join(js_lines)


</t>
<t tx="ekr.20181031045138.550">def _update_implicit_connections(self, connections):
    """ Update the list of implicit (i.e. automatic) connections.
    Used by the loop.
    """
    # Init - each connection is a (component, type) tuple
    old_conns = self._implicit_connections
    new_conns = connections
    self._implicit_connections = new_conns

    # Reconnect in a smart way
    self._connect_and_disconnect(old_conns, new_conns)

</t>
<t tx="ekr.20181031045138.551">def _clear_component_refs(self, ob):
    """ Clear all references to the given Component instance. This is
    called from a Component' dispose() method. This reaction remains
    working, but wont receive events from that object anymore.
    """
    for i in range(len(self._implicit_connections)-1, -1, -1):
        if self._implicit_connections[i][0] is ob:
            self._implicit_connections.pop(i)
    for ic in range(len(self._connections)):
        connection = self._connections[ic]
        for i in range(len(connection.objects)-1, -1, -1):
            if connection.objects[i][0] is ob:
                connection.objects.pop(i)

</t>
<t tx="ekr.20181031045138.552">def reconnect(self, index):
    """ (re)connect the index'th connection.
    """
    connection = self._connections[index]

    # Prepare disconnecting
    old_objects = connection.objects  # (ob, type) tuples
    connection.objects = []

    # Obtain root object and setup connections
    ob = self._ob1()
    if ob is not None:
        self._seek_event_object(index, connection.parts, ob)
    new_objects = connection.objects

    # Verify
    if len(new_objects) == 0:
        raise RuntimeError('Could not connect to %r' % connection.fullname)

    # Reconnect in a smart way
    self._connect_and_disconnect(old_objects, new_objects, connection.force)

</t>
<t tx="ekr.20181031045138.553">def _connect_and_disconnect(self, old_objects, new_objects, force=False):
    """ Update connections by disconnecting old and connecting new,
    but try to keep connections that do not change.
    """

    # Keep track of what connections we skip, i.e. which we should not remove.
    # Otherwise we may remove duplicate objects. See issue #460.
    should_stay = {}

    # Skip common objects from the start
    i1 = 0
    while (i1 &lt; len(new_objects) and i1 &lt; len(old_objects) and
           new_objects[i1][0] is old_objects[i1][0] and
           new_objects[i1][1] == old_objects[i1][1]):
        should_stay[new_objects[i1][0].id + '-' + new_objects[i1][1]] = True
        i1 += 1
    # Skip common objects from the end
    i2, i3 = len(new_objects) - 1, len(old_objects) - 1
    while (i2 &gt;= i1 and i3 &gt;= i1 and
           new_objects[i2][0] is old_objects[i3][0] and
           new_objects[i2][1] == old_objects[i3][1]):
        should_stay[new_objects[i2][0].id + '-' + new_objects[i2][1]] = True
        i2 -= 1
        i3 -= 1
    # Disconnect remaining old
    for i in range(i1, i3+1):
        ob, type = old_objects[i]
        if should_stay.get(ob.id + '-' + type, False) is False:
            ob.disconnect(type, self)
    # Connect remaining new
    for i in range(i1, i2+1):
        ob, type = new_objects[i]
        ob._register_reaction(type, self, force)

</t>
<t tx="ekr.20181031045138.554">def _seek_event_object(self, index, path, ob):
    """ Seek an event object based on the name (PScript compatible).
    The path is a list: the path to the event, the last element being the
    event type.
    """
    connection = self._connections[index]

    # Should we make connection or stop?
    if ob is None or len(path) == 0:
        return  # We cannot seek further
    if len(path) == 1:
        # Path only consists of event type now: make connection
        # connection.type consists of event type name (no stars) plus a label
        if hasattr(ob, '_IS_COMPONENT'):
            connection.objects.append((ob, connection.type))
        # Reached end or continue?
        if not path[0].endswith('**'):
            return

    # Resolve name
    obname_full, path = path[0], path[1:]
    obname = obname_full.rstrip('*')
    selector = obname_full[len(obname):]

    # Internally, 3-star notation is used for optional selectors
    if selector == '***':
        self._seek_event_object(index, path, ob)
    # Select object
    if hasattr(ob, '_IS_COMPONENT') and obname in ob.__properties__:
        name_label = obname + ':reconnect_' + str(index)
        connection.objects.append((ob, name_label))
        new_ob = getattr(ob, obname, None)
    else:
        new_ob = getattr(ob, obname, None)
    # Look inside?
    if len(selector) and selector in '***' and isinstance(new_ob, (tuple, list)):
        if len(selector) &gt; 1:
            path = [obname + '***'] + path  # recurse (avoid insert for space)
        for isub in range(len(new_ob)):
            self._seek_event_object(index, path, new_ob[isub])
        return
    elif selector == '*':  # "**" is recursive, so allow more
        t = "Invalid connection {name_full} because {name} is not a tuple/list."
        raise RuntimeError(t.replace("{name_full}", obname_full)
            .replace("{name}", obname))
    else:
        return self._seek_event_object(index, path, new_ob)
</t>
<t tx="ekr.20181031045138.555">@path C:/Anaconda3/Lib/site-packages/flexx/event/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.556">"""
The Flexx event system.
"""

import logging
logger = logging.getLogger(__name__)
del logging

import sys
assert sys.version_info &gt; (3, 5), "Flexx.event needs Python 3.5+"
del sys

# flake8: noqa
from ._dict import Dict
from ._loop import Loop, loop
from ._action import Action, action
from ._reaction import Reaction, reaction
from ._emitter import emitter, Emitter
from ._attribute import Attribute
from ._property import *
from ._component import Component, mutate_array, mutate_dict
</t>
<t tx="ekr.20181031045138.557"></t>
<t tx="ekr.20181031045138.558">@path C:/Anaconda3/Lib/site-packages/flexx/resources/
@others
if __name__ == '__main__':

    rgba = create_icon(48)

    import visvis as vv
    vv.figure(1)
    vv.clf()
    vv.imshow(rgba)

    create_icons()
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.559">"""
Simple script to generate Flexx' icon for different sizes.
"""

import os
import base64

import numpy as np

import flexx
from flexx.util.icon import Icon


# colors:
# (70, 140, 210) - Python blue
# (240, 80, 80) - a strong red


</t>
<t tx="ekr.20181031045138.56">def run_live(func):
    """ Decorator to run a live test.
    """

    def runner():
        # Run with a fresh server and loop
        loop.reset()
        #asyncio_loop = asyncio.get_event_loop()
        asyncio_loop = asyncio.new_event_loop()
        app.create_server(port=0, loop=asyncio_loop)

        print('running', func.__name__, '...', end='')
        orig_stdout = sys.stdout
        orig_stderr = sys.stderr
        fake_stdout = FakeStream()
        sys.stdout = sys.stderr = fake_stdout
        t0 = time.time()
        try:
            # Call function - it could be a co-routine
            cr = func()
            if asyncio.iscoroutine(cr):
                asyncio_loop.run_until_complete(cr)
            gc.collect()
        finally:
            sys.stdout = orig_stdout
            sys.stderr = orig_stderr

        # Clean up / shut down
        print('done in %f seconds' % (time.time()-t0))
        for appname in app.manager.get_app_names():
            if 'default' not in appname:
                sessions = app.manager.get_connections(appname)
                for session in sessions:
                    if session.app is not None:
                        session.app.dispose()
                        session.close()
        loop.reset()

        # Get reference text
        pyresult, jsresult = filter_stdout(fake_stdout.getvalue())
        reference = '\n'.join(line[4:] for line in func.__doc__.splitlines())
        parts = reference.split('-'*10)
        pyref = parts[0].strip(' \n')
        jsref = parts[-1].strip(' \n-')

        # Compare
        smart_compare(func, ('Python', pyresult, pyref),
                            ('JavaScript', jsresult, jsref))

    return runner
</t>
<t tx="ekr.20181031045138.560">def create_icon(N=16, COLOR=(240, 80, 80)):

    im = np.zeros((N, N), np.bool)

    row_index = [0, 1, 1, 1, 1, 0, 2, 2, 2, 2, 0, 3, 3, 3, 3, 0]
    col_index1 = [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    col_index2 = [0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0]
    col_index3 = [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0]
    col_index = None, col_index1, col_index2, col_index3


    # Create template image
    for y in range(N):
        for x in range(N):
            row16 = int(y * 16 / N)
            col16 = int(x * 16 / N)
            inrow = row_index[row16]

            if inrow:
                incol = col_index[inrow][col16]

                if incol:
                    im[y, x] = True

    im = np.flipud(im)  # images have y up

    # Colorize
    rgba = np.zeros((N, N, 4), np.uint8)
    for y in range(N):
        for x in range(N):
            if im[y, x]:
                rgba[y, x, :3] = COLOR
                rgba[y, x, 3] = 255
            elif im[max(0, y-1):y+2, max(0, x-1):x+2].any():
                factor = im[max(0, y-1):y+2, max(0, x-1):x+2].sum()
                rgba[y, x, :3] = COLOR
                rgba[y, x, :3] //= 2
                rgba[y, x, 3] = 64 * (0.66 if factor == 1 else 1)
            # else:
            #     rgba[y, x, :3] = 0, 0, 0
            #     rgba[y, x, 3] = 128

    return rgba


</t>
<t tx="ekr.20181031045138.561">def create_icons():
    icon = Icon()
    for n in (16, 32, 48, 64, 128, 256):
        icon.add(create_icon(n).tobytes())
    icon.write(os.path.join(flexx.__path__[0], 'resources', 'flexx.ico'))


</t>
<t tx="ekr.20181031045138.562">def create_silly_icon():

    im = np.zeros((16, 16, 4), 'uint8')
    im[3:-3, 3:-3] = 200
    im[:, :, 3] = 255

    icon = Icon()
    icon.add(im.tobytes())
    bb = icon._to_png(icon._ims[16])
    print(base64.encodebytes(bb).decode())


</t>
<t tx="ekr.20181031045138.563"></t>
<t tx="ekr.20181031045138.564">@path C:/Anaconda3/Lib/site-packages/flexx/ui/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.565">"""
Provides the base ``Widget`` class.

When subclassing a Widget to create a compound widget (i.e. a widget
that contains other widgets), initialize the child widgets inside the
``init()`` method. That method is called while the widget is the
*current widget*; any widgets instantiated inside it will automatically
become children.

.. UIExample:: 100

    from flexx import flx

    class Example(flx.Widget):
        def init(self):
            super().init()
            
            flx.Button(text='foo')
            flx.Button(text='bar')


One can also use a widget as a context manager (i.e. using the ``with``
statement) to create child widgets. This is particularly useful for
layout widgets (like ``HBox``).

.. UIExample:: 100

    from flexx import flx

    class Example(flx.Widget):
        def init(self):
            super().init()
            
            with flx.HBox():
                flx.Button(flex=1, text='foo')
                flx.Button(flex=2, text='bar')


It is possible to create custom low-level widgets by implementing
``_render_dom()``, resulting in a declarative "react-like" (but less
Pythonic) approach. It returns a virtual DOM that is used to update/replace
the real browser DOM.

.. UIExample:: 100

    from flexx import flx
    
    class Example(flx.Widget):
        
        count = flx.IntProp()
        
        def _render_dom(self):
            # This method automatically gets called when any of the used
            # properties (only count, in this case) changes.
            return flx.create_element('div', {}, 
                flx.create_element('button',
                                   {'onclick': self.increase_count},
                                   '+'),
                flx.create_element('span',
                                   {'style.background': '#afa'},
                                   str(self.count)),
                )
        
        @flx.action
        def increase_count(self):
            self._mutate_count(self.count + 1)

"""

from pscript import undefined, window

from ..event import loop
from .. import event, app

from . import logger  # noqa


</t>
<t tx="ekr.20181031045138.566">def create_element(type, props=None, *children):
    """ Convenience function to create a dictionary to represent
    a virtual DOM node. Intended for use inside ``Widget._render_dom()``.

    The content of the widget may be given as a series/list of child nodes
    (virtual or real), and strings. Strings are converted to text nodes. To
    insert raw HTML, use the ``innerHTML`` prop, but be careful not to
    include user-defined text, as this may introduce openings for XSS attacks.

    The returned dictionary has three fields: type, props, children.
    """
    if len(children) == 0:
        children = None  # i.e. don't touch children
    elif len(children) == 1 and isinstance(children[0], list):
        children = children[0]

    return dict(type=type,
                props=props or {},
                children=children,
                )


</t>
<t tx="ekr.20181031045138.567">class Widget(app.JsComponent):
    """ Base widget class (a :class:`Component &lt;flexx.event.Component&gt;` in JS wrapping
    an `HTML element &lt;https://developer.mozilla.org/docs/Web/HTML/Element&gt;`_).
    
    When subclassing a Widget, it is recommended to not implement the
    ``__init__()`` method, but instead implement ``init()`` for compound
    (higher-level) widgets, and ``_create_dom()`` for low-level widgets.
    
    Widgets can be styled using `CSS &lt;https://developer.mozilla.org/docs/Web/CSS&gt;`_
    by implementing a string class attribute named ``CSS``.
    A widget's node has a CSS-class-name corresponding to its Python class
    (and its base classes), following the scheme ``flx-WidgetClassName``.
    
    All widgets have a ``node`` and ``outernode`` attribute (only accessible
    in JavaScript), representing the 
    `DOM element(s) &lt;https://developer.mozilla.org/docs/Web/HTML/Element&gt;`_
    that represent the widget. For most types of widgets, ``node`` is
    equal to ``outernode``. For the ``Widget`` class, this is simply a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_
    element. If you don't understand what this is about, don't worry;
    you won't need it unless you are creating your own low-level widgets :)
    
    When implementing your own widget class, the class attribute
    ``DEFAULT_MIN_SIZE`` can be set to specify a sensible minimum size.
    
    """

    DEFAULT_MIN_SIZE = 0, 0

    CSS = """

    .flx-Widget {
        box-sizing: border-box;
        overflow: hidden;
        position: relative;  /* helps with absolute positioning of content */
    }

    /* Main widget to fill the whole page */
    .flx-main-widget {
       position: absolute;
       left: 0;
       right: 0;
       width: 100%;
       top: 0;
       bottom: 0;
       height: 100%;
    }

    /* to position children absolute */
    .flx-abs-children &gt; .flx-Widget {
        position: absolute;
    }

    /* Fix issue flexbox &gt; Widget &gt; layout on Chrome */
    .flx-Widget:not(.flx-Layout) &gt; .flx-Layout {
        position: absolute;
    }
    """

    ## Properties

    container = event.StringProp('', settable=True, doc="""
        The id of the DOM element that contains this widget if
        parent is None. Use 'body' to make this widget the root.
        """)

    parent = event.ComponentProp(None, doc="""
        The parent widget, or None if it has no parent. Setting
        this property will update the "children" property of the
        old and new parent.
        """)

    children = app.LocalProperty((), doc="""
        The child widgets of this widget. This property is not settable and
        only present in JavaScript.
        """)

    title = event.StringProp('', settable=True, doc="""
        The string title of this widget. This is used to mark
        the widget in e.g. a tab layout or form layout, and is used
        as the app's title if this is the main widget.
        """)

    icon = app.LocalProperty('', settable=False, doc="""
        The icon for this widget. This is used is some widgets classes,
        and is used as the app's icon if this is the main widget.
        It is settable from Python, but only present in JavaScript.
        """)

    css_class = event.StringProp('', settable=True, doc="""
        The extra CSS class name to asign to the DOM element.
        Spaces can be used to delimit multiple names. Note that the
        DOM element already has a css class-name corresponding to
        its class (e.g. 'flx-Widget) and all its superclasses.
        """)

    flex = event.FloatPairProp((0, 0), settable=True, doc="""
        How much space this widget takes (relative to the other
        widgets) when contained in a flexible layout such as HBox,
        HFix, HSplit or FormLayout. A flex of 0 means to take
        the minimum size. Flex is a two-element tuple, but both values
        can be specified at once by specifying a scalar.
        """)

    size = event.FloatPairProp((0, 0), settable=False, doc="""
        The actual size of the widget (readonly). Flexx tries to keep
        this value up-to-date, but in e.g. a box layout, a change in a
        Button's text can change the size of sibling widgets.
        """)

    minsize = event.FloatPairProp((0, 0), settable=True, doc="""
        The user-defined minimum size (width, height) of this widget in pixels.
        The default value differs per widget (``Widget.DEFAULT_MIN_SIZE``).
        Note that using "min-width" or "min-height" in ``apply_style()``.
        (and in the ``style`` kwarg) also set this property. Minimum sizes set
        in CSS are ignored.
        """)

    minsize_from_children = event.BoolProp(True, settable=True, doc="""
        Whether the children are taken into account to calculate this
        widget's size constraints. Default True: both the ``minsize``
        of this widget and the size constraints of its children (plus
        spacing and padding for layout widgets) are used to calculate
        the size constraints for this widget.

        Set to False to prevent the content in this widget to affect
        the parent's layout, e.g. to allow fully collapsing this widget
        when the parent is a splitter. If this widget has a lot of
        content, you may want to combine with ``style='overflow-y: auto'``.
        """)

    maxsize = event.FloatPairProp((1e9, 1e9), settable=True, doc="""
        The user-defined maximum size (width, height) of this widget in pixels.
        Note that using "max-width" or "max-height" in ``apply_style()``.
        (and in the ``style`` kwarg) also set this property. Maximum sizes set
        in CSS are ignored.
        """)

    _size_limits = event.TupleProp((0, 1e9, 0, 1e9), settable=True, doc="""
        A 4-element tuple (minWidth, maxWidth, minHeight, maxHeight) in pixels,
        based on ``minsize``, ``maxsize`` (and for some layouts the size limits
        of the children). Private prop for internal use.
        """)

    tabindex = event.IntProp(-2, settable=True, doc="""
        The index used to determine widget order when the user
        iterates through the widgets using tab. This also determines
        whether a widget is able to receive key events. Flexx automatically
        sets this property when it should emit key events.
        Effect of possible values on underlying DOM element:

        * -2: element cannot have focus unless its a special element like
            a link or form control (default).
        * -1: element can have focus, but is not reachable via tab.
        * 0: element can have focus, and is reachable via tab in the order
            at which the element is defined.
        * 1 and up: element can have focus, and the tab-order is determined
            by the value of tabindex.
        """)

    capture_mouse = event.IntProp(1, settable=True, doc="""
        To what extend the mouse is "captured".

        * If 0, the mouse is not captured, and move events are only emitted
          when the mouse is pressed down (not recommended).
        * If 1 (default) the mouse is captured when pressed down, so move
          and up events are received also when the mouse is outside the widget.
        * If 2, move events are also emitted when the mouse is not pressed down
          and inside the widget.
        """)

    @others
</t>
<t tx="ekr.20181031045138.568">@event.action
def set_icon(self, val):
    """ Set the icon for this widget. This is used is some widgets classes,
    and is used as the app's icon if this is the main widget.
    It is settable from Python, but the property is not available in Python.

    Can be a url, a relative url to a shared asset, or a base64
    encoded image. In the future this may also support names in
    icon packs like FontAwesome.
    """
    if not isinstance(val, str):
        raise TypeError('Icon must be a string')
    self._mutate_icon(val)

## Methods

</t>
<t tx="ekr.20181031045138.569">def __init__(self, *init_args, **kwargs):

    # Handle parent
    try:
        given_parent = parent = kwargs.pop('parent')
        parent_given = True
    except KeyError:
        given_parent = parent = None
        parent_given = False
    
    if parent is None:
        active_components = loop.get_active_components()
        for active_component in reversed(active_components):
            if isinstance(active_component, Widget):
                parent = active_component
                break
    # -&gt; we apply via set_parent below

    # Use parent session unless session was given
    if parent is not None and not kwargs.get('flx_session', None):
        kwargs['flx_session'] = parent.session

    # Allow initial styling via property-like mechanism
    style = kwargs.pop('style', '')

    # Whether this was the component that represents the app.
    # We use window.flexx.need_main_widget for a similar purpose,
    # but we might use it in the future.
    is_app = kwargs.get('flx_is_app', False)  # noqa

    # Init this component (e.g. create properties and actions)
    super().__init__(*init_args, **kwargs)

    # Some further initialization ...
    # Note that the _comp_init_property_values() will get called first.

    # Attach this widget in the widget hierarchy, if we can
    if parent_given:
        self.set_parent(given_parent)
    elif parent is not None:
        self.set_parent(parent)
    elif self.container == '':
        # Determine whether this should be the main widget. If the browser
        # seems to need one, and this is the first "orphan" widget to be
        # instantiated, this widget will take on this role.
        if window.flexx.need_main_widget:
            window.flexx.need_main_widget = False
            self.set_container('body')

    # Apply widget-specific default minsize if minsize is not given
    if kwargs.get('minsize', None) is None:
        self.set_minsize(self.DEFAULT_MIN_SIZE)

    # Apply style if given (can override minsize)
    if style:
        self.apply_style(style)

</t>
<t tx="ekr.20181031045138.57">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.570">def _comp_init_property_values(self, property_values):
    # This is a good time to do further initialization. The JsComponent
    # does its init here, property values have been set at this point,
    # but init() has not yet been called.

    super()._comp_init_property_values(property_values)

    # Create DOM nodes
    # outernode is the root node
    # node is an inner (representative) node, often the same, but not always
    nodes = self._create_dom()
    assert nodes is not None
    if not isinstance(nodes, list):
        nodes = [nodes]
    assert len(nodes) == 1 or len(nodes) == 2
    if len(nodes) == 1:
        self.outernode = self.node = self.__render_resolve(nodes[0])
    else:
        self.outernode = self.__render_resolve(nodes[0])
        self.node = self.__render_resolve(nodes[1])

    # Derive css class name from class hierarchy (needs self.outernode)
    cls = self.__class__
    for i in range(32):  # i.e. a safe while-loop
        self.outernode.classList.add('flx-' + cls.__name__)
        if cls is Widget.prototype:
            break
        cls = cls._base_class
    else:
        raise RuntimeError('Error determining class names for %s' % self.id)

    # Setup JS events to enter Flexx' event system (needs self.node)
    self._init_events()

</t>
<t tx="ekr.20181031045138.571">def init(self):
    """ Overload this to initialize a custom widget. It's preferred
    to use this instead of ``__init__()``, because it gets called
    at a better moment in the instantiation of the widget.
    
    This method receives any positional arguments that were passed
    to the constructor.  When called, this widget is the current parent.
    """
    # The Component class already implement a stub, but we may like a more
    # specific docstring here.
    pass

</t>
<t tx="ekr.20181031045138.572">def _create_dom(self):
    """ Create DOM node(s) for this widget.

    This method must return two (real or virtual) DOM nodes which
    will be available as ``self.outernode`` and ``self.node``
    respectively. If a single node is given, it is used for both
    values. These attributes must remain unchanged throughout the
    lifetime of a widget. This method can be overloaded in
    subclasses.
    """
    return create_element('div')

</t>
<t tx="ekr.20181031045138.573">def _render_dom(self):
    """ Update the content of the DOM for this widget.

    This method must return a DOM structure consisting of (a mix of)
    virtual nodes, real nodes and strings. The widget will use this
    structure to update the real DOM in a relatively efficient
    manner (new nodes are only (re)created if needed). The root
    element must match the type of this widget's outernode. This
    method may also return a list to apply as the root node's children.

    Note that this method is called from an implicit reaction: it will
    auto-connect to any properties that are accessed. Combined with the
    above, this allows for a very declarative way to write widgets.

    Virtual nodes are represented as dicts with fields "type", "props"
    and "children". Children is a list consisting of real dom nodes,
    virtual nodes, and strings. Strings are converted to TextNode (XSS safe).
    The ``create_element()`` function makes it easy to create virtual nodes.

    The default ``_render_dom()`` method simply places the outer node of
    the child widgets as the content of this DOM node, while preserving
    nodes that do not represent a widget. Overload as needed.
    """
    nodes = []
    for i in range(len(self.outernode.childNodes)):
        node = self.outernode.childNodes[i]
        if not (node.classList and node.classList.contains('flx-Widget')):
            nodes.append(node)
    for widget in self.children:
        nodes.append(widget.outernode)
    return nodes

</t>
<t tx="ekr.20181031045138.574">@event.reaction
def __render(self):
    # Call render method
    vnode = self._render_dom()
    # Validate output, allow it to return content instead of a vnode
    if vnode is None or vnode is self.outernode:
        return
    elif isinstance(vnode, list):
        vnode = dict(type=self.outernode.nodeName, props={}, children=vnode)
    elif isinstance(vnode, dict):
        if vnode.type.lower() != self.outernode.nodeName.lower():
            raise ValueError('Widget._render_dom() must return root node with '
                             'same element type as outernode.')
    else:
        raise TypeError('Widget._render_dom() '
                        'must return None, list or dict.')
    # Resolve
    node = self.__render_resolve(vnode, self.outernode)
    assert node is self.outernode

</t>
<t tx="ekr.20181031045138.575">def __render_resolve(self, vnode, node=None):
    """ Given a DOM node and its virtual representation,
    update or create a new DOM node as necessary.
    """

    # Check vnode (we check vnode.children further down)
    if vnode and vnode.nodeName:  # is DOM node
        return vnode
    elif isinstance(vnode, str):
        return window.document.createTextNode(vnode)
    elif not isinstance(vnode, dict):
        raise TypeError('Widget._render_dom() needs virtual nodes '
                        'to be dicts, not ' + vnode)
    if not isinstance(vnode.type, str):
        raise TypeError('Widget._render_dom() needs virtual node '
                        'type to be str, not ' + vnode.type)
    if not isinstance(vnode.props, dict):
        raise TypeError('Widget._render_dom() needs virtual node '
                        'props as dict, not ' + vnode.props)

    # Resolve the node itself
    if node is None or node.nodeName.lower() != vnode.type.lower():
        node = window.document.createElement(vnode.type)

    # Resolve props (i.e. attributes)
    map = {'css_class': 'className', 'class': 'className'}
    for key, val in vnode.props.items():
        ob = node
        parts = key.replace('__', '.').split('.')
        for i in range(len(parts)-1):
            ob = ob[parts[i]]
        key = parts[len(parts)-1]
        ob[map.get(key, key)] = val

    # Resolve content
    if vnode.children is None:
        pass  # dont touch it
    elif isinstance(vnode.children, list):
        # Truncate children
        while len(node.childNodes) &gt; len(vnode.children):
            node.removeChild(node.childNodes[len(node.childNodes)-1])
        # Resolve children
        i1 = -1
        for i2 in range(len(vnode.children)):
            i1 += 1
            vsubnode = vnode.children[i2]
            subnode = None
            if i1 &lt; len(node.childNodes):
                subnode = node.childNodes[i1]
                if subnode.nodeName == "#text" and isinstance(vsubnode, str):
                    if subnode.data != vsubnode:
                        subnode.data = vsubnode
                    continue  # early exit for text nodes
            new_subnode = self.__render_resolve(vsubnode, subnode)
            if subnode is None:
                node.appendChild(new_subnode)
            elif subnode is not new_subnode:
                node.insertBefore(new_subnode, subnode)
                node.removeChild(subnode)
    else:
        window.flexx_vnode = vnode
        raise TypeError('Widget._render_dom() '
                        'needs virtual node children to be None or list, not %s' %
                        vnode.children)

    return node

# Note that this method is only present at the Python side
# (because the JsComponent meta class makes it so).
</t>
<t tx="ekr.20181031045138.576">def _repr_html_(self):
    """ This is to get the widget shown inline in the notebook.
    """
    if self.container:
        return "&lt;i&gt;Th widget %s is already shown in this notebook&lt;/i&gt;" % self.id

    container_id = self.id + '_container'
    self.set_container(container_id)
    return "&lt;div class='flx-container' id='%s' /&gt;" % container_id

</t>
<t tx="ekr.20181031045138.577">def dispose(self):
    """ Overloaded version of dispose() that disposes any child widgets.
    """
    # Dispose children? Yes, each widget can have exactly one parent and
    # when that parent is disposed, it makes sense to assume that the
    # child ought to be disposed as well. It avoids memory leaks. If a
    # child is not supposed to be disposed, the developer should orphan the
    # child widget.
    children = self.children
    # First dispose children (so they wont send messages back), then clear
    # the children and dispose ourselves.
    for child in children:
        child.dispose()
    super().dispose()
    self.set_parent(None)
    self._children_value = ()

## Actions


</t>
<t tx="ekr.20181031045138.578">@event.action
def apply_style(self, style):
    """ Apply CSS style to this widget object. e.g.
    ``"background: #f00; color: #0f0;"``. If the given value is a
    dict, its key-value pairs are converted to a CSS style string.

    Initial styling can also be given in a property-like fashion:
    ``MyWidget(style='background:red;')``

    For static styling it is often better to define a CSS class attribute
    and/or use ``css_class``.
    """
    if isinstance(style, dict):
        style = ['%s: %s' % (k, v) for k, v in style.items()]
        style = '; '.join(style)

    # self.node.style = style  # forbidden in strict mode,
    # plus it clears all previously set style

    # Note that styling is applied to the outer node, just like
    # the styling defined via the CSS attribute. In most cases
    # the inner and outer node are the same, but not always
    # (e.g. CanvasWidget).

    # Set style elements, keep track in a dict
    d = {}
    if style:
        for part in style.split(';'):
            if ':' in part:
                key, val = part.split(':')
                key, val = key.trim(), val.trim()
                self.outernode.style[key] = val
                d[key] = val

    # Did we change style related to sizing?
    w1, h1 = self.minsize
    w2, h2 = self.maxsize
    mima = w1, w2, h1, h2
    size_limits_keys = 'min-width', 'max-width', 'min-height', 'max-height'
    size_limits_changed = False
    for i in range(4):
        key = size_limits_keys[i]
        if key in d:
            val = d[key]
            if val == '0':
                mima[i] = 0
                size_limits_changed = True
            elif val.endswith('px'):
                mima[i] = float(val[:-2])
                size_limits_changed = True

    if size_limits_changed:
        self.set_minsize((mima[0], mima[2]))
        self.set_maxsize((mima[1], mima[3]))

## Reactions

</t>
<t tx="ekr.20181031045138.579">@event.reaction('css_class')
def __css_class_changed(self, *events):
    if len(events):
        # Reset / apply explicitly given class name (via the prop)
        for cn in events[0].old_value.split(' '):
            if cn:
                self.outernode.classList.remove(cn)
        for cn in events[-1].new_value.split(' '):
            if cn:
                self.outernode.classList.add(cn)

</t>
<t tx="ekr.20181031045138.58">"""
Definition of the App class and app manager.
"""

import os
import io
import time
import weakref
import zipfile
from base64 import encodestring as encodebytes

import webruntime

from .. import config, event

from ._component2 import PyComponent, JsComponent
from ._server import current_server
from ._session import Session, get_page_for_export
from ._assetstore import assets
from . import logger


</t>
<t tx="ekr.20181031045138.580">@event.reaction('title')
def __title_changed(self, *events):
    if self.parent is None and self.container == 'body':
        window.document.title = self.title or 'Flexx app'

</t>
<t tx="ekr.20181031045138.581">@event.reaction('icon')
def __icon_changed(self, *events):
    if self.parent is None and self.container == 'body':
        window.document.title = self.title or 'Flexx app'

        link = window.document.createElement('link')
        oldLink = window.document.getElementById('flexx-favicon')
        link.id = 'flexx-favicon'
        link.rel = 'shortcut icon'
        link.href = events[-1].new_value
        if oldLink:
            window.document.head.removeChild(oldLink)
        window.document.head.appendChild(link)

</t>
<t tx="ekr.20181031045138.582">@event.reaction
def __update_tabindex(self, *events):
    # Note that this also makes the widget able to get focus, and thus
    # able to do key events.
    ti = self.tabindex
    if ti &lt; -1:
        self.node.removeAttribute('tabIndex')
    else:
        self.node.tabIndex = ti

# Now solved with CSS, which seems to work, but leaving this code for now ...
# @event.reaction('children', '!children*.mode', '!children*.orientation')
# def __make_singleton_container_widgets_work(self, *events):
#     classNames = self.outernode.classList
#     if not classNames.contains('flx-Layout'):
#         # classNames.remove('flx-box')
#         # classNames.remove('flx-horizontal')
#         # classNames.remove('flx-vertical')
#         classNames.remove('flx-abs-children')
#         children = self.children
#         if len(children) == 1:
#             subClassNames = children[0].outernode.classList
#             if subClassNames.contains('flx-Layout'):
#                 classNames.add('flx-abs-children')
#             # This seems to be enough, though previously we did:
#             # if subClassNames.contains('flx-box'):
#             #     # classNames.add('flx-box')
#             #     vert = subClassNames.contains('flx-vertical')
#             #     classNames.add('flx-horizontal' if vert else 'flx-horizontal')
#             # else:
#             #     # If child is a layout that uses absolute position, make
#             #     # out children absolute.
#             #     for name in ('split', 'StackPanel', 'TabPanel', 'DockPanel'):
#             #         if subClassNames.contains('flx-' + name):
#             #             classNames.add('flx-abs-children')
#             #             break

## Sizing

</t>
<t tx="ekr.20181031045138.583">@event.reaction
def _update_minmaxsize(self):
    """ Update the internal _size_limits.
    Note that this is an implicit reaction.
    """
    # Get new limits
    w1, w2, h1, h2 = self._query_min_max_size()
    w1 = max(0, w1)
    h1 = max(0, h1)
    # Update the property, so that our parent may react
    self._set_size_limits((w1, w2, h1, h2))
    # Update the style, so that flexbox works
    s = self.outernode.style
    s['min-width'] = w1 + 'px'
    s['max-width'] = w2 + 'px'
    s['min-height'] = h1 + 'px'
    s['max-height'] = h2 + 'px'

</t>
<t tx="ekr.20181031045138.584">def _query_min_max_size(self):
    """Can be overloaded in subclasses to include the minsize and maxsize of
    children. Note that this is called from an implicit reaction.
    """
    w1, h1 = self.minsize
    w2, h2 = self.maxsize

    # Widgets that are custom classes containing a single layout propagate
    # that layout's limits
    if self.outernode.classList.contains('flx-Layout') is False:
        if self.minsize_from_children is True and len(self.children) == 1:
            child = self.children[0]
            if child.outernode.classList.contains('flx-Layout') is True:
                w3, w4, h3, h4 = child._query_min_max_size()
                w1, w2 = max(w1, w3), min(w2, w4)
                h1, h2 = max(h1, h3), min(h2, h4)

    return w1, w2, h1, h2

</t>
<t tx="ekr.20181031045138.585">@event.action
def check_real_size(self):
    """ Check whether the current size has changed. It should usually not
    be necessary to invoke this action, since a widget does so by itself,
    but it some situations the widget may not be aware of possible size
    changes.
    """
    n = self.outernode
    cursize = self.size
    if cursize[0] != n.clientWidth or cursize[1] != n.clientHeight:
        self._mutate_size([n.clientWidth, n.clientHeight])

</t>
<t tx="ekr.20181031045138.586">@event.reaction('container', 'parent.size', 'children')
def __size_may_have_changed(self, *events):
    # Invoke actions, i.e. check size in *next* event loop iter to
    # give the DOM a chance to settle.
    self.check_real_size()

</t>
<t tx="ekr.20181031045138.587">def _set_size(self, prefix, w, h):
    """ Method to allow setting size (via style). Used by some layouts.
    """
    size = w, h
    for i in range(2):
        if size[i] &lt;= 0 or size is None or size is undefined:
            size[i] = ''  # Use size defined by CSS
        elif size[i] &gt; 1:
            size[i] = size[i] + 'px'
        else:
            size[i] = size[i] * 100 + '%'
    self.outernode.style[prefix + 'width'] = size[0]
    self.outernode.style[prefix + 'height'] = size[1]

## Parenting

</t>
<t tx="ekr.20181031045138.588">@event.action
def set_parent(self, parent, pos=None):
    """ Set the parent widget (can be None). This action also mutates the
    childen of the old and new parent.
    """
    old_parent = self.parent  # or None
    new_parent = parent

    # Early exit
    if new_parent is old_parent and pos is None:
        return
    if not (new_parent is None or isinstance(new_parent, Widget)):
        raise ValueError('%s.parent must be a Widget or None' % self.id)

    # Apply parent
    self._mutate_parent(new_parent)

    # Remove ourselves
    if old_parent is not None:
        children = list(old_parent.children)
        while self in children:
            children.remove(self)
        if old_parent is not new_parent:
            old_parent._mutate_children(children)

    # Insert ourselves
    if new_parent is not None:
        if old_parent is not new_parent:
            children = list(new_parent.children)
        while self in children:
            children.remove(self)
        if pos is None:
            children.append(self)
        elif pos &gt;= 0:
            children.insert(pos, self)
        elif pos &lt; 0:
            children.append(None)
            children.insert(pos, self)
            children.pop(-1)
        else:  # maybe pos is nan for some reason
            children.append(None)
        new_parent._mutate_children(children)

</t>
<t tx="ekr.20181031045138.589">@event.reaction('container')
def __container_changed(self, *events):
    id = self.container
    self.outernode.classList.remove('flx-main-widget')
    if self.parent:
        return

    # Let session keep us up to date about size changes
    self._session.keep_checking_size_of(self, bool(id))

    if id:
        if id == 'body':
            el = window.document.body
            self.outernode.classList.add('flx-main-widget')
            window.document.title = self.title or 'Flexx app'
        else:
            el = window.document.getElementById(id)
            if el is None:  # Try again later
                window.setTimeout(self.__container_changed, 100)
                return
        el.appendChild(self.outernode)

</t>
<t tx="ekr.20181031045138.59">class ExporterWebSocketDummy:
    """ Object that can be used by an app inplace of the websocket to
    export apps to standalone HTML. The object tracks the commands send
    by the app, so that these can be re-played in the exported document.
    """
    close_code = None

    @others
</t>
<t tx="ekr.20181031045138.590">def _release_child(self, widget):
    """ Overload to restore a child widget, e.g. to its normal style.
    """
    pass

## Events

# todo: events: focus, enter, leave ... ?

</t>
<t tx="ekr.20181031045138.591">def _registered_reactions_hook(self):
    event_types = super()._registered_reactions_hook()
    if self.tabindex &lt; -1:
        for event_type in event_types:
            if event_type in ('key_down', 'key_up', 'key_press'):
                self.set_tabindex(-1)
    return event_types

</t>
<t tx="ekr.20181031045138.592">def _init_events(self):
    # Connect some standard events
    self._addEventListener(self.node, 'wheel', self.pointer_wheel, 0)
    self._addEventListener(self.node, 'keydown', self.key_down, 0)
    self._addEventListener(self.node, 'keyup', self.key_up, 0)
    self._addEventListener(self.node, 'keypress', self.key_press, 0)
    # Mouse events, for move and up we implement some heuristics below
    self._addEventListener(self.node, 'mousedown', self.pointer_down, 0)
    self._addEventListener(self.node, 'click', self.pointer_click, 0)
    self._addEventListener(self.node, 'dblclick', self.pointer_double_click, 0)
    # Touch events
    self._addEventListener(self.node, 'touchstart', self.pointer_down, 0)
    self._addEventListener(self.node, 'touchmove', self.pointer_move, 0)
    self._addEventListener(self.node, 'touchend', self.pointer_up, 0)
    self._addEventListener(self.node, 'touchcancel', self.pointer_cancel, 0)

    # Implement mouse capturing. When a mouse is pressed down on
    # a widget, it "captures" the mouse, and will continue to receive
    # move and up events, even if the mouse is not over the widget.

    self._capture_flag = 0
    # 0: mouse not down, 1: mouse down (no capture), 2: captured, -1: capture end

    def mdown(e):
        # Start emitting move events, maybe follow the mouse outside widget bounds
        if self.capture_mouse == 0:
            self._capture_flag = 1
        else:
            self._capture_flag = 2
            window.document.addEventListener("mousemove", mmove_outside, True)
            window.document.addEventListener("mouseup", mup_outside, True)
            # Explicit caputuring is not necessary, and even causes problems on IE
            #if self.node.setCapture:
            #    self.node.setCapture()

    def mmove_inside(e):
        # maybe emit move event
        if self._capture_flag == -1:
            self._capture_flag = 0
        elif self._capture_flag == 1:
            self.pointer_move(e)
        elif self._capture_flag == 0 and self.capture_mouse &gt; 1:
            self.pointer_move(e)

    def mup_inside(e):
        if self._capture_flag == 1:
            self.pointer_up(e)
        self._capture_flag = 0

    def mmove_outside(e):
        # emit move event
        if self._capture_flag == 2:  # can hardly be anything else, but be safe
            e = window.event if window.event else e
            self.pointer_move(e)

    def mup_outside(e):
        # emit mouse up event, and stop capturing
        if self._capture_flag == 2:
            e = window.event if window.event else e
            stopcapture()
            self.pointer_up(e)

    def stopcapture():
        # Stop capturing
        if self._capture_flag == 2:
            self._capture_flag = -1
            window.document.removeEventListener("mousemove", mmove_outside, True)
            window.document.removeEventListener("mouseup", mup_outside, True)

    def losecapture(e):
        # We lost the capture. The losecapture event seems to be IE only.
        # The pointer_cancel seems poort supported too. So pointer_cancel
        # only really works with touch events ...
        stopcapture()
        self.pointer_cancel(e)

    # Setup capturing and releasing
    self._addEventListener(self.node, 'mousedown', mdown, True)
    self._addEventListener(self.node, "losecapture", losecapture)
    # Subscribe to normal mouse events
    self._addEventListener(self.node, "mousemove", mmove_inside, False)
    self._addEventListener(self.node, "mouseup", mup_inside, False)

</t>
<t tx="ekr.20181031045138.593">@event.emitter
def pointer_down(self, e):
    """ Event emitted when mouse-button/touchpad/screen is pressed.

    All pointer events have the following attributes:

    * pos: the pointer position, in pixels, relative to this widget
    * page_pos: the pointer position relative to the page
    * button: what mouse button the event is about, 1, 2, 3 are left, right,
        middle, respectively. 0 indicates no button.
    * buttons: what buttons were pressed at the time of the event.
    * modifiers: list of strings "Alt", "Shift", "Ctrl", "Meta" for
        modifier keys pressed down at the time of the event.
    * touches: a dictionary that maps touch_id's to (x, y, force) tuples.
        For mouse events touch_id is -1 and force is 1.

    A note about the relation with JavaScript events: although the name
    might suggest that this makes use of JS pointer events, this is not
    the case; Flexx captures both mouse events and touch events and exposes
    both as its own "pointer event". In effect, it works better on mobile
    devices, and has multi-touch support.
    """
    return self._create_pointer_event(e)

</t>
<t tx="ekr.20181031045138.594">@event.emitter
def pointer_up(self, e):
    """ Event emitted when mouse-button/touchpad/screen is released.

    See pointer_down() for a description of the event object.
    """
    return self._create_pointer_event(e)

</t>
<t tx="ekr.20181031045138.595">@event.emitter
def pointer_cancel(self, e):
    """ Event emitted when the mouse/touch is lost, e.g. the window becomes
    inactive during a drag. This only seem to work well for touch events
    in most browsers.

    See pointer_down() for a description of the event object.
    """
    return self._create_pointer_event(e)

</t>
<t tx="ekr.20181031045138.596">@event.emitter
def pointer_click(self, e):
    """ Event emitted when mouse-button/touchpad/screen is clicked.

    See pointer_down() for a description of the event object.
    """
    return self._create_pointer_event(e)

</t>
<t tx="ekr.20181031045138.597">@event.emitter
def pointer_double_click(self, e):
    """ Event emitted when mouse-button/touchpad/screen is double-clicked.

    See pointer_down() for a description of the event object.
    """
    return self._create_pointer_event(e)

</t>
<t tx="ekr.20181031045138.598">@event.emitter
def pointer_move(self, e):
    """ Event fired when the mouse or a touch is moved.

    See pointer_down for details.
    """

    ev = self._create_pointer_event(e)
    ev.button = 0
    return ev

</t>
<t tx="ekr.20181031045138.599">@event.emitter
def pointer_wheel(self, e):
    """ Event emitted when the mouse wheel is used.

    See pointer_down() for a description of the event object.
    Additional event attributes:

    * hscroll: amount of scrolling in horizontal direction
    * vscroll: amount of scrolling in vertical direction
    """
    # Note: wheel event gets generated also for parent widgets
    # I think this makes sense, but there might be cases
    # where we want to prevent propagation.
    ev = self._create_pointer_event(e)
    ev.button = 0
    ev.hscroll = e.deltaX * [1, 16, 600][e.deltaMode]
    ev.vscroll = e.deltaY * [1, 16, 600][e.deltaMode]
    return ev

</t>
<t tx="ekr.20181031045138.6">@path C:/Anaconda3/Lib/site-packages/flexx/
@others
if sys.version_info &lt; (3, 5):  # pragma: no cover
    raise RuntimeError('Flexx needs at least Python 3.5')

# Import config object
from ._config import config  # noqa
from .util.logging import set_log_level  # noqa
set_log_level(config.log_level)

del sys
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.60">def __init__(self):
    self.commands = []

</t>
<t tx="ekr.20181031045138.600">def _create_pointer_event(self, e):
    # Get offset to fix positions
    rect = self.node.getBoundingClientRect()
    offset = rect.left, rect.top

    if e.type.startswith('touch'):
        # Touch event - select one touch to represent the main position
        t = e.changedTouches[0]
        pos = float(t.clientX - offset[0]), float(t.clientY - offset[1])
        page_pos = t.pageX, t.pageY
        button = 0
        buttons = []
        # Include basic support for multi-touch
        touches = {}
        for i in range(e.changedTouches.length):
            t = e.changedTouches[i]
            if t.target is not e.target:
                continue
            touches[t.identifier] = (float(t.clientX - offset[0]),
                                     float(t.clientY - offset[1]),
                                     t.force)
    else:
        # Mouse event
        pos = float(e.clientX - offset[0]), float(e.clientY - offset[1])
        page_pos = e.pageX, e.pageY
        # Fix buttons
        if e.buttons:
            buttons_mask = reversed([c for c in e.buttons.toString(2)]).join('')
        else:
            # libjavascriptcoregtk-3.0-0  version 2.4.11-1 does not define
            # e.buttons
            buttons_mask = [e.button.toString(2)]
        buttons = [i+1 for i in range(5) if buttons_mask[i] == '1']
        button = {0: 1, 1: 3, 2: 2, 3: 4, 4: 5}[e.button]
        touches = {-1: (pos[0], pos[1], 1)}  # key must not clash with real touches

    # note: our button has a value as in JS "which"
    modifiers = [n for n in ('Alt', 'Shift', 'Ctrl', 'Meta')
                    if e[n.lower()+'Key']]
    # Create event dict
    return dict(pos=pos, page_pos=page_pos, touches=touches,
                button=button, buttons=buttons,
                modifiers=modifiers,
                )

</t>
<t tx="ekr.20181031045138.601">@event.emitter
def key_down(self, e):
    """ Event emitted when a key is pressed down while this
    widget has focus. A key event has the following attributes:

    * key: the character corresponding to the key being pressed, or
        a key name like "Escape", "Alt", "Enter".
    * modifiers: list of strings "Alt", "Shift", "Ctrl", "Meta" for
        modifier keys pressed down at the time of the event.

    A browser may associate certain actions with certain key presses.
    If this browser action is unwanted, it can be disabled by
    overloading this emitter:

    .. code-block:: py

        @event.emitter
        def key_down(self, e):
            # Prevent browser's default reaction to function keys
            ev = super().key_press(e)
            if ev.key.startswith('F'):
                e.preventDefault()
            return ev
    """
    return self._create_key_event(e)

</t>
<t tx="ekr.20181031045138.602">@event.emitter
def key_up(self, e):
    """ Event emitted when a key is released while
    this widget has focus. See key_down for details.
    """
    return self._create_key_event(e)

</t>
<t tx="ekr.20181031045138.603">@event.emitter
def key_press(self, e):
    """ Event emitted when a key is released after pressing down, in theory.
    In contast to key_down, this event does not fire for the
    pressing of modifier keys, and some browsers will also not fire
    for the arrow keys, backspace, etc. See key_down for details.
    """
    # Is there actually a reason for ever using this instead of key_down?
    return self._create_key_event(e)

</t>
<t tx="ekr.20181031045138.604">def _create_key_event(self, e):
    # https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent
    # key: chrome 51, ff 23, ie 9
    # code: chrome ok, ff 32, ie no
    modifiers = [n for n in ('Alt', 'Shift', 'Ctrl', 'Meta')
                    if e[n.lower()+'Key']]
    key = e.key
    if not key and e.code:  # Chrome &lt; v51
        key = e.code
        if key.startswith('Key'):
            key = key[3:]
            if 'Shift' not in modifiers:
                key = key.lower()
        elif key.startswith('Digit'):
            key = key[5:]
    # todo: handle Safari and older browsers via keyCode
    key = {'Esc': 'Escape', 'Del': 'Delete'}.get(key, key)  # IE
    return dict(key=key, modifiers=modifiers)
</t>
<t tx="ekr.20181031045138.605">@path C:/Anaconda3/Lib/site-packages/flexx/ui/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.606">"""
The Flexx widgets.
"""

import logging
logger = logging.getLogger(__name__)
del logging

# flake8: noqa

# We follow the convention of having one module per widget class (or a
# small set of closely related classes). In order not to pollute the
# namespaces, we prefix the module names with an underscrore.

from ._widget import Widget, create_element
from .layouts import *
from .widgets import *
</t>
<t tx="ekr.20181031045138.607"></t>
<t tx="ekr.20181031045138.608">@path C:/Anaconda3/Lib/site-packages/flexx/ui/layouts/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.609">""" FormLayout

Layout a series of (input) widgets in a form. Example:

.. UIExample:: 200

    from flexx import ui

    class Example(ui.Widget):
        def init(self):
            with ui.FormLayout():
                self.b1 = ui.LineEdit(title='Name:')
                self.b2 = ui.LineEdit(title="Age:")
                self.b3 = ui.LineEdit(title="Favorite color:")
                ui.Widget(flex=1)  # Spacing

Also see examples: :ref:`themed_form.py`.

"""

from pscript import window, undefined

from ... import event
from . import Layout
from .. import create_element


</t>
<t tx="ekr.20181031045138.61">def write_command(self, cmd):
    self.commands.append(cmd)


</t>
<t tx="ekr.20181031045138.610">class BaseTableLayout(Layout):
    """ Abstract base class for layouts that use an HTML table.

    Layouts that use this approach don't have good performance when
    resizing. This is not so much a problem when it is used as a leaf
    layout, but it's not recommended to embed such layouts in each-other.
    """

    CSS = """

    /* Clear any styling on this table (rendered_html is an IPython thing) */
    .flx-BaseTableLayout, .flx-BaseTableLayout td, .flx-BaseTableLayout tr,
    .rendered_html .flx-BaseTableLayout {
        border: 0px;
        padding: initial;
        margin: initial;
        background: initial;
    }

    /* Behave well inside hbox/vbox,
       we assume no layouts to be nested inside a table layout */
    .flx-box.flx-horizontal &gt; .flx-BaseTableLayout {
        width: auto;
    }
    .flx-box.flx-vertical &gt; .flx-BaseTableLayout {
        height: auto;
    }

    td.flx-vflex, td.flx-hflex {
        padding: 2px;
    }

    /* In flexed cells, occupy the full space */
    td.flx-vflex &gt; .flx-Widget {
        height: 100%;
    }
    td.flx-hflex &gt; .flx-Widget {
        width: 100%;
    }
    """


    @others
</t>
<t tx="ekr.20181031045138.611">def _apply_table_layout(self):
    table = self.node
    AUTOFLEX = 729  # magic number unlikely to occur in practice

    # Get table dimensions
    nrows = len(table.children)
    ncols = 0
    for i in range(len(table.children)):
        row = table.children[i]
        ncols = max(ncols, len(row.children))
    if ncols == 0 and nrows == 0:
        return

    # Collect flexes
    vflexes = []
    hflexes = []
    for i in range(nrows):
        row = table.children[i]
        for j in range(ncols):
            col = row.children[j]
            if (col is undefined) or (len(col.children) == 0):
                continue
            vflexes[i] = max(vflexes[i] or 0, col.children[0].vflex or 0)
            hflexes[j] = max(hflexes[j] or 0, col.children[0].hflex or 0)

    # What is the cumulative "flex-value"?
    cum_vflex = vflexes.reduce(lambda pv, cv: pv + cv, 0)
    cum_hflex = hflexes.reduce(lambda pv, cv: pv + cv, 0)

    # If no flexes are given; assign each equal
    if (cum_vflex == 0):
        for i in range(len(vflexes)):
            vflexes[i] = AUTOFLEX
        cum_vflex = len(vflexes) * AUTOFLEX
    if (cum_hflex == 0):
        for i in range(len(hflexes)):
            hflexes[i] = AUTOFLEX
        cum_hflex = len(hflexes) * AUTOFLEX

    # Assign css class and height/weight to cells
    for i in range(nrows):
        row = table.children[i]
        row.vflex = vflexes[i] or 0  # Store for use during resizing
        for j in range(ncols):
            col = row.children[j]
            if (col is undefined) or (col.children.length is 0):
                continue
            self._apply_cell_layout(row, col, vflexes[i], hflexes[j],
                                    cum_vflex, cum_hflex)

</t>
<t tx="ekr.20181031045138.612">@event.reaction('size')
def _adapt_to_size_change(self, *events):
    """ This function adapts the height (in percent) of the flexible rows
    of a layout. This is needed because the percent-height applies to the
    total height of the table. This function is called whenever the
    table resizes, and adjusts the percent-height, taking the available
    remaining table height into account. This is not necesary for the
    width, since percent-width in colums *does* apply to available width.
    """
    table = self.node  # or event.target
    #print('heigh changed', event.heightChanged, event.owner.__id)

    if events[-1].new_value[1] != events[0].old_value[1]:

        # Set one flex row to max, so that non-flex rows have their
        # minimum size. The table can already have been stretched
        # a bit, causing the total row-height in % to not be
        # sufficient from keeping the non-flex rows from growing.
        for i in range(len(table.children)):
            row = table.children[i]
            if (row.vflex &gt; 0):
                row.style.height = '100%'
                break

        # Get remaining height: subtract height of each non-flex row
        remainingHeight = table.clientHeight
        cum_vflex = 0
        for i in range(len(table.children)):
            row = table.children[i]
            cum_vflex += row.vflex
            if (row.vflex == 0) and (row.children.length &gt; 0):
                remainingHeight -= row.children[0].clientHeight

        # Apply height % for each flex row
        remainingPercentage = 100 * remainingHeight / table.clientHeight
        for i in range(len(table.children)):
            row = table.children[i]
            if row.vflex &gt; 0:
                row.style.height = round(row.vflex /cum_vflex *
                                            remainingPercentage) + 1 + '%'

</t>
<t tx="ekr.20181031045138.613">def _apply_cell_layout(self, row, col, vflex, hflex, cum_vflex, cum_hflex):
    raise NotImplementedError()



</t>
<t tx="ekr.20181031045138.614">class FormLayout(BaseTableLayout):
    """ A layout widget that vertically alligns its child widgets in a form.
    A label is placed to the left of each widget (based on the widget's title).
    
    The ``node`` of this widget is a
    `&lt;table&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/table&gt;`_.
    (This may be changed to use a CSS layout instead.)
    """

    CSS = """
    .flx-FormLayout .flx-title {
        text-align: right;
        padding-right: 5px;
    }
    """

    @others
</t>
<t tx="ekr.20181031045138.615">def _create_dom(self):
    return window.document.createElement('table')

</t>
<t tx="ekr.20181031045138.616">def _render_dom(self):
    rows = []
    for widget in self.children:
        row = create_element('tr', {},
                create_element('td', {'class': 'flx-title'}, widget.title),
                create_element('td', {}, [widget.outernode]),
                )
        widget.outernode.hflex = 1
        widget.outernode.vflex = widget.flex[1]
        rows.append(row)
    event.loop.call_soon(self._apply_table_layout)
    return rows

</t>
<t tx="ekr.20181031045138.617">def _apply_cell_layout(self, row, col, vflex, hflex, cum_vflex, cum_hflex):
    AUTOFLEX = 729
    className = ''
    if (vflex == AUTOFLEX) or (vflex == 0):
        row.style.height = 'auto'
        className += ''
    else:
        row.style.height = vflex * 100 / cum_vflex + '%'
        className += 'flx-vflex'
    className += ' '
    if (hflex == 0):
        col.style.width = 'auto'
        className += ''
    else:
        col.style.width = '100%'
        className += 'flx-hflex'
    col.className = className

</t>
<t tx="ekr.20181031045138.618">def _query_min_max_size(self):
    """ Overload to also take child limits into account.
    """

    # Collect contributions of child widgets
    mima1 = [0, 1e9, 0, 0]
    for child in self.children:
        mima2 = child._size_limits
        mima1[0] = max(mima1[0], mima2[0])
        mima1[1] = min(mima1[1], mima2[1])
        mima1[2] += mima2[2]
        mima1[3] += mima2[3]

    # Dont forget padding and spacing
    extra_padding = 2
    extra_spacing = 2
    for i in range(4):
        mima1[i] += extra_padding
    mima1[2] += extra_spacing
    mima1[3] += extra_spacing

    # Own limits
    mima3 = super()._query_min_max_size()

    # Combine own limits with limits of children
    return [max(mima1[0], mima3[0]),
            min(mima1[1], mima3[1]),
            max(mima1[2], mima3[2]),
            min(mima1[3], mima3[3])]
</t>
<t tx="ekr.20181031045138.619">@path C:/Anaconda3/Lib/site-packages/flexx/ui/layouts/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.62">class App:
    """ Specification of a Flexx app.

    Strictly speaking, this is a container for a ``PyComponent``/``JsComponent``
    class plus the args and kwargs that it is to be instantiated with.

    Arguments:
        cls (Component): the PyComponent or JsComponent class (e.g. Widget) that
            represents this app.
        args: positional arguments used to instantiate the class (and received
            in its ``init()`` method).
        kwargs: keyword arguments used to initialize the component's properties.
    """

    @others
</t>
<t tx="ekr.20181031045138.620">""" HVLayout

The HVLayout and its subclasses provide a simple mechanism to horizontally
or vertically stack child widgets. This can be done in different *modes*:
box mode is suited for aligning content where natural size matters. The
fix mode and split mode are more suited for high-level layout. See
the HVLayout class for details.


Interactive Box layout example:

.. UIExample:: 200

    from flexx import app, event, ui

    class Example(ui.HBox):
        def init(self):
            self.b1 = ui.Button(text='Horizontal', flex=0)
            self.b2 = ui.Button(text='Vertical', flex=1)
            self.b3 = ui.Button(text='Horizontal reversed', flex=2)
            self.b4 = ui.Button(text='Vertical reversed', flex=3)

        @event.reaction('b1.pointer_down')
        def _to_horizontal(self, *events):
            self.set_orientation('h')

        @event.reaction('b2.pointer_down')
        def _to_vertical(self, *events):
            self.set_orientation('v')

        @event.reaction('b3.pointer_down')
        def _to_horizontal_rev(self, *events):
            self.set_orientation('hr')

        @event.reaction('b4.pointer_down')
        def _to_vertical_r(self, *events):
            self.set_orientation('vr')

Also see examples: :ref:`app_layout.py`, :ref:`splitters.py`,
:ref:`box_vs_fix_layout.py`, :ref:`mondriaan.py`.

"""


"""
## Notes on performance and layout boundaries.

In layout one can see multiple streams of information:

- Information about available size streams downward.
- Information about minimum and maxium allowed sizes streams upward.
- Information about natural sizes streams upward.

The first two streams are not problematic, as they are very much
one-directional, and minimum/maximum sizes are often quite static.
The flow of natural size is important to obtain good looking layouts, but
adds complications because of its recursive effect; a change in size may
need several document reflows to get the layout right, which can cause
severe performance penalties if many elements are involved. Therefore it
is important to introduce "layout boundaries" in the higher levels of a UI
so that layout can be established within individual parts of the UI without
affecting the other parts.

This module implements horizontal/vertical layouts that support natural sizes
(box) and layouts that do not (fix and split). The former is implemented with
CSS flexbox (the browser does all the work, and maintains the upward stream
of natural sizes). The latter is implemented with absolute positioning (we make
JavaScript do all the work). We realize good compatibility by maintaining the
first two streams of information.

To clearify, it would be possible to implement split and fix with flexbox,
and this could result in a "nicety" that a VSplit with content can still
have a natural horizontal size (and used as such in an HBox with flex 0).
However, one can see how this will require additional document reflows
(since a change in width can change the natural height and vice versa).
Split and Fix layouts provide an intuitive way to introduce layout boundaries.

For an element to be a layout boundary it must:

- Not be display inline or inline-block
- Not have a percentage height value.
- Not have an implicit or auto height value.
- Not have an implicit or auto width value.
- Have an explicit overflow value (scroll, auto or hidden).
- Not be a descendant of a &lt;table&gt; element.

Most Widgets inside a HVLayout in split or fix mode conform to this:
they are typically not table elements, the Widget sets overflow, the layout
itself uses CSS to set display, and sets height and weight.

More reading:

- http://wilsonpage.co.uk/introducing-layout-boundaries/
- https://css-tricks.com/snippets/css/a-guide-to-flexbox/

"""

from ... import event, app
from ...event import Property
from . import Layout


</t>
<t tx="ekr.20181031045138.621">class OrientationProp(Property):
    """ A property that represents a pair of float values, which can also be
    set using a scalar.
    """

    _default = 'h'

    @others
</t>
<t tx="ekr.20181031045138.622">def _validate(self, v, name, data):
    if isinstance(v, str):
        v = v.lower().replace('-', '')
    v = {'horizontal': 'h', 0: 'h', 'lefttoright': 'h',
         'vertical': 'v', 1: 'v', 'toptobottom': 'v',
         'righttoleft': 'hr', 'bottomtotop': 'vr'}.get(v, v)
    if v not in ('h', 'v', 'hr', 'vr'):
        raise ValueError('%s.orientation got unknown value %r' % (self.id, v))
    return v


</t>
<t tx="ekr.20181031045138.623">class HVLayout(Layout):
    """ A layout widget to distribute child widgets horizontally or vertically.

    This is a versatile layout class which can operate in different
    orientations (horizontal, vertical, reversed), and in different modes:

    In 'fix' mode, all available space is simply distributed corresponding
    to the children's flex values. This can be convenient to e.g. split
    a layout in two halves.

    In 'box' mode, each widget gets at least its natural size (if available),
    and any *additional* space is distributed corresponding to the children's
    flex values. This is convenient for low-level layout of widgets, e.g. to
    align  one or more buttons. It is common to use flex values of zero to
    give widgets just the size that they needs and use an empty widget with a
    flex of 1 to fill up any remaining space. This mode is based on CSS flexbox.

    In 'split' mode, all available space is initially distributed corresponding
    to the children's flex values. The splitters between the child widgets
    can be dragged by the user and positioned via an action. This is useful
    to give the user more control over the (high-level) layout.

    In all modes, the layout is constrained by the minimum and maximum size
    of the child widgets (as set via style/CSS). Note that flexbox (and thus
    box mode) may not honour min/max sizes of widgets in child layouts.

    Note that widgets with a flex value of zero may collapse if used inside
    a fix/split layout, or in a box layout but lacking a natural size. This
    can be resolved by assigning a minimum width/height to the widget. The
    exception is if all child widgets have a flex value of zero, in which
    case the available space is divided equally.

    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_. The
    outer nodes of the child widgets are layed-out using JavaScript of CSS,
    depending on the mode.
    
    Also see the convenience classes: HFix, VFix, HBox, VBox, HSplit, VSplit.
    """

    _DEFAULT_ORIENTATION = 'h'
    _DEFAULT_MODE = 'box'

    CSS = """

    /* === for box layout === */

    .flx-HVLayout &gt; .flx-Widget {
        margin: 0; /* the layout handles the margin */
     }

    .flx-box {
        display: -webkit-flex;
        display: -ms-flexbox;  /* IE 10 */
        display: -ms-flex;     /* IE 11 */
        display: -moz-flex;
        display: flex;

        /* How space is divided when all flex-factors are 0:
           start, end, center, space-between, space-around */
        -webkit-justify-content: space-around;
        -ms-justify-content: space-around;
        -moz-justify-content: space-around;
        justify-content: space-around;

        /* How items are aligned in the other direction:
           center, stretch, baseline */
        -webkit-align-items: stretch;
        -ms-align-items: stretch;
        -moz-align-items: stretch;
        align-items: stretch;
    }

    .flx-box.flx-horizontal {
        -webkit-flex-flow: row;
        -ms-flex-flow: row;
        -moz-flex-flow: row;
        flex-flow: row;
        width: 100%;
    }
    .flx-box.flx-vertical {
        -webkit-flex-flow: column;
        -ms-flex-flow: column;
        -moz-flex-flow: column;
        flex-flow: column;
        height: 100%; width: 100%;
    }
    .flx-box.flx-horizontal.flx-reversed {
        -webkit-flex-flow: row-reverse;
        -ms-flex-flow: row-reverse;
        -moz-flex-flow: row-reverse;
        flex-flow: row-reverse;
    }
    .flx-box.flx-vertical.flx-reversed {
        -webkit-flex-flow: column-reverse;
        -ms-flex-flow: column-reverse;
        -moz-flex-flow: column-reverse;
        flex-flow: column-reverse;
    }

    /* Make child widgets (and layouts) size correctly */
    .flx-box.flx-horizontal &gt; .flx-Widget {
        height: auto;
        width: auto;
    }
    .flx-box.flx-vertical &gt; .flx-Widget {
        width: auto;
        height: auto;
    }

    /* If a boxLayout is in a compound widget, we need to make that widget
       a flex container (done with JS in Widget class), and scale here */
    .flx-Widget &gt; .flx-box {
        flex-grow: 1;
        flex-shrink: 1;
    }

    /* === For split and fix layout === */

    .flx-split &gt; .flx-Widget {
        /* Let child widgets position well, and help them become a layout
         * boundary. We cannot do "display: block;", as that would break stuff.
        /* overflow is set in Widget.CSS, setting here breaks scrollable widgets
         */
        position: absolute;
    }

    .flx-split.flx-dragging { /* Fix for odd drag behavior on Chrome */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    .flx-split.flx-dragging iframe {  /* disable iframe during drag */
        pointer-events: none;
    }

    .flx-split.flx-horizontal &gt; .flx-split-sep,
    .flx-split.flx-horizontal.flx-dragging {
        cursor: ew-resize;
    }
    .flx-split.flx-vertical &gt; .flx-split-sep,
    .flx-split.flx-vertical.flx-dragging {
        cursor: ns-resize;
    }
    .flx-split-sep {
        z-index: 2;
        position: absolute;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        box-sizing: border-box;
        background: rgba(0, 0, 0, 0); /* transparent */
        /* background: #fff;  /* hide underlying widgets */
    }
    """

    mode = event.EnumProp(('box', 'fix', 'split'), settable=True, doc="""
        The mode in which this layout operates:

        * 'BOX': (default) each widget gets at least its natural size, and
          additional space is distributed corresponding to the flex values.
        * 'FIX': all available space is distributed corresponding to the flex values.
        * 'SPLIT': available space is initially distributed correspondong to the
          flex values, and can be modified by the user by dragging the splitters.
        """)

    orientation = OrientationProp(settable=True, doc="""
        The orientation of the child widgets. 'h' or 'v' for horizontal and
        vertical, or their reversed variants 'hr' and 'vr'. Settable with
        values: 0, 1, 'h', 'v', 'hr', 'vr', 'horizontal', 'vertical',
        'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
        (insensitive to case and use of dashes).
        """)
    
    spacing = event.FloatProp(4, settable=True, doc="""
        The space between two child elements (in pixels).
        """)

    padding = event.FloatProp(1, settable=True, doc="""
        The empty space around the layout (in pixels).
        """)

    # splitter_positions = event.TupleProp(doc="""  xx local property!
    splitter_positions = app.LocalProperty(doc="""
        The preferred relative positions of the splitters. The actual
        positions are subject to minsize and maxsize constraints
        (and natural sizes for box-mode).
        """)

    @others
</t>
<t tx="ekr.20181031045138.624">def __init__(self, *args, **kwargs):
    kwargs['mode'] = kwargs.get('mode', self._DEFAULT_MODE)
    kwargs['orientation'] = kwargs.get('orientation', self._DEFAULT_ORIENTATION)

    self._seps = []
    self._dragging = None

    super().__init__(*args, **kwargs)

    if 'Split' in self._id and 'spacing' not in kwargs:
        self.set_spacing(8)

## Actions

</t>
<t tx="ekr.20181031045138.625">@event.action
def set_from_flex_values(self):
    """ Set the divider positions corresponding to the children's flex values.
    Only has a visual effect in split-mode.
    """
    # Note that we still use it for fix mode to initialize it, and in box
    # mode to set splitter_positions prop, for consistency.

    # Collect flexes
    sizes = []
    dim = 0 if 'h' in self.orientation else 1
    for widget in self.children:
        sizes.append(widget.flex[dim])

    # Normalize size, so that total is one
    size_sum = 0 if len(sizes) == 0 else sum(sizes)
    if size_sum == 0:
        # Convenience: all zeros probably means to divide equally
        sizes = [1/len(sizes) for i in sizes]
    else:
        sizes = [i/size_sum for i in sizes]

    # Turn sizes into positions
    positions = []
    pos = 0
    for i in range(len(sizes) - 1):
        pos = pos + sizes[i]
        positions.append(pos)

    # Apply
    self._mutate_splitter_positions(positions)

</t>
<t tx="ekr.20181031045138.626">@event.action
def set_splitter_positions(self, *positions):
    """ Set relative splitter posisions (None or values between 0 and 1).
    Only usable in split-mode.
    """
    # todo: technically, we could allow this in fix-mode too, but *should* we?
    if self.mode != 'SPLIT':
        return

    positions2 = []
    for i in range(len(positions)):
        pos = positions[i]
        if pos is not None:
            pos = max(0.0, min(1.0, float(pos)))
        positions2.append(pos)

    self._mutate_splitter_positions(positions2)

</t>
<t tx="ekr.20181031045138.627">@event.emitter
def user_splitter_positions(self, *positions):
    """ Event emitted when the splitter is positioned by the user.
    The event has a ``positions`` attribute.
    """
    if self.mode != 'SPLIT':
        return None  # do not emit

    positions2 = []
    for i in range(len(positions)):
        pos = positions[i]
        if pos is not None:
            pos = max(0.0, min(1.0, float(pos)))
        positions2.append(pos)

    self.set_splitter_positions(*positions)
    return {'positions': positions}

## General reactions and hooks

</t>
<t tx="ekr.20181031045138.628">def _query_min_max_size(self):
    """ Overload to also take child limits into account.
    """

    # This streams information about min and max sizes upward, for
    # split and fix mode. Most flexbox implementations don't seem to
    # look for min/max sizes of their children. We could set min-width and
    # friends at the layout to help flexbox a bit, but that would possibly
    # overwrite a user-set value. Hopefully flexbox will get fixed soon.
    
    hori = 'h' in self.orientation
    
    # Own limits
    mima0 = super()._query_min_max_size()
    
    # Init limits for children
    if hori is True:
        mima1 = [0, 0, 0, 1e9]
    else:
        mima1 = [0, 1e9, 0, 0]
    
    # Collect contributions of child widgets?
    if self.minsize_from_children:
        for child in self.children:
            mima2 = child._size_limits
            if hori is True:
                mima1[0] += mima2[0]
                mima1[1] += mima2[1]
                mima1[2] = max(mima1[2], mima2[2])
                mima1[3] = min(mima1[3], mima2[3])
            else:
                mima1[0] = max(mima1[0], mima2[0])
                mima1[1] = min(mima1[1], mima2[1])
                mima1[2] += mima2[2]
                mima1[3] += mima2[3]
    
    # Set unset max sizes
    if mima1[1] == 0:
        mima1[1] = 1e9
    if mima1[3] == 0:
        mima1[3] = 1e9
    
    # Add padding and spacing
    if self.minsize_from_children:
        extra_padding = self.padding * 2
        extra_spacing = self.spacing * (len(self.children) - 1)
        for i in range(4):
            mima1[i] += extra_padding
        if hori is True:
            mima1[0] += extra_spacing
            mima1[1] += extra_spacing
        else:
            mima1[2] += extra_spacing
            mima1[3] += extra_spacing
    
    # Combine own limits with limits of children
    return [max(mima1[0], mima0[0]),
            min(mima1[1], mima0[1]),
            max(mima1[2], mima0[2]),
            min(mima1[3], mima0[3])]

</t>
<t tx="ekr.20181031045138.629">@event.reaction('size', '_size_limits', mode='greedy')
def __size_changed(self, *events):
    self._rerender()

</t>
<t tx="ekr.20181031045138.63">def __init__(self, cls, *args, **kwargs):
    if not isinstance(cls, type) and issubclass(type, (PyComponent, JsComponent)):
        raise ValueError('App needs a PyComponent or JsComponent class '
                         'as its first argument.')
    self._cls = cls
    self.args = args
    self.kwargs = kwargs
    self._path = cls.__name__  # can be overloaded by serve()
    self._is_served = False

    # Handle good defaults
    if hasattr(cls, 'title') and self.kwargs.get('title', None) is None:
        self.kwargs['title'] = 'Flexx app - ' + cls.__name__
    if hasattr(cls, 'set_icon') and self.kwargs.get('icon', None) is None:
        # Set icon as base64 str; exported apps can still be standalone
        fname = os.path.abspath(os.path.join(__file__, '..', '..',
                                                'resources', 'flexx.ico'))
        icon_str = encodebytes(open(fname, 'rb').read()).decode()
        self.kwargs['icon'] = 'data:image/ico;base64,' + icon_str

</t>
<t tx="ekr.20181031045138.630">@event.reaction('children*.size', mode='greedy')
def __let_children_check_size(self, *events):
    for child in self.children:
        child.check_real_size()

</t>
<t tx="ekr.20181031045138.631">@event.reaction('mode')
def __set_mode(self, *events):
    # reset children style
    for child in self.children:
        self._release_child(child)

    if self.mode == 'BOX':
        self.outernode.classList.remove('flx-split')
        self.outernode.classList.add('flx-box')
        self._set_box_child_flexes()
        self._set_box_spacing()
    else:
        self.outernode.classList.remove('flx-box')
        self.outernode.classList.add('flx-split')
        self._rerender()  # the above might not have triggered a rerender

</t>
<t tx="ekr.20181031045138.632">@event.reaction('orientation')
def __set_orientation(self, *events):
    ori = self.orientation
    if 'h' in ori:
        self.outernode.classList.add('flx-horizontal')
        self.outernode.classList.remove('flx-vertical')
    else:
        self.outernode.classList.remove('flx-horizontal')
        self.outernode.classList.add('flx-vertical')
    if 'r' in ori:
        self.outernode.classList.add('flx-reversed')
    else:
        self.outernode.classList.remove('flx-reversed')

    for widget in self.children:
        widget.check_real_size()
    self._rerender()

</t>
<t tx="ekr.20181031045138.633">@event.reaction('padding')
def __set_padding(self, *events):
    self.outernode.style['padding'] = self.padding + 'px'
    for widget in self.children:
        widget.check_real_size()
    self._rerender()

</t>
<t tx="ekr.20181031045138.634">def _release_child(self, widget):
    for n in ['margin', 'left', 'width', 'top', 'height']:
        widget.outernode.style[n] = ''

</t>
<t tx="ekr.20181031045138.635">def _render_dom(self):
    children = self.children
    mode = self.mode
    use_seps = mode == 'SPLIT'
    if mode == 'BOX':
        self._ensure_seps(0)
    else:
        self._ensure_seps(len(children) - 1)

    # Add new children and maybe interleave with separater widgets
    nodes = []
    for i in range(len(children)):
        nodes.append(children[i].outernode)
        if use_seps and i &lt; len(self._seps):
            nodes.append(self._seps[i])
    return nodes

</t>
<t tx="ekr.20181031045138.636">def _ensure_seps(self, n):
    """ Ensure that we have exactly n seperators.
    """
    global window
    n = max(0, n)
    to_remove = self._seps[n:]  # noqa
    self._seps = self._seps[:n]
    # hv = 'flx-horizontal' if 'h' in self.orientation else 'flx-vertical'
    while len(self._seps) &lt; n:
        sep = window.document.createElement('div')
        self._seps.append(sep)
        sep.i = len(self._seps) - 1
        sep.classList.add('flx-split-sep')
        # sep.classList.add(hv)
        sep.rel_pos = 0
        sep.abs_pos = 0

</t>
<t tx="ekr.20181031045138.637">@event.action
def _rerender(self):
    """ Invoke a re-render. Only necessary for fix/split mode.
    """
    if self.mode == 'BOX':
        # Sizes may have changed
        for child in self.children:
            child.check_real_size()
    else:
        # Enfore a rerender by mutating splitter_positions
        sp1 = ()
        sp2 = self.splitter_positions
        sp2 = () if sp2 is None else sp2
        if len(sp2) == 0:
            sp1 = (1, )
        self._mutate_splitter_positions(sp1)
        self._mutate_splitter_positions(sp2)

## Reactions for box mode

</t>
<t tx="ekr.20181031045138.638">@event.reaction('orientation', 'children', 'children*.flex', mode='greedy')
def _set_box_child_flexes(self, *events):
    if self.mode != 'BOX':
        return
    ori = self.orientation
    i = 0 if ori in (0, 'h', 'hr') else 1
    for widget in self.children:
        _applyBoxStyle(widget.outernode, 'flex-grow', widget.flex[i])
        _applyBoxStyle(widget.outernode, 'flex-shrink', widget.flex[i] or 1)
    for widget in self.children:
        widget.check_real_size()

</t>
<t tx="ekr.20181031045138.639">@event.reaction('spacing', 'orientation', 'children', mode='greedy')
def _set_box_spacing(self, *events):
    if self.mode != 'BOX':
        return
    ori = self.orientation
    children_events = [ev for ev in events if ev.type == 'children']
    old_children = children_events[0].old_value if children_events else []
    children = self.children
    # Reset
    for child in children:
        child.outernode.style['margin-top'] = ''
        child.outernode.style['margin-left'] = ''
    for child in old_children:
        child.outernode.style['margin-top'] = ''
        child.outernode.style['margin-left'] = ''
    # Set
    margin = 'margin-top' if ori in (1, 'v', 'vr') else 'margin-left'
    if children.length:
        if ori in ('vr', 'hr'):
            children[-1].outernode.style[margin] = '0px'
            for child in children[:-1]:
                child.outernode.style[margin] = self.spacing + 'px'
        else:
            children[0].outernode.style[margin] = '0px'
            for child in children[1:]:
                child.outernode.style[margin] = self.spacing + 'px'
    for widget in children:
        widget.check_real_size()

## Reactions and machinerey for fix/split mode

</t>
<t tx="ekr.20181031045138.64">def __call__(self, *args, **kwargs):
    a = list(self.args) + list(args)
    kw = {}
    kw.update(self.kwargs)
    kw.update(kwargs)
    return self.cls(*a, **kw)

</t>
<t tx="ekr.20181031045138.640">def _get_available_size(self):
    bar_size = self.spacing
    pad_size = self.padding
    if 'h' in self.orientation:
        total_size = self.outernode.clientWidth
    else:
        total_size = self.outernode.clientHeight
    return total_size, total_size - bar_size * len(self._seps) - 2 * pad_size

</t>
<t tx="ekr.20181031045138.641">@event.reaction('spacing')
def __spacing_changed(self, *events):
    self._rerender()

</t>
<t tx="ekr.20181031045138.642">@event.reaction('children', 'children*.flex', mode='greedy')
def _set_split_from_flexes(self, *events):
    self.set_from_flex_values()

</t>
<t tx="ekr.20181031045138.643">@event.reaction
def __watch_splitter_positions(self):
    """ Set the slider positions, subject to constraints.
    """
    # This is an implicit reaction, triggered by splitter_positions.
    # Implicit reactions collect events in a way that is less sensitive
    # to ordering with other reactions. We emit the rerender event instead
    # of calling the render method, otherwise that would trigger a lot
    # of unintended propery usage!
    if self.mode != 'BOX':
        self.splitter_positions
        self.emit('_render')

    # todo: we could do more thottling here, or use a scheme to tell the loop
    # that this reaction does not care about event ordering. (issue #426)

</t>
<t tx="ekr.20181031045138.644">def __apply_one_splitter_pos(self, index, pos):
    """ Set the absolute position of one splitter. Called from move event.
    """

    # Note that the min/max constraints are applied in a rather different
    # way as they are in the render method, because here the goal is to
    # shift neighboring widgets around, while in rendering the purpose is
    # to distribute superfluous/missing space equally.

    children = self.children
    total_size, available_size = self._get_available_size()
    ori = self.orientation

    if index &gt;= len(self._seps):
        return

    # Apply the position
    if pos &lt; 0:
        pos = available_size - pos
    pos = max(0, min(available_size, pos))
    abs_positions = [sep.abs_pos for sep in self._seps]
    abs_positions[index] = pos

    # Move seps on the left, as needed
    ref_pos = pos
    for i in reversed(range(0, index)):
        cur = abs_positions[i]
        mi, ma = _get_min_max(children[i+1], ori)
        abs_positions[i] = ref_pos = max(ref_pos - ma, min(ref_pos - mi, cur))

    # Move seps on the right, as needed
    ref_pos = pos
    for i in range(index+1, len(abs_positions)):
        cur = abs_positions[i]
        mi, ma = _get_min_max(children[i], ori)
        abs_positions[i] = ref_pos = max(ref_pos + mi, min(ref_pos + ma, cur))

    # Correct seps from the right edge
    ref_pos = available_size
    for i in reversed(range(0, len(abs_positions))):
        cur = abs_positions[i]
        mi, ma = _get_min_max(children[i+1], ori)
        abs_positions[i] = ref_pos = max(ref_pos - ma, min(ref_pos - mi, cur))

    # Correct seps from the left edge
    ref_pos = 0
    for i in range(0, len(abs_positions)):
        cur = abs_positions[i]
        mi, ma = _get_min_max(children[i], ori)
        abs_positions[i] = ref_pos = max(ref_pos + mi, min(ref_pos + ma, cur))

    # Set (relative) splitter positions. This may seem like a detour, but
    # this way the splits will scale nicely e.g. during resizing.
    self.user_splitter_positions(*[pos/available_size for pos in abs_positions])

</t>
<t tx="ekr.20181031045138.645">def __apply_positions(self):
    """ Set sep.abs_pos and sep.rel_pos on each separator.
    Called by __render_positions.
    """

    children = self.children
    total_size, available_size = self._get_available_size()
    ori = self.orientation
    positions = self.splitter_positions

    if len(positions) != len(self._seps):
        return
    if len(children) != len(self._seps) + 1:
        return

    # Apply absolute positions
    for i in range(len(positions)):
        self._seps[i].abs_pos = positions[i] * available_size

    # Collect info for each widget ...
    # given: the width/height that the widget seems to get at this point
    # mi/ma: min/max size
    # can_give: how much it has more than it needs; negative means it needs more
    # can_receive: how much it has less than the max; negative means it needs less
    ww = []
    ref_pos = 0
    for i in range(len(children)):
        w = {}
        ww.append(w)
        if i &lt; len(self._seps):
            w.given = self._seps[i].abs_pos - ref_pos
            ref_pos = self._seps[i].abs_pos
        else:
            w.given = available_size - ref_pos
        w.mi, w.ma = _get_min_max(children[i], ori)
        w.can_give = w.given - w.mi
        w.can_receive = w.ma - w.given
        w.has = w.given  # may be reset

    # Give each widget what it needs
    net_size = 0
    for w in ww:
        if w.can_give &lt; 0:  # i.e. must take
            net_size += w.can_give
            w.has = w.mi
            w.can_give = 0
            w.can_receive = w.ma - w.has
        elif w.can_receive &lt; 0:  # i.e. must give
            net_size -= w.can_receive
            w.has = w.ma
            w.can_receive = 0
            w.can_give = w.has - w.mi

    # Now divide remaining space (or lack thereof) equally
    ww2 = ww.copy()
    for iter in range(4):  # safe for-loop
        if abs(net_size) &lt; 0.5 or len(ww2) == 0:
            break
        size_for_each = net_size / len(ww2)
        for i in reversed(range(len(ww2))):
            w = ww2[i]
            if net_size &gt; 0:  # size to divide where we can
                if w.can_receive &gt; 0:
                    gets = min(w.can_receive, size_for_each)
                    net_size -= gets
                    w.can_receive -= gets
                    w.has += gets
                if w.can_receive &lt;= 0:
                    ww2.pop(i)
            else:  # size to take where we can
                if w.can_give &gt; 0:
                    take = min(w.can_give, -size_for_each)
                    net_size += take
                    w.can_give -= take
                    w.has -= take
                if w.can_give &lt;= 0:
                    ww2.pop(i)

    # Apply new sep positions
    ref_pos = 0
    for i in range(len(self._seps)):
        ref_pos += ww[i].has
        self._seps[i].abs_pos = ref_pos

    # The assertion below might not hold if the layout is too
    # small/large to fulfil constraints:
    # assert abs(ref_pos + ww[-1].has - available_size)

    # Store relative posisions, for good measure
    for i in range(0, len(self._seps)):
        self._seps[i].rel_pos = self._seps[i].abs_pos / available_size

</t>
<t tx="ekr.20181031045138.646">@event.reaction('!_render', mode='greedy')
def __render_positions(self):
    """ Use the absolute positions on the seps to apply positions to
    the child elements and separators.
    """

    children = self.children
    bar_size = self.spacing
    pad_size = self.padding
    total_size, available_size = self._get_available_size()
    ori = self.orientation

    if len(children) != len(self._seps) + 1:
        return

    # First apply absolute positions based on splitter_positions attribute.
    self.__apply_positions()

    # Apply
    is_horizonal = 'h' in ori
    is_reversed = 'r' in ori
    offset = pad_size
    last_sep_pos = 0
    for i in range(len(children)):
        widget = children[i]
        ref_pos = self._seps[i].abs_pos if i &lt; len(self._seps) else available_size
        size = ref_pos - last_sep_pos
        if True:
            # Position widget
            pos = last_sep_pos + offset
            if is_reversed is True:
                pos = total_size - pos - size
            if is_horizonal is True:
                widget.outernode.style.left = pos + 'px'
                widget.outernode.style.width = size + 'px'
                widget.outernode.style.top = pad_size + 'px'
                widget.outernode.style.height = 'calc(100% - ' + 2*pad_size + 'px)'
            else:
                widget.outernode.style.left = pad_size + 'px'
                widget.outernode.style.width = 'calc(100% - ' + 2*pad_size + 'px)'
                widget.outernode.style.top = pos + 'px'
                widget.outernode.style.height = size + 'px'
        if i &lt; len(self._seps):
            # Position divider
            sep = self._seps[i]
            pos = sep.abs_pos + offset
            if is_reversed is True:
                pos = total_size - pos - bar_size
            if is_horizonal is True:
                sep.style.left = pos + 'px'
                sep.style.width = bar_size + 'px'
                sep.style.top = '0'
                sep.style.height = '100%'
            else:
                sep.style.top = pos + 'px'
                sep.style.height = bar_size + 'px'
                sep.style.left = '0'
                sep.style.width = '100%'
            offset += bar_size
            last_sep_pos = sep.abs_pos

    # Child sizes have likely changed
    for child in children:
        child.check_real_size()

</t>
<t tx="ekr.20181031045138.647">@event.emitter
def pointer_down(self, e):
    if self.mode == 'SPLIT' and e.target.classList.contains("flx-split-sep"):
        e.stopPropagation()
        sep = e.target
        t = e.changedTouches[0] if e.changedTouches else e
        x_or_y1 = t.clientX if 'h' in self.orientation else t.clientY
        self._dragging = self.orientation, sep.i, sep.abs_pos, x_or_y1
        self.outernode.classList.add('flx-dragging')
    else:
        return super().pointer_down(e)

</t>
<t tx="ekr.20181031045138.648">@event.emitter
def pointer_up(self, e):
    self._dragging = None
    self.outernode.classList.remove('flx-dragging')
    return super().pointer_down(e)

</t>
<t tx="ekr.20181031045138.649">@event.emitter
def pointer_move(self, e):
    if self._dragging is not None:
        e.stopPropagation()
        e.preventDefault()  # prevent drag-down-refresh on mobile devices
        ori, i, ref_pos, x_or_y1 = self._dragging
        if ori == self.orientation:
            t = e.changedTouches[0] if e.changedTouches else e
            x_or_y2 = t.clientX if 'h' in self.orientation else t.clientY
            diff = (x_or_y1 - x_or_y2) if 'r' in ori else (x_or_y2 - x_or_y1)
            self.__apply_one_splitter_pos(i, max(0, ref_pos + diff))
    else:
        return super().pointer_move(e)


\\-4.## Util funcs

</t>
<t tx="ekr.20181031045138.65">def __repr__(self):
    t = '&lt;App based on class %s pre-initialized with %i args and %i kwargs&gt;'
    return t % (self.cls.__name__, len(self.args), len(self.kwargs))

</t>
<t tx="ekr.20181031045138.650">def _applyBoxStyle(e, sty, value):
    for prefix in ['-webkit-', '-ms-', '-moz-', '']:
        e.style[prefix + sty] = value


</t>
<t tx="ekr.20181031045138.651">def _get_min_max(widget, ori):
    mima = widget._size_limits
    if 'h' in ori:
        return mima[0], mima[1]
    else:
        return mima[2], mima[3]


## Convenience subclasses

</t>
<t tx="ekr.20181031045138.652">class HBox(HVLayout):
    """ Horizontal layout that tries to give each widget its natural size and
    distributes any remaining space corresponding to the widget's flex values.
    (I.e. an HVLayout with orientation 'h' and mode 'box'.)
    """
    _DEFAULT_ORIENTATION = 'h'
    _DEFAULT_MODE = 'box'


</t>
<t tx="ekr.20181031045138.653">class VBox(HVLayout):
    """ Vertical layout that tries to give each widget its natural size and
    distributes any remaining space corresponding to the widget's flex values.
    (I.e. an HVLayout with orientation 'v' and mode 'box'.)
    """
    _DEFAULT_ORIENTATION = 'v'
    _DEFAULT_MODE = 'box'


</t>
<t tx="ekr.20181031045138.654">class HFix(HVLayout):
    """ Horizontal layout that distributes the available space corresponding
    to the widget's flex values.
    (I.e. an HVLayout with orientation 'h' and mode 'fix'.)
    """
    _DEFAULT_ORIENTATION = 'h'
    _DEFAULT_MODE = 'fix'


</t>
<t tx="ekr.20181031045138.655">class VFix(HVLayout):
    """ Vertical layout that distributes the available space corresponding
    to the widget's flex values.
    (I.e. an HVLayout with orientation 'v' and mode 'fix'.)
    """
    _DEFAULT_ORIENTATION = 'v'
    _DEFAULT_MODE = 'fix'


</t>
<t tx="ekr.20181031045138.656">class HSplit(HVLayout):
    """ Horizontal layout that initially distributes the available space
    corresponding to the widget's flex values, and has draggable splitters.
    By default, this layout has a slightly larger spacing between the widgets.
    (I.e. an HVLayout with orientation 'h' and mode 'split'.)
    """
    _DEFAULT_ORIENTATION = 'h'
    _DEFAULT_MODE = 'split'


</t>
<t tx="ekr.20181031045138.657">class VSplit(HVLayout):
    """ Vertical layout that initially distributes the available space
    corresponding to the widget's flex values, and has draggable splitters.
    By default, this layout has a slightly larger spacing between the widgets.
    (I.e. an HVLayout with orientation 'v' and mode 'split'.)
    """
    _DEFAULT_ORIENTATION = 'v'
    _DEFAULT_MODE = 'split'
</t>
<t tx="ekr.20181031045138.658">@path C:/Anaconda3/Lib/site-packages/flexx/ui/layouts/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.659">""" Layout
"""

from . import Widget


</t>
<t tx="ekr.20181031045138.66">@property
def cls(self):
    """ The Component class that is the basis of this app.
    """
    return self._cls

</t>
<t tx="ekr.20181031045138.660">class Layout(Widget):
    """ Abstract class for widgets that layout their child widgets.
    """

    CSS = """

    body {
        margin: 0;
        padding: 0;
    }

    .flx-Layout {
        /* sizing of widgets/layouts inside layout is defined per layout */
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        border-spacing: 0;
        border: 0;
    }

    """
</t>
<t tx="ekr.20181031045138.661">@path C:/Anaconda3/Lib/site-packages/flexx/ui/layouts/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.662">""" PinboardLayout

Free positioning (absolute or relative) of child widgets. Example:

.. UIExample:: 200

    from flexx import app, ui

    class Example(ui.Widget):

        def init(self):

            with ui.PinboardLayout():
                self.b1 = ui.Button(text='Stuck at (20, 20)',
                                    style='left:20px; top:20px;')
                self.b2 = ui.Button(text='Dynamic at (30%, 30%)',
                                    style='left:30%; top:30%; height:100px;')
                self.b3 = ui.Button(text='Dynamic at (50%, 70%)',
                                    style='left:50%; top:70%;')

"""

from . import Layout


</t>
<t tx="ekr.20181031045138.663">class PinboardLayout(Layout):
    """ Unconstrained absolute and relative positioning of child widgets.

    This simply places child widgets using CSS "position: absolute". Use
    CSS "left" and "top" to position the widget (using a "px" or "%" suffix).
    Optionally "width", "height", "right" and "bottom" can also be used.
    
    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_.
    """

    CSS = """
    .flx-PinboardLayout &gt; .flx-Widget {
        position: absolute;
    }
    """
</t>
<t tx="ekr.20181031045138.664">@path C:/Anaconda3/Lib/site-packages/flexx/ui/layouts/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.665">""" StackLayout

Show only one child at any time. Example:

.. UIExample:: 200

    from flexx import app, event, ui

    class Example(ui.Widget):

        def init(self):
            with ui.HBox():
                with ui.VBox():
                    self.buta = ui.Button(text='red')
                    self.butb = ui.Button(text='green')
                    self.butc = ui.Button(text='blue')
                    ui.Widget(flex=1)  # space filler
                with ui.StackLayout(flex=1) as self.stack:
                    self.buta.w = ui.Widget(style='background:#a00;')
                    self.butb.w = ui.Widget(style='background:#0a0;')
                    self.butc.w = ui.Widget(style='background:#00a;')

        @event.reaction('buta.pointer_down', 'butb.pointer_down', 'butc.pointer_down')
        def _stacked_current(self, *events):
            button = events[-1].source
            self.stack.set_current(button.w)
"""

from ... import event
from . import Layout


</t>
<t tx="ekr.20181031045138.666">class StackLayout(Layout):
    """ A layout widget which shows only one of its children at a time.
    
    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_.
    """

    CSS = """
        .flx-StackLayout &gt; .flx-Widget {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
        }
        .flx-StackLayout &gt; .flx-Widget:not(.flx-current) {
            display: none;
        }
    """

    current = event.ComponentProp(doc="""
            The currently shown widget (or None).
            """)

    @others
</t>
<t tx="ekr.20181031045138.667">@event.action
def set_current(self, current):
    """ Setter for current widget. Can also set using an integer index.
    """
    if isinstance(current, (float, int)):
        current = self.children[int(current)]
    self._mutate_current(current)

</t>
<t tx="ekr.20181031045138.668">@event.reaction
def __set_current_widget(self):
    current = self.current
    children = self.children

    if len(children) == 0:
        if current is not None:
            self.set_current(None)
    else:
        if current is None:
            current = children[0]
            self.set_current(current)

        for widget in self.children:
            if widget is current:
                widget.outernode.classList.add('flx-current')
                widget.check_real_size()
            else:
                widget.outernode.classList.remove('flx-current')
</t>
<t tx="ekr.20181031045138.669">@path C:/Anaconda3/Lib/site-packages/flexx/ui/layouts/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.67">@property
def is_served(self):
    """ Whether this app is already registered by the app manager.
    """
    return self._is_served

</t>
<t tx="ekr.20181031045138.670">""" TabLayout

A ``StackLayout`` subclass that uses tabs to let the user select a child widget.

Example:

.. UIExample:: 100

    from flexx import app, ui

    class Example(ui.Widget):
        def init(self):
            with ui.TabLayout() as self.t:
                self.a = ui.Widget(title='red', style='background:#a00;')
                self.b = ui.Widget(title='green', style='background:#0a0;')
                self.c = ui.Widget(title='blue', style='background:#00a;')

Also see examples: :ref:`demo.py`.

"""

from pscript import window

from ... import event
from ._stack import StackLayout


</t>
<t tx="ekr.20181031045138.671">class TabLayout(StackLayout):
    """ A StackLayout which provides a tabbar for selecting the current widget.
    The title of each child widget is used for the tab label.
    
    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_.
    The visible child widget fills the entire area of this element,
    except for a small area at the top where the tab-bar is shown.
    """

    CSS = """

    .flx-TabLayout &gt; .flx-Widget {
        top: 30px;
        margin: 0;
        height: calc(100% - 30px);
        border: 1px solid #ddd;
    }

    .flx-TabLayout &gt; .flx-tabbar {
        box-sizing: border-box;
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 30px;
        overflow: hidden;
    }

    .flx-tabbar &gt; .flx-tab-item {
        display: inline-block;
        height: 22px;  /* 100% - 8px: 3 margin + 2 borders + 2 padding -1 overlap */
        margin-top: 3px;
        padding: 3px 6px 1px 6px;

        overflow: hidden;
        min-width: 10px;

        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;

        background: #ececec;
        border: 1px solid #bbb;
        border-radius: 3px 3px 0px 0px;
        margin-left: -1px;
        transition: background 0.3s;
    }
    .flx-tabbar &gt; .flx-tab-item:first-of-type {
        margin-left: 0;
    }

    .flx-tabbar &gt; .flx-tab-item.flx-current {
        background: #eaecff;
        border-top: 3px solid #7bf;
        margin-top: 0;
    }

    .flx-tabbar &gt; .flx-tab-item:hover {
        background: #eaecff;
    }
    """

    @others
</t>
<t tx="ekr.20181031045138.672">def _create_dom(self):
    outernode = window.document.createElement('div')
    self._tabbar = window.document.createElement('div')
    self._tabbar.classList.add('flx-tabbar')
    self._addEventListener(self._tabbar, 'mousedown',  # also works for touch
                           self._tabbar_click)
    outernode.appendChild(self._tabbar)
    return outernode

</t>
<t tx="ekr.20181031045138.673">def _render_dom(self):
    nodes = [child.outernode for child in self.children]
    nodes.append(self._tabbar)
    return nodes

</t>
<t tx="ekr.20181031045138.674">@event.reaction
def __update_tabs(self):
    children = self.children
    current = self.current

    # Add items to tabbar as needed
    while len(self._tabbar.children) &lt; len(children):
        node = window.document.createElement('p')
        node.classList.add('flx-tab-item')
        node.index = len(self._tabbar.children)
        self._tabbar.appendChild(node)

    # Remove items from tabbar as needed
    while len(self._tabbar.children) &gt; len(children):
        c = self._tabbar.children[len(self._tabbar.children) - 1]
        self._tabbar.removeChild(c)

    # Update titles
    for i in range(len(children)):
        widget = children[i]
        node = self._tabbar.children[i]
        node.textContent = widget.title
        if widget is current:
            node.classList.add('flx-current')
        else:
            node.classList.remove('flx-current')

    # Update sizes
    self.__checks_sizes()

</t>
<t tx="ekr.20181031045138.675">@event.reaction('size')
def __checks_sizes(self, *events):
    # Make the tabbar items occupy (nearly) the full width
    nodes = self._tabbar.children
    width = (self.size[0] - 10) / len(nodes) - 2 - 12  # - padding and border
    for i in range(len(nodes)):
        nodes[i].style.width = width + 'px'

</t>
<t tx="ekr.20181031045138.676">@event.emitter
def user_current(self, current):
    """ Event emitted when the user selects a tab. Can be used to distinguish
    user-invoked from programatically-invoked tab changes.
    Has ``old_value`` and ``new_value`` attributes.
    """
    if isinstance(current, (float, int)):
        current = self.children[int(current)]
    d = {'old_value': self.current, 'new_value': current}
    self.set_current(current)
    return d

</t>
<t tx="ekr.20181031045138.677">def _tabbar_click(self, e):
    index = e.target.index
    if index &gt;= 0:
        self.user_current(index)
</t>
<t tx="ekr.20181031045138.678">@path C:/Anaconda3/Lib/site-packages/flexx/ui/layouts/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.679">""" Namespace for all layout widgets.
"""

# flake8: noqa

from .._widget import Widget

from ._layout import Layout
from ._hv import HVLayout, HBox, VBox, HFix, VFix, HSplit, VSplit
from ._stack import StackLayout
from ._tabs import TabLayout
from ._pinboard import PinboardLayout
from ._form import FormLayout
</t>
<t tx="ekr.20181031045138.68">@property
def url(self):
    """ The url to acces this app. This raises an error if serve() has not
    been called yet or if Flexx' server is not yet running.
    """
    server = current_server(False)
    if not self._is_served:
        raise RuntimeError('Cannot determine app url if app is not yet "served".')
    elif not (server and server.serving):
        raise RuntimeError('Cannot determine app url if the server is not '
                           'yet running.')
    else:
        proto = server.protocol
        host, port = server.serving
        path = self._path + '/' if self._path else ''
        return '%s://%s:%i/%s' % (proto, host, port, path)

</t>
<t tx="ekr.20181031045138.680"></t>
<t tx="ekr.20181031045138.681">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.682">""" BokehWidget

Show Bokeh plots in Flexx. Example:

.. UIExample:: 300

    import numpy as np
    from bokeh.plotting import figure
    from flexx import app, event, ui

    x = np.linspace(0, 6, 50)

    p1 = figure()
    p1.line(x, np.sin(x))

    p2 = figure()
    p2.line(x, np.cos(x))

    class Example(app.PyComponent):
        def init(self):
            with ui.HSplit():
                ui.BokehWidget.from_plot(p1)
                ui.BokehWidget.from_plot(p2)

Also see examples: :ref:`bokehdemo.py`.

"""


import os

from ... import event, app
from . import Widget


</t>
<t tx="ekr.20181031045138.683">def _load_bokeh(ext):
    import bokeh.resources
    dev = os.environ.get('BOKEH_RESOURCES', '') == 'relative-dev'
    res = bokeh.resources.bokehjsdir()
    if dev:
        res = os.path.abspath(os.path.join(bokeh.__file__,
                                            '..', '..', 'bokehjs', 'build'))
    modname = 'bokeh' if dev else 'bokeh.min'
    filename = os.path.join(res, ext, modname + '.' + ext)
    return open(filename, 'rb').read().decode()

</t>
<t tx="ekr.20181031045138.684">def _load_bokeh_js():
    return _load_bokeh('js')

</t>
<t tx="ekr.20181031045138.685">def _load_bokeh_css():
    return _load_bokeh('css')

# Associate Bokeh asset, but in a "lazy" way, so that we don't attempt to
# import bokeh until the user actually instantiates a BokehWidget.
app.assets.associate_asset(__name__, 'bokeh.js', _load_bokeh_js)
app.assets.associate_asset(__name__, 'bokeh.css', _load_bokeh_css)


</t>
<t tx="ekr.20181031045138.686">def make_bokeh_widget(plot, **kwargs):
    from bokeh.models import Plot
    from bokeh.embed import components
    # Set plot prop
    if not isinstance(plot, Plot):
        raise ValueError('plot must be a Bokeh plot object.')
    # The sizing_mode is fixed by default, but that's silly in this context
    if plot.sizing_mode == 'fixed':
        plot.sizing_mode = 'stretch_both'
    # Get components and apply to widget
    script, div = components(plot)
    script = '\n'.join(script.strip().split('\n')[1:-1])
    widget = BokehWidget(**kwargs)
    widget.set_plot_components(
        dict(script=script, div=div, id=plot.ref['id']))
    return widget


</t>
<t tx="ekr.20181031045138.687">class BokehWidget(Widget):
    """ A widget that shows a Bokeh plot object.

    For Bokeh 0.12 and up. The plot's ``sizing_mode`` property is set to
    ``stretch_both`` unless it was set to something other than ``fixed``. Other
    responsive modes are 'scale_width', 'scale_height' and 'scale_both`, which
    all keep aspect ratio while being responsive in a certain direction.

    This widget is, like all widgets, a JsComponent; it lives in the browser,
    while the Bokeh plot is a Python object. Therefore we cannot simply use
    a property to set the plot. Use ``ui.BokehWidget.from_plot(plot)`` to
    instantiate the widget from Python.
    """

    DEFAULT_MIN_SIZE = 100, 100

    CSS = """
    .flx-BokehWidget &gt; .plotdiv {
        overflow: hidden;
    }
    """

    @others
</t>
<t tx="ekr.20181031045138.688">@classmethod
def from_plot(cls, plot, **kwargs):
    """ Create a BokehWidget using a Bokeh plot.
    """
    return make_bokeh_widget(plot, **kwargs)

plot = event.Attribute(doc="""The JS-side of the Bokeh plot object.""")

</t>
<t tx="ekr.20181031045138.689">def _render_dom(self):
    return None

</t>
<t tx="ekr.20181031045138.69">@property
def name(self):
    """ The name of the app, i.e. the url path that this app is served at.
    """
    return self._path or '__main__'

</t>
<t tx="ekr.20181031045138.690">@event.action
def set_plot_components(self, d):
    """ Set the plot using its script/html components.
    """
    global window
    # Embed div
    self.node.innerHTML = d.div  # We put trust in d.div
    # "exec" code
    el = window.document.createElement('script')
    el.innerHTML = d.script
    self.node.appendChild(el)
    # Get plot from id in next event-loop iter
    def getplot():
        self._plot = window.Bokeh.index[d.id]
        self.__resize_plot()
    window.setTimeout(getplot, 10)

</t>
<t tx="ekr.20181031045138.691">@event.reaction('size')
def __resize_plot(self, *events):
    if self.plot and self.parent:
        if self.plot.resize:
            self.plot.resize()
        else:
            self.plot.model.document.resize()  # older
</t>
<t tx="ekr.20181031045138.692">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.693">""" Button classes

Simple example:

.. UIExample:: 50

    b = ui.Button(text="Push me")


Also see examples: :ref:`buttons.py`.

"""

from ... import event
from .._widget import Widget


</t>
<t tx="ekr.20181031045138.694">class BaseButton(Widget):
    """ Abstract button class.
    """

    DEFAULT_MIN_SIZE = 10, 24

    CSS = """

    .flx-BaseButton {
        white-space: nowrap;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        color: #333;
    }
    .flx-BaseButton, .flx-BaseButton &gt; input {
        margin: 2px; /* room for outline */
    }
    .flx-BaseButton:focus, .flx-BaseButton &gt; input:focus  {
        outline: none;
        box-shadow: 0px 0px 3px 1px rgba(0, 100, 200, 0.7);
    }

    .flx-Button, .flx-ToggleButton{
        background: #e8e8e8;
        border: 1px solid #ccc;
        transition: background 0.3s;
    }
    .flx-Button:hover, .flx-ToggleButton:hover {
        background: #e8eaff;
    }

    .flx-ToggleButton {
        text-align: left;
    }
    .flx-ToggleButton.flx-checked {
        background: #e8eaff;
    }
    .flx-ToggleButton::before {
        content: '\\2610\\00a0 ';
    }
    .flx-ToggleButton.flx-checked::before {
        content: '\\2611\\00a0 ';
    }

    .flx-RadioButton &gt; input, .flx-CheckBox &gt; input{
        margin-left: 0.3em;
        margin-right: 0.3em;
    }

    .flx-RadioButton &gt; input, .flx-CheckBox &gt; input {
        color: #333;
    }
    .flx-RadioButton:hover &gt; input, .flx-CheckBox:hover &gt; input {
        color: #036;
    }
    """

    text = event.StringProp('', settable=True, doc="""
        The text on the button.
        """)

    checked = event.BoolProp(False, settable=True, doc="""
        Whether the button is checked.
        """)

    disabled = event.BoolProp(False, settable=True, doc="""
        Whether the button is disabled.
        """)

    @others
</t>
<t tx="ekr.20181031045138.695">@event.reaction('pointer_click')
def __on_pointer_click(self, e):
    self.node.blur()

</t>
<t tx="ekr.20181031045138.696">@event.emitter
def user_checked(self, checked):
    """ Event emitted when the user (un)checks this button. Has
    ``old_value`` and ``new_value`` attributes.
    """
    d = {'old_value': self.checked, 'new_value': checked}
    self.set_checked(checked)
    return d


</t>
<t tx="ekr.20181031045138.697">class Button(BaseButton):
    """ A push button.
    
    The ``node`` of this widget is a
    `&lt;button&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/button&gt;`_.
    """

    DEFAULT_MIN_SIZE = 10, 28

    @others
</t>
<t tx="ekr.20181031045138.698">def _create_dom(self):
    global window
    node = window.document.createElement('button')
    # node = window.document.createElement('input')
    # node.setAttribute('type', 'button')
    return node

</t>
<t tx="ekr.20181031045138.699">def _render_dom(self):
    return [self.text]

</t>
<t tx="ekr.20181031045138.7">"""
`Flexx &lt;https://flexx.readthedocs.io&gt;`_ is a pure Python toolkit for
creating graphical user interfaces (GUI's), that uses web technology
for its rendering. Apps are written purely in Python; The
`PScript &lt;https://pscript.readthedocs.io&gt;`_ transpiler generates the
necessary JavaScript on the fly.

You can use Flexx to create (cross platform) desktop applications, web
applications, and export an app to a standalone HTML document. It also
works in the Jupyter notebook.

The docs are on `Readthedocs &lt;http://flexx.readthedocs.io&gt;`_,
the code is on `Github &lt;http://github.com/flexxui/flexx&gt;`_,
and there is a `demo server &lt;http://demo.flexx.app&gt;`_.
Once you've got started, the most important page is probably the
:doc:`Widget reference &lt;ui/api&gt;`.

----

For more information, see http://flexx.readthedocs.io.
"""

# NOTES ON DOCS:
# There are 2 places that define the short summary of Flexx: the
# __init__.py and the README.md. Their summaries should be kept equal.
# The index.rst for the docs uses the summary from __init__.py (the
# part after the "----" is stripped. The long-description for Pypi is
# obtained by converting README.md to RST.

__version__ = '0.6.2'

# Assert compatibility
import sys
</t>
<t tx="ekr.20181031045138.70">def serve(self, name=None):
    """ Start serving this app.

    This registers the given class with the internal app manager. The
    app can be loaded via 'http://hostname:port/name'.

    Arguments:
        name (str, optional): the relative URL path to serve the app on.
            If this is ``''`` (the empty string), this will be the main app.
            If not given or None, the name of the component class is used.
    """
    # Note: this talks to the manager; it has nothing to do with the server
    if self._is_served:
        raise RuntimeError('This app (%s) is already served.' % self.name)
    if name is not None:
        self._path = name
    manager.register_app(self)
    self._is_served = True

</t>
<t tx="ekr.20181031045138.700">@event.reaction('disabled')
def __disabled_changed(self, *events):
    if events[-1].new_value:
        self.node.setAttribute("disabled", "disabled")
    else:
        self.node.removeAttribute("disabled")


</t>
<t tx="ekr.20181031045138.701">class ToggleButton(BaseButton):
    """ A button that can be toggled. It behaves like a checkbox, while
    looking more like a regular button.
    
    The ``node`` of this widget is a
    `&lt;button&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/button&gt;`_.
    """

    DEFAULT_MIN_SIZE = 10, 28

    @others
</t>
<t tx="ekr.20181031045138.702">def _create_dom(self):
    global window
    node = window.document.createElement('button')
    return node

</t>
<t tx="ekr.20181031045138.703">def _render_dom(self):
    return [self.text]

</t>
<t tx="ekr.20181031045138.704">@event.reaction('pointer_click')
def __toggle_checked(self, *events):
    self.user_checked(not self.checked)

</t>
<t tx="ekr.20181031045138.705">@event.reaction('checked')
def __check_changed(self, *events):
    if self.checked:
        self.node.classList.add('flx-checked')
    else:
        self.node.classList.remove('flx-checked')


</t>
<t tx="ekr.20181031045138.706">class RadioButton(BaseButton):
    """ A radio button. Of any group of radio buttons that share the
    same parent, only one can be active.
    
    The ``outernode`` of this widget is a
    `&lt;label&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/label&gt;`_,
    and the ``node`` a radio
    `&lt;input&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/input&gt;`_.
    """

    @others
</t>
<t tx="ekr.20181031045138.707">def _create_dom(self):
    global window
    outernode = window.document.createElement('label')
    node = window.document.createElement('input')
    outernode.appendChild(node)

    node.setAttribute('type', 'radio')
    node.setAttribute('id', self.id)
    outernode.setAttribute('for', self.id)

    return outernode, node

</t>
<t tx="ekr.20181031045138.708">def _render_dom(self):
    return [self.node, self.text]

</t>
<t tx="ekr.20181031045138.709">@event.reaction('parent')
def __update_group(self, *events):
    if self.parent:
        self.node.name = self.parent.id

</t>
<t tx="ekr.20181031045138.71">def launch(self, runtime=None, **runtime_kwargs):
    """ Launch this app as a desktop app in the given runtime.
    See https://webruntime.readthedocs.io for details.

    Arguments:
        runtime (str): the runtime to launch the application in.
            Default 'app or browser'.
        runtime_kwargs: kwargs to pass to the ``webruntime.launch`` function.
            A few names are passed to runtime kwargs if not already present
            ('title' and 'icon').

    Returns:
        Component: an instance of the given class.
    """
    # creates server (and event loop) if it did not yet exist
    current_server()

    # Create session
    if not self._is_served:
        self.serve()
    session = manager.create_session(self.name)

    # Transfer title and icon
    if runtime_kwargs.get('title', None) is None and 'title' in self.kwargs:
        runtime_kwargs['title'] = self.kwargs['title']
    if runtime_kwargs.get('icon', None) is None and 'icon' in self.kwargs:
        runtime_kwargs['icon'] = self.kwargs['icon']
    # Launch web runtime, the server will wait for the connection
    url = self.url + '?session_id=%s' % session.id
    if not runtime or '!' in config.webruntime:
        runtime = config.webruntime.strip('!')
    session._runtime = webruntime.launch(url, runtime=runtime, **runtime_kwargs)
    return session.app

</t>
<t tx="ekr.20181031045138.710">@event.reaction('checked')
def __check_changed(self, *events):
    self.node.checked = self.checked

</t>
<t tx="ekr.20181031045138.711">@event.emitter
def pointer_click(self, e):
    """ This method is called on JS a click event. We *first* update
    the checked properties, and then emit the Flexx click event.
    That way, one can connect to the click event and have an
    up-to-date checked props (even on Py).
    """
    # Turn off any radio buttons in the same group
    if self.parent:
        for child in self.parent.children:
            if isinstance(child, RadioButton) and child is not self:
                child.set_checked(child.node.checked)
    # Turn on this button (last)
    self.user_checked(self.node.checked)  # instead of set_checked
    # Process actual click event
    super().pointer_click(e)


</t>
<t tx="ekr.20181031045138.712">class CheckBox(BaseButton):
    """ A checkbox button.
    
    The ``outernode`` of this widget is a
    `&lt;label&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/label&gt;`_,
    and the ``node`` a checkbox
    `&lt;input&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/input&gt;`_.
    """

    @others
</t>
<t tx="ekr.20181031045138.713">def _create_dom(self):
    global window
    outernode = window.document.createElement('label')
    node = window.document.createElement('input')
    outernode.appendChild(node)

    node.setAttribute('type', 'checkbox')
    node.setAttribute('id', self.id)
    outernode.setAttribute('for', self.id)
    self._addEventListener(node, 'click', self._check_changed_from_dom, 0)

    return outernode, node

</t>
<t tx="ekr.20181031045138.714">def _render_dom(self):
    return [self.node, self.text]

</t>
<t tx="ekr.20181031045138.715">@event.reaction('checked')
def __check_changed(self, *events):
    self.node.checked = self.checked

</t>
<t tx="ekr.20181031045138.716">def _check_changed_from_dom(self, ev):
    self.user_checked(self.node.checked)
</t>
<t tx="ekr.20181031045138.717">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.718">""" CanvasWidget

The canvas can be used for specialized graphics of many sorts. It can
provide either a WebGL context or a 2d context as in the example below:

.. UIExample:: 100

    from flexx import app, event, ui

    class Example(ui.CanvasWidget):

        def init(self):
            super().init()
            self.ctx = self.node.getContext('2d')
            self.set_capture_mouse(1)
            self._last_pos = (0, 0)

        @event.reaction('pointer_move')
        def on_move(self, *events):
            for ev in events:
                self.ctx.beginPath()
                self.ctx.strokeStyle = '#080'
                self.ctx.lineWidth = 3
                self.ctx.lineCap = 'round'
                self.ctx.moveTo(*self._last_pos)
                self.ctx.lineTo(*ev.pos)
                self.ctx.stroke()
                self._last_pos = ev.pos

        @event.reaction('pointer_down')
        def on_down(self, *events):
            self._last_pos = events[-1].pos

Also see example: :ref:`drawing.py`, :ref:`splines.py`.

"""

from ... import event
from .. import Widget

perf_counter = None  # exists in PScript, time.perf_counter only in Python 3.3+

# todo: make it easy to enable high-res aa


</t>
<t tx="ekr.20181031045138.719">class CanvasWidget(Widget):
    """ A widget that provides an HTML5 canvas. The canvas is scaled with
    the available space. Use ``self.node.getContext('2d')`` or
    ``self.node.getContext('webgl')`` in the ``init()`` method to get
    a contex to perform the actual drawing.
    
    The ``node`` of this widget is a
    `&lt;canvas&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/canvas&gt;`_
    wrapped in a `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_
    (the ``outernode``) to handle sizing.
    """

    DEFAULT_MIN_SIZE = 50, 50

    CSS = """
    .flx-CanvasWidget {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    .flx-CanvasWidget &gt; canvas {
        /* Set position to absolute so that the canvas is not going
         * to be forcing a size on the container div. */
        position: absolute;
    }
    """

    capture_wheel = event.BoolProp(False, settable=True, doc="""
        Whether the wheel event is "captured", i.e. not propagated to result
        into scrolling of the parent widget (or page). If True, if no scrolling
        must have been performed outside of the widget for about half a second
        in order for the widget to capture scroll events.
        """)

    @others
</t>
<t tx="ekr.20181031045138.72">def dump(self, fname=None, link=2):
    """ Get a dictionary of web assets that statically represents the app.

    The returned dict contains at least one html file. Any
    session-specific or shared data is also included. If link is
    2/3, all shared assets are included too (and the main document
    links to them). A link value of 0/1 may be prefered for
    performance or ease of distribution, but with link 2/3 debugging
    is easier and multiple apps can share common assets.
    
    When a process only dumps/exports an app, no server is started.
    Tornado is not even imported (we have a test for this). This makes
    it possible to use Flexx to dump an app and then serve it with any
    tool one likes.
    
    Arguments:
        fname (str, optional): the name of the main html asset.
            If not given or None, the name of the component class
            is used. Must end in .html/.htm/.hta.
        link (int): whether to link (JS and CSS) assets or embed them:
            A values of 0/1 is recommended for single (and standalone) apps,
            while multiple apps can share common assets by using 2/3.

            * 0: all assets are embedded into the main html document.
            * 1: normal assets are embedded, remote assets remain remote.
            * 2: all assets are linked (as separate files). Default.
            * 3: normal assets are linked, remote assets remain remote.

    Returns:
        dict: A collection of assets.
    """

    # Get asset name
    if fname is None:
        if self.name in ('__main__', ''):
            fname = 'index.html'
        else:
            fname = self.name.lower() + '.html'

    # Validate fname
    if os.path.basename(fname) != fname:
        raise ValueError('App.dump() fname must not contain directory names.')
    elif not fname.lower().endswith(('.html', 'htm', '.hta')):
        raise ValueError('Invalid extension for dumping {}'.format(fname))

    # Do stripped version of manager.create_session()
    name = fname.split('.')[0].replace('-', '_').replace(' ', '_')
    session = Session(name)
    session._id = name  # Force id to be the same on each dump
    # Instantiate the component
    self(flx_session=session, flx_is_app=True)

    # Do stripped version of manager.connect_client()
    exporter = ExporterWebSocketDummy()
    session._set_ws(exporter)

    assert link in (0, 1, 2, 3), "Expecting link to be in (0, 1, 2, 3)."

    # Warn for PyComponents
    if issubclass(self.cls, PyComponent):
        logger.warn('Exporting a PyComponent - any Python interactivity will '
                    'not work in exported apps.')

    d = {}

    # Get main HTML page
    html = get_page_for_export(session, exporter.commands, link)
    if fname.lower().endswith('.hta'):
        hta_tag = '&lt;meta http-equiv="x-ua-compatible" content="ie=edge" /&gt;'
        html = html.replace('&lt;head&gt;', '&lt;head&gt;\n    ' + hta_tag, 1)
    d[fname] = html.encode()

    # Add shares assets if we link to it from the main page
    if link in (2, 3):
        d.update(assets._dump_assets(link==2))  # also_remote if link==2

    # Add session specific, and shared data
    d.update(session._dump_data())
    d.update(assets._dump_data())

    return d

</t>
<t tx="ekr.20181031045138.720">def _create_dom(self):
    global window

    outernode = window.document.createElement('div')
    innernode = window.document.createElement('canvas')
    innernode.id = self.id + '-canvas'
    outernode.appendChild(innernode)

    # Disable context menu so we can handle RMB clicks
    # Firefox is particularly stuborn with Shift+RMB, and RMB dbl click
    for ev_name in ('contextmenu', 'click', 'dblclick'):
        self._addEventListener(window.document, ev_name,
                               self._prevent_default_event, 0)

    # If the canvas uses the wheel event for something, you'd want to
    # disable browser-scroll when the mouse is over the canvas. But
    # when you scroll down a page and the cursor comes over the canvas
    # because of that, we don't want the canvas to capture too eagerly.
    # This code only captures if there has not been scrolled elsewhere
    # for about half a second.
    def wheel_behavior(e):
        id, t0 = window.flexx._wheel_timestamp
        t1 = perf_counter()
        if (t1 - t0) &lt; 0.5:
            window.flexx._wheel_timestamp = id, t1  # keep scrolling
        else:
            window.flexx._wheel_timestamp = e.target.id, t1  # new scroll
    if not window.flexx._wheel_timestamp:
        window.flexx._wheel_timestamp = 0, ''
        self._addEventListener(window.document, 'wheel', wheel_behavior, 0)

    return outernode, innernode

</t>
<t tx="ekr.20181031045138.721">def _prevent_default_event(self, e):
    """ Prevent the default action of an event unless all modifier
    keys (shift, ctrl, alt) are pressed down.
    """
    if e.target is self.node:
        if not (e.altKey is True and e.ctrlKey is True and e.shiftKey is True):
            e.preventDefault()

</t>
<t tx="ekr.20181031045138.722">def _create_pointer_event(self, e):
    # In a canvas, prevent browser zooming and the like
    if e.type.startswith('touch'):
        e.preventDefault()
    return super()._create_pointer_event(e)

</t>
<t tx="ekr.20181031045138.723">@event.emitter
def pointer_wheel(self, e):
    global window
    if self.capture_wheel &lt;= 0:
        return super().pointer_wheel(e)  # normal behavior
    elif window.flexx._wheel_timestamp[0] == self.node.id:
        e.preventDefault()
        return super().pointer_wheel(e)

</t>
<t tx="ekr.20181031045138.724">@event.reaction
def _update_canvas_size(self, *events):
    size = self.size
    if size[0] or size[1]:
        self.node.width = size[0]
        self.node.height = size[1]
        self.node.style.width = size[0] + 'px'
        self.node.style.height = size[1] + 'px'
</t>
<t tx="ekr.20181031045138.725">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.726">""" ColorSelectWidget

.. UIExample:: 50

    from flexx import event, ui

    class Example(ui.Widget):

        def init(self):
            self.c = ui.ColorSelectWidget()

        @event.reaction
        def _color_changed(self):
            self.node.style.background = self.c.color.hex
"""

from ... import event
from . import Widget


</t>
<t tx="ekr.20181031045138.727">class ColorSelectWidget(Widget):
    """ A widget used to select a color.

    The ``node`` of this widget is an
    `&lt;input&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/input&gt;`_
    element of type ``color``. This is supported at least
    on Firefox and Chrome, but not on IE.
    """

    DEFAULT_MIN_SIZE = 28, 28

    color = event.ColorProp('#000000', settable=True, doc="""
        The currently selected color.
        """)

    disabled = event.BoolProp(False, settable=True, doc="""
        Whether the color select is disabled.
        """)

    @others
</t>
<t tx="ekr.20181031045138.728">def _create_dom(self):
    global window
    node = window.document.createElement('input')
    try:
        node.type = 'color'
    except Exception:  # This widget simply does not work on IE
        node = window.document.createElement('div')
        node.innerHTML = 'Not supported'
    self._addEventListener(node, 'input', self._color_changed_from_dom, 0)
    return node

</t>
<t tx="ekr.20181031045138.729">@event.emitter
def user_color(self, color):
    """ Event emitted when the user changes the color. Has ``old_value``
    and ``new_value`` attributes.
    """
    d = {'old_value': self.color, 'new_value': color}
    self.set_color(color)
    return d

</t>
<t tx="ekr.20181031045138.73">def export(self, filename, link=2, overwrite=True):
    """ Export this app to a static website.

    Also see dump(). An app that contains no data, can be exported to a
    single html document by setting link to 0.

    Arguments:
        filename (str): Path to write the HTML document to.
            If the filename ends with .hta, a Windows HTML Application is
            created. If a directory is given, the app is exported to
            appname.html in that directory.
        link (int): whether to link (JS and CSS) assets or embed them:

            * 0: all assets are embedded into the main html document.
            * 1: normal assets are embedded, remote assets remain remote.
            * 2: all assets are linked (as separate files). Default.
            * 3: normal assets are linked, remote assets remain remote.
        overwrite (bool, optional): if True (default) will overwrite files
            that already exist. Otherwise existing files are skipped.
            The latter makes it possible to efficiently export a series of
            apps to the same directory and have them share common assets.
    """

    # Derive dirname and app name
    if not isinstance(filename, str):
        raise ValueError('str filename required, use dump() for in-memory export.')
    filename = os.path.abspath(os.path.expanduser(filename))
    if (
            os.path.isdir(filename) or
            filename.endswith(('/', '\\')) or
            '.' not in os.path.basename(filename)
            ):
        dirname = filename
        fname = None
    else:
        dirname, fname = os.path.split(filename)

    # Collect asset dict
    d = self.dump(fname, link)

    # Write all assets to file
    for fname, blob in d.items():
        filename = os.path.join(dirname, fname)
        if not overwrite and os.path.isfile(filename):
            continue
        dname = os.path.dirname(filename)
        if not os.path.isdir(dname):
            os.makedirs(dname)
        with open(filename, 'wb') as f:
            f.write(blob)

    app_type = 'standalone app' if len(d) == 1 else 'app'
    logger.info('Exported %s to %r' % (app_type, filename))

</t>
<t tx="ekr.20181031045138.730">@event.reaction('color')
def _color_changed(self, *events):
    self.node.value = self.color.hex  # hex is html-compatible, color.css is not

</t>
<t tx="ekr.20181031045138.731">def _color_changed_from_dom(self, e):
    self.user_color(self.node.value)

</t>
<t tx="ekr.20181031045138.732">@event.reaction('disabled')
def __disabled_changed(self, *events):
    if self.disabled:
        self.node.setAttribute("disabled", "disabled")
    else:
        self.node.removeAttribute("disabled")
</t>
<t tx="ekr.20181031045138.733">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.734">""" Dropdown widgets

.. UIExample:: 120

    from flexx import app, event, ui

    class Example(ui.Widget):

        def init(self):
            self.combo = ui.ComboBox(editable=True,
                                     options=('foo', 'bar', 'spaaaaaaaaam', 'eggs'))
            self.label = ui.Label()

        @event.reaction
        def update_label(self):
            text = 'Combobox text: ' + self.combo.text
            if self.combo.selected_index is not None:
                text += ' (index %i)' % self.combo.selected_index
            self.label.set_text(text)

Also see examples: :ref:`control_with_keys.py`.

"""

from pscript import window

from ... import event, app
from .._widget import Widget, create_element


# todo: some form of autocompletetion?


</t>
<t tx="ekr.20181031045138.735">class BaseDropdown(Widget):
    """ Base class for drop-down-like widgets.
    """

    DEFAULT_MIN_SIZE = 50, 28

    CSS = """

        .flx-BaseDropdown {
            display: inline-block;
            overflow: visible;
            margin: 2px;
            border-radius: 3px;
            padding: 2px;
            border: 1px solid #aaa;
            max-height: 28px; /* overridden by maxsize */
            white-space: nowrap; /* keep label and but on-line */
            background: #e8e8e8
        }

        .flx-BaseDropdown:focus {
            outline: none;
            box-shadow: 0px 0px 3px 1px rgba(0, 100, 200, 0.7);
        }

        .flx-BaseDropdown &gt; .flx-dd-edit {
            display: none;
            max-width: 2em;  /* reset silly lineedit sizing */
            min-width: calc(100% - 1.5em - 2px);
            min-height: 1em;
            margin: 0;
            padding: 0;
            border: none;
        }

        .flx-BaseDropdown &gt; .flx-dd-label {
            display: inline-block;
            min-width: calc(100% - 1.5em - 2px);
            min-height: 1em;
            user-select: none;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        .flx-BaseDropdown.editable-true {
            background: #fff;
        }
        .flx-BaseDropdown.editable-true &gt; .flx-dd-label {
            display: none;
        }
        .flx-BaseDropdown.editable-true &gt; .flx-dd-edit {
            display: inline-block;
        }

        .flx-BaseDropdown &gt; .flx-dd-button {
            display: inline-block;
            position: static;
            min-width: 1.5em;
            max-width: 1.5em;
            text-align: center;
            margin: 0;
        }
        .flx-BaseDropdown &gt; .flx-dd-button:hover {
            background: rgba(128, 128, 128, 0.1);
        }
        .flx-BaseDropdown &gt; .flx-dd-button::after {
            content: '\\25BE';  /* 2228 1F847 1F83F */
        }

        .flx-BaseDropdown .flx-dd-space {
            display: inline-block;
            min-width: 1em;
        }

        .flx-BaseDropdown &gt; .flx-dd-strud {
            /* The strud allows to give the box a natural minimum size,
               but it should not affect the height. */
            visibility: hidden;
            overflow: hidden;
            max-height: 0;
        }
    """

    @others
</t>
<t tx="ekr.20181031045138.736">def init(self):
    if self.tabindex == -2:
        self.set_tabindex(-1)

</t>
<t tx="ekr.20181031045138.737">@event.action
def expand(self):
    """ Expand the dropdown and give it focus, so that it can be used
    with the up/down keys.
    """
    self._expand()
    self.node.focus()

</t>
<t tx="ekr.20181031045138.738">def _create_dom(self):
    return window.document.createElement('span')

</t>
<t tx="ekr.20181031045138.739">def _render_dom(self):
    # Render more or less this:
    # &lt;span class='flx-dd-label'&gt;&lt;/span&gt;
    # &lt;input type='text' class='flx-dd-edit'&gt;&lt;/input&gt;
    # &lt;span&gt;&lt;/span&gt;
    # &lt;span class='flx-dd-button'&gt;&lt;/span&gt;
    # &lt;div class='flx-dd-strud'&gt;&amp;nbsp;&lt;/div&gt;
    f2 = lambda e: self._submit_text() if e.which == 13 else None
    return [create_element('span',
                           {'className': 'flx-dd-label',
                            'onclick': self._but_click},
                           self.text + '\u00A0'),
            create_element('input',
                           {'className': 'flx-dd-edit',
                            'onkeypress': f2,
                            'onblur': self._submit_text,
                            'value': self.text}),
            create_element('span'),
            create_element('span', {'className': 'flx-dd-button',
                                    'onclick': self._but_click}),
            create_element('div', {'className': 'flx-dd-strud'}, '\u00A0'),
            ]

</t>
<t tx="ekr.20181031045138.74">def publish(self, name, token, url=None):
    """ Publish this app as static HTML on the web.

    This is an experimental feature! We will try to keep your app published,
    but make no guarantees. We reserve the right to remove apps or shut down
    the web server completely.

    Arguments:
        name (str): The name by which to publish this app. Must be unique
            within the scope of the published site.
        token (str): a secret token. This is stored at the target website.
            Subsequent publications of the same app name must have the same
            token.
        url (str): The url to POST the app to. If None (default),
            the default Flexx live website url will be used.
    """
    # Dump assets into dict
    d = self.dump('index.html', 2)
    # Zip it up
    f = io.BytesIO()
    with zipfile.ZipFile(f, 'w') as zf:
        for fname in d.keys():
            zf.writestr(fname, d[fname])
    # POST
    try:
        import requests
    except ImportError:
        raise ImportError('App.publish() needs requests lib: pip install requests')
    url = url or 'http://flexx.app/submit/{name}/{token}'
    real_url = url.format(name=name, token=token)
    r = requests.post(real_url, data=f.getvalue())
    if r.status_code != 200:
        raise RuntimeError('Publish failed: ' + r.text)
    else:
        print('Publish succeeded, ' + r.text)
        if url.startswith('http://flexx.app'):
            print('You app is now available at '
                  'http://flexx.app/open/%s/' % name)

\\-4.# todo: thread safety

</t>
<t tx="ekr.20181031045138.740">def _but_click(self):
    if self.node.classList.contains('expanded'):
        self._collapse()
    else:
        self._expand()

</t>
<t tx="ekr.20181031045138.741">def _submit_text(self):
    edit_node = self.outernode.childNodes[1]  # not pretty but we need to get value
    self.set_text(edit_node.value)

</t>
<t tx="ekr.20181031045138.742">def _expand(self):
    # Expand
    self.node.classList.add('expanded')
    # Collapse when the node changes position (e.g. scroll or layout change)
    rect = self.node.getBoundingClientRect()
    self._rect_to_check = rect
    window.setTimeout(self._check_expanded_pos, 100)
    # Collapse when the mouse is used outside the combobox (or its children)
    self._addEventListener(window.document, 'mousedown', self._collapse_maybe, 1)
    # Return rect so subclasses can use it
    return rect

</t>
<t tx="ekr.20181031045138.743">def _collapse_maybe(self, e):
    # Collapse if the given pointer event is outside the combobox.
    # Better version of blur event, sort of. Dont use mouseup, as then
    # there's mouse capturing (the event will come from the main widget).
    t = e.target
    while t is not window.document.body:
        if t is self.outernode:
            return
        t = t.parentElement
    window.document.removeEventListener('mousedown', self._collapse_maybe, 1)
    self._collapse()

</t>
<t tx="ekr.20181031045138.744">def _collapse(self):
    self.node.classList.remove('expanded')

</t>
<t tx="ekr.20181031045138.745">def _check_expanded_pos(self):
    if self.node.classList.contains('expanded'):
        rect = self.node.getBoundingClientRect()
        if not (rect.top == self._rect_to_check.top and
                rect.left == self._rect_to_check.left):
            self._collapse()
        else:
            window.setTimeout(self._check_expanded_pos, 100)


</t>
<t tx="ekr.20181031045138.746">class ComboBox(BaseDropdown):
    """
    The Combobox is a combination of a button and a popup list, optionally
    with an editable text. It can be used to select among a set of
    options in a more compact manner than a TreeWidget would.
    Optionally, the text of the combobox can be edited.

    It is generally good practive to react to ``user_selected`` to detect user
    interaction, and react to ``text``, ``selected_key`` or ``selected_index``
    to keep track of all kinds of (incl. programatic) interaction .

    When the combobox is expanded, the arrow keys can be used to select
    an item, and it can be made current by pressing Enter or spacebar.
    Escape can be used to collapse the combobox.
    
    The ``node`` of this widget is a
    `&lt;span&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/span&gt;`_
    with some child elements and quite a bit of CSS for rendering.
    """

    CSS = """

        .flx-ComboBox {
        }

        .flx-ComboBox &gt; ul  {
            list-style-type: none;
            box-sizing: border-box;
            border: 1px solid #333;
            border-radius: 3px;
            margin: 0;
            padding: 2px;
            position: fixed;  /* because all our widgets are overflow:hidden */
            background: white;
            z-index: 9999;
            display: none;
        }
        .flx-ComboBox.expanded &gt; ul {
            display: block;
            max-height: 220px;
            overflow-y: auto;
        }

        .flx-ComboBox.expanded &gt; ul &gt; li:hover {
            background: rgba(0, 128, 255, 0.2);
        }
        .flx-ComboBox.expanded &gt; ul &gt; li.highlighted-true {
            box-shadow: inset 0 0 3px 1px rgba(0, 0, 255, 0.4);
        }
    """

    # Note: we don't define text on the base class, because it would be
    # the only common prop, plus we want a different docstring.

    text = event.StringProp('', settable=True, doc="""
        The text displayed on the widget. This property is set
        when an item is selected from the dropdown menu. When editable,
        the ``text`` is also set when the text is edited by the user.
        This property is settable programatically regardless of the
        value of ``editable``.
        """)

    selected_index = event.IntProp(-1, settable=True, doc="""
        The currently selected item index. Can be -1 if no item has
        been selected or when the text was changed manually (if editable).
        Can also be programatically set.
        """)

    selected_key = event.StringProp('', settable=True, doc="""
        The currently selected item key. Can be '' if no item has
        been selected or when the text was changed manually (if editable).
        Can also be programatically set.
        """)

    placeholder_text = event.StringProp('', settable=True, doc="""
        The placeholder text to display in editable mode.
        """)

    editable = event.BoolProp(False, settable=True, doc="""
        Whether the combobox's text is editable.
        """)

    options = event.TupleProp((), settable=True, doc="""
        A list of tuples (key, text) representing the options. Both
        keys and texts are converted to strings if they are not already.
        For items that are given as a string, the key and text are the same.
        If a dict is given, it is transformed to key-text pairs.
        """)

    _highlighted = app.LocalProperty(-1, settable=True, doc="""
        The index of the currently highlighted item.
        """)

    @others
</t>
<t tx="ekr.20181031045138.747">@event.action
def set_options(self, options):
    # If dict ...
    if isinstance(options, dict):
        keys = options.keys()
        keys = sorted(keys)  # Sort dict by key
        options = [(k, options[k]) for k in keys]
    # Parse
    options2 = []
    for opt in options:
        if isinstance(opt, (tuple, list)):
            opt = str(opt[0]), str(opt[1])
        else:
            opt = str(opt), str(opt)
        options2.append(opt)
    self._mutate_options(tuple(options2))

    # Be smart about maintaining item selection
    keys = [key_text[0] for key_text in self.options]
    if self.selected_key and self.selected_key in keys:
        key = self.selected_key
        self.set_selected_key('')
        self.set_selected_key(key)  # also changes text
    elif 0 &lt;= self.selected_index &lt; len(self.options):
        index = self.selected_index
        self.set_selected_index(-1)
        self.set_selected_index(index)  # also changes text
    elif self.selected_key:
        self.selected_key('')  # also changes text
    else:
        pass  # no selection, leave text alone

</t>
<t tx="ekr.20181031045138.748">@event.action
def set_selected_index(self, index):
    if index == self.selected_index:
        return
    elif 0 &lt;= index &lt; len(self.options):
        key, text = self.options[index]
        self._mutate('selected_index', index)
        self._mutate('selected_key', key)
        self.set_text(text)
    else:
        self._mutate('selected_index', -1)
        self._mutate('selected_key', '')
        self.set_text('')

</t>
<t tx="ekr.20181031045138.749">@event.action
def set_selected_key(self, key):
    if key == self.selected_key:
        return
    elif key:
        if key == self.selected_key:
            return  # eraly exit
        for index, option in enumerate(self.options):
            if option[0] == key:
                self._mutate('selected_index', index)
                self._mutate('selected_key', key)
                self.set_text(option[1])
                return
    # else
    self._mutate('selected_index', -1)
    self._mutate('selected_key', '')
    self.set_text('')

</t>
<t tx="ekr.20181031045138.75">def valid_app_name(name):
    T = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'
    return name and name[0] in T[:-10] and all([c in T for c in name])


# Note that the AppManager is a Component (but not a PyComponent)

</t>
<t tx="ekr.20181031045138.750">@event.emitter
def user_selected(self, index):
    """ Event emitted when the user selects an item using the mouse or
    keyboard. The event has attributes ``index``, ``key`` and ``text``.
    """
    options = self.options
    if index &gt;= 0 and index &lt; len(options):
        key, text = options[index]
        self.set_selected_index(index)
        self.set_selected_key(key)
        self.set_text(text)
        return dict(index=index, key=key, text=text)

</t>
<t tx="ekr.20181031045138.751">def _create_dom(self):
    node = super()._create_dom()
    node.onkeydown=self._key_down
    return node

</t>
<t tx="ekr.20181031045138.752">def _render_dom(self):
    # Create a virtual node for each option
    options = self.options
    option_nodes = []
    strud = []
    for i in range(len(options)):
        key, text = options[i]
        clsname = 'highlighted-true' if self._highlighted == i else ''
        li = create_element('li',
                            dict(index=i, className=clsname),
                            text if len(text.strip()) else '\u00A0')
        strud += [text + '\u00A0',
                  create_element('span', {'class': "flx-dd-space"}),
                  create_element('br')]
        option_nodes.append(li)

    # Update the list of nodes created by superclass
    nodes = super()._render_dom()
    nodes[1].props.placeholder = self.placeholder_text  # the line edit
    nodes[-1].children = strud  # set strud
    nodes.append(create_element('ul',
                                dict(onmousedown=self._ul_click),
                                option_nodes))
    return nodes

</t>
<t tx="ekr.20181031045138.753">@event.reaction
def __track_editable(self):
    if self.editable:
        self.node.classList.remove('editable-false')
        self.node.classList.add('editable-true')
    else:
        self.node.classList.add('editable-false')
        self.node.classList.remove('editable-true')

</t>
<t tx="ekr.20181031045138.754">def _ul_click(self, e):
    if hasattr(e.target, 'index'):  # not when scrollbar is clicked
        self._select_from_ul(e.target.index)

</t>
<t tx="ekr.20181031045138.755">def _select_from_ul(self, index):
    self.user_selected(index)
    self._collapse()

</t>
<t tx="ekr.20181031045138.756">def _key_down(self, e):
    # Get key
    key = e.key
    if not key and e.code:
        key = e.code

    # If collapsed, we may want to expand. Otherwise, do nothing.
    # In this case, only consume events that dont sit in the way with
    # the line edit of an editable combobox.
    if not self.node.classList.contains('expanded'):
        if key in ['ArrowUp', 'ArrowDown']:
            e.stopPropagation()
            self.expand()
        return

    # Early exit, be specific about the keys that we want to accept
    if key not in ['Escape', 'ArrowUp', 'ArrowDown', ' ', 'Enter']:
        return

    # Consume the keys
    e.preventDefault()
    e.stopPropagation()

    if key == 'Escape':
        self._set_highlighted(-1)
        self._collapse()

    elif key == 'ArrowUp' or key == 'ArrowDown':
        if key == 'ArrowDown':
            hl = self._highlighted + 1
        else:
            hl = self._highlighted - 1
        self._set_highlighted(min(max(hl, 0), len(self.options)-1))

    elif key == 'Enter' or key == ' ':
        if self._highlighted &gt;= 0 and self._highlighted &lt; len(self.options):
            self._select_from_ul(self._highlighted)

</t>
<t tx="ekr.20181031045138.757">def _expand(self):
    rect = super()._expand()
    ul = self.outernode.children[len(self.outernode.children) - 1]
    ul.style.left = rect.left + 'px'
    ul.style.top = (rect.bottom - 1) + 'px'
    ul.style.width = rect.width + 'px'

</t>
<t tx="ekr.20181031045138.758">def _submit_text(self):
    super()._submit_text()
    # todo: should this select option if text happens to match it?
    self.set_selected_index(-1)
    self.set_selected_key('')


</t>
<t tx="ekr.20181031045138.759">class DropdownContainer(BaseDropdown):
    """
    A dropdown widget that shows its children when expanded. This can be
    used to e.g. make a collapsable tree widget. Some styling may be required
    for the child widget to be sized appropriately.

    *Note: This widget is currently broken, because pointer events do not work in the
    contained widget (at least on Firefox).*
    """

    CSS = """
        .flx-DropdownContainer {
            min-width: 50px;
        }
        .flx-DropdownContainer &gt; .flx-Widget {
            position: fixed;
            min-height: 100px;
            max-height: 300px;
            width: 200px;
            background: white;
            z-index: 10001;
            display: none;
        }
        .flx-DropdownContainer.expanded &gt; .flx-Widget {
            display: initial;
        }
    """

    text = event.StringProp('', settable=True, doc="""
        The text displayed on the dropdown widget.
        """)

    @others
</t>
<t tx="ekr.20181031045138.76">class AppManager(event.Component):
    """ Manage apps, or more specifically, the session objects.

    There is one AppManager class (in ``flexx.app.manager``). It's
    purpose is to manage the application classes and instances. It is mostly
    intended for internal use, but users can use it to e.g. monitor connections.
    Create a reaction using ``@app.manager.reaction('connections_changed')``
    to track when the number of connected session changes.
    """

    total_sessions = 0  # Keep track how many sessesions we've served in total

    @others
manager = AppManager()
</t>
<t tx="ekr.20181031045138.760">def _render_dom(self):
    nodes = super()._render_dom()
    for widget in self.children:
        nodes.append(widget.outernode)
    return nodes

</t>
<t tx="ekr.20181031045138.761">def _expand(self):
    rect = super()._expand()
    node = self.children[0].outernode
    node.style.left = rect.left + 'px'
    node.style.top = (rect.bottom - 1) + 'px'
    # node.style.width = (rect.width - 6) + 'px'
</t>
<t tx="ekr.20181031045138.762">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.763">""" GroupWidget

Visually group a collection of input widgets. Example:

.. UIExample:: 150

    from flexx import app, event, ui

    class Example(ui.GroupWidget):
        def init(self):
            self.set_title('A silly panel')
            with ui.VBox():
                self.progress = ui.ProgressBar(min=0, max=9,
                                               text='Clicked {value} times')
                self.but = ui.Button(text='click me')

        @event.reaction('but.pointer_down')
        def _button_pressed(self, *events):
            self.progress.set_value(self.progress.value + 1)
"""

from ... import event
from . import Widget


</t>
<t tx="ekr.20181031045138.764">class GroupWidget(Widget):
    """ Widget to collect widgets in a named group.
    It does not provide a layout. This is similar to a QGroupBox or an
    HTML fieldset.
    
    The ``node`` of this widget is a
    `&lt;fieldset&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/fieldset&gt;`_. 
    """

    CSS = """

    .flx-GroupWidget {
        margin: 0;
        padding: 5px;
        border: 2px solid #ccc;
        border-radius: 3px;
    }
    .flx-GroupWidget &gt; .flx-Layout {
        width: calc(100% - 10px);
        height: calc(100% - 25px);
    }

    """

    @others
</t>
<t tx="ekr.20181031045138.765">def _create_dom(self):
    global window
    node = window.document.createElement('fieldset')
    self._legend = window.document.createElement('legend')
    node.appendChild(self._legend)
    return node

</t>
<t tx="ekr.20181031045138.766">def _render_dom(self):
    nodes = [self._legend]
    for widget in self.children:
        nodes.append(widget.outernode)
    return nodes

</t>
<t tx="ekr.20181031045138.767">def _query_min_max_size(self):
    w1, w2, h1, h2 = super()._query_min_max_size()
    w1 += 10
    h1 += 30
    return w1, w2, h1, h2

</t>
<t tx="ekr.20181031045138.768">@event.reaction('title')
def _title_changed(self, *events):
    self._legend.textContent = '\u00A0' + self.title + '\u00A0'
</t>
<t tx="ekr.20181031045138.769">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.77">def __init__(self):
    super().__init__()
    # name -&gt; (app, pending, connected) - lists contain Session objects
    self._appinfo = {}
    self._session_map = weakref.WeakValueDictionary()
    self._last_check_time = time.time()

</t>
<t tx="ekr.20181031045138.770">""" IFrame

.. UIExample:: 100

    with ui.HSplit():
        ui.IFrame(url='bsdf.io')
        ui.IFrame(url='http://flexx.readthedocs.io')
        # Note: the rtd page does not seem to load on Firefox 57.04

"""

from ... import event
from . import Widget


</t>
<t tx="ekr.20181031045138.771">class IFrame(Widget):
    """ An iframe element, i.e. a container to show web-content.
    Note that some websites do not allow themselves to be rendered in
    a cross-source iframe.
    
    The ``node`` of this widget is a
    `&lt;iframe&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/iframe&gt;`_. 
    """

    DEFAULT_MIN_SIZE = 10, 10

    CSS = """
        .flx-IFrame {
            border: none;
        }
    """

    url = event.StringProp('', settable=True, doc="""
        The url to show. 'http://' is automatically prepended if the url
        does not have '://' in it.
        """)

    @others
</t>
<t tx="ekr.20181031045138.772">def _create_dom(self):
    global document
    return document.createElement('iframe')

</t>
<t tx="ekr.20181031045138.773">@event.reaction('size')
def __on_size(self, *events):
    self.node.width = self.size[0]

</t>
<t tx="ekr.20181031045138.774">@event.reaction('url')
def _update_url(self, *events):
    url = self.url
    if url and '://' not in url:
        url = 'http://' + url
    self.node.src = url
</t>
<t tx="ekr.20181031045138.775">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.776">""" Label

.. UIExample:: 50
    from flexx import app, event, ui

    class Example(ui.Widget):

        def init(self):
            with ui.HBox():
                self.but = ui.Button(text='Push me')
                self.label = ui.Label(flex=1, wrap=True, text='This is a label. ')

        @event.reaction('but.pointer_down')
        def _add_label_text(self, *events):
            self.label.set_text(self.label.text + 'Yes it is. ')

"""

from ... import event
from . import Widget


</t>
<t tx="ekr.20181031045138.777">class Label(Widget):
    """ Widget to show text/html.
    
    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_ with
    CSS ``word-wrap`` and ``white-space`` set appropriately.
    """

    DEFAULT_MIN_SIZE = 10, 24

    CSS = """
        .flx-Label {
            border: 0px solid #454;
            user-select: text;
            -moz-user-select: text;
            -webkit-user-select: text;
            -ms-user-select: text;
        }"""

    text = event.StringProp('', doc="""
        The text shown in the label (HTML is shown verbatim).
        """)

    html = event.StringProp('', doc="""
        The html shown in the label.

        Warning: there is a risk of introducing openings for XSS attacks
        when html is introduced that you do not control (e.g. from user input).
        """)

    wrap = event.IntProp(0, settable=True, doc="""
        Whether the content is allowed to be wrapped on multiple
        lines. Set to 0/False for no wrap (default), 1/True for word-wrap,
        2 for character wrap.
        """)

    @others
</t>
<t tx="ekr.20181031045138.778">def init(self):
    if self.text:
        self.set_text(self.text)
    elif self.html:
        self.set_html(self.html)

</t>
<t tx="ekr.20181031045138.779">@event.action
def set_text(self, text):
    """ Setter for the text property.
    """
    if not self.node:
        self._mutate_text(text)
        return
    self.node.textContent = text
    self._mutate_text(self.node.textContent)
    self._mutate_html(self.node.innerHTML)

</t>
<t tx="ekr.20181031045138.78">def register_app(self, app):
    """ Register an app (an object that wraps a Component class plus init args).
    After registering an app (and starting the server) it is
    possible to connect to "http://address:port/app_name".
    """
    assert isinstance(app, App)
    name = app.name
    if not valid_app_name(name):
        raise ValueError('Given app does not have a valid name %r' % name)
    pending, connected = [], []
    if name in self._appinfo:
        old_app, pending, connected = self._appinfo[name]
        if app.cls is not old_app.cls:  # if app is not old_app:
            logger.warn('Re-defining app class %r' % name)
    self._appinfo[name] = app, pending, connected

</t>
<t tx="ekr.20181031045138.780">@event.action
def set_html(self, html):
    """ Setter for the html property. Use with care.
    """
    if not self.node:
        self._mutate_html(html)
        return
    self.node.innerHTML = html
    self._mutate_text(self.node.textContent)
    self._mutate_html(self.node.innerHTML)

</t>
<t tx="ekr.20181031045138.781">@event.reaction('wrap')
def _wrap_changed(self, *events):
    wrap = self.wrap
    if wrap &lt; 0 or wrap &gt; 2:
        wrap = 0
    self.node.style['word-wrap'] = ['normal', 'normal', 'break-word'][wrap]
    self.node.style['white-space'] = ['nowrap', 'normal', 'normal'][wrap]
    self.check_real_size(True)
</t>
<t tx="ekr.20181031045138.782">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.783">""" LineEdit


.. UIExample:: 100

    from flexx import app, event, ui

    class Example(ui.Widget):

        def init(self):
            with ui.VBox():
                self.line = ui.LineEdit(placeholder_text='type here')
                self.l1 = ui.Label(html='&lt;i&gt;when user changes text&lt;/i&gt;')
                self.l2 = ui.Label(html='&lt;i&gt;when unfocusing or hitting enter &lt;/i&gt;')
                self.l3 = ui.Label(html='&lt;i&gt;when submitting (hitting enter)&lt;/i&gt;')
                ui.Widget(flex=1)

        @event.reaction('line.user_text')
        def when_user_changes_text(self, *events):
            self.l1.set_text('user_text: ' + self.line.text)

        @event.reaction('line.user_done')
        def when_user_is_done_changing_text(self, *events):
            self.l2.set_text('user_done: ' + self.line.text)

        @event.reaction('line.submit')
        def when_user_submits_text(self, *events):
            self.l3.set_text('submit: ' + self.line.text)

"""

from ... import event
from . import Widget


</t>
<t tx="ekr.20181031045138.784">class LineEdit(Widget):
    """ An input widget to edit a line of text.
    
    The ``node`` of this widget is a text
    `&lt;input&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/input&gt;`_.
    """

    DEFAULT_MIN_SIZE = 100, 28

    CSS = """
    .flx-LineEdit {
        color: #333;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        border: 1px solid #aaa;
        margin: 2px;
    }
    .flx-LineEdit:focus  {
        outline: none;
        box-shadow: 0px 0px 3px 1px rgba(0, 100, 200, 0.7);
    }
    """

    ## Properties

    text = event.StringProp(settable=True, doc="""
        The current text of the line edit. Settable. If this is an empty
        string, the placeholder_text is displayed instead.
        """)

    password_mode = event.BoolProp(False, settable=True, doc="""
        Whether the insered text should be hidden.
        """)

    placeholder_text = event.StringProp(settable=True, doc="""
        The placeholder text (shown when the text is an empty string).
        """)

    autocomp = event.TupleProp(settable=True, doc="""
        A tuple/list of strings for autocompletion. Might not work in all browsers.
        """)

    disabled = event.BoolProp(False, settable=True, doc="""
        Whether the line edit is disabled.
        """)

    ## Methods, actions, emitters

    @others
</t>
<t tx="ekr.20181031045138.785">def _create_dom(self):
    global window

    # Create node element
    node = window.document.createElement('input')
    node.setAttribute('type', 'input')
    node.setAttribute('list', self.id)

    self._autocomp = window.document.createElement('datalist')
    self._autocomp.id = self.id
    node.appendChild(self._autocomp)

    f1 = lambda: self.user_text(self.node.value)
    self._addEventListener(node, 'input', f1, False)
    self._addEventListener(node, 'blur', self.user_done, False)
    #if IE10:
    #    self._addEventListener(self.node, 'change', f1, False)
    return node

</t>
<t tx="ekr.20181031045138.786">@event.emitter
def user_text(self, text):
    """ Event emitted when the user edits the text. Has ``old_value``
    and ``new_value`` attributes.
    """
    d = {'old_value': self.text, 'new_value': text}
    self.set_text(text)
    return d

</t>
<t tx="ekr.20181031045138.787">@event.emitter
def user_done(self):
    """ Event emitted when the user is done editing the text, either by
    moving the focus elsewhere, or by hitting enter.
    Has ``old_value`` and ``new_value`` attributes (which are the same).
    """
    d = {'old_value': self.text, 'new_value': self.text}
    return d

</t>
<t tx="ekr.20181031045138.788">@event.emitter
def submit(self):
    """ Event emitted when the user strikes the enter or return key
    (but not when losing focus). Has ``old_value`` and ``new_value``
    attributes (which are the same).
    """
    self.user_done()
    d = {'old_value': self.text, 'new_value': self.text}
    return d

</t>
<t tx="ekr.20181031045138.789">@event.emitter
def key_down(self, e):
    # Prevent propating the key
    ev = super().key_down(e)
    pkeys = 'Escape',  # keys to propagate
    if (ev.modifiers and ev.modifiers != ('Shift', )) or ev.key in pkeys:
        pass
    else:
        e.stopPropagation()
    if ev.key in ('Enter', 'Return'):
        self.submit()
        # Nice to blur on mobile, since it hides keyboard, but less nice on desktop
        # self.node.blur()
    elif ev.key == 'Escape':
        self.node.blur()
    return ev

## Reactions

</t>
<t tx="ekr.20181031045138.79">def create_default_session(self, cls=None):
    """ Create a default session for interactive use (e.g. the notebook).
    """

    if '__default__' in self._appinfo:
        raise RuntimeError('The default session can only be created once.')

    if cls is None:
        cls = JsComponent
    if not isinstance(cls, type) and issubclass(cls, (PyComponent, JsComponent)):
        raise TypeError('create_default_session() needs a JsComponent subclass.')

    # Create app and register it by __default__ name
    app = App(cls)
    app.serve('__default__')  # calls register_app()

    # Create the session instance and register it
    session = Session('__default__')
    self._session_map[session.id] = session
    _, pending, connected = self._appinfo['__default__']
    pending.append(session)

    # Instantiate the component
    app(flx_session=session, flx_is_app=True)

    return session

</t>
<t tx="ekr.20181031045138.790">@event.reaction
def __text_changed(self):
    self.node.value = self.text

</t>
<t tx="ekr.20181031045138.791">@event.reaction
def __password_mode_changed(self):
    self.node.type = ['text', 'password'][int(bool(self.password_mode))]

</t>
<t tx="ekr.20181031045138.792">@event.reaction
def __placeholder_text_changed(self):
    self.node.placeholder = self.placeholder_text

# note: this works in the browser but not in e.g. firefox-app
</t>
<t tx="ekr.20181031045138.793">@event.reaction
def __autocomp_changed(self):
    global window
    autocomp = self.autocomp
    # Clear
    for op in self._autocomp:
        self._autocomp.removeChild(op)
    # Add new options
    for option in autocomp:
        op = window.document.createElement('option')
        op.value = option
        self._autocomp.appendChild(op)

</t>
<t tx="ekr.20181031045138.794">@event.reaction
def __disabled_changed(self):
    if self.disabled:
        self.node.setAttribute("disabled", "disabled")
    else:
        self.node.removeAttribute("disabled")
</t>
<t tx="ekr.20181031045138.795">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.796">""" Media widgets

.. UIExample:: 200

    from flexx import ui

    class Example(ui.Widget):

        def init(self):
            with ui.HSplit():
                url = 'http://www.w3schools.com/tags/mov_bbb.mp4'
                ui.VideoWidget(source=url)
                ui.YoutubeWidget(source='RG1P8MQS1cU')
                with ui.VBox():
                    stretch = ui.CheckBox(text='Stretch')
                    ui.ImageWidget(flex=1, stretch=lambda:stretch.checked,
                                    source='http://github.com/fluidicon.png')

"""

from ... import event
from . import Widget


</t>
<t tx="ekr.20181031045138.797">class ImageWidget(Widget):
    """ Display an image from a url.
    
    The ``node`` of this widget is an
    `&lt;img&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/img&gt;`_
    wrapped in a `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_
    (the ``outernode``) to handle sizing.
    """

    DEFAULT_MIN_SIZE = 16, 16

    _sequence = 0

    source = event.StringProp('', settable=True, doc="""
        The source of the image, This can be anything that an HTML
        img element supports.
        """)

    stretch = event.BoolProp(False, settable=True, doc="""
        Whether the image should stretch to fill all available
        space, or maintain its aspect ratio (default).
        """)

    @others
</t>
<t tx="ekr.20181031045138.798">def _create_dom(self):
    global window
    outer = window.document.createElement('div')
    inner = window.document.createElement('img')
    outer.appendChild(inner)
    return outer, inner

</t>
<t tx="ekr.20181031045138.799">@event.reaction
def __resize_image(self):
    size = self.size
    if self.stretch:
        self.node.style.maxWidth = None
        self.node.style.maxHeight = None
        self.node.style.width = size[0] + 'px'
        self.node.style.height = size[1] + 'px'
    else:
        self.node.style.maxWidth = size[0] + 'px'
        self.node.style.maxHeight = size[1] + 'px'
        self.node.style.width = None
        self.node.style.height = None

</t>
<t tx="ekr.20181031045138.8">@path C:/Anaconda3/Lib/site-packages/flexx/
"""
Flexx has a command line interface to perform some simple tasks.
Invoke it via ``python -m flexx``. Additional command line arguments
can be provided to configure Flexx, see
:func:`configuring flexx &lt;flexx.config&gt;`.

.. code-block:: none

"""

import sys

ALIASES = {'-h': 'help', '--help': 'help',
           '--version': 'version',
          }

@others
if __name__ == '__main__':
    main()
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.80">def remove_default_session(self):
    """ Remove default session if there is one, closing the session.
    """
    s = self.get_default_session()
    if s is not None:
        s.close()
    self._appinfo.pop('__default__', None)

</t>
<t tx="ekr.20181031045138.800">@event.reaction
def __source_changed(self):
    self.node.src = self.source


</t>
<t tx="ekr.20181031045138.801">class VideoWidget(Widget):
    """ Display a video from a url.
    
    The ``node`` of this widget is a
    `&lt;video&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/video&gt;`_.
    """

    DEFAULT_MIN_SIZE = 100, 100

    source = event.StringProp('', settable=True, doc="""
        The source of the video. This must be a url of a resource
        on the web.
        """)

    @others
</t>
<t tx="ekr.20181031045138.802">def _create_dom(self):
    global window
    node = window.document.createElement('video')
    node.controls = 'controls'
    node.textContent = 'Your browser does not support HTML5 video.'

    self.src_node = window.document.createElement('source')
    self.src_node.type = 'video/mp4'
    self.src_node.src = None
    node.appendChild(self.src_node)
    return node

</t>
<t tx="ekr.20181031045138.803">def _render_dom(self):
    return None

</t>
<t tx="ekr.20181031045138.804">@event.reaction
def __source_changed(self):
    self.src_node.src = self.source or None
    self.node.load()


</t>
<t tx="ekr.20181031045138.805">class YoutubeWidget(Widget):
    """ Display a Youtube video.
    
    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_
    containing an
    `&lt;iframe&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/iframe&gt;`_
    that loads the youtube page.
    """

    DEFAULT_MIN_SIZE = 100, 100

    source = event.StringProp('oHg5SJYRHA0', settable=True, doc="""
        The source of the video represented as the Youtube id.
        """)

    @others
</t>
<t tx="ekr.20181031045138.806">def _create_dom(self):
    global window
    node = window.document.createElement('div')
    self.inode = window.document.createElement('iframe')
    node.appendChild(self.inode)
    return node

</t>
<t tx="ekr.20181031045138.807">@event.reaction
def _update_canvas_size(self, *events):
    size = self.size
    if size[0] or size[1]:
        self.inode.style.width = size[0] + 'px'
        self.inode.style.height = size[1] + 'px'

</t>
<t tx="ekr.20181031045138.808">@event.reaction
def __source_changed(self, *events):
    base_url = 'http://www.youtube.com/embed/'
    self.inode.src = base_url + self.source + '?autoplay=0'


\\-4.# todo: SVG? Icon?
</t>
<t tx="ekr.20181031045138.809">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.81">def get_default_session(self):
    """ Get the default session that is used for interactive use.
    Returns None unless create_default_session() was called earlier.

    When a JsComponent class is created without a session, this method
    is called to get one (and will then fail if it's None).
    """
    x = self._appinfo.get('__default__', None)
    if x is None:
        return None
    else:
        _, pending, connected = x
        sessions = pending + connected
        if sessions:
            return sessions[-1]

</t>
<t tx="ekr.20181031045138.810">"""

Simple example:

.. UIExample:: 200

    # Define data. This can also be generated with the plotly Python library
    data = [{'type': 'bar',
             'x': ['giraffes', 'orangutans', 'monkeys'],
             'y': [20, 14, 23]}]

    # Show
    p = ui.PlotlyWidget(data=data)

Also see examples: :ref:`plotly_gdp.py`.

"""

from ... import app, event
from . import Widget

app.assets.associate_asset(__name__, 'https://cdn.plot.ly/plotly-latest.min.js')


</t>
<t tx="ekr.20181031045138.811">class PlotlyWidget(Widget):
    """ A widget that shows a Plotly visualization.
    """

    data = event.ListProp(settable=True, doc="""
        The data (list of dicts) that describes the plot.
        This can e.g. be the output of the Python plotly API call.
        """)

    layout = event.DictProp(settable=True, doc="""
        The layout dict to style the plot.
        """)

    config = event.DictProp(settable=True, doc="""
        The config for the plot.
        """)

    @others
</t>
<t tx="ekr.20181031045138.812">@event.reaction
def __relayout(self):
    global Plotly
    w, h = self.size
    if len(self.node.children) &gt; 0:
        Plotly.relayout(self.node, dict(width=w, height=h))

</t>
<t tx="ekr.20181031045138.813">@event.reaction
def _init_plot(self):
    # https://plot.ly/javascript/plotlyjs-function-reference/#plotlynewplot
    # Overwrites an existing plot
    global Plotly
    Plotly.newPlot(self.node, self.data, self.layout, self.config)
</t>
<t tx="ekr.20181031045138.814">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.815">""" PlotWidget

The plot widget provides rudimentary plotting functionality, mostly to
demonstrate how plots can be embedded in a Flexx GUI. It may be
sufficient for simple cases, but don't expect it to ever support
log-plotting, legends, and other fancy stuff. For real plotting, see
e.g. ``BokehWidget``. There might also be a Plotly widget at some point.


Simple example:

.. UIExample:: 200

    p = ui.PlotWidget(xdata=range(5), ydata=[1,3,4,2,5],
                      line_width=4, line_color='red', marker_color='',
                      minsize=200)

Also see examples: :ref:`sine.py`, :ref:`twente.py`, :ref:`monitor.py`.

"""

from pscript import window

from ... import event
from ._canvas import CanvasWidget


</t>
<t tx="ekr.20181031045138.816">class PlotWidget(CanvasWidget):
    """ Widget to show a plot of x vs y values. Enough for simple
    plotting tasks.
    """

    DEFAULT_MIN_SIZE = 300, 200

    xdata = event.TupleProp((), doc="""
            A list of values for the x-axis. Set via the ``set_data()`` action.
            """)

    ydata = event.TupleProp((), doc="""
            A list of values for the y-axis. Set via the ``set_data()`` action.
            """)

    @others
</t>
<t tx="ekr.20181031045138.817">@event.action
def set_data(self, xdata, ydata):
    """ Set the xdata and ydata.
    """
    xdata = [float(i) for i in xdata]
    ydata = [float(i) for i in ydata]
    if len(xdata) != len(ydata):
        raise ValueError('xdata and ydata must be of equal length.')
    self._mutate('xdata', xdata)
    self._mutate('ydata', ydata)

yrange = event.FloatPairProp((0, 0), settable=True, doc="""
    The range for the y-axis. If (0, 0) (default) it is determined
    from the data.
    """)

line_color = event.ColorProp('#5af', settable=True, doc="""
    The color of the line. Set to the empty string to hide the line.
    """)

marker_color = event.ColorProp('#5af', settable=True, doc="""
    The color of the marker. Set to the empty string to hide the marker.
    """)

line_width = event.FloatProp(2, settable=True, doc="""
    The width of the line, in pixels.
    """)

marker_size = event.FloatProp(6, settable=True, doc="""
    The size of the marker, in pixels.
    """)

xlabel = event.StringProp('', settable=True, doc="""
    The label to show on the x-axis.
    """)

ylabel = event.StringProp('', settable=True, doc="""
    The label to show on the y-axis.
    """)

</t>
<t tx="ekr.20181031045138.818">def init(self):
    super().init()
    self._context = self.node.getContext('2d')

    # create tick units
    self._tick_units = []
    for e in range(-10, 10):
        for i in [10, 20, 25, 50]:
            self._tick_units.append(i*10**e)


</t>
<t tx="ekr.20181031045138.819">@event.reaction('xdata', 'ydata', 'yrange', 'line_color', 'line_width',
                'marker_color', 'marker_size', 'xlabel', 'ylabel',
                'title', 'size')
def update(self, *events):
    window.requestAnimationFrame(self._update)

</t>
<t tx="ekr.20181031045138.82">def _clear_old_pending_sessions(self, max_age=30):
    try:

        count = 0
        for name in self._appinfo:
            if name == '__default__':
                continue
            _, pending, _ = self._appinfo[name]
            to_remove = [s for s in pending
                         if (time.time() - s._creation_time) &gt; max_age]
            for s in to_remove:
                self._session_map.pop(s.id, None)
                pending.remove(s)
            count += len(to_remove)
        if count:
            logger.warn('Cleared %i old pending sessions' % count)

    except Exception as err:
        logger.error('Error when clearing old pending sessions: %s' % str(err))

</t>
<t tx="ekr.20181031045138.820">def _update(self):
    xx, yy = self.xdata, self.ydata
    yrange = self.yrange
    lc, lw = self.line_color, self.line_width
    mc, ms = self.marker_color, self.marker_size
    title, xlabel, ylabel = self.title, self.xlabel, self.ylabel

    # Prepare
    ctx = self._context
    w, h = self.node.clientWidth, self.node.clientHeight

    # Get range
    x1, x2 = min(xx), max(xx)
    y1, y2 = min(yy), max(yy)
    #
    if xx:
        x1 -= (x2-x1) * 0.02
        x2 += (x2-x1) * 0.02
    else:
        x1, x2 = 0, 1
    #
    if yrange != (0, 0):
        y1, y2 = yrange
    elif yy:
        y1 -= (y2-y1) * 0.02
        y2 += (y2-y1) * 0.02
    else:
        y1, y2 = 0, 1

    # Convert to screen coordinates
    # 0.5 offset so we land on whole pixels with axis
    lpad = rpad = bpad = tpad = 25.5
    lpad += 30
    if title:
        tpad += 10
    if xlabel:
        bpad += 20
    if ylabel:
        lpad += 20
    scale_x = (w-lpad-rpad) / (x2-x1)
    scale_y = (h-bpad-tpad) / (y2-y1)
    sxx = [lpad + (x-x1)*scale_x for x in xx]
    syy = [bpad + (y-y1)*scale_y for y in yy]

    # Define ticks
    x_ticks = self._get_ticks(scale_x, x1, x2)
    y_ticks = self._get_ticks(scale_y, y1, y2)
    sx_ticks = [lpad + (x-x1)*scale_x for x in x_ticks]
    sy_ticks = [bpad + (y-y1)*scale_y for y in y_ticks]

    ctx.clearRect(0, 0, w, h)

    # Draw inner background
    ctx.fillStyle = 'white'
    ctx.fillRect(lpad, tpad, w-lpad-rpad, h-bpad-tpad)

    # Draw ticks
    ctx.beginPath()
    ctx.lineWidth= 1
    ctx.strokeStyle = "#444"
    for sx in sx_ticks:
        ctx.moveTo(sx, h-bpad)
        ctx.lineTo(sx, h-bpad+5)
    for sy in sy_ticks:
        ctx.moveTo(lpad, h-sy)
        ctx.lineTo(lpad-5, h-sy)
    ctx.stroke()

    # Draw gridlines
    ctx.beginPath()
    ctx.lineWidth= 1
    ctx.setLineDash([2, 2])
    ctx.strokeStyle = "#ccc"
    for sx in sx_ticks:
        ctx.moveTo(sx, h-bpad)
        ctx.lineTo(sx, tpad)
    for sy in sy_ticks:
        ctx.moveTo(lpad, h-sy)
        ctx.lineTo(w-rpad, h-sy)
    ctx.stroke()
    ctx.setLineDash([])

    # Draw tick labels
    ctx.font = '11px verdana'
    ctx.fillStyle = 'black'
    ctx.textAlign = "center"
    ctx.textBaseline = 'top'
    for x, sx in zip(x_ticks, sx_ticks):
        ctx.fillText(x, sx, h-bpad+8)
    ctx.textAlign = "end"
    ctx.textBaseline = 'middle'
    for y, sy in zip(y_ticks, sy_ticks):
        ctx.fillText(y, lpad-8, h-sy)

    # Draw labels
    ctx.textAlign = "center"
    if title:
        ctx.font = '20px verdana'
        ctx.textBaseline = 'top'
        ctx.fillText(title, w/2, 5)
    if xlabel:
        ctx.font = '16px verdana'
        ctx.textBaseline = 'bottom'
        ctx.fillText(xlabel, w/2, h-5)
    if ylabel:
        ctx.save()
        ctx.translate(0, h/2)
        ctx.rotate(-window.Math.PI/2)
        ctx.textBaseline = 'top'
        ctx.fillText(ylabel, 0, 5)
        ctx.restore()

    # Draw axis
    ctx.beginPath()
    ctx.lineWidth= 1
    ctx.strokeStyle = "#444"
    ctx.moveTo(lpad, tpad)
    ctx.lineTo(lpad, h-bpad)
    ctx.lineTo(w-rpad, h-bpad)
    ctx.stroke()

    # Draw line
    if lc.alpha and lw:
        ctx.beginPath()
        ctx.lineWidth= lw
        ctx.strokeStyle = lc.css
        ctx.moveTo(sxx[0], h-syy[0])
        for x, y in zip(sxx, syy):
            ctx.lineTo(x, h-y)
        ctx.stroke()

    # Draw markers
    if mc.alpha and ms:
        ctx.fillStyle = mc.css
        for x, y in zip(sxx, syy):
            ctx.beginPath()
            ctx.arc(x, h-y, ms/2, 0, 2*window.Math.PI)
            ctx.fill()

</t>
<t tx="ekr.20181031045138.821">def _get_ticks(self, scale, t1, t2, min_tick_dist=40):
    # Get tick unit
    for tick_unit in self._tick_units:
        if tick_unit * scale &gt;= min_tick_dist:
            break
    else:
        return []
    # Calculate tick values
    first_tick = window.Math.ceil(t1 / tick_unit) * tick_unit
    last_tick = window.Math.floor(t2 / tick_unit) * tick_unit
    ticks = []
    t = first_tick
    while t &lt;= last_tick:
        ticks.append(t)
        t += tick_unit
    for i in range(len(ticks)):
        t = ticks[i].toPrecision(4)
        if '.' in t:
            t = t.replace(window.RegExp("[0]+$"), "")
        if t[-1] == '.':
            t += '0'
        ticks[i] = t

    return ticks
</t>
<t tx="ekr.20181031045138.822">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.823">""" ProgressBar

Example:

.. UIExample:: 100

    from flexx import app, event, ui

    class Example(ui.Widget):

        def init(self):
            with ui.HBox():
                self.b1 = ui.Button(flex=0, text='Less')
                self.b2 = ui.Button(flex=0, text='More')
                self.prog = ui.ProgressBar(flex=1, value=0.1, text='{percent} done')

        @event.reaction('b1.pointer_down', 'b2.pointer_down')
        def _change_progress(self, *events):
            for ev in events:
                if ev.source is self.b1:
                    self.prog.set_value(self.prog.value - 0.1)
                else:
                    self.prog.set_value(self.prog.value + 0.1)
"""

from ... import event
from .._widget import Widget, create_element


</t>
<t tx="ekr.20181031045138.824">class ProgressBar(Widget):
    """ A widget to show progress.
    
    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_
    containing a few HTML elements for rendering.
    """

    DEFAULT_MIN_SIZE = 40, 16

    CSS = """

    .flx-ProgressBar {
        border: 1px solid #ddd;
        border-radius: 6px;
        background: #eee;
    }

    .flx-ProgressBar &gt; .progress-bar {
        /* Use flexbox to vertically align label text */
        display: -webkit-flex;
        display: -ms-flexbox;
        display: -ms-flex;
        display: -moz-flex;
        display: flex;
        -webkit-flex-flow: column;
        -ms-flex-flow: column;
        -moz-flex-flow: column;
        flex-flow: column;
        -webkit-justify-content: center;
        -ms-justify-content: center;
        -moz-justify-content: center;
        justify-content: center;
        white-space: nowrap;
        align-self: stretch;

        position: absolute; /* need this on Chrome when in a VBox */
        background: #8be;
        text-align: center;
        /*transition: width 0.2s ease; behaves silly on Chrome */
        }

    """

    value = event.FloatProp(0, settable=True, doc="""
            The progress value.
            """)

    min = event.FloatProp(0, settable=True, doc="""
        The minimum progress value.
        """)

    max = event.FloatProp(1, settable=True, doc="""
        The maximum progress value.
        """)

    text = event.StringProp('', settable=True, doc="""
        The label to display on the progress bar. Occurances of
        "{percent}" are replaced with the current percentage, and
        "{value}" with the current value.
        """)

    @others
</t>
<t tx="ekr.20181031045138.825">@event.action
def set_value(self, value):
    value = max(self.min, value)
    value = min(self.max, value)
    self._mutate_value(value)

</t>
<t tx="ekr.20181031045138.826">@event.reaction('min', 'max')
def __keep_value_constrained(self, *events):
    self.set_value(self.value)

</t>
<t tx="ekr.20181031045138.827">def _render_dom(self):
    global Math
    value = self.value
    mi, ma = self.min, self.max
    perc = 100 * (value - mi) / (ma - mi)
    label = self.text
    label = label.replace('{value}', str(value))
    label = label.replace('{percent}', Math.round(perc) + '%')
    attr = {'style__width': perc+'%',
            'style__height': '100%',
            'className': 'progress-bar',
            }
    return [create_element('div', attr, label)]
</t>
<t tx="ekr.20181031045138.828">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.829">"""

Simple example:

.. UIExample:: 50

    s = ui.Slider(min=10, max=20, value=12)


Also see examples: :ref:`sine.py`, :ref:`twente.py`,
:ref:`deep_event_connections.py`.

"""

from ... import event
from .._widget import Widget, create_element


</t>
<t tx="ekr.20181031045138.83">def create_session(self, name, id=None, request=None):
    """ Create a session for the app with the given name.

    Instantiate an app and matching session object corresponding
    to the given name, and return the session. The client should
    be connected later via connect_client().
    """
    # Called by the server when a client connects, and from the
    # launch and export functions.

    if time.time() - self._last_check_time &gt; 5:
        self._last_check_time = time.time()
        self._clear_old_pending_sessions()

    if name == '__default__':
        raise RuntimeError('There can be only one __default__ session.')
    elif name not in self._appinfo:
        raise ValueError('Can only instantiate a session with a valid app name.')

    app, pending, connected = self._appinfo[name]

    # Create the session
    session = Session(name, request=request)
    if id is not None:
        session._id = id  # use custom id (export() used to use this)
    self._session_map[session.id] = session
    # Instantiate the component
    # This represents the "instance" of the App object (Component class + args)
    app(flx_session=session, flx_is_app=True)

    # Now wait for the client to connect. The client will be served
    # a page that contains the session_id. Upon connecting, the id
    # will be communicated, so it connects to the correct session.
    pending.append(session)

    logger.debug('Instantiate app client %s' % session.app_name)
    return session

</t>
<t tx="ekr.20181031045138.830">class Slider(Widget):
    """ An input widget to select a value in a certain range.
    
    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_
    containing a few HTML elements for rendering. It does not use
    a ``&lt;input type='range'&gt;`` because of its different appearance and
    behaviour accross browsers.
    """

    DEFAULT_MIN_SIZE = 40, 20

    CSS = """

    .flx-Slider:focus {
        outline: none;
    }

    .flx-Slider &gt; .gutter {
        box-sizing: border-box;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;

        margin: 0 5px; /* half width of slider */
        position: absolute;
        top: calc(50% - 2px);
        height: 4px;
        width: calc(100% - 10px);
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.2);
        color: rgba(0,0,0,0);
        text-align: center;
        transition: height 0.2s, top 0.2s;
    }
    .flx-Slider.flx-dragging &gt; .gutter, .flx-Slider:focus &gt; .gutter {
        top: calc(50% - 10px);
        height: 20px;
        color: rgba(0,0,0,1);
    }

    .flx-Slider .slider {
        box-sizing: border-box;
        text-align: center;
        border-radius: 3px;
        background: #48c;
        border: 2px solid #48c;
        transition: top 0.2s, height 0.2s, background 0.4s;
        position: absolute;
        top: calc(50% - 8px);
        height: 16px;
        width: 10px;
        }
    .flx-Slider.flx-dragging .slider, .flx-Slider:focus .slider {
        background: none;
        top: calc(50% - 10px);
        height: 20px;
    }
    .flx-Slider &gt; .gutter &gt; .slider.disabled {
        background: #888;
        border: none;
    }
    """

    step = event.FloatProp(0.01, settable=True, doc="""
        The step size for the slider.
        """)

    min = event.FloatProp(0, settable=True, doc="""
        The minimal slider value.
        """)

    max = event.FloatProp(1, settable=True, doc="""
        The maximum slider value.
        """)

    value = event.FloatProp(0, settable=True, doc="""
        The current slider value.
        """)

    text = event.StringProp('{value}', settable=True, doc="""
        The label to display on the slider during dragging. Occurances of
        "{percent}" are replaced with the current percentage, and
        "{value}" with the current value. Default "{value}".
        """)

    disabled = event.BoolProp(False, settable=True, doc="""
        Whether the slider is disabled.
        """)

    @others
</t>
<t tx="ekr.20181031045138.831">def init(self):
    self._dragging = None

</t>
<t tx="ekr.20181031045138.832">@event.emitter
def user_value(self, value):
    """ Event emitted when the user manipulates the slider.
    Has ``old_value`` and ``new_value`` attributes.
    """
    d = {'old_value': self.value, 'new_value': value}
    self.set_value(value)
    return d

</t>
<t tx="ekr.20181031045138.833">@event.emitter
def user_done(self):
    """ Event emitted when the user stops manipulating the slider. Has
    ``old_value`` and ``new_value`` attributes (which have the same value).
    """
    d = {'old_value': self.value, 'new_value': self.value}
    return d

</t>
<t tx="ekr.20181031045138.834">@event.action
def set_value(self, value):
    global Math
    value = max(self.min, value)
    value = min(self.max, value)
    value = Math.round(value / self.step) * self.step
    self._mutate_value(value)

</t>
<t tx="ekr.20181031045138.835">@event.reaction('min', 'max', 'step')
def __keep_value_constrained(self, *events):
    self.set_value(self.value)

</t>
<t tx="ekr.20181031045138.836">def _render_dom(self):
    global Math
    value = self.value
    mi, ma = self.min, self.max
    perc = 100 * (value - mi) / (ma - mi)
    valuestr = str(value)
    if '.' in valuestr and valuestr[-4:-1] == '000':
        valuestr = valuestr[:-1].rstrip('0')
    label = self.text
    label = label.replace('{value}', valuestr)
    label = label.replace('{percent}', Math.round(perc) + '%')

    attr = {'className': 'slider disabled' if self.disabled else 'slider',
            'style__left': 'calc(' + perc + '% - 5px)'
            }
    return [create_element('div', {'className': 'gutter'},
                create_element('span', {}, label),
                create_element('div', attr),
                )
            ]

# Use the Flexx pointer event system, so we can make use of capturing ...

</t>
<t tx="ekr.20181031045138.837">@event.emitter
def pointer_down(self, e):
    if not self.disabled:
        e.stopPropagation()
        x1 = e.changedTouches[0].clientX if e.changedTouches else e.clientX
        if not e.target.classList.contains("slider"):
            x1 = (self.node.getBoundingClientRect().left +
                  self.node.children[0].children[1].offsetLeft)
        self._dragging = self.value, x1
        self.outernode.classList.add('flx-dragging')
    else:
        return super().pointer_down(e)

</t>
<t tx="ekr.20181031045138.838">@event.emitter
def pointer_up(self, e):
    if self._dragging is not None and len(self._dragging) == 3:
        self.outernode.blur()
    self._dragging = None
    self.outernode.classList.remove('flx-dragging')
    self.user_done()
    return super().pointer_down(e)

</t>
<t tx="ekr.20181031045138.839">@event.emitter
def pointer_move(self, e):
    if self._dragging is not None:
        e.stopPropagation()
        ref_value, x1 = self._dragging[0], self._dragging[1]
        self._dragging = ref_value, x1, True  # mark as moved
        x2 = e.changedTouches[0].clientX if e.changedTouches else e.clientX
        mi, ma = self.min, self.max
        value_diff = (x2 - x1) / self.outernode.clientWidth * (ma - mi)
        self.user_value(ref_value + value_diff)
    else:
        return super().pointer_move(e)

</t>
<t tx="ekr.20181031045138.84">def connect_client(self, ws, name, session_id, cookies=None):
    """ Connect a client to a session that was previously created.
    """
    _, pending, connected = self._appinfo[name]
    # Search for the session with the specific id
    for session in pending:
        if session.id == session_id:
            pending.remove(session)
            break
    else:
        raise RuntimeError('Asked for session id %r, but could not find it' %
                           session_id)

    # Add app to connected, set ws
    assert session.id == session_id
    assert session.status == Session.STATUS.PENDING
    logger.info('New session %s %s' % (name, session_id))
    session._set_cookies(cookies)
    session._set_ws(ws)
    connected.append(session)
    AppManager.total_sessions += 1
    self.connections_changed(session.app_name)
    return session  # For the ws

</t>
<t tx="ekr.20181031045138.840">@event.reaction('key_down')
def __on_key(self, *events):
    for ev in events:
        if ev.key == 'Escape':
            self.outernode.blur()
            self.user_done()
        elif ev.key == 'ArrowRight':
            self.user_value(self.value + self.step)
        elif ev.key == 'ArrowLeft':
            self.user_value(self.value - self.step)
</t>
<t tx="ekr.20181031045138.841">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.842">""" TreeWidget

A ``TreeWidget`` can contain ``TreeItems``, which in turn can contain
``TreeItems`` to construct a tree.

.. UIExample:: 120

    from flexx import app, ui

    class Example(ui.Widget):

        def init(self):

            with ui.TreeWidget(max_selected=2):

                for t in ['foo', 'bar', 'spam', 'eggs']:
                    ui.TreeItem(text=t, checked=True)

Also see examples: :ref:`tree.py`, :ref:`control_with_keys.py`.

"""

from ... import event
from .._widget import Widget, create_element

loop = event.loop


# todo: icons
# todo: tooltips
# todo: a variant that can load data dynamically from Python, for biggish data


</t>
<t tx="ekr.20181031045138.843">class TreeWidget(Widget):
    """
    A Widget that can be used to structure information in a list or a tree.
    It's items are represented by its children, which may only be TreeItem
    objects. Sub items can be created by instantiating TreeItems in the context
    of another TreeItem.

    When the items in the tree have no sub-items themselves, the TreeWidget is
    in "list mode". Otherwise, items can be collapsed/expanded etc.
    
    The ``node`` of this widget is a
    `&lt;div&gt; &lt;https://developer.mozilla.org/docs/Web/HTML/Element/div&gt;`_
    with some child elements and quite a bit of CSS for rendering.
    
    **Style**

    This widget can be fully styled using CSS, using the following CSS classes:

    * ``flx-listmode`` is set on the widget's node if no items have sub items.

    Style classes for a TreeItem's elements:

    * ``flx-TreeItem`` indicates the row of an item (its text, icon, and checkbox).
    * ``flx-TreeItem &gt; collapsebut`` the element used to collapse/expand an item.
    * ``flx-TreeItem &gt; checkbut`` the element used to check/uncheck an item.
    * ``flx-TreeItem &gt; text`` the element that contains the text of the item.
    * ``flx-TreeItem &gt; title`` the element that contains the title of the item.

    Style classes applied to the TreeItem, corresponding to its properties:

    * ``visible-true`` and ``visible-false`` indicate visibility.
    * ``selected-true`` and ``selected-false`` indicate selection state.
    * ``checked-true``, ``checked-false`` and ``checked-null`` indicate checked
      state, with the ``null`` variant indicating not-checkable.
    * ``collapsed-true``, ``collapsed-false`` and ``collapsed-null`` indicate
      collapse state, with the ``null`` variant indicating not-collapsable.
    
    """

    DEFAULT_MIN_SIZE = 100, 50

    CSS = """

    /* ----- Tree Widget Mechanics ----- */

    .flx-TreeWidget {
        height: 100%;
        overflow-y: scroll;
        overflow-x: hidden;
        cursor: default;
    }

    .flx-TreeWidget &gt; ul {
        position: absolute; /* avoid having an implicit width */
        left: 0;
        right: 0;
    }

    .flx-TreeWidget .flx-TreeItem {
        display: inline-block;
        margin: 0;
        padding-left: 2px;
        width: 100%;
        user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
    }

    .flx-TreeWidget .flx-TreeItem &gt; .text {
        display: inline-block;
        position: absolute;
        right: 0;
    }
    .flx-TreeWidget .flx-TreeItem &gt; .title:empty + .text {
        position: static;  /* .text width is not used*/
    }

    .flx-TreeWidget ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }

    .flx-TreeWidget li.visible-false {
        display: none;
    }
    .flx-TreeWidget li.collapsed-true ul {
        display: none;
    }

    /* collapse button */
    .flx-TreeWidget .flx-TreeItem &gt; .collapsebut {
        display: inline-block;
        width: 1.5em;  /* must match with ul padding-left */
        text-align: center;
        margin-left: -1px;  /* aligns better with indentation guide */
    }
    .flx-TreeWidget .flx-TreeItem.collapsed-null &gt; .collapsebut {
        visibility: hidden;
    }
    .flx-TreeWidget.flx-listmode .flx-TreeItem &gt; .collapsebut {
        display: none;
    }

    /* indentation guides */
    .flx-TreeWidget ul {
        padding-left: 0.75em;
    }
    .flx-TreeWidget &gt; ul {
        padding-left: 0em;
    }
    .flx-TreeWidget.flx-listmode ul {
        padding-left: 0.25em;
    }

    /* ----- Tree Widget Style ----- */

    .flx-TreeWidget {
        border: 2px groove black;
        padding: 3px;
    }

    .flx-TreeItem.selected-true {
        background: rgba(128, 128, 128, 0.35);
    }
    .flx-TreeItem.highlighted-true {
        box-shadow: inset 0 0 3px 1px rgba(0, 0, 255, 0.4);
    }

    .flx-TreeWidget .flx-TreeItem.collapsed-true &gt; .collapsebut::after {
        vertical-align: top;
        content: '\\25B8';  /* small right triangle */
    }
    .flx-TreeWidget .flx-TreeItem.collapsed-false &gt; .collapsebut::after {
        vertical-align: top;
        content: '\\25BE';  /* small down triangle */
    }

    .flx-TreeWidget .flx-TreeItem &gt; .collapsebut {
        color: rgba(128, 128, 128, 0.6);
    }
    .flx-TreeWidget li.collapsed-false &gt; ul &gt; li {
        border-left: 1px solid rgba(128, 128, 128, 0.3);
    }
    .flx-TreeWidget li.collapsed-false.selected-true &gt; ul &gt; li {
        border-left: 1px solid rgba(128, 128, 128, 0.6);
    }

    .flx-TreeItem.checked-null &gt; .checkbut {
        content: '\\2611\\00a0';
       /* display: none;  /* could also be visibility: hidden */
    }
    .flx-TreeItem.checked-true &gt; .checkbut::after {
        vertical-align: top;
        content: '\\2611\\00a0';
    }
    .flx-TreeItem.checked-false &gt; .checkbut::after {
        vertical-align: top;
        content: '\\2610\\00a0';
    }

    .flx-TreeWidget .flx-TreeItem &gt; .text.hastitle {
        width: 50%;
    }
    /* ----- End Tree Widget ----- */

    """

    max_selected = event.IntProp(0, settable=True, doc="""
        The maximum number of selected items:

        * If 0 (default) there is no selection.
        * If 1, there can be one selected item.
        * If &gt; 1, up to this number of items can be selected by clicking them.
        * If -1, any number of items can be selected by holding Ctrl or Shift.
        """)

    @others
</t>
<t tx="ekr.20181031045138.844">def init(self):
    self._highlight_on = False
    self._last_highlighted_hint = ''
    self._last_selected = None

</t>
<t tx="ekr.20181031045138.845">def get_all_items(self):
    """ Get a flat list of all TreeItem instances in this Tree
    (including sub children and sub-sub children, etc.), in the order that
    they are shown in the tree.
    """
    items = []
    def collect(x):
        items.append(x)
        for i in x.children:
            if i:
                collect(i)

    for x in self.children:
        collect(x)
    return items

</t>
<t tx="ekr.20181031045138.846">def _render_dom(self):
    nodes = [i.node for i in self.children if isinstance(i, TreeItem)]
    return [create_element('ul', {}, nodes)]

</t>
<t tx="ekr.20181031045138.847">@event.reaction('children', 'children*.children')
def __check_listmode(self, *events):
    listmode = True
    for i in self.children:
        listmode = listmode and len(i.children) == 0 and i.collapsed is None
    if listmode:
        self.node.classList.add('flx-listmode')
    else:
        self.node.classList.remove('flx-listmode')

</t>
<t tx="ekr.20181031045138.848">@event.reaction('max_selected')
def __max_selected_changed(self, *events):
    if self.max_selected == 0:
        # Deselect all
        for i in self.get_all_items():
            i.set_selected(False)
    elif self.max_selected &lt; 0:
        # No action needed
        pass
    else:
        # Deselect all if the count exceeds the max
        count = 0
        for i in self.get_all_items():
            count += int(i.selected)
        if count &gt; self.max_selected:
            for i in self.children:
                i.set_selected(False)

</t>
<t tx="ekr.20181031045138.849">@event.reaction('!children**.pointer_click', '!children**.pointer_double_click')
def _handle_item_clicked(self, *events):
    self._last_highlighted_hint = events[-1].source.id
    if self._highlight_on:  # highhlight tracks clicks
        self.highlight_show_item(events[-1].source)

    if self.max_selected == 0:
        # No selection allowed
        pass

    elif self.max_selected &lt; 0:
        # Select/deselect any, but only with CTRL and SHIFT
        for ev in events:
            item = ev.source
            modifiers = ev.modifiers if ev.modifiers else []
            if 'Shift' in modifiers:  # Ctrl can also be in modifiers
                # Select everything between last selected and current
                if self._last_selected is not None:
                    if self._last_selected is not item:
                        mark_selected = False
                        for i in self.get_all_items():
                            if mark_selected == True:  # noqa - PScript perf
                                if i is item or i is self._last_selected:
                                    break
                                i.user_selected(True)
                            else:
                                if i is item or i is self._last_selected:
                                    mark_selected = True
                item.user_selected(True)
                self._last_selected = item
            elif 'Ctrl' in modifiers:
                # Toggle
                select = not item.selected
                item.user_selected(select)
                self._last_selected = item if select else None
            else:
                # Similar as when max_selected is 1
                for i in self.get_all_items():
                    if i.selected and i is not item:
                        i.user_selected(False)
                select = not item.selected
                item.user_selected(select)
                self._last_selected = item if select else None

    elif self.max_selected == 1:
        # Selecting one, deselects others
        item = events[-1].source
        gets_selected = not item.selected
        if gets_selected:
            for i in self.get_all_items():
                if i.selected and i is not item:
                    i.user_selected(False)
        item.user_selected(gets_selected)  # set the item last

    else:
        # Select to a certain max
        item = events[-1].source
        if item.selected:
            item.user_selected(False)
        else:
            count = 0
            for i in self.get_all_items():
                count += int(i.selected)
            if count &lt; self.max_selected:
                item.user_selected(True)

# NOTE: this highlight API is currently not documented, as it lives
# in JS only. The big refactoring will change all that.

</t>
<t tx="ekr.20181031045138.85">def disconnect_client(self, session):
    """ Close a connection to a client.

    This is called by the websocket when the connection is closed.
    The manager will remove the session from the list of connected
    instances.
    """
    if session.app_name == '__default__':
        logger.info('Default session lost connection to client.')
        return  # The default session awaits a re-connect

    _, pending, connected = self._appinfo[session.app_name]
    try:
        connected.remove(session)
    except ValueError:
        pass
    logger.info('Session closed %s %s' %(session.app_name, session.id))
    session.close()
    self.connections_changed(session.app_name)

</t>
<t tx="ekr.20181031045138.850">def highlight_hide(self):
    """ Stop highlighting the "current" item.
    """
    all_items = self._get_all_items_annotated()
    self._de_highlight_and_get_highlighted_index(all_items)
    self._highlight_on = False

</t>
<t tx="ekr.20181031045138.851">def highlight_show_item(self, item):
    """ Highlight the given item.
    """
    classname = 'highlighted-true'
    all_items = self._get_all_items_annotated()
    self._highlight_on = True
    self._de_highlight_and_get_highlighted_index(all_items)
    item._row.classList.add(classname)
    self._last_highlighted_hint = item.id

</t>
<t tx="ekr.20181031045138.852">def highlight_show(self, step=0):
    """ Highlight the "current" item, optionally moving step items.
    """
    classname = 'highlighted-true'
    all_items = self._get_all_items_annotated()
    self._highlight_on = True

    index1 = self._de_highlight_and_get_highlighted_index(all_items)
    index2 = 0 if index1 is None else index1 + step
    while 0 &lt;= index2 &lt; len(all_items):
        visible, _ = all_items[index2]
        if visible:
            break
        index2 += step
    else:
        index2 = index1
    if index2 is not None:
        _, item = all_items[index2]
        item._row.classList.add(classname)
        self._last_highlighted_hint = item.id
        # Scroll into view when needed
        y1 = item._row.offsetTop - 20
        y2 = item._row.offsetTop + item._row.offsetHeight + 20
        if self.node.scrollTop &gt; y1:
            self.node.scrollTop = y1
        if self.node.scrollTop + self.node.offsetHeight &lt; y2:
            self.node.scrollTop = y2 - self.node.offsetHeight

</t>
<t tx="ekr.20181031045138.853">def highlight_get(self):
    """ Get the "current" item. This is the currently highlighted
    item if there is one. Otherwise it can be the last highlighted item
    or the last clicked item.
    """
    classname = 'highlighted-true'
    all_items = self._get_all_items_annotated()

    index = self._de_highlight_and_get_highlighted_index(all_items)
    if index is not None:
        _, item = all_items[index]
        item._row.classList.add(classname)
        return item

</t>
<t tx="ekr.20181031045138.854">def highlight_toggle_selected(self):
    """ Convenience method to toggle the "selected" property of the
    current item.
    """
    item = self.highlight_get()
    if item is not None:
        self._handle_item_clicked(dict(source=item))  # simulate click

</t>
<t tx="ekr.20181031045138.855">def highlight_toggle_checked(self):
    """ Convenience method to toggle the "checked" property of the
    current item.
    """
    item = self.highlight_get()
    if item is not None:
        if item.checked is not None:  # is it checkable?
            item.user_checked(not item.checked)

</t>
<t tx="ekr.20181031045138.856">def _de_highlight_and_get_highlighted_index(self, all_items):
    """ Unhighlight all items and get the index of the item that was
    highlighted, or which otherwise represents the "current" item, e.g.
    because it was just clicked.
    """
    classname = 'highlighted-true'
    index = None
    hint = None
    for i in range(len(all_items)):
        visible, item = all_items[i]
        if item._row.classList.contains(classname):
            item._row.classList.remove(classname)
            if index is None:
                index = i
        if hint is None and item.id == self._last_highlighted_hint:
            hint = i
    if index is not None:
        return index
    else:
        return hint

</t>
<t tx="ekr.20181031045138.857">def _get_all_items_annotated(self):
    """ Get a flat list of all TreeItem instances in this Tree,
    including visibility information due to collapsed parents.
    """
    items = []
    def collect(x, parent_collapsed):
        visible = x.visible and not parent_collapsed
        items.append((visible, x))
        for i in x.children:
            if i:
                collect(i, parent_collapsed or x.collapsed)

    for x in self.children:
        collect(x, False)
    return items


</t>
<t tx="ekr.20181031045138.858">class TreeItem(Widget):
    """ An item to put in a TreeWidget. This widget should only be used inside
    a TreeWidget or another TreeItem.

    Items are collapsable/expandable if their ``collapsed`` property
    is set to ``True`` or ``False`` (i.e. not ``None``), or if they
    have sub items. Items are checkable if their ``checked`` property
    is set to ``True`` or ``False`` (i.e. not ``None``). Items are
    selectable depending on the selection policy defined by
    ``TreeWidget.max_selected``.

    If needed, the ``_render_title()`` and ``_render_text()`` methods can
    be overloaded to display items in richer ways. See the documentation
    of ``Widget._render_dom()`` for details.

    """

    text = event.StringProp('', settable=True, doc="""
        The text for this item. Can be used in combination with
        ``title`` to obtain two columns.
        """)

    title = event.StringProp('', settable=True, doc="""
        The title for this item that appears before the text. Intended
        for display of key-value pairs. If a title is given, the text is
        positioned in a second (virtual) column of the tree widget.
        """)

    visible = event.BoolProp(True, settable=True, doc="""
        Whether this item (and its sub items) is visible.
        """)

    selected = event.BoolProp(False, settable=True, doc="""
        Whether this item is selected. Depending on the TreeWidget's
        policy (max_selected), this can be set/unset on clicking the item.
        """)

    checked = event.TriStateProp(settable=True, doc="""
        Whether this item is checked (i.e. has its checkbox set).
        The value can be None, True or False. None (the default)
        means that the item is not checkable.
        """)

    collapsed = event.TriStateProp(settable=True, doc="""
        Whether this item is expanded (i.e. shows its children).
        The value can be None, True or False. None (the default)
        means that the item is not collapsable (unless it has sub items).
        """)

    @others
</t>
<t tx="ekr.20181031045138.859">@event.emitter
def user_selected(self, selected):
    """ Event emitted when the user (un)selects this item. Has ``old_value``
    and ``new_value`` attributes. One can call this emitter directly to
    emulate a user-selection, but note that this bypasses the max_selected
    policy.
    """
    d = {'old_value': self.selected, 'new_value': selected}
    self.set_selected(selected)
    return d

</t>
<t tx="ekr.20181031045138.86">def has_app_name(self, name):
    """ Returns the case-corrected name if the given name matches
    a registered appliciation (case insensitive). Returns None if the
    given name does not match any applications.
    """
    name = name.lower()
    for key in self._appinfo.keys():
        if key.lower() == name:
            return key
    else:
        return None

</t>
<t tx="ekr.20181031045138.860">@event.emitter
def user_checked(self, checked):
    """ Event emitted when the user (un)checks this item. Has ``old_value``
    and ``new_value`` attributes.
    """
    d = {'old_value': self.checked, 'new_value': checked}
    self.set_checked(checked)
    return d

</t>
<t tx="ekr.20181031045138.861">@event.emitter
def user_collapsed(self, collapsed):
    """ Event emitted when the user (un)collapses this item. Has ``old_value``
    and ``new_value`` attributes.
    """
    d = {'old_value': self.collapsed, 'new_value': collapsed}
    self.set_collapsed(collapsed)
    return d

</t>
<t tx="ekr.20181031045138.862">@event.action
def set_parent(self, parent, pos=None):
    # Verify that this class is used correctly
    # Note that this action is already called from the init by Widget.
    if not (parent is None or
            isinstance(parent, TreeItem) or
            isinstance(parent, TreeWidget)):
        raise RuntimeError('TreeItems can only be created in the context '
                           'of a TreeWidget or TreeItem.')
    super().set_parent(parent, pos)

</t>
<t tx="ekr.20181031045138.863">def _create_dom(self):
    global window
    node = window.document.createElement('li')
    self._row = window.document.createElement('span')  # we need this node
    node.appendChild(self._row)
    self._addEventListener(node, 'click', self._on_click)
    self._addEventListener(node, 'dblclick', self._on_double_click)
    return node

</t>
<t tx="ekr.20181031045138.864">def _render_dom(self):
    # We render more or less this:
    # &lt;li&gt;
    #     &lt;span class='flx-TreeItem'&gt;     # the row that represents the item
    #         &lt;span class='padder'&gt;&lt;/span&gt;    # padding
    #         &lt;span class='collapsebut'&gt;&lt;/span&gt;   # the collapse button
    #         &lt;span class='checkbut'&gt;&lt;/span&gt;  # the check button
    #         &lt;span class='title'&gt;&lt;/span&gt;     # the title text for this item
    #         &lt;span class='text'&gt;&lt;/span&gt;      # the text for this item
    #         &lt;/span&gt;
    #     &lt;ul&gt;&lt;/ul&gt;                           # to hold sub items
    # &lt;/li&gt;

    subnodes = [item.outernode for item in self.children]

    # Get class names to apply to the li and row. We apply the clases to
    # both to allow styling both depending on these values, but strictly
    # speaking visible and collapsed are only needed for the li and
    # selected and checked for the span.
    cnames = []
    collapsed = bool(self.collapsed) if len(self.children) &gt; 0 else self.collapsed
    for name, val in [('visible', self.visible),
                      ('collapsed', collapsed),
                      ('selected', self.selected),
                      ('checked', self.checked),
                      ]:
        cnames.append(name + '-' + str(val))
    cnames = ' '.join(cnames)

    # Get title and text content
    title, text = self._render_title(), self._render_text()

    # Note that the outernode (the &lt;li&gt;) has not flx-Widget nor flx-TreeItem
    text_class = 'text hastitle' if len(title) &gt; 0 else 'text'
    return create_element('li', {'className': cnames},
                create_element('span', {'className': 'flx-TreeItem ' + cnames},
                    create_element('span', {'className': 'padder'}),
                    create_element('span', {'className': 'collapsebut'}),
                    create_element('span', {'className': 'checkbut'}),
                    create_element('span', {'className': 'title'}, title),
                    create_element('span', {'className': text_class}, text),
                    ),
                create_element('ul', {}, subnodes),
                )

</t>
<t tx="ekr.20181031045138.865">def _render_title(self):
    """ Return a node for title. Can be overloaded to e.g. format with html.
    """
    return self.title

</t>
<t tx="ekr.20181031045138.866">def _render_text(self):
    """ Return a node for text. Can be overloaded to e.g. format these with html.
    """
    return self.text

</t>
<t tx="ekr.20181031045138.867">def _on_click(self, e):
    # Handle JS mouse click event
    e.stopPropagation()  # don't click parent items
    if e.target.classList.contains('collapsebut'):
        self.user_collapsed(not self.collapsed)
    elif e.target.classList.contains('checkbut'):
        self.user_checked(not self.checked)
    else:
        self.pointer_click(e)

</t>
<t tx="ekr.20181031045138.868">def _on_double_click(self, e):
    # Handle JS mouse double click event
    e.stopPropagation()  # don't click parent items
    c1 = e.target.classList.contains('collapsebut')
    c2 = e.target.classList.contains('checkbut')
    if not (c1 or c2):
        self.pointer_double_click(e)
</t>
<t tx="ekr.20181031045138.869">@path C:/Anaconda3/Lib/site-packages/flexx/ui/widgets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.87">def get_app_names(self):
    """ Get a list of registered application names.
    """
    return [name for name in sorted(self._appinfo.keys())]

</t>
<t tx="ekr.20181031045138.870">""" Namespace for all widgets (that are not layouts).
"""

# flake8: noqa

from .. import Widget

from ._button import BaseButton, Button, ToggleButton, RadioButton, CheckBox
from ._lineedit import LineEdit
from ._label import Label
from ._group import GroupWidget
from ._iframe import IFrame
from ._canvas import CanvasWidget
from ._color import ColorSelectWidget
from ._media import ImageWidget, VideoWidget, YoutubeWidget

from ._progressbar import ProgressBar
from ._slider import Slider
from ._tree import TreeWidget, TreeItem
from ._dropdown import ComboBox, DropdownContainer

from ._plotwidget import PlotWidget
from ._plotly import PlotlyWidget
from ._bokeh import BokehWidget
</t>
<t tx="ekr.20181031045138.871"></t>
<t tx="ekr.20181031045138.872">@path C:/Anaconda3/Lib/site-packages/flexx/util/
@others
if __name__ == '__main__':

    sys.argv.append('--test-foo=8')
    c = Config('test',
               foo=(3, int, 'foo yeah'),
               spam=(2.1, float, 'a float!'))
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.873">from __future__ import print_function, absolute_import

import re
import os
import sys
import logging

if sys.version_info[0] == 2:  # pragma: no cover
    from ConfigParser import ConfigParser as _ConfigParser
    from StringIO import StringIO

    class ConfigParser(_ConfigParser):
        def read_string(self, string, source):
            return self.readfp(StringIO(string), source)

else:
    from configparser import ConfigParser


</t>
<t tx="ekr.20181031045138.874">def as_bool(value):
    if isinstance(value, bool):
        return value
    elif isinstance(value, basestring) and value.lower() in BOOLEAN_STATES:
        return BOOLEAN_STATES[value.lower()]
    else:
        raise ValueError('Cannot make a bool of %r' % value)

</t>
<t tx="ekr.20181031045138.875">def get_tuple_validator(subvalidator):
    def validator(value):
        if isinstance(value, (tuple, list)):
            value2 = tuple(value)
        elif isinstance(value, basestring):
            value2 = tuple([s.strip() for s in value.strip('()[]').split(',')])
        else:
            raise ValueError('Cannot make a tuple of %r' % value)
        return tuple([subvalidator(x) for x in value2])
    return validator

</t>
<t tx="ekr.20181031045138.876">def stack_sorter(key):
    # Implement ordering, files and strings go at spot 1
    return dict(default=0, environ=2, argv=3, set=4).get(key[0], 1)


BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True,
                  '0': False, 'no': False, 'false': False, 'off': False}

TYPEMAP = {float: float, int: int, bool: as_bool}
if sys.version_info[0] == 2:  # pragma: no cover
    TYPEMAP[basestring] = unicode  # noqa
    TYPEMAP[str] = unicode  # noqa
else:
    basestring = str
    TYPEMAP[str] = str

INSTANCE_DOCS = """ Configuration object for {name}

    The options below can be set from different sources, and are
    evaluated in the following order:

    * From the default value.
    * From .cfg or .ini file, or a string in cfg format.
    * From environment variables, e.g. ``{NAME}_FOO=3``.
    * From command-line arguments, e.g. ``--{name}-foo=3``.
    * From setting the config option directly, e.g. ``config.foo = 3``.

    Use ``print(config)`` to get a summary of the current values and
    from which sources they were set.

    Parameters:
    """


</t>
<t tx="ekr.20181031045138.877">class Config(object):
    """ Class for configuration objects.

    A Config object has a set of options, which can be str, int, float,
    bool, or a tuple of any of the above. Options can be set from
    different sources:

    * Each option has a default value.
    * From .cfg or .ini files.
    * From strings in ini format.
    * From environment variables.
    * From command-line arguments.
    * By setting the config option directly.

    Parameters:
        name (str): the name by which to identify this config. This name
            is used as a prefix in environment variables and command
            line arguments, and optionally as a section header in .cfg files.
        *sources: Sources to initialize the option values with.
            These can be strings in ini format, or .ini or .cfg filenames.
            If a file is given that does not exist, it is simply ignored.
            Special prefixes ``~/`` and ``~appdata/`` are expanded to the
            home dir and appdata dir.
        **options: The options specification: each option consists of
            a 3-element tuple (default, type, docstring).

    Example:

        .. code-block:: Python

            config = Config('myconfig', '~appdata/.myconfig.cfg',
                            foo=(False, bool, 'Whether to foo'),
                            bar=(0.0, float, 'The size of the bar'),
                            spam=('1,2,3', [int], 'A tuple of ints'))

        With this, options can be set:

        * With an entry ``foo = 3`` in "~appdata/.myconfig.cfg".
        * With a string ``"foo = 3"`` passed at initialization.
        * With an environment variable named ``MYCONFIG_FOO``.
        * With a command line argument ``--myconfig-foo=3``.
        * By doing ``config.foo = 3``, or ``config['foo'] = 3`` in Python.

    Notes:
        * Option names are case insensitive, except for attribute access and
          environment variables (the latter must be all uppercase).
        * All values can be set as a Python object or a string; they
          are automatically converted to the correct type.
        * Each instance gets a docstring that lists all options, so it
          can easily be used in e.g. Sphynx docs.
    """

    @others
</t>
<t tx="ekr.20181031045138.878">def __init__(self, name, *sources, **options):

    # The identifier name for this config
    self._name = name
    if not is_valid_name(name):
        raise ValueError('Config name must be an alphanumeric string, '
                         'starting with a letter.')

    # The option names (unmodified case)
    self._options = []

    # Where the values are stored, we keep a stack, lowercase keys
    self._opt_values = {}  # name -&gt; list of (source, value) tuples

    # Map of lowercase option names to validator functions
    self._opt_validators = {}

    # Map of lowercase option names to type names, for better reporting
    self._opt_typenames = {}

    # Map of lowercase option names to docstrings
    self._opt_docs = {}

    # Parse options
    option_docs = ['']
    for name in sorted(options.keys(), key=lambda x: x.lower()):
        lname = name.lower()
        spec = options[name]
        # Checks
        if not is_valid_name(name):
            raise ValueError('Option name must be alphanumeric strings, '
                             'starting with a letter, and not private.')
        if not len(spec) == 3:
            raise ValueError('Option spec must be (default, type, docs)')
        default, typ, doc = spec
        istuple = False
        if isinstance(typ, (tuple, list)):
            if len(typ) != 1:
                raise ValueError('Tuple type spec should have one element.')
            istuple, typ = True, typ[0]
        if not (isinstance(typ, type) and issubclass(typ, tuple(TYPEMAP))):
            raise ValueError('Option types can be str, bool, int, float.')
        # Parse
        typename = typ.__name__ + ('-tuple' if istuple else '')
        args = name, typename, doc, default
        option_docs.append(' '*8 + '%s (%s): %s (default %r)' % args)
        self._options.append(name)
        self._opt_typenames[lname] = typename
        self._opt_validators[lname] = (get_tuple_validator(TYPEMAP[typ])
                                       if istuple else TYPEMAP[typ])
        self._opt_docs[lname] = doc
        self._opt_values[lname] = []

    # Overwrite docstring
    self.__doc__ = INSTANCE_DOCS.format(name=self._name,
                                        NAME=self._name.upper())
    self.__doc__ += '\n'.join(option_docs)

    # --- init values

    # Set defaults
    for name, spec in options.items():
        self._set('default', name, spec[0])

    # Load from sources
    for source in sources:
        if not isinstance(source, basestring):
            raise ValueError('Sources should be strings or filenames.')
        if '\n' in source:
            self.load_from_string(source)
        else:
            self.load_from_file(source)

    # Load from environ
    for name in self._opt_values:
        env_name = (self._name + '_' + name).upper()
        value = os.getenv(env_name, None)  # getenv is case insensitive
        if value is not None:
            self._set('environ', name, value)

    # Load from argv
    arg_prefix = '--' + self._name.lower() + '-'
    for i in range(1, len(sys.argv)):
        arg = sys.argv[i]
        if arg.lower().startswith(arg_prefix) and '=' in arg:
            name, value = arg[len(arg_prefix):].split('=', 1)
            if name.lower() in self._opt_values:
                self._set('argv', name, value)

</t>
<t tx="ekr.20181031045138.879">def __repr__(self):
    t = '&lt;Config %r with %i options at 0x%x&gt;'
    return t % (self._name, len(self._options), id(self))

</t>
<t tx="ekr.20181031045138.88">def get_session_by_id(self, id):
    """ Get session object by its id, or None.
    """
    return self._session_map.get(id, None)

</t>
<t tx="ekr.20181031045138.880">def __str__(self):
    # Return a string representing a summary of the options and
    # how they were set from different sources.
    lines = []
    lines.append('Config %r with %i options.' %
                 (self._name, len(self._options)))
    for name in self._options:
        lname = name.lower()
        lines.append('\nOption %s (%s) - %s' % (name,
                                              self._opt_typenames[lname],
                                              self._opt_docs[lname]))
        for source, val in self._opt_values[lname]:
            lines.append('    %r from %s' % (val, source))
        lines[-1] = ' -&gt; ' + lines[-1][4:]  # Mark current value
    return '\n'.join(lines)

</t>
<t tx="ekr.20181031045138.881">def __len__(self):
    return len(self._options)

</t>
<t tx="ekr.20181031045138.882">def __iter__(self):
    return self._options.__iter__()

</t>
<t tx="ekr.20181031045138.883">def __dir__(self):
    return self._options

</t>
<t tx="ekr.20181031045138.884">def __getattr__(self, name):
    # Case sensitive get
    if not name.startswith('_') and name in self._options:
        return self._opt_values[name.lower()][-1][1]
    return super(Config, self).__getattribute__(name)

</t>
<t tx="ekr.20181031045138.885">def __getitem__(self, name):
    # Case insensitive get
    if not isinstance(name, basestring):
        raise TypeError('Config only allows subscripting by name strings.')
    if name.lower() in self._opt_values:
        return self._opt_values[name.lower()][-1][1]
    else:
        raise IndexError('Config has no option %r' % name)

</t>
<t tx="ekr.20181031045138.886">def __setattr__(self, name, value):
    # Case sensitive set
    if not name.startswith('_') and name in self._options:
        return self._set('set', name, value)
    return super(Config, self).__setattr__(name, value)

</t>
<t tx="ekr.20181031045138.887">def __setitem__(self, name, value):
    # Case insensitve set
    if not isinstance(name, basestring):
        raise TypeError('Config only allows subscripting by name strings.')
    if name.lower() in self._opt_values:
        return self._set('set', name, value)
    else:
        raise IndexError('Config has no option %r' % name)

</t>
<t tx="ekr.20181031045138.888">def _set(self, source, name, value):
    # The actual setter (case insensitive), applies the validator
    validator = self._opt_validators[name.lower()]
    try:
        real_value = validator(value)
    except Exception:
        args = name, self._opt_typenames[name.lower()], value
        raise ValueError('Cannot set option %s (%s) from %r' % args)
    stack = self._opt_values[name.lower()]
    if stack and stack[-1][0] == source:
        stack[-1] = source, real_value
    else:
        stack.append((source, real_value))
        stack.sort(key=stack_sorter)

</t>
<t tx="ekr.20181031045138.889">def load_from_file(self, filename):
    """ Load config options from a file, as if it was given as a
    source during initialization. This means that options set via
    argv, environ or directly will not be influenced.
    """
    # Expand special prefix
    filename = filename.replace('~appdata/', appdata_dir() + '/')
    filename = filename.replace('~appdata\\', appdata_dir() + '\\')
    filename = os.path.expanduser(filename)
    # Proceed if is an actual file
    if os.path.isfile(filename):
        text = None
        try:
            text = open(filename, 'rb').read().decode()
        except Exception as err:
            logging.warn('Could not read config from %r:\n%s' %
                         (filename, str(err)))
            return
        self.load_from_string(text, filename)

</t>
<t tx="ekr.20181031045138.89">def get_connections(self, name):
    """ Given an app name, return the connected session objects.
    """
    _, pending, connected = self._appinfo[name]
    return list(connected)

</t>
<t tx="ekr.20181031045138.890">def load_from_string(self, text, filename='&lt;string&gt;'):
    """ Load config options from a string, as if it was given as a
    source during initialization. This means that options set via
    argv, environ or directly will not be influenced.
    """
    try:
        self._load_from_string(text, filename)
    except Exception as err:
        logging.warn(str(err))

</t>
<t tx="ekr.20181031045138.891">def _load_from_string(self, s, filename):
    # Create default section, so that users can work with sectionless
    # files (as is common in an .ini file)
    name_section = '[%s]\n' % self._name
    if name_section not in s:
        s = name_section + s
    s += '\n'
    parser = ConfigParser()
    parser.read_string(s, filename)
    if parser.has_section(self._name):
        for name in self._options:
            if parser.has_option(self._name, name):
                value = parser.get(self._name, name)
                self._set(filename, name, value)


</t>
<t tx="ekr.20181031045138.892">def is_valid_name(n):
    return isidentifier(n) and not n.startswith('_')


</t>
<t tx="ekr.20181031045138.893">def isidentifier(s):
    # http://stackoverflow.com/questions/2544972/
    if not isinstance(s, basestring):  # noqa
        return False
    return re.match(r'^\w+$', s, re.UNICODE) and re.match(r'^[0-9]', s) is None


# From pyzolib/paths.py 
</t>
<t tx="ekr.20181031045138.894">def appdata_dir(appname=None, roaming=False):
    """ Get the path to the application directory, where applications
    are allowed to write user specific files (e.g. configurations).
    """
    # Define default user directory
    userDir = os.path.expanduser('~')
    # Get system app data dir
    path = None
    if sys.platform.startswith('win'):
        path1, path2 = os.getenv('LOCALAPPDATA'), os.getenv('APPDATA')
        path = (path2 or path1) if roaming else (path1 or path2)
    elif sys.platform.startswith('darwin'):
        path = os.path.join(userDir, 'Library', 'Application Support')
    # On Linux and as fallback
    if not (path and os.path.isdir(path)):  # pragma: no cover
        path = os.environ.get(
            "XDG_CONFIG_HOME",
            os.path.expanduser(os.path.join("~", ".config")))
    # Maybe we should store things local to the executable (in case of a
    # portable distro or a frozen application that wants to be portable)
    prefix = sys.prefix
    if getattr(sys, 'frozen', None):  # See application_dir() function
        prefix = os.path.abspath(os.path.dirname(sys.executable))
    for reldir in ('settings', '../settings'):
        localpath = os.path.abspath(os.path.join(prefix, reldir))
        if os.path.isdir(localpath):  # pragma: no cover
            try:
                open(os.path.join(localpath, 'test.write'), 'wb').close()
                os.remove(os.path.join(localpath, 'test.write'))
            except IOError:
                pass  # We cannot write in this directory
            else:
                path = localpath
                break
    # Get path specific for this app
    if appname:  # pragma: no cover
        if path == userDir:
            appname = '.' + appname.lstrip('.')  # Make it a hidden directory
        path = os.path.join(path, appname)
        if not os.path.isdir(path):  # pragma: no cover
            os.mkdir(path)
    # Done
    return path


</t>
<t tx="ekr.20181031045138.895">@path C:/Anaconda3/Lib/site-packages/flexx/util/
@others
if __name__ == '__main__':
    for key in RESOURCES:
        get_resource(key)
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.896">"""
Functionality to ensure up-to-date versions of resources. This module
must be able to run standalone, since it will be used from setup.py to
pack resources in dist packages.
"""

from __future__ import absolute_import, print_function, division

import os

try:
    from .logging import logger
    warning, info = logger.warning, logger.info
except Exception:
    warning = info = print

try:
    from urllib.request import urlopen
except ImportError:
    try:
        from urllib2 import urlopen  # Legacy Python
    except ImportError:
        raise RuntimeError('Could not import urlopen.')


# Definition of remote resources, optionally versioned ('{}' in url becomes tag)
phosphor_url = 'https://raw.githubusercontent.com/flexxui/phosphor-all/{}/dist/'
RESOURCES = {
    #'bsdf.js': ('https://gitlab.com/almarklein/bsdf/raw/{}/javascript/bsdf.js', ''),
    'phosphor-all.js': (phosphor_url + 'phosphor-all.js', '94d59b003849f'),
    'phosphor-all.css': (phosphor_url + 'phosphor-all.css', '94d59b003849f'),
}


</t>
<t tx="ekr.20181031045138.897">def get_resoure_path(filename):
    """ Get the full path to a resource, corresponding to the given
    filename. Will use cached version if available. Otherwise will
    download and cache.
    """

    # Get location of resource dir
    dest = os.path.abspath(os.path.join(__file__, '..', '..', 'resources'))
    if not os.path.isdir(dest):
        raise ValueError('Resource dest dir %r is not a directory.' % dest)

    # Get full filename for downloaded file
    path = os.path.join(dest, filename)
    url = ''

    if filename in RESOURCES:
        # Get url
        url, tag = RESOURCES[filename]
        # Modify url and path based on tag
        if tag:
            url = url.replace('{}', tag)
            basename, ext = path.rsplit('.', 1)
            path = basename + '.' + tag + '.' + ext
        # Download if needed
        if not os.path.isfile(path):
            data = _fetch_file(url)
            with open(path, 'wb') as f:
                f.write(data)
    else:
        # Resource is supposed to just be in the dir
        if not os.path.isfile(path):
            raise ValueError('Unknown/unavailable resource %r' % filename)

    return path


</t>
<t tx="ekr.20181031045138.898">def get_resource(filename):
    """ Get the bytes of the resource corresponding to the given filename.
    """
    return open(get_resoure_path(filename), 'rb').read()


</t>
<t tx="ekr.20181031045138.899">def _fetch_file(url):
    """ Fetches a file from the internet. Retry a few times before
    giving up on failure.
    """
    info('Downloading %s' % url)
    for tries in range(4):
        try:
            return urlopen(url, timeout=5.0).read()
        except Exception as e:
            warning('Error while fetching file: %s' % str(e))
    raise IOError('Unable to download %r. Perhaps there is a no internet '
                  'connection? If there is, please report this problem.' % url)


# Running this file as a script will download all downloadable resources
</t>
<t tx="ekr.20181031045138.90">@event.emitter
def connections_changed(self, name):
    """ Emits an event with the name of the app for which a
    connection is added or removed.
    """
    return dict(name=str(name))


\\-4.# Create global app manager object
</t>
<t tx="ekr.20181031045138.900">@path C:/Anaconda3/Lib/site-packages/flexx/util/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.901">"""
Improved logging facilities:

* info and debug messages are printed to stdout instead of stderr.
* if level is set to debug, will show source of each message.
* ability to filter messages with a regexp.
* provides a context manager to capture log messages in a list.

This code can be put anywhere in your project, then import
set_log_level()
"""

# The code in this file is inspired by similar code from the Vispy project

import re
import sys
import time
import logging
import traceback


MODULE_NAME = __name__.split('.')[0]

logging_types = dict(debug=logging.DEBUG, info=logging.INFO,
                     warning=logging.WARNING, error=logging.ERROR,
                     critical=logging.CRITICAL)


</t>
<t tx="ekr.20181031045138.902">class _Formatter(logging.Formatter):
    """Formatter that optionally prepends caller """

    @others
</t>
<t tx="ekr.20181031045138.903">def __init__(self):
    super().__init__()  # '%(levelname)s %(name)s: %(message)s')
    self.prepend_caller = False

</t>
<t tx="ekr.20181031045138.904">def format(self, record):
    base = '[{} {} {}] '.format(record.levelname[0],
                                time.strftime('%H:%M:%S'),
                                record.name)
    if isinstance(record.msg, Exception):
        # Get excepion info and skip first frames
        type_, value, tb = sys.exc_info()
        for _ in range(getattr(value, 'skip_tb', 0)):
            tb = tb.tb_next
        # Enable post mortem debugging
        sys.last_type = type_
        sys.last_value = value
        sys.last_traceback = tb
        # Compose message
        cname = type_.__name__
        out = ''.join(traceback.format_list(traceback.extract_tb(tb)))
        del tb  # we don't want to hold too much references to this
        return base + cname + ': ' + str(value) + '\n' + out.rstrip()
    else:
        out = base + str(record.msg % record.args)
        if self.prepend_caller:
            part1, part2 = out.split(':', 1)
            out = part1 + ' ' + record.funcName + '():' + part2
        return out


</t>
<t tx="ekr.20181031045138.905">class _Handler(logging.StreamHandler):
    """ Stream handler that prints INFO and lower to stdout
    """

    @others
</t>
<t tx="ekr.20181031045138.906">def emit(self, record):
    if record.levelno &gt;= logging.WARNING:
        self.stream = sys.stderr
    else:
        self.stream = sys.stdout
    super().emit(record)


</t>
<t tx="ekr.20181031045138.907">class _MatchFilter:
    """ To filter records on regexp matches.
    """
    @others
</t>
<t tx="ekr.20181031045138.908">def __init__(self):
    self.match = None

</t>
<t tx="ekr.20181031045138.909">def filter(self, record):
    match = self.match
    if not match:
        return True
    elif isinstance(match, str):
        return (match in record.name or
                match in record.getMessage() or
                match in record.funcName)
    else:
        return (re.search(match, record.name) or
                re.search(match, record.getMessage()) or
                re.search(match, record.funcName))


</t>
<t tx="ekr.20181031045138.91">@path C:/Anaconda3/Lib/site-packages/flexx/app/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.910">class _CaptureFilter:
    """ To collect records in the capture_log context.
    """
    @others
</t>
<t tx="ekr.20181031045138.911">def __init__(self):
    self.records = []

</t>
<t tx="ekr.20181031045138.912">def filter(self, record):
    self.records.append(_formatter.format(record))
    return False


</t>
<t tx="ekr.20181031045138.913">def set_log_level(level, match=None):
    """Set the logging level and match filter

    Parameters:
        level (str, int): The verbosity of messages to print.
            If a str, it can be either DEBUG, INFO, WARNING, ERROR, or
            CRITICAL. Note that these are for convenience and are equivalent
            to passing in logging.DEBUG, etc.
        match (str, regexp, None): String to match. Only those messages
            that contain ``match`` as a substring (and has the
            appropriate ``level``) will be displayed. Match can also be
            a compiled regexp.

    Notes
    -----
    If level is DEBUG, the method emitting the log message will be
    prepended to each log message. Note that if ``level`` is DEBUG or
    if the ``match`` option is used, a small overhead is added to each
    logged message.
    """
    if isinstance(level, str):
        level = level.lower()
        if level not in logging_types:
            raise ValueError('Invalid argument "%s"' % level)
        level = logging_types[level]
    elif not isinstance(level, int):
        raise TypeError('log level must be an int or string')
    logger.setLevel(level)
    _filter.match = match
    _formatter.prepend_caller = level &lt;= logging.DEBUG


</t>
<t tx="ekr.20181031045138.914">class capture_log:
    """ Context manager to capture log messages. Useful for testing.
    Usage:

    .. code-block:: python

        with capture_log(level, match) as log:
            ...
        # log is a list strings (as they would have appeared in the console)
    """

    @others
logger = logging.getLogger(MODULE_NAME)
logger.propagate = False
logger.setLevel(logging.INFO)

# Remove previous handlers, these can be leftovers when flexx is re-imorted,
# as can happen during tests
h = None
for h in list(logger.handlers):
    if h.__class__.__module__ == __name__:
        logger.removeHandler(h)
del h

_handler = _Handler()
_filter = _MatchFilter()
_formatter = _Formatter()

logger.addHandler(_handler)
_handler.addFilter(_filter)
_handler.setFormatter(_formatter)
</t>
<t tx="ekr.20181031045138.915">def __init__(self, level, match=None):
    self._args = level, match

</t>
<t tx="ekr.20181031045138.916">def __enter__(self):
    self._old_args = logger.level, _filter.match
    set_log_level(*self._args)
    self._filter = _CaptureFilter()
    _handler.addFilter(self._filter)
    return self._filter.records

</t>
<t tx="ekr.20181031045138.917">def __exit__(self, type, value, traceback):
    _handler.removeFilter(self._filter)
    set_log_level(*self._old_args)


\\-4.# Create logger

</t>
<t tx="ekr.20181031045138.918">@path C:/Anaconda3/Lib/site-packages/flexx/util/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.919">"""
JavaScript minification tools.
"""

</t>
<t tx="ekr.20181031045138.92">"""
Definition of the Asset class to represent JS and CSS assets, and a derived
class used as a container for one or more JSModule classes.
"""

import sys
import types
from urllib.request import urlopen, Request

from . import logger

# The pscript package does not deal with license headers,
# we add them to our assets here.
HEADER = 'Autogenerated code from Flexx. Code Subject to the BSD-2-clause license.'
HEADER = '/* %s */\n\n' % HEADER

url_starts = 'https://', 'http://'


# Although these two funcs are better off in modules.py, that causes circular refs.
</t>
<t tx="ekr.20181031045138.920">def minify(code, remove_whitespace=False):
    """ Very basic minification of JavaScript code. Will likely support
    more advanced minifcation in the future.

    Parameters:
        code (str) : the JavaScript code to minify.
        remove_whitespace (bool) : if True, removes all non-functional
            whitespace. Otherwise remove all trailing whitespace and
            indents using tabs to preserve space. Default False.
    """
    code = remove_comments(code)
    if remove_whitespace:
        code = remove_all_whitespace(code)
    else:
        code = remove_trailing_whitespace(code)
        code = remove_empty_lines(code)
        code = tabbify(code)
    return code

</t>
<t tx="ekr.20181031045138.921">def remove_comments(code):
    chars = ['\n']
    class non_local:
        pass
    non_local._i = -1

    def read():
        non_local._i += 1
        if non_local._i &lt; len(code):
            return code[non_local._i]
    def to_end_of_string(c0):
        chars.append(c0)
        while True:
            c = read()
            if not c:
                break
            chars.append(c)
            if c == c0 and chars[-2] != '\\':
                return
    def to_end_of_line():
        while True:
            c = read()
            if c == '\n' or not c:
                break
    def to_end_of_mutiline_comment():
        lastchar = ''
        while True:
            c = read()
            if not c:
                break
            if c == '/' and lastchar == '*':
                return
            lastchar = c
    while True:
        c = read()
        if not c:
            break  # end of code
        elif c == "'" or c == '"':
            to_end_of_string(c)
        elif c == '/' and chars[-1] == '/' and chars[-2] != '\\':
            chars.pop(-1)
            to_end_of_line()
            chars.append('\n')
        elif c == '*' and chars[-1] == '/':
            chars.pop(-1)
            to_end_of_mutiline_comment()
        else:
            chars.append(c)
    chars.pop(0)
    return ''.join(chars)

</t>
<t tx="ekr.20181031045138.922">def remove_all_whitespace(code):
    raise RuntimeError('full whitespace removal for minification is currently broken')
    # todo: this is broken
    code = code.replace('\t', ' ').replace('\r', ' ').replace('\n', ' ')
    space_safe = ' =+-/*&amp;|(){},.&gt;&lt;:;'
    chars = ['\n']
    class non_local:
        pass
    non_local._i = -1

    def read():
        non_local._i += 1
        if non_local._i &lt; len(code):
            return code[non_local._i]
    while True:
        c = read()
        if not c:
            break  # end of code
        if c in ' ':
            if chars[-1] not in space_safe:
                chars.append(c)
        elif c in space_safe and chars[-1] == ' ':
            chars[-1] = c  # replace last char
        else:
            chars.append(c)
    chars.pop(0)
    return ''.join(chars)

</t>
<t tx="ekr.20181031045138.923">def remove_empty_lines(code):
    return '\n'.join([line for line in code.splitlines() if line])

</t>
<t tx="ekr.20181031045138.924">def remove_trailing_whitespace(code):
    return '\n'.join([line.rstrip() for line in code.splitlines()])

</t>
<t tx="ekr.20181031045138.925">def tabbify(code):
    lines = []
    for line in code.splitlines():
        line2 = line.lstrip(' \t')
        indent_str = line[:len(line)-len(line2)]
        for s1, s2 in [('    ', '\t'), ('  ', '\t'), (' ', '')]:
            indent_str = indent_str.replace(s1, s2)
        lines.append(indent_str + line2)
    return '\n'.join(lines)
</t>
<t tx="ekr.20181031045138.926">@path C:/Anaconda3/Lib/site-packages/flexx/util/
@others
if sys.platform.startswith('win'):

    import ctypes
    from ctypes import windll
    from ctypes.wintypes import (BOOL, DOUBLE, DWORD, HBITMAP, HDC, HGDIOBJ,  # noqa
                                 HWND, INT, LPARAM, LONG, UINT, WORD)  # noqa

    SRCCOPY = 13369376
    DIB_RGB_COLORS = BI_RGB = 0

    class RECT(ctypes.Structure):
        _fields_ = [('left', ctypes.c_long),
                    ('top', ctypes.c_long),
                    ('right', ctypes.c_long),
                    ('bottom', ctypes.c_long)]

    class BITMAPINFOHEADER(ctypes.Structure):
            _fields_ = [('biSize', DWORD), ('biWidth', LONG), ('biHeight', LONG),
                        ('biPlanes', WORD), ('biBitCount', WORD),
                        ('biCompression', DWORD), ('biSizeImage', DWORD),
                        ('biXPelsPerMeter', LONG), ('biYPelsPerMeter', LONG),
                        ('biClrUsed', DWORD), ('biClrImportant', DWORD)]

    class BITMAPINFO(ctypes.Structure):
        _fields_ = [('bmiHeader', BITMAPINFOHEADER), ('bmiColors', DWORD * 3)]

    # Function shorthands
    GetClientRect = windll.user32.GetClientRect
    GetWindowRect = windll.user32.GetWindowRect
    PrintWindow = windll.user32.PrintWindow
    GetWindowThreadProcessId = windll.user32.GetWindowThreadProcessId
    IsWindowVisible = windll.user32.IsWindowVisible
    EnumWindows = windll.user32.EnumWindows
    EnumWindowsProc = ctypes.WINFUNCTYPE(ctypes.c_bool,
                                         ctypes.POINTER(ctypes.c_int),
                                         ctypes.POINTER(ctypes.c_int))

    GetWindowDC = windll.user32.GetWindowDC
    CreateCompatibleDC = windll.gdi32.CreateCompatibleDC
    CreateCompatibleBitmap = windll.gdi32.CreateCompatibleBitmap
    SelectObject = windll.gdi32.SelectObject
    BitBlt = windll.gdi32.BitBlt
    DeleteObject = windll.gdi32.DeleteObject
    GetDIBits = windll.gdi32.GetDIBits

    # Arg types
    windll.user32.GetWindowDC.argtypes = [HWND]
    windll.gdi32.CreateCompatibleDC.argtypes = [HDC]
    windll.gdi32.CreateCompatibleBitmap.argtypes = [HDC, INT, INT]
    windll.gdi32.SelectObject.argtypes = [HDC, HGDIOBJ]
    windll.gdi32.BitBlt.argtypes = [HDC, INT, INT, INT, INT, HDC, INT, INT, DWORD]
    windll.gdi32.DeleteObject.argtypes = [HGDIOBJ]
    windll.gdi32.GetDIBits.argtypes = [HDC, HBITMAP, UINT, UINT, ctypes.c_void_p,
                                        ctypes.POINTER(BITMAPINFO), UINT]
    # Return types
    windll.user32.GetWindowDC.restypes = HDC
    windll.gdi32.CreateCompatibleDC.restypes = HDC
    windll.gdi32.CreateCompatibleBitmap.restypes = HBITMAP
    windll.gdi32.SelectObject.restypes = HGDIOBJ
    windll.gdi32.BitBlt.restypes = BOOL
    windll.gdi32.GetDIBits.restypes = INT
    windll.gdi32.DeleteObject.restypes = BOOL


    def win_for_pid(pid):
        """ Get the windows-handle for the first visible window of the
        process with the given id.
        """
        handles = []

        def called_for_each_win(hwnd, lParam):
            if not IsWindowVisible(hwnd):
                return True
            # get the proccessid from the windowhandle
            p_id = ctypes.c_int()
            #t_id = GetWindowThreadProcessId(hwnd, ctypes.byref(p_id))
            if p_id.value == pid:
                handles.append(hwnd)
                return False
            return True

        EnumWindows(EnumWindowsProc(called_for_each_win), 0)
        if handles:
            return handles[0]
        else:
            return None


    def screenshot(pid, client=True):
        """ Grab a screenshot of the first visible window of the process
        with the given id. If client is True, no Window decoration is shown.

        This code is derived from https://github.com/BoboTiG/python-mss
        """
        # Get handle
        hwnd = win_for_pid(pid)
        # Get window dimensions
        rect = RECT()
        if client:
            GetClientRect(hwnd, ctypes.byref(rect))
        else:
            GetWindowRect(hwnd, ctypes.byref(rect))
        left, right, top, bottom = rect.left, rect.right, rect.top, rect.bottom
        w, h = right - left, bottom - top

        hwndDC = saveDC = bmp = None
        try:
            # Get device contexts
            hwndDC = GetWindowDC(hwnd)
            saveDC = CreateCompatibleDC(hwndDC)
            # Get bitmap
            bmp = CreateCompatibleBitmap(hwndDC, w, h)
            SelectObject(saveDC, bmp)
            if client:
                PrintWindow(hwnd, saveDC, 1)  # todo: result is never used??
            else:
                PrintWindow(hwnd, saveDC, 0)
            # Init bitmap info
            # We grab the image in RGBX mode, so that each word is 32bit and
            # we have no striding, then we transform to RGB
            buffer_len = h * w * 4
            bmi = BITMAPINFO()
            bmi.bmiHeader.biSize = ctypes.sizeof(BITMAPINFOHEADER)
            bmi.bmiHeader.biWidth = w
            bmi.bmiHeader.biHeight = -h  # Why minus? See [1]
            bmi.bmiHeader.biPlanes = 1  # Always 1
            bmi.bmiHeader.biBitCount = 32
            bmi.bmiHeader.biCompression = BI_RGB
            # Blit
            image = ctypes.create_string_buffer(buffer_len)
            bits = windll.gdi32.GetDIBits(saveDC, bmp, 0, h, image, bmi, DIB_RGB_COLORS)
            assert bits == h
            # Replace pixels values: BGRX to RGB
            image2 = ctypes.create_string_buffer(h*w*3)
            image2[0::3] = image[2::4]
            image2[1::3] = image[1::4]
            image2[2::3] = image[0::4]

            return bytes(image2), (w, h, 3)

        finally:
            # Clean up
            if hwndDC:
                DeleteObject(hwndDC)
            if saveDC:
                DeleteObject(saveDC)
            if bmp:
                DeleteObject(bmp)


if __name__ == '__main__':
    im, shape = screenshot(5144, True)

    from flexx.util import icon
    png = icon.write_png(im, shape)
    open('C:\\Users\\Almar\\test.png', 'wb').write(png)
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.927">""" Make screenshots of windows on Windows and Linux.
We need this to do visual tests.
"""

import sys

</t>
<t tx="ekr.20181031045138.928">@path C:/Anaconda3/Lib/site-packages/flexx/util/
# -*- coding: utf-8 -*-
# Copyright (c) 2016, Almar Klein
# Distributed under the (new) BSD License.

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.929">"""
Functionality used for testing, based on pytest. This module is designed
to just work, without modification, in most projects.

Write your tests like this:

    from yourproject.xxx.testing import run_tests_if_main, raises, skipif
    ...
    run_tests_if_main()

Then you can run the test file as a script, which will run all tests
and report coverage. Magic!
"""


from __future__ import absolute_import, print_function, division

import os
import sys
import inspect

import pytest


PACKAGE_NAME = __name__.split('.')[0]

# Get project root dir
THIS_DIR = os.path.abspath(os.path.dirname(__file__))
ROOT_DIR = THIS_DIR
for i in range(9):
    ROOT_DIR = os.path.dirname(ROOT_DIR)
    if os.path.basename(ROOT_DIR) == PACKAGE_NAME:
        ROOT_DIR = os.path.dirname(ROOT_DIR)
        break
else:
    print('testing.py could not find project root dir, '
          'using testing.py directory instead.')
    ROOT_DIR = THIS_DIR


# Inject some function names so they can be obtained with one import
raises = pytest.raises
skipif = pytest.mark.skipif
skip = pytest.skip


</t>
<t tx="ekr.20181031045138.93">def get_mod_name(ob):
    """ Get the module name of an object (the name of a module object or
    the name of the module in which the object is defined). Our naming
    differs slighly from Python's in that the module in ``foo/bar/__init__.py``
    would be named ``foo.bar.__init__``, which simplifies dependency handling
    for Flexx. Note that such modules only occur if stuff is actually defined
    in them.
    """
    if not isinstance(ob, types.ModuleType):
        ob = sys.modules[ob.__module__]
    name = ob.__name__
    if module_is_package(ob):
        name += '.__init__'
    return name


</t>
<t tx="ekr.20181031045138.930">def run_tests_if_main(show_coverage=False):
    """ Run tests in a given file if it is run as a script

    Coverage is reported for running this single test. Set show_coverage to
    launch the report in the web browser.
    """
    local_vars = inspect.currentframe().f_back.f_locals
    if not local_vars.get('__name__', '') == '__main__':
        return
    # we are in a "__main__"
    os.chdir(ROOT_DIR)
    fname = str(local_vars['__file__'])
    _clear_our_modules()
    _enable_faulthandler()
    pytest.main(['-v', '-x', '--color=yes', '--cov', PACKAGE_NAME,
                 '--cov-config', '.coveragerc', '--cov-report', 'html', fname])
    if show_coverage:
        import webbrowser
        fname = os.path.join(ROOT_DIR, 'htmlcov', 'index.html')
        webbrowser.open_new_tab(fname)


</t>
<t tx="ekr.20181031045138.931">def _enable_faulthandler():
    """ Enable faulthandler (if we can), so that we get tracebacks
    on segfaults.
    """
    try:
        import faulthandler
        faulthandler.enable()
        print('Faulthandler enabled')
    except Exception:
        print('Could not enable faulthandler')


</t>
<t tx="ekr.20181031045138.932">def _clear_our_modules():
    """ Remove ourselves from sys.modules to force an import.
    """
    for key in list(sys.modules.keys()):
        if key.startswith(PACKAGE_NAME) and 'testing' not in key:
            del sys.modules[key]
</t>
<t tx="ekr.20181031045138.933">@path C:/Anaconda3/Lib/site-packages/flexx/util/
@language python
@tabwidth -4
</t>
<t tx="ekr.20181031045138.94">def module_is_package(module):
    """ Get whether the given module represents a package.
    """
    if hasattr(module, '__file__'):
        if module.__file__.rsplit('.', 1)[0].endswith('__init__'):
            return True
    return False


</t>
<t tx="ekr.20181031045138.95">def solve_dependencies(things, warn_missing=False):
    """ Given a list of things, which each have a ``name`` and ``deps``
    attribute, return a new list sorted to meet dependencies.
    """
    assert isinstance(things, (tuple, list))
    names = [thing.name for thing in things]
    thingmap = dict([(n, t) for n, t in zip(names, things)])

    for index in range(len(names)):
        seen_names = set()
        while True:
            # Get thing name on this position, check if its new
            name = names[index]
            if name in seen_names:
                raise RuntimeError('Detected circular dependency!')
            seen_names.add(name)
            # Move deps in front of us if necessary
            for dep in thingmap[name].deps:
                if dep not in names:
                    if warn_missing:
                        logger.warn('%r has missing dependency %r' % (name, dep))
                else:
                    j = names.index(dep)
                    if j &gt; index:
                        names.insert(index, names.pop(j))
                        break  # do this index again; the dep we just moved
            else:
                break  # no changes, move to next index
    return [thingmap[name] for name in names]

# todo: We could do (basic) minification of the JS
# but it will make the code less readable, so better do this after we've
# source maps.


</t>
<t tx="ekr.20181031045138.96">class Asset:
    """ Class to represent an asset (JS or CSS) to be included on the page.
    Users will typically use ``app.assets.add_shared_asset()``, see the
    corresponding docs for details.
    """

    _counter = 0

    @others
</t>
<t tx="ekr.20181031045138.97">def __init__(self, name, source=None):

    Asset._counter += 1  # so we can sort assets by their instantiation order
    self.i = Asset._counter

    # Handle name
    if not isinstance(name, str):
        raise TypeError('Asset name must be str.')
    if name.startswith(url_starts):
        if source is not None:
            raise TypeError('Remote assets cannot have a source: %s' % name)
        source = name
        name = name.replace('\\', '/').split('/')[-1]
    if not name.lower().endswith(('.js', '.css')):
        raise ValueError('Asset name must end in .js or .css.')
    self._name = name

    # Handle source
    self._remote = False
    self._source_str = None
    self._source = source
    if source is None:
        raise TypeError('Asset needs a source.')
    elif isinstance(source, str):
        if source.startswith(url_starts):
            self._remote = True
        elif source.startswith('file://'):
            raise TypeError('Cannot specify an asset using "file://", '
                            'use http or open the file and use contents.')
        else:
            self._source_str = source
    elif callable(source):
        pass
    else:
        raise TypeError('Asset source must be str or callable.')

</t>
<t tx="ekr.20181031045138.98">def __repr__(self):
    return '&lt;%s %r at 0x%0x&gt;' % (self.__class__.__name__, self._name, id(self))

</t>
<t tx="ekr.20181031045138.99">@property
def name(self):
    """ The (file) name of this asset.
    """
    return self._name

</t>
</tnodes>
</leo_file>
