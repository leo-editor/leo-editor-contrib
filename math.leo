<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20241212164559.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735803000000302e3271067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c7573752e"><vh>Startup</vh>
<v t="ekr.20241212164559.3" descendentVnodeUnknownAttributes="7d71002858010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735806000000302e31382e3071067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c7573752e"><vh>@settings</vh>
<v t="ekr.20241212164559.4"><vh>@bool allow-text-zoom = True</vh></v>
<v t="ekr.20241212164559.5"><vh>@bool check-python-code-on-write = True</vh></v>
<v t="ekr.20241212164559.7"><vh>@bool use-mouse-expand-gestures = False</vh></v>
<v t="ekr.20241212164559.8"><vh>@data exec-script-commands</vh></v>
<v t="ekr.20241212164559.9"><vh>@data exec-script-patterns</vh></v>
<v t="ekr.20241212164559.305"><vh>@data history-list</vh></v>
<v t="ekr.20241212164559.306"><vh>@string qt-layout-name = legacy</vh></v>
<v t="ekr.20241212164559.13"><vh>Abbreviation settings</vh>
<v t="ekr.20241212164559.14"><vh>@bool enable-abbreviations = True</vh></v>
<v t="ekr.20241212164559.15"><vh>@outline-data tree-abbreviations</vh>
<v t="ekr.20241212164559.16"><vh>@organizer 1</vh>
<v t="ekr.20241212164559.17"><vh>@organizer 2</vh>
<v t="ekr.20241212164559.18"><vh>demo;;</vh>
<v t="ekr.20241212164559.19"><vh>@@button MyDemo @key=Ctrl-9</vh>
<v t="ekr.20241212164559.20"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20241212164559.21"><vh>script_string</vh></v>
<v t="ekr.20241212164559.22"><vh>class myDemo</vh></v>
<v t="ekr.20241212164559.23"><vh>wrappers</vh></v>
</v>
</v>
</v>
<v t="ekr.20241212164559.24"><vh>per-commander-plugin;;</vh>
<v t="ekr.20241212164559.25"><vh>@@file pluginname.py</vh>
<v t="ekr.20241212164559.26"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20241212164559.27"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20241212164559.28"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20241212164559.29"><vh>init</vh></v>
<v t="ekr.20241212164559.30"><vh>onCreate</vh></v>
<v t="ekr.20241212164559.31"><vh>class pluginController</vh>
<v t="ekr.20241212164559.32"><vh>__init__</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20241212164559.33"><vh>importer;;</vh>
<v t="ekr.20241212164559.34"><vh>@@file importers/{|{x=name}|}.py</vh>
<v t="ekr.20241212164559.35"><vh>class {|{x=cap_name}|}_Importer</vh>
<v t="ekr.20241212164559.36"><vh>{|{x=name}|}.Overrides</vh>
<v t="ekr.20241212164559.37"><vh>{|{x=name}|}.clean_headline</vh></v>
<v t="ekr.20241212164559.38"><vh>{|{x=name}|}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20241212164559.39"><vh>class class {|{x=cap_name}|}_ScanState</vh>
<v t="ekr.20241212164559.40"><vh>{|{x=name}|}_state.level</vh></v>
<v t="ekr.20241212164559.41"><vh>{|{x=name}|}_state.update</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20241212164559.42"><vh>Appearance settings</vh>
<v t="ekr.20241212164559.43"><vh>@bool log-pane-wraps = False</vh></v>
<v t="ekr.20241212164559.44"><vh>@bool recent-files-group-always = True</vh></v>
<v t="ekr.20241212164559.45"><vh>@bool show-iconbar = True</vh></v>
<v t="ekr.20241212164559.46"><vh>@bool show-tips = False</vh></v>
<v t="ekr.20241212164559.47"><vh>@bool stayInTreeAfterSelect = True</vh></v>
<v t="ekr.20241212164559.48"><vh>@bool use-chapter-tabs = True</vh></v>
<v t="ekr.20241212164559.49"><vh>@bool use-chapters = True</vh></v>
<v t="ekr.20241212164559.50"><vh>@bool use-gutter = False</vh></v>
<v t="ekr.20241212164559.51"><vh>@int qweb-view-font-size = 30</vh></v>
<v t="ekr.20241212164559.52"><vh>@string initial-split-orientation = v</vh></v>
</v>
<v t="ekr.20241212164559.106"><vh>Chapters</vh>
<v t="ekr.20241212164559.107"><vh>@chapter 1</vh>
<v t="ekr.20241212164559.108"><vh>abc node 1</vh>
<v t="ekr.20241212164559.109"><vh>child</vh></v>
</v>
<v t="ekr.20241212164559.114"><vh>cloned node in chapter</vh></v>
</v>
<v t="ekr.20241212164559.111"><vh>@chapter 2</vh>
<v t="ekr.20241212164559.112"><vh>Chapter two</vh>
<v t="ekr.20241212164559.113"><vh>Second node</vh></v>
</v>
<v t="ekr.20241212164559.114"></v>
</v>
<v t="ekr.20241212164559.115"><vh>@chapter 3</vh></v>
<v t="ekr.20241212164559.116"><vh>@chapter ä¸— @key=Ctrl-1</vh></v>
</v>
<v t="ekr.20241212164559.117"><vh>Coloring settings</vh>
<v t="ekr.20241212164559.118"><vh>@bool color-doc-parts-as-rest = True</vh></v>
<v t="ekr.20241212164559.119"><vh>@bool use-pygments = False</vh></v>
<v t="ekr.20241212164559.120"><vh>@bool use-pygments-styles = False</vh></v>
<v t="ekr.20241212164559.121"><vh>@color head-bg = @mistyrose2</vh></v>
<v t="ekr.20241212164559.122"><vh>@string pygments-style-name = leonine</vh></v>
<v t="ekr.20241212164559.302"><vh>@string target-language = python</vh></v>
</v>
<v t="ekr.20241212164559.124"><vh>Command settings</vh>
<v t="ekr.20241212164559.125"><vh>@bool create-at-persistence-nodes-automatically = True</vh></v>
<v t="ekr.20241212164559.126"><vh>@bool enable-persistence = True</vh></v>
<v t="ekr.20241212164559.127"><vh>@bool make-node-conflicts-node = True</vh></v>
<v t="ekr.20241212164559.128"><vh>@bool run-pyflakes-on-write = True</vh></v>
<v t="ekr.20241212164559.129"><vh>@bool use-jedi = True</vh></v>
<v t="ekr.20241212164559.130"><vh>@bool use-qcompleter = False</vh></v>
<v t="ekr.20241212164559.131"><vh>@bool warn-about-redefined-shortcuts = True</vh></v>
<v t="ekr.20241212164559.132"><vh>@int auto-justify = 80</vh></v>
<v t="ekr.20241212164559.133"><vh>rst3 path options</vh>
<v t="ekr.20241212164559.134"><vh>@string rst3-write-intermediate-extension = .txt</vh></v>
<v t="ekr.20241212164559.135"><vh>@string rst3-default-path = None</vh></v>
<v t="ekr.20241212164559.136"><vh>@string rst3-stylesheet-name = default.css</vh></v>
<v t="ekr.20241212164559.137"><vh>@string rst3-stylesheet-path = None</vh></v>
<v t="ekr.20241212164559.138"><vh>@string rst3-publish-argv-for-missing-stylesheets = None</vh></v>
</v>
</v>
<v t="ekr.20241212164559.139"><vh>Declutter</vh>
<v t="ekr.20241212164559.300"><vh>@bool tree-declutter = False</vh></v>
<v t="ekr.20241212164559.141"><vh>@data tree-declutter-patterns</vh></v>
<v t="ekr.20241212164559.142"><vh>--- unused patterns</vh>
<v t="ekr.20241212164559.143"><vh> About Decluttering</vh>
<v t="ekr.20241212164559.144"><vh>Rule &amp; replacement lines</vh></v>
<v t="ekr.20241212164559.145"><vh>Style lines</vh></v>
</v>
<v t="ekr.20241212164559.146"><vh>declutter: add icon to folders and remove...</vh></v>
<v t="ekr.20241212164559.147"><vh>declutter: demo pattern</vh></v>
<v t="ekr.20241212164559.148"><vh>declutter: hide org-mode tags</vh></v>
<v t="ekr.20241212164559.149"><vh>declutter: replace @&lt;file&gt; with an icon</vh></v>
<v t="ekr.20241212164559.150"><vh>declutter: show last part of long filenames</vh></v>
</v>
</v>
<v t="ekr.20241212164559.151"><vh>Environment settings</vh>
<v t="ekr.20241212164559.152"><vh>@ifenv COMPUTERNAME, edreamleo-pc, other-pc</vh>
<v t="ekr.20241212164559.153"><vh>@bool computername = True</vh></v>
</v>
<v t="ekr.20241212164559.154"><vh>@ifenv xyzzy, abc</vh>
<v t="ekr.20241212164559.155"><vh>@bool xyzzy = True</vh></v>
</v>
<v t="ekr.20241212164559.156"><vh>@ifplatform win32,linux2</vh>
<v t="ekr.20241212164559.157"><vh>@string platform = not-mac</vh></v>
</v>
</v>
<v t="ekr.20241212164559.158"><vh>File settings</vh>
<v t="ekr.20241212164559.159"><vh>@bool open-with-clean-filenames = True</vh></v>
<v t="ekr.20241212164559.160"><vh>@bool check-for-changed-external-files = True</vh></v>
<v t="ekr.20241212164559.161"><vh>@bool open-with-save-on-update = False</vh></v>
<v t="ekr.20241212164559.162"><vh>@bool open-with-uses-derived-file-extensions = True</vh></v>
</v>
<v t="ekr.20241212164559.163"><vh>Find settings</vh>
<v t="ekr.20241212164559.164"><vh>@bool auto-scroll-find-tab = False</vh></v>
<v t="ekr.20241212164559.165"><vh>@bool close-find-dialog-after-search = False</vh></v>
<v t="ekr.20241212164559.166"><vh>@bool find-ignore-duplicates = False</vh></v>
<v t="ekr.20241212164559.167"><vh>@bool minibuffer-find-mode = True</vh></v>
<v t="ekr.20241212164559.168"><vh>@bool use-find-dialog = False</vh></v>
</v>
<v t="ekr.20241212164559.169"><vh>Importer settings</vh>
<v t="ekr.20241212164559.170"><vh>@data import-html-tags</vh></v>
<v t="ekr.20241212164559.171"><vh>@data import-xml-tags</vh></v>
</v>
<v t="ekr.20241212164559.172"><vh>make-stub-files settings</vh>
<v t="ekr.20241212164559.173"><vh>@bool stub-overwrite = True</vh></v>
<v t="ekr.20241212164559.174"><vh>@bool stub-trace-matches = False</vh></v>
<v t="ekr.20241212164559.175"><vh>@bool stub-trace-patterns = False</vh></v>
<v t="ekr.20241212164559.176"><vh>@bool stub-trace-reduce = False</vh></v>
<v t="ekr.20241212164559.177"><vh>@bool stub-trace-visitors = False</vh></v>
<v t="ekr.20241212164559.178"><vh>@bool stub-update = False</vh></v>
<v t="ekr.20241212164559.179"><vh>@data stub-def-name-patterns</vh></v>
<v t="ekr.20241212164559.180"><vh>@data stub-general-patterns</vh></v>
<v t="ekr.20241212164559.181"><vh>@data stub-prefix-lines</vh></v>
<v t="ekr.20241212164559.182"><vh>@string stub-output-directory = ~/stubs</vh></v>
</v>
<v t="ekr.20241212164559.183" descendentVnodeUnknownAttributes="7d71005803000000302e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d333071077573732e"><vh>Plugins (one of these is essential)</vh>
<v t="ekr.20241212164559.307" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d333071077573732e"><vh>@enabled-plugins</vh></v>
<v t="ekr.20241212164559.185"><vh>@@bool scripting-at-plugin-nodes = True</vh></v>
<v t="ekr.20241212164559.186"><vh>mod_http settings</vh>
<v t="ekr.20241212164559.187"><vh>@bool http-active = True</vh></v>
<v t="ekr.20241212164559.188"><vh>@int port = 8080</vh></v>
<v t="ekr.20241212164559.189"><vh>@string rst-http-attributename = 'rst_http_attribute'</vh></v>
</v>
<v t="ekr.20241212164559.190"><vh>viewrendered settings</vh>
<v t="ekr.20241212164559.191"><vh>@bool view-rendered-auto-create = False</vh></v>
<v t="ekr.20241212164559.192"><vh>@bool view-rendered-auto-hide = False</vh></v>
<v t="ekr.20241212164559.193"><vh>@string view-rendered-default-kind = rst</vh></v>
</v>
<v t="ekr.20241212164559.194"><vh>wikiview plugin</vh>
<v t="ekr.20241212164559.195"><vh>@data wikiview-link-patterns</vh></v>
<v t="ekr.20241212164559.196"><vh>@bool wikiview-active = True</vh></v>
</v>
</v>
<v t="ekr.20241212164559.197"><vh>Scintilla settings</vh>
<v t="ekr.20241212164559.299"><vh>@bool qt-use-scintilla = False</vh></v>
</v>
<v t="ekr.20241212164559.199"><vh>Sphinx settings</vh>
<v t="ekr.20241212164559.200"><vh>@string sphinx-command-directory = </vh></v>
<v t="ekr.20241212164559.201"><vh>@string sphinx-default-command = make html</vh></v>
<v t="ekr.20241212164559.202"><vh>@string sphinx-input-directory = None</vh></v>
<v t="ekr.20241212164559.203"><vh>@string sphinx-output-directory = None</vh></v>
</v>
<v t="ekr.20241212164559.204"><vh>Syntax coloring settings</vh>
<v t="ekr.20241212164559.205"><vh>@@color rest.keyword2 = red</vh></v>
<v t="ekr.20241212164559.206"><vh>@@color rest.keyword4 = blue</vh></v>
<v t="ekr.20241212164559.207"><vh>@@color rest.leokeyword = green</vh></v>
<v t="ekr.20241212164559.208"><vh>@color forth.keyword3 = black</vh></v>
<v t="ekr.20241212164559.209"><vh>@color python.name = @solarized-yellow</vh></v>
<v t="ekr.20241212164559.210"><vh>@font rest.comment1</vh></v>
</v>
<v t="ekr.20241212164559.211"><vh>Vim mode</vh>
<v t="ekr.20241212164559.212"><vh>@string vim-mode-normal-border = border: 3px solid #268bd2</vh></v>
<v t="ekr.20241212164559.213"><vh>@string vim-mode-insert-border = border: 3px solid #dc322f</vh></v>
<v t="ekr.20241212164559.214"><vh>@string vim-mode-visual-border = border: 3px solid gray</vh></v>
<v t="ekr.20241212164559.215"><vh>@string vim-mode-unfocused-border = border: 3px dashed #268bd2</vh></v>
<v t="ekr.20241212164559.216"><vh>@bool vim-mode = False</vh></v>
</v>
</v>
<v t="ekr.20241212164559.305"></v>
<v t="ekr.20241212164559.307" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d333071077573732e"></v>
</v>
<v t="ekr.20241213035513.1"><vh>Read me</vh></v>
<v t="ekr.20241212164526.17"><vh>@button import-ipynb</vh></v>
<v t="ekr.20241212164526.14"><vh>@button exec-py-file</vh></v>
<v t="ekr.20241213022535.1"><vh>--- Converted ipynb files</vh>
<v t="ekr.20241212164526.16"><vh>pyflakes warnings</vh></v>
<v t="ekr.20241213022535.2"><vh>CH01</vh>
<v t="ekr.20241213022535.3"><vh># @file CH01\CH01_SEC02.py</vh>
<v t="ekr.20241213022535.5"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241213022535.6"><vh>plt.rcParams['figure.figsize'] = [16, 8]</vh></v>
<v t="ekr.20241213022535.7"><vh>U, S, VT =</vh></v>
<v t="ekr.20241213022535.8"><vh>plt.figure(1)</vh></v>
</v>
<v t="ekr.20241213022535.9"><vh># @file CH01\CH01_SEC03_Rotation.py</vh>
<v t="ekr.20241213022535.11"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.12"><vh>Plot sphere</vh></v>
<v t="ekr.20241213022535.13"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.14"><vh># @file CH01\CH01_SEC04_1_Linear.py</vh>
<v t="ekr.20241213022535.16"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.17"><vh>Three methods of computing regression</vh></v>
</v>
<v t="ekr.20241213022535.18"><vh># @file CH01\CH01_SEC04_2_Cement.py</vh>
<v t="ekr.20241213022535.20"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.21"><vh>Alternative Methods:</vh></v>
<v t="ekr.20241213022535.22"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.23"><vh># @file CH01\CH01_SEC04_3_Housing.py</vh>
<v t="ekr.20241213022535.25"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.26"><vh>A_mean = np.mean(A,axis=0)</vh></v>
</v>
<v t="ekr.20241213022535.27"><vh># @file CH01\CH01_SEC05_1_PCAGaussian.py</vh>
<v t="ekr.20241213022535.29"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.30"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241213022535.31"><vh># @file CH01\CH01_SEC05_2_OvarianCancer.py</vh>
<v t="ekr.20241213022535.33"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.34"><vh>fig2 = plt.figure()</vh></v>
</v>
<v t="ekr.20241213022535.35"><vh># @file CH01\CH01_SEC06_1.py</vh>
<v t="ekr.20241213022535.37"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.38"><vh>for person in range(len(nfaces)):</vh></v>
</v>
<v t="ekr.20241213022535.39"><vh># @file CH01\CH01_SEC06_2_3_4.py</vh>
<v t="ekr.20241213022535.41"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.42"><vh># Now show eigenface reconstruction of</vh></v>
<v t="ekr.20241213022535.43"><vh># Project person 2 and 7 onto PC5 and</vh></v>
<v t="ekr.20241213022535.44"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241213022535.45"><vh># @file CH01\CH01_SEC07_1.py</vh>
<v t="ekr.20241213022535.47"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.48"><vh>sigma = 1</vh></v>
<v t="ekr.20241213022535.49"><vh>U, S, VT =</vh></v>
<v t="ekr.20241213022535.50"><vh>Cumulative energy</vh></v>
<v t="ekr.20241213022535.51"><vh># Plot Singular Values</vh></v>
<v t="ekr.20241213022535.52"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022535.53"><vh># @file CH01\CH01_SEC07_2.py</vh>
<v t="ekr.20241213022535.55"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.56"><vh>X_rot = skimage.transform.rotate(X,10)</vh></v>
<v t="ekr.20241213022535.57"><vh>U, S, VT =</vh></v>
<v t="ekr.20241213022535.58"><vh>U_rot, S_rot, VT_rot =</vh></v>
<v t="ekr.20241213022535.59"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022535.60"><vh># @file CH01\CH01_SEC07_3.py</vh>
<v t="ekr.20241213022535.62"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.63"><vh>Xrot = X</vh></v>
<v t="ekr.20241213022535.64"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.65"><vh># @file CH01\CH01_SEC08_RSVD.py</vh>
<v t="ekr.20241213022535.67"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.68"><vh>A = imread(os.path.join('..','DATA','jup</vh></v>
<v t="ekr.20241213022535.69"><vh># Reconstruction</vh></v>
<v t="ekr.20241213022535.70"><vh># Plot</vh></v>
<v t="ekr.20241213022535.71"><vh># Illustrate power iterations</vh></v>
<v t="ekr.20241213022535.72"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022535.73"><vh># @file CH01\CH01_SEC09_Tensor.py</vh>
<v t="ekr.20241213022535.75"><vh>import matplotlib.pyplot as plt</vh></v>
<v t="ekr.20241213022535.76"><vh>plt.rcParams['figure.figsize'] = [16,10]</vh></v>
<v t="ekr.20241213022535.77"><vh>Tensor factorization method requires the</vh></v>
<v t="ekr.20241213022535.78"><vh>Cell 4</vh></v>
<v t="ekr.20241213022535.79"><vh>Cell 5</vh></v>
</v>
</v>
<v t="ekr.20241213022535.80"><vh>CH02</vh>
<v t="ekr.20241213022535.81"><vh># @file CH02\CH02_SEC01_0_InnerProduct.py</vh>
<v t="ekr.20241213022535.83"><vh>import numpy as np</vh></v>
</v>
<v t="ekr.20241213022535.84"><vh># @file CH02\CH02_SEC01_1_FourierSines.py</vh>
<v t="ekr.20241213022535.86"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.87"><vh># Plot amplitudes</vh></v>
<v t="ekr.20241213022535.88"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.89"><vh># @file CH02\CH02_SEC01_2_Gibbs.py</vh>
<v t="ekr.20241213022535.91"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.92"><vh>Cell 2</vh></v>
<v t="ekr.20241213022535.93"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.94"><vh># @file CH02\CH02_SEC01_2_Gibbs_Movie.py</vh>
<v t="ekr.20241213022535.96"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.97"><vh>Cell 2</vh></v>
<v t="ekr.20241213022535.98"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.99"><vh># @file CH02\CH02_SEC02_1_DFT.py</vh>
<v t="ekr.20241213022535.101"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.102"><vh>DFT = np.zeros((n,n))</vh></v>
<v t="ekr.20241213022535.103"><vh>Fast</vh></v>
<v t="ekr.20241213022535.104"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241213022535.105"><vh># @file CH02\CH02_SEC02_2_Denoise.py</vh>
<v t="ekr.20241213022535.107"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.108"><vh># Compute the Fast Fourier Transform</vh></v>
<v t="ekr.20241213022535.109"><vh># Use the PSD to filter out noise</vh></v>
<v t="ekr.20241213022535.110"><vh># Plots</vh></v>
</v>
<v t="ekr.20241213022535.111"><vh># @file CH02\CH02_SEC02_3_SpectralDerivative.py</vh>
<v t="ekr.20241213022535.113"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.114"><vh># Approximate derivative using finite</vh></v>
<v t="ekr.20241213022535.115"><vh># Derivative using FFT (spectral</vh></v>
<v t="ekr.20241213022535.116"><vh># Plots</vh></v>
<v t="ekr.20241213022535.117"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022535.118"><vh># @file CH02\CH02_SEC03_1_FFTHeat.py</vh>
<v t="ekr.20241213022535.120"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.121"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241213022535.122"><vh># @file CH02\CH02_SEC03_2_FFTWave.py</vh>
<v t="ekr.20241213022535.124"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.125"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241213022535.126"><vh># @file CH02\CH02_SEC03_3_FFTBurgers.py</vh>
<v t="ekr.20241213022535.128"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.129"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241213022535.130"><vh># @file CH02\CH02_SEC04_1_SpectrogramChirp.py</vh>
<v t="ekr.20241213022535.132"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.133"><vh>Cell 2</vh></v>
<v t="ekr.20241213022535.134"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.135"><vh># @file CH02\CH02_SEC05_HAAR.py</vh>
<v t="ekr.20241213022535.137"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022535.138"><vh>x = np.arange(-5,5,0.001)</vh></v>
<v t="ekr.20241213022535.139"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.140"><vh># @file CH02\CH02_SEC06_1_2DFFT.py</vh>
<v t="ekr.20241213022535.142"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241213022535.143"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241213022535.144"><vh># @file CH02\CH02_SEC06_2_Compress.py</vh>
<v t="ekr.20241213022535.146"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241213022535.147"><vh>Cell 2</vh></v>
<v t="ekr.20241213022535.148"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022535.149"><vh># @file CH02\CH02_SEC06_3_Denoise.py</vh>
<v t="ekr.20241213022535.151"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241213022535.152"><vh># Denoise</vh></v>
</v>
<v t="ekr.20241213022535.153"><vh># @file CH02\CH02_SEC06_4_Wavelet.py</vh>
<v t="ekr.20241213022535.155"><vh>Using the PyWavelets module, available</vh></v>
<v t="ekr.20241213022535.156"><vh># Wavelet decomposition (2 level)</vh></v>
</v>
<v t="ekr.20241213022535.157"><vh># @file CH02\CH02_SEC06_5_WaveletCompress.py</vh>
<v t="ekr.20241213022535.159"><vh>Using the PyWavelets module, available</vh></v>
<v t="ekr.20241213022535.160"><vh># Wavelet Compression</vh></v>
</v>
</v>
<v t="ekr.20241213022535.161"><vh>CH03</vh>
<v t="ekr.20241213022535.162"><vh># @file CH03\CH03_SEC01_Compress.py</vh>
<v t="ekr.20241213022535.164"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241213022535.165"><vh># Compute FFT of image using fft2</vh></v>
<v t="ekr.20241213022535.166"><vh># Zero out all small coefficients and</vh></v>
<v t="ekr.20241213022535.167"><vh># Plot Reconstruction</vh></v>
<v t="ekr.20241213022535.168"><vh>plt.rcParams['figure.figsize'] = [16, 8]</vh></v>
<v t="ekr.20241213022535.169"><vh>Cell 6</vh></v>
<v t="ekr.20241213022535.170"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241213022536.1"><vh># @file CH03\CH03_SEC03_1_Underdetermined.py</vh>
<v t="ekr.20241213022536.3"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.4"><vh>L2 Minimum norm solution s_L2</vh></v>
<v t="ekr.20241213022536.5"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241213022536.6"><vh>Cell 4</vh></v>
<v t="ekr.20241213022536.7"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022536.8"><vh># @file CH03\CH03_SEC03_2_AudioCS.py</vh>
<v t="ekr.20241213022536.10"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.11"><vh># Generate signal, DCT of signal</vh></v>
<v t="ekr.20241213022536.12"><vh># Randomly sample signal</vh></v>
<v t="ekr.20241213022536.13"><vh># Solve compressed sensing problem</vh></v>
<v t="ekr.20241213022536.14"><vh># Plot</vh></v>
<v t="ekr.20241213022536.15"><vh># L1-Minimization using SciPy</vh></v>
<v t="ekr.20241213022536.16"><vh>Theta.shape</vh></v>
<v t="ekr.20241213022536.17"><vh>y.shape</vh></v>
<v t="ekr.20241213022536.18"><vh>Cell 9</vh></v>
</v>
<v t="ekr.20241213022536.19"><vh># @file CH03\CH03_SEC04_Matrices.py</vh>
<v t="ekr.20241213022536.21"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.22"><vh># Plot Psi</vh></v>
<v t="ekr.20241213022536.23"><vh># Plot C</vh></v>
<v t="ekr.20241213022536.24"><vh># Plot Theta</vh></v>
<v t="ekr.20241213022536.25"><vh># Plot s, y</vh></v>
<v t="ekr.20241213022536.26"><vh># L1-Minimization using SciPy</vh></v>
<v t="ekr.20241213022536.27"><vh># Plot C and Theta (2) - Gaussian Random</vh></v>
<v t="ekr.20241213022536.28"><vh>Plot C and Theta (3) - Bernoulli Random</vh></v>
<v t="ekr.20241213022536.29"><vh>Plot C and Theta (4) - Sparse Bernoulli</vh></v>
<v t="ekr.20241213022536.30"><vh>Bad C and Theta (5) - DCT Meas</vh></v>
<v t="ekr.20241213022536.31"><vh>Cell 11</vh></v>
<v t="ekr.20241213022536.32"><vh>Cell 12</vh></v>
<v t="ekr.20241213022536.33"><vh>Cell 13</vh></v>
</v>
<v t="ekr.20241213022536.34"><vh># @file CH03\CH03_SEC05_1_RobustRegression.py</vh>
<v t="ekr.20241213022536.36"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.37"><vh>Random data from [-2,2]</vh></v>
<v t="ekr.20241213022536.38"><vh># L1 optimization to reject outlier</vh></v>
<v t="ekr.20241213022536.39"><vh>Data</vh></v>
<v t="ekr.20241213022536.40"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022536.41"><vh># @file CH03\CH03_SEC05_2_LASSO.py</vh>
<v t="ekr.20241213022536.43"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.44"><vh>Matrix of possible predictors</vh></v>
<v t="ekr.20241213022536.45"><vh>reg = linear_model.LassoCV(cv=10).fit(A,</vh></v>
<v t="ekr.20241213022536.46"><vh>XL1 = linear_model.Lasso(alpha=clf.best_</vh></v>
<v t="ekr.20241213022536.47"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022536.48"><vh># @file CH03\CH03_SEC06_SparseRepresentation.py</vh>
<v t="ekr.20241213022536.50"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.51"><vh># Build Training and Test sets</vh></v>
<v t="ekr.20241213022536.52"><vh># Downsample Training Images (Build</vh></v>
<v t="ekr.20241213022536.53"><vh># Renormalize Columns of Theta</vh></v>
<v t="ekr.20241213022536.54"><vh># Occlude Test Image (Test[:,125] = test</vh></v>
<v t="ekr.20241213022536.55"><vh># Downsample Test Images</vh></v>
<v t="ekr.20241213022536.56"><vh># L1 Search, Testclean</vh></v>
<v t="ekr.20241213022536.57"><vh>plt.figure()</vh></v>
<v t="ekr.20241213022536.58"><vh># L1 Search, Mustache</vh></v>
<v t="ekr.20241213022536.59"><vh>plt.figure()</vh></v>
<v t="ekr.20241213022536.60"><vh># L1 Search, Occlusion</vh></v>
<v t="ekr.20241213022536.61"><vh>plt.figure()</vh></v>
<v t="ekr.20241213022536.62"><vh># L1 Search, Noise</vh></v>
<v t="ekr.20241213022536.63"><vh>plt.figure()</vh></v>
<v t="ekr.20241213022536.64"><vh># Least Squares Is No Good</vh></v>
<v t="ekr.20241213022536.65"><vh>Cell 16</vh></v>
<v t="ekr.20241213022536.66"><vh>Cell 17</vh></v>
</v>
<v t="ekr.20241213022536.67"><vh># @file CH03\CH03_SEC07_RPCA.py</vh>
<v t="ekr.20241213022536.69"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.70"><vh># Function Definitions</vh></v>
<v t="ekr.20241213022536.71"><vh>X = faces[:,:nfaces[0]]</vh></v>
<v t="ekr.20241213022536.72"><vh>inds = (3,4,14,15,17,18,19,20,21,32,43)</vh></v>
<v t="ekr.20241213022536.73"><vh>Cell 5</vh></v>
<v t="ekr.20241213022536.74"><vh>Cell 6</vh></v>
</v>
</v>
<v t="ekr.20241213022536.75"><vh>CH04</vh>
<v t="ekr.20241213022536.76"><vh># @file CH04\CH04_SEC01_LinearRegression.py</vh>
<v t="ekr.20241213022536.78"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.79"><vh>The data</vh></v>
<v t="ekr.20241213022536.80"><vh>x = np.arange(1,11)</vh></v>
<v t="ekr.20241213022536.81"><vh>Cell 4</vh></v>
<v t="ekr.20241213022536.82"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022536.83"><vh># @file CH04\CH04_SEC02_1_GradientDescent.py</vh>
<v t="ekr.20241213022536.85"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.86"><vh>h = 0.5</vh></v>
<v t="ekr.20241213022536.87"><vh>rcParams['figure.figsize'] = [16, 8]</vh></v>
<v t="ekr.20241213022536.88"><vh>rcParams['figure.figsize'] = [16, 16]</vh></v>
<v t="ekr.20241213022536.89"><vh># Gradient Descent</vh></v>
<v t="ekr.20241213022536.90"><vh>fig,ax = plt.subplots(1,1,subplot_kw={'p</vh></v>
<v t="ekr.20241213022536.91"><vh># Computing the gradient descent with</vh></v>
<v t="ekr.20241213022536.92"><vh>rcParams['figure.figsize'] = [12, 8]</vh></v>
<v t="ekr.20241213022536.93"><vh>fig,ax = plt.subplots(1,1,subplot_kw={'p</vh></v>
<v t="ekr.20241213022536.94"><vh># Alternating Descent</vh></v>
<v t="ekr.20241213022536.95"><vh>rcParams['figure.figsize'] = [12, 8]</vh></v>
<v t="ekr.20241213022536.96"><vh>fig,ax = plt.subplots(1,1,subplot_kw={'p</vh></v>
<v t="ekr.20241213022536.97"><vh>Cell 13</vh></v>
</v>
<v t="ekr.20241213022536.98"><vh># @file CH04\CH04_SEC03_1_OverUnderDetermined.py</vh>
<v t="ekr.20241213022536.100"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.101"><vh>Underdetermined</vh></v>
<v t="ekr.20241213022536.102"><vh>plt.rcParams['figure.figsize'] = [12, 8]</vh></v>
<v t="ekr.20241213022536.103"><vh>Overdetermined</vh></v>
<v t="ekr.20241213022536.104"><vh># Matrix Overdetermined System</vh></v>
<v t="ekr.20241213022536.105"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022536.106"><vh># @file CH04\CH04_SEC04_1_CompareRegression.py</vh>
<v t="ekr.20241213022536.108"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.109"><vh>n = 100</vh></v>
<v t="ekr.20241213022536.110"><vh># Different regressions</vh></v>
<v t="ekr.20241213022536.111"><vh>plt.rcParams['figure.figsize'] = [12,</vh></v>
<v t="ekr.20241213022536.112"><vh>M = 10</vh></v>
<v t="ekr.20241213022536.113"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022536.114"><vh># @file CH04\CH04_SEC05_0_Fig4p16_Pareto.py</vh>
<v t="ekr.20241213022536.116"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.117"><vh>fig,ax = plt.subplots(1)</vh></v>
<v t="ekr.20241213022536.118"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022536.119"><vh># @file CH04\CH04_SEC05_1_CrossValidate.py</vh>
<v t="ekr.20241213022536.121"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.122"><vh>n = 200</vh></v>
<v t="ekr.20241213022536.123"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241213022536.124"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241213022536.125"><vh># @file CH04\CH04_SEC06_1_kFoldValidation.py</vh>
<v t="ekr.20241213022536.127"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.128"><vh>n = 100</vh></v>
<v t="ekr.20241213022536.129"><vh>plt.rcParams['figure.figsize'] = [8,8]</vh></v>
<v t="ekr.20241213022536.130"><vh>n = 200</vh></v>
<v t="ekr.20241213022536.131"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022536.132"><vh># @file CH04\CH04_SEC07_1_ModelValidation.py</vh>
<v t="ekr.20241213022536.134"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.135"><vh>n = 10000</vh></v>
<v t="ekr.20241213022536.136"><vh>generate PDFs</vh></v>
<v t="ekr.20241213022536.137"><vh>Compute integrand</vh></v>
<v t="ekr.20241213022536.138"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022536.139"><vh># @file CH04\CH04_SEC07_2_RegressAIC_BIC.py</vh>
<v t="ekr.20241213022536.141"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.142"><vh>for random data reproducibility</vh></v>
<v t="ekr.20241213022536.143"><vh>Cell 3</vh></v>
</v>
</v>
<v t="ekr.20241213022536.144"><vh>CH05</vh>
<v t="ekr.20241213022536.145"><vh># @file CH05\CH05_SEC01_1_FischerExtraction.py</vh>
<v t="ekr.20241213022536.147"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.148"><vh>fisheriris_mat = io.loadmat(os.path.join</vh></v>
<v t="ekr.20241213022536.149"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241213022536.150"><vh>dogdata_mat = io.loadmat(os.path.join('.</vh></v>
<v t="ekr.20241213022536.151"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241213022536.152"><vh>fig,axs = plt.subplots(4,1)</vh></v>
<v t="ekr.20241213022536.153"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241213022536.154"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241213022536.155"><vh>fig,axs = plt.subplots(4,1)</vh></v>
<v t="ekr.20241213022536.156"><vh>xbin = np.linspace(-0.25,0.25,20)</vh></v>
<v t="ekr.20241213022536.157"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241213022536.158"><vh>master = np.zeros((32*5,32*4))</vh></v>
<v t="ekr.20241213022536.159"><vh>master = np.zeros((32*5,32*4))</vh></v>
<v t="ekr.20241213022536.160"><vh>Cell 14</vh></v>
</v>
<v t="ekr.20241213022536.161"><vh># @file CH05\CH05_SEC02_1_Fig5p7_Fig5p8.py</vh>
<v t="ekr.20241213022536.163"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.164"><vh>Training and test set sizes</vh></v>
<v t="ekr.20241213022536.165"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241213022536.166"><vh>training set size</vh></v>
<v t="ekr.20241213022536.167"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022536.168"><vh># @file CH05\CH05_SEC03_1_Kmeans.py</vh>
<v t="ekr.20241213022536.170"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.171"><vh>Training and testing set sizes</vh></v>
<v t="ekr.20241213022536.172"><vh>plt.figure()</vh></v>
<v t="ekr.20241213022536.173"><vh>Training set: first 200 of 240 points</vh></v>
<v t="ekr.20241213022536.174"><vh>Initial guess</vh></v>
<v t="ekr.20241213022536.175"><vh>kmeans code</vh></v>
<v t="ekr.20241213022536.176"><vh>midx = (c[0,0]+c[1,0])/2</vh></v>
<v t="ekr.20241213022536.177"><vh># Dendrograms</vh></v>
<v t="ekr.20241213022536.178"><vh>plt.bar(range(100),dn['leaves'])</vh></v>
<v t="ekr.20241213022536.179"><vh>Cell 10</vh></v>
</v>
<v t="ekr.20241213022536.180"><vh># @file CH05\CH05_SEC04_1_Dendrogram.py</vh>
<v t="ekr.20241213022536.182"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.183"><vh>Training and testing set sizes</vh></v>
<v t="ekr.20241213022536.184"><vh>plt.figure()</vh></v>
<v t="ekr.20241213022536.185"><vh>Training set: first 200 of 240 points</vh></v>
<v t="ekr.20241213022536.186"><vh># Dendrograms</vh></v>
<v t="ekr.20241213022536.187"><vh>plt.bar(range(100),dn['leaves'])</vh></v>
<v t="ekr.20241213022536.188"><vh>thresh = 0.25*np.max(Z[:,2])</vh></v>
<v t="ekr.20241213022536.189"><vh>Cell 8</vh></v>
<v t="ekr.20241213022536.190"><vh>Cell 9</vh></v>
</v>
<v t="ekr.20241213022536.191"><vh># @file CH05\CH05_SEC05_1_GaussianMixtureModels.py</vh>
<v t="ekr.20241213022536.193"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.194"><vh>dogdata_w_mat = io.loadmat(os.path.join(</vh></v>
<v t="ekr.20241213022536.195"><vh>dogcat = v[:,(1,3)]</vh></v>
<v t="ekr.20241213022536.196"><vh>ax = plt.axes(projection='3d')</vh></v>
<v t="ekr.20241213022536.197"><vh># AIC Scores</vh></v>
<v t="ekr.20241213022536.198"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022536.199"><vh># @file CH05\CH05_SEC06_1_LDA_Classify.py</vh>
<v t="ekr.20241213022536.201"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.202"><vh>dogdata_w_mat = io.loadmat(os.path.join(</vh></v>
<v t="ekr.20241213022536.203"><vh>xtrain = np.concatenate((v[:60,np.array(</vh></v>
<v t="ekr.20241213022536.204"><vh>plt.rcParams['figure.figsize'] = [8,4]</vh></v>
<v t="ekr.20241213022536.205"><vh>dogdata_mat = io.loadmat(os.path.join('.</vh></v>
<v t="ekr.20241213022536.206"><vh>plt.rcParams['figure.figsize'] = [12,</vh></v>
<v t="ekr.20241213022536.207"><vh># Cross-validate</vh></v>
<v t="ekr.20241213022536.208"><vh>dogdata_w_mat = io.loadmat(os.path.join(</vh></v>
<v t="ekr.20241213022536.209"><vh>plt.rcParams['figure.figsize'] = [12, 6]</vh></v>
<v t="ekr.20241213022536.210"><vh>Cell 10</vh></v>
</v>
<v t="ekr.20241213022536.211"><vh># @file CH05\CH05_SEC07_1_SVM.py</vh>
<v t="ekr.20241213022536.213"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.214"><vh>Random ellipse 1</vh></v>
<v t="ekr.20241213022536.215"><vh>z1 = np.power(x1,2) * y1</vh></v>
<v t="ekr.20241213022536.216"><vh>r = 7 + np.random.randn(n1)</vh></v>
<v t="ekr.20241213022536.217"><vh>Classify dogs vs. cats</vh></v>
<v t="ekr.20241213022536.218"><vh>features = np.arange(1,21)</vh></v>
<v t="ekr.20241213022536.219"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241213022536.220"><vh># @file CH05\CH05_SEC08_1_Trees.py</vh>
<v t="ekr.20241213022536.222"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.223"><vh>fisheriris_mat = io.loadmat(os.path.join</vh></v>
<v t="ekr.20241213022536.224"><vh>setosa</vh></v>
<v t="ekr.20241213022536.225"><vh>dogs vs. cats</vh></v>
<v t="ekr.20241213022536.226"><vh># Census Data</vh></v>
<v t="ekr.20241213022536.227"><vh># Splitting Procedure</vh></v>
<v t="ekr.20241213022536.228"><vh>plt.plot(x1[:,0],x1[:,1],'o',markerfacec</vh></v>
<v t="ekr.20241213022536.229"><vh>Cell 8</vh></v>
</v>
</v>
<v t="ekr.20241213022536.230"><vh>CH06</vh>
<v t="ekr.20241213022536.231"><vh># @file CH06\CH06_SEC01_1_NN.py</vh>
<v t="ekr.20241213022536.233"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.234"><vh>dogs vs. cats</vh></v>
<v t="ekr.20241213022536.235"><vh>lasso =</vh></v>
<v t="ekr.20241213022536.236"><vh>fig,axs = plt.subplots(4,1)</vh></v>
<v t="ekr.20241213022536.237"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241213022536.238"><vh># To be implemented: Python version of</vh></v>
<v t="ekr.20241213022536.239"><vh>Cell 7</vh></v>
<v t="ekr.20241213022536.240"><vh>Cell 8</vh></v>
</v>
<v t="ekr.20241213022536.241"><vh># @file CH06\CH06_SEC04_1_StochasticGradientDescent.py</vh>
<v t="ekr.20241213022536.243"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022536.244"><vh>iterMax = 100</vh></v>
<v t="ekr.20241213022536.245"><vh>plt.figure()</vh></v>
<v t="ekr.20241213022536.246"><vh>fig,ax = plt.subplots(1,1,subplot_kw={'p</vh></v>
<v t="ekr.20241213022536.247"><vh>Cell 5</vh></v>
<v t="ekr.20241213022536.248"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022537.1"><vh># @file CH06\CH06_SEC05_1_DeepCNN.py</vh>
<v t="ekr.20241213022537.3"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.4"><vh>letters_train_mat = io.loadmat(os.path.j</vh></v>
<v t="ekr.20241213022537.5"><vh>classes = np.unique(TTrain)</vh></v>
<v t="ekr.20241213022537.6"><vh>create model</vh></v>
<v t="ekr.20241213022537.7"><vh>YPredict =</vh></v>
<v t="ekr.20241213022537.8"><vh>Cell 6</vh></v>
<v t="ekr.20241213022537.9"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241213022537.10"><vh># @file CH06\CH06_SEC06_1_NNLorenz.py</vh>
<v t="ekr.20241213022537.12"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.13"><vh># Simulate the Lorenz System</vh></v>
<v t="ekr.20241213022537.14"><vh># Neural Net</vh></v>
<v t="ekr.20241213022537.15"><vh>nn_input.shape</vh></v>
<v t="ekr.20241213022537.16"><vh>Cell 5</vh></v>
</v>
</v>
<v t="ekr.20241213022537.17"><vh>CH07</vh>
<v t="ekr.20241213022537.18"><vh># @file CH07\CH07_SEC01_SimulateLogistic.py</vh>
<v t="ekr.20241213022537.20"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.21"><vh>startval = 1</vh></v>
<v t="ekr.20241213022537.22"><vh>plt.plot(xvals[1,:],xvals[0,:],'.',ms=0.</vh></v>
<v t="ekr.20241213022537.23"><vh>plt.plot(xvals[1,:],xvals[0,:],'.',ms=0.</vh></v>
<v t="ekr.20241213022537.24"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241213022537.25"><vh># @file CH07\CH07_SEC01_SimulateLorenz.py</vh>
<v t="ekr.20241213022537.27"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.28"><vh># Simulate the Lorenz System</vh></v>
<v t="ekr.20241213022537.29"><vh>Cell 3</vh></v>
<v t="ekr.20241213022537.30"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241213022537.31"><vh># @file CH07\CH07_SEC02_DMD_Cylinder.py</vh>
<v t="ekr.20241213022537.33"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.34"><vh>vortall_mat = io.loadmat(os.path.join('.</vh></v>
<v t="ekr.20241213022537.35"><vh>def DMD(X,Xprime,r):</vh></v>
<v t="ekr.20241213022537.36"><vh>Phi, Lambda, b =</vh></v>
<v t="ekr.20241213022537.37"><vh># Plot Mode 2</vh></v>
<v t="ekr.20241213022537.38"><vh>V2 =</vh></v>
<v t="ekr.20241213022537.39"><vh>Cell 7</vh></v>
<v t="ekr.20241213022537.40"><vh>Cell 8</vh></v>
</v>
<v t="ekr.20241213022537.41"><vh># @file CH07\CH07_SEC03_SINDY_Lorenz.py</vh>
<v t="ekr.20241213022537.43"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.44"><vh># Simulate the Lorenz System</vh></v>
<v t="ekr.20241213022537.45"><vh># Compute Derivative</vh></v>
<v t="ekr.20241213022537.46"><vh># SINDy Function Definitions</vh></v>
<v t="ekr.20241213022537.47"><vh>Up to third order polynomials</vh></v>
<v t="ekr.20241213022537.48"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022537.49"><vh># @file CH07\CH07_SEC04_Koopman.py</vh>
<v t="ekr.20241213022537.51"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.52"><vh>mu = -0.05</vh></v>
<v t="ekr.20241213022537.53"><vh># Integrate Koopman trajectories</vh></v>
<v t="ekr.20241213022537.54"><vh># Plot invariant surfaces</vh></v>
<v t="ekr.20241213022537.55"><vh>Cell 5</vh></v>
<v t="ekr.20241213022537.56"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022537.57"><vh># @file CH07\CH07_SEC05_HAVOK_Lorenz.py</vh>
<v t="ekr.20241213022537.59"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.60"><vh># Simulate the Lorenz System</vh></v>
<v t="ekr.20241213022537.61"><vh># Eigen-time delay coordinates</vh></v>
<v t="ekr.20241213022537.62"><vh># Compute Derivatives (4th Order Central</vh></v>
<v t="ekr.20241213022537.63"><vh># Build HAVOK Regression Model on Time</vh></v>
<v t="ekr.20241213022537.64"><vh>print(1/2/3)</vh></v>
<v t="ekr.20241213022537.65"><vh>Cell 7</vh></v>
</v>
</v>
<v t="ekr.20241213022537.66"><vh>CH08</vh>
<v t="ekr.20241213022537.67"><vh># @file CH08\CH08_SEC01_CruiseControl.py</vh>
<v t="ekr.20241213022537.69"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.70"><vh>time</vh></v>
<v t="ekr.20241213022537.71"><vh>plt.plot(t,wr,'k',linewidth=2,label='Ref</vh></v>
<v t="ekr.20241213022537.72"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241213022537.73"><vh># @file CH08\CH08_SEC07_1_LQR.py</vh>
<v t="ekr.20241213022537.75"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.76"><vh>m = 1</vh></v>
<v t="ekr.20241213022537.77"><vh># Design LQR Controller</vh></v>
<v t="ekr.20241213022537.78"><vh># ODE RHS Function Definition</vh></v>
<v t="ekr.20241213022537.79"><vh># Simulate closed-loop system</vh></v>
<v t="ekr.20241213022537.80"><vh>for k in range(np.floor(len(t)/100)):</vh></v>
<v t="ekr.20241213022537.81"><vh>fig,ax = plt.subplots()</vh></v>
<v t="ekr.20241213022537.82"><vh>plot_labels = ('x','v','theta','omega')</vh></v>
<v t="ekr.20241213022537.83"><vh># Compare with many examples of Pole</vh></v>
<v t="ekr.20241213022537.84"><vh># Plots</vh></v>
<v t="ekr.20241213022537.85"><vh>for count in range(100):</vh></v>
</v>
<v t="ekr.20241213022537.86"><vh># @file CH08\CH08_SEC07_2b_Obsv.py</vh>
<v t="ekr.20241213022537.88"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.89"><vh>m = 1</vh></v>
<v t="ekr.20241213022537.90"><vh># Which measurements are best if we omit</vh></v>
<v t="ekr.20241213022537.91"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241213022537.92"><vh># @file CH08\CH08_SEC07_2_KalmanFilter.py</vh>
<v t="ekr.20241213022537.94"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.95"><vh>m = 1</vh></v>
<v t="ekr.20241213022537.96"><vh>Kalman estimator design</vh></v>
<v t="ekr.20241213022537.97"><vh># Specify disturbance and noise</vh></v>
<v t="ekr.20241213022537.98"><vh># Augment system with additional inputs</vh></v>
<v t="ekr.20241213022537.99"><vh># Estimate linearized system in "down"</vh></v>
<v t="ekr.20241213022537.100"><vh>plt.plot(t,y,color=(0.5,0.5,0.5),label='</vh></v>
<v t="ekr.20241213022537.101"><vh>x_labels = ('x','v','theta','omega')</vh></v>
<v t="ekr.20241213022537.102"><vh>Cell 9</vh></v>
</v>
<v t="ekr.20241213022537.103"><vh># @file CH08\CH08_SEC08_1_TransferFunction.py</vh>
<v t="ekr.20241213022537.105"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.106"><vh>s = tf(np.array([1,0]),np.array([0,1]))</vh></v>
<v t="ekr.20241213022537.107"><vh>A = np.array([[0,1],[-2,-1]])</vh></v>
<v t="ekr.20241213022537.108"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241213022537.109"><vh># @file CH08\CH08_SEC08_2_SandT.py</vh>
<v t="ekr.20241213022537.111"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.112"><vh>s = tf(np.array([1,0]),np.array([0,1]))</vh></v>
<v t="ekr.20241213022537.113"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241213022537.114"><vh># @file CH08\CH08_SEC08_3_PlantInversion.py</vh>
<v t="ekr.20241213022537.116"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.117"><vh>s = tf(np.array([1,0]),np.array([0,1]))</vh></v>
<v t="ekr.20241213022537.118"><vh>Cell 3</vh></v>
<v t="ekr.20241213022537.119"><vh>Cell 4</vh></v>
</v>
</v>
<v t="ekr.20241213022537.120"><vh>CH09</vh>
<v t="ekr.20241213022537.121"><vh># @file CH09\CH09_SEC02_1_GramianPlot.py</vh>
<v t="ekr.20241213022537.123"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.124"><vh>A = np.array([[-0.75,1],[-0.3,-0.75]])</vh></v>
<v t="ekr.20241213022537.125"><vh>Manually compute transform matrix for</vh></v>
<v t="ekr.20241213022537.126"><vh># Plot Gramians</vh></v>
<v t="ekr.20241213022537.127"><vh>plt.plot(xc,yc,'k--',linewidth=2)</vh></v>
<v t="ekr.20241213022537.128"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022537.129"><vh># @file CH09\CH09_SEC02_2_BalancedTruncation.py</vh>
<v t="ekr.20241213022537.131"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.132"><vh>testSys_mat = io.loadmat(os.path.join('.</vh></v>
<v t="ekr.20241213022537.133"><vh># Plot Hankel Singular Values</vh></v>
<v t="ekr.20241213022537.134"><vh>Balanced truncation</vh></v>
<v t="ekr.20241213022537.135"><vh>Compute BPOD</vh></v>
<v t="ekr.20241213022537.136"><vh># Plot impulse responses for all methods</vh></v>
<v t="ekr.20241213022537.137"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241213022537.138"><vh># @file CH09\CH09_SEC03_ERA_OKID.py</vh>
<v t="ekr.20241213022537.140"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.141"><vh>Number of inputs</vh></v>
<v t="ekr.20241213022537.142"><vh>yFull = np.zeros((r*5+2,p,q))</vh></v>
<v t="ekr.20241213022537.143"><vh># ERA and OKID Function Definitions</vh></v>
<v t="ekr.20241213022537.144"><vh># Compute ERA from impulse response</vh></v>
<v t="ekr.20241213022537.145"><vh># Compute random input simulation for</vh></v>
<v t="ekr.20241213022537.146"><vh># Compute OKID and then ERA</vh></v>
<v t="ekr.20241213022537.147"><vh># Plot impulse responses for all methods</vh></v>
<v t="ekr.20241213022537.148"><vh># Plot input/output pair for OKID</vh></v>
<v t="ekr.20241213022537.149"><vh>uRandom.shape</vh></v>
<v t="ekr.20241213022537.150"><vh>Cell 11</vh></v>
</v>
<v t="ekr.20241213022537.151"><vh># @file CH09\CH09_SEC03_Fig9p5.py</vh>
<v t="ekr.20241213022537.153"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.154"><vh>Number of inputs</vh></v>
<v t="ekr.20241213022537.155"><vh># Figure 1 = simple impulse response</vh></v>
<v t="ekr.20241213022537.156"><vh>plt.step(t,u,'k',linewidth=1.5)</vh></v>
<v t="ekr.20241213022537.157"><vh>plt.step(t,y,'k',linewidth=1.5)</vh></v>
<v t="ekr.20241213022537.158"><vh># FIgure 2 - OKID response</vh></v>
<v t="ekr.20241213022537.159"><vh>plt.step(t,u,'k',linewidth=1.5)</vh></v>
<v t="ekr.20241213022537.160"><vh>plt.step(t,y,'k',linewidth=1.5)</vh></v>
</v>
</v>
<v t="ekr.20241213022537.161"><vh>CH10</vh>
<v t="ekr.20241213022537.162"><vh># @file CH10\CH10_SEC03_ESCfixed.py</vh>
<v t="ekr.20241213022537.164"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.165"><vh>J = lambda u,t: (25-np.power((5-u),2))</vh></v>
<v t="ekr.20241213022537.166"><vh># Extremum Seeking Control Parameters</vh></v>
<v t="ekr.20241213022537.167"><vh># High pass filter (Butterworth filter)</vh></v>
<v t="ekr.20241213022537.168"><vh># Figures</vh></v>
<v t="ekr.20241213022537.169"><vh>Cell 6</vh></v>
<v t="ekr.20241213022537.170"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241213022537.171"><vh># @file CH10\CH10_SEC03_ESCsinusoidal.py</vh>
<v t="ekr.20241213022537.173"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022537.174"><vh>J = lambda u,t:</vh></v>
<v t="ekr.20241213022537.175"><vh># Extremum Seeking Control Parameters</vh></v>
<v t="ekr.20241213022537.176"><vh># High pass filter (Butterworth filter)</vh></v>
<v t="ekr.20241213022537.177"><vh># Figures</vh></v>
<v t="ekr.20241213022537.178"><vh>Cell 6</vh></v>
</v>
</v>
<v t="ekr.20241213022538.1"><vh>CH11</vh>
<v t="ekr.20241213022538.2"><vh># @file CH11\CH11_SEC01_1_Fig11p1.py</vh>
<v t="ekr.20241213022538.4"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.5"><vh>L = 20</vh></v>
<v t="ekr.20241213022538.6"><vh>fig,axs = plt.subplots(1,2)</vh></v>
<v t="ekr.20241213022538.7"><vh>ut21 = np.zeros(n,dtype='complex_')</vh></v>
<v t="ekr.20241213022538.8"><vh>plt.semilogy(erx,er3,'b',linewidth=2)</vh></v>
<v t="ekr.20241213022538.9"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241213022538.10"><vh># @file CH11\CH11_SEC02_1_HarmonicOscillator.py</vh>
<v t="ekr.20241213022538.12"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.13"><vh>L = 30</vh></v>
<v t="ekr.20241213022538.14"><vh>def harm_rhs(ut_split,t,k=k,V=V,n=n):</vh></v>
<v t="ekr.20241213022538.15"><vh>initial conditions</vh></v>
<v t="ekr.20241213022538.16"><vh>initial conditions</vh></v>
<v t="ekr.20241213022538.17"><vh>ax = Axes3D(plt.figure())</vh></v>
<v t="ekr.20241213022538.18"><vh>ax = Axes3D(plt.figure())</vh></v>
<v t="ekr.20241213022538.19"><vh>usol3 = np.zeros_like(usol)</vh></v>
<v t="ekr.20241213022538.20"><vh>plt.plot(100*S/np.sum(S),'ko',linewidth=</vh></v>
<v t="ekr.20241213022538.21"><vh>plt.plot(100*S2/np.sum(S2),'ko',linewidt</vh></v>
<v t="ekr.20241213022538.22"><vh>fig,axs = plt.subplots(3,1)</vh></v>
<v t="ekr.20241213022538.23"><vh>Cell 12</vh></v>
</v>
<v t="ekr.20241213022538.24"><vh># @file CH11\CH11_SEC03_1_NonlinearSchrodinger.py</vh>
<v t="ekr.20241213022538.26"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.27"><vh>L = 40</vh></v>
<v t="ekr.20241213022538.28"><vh>def nls_rhs(ut_split,t,k=k):</vh></v>
<v t="ekr.20241213022538.29"><vh>N = 1</vh></v>
<v t="ekr.20241213022538.30"><vh>N = 2</vh></v>
<v t="ekr.20241213022538.31"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241213022538.32"><vh>U,S,VT = np.linalg.svd(usol.T)</vh></v>
<v t="ekr.20241213022538.33"><vh>plt.rcParams['figure.figsize'] = [12, 6]</vh></v>
<v t="ekr.20241213022538.34"><vh>color_list = ['b','g','r']</vh></v>
<v t="ekr.20241213022538.35"><vh>for jj in range(3):</vh></v>
<v t="ekr.20241213022538.36"><vh>Cell 11</vh></v>
</v>
<v t="ekr.20241213022538.37"><vh># @file CH11\CH11_SEC05_1_Invariance.py</vh>
<v t="ekr.20241213022538.39"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.40"><vh>L = 20</vh></v>
<v t="ekr.20241213022538.41"><vh>U,S,VT =</vh></v>
<v t="ekr.20241213022538.42"><vh>fig, axs = plt.subplots(2,1)</vh></v>
<v t="ekr.20241213022538.43"><vh>plt.rcParams['figure.figsize'] = [12,</vh></v>
<v t="ekr.20241213022538.44"><vh>u = np.tanh(np.sqrt(np.power(X,2)+np.pow</vh></v>
<v t="ekr.20241213022538.45"><vh># Translation</vh></v>
<v t="ekr.20241213022538.46"><vh>plt.rcParams['figure.figsize'] = [12,12]</vh></v>
<v t="ekr.20241213022538.47"><vh>U2,S2,V2T = np.linalg.svd(X)</vh></v>
<v t="ekr.20241213022538.48"><vh>Cell 10</vh></v>
</v>
</v>
<v t="ekr.20241213022538.49"><vh>CH12</vh>
<v t="ekr.20241213022538.50"><vh># @file CH12\CH12_SEC01_1_GAPPY.py</vh>
<v t="ekr.20241213022538.52"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.53"><vh>define domain</vh></v>
<v t="ekr.20241213022538.54"><vh>plt.rcParams['figure.figsize'] = [12,12]</vh></v>
<v t="ekr.20241213022538.55"><vh>plt.rcParams['figure.figsize'] = [12,12]</vh></v>
<v t="ekr.20241213022538.56"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241213022538.57"><vh>plt.rcParams['figure.figsize'] = [12,6]</vh></v>
<v t="ekr.20241213022538.58"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241213022538.59"><vh># @file CH12\CH12_SEC02_1_GAPPY.py</vh>
<v t="ekr.20241213022538.61"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.62"><vh>define domain</vh></v>
<v t="ekr.20241213022538.63"><vh>n = len(x)</vh></v>
<v t="ekr.20241213022538.64"><vh># Test Random trials with P% of</vh></v>
<v t="ekr.20241213022538.65"><vh>fig,axs = plt.subplots(2,1)</vh></v>
<v t="ekr.20241213022538.66"><vh># For 20% measurements, sort great from</vh></v>
<v t="ekr.20241213022538.67"><vh>fig,axs = plt.subplots(3,1)</vh></v>
<v t="ekr.20241213022538.68"><vh>fig, ax = plt.subplots(1,1)</vh></v>
<v t="ekr.20241213022538.69"><vh>jloc = np.argsort(co)</vh></v>
<v t="ekr.20241213022538.70"><vh>m = 30</vh></v>
<v t="ekr.20241213022538.71"><vh>Cell 11</vh></v>
</v>
<v t="ekr.20241213022538.72"><vh># @file CH12\CH12_SEC03_1_GAPPY_ConditionNumber.py</vh>
<v t="ekr.20241213022538.74"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.75"><vh>define domain</vh></v>
<v t="ekr.20241213022538.76"><vh># Method 1 -- Condition Number</vh></v>
<v t="ekr.20241213022538.77"><vh>plt.rcParams['figure.figsize'] = [12,10]</vh></v>
<v t="ekr.20241213022538.78"><vh>titer = np.arange(1,21)</vh></v>
<v t="ekr.20241213022538.79"><vh>plt.rcParams['figure.figsize'] = [12,6]</vh></v>
<v t="ekr.20241213022538.80"><vh># Method 2 -- Max Diagonal vs. Off-</vh></v>
<v t="ekr.20241213022538.81"><vh>plt.rcParams['figure.figsize'] = [12,10]</vh></v>
<v t="ekr.20241213022538.82"><vh># Method 1 -- First 4 Condition Number</vh></v>
<v t="ekr.20241213022538.83"><vh>Cell 10</vh></v>
</v>
<v t="ekr.20241213022538.84"><vh># @file CH12\CH12_SEC04_1_GAPPY_Variance.py</vh>
<v t="ekr.20241213022538.86"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.87"><vh>define domain</vh></v>
<v t="ekr.20241213022538.88"><vh># Method 1 -- Start with max of each</vh></v>
<v t="ekr.20241213022538.89"><vh># Method 2 -- Start with max and mins of</vh></v>
<v t="ekr.20241213022538.90"><vh># Method 3 -- Search for extrema, then</vh></v>
<v t="ekr.20241213022538.91"><vh># select random 20 - shuffle</vh></v>
<v t="ekr.20241213022538.92"><vh># Method to compare -- Willcox condition</vh></v>
<v t="ekr.20241213022538.93"><vh>fig,axs = plt.subplots(3,1)</vh></v>
<v t="ekr.20241213022538.94"><vh>titer = np.arange(1,21)</vh></v>
<v t="ekr.20241213022538.95"><vh>plt.rcParams['figure.figsize'] = [12,6]</vh></v>
<v t="ekr.20241213022538.96"><vh>Cell 11</vh></v>
</v>
<v t="ekr.20241213022538.97"><vh># @file CH12\CH12_SEC06_1_DEIM.py</vh>
<v t="ekr.20241213022538.99"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.100"><vh>spatial discretization</vh></v>
<v t="ekr.20241213022538.101"><vh>def ch_pod_sol_rhs(ut_split,t,k=k):</vh></v>
<v t="ekr.20241213022538.102"><vh>N = 2</vh></v>
<v t="ekr.20241213022538.103"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241213022538.104"><vh>data matrix X</vh></v>
<v t="ekr.20241213022538.105"><vh>NL = (1j)*np.power(np.abs(X),2)*X</vh></v>
<v t="ekr.20241213022538.106"><vh>nonlinear projection</vh></v>
<v t="ekr.20241213022538.107"><vh>def rom_deim_rhs(a_split,tspan,P_NL=P_NL</vh></v>
<v t="ekr.20241213022538.108"><vh>Separate real/complex pieces</vh></v>
<v t="ekr.20241213022538.109"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241213022538.110"><vh># QR DEIM</vh></v>
<v t="ekr.20241213022538.111"><vh>Cell 13</vh></v>
<v t="ekr.20241213022538.112"><vh>Cell 14</vh></v>
</v>
<v t="ekr.20241213022538.113"><vh># @file CH12\CH12_SEC06_2_DEIM.py</vh>
<v t="ekr.20241213022538.115"><vh>import numpy as np</vh></v>
<v t="ekr.20241213022538.116"><vh>spatial discretization</vh></v>
<v t="ekr.20241213022538.117"><vh>def ch_pod_sol_rhs(ut_split,t,k=k):</vh></v>
<v t="ekr.20241213022538.118"><vh>N = 2</vh></v>
<v t="ekr.20241213022538.119"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241213022538.120"><vh>data matrix X</vh></v>
<v t="ekr.20241213022538.121"><vh>NL = (1j)*np.power(np.abs(X),2)*X</vh></v>
<v t="ekr.20241213022538.122"><vh>nonlinear projection</vh></v>
<v t="ekr.20241213022538.123"><vh>def rom_deim_rhs(a_split,tspan,P_NL=P_NL</vh></v>
<v t="ekr.20241213022538.124"><vh>Separate real/complex pieces</vh></v>
<v t="ekr.20241213022538.125"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241213022538.126"><vh>plt.plot(x,-np.real(Psi[:,:3]))</vh></v>
<v t="ekr.20241213022538.127"><vh># QR compare</vh></v>
<v t="ekr.20241213022538.128"><vh>Cell 14</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20241212164526.14">"""Execute one .py file externally."""

g.cls()
import os

# Must execute the script in the proper folder.
dir_ = os.path.dirname(c.fileName())
os.chdir(dir_)  # r'C:\Users\Dev\EKR-Study\python\CODE_PYTHON'

# All the sections have a common naming convention.
chapter = 'CH01'
section = r'SEC03_Rotation.py'
path = fr'{chapter}/{chapter}_{section}'

# No need to hang Leo.
g.execute_shell_commands(f"&amp;python {path}")
</t>
<t tx="ekr.20241212164526.16"># pyflakes generated these warnings when saving "live" versions of the converted files.

tbo: beautified: CH01_SEC02.py
tbo: beautified: CH01_SEC03_Rotation.py
CH01_SEC03_Rotation.py:24:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH01_SEC04_1_Linear.py
tbo: beautified: CH01_SEC04_2_Cement.py
tbo: beautified: CH01_SEC04_3_Housing.py
tbo: beautified: CH01_SEC05_1_PCAGaussian.py
tbo: beautified: CH01_SEC05_2_OvarianCancer.py
CH01_SEC05_2_OvarianCancer.py:25:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH01_SEC06_1.py
tbo: beautified: CH01_SEC06_2_3_4.py
tbo: beautified: CH01_SEC07_1.py
tbo: beautified: CH01_SEC07_2.py
CH01_SEC07_2.py:24:1: 'scipy.misc' imported but unused
CH01_SEC07_2.py:42:9: undefined name 'skimage'
CH01_SEC07_2.py:46:12: undefined name 'Y'
tbo: beautified: CH01_SEC07_3.py
CH01_SEC07_3.py:23:1: 'matplotlib.cm' imported but unused
tbo: beautified: CH01_SEC08_RSVD.py
tbo: beautified: CH01_SEC09_Tensor.py
CH01_SEC09_Tensor.py:24:1: 'os' imported but unused
CH01_SEC09_Tensor.py:25:1: 'matplotlib.rc' imported but unused
CH01_SEC03_Rotation.py:24:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
CH01_SEC05_2_OvarianCancer.py:25:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
CH01_SEC07_2.py:24:1: 'scipy.misc' imported but unused
CH01_SEC07_2.py:42:9: undefined name 'skimage'
CH01_SEC07_2.py:46:12: undefined name 'Y'
CH01_SEC07_3.py:23:1: 'matplotlib.cm' imported but unused
CH01_SEC09_Tensor.py:24:1: 'os' imported but unused
CH01_SEC09_Tensor.py:25:1: 'matplotlib.rc' imported but unused
tbo: beautified: CH02_SEC01_0_InnerProduct.py
tbo: beautified: CH02_SEC01_1_FourierSines.py
tbo: beautified: CH02_SEC01_2_Gibbs.py
tbo: beautified: CH02_SEC01_2_Gibbs_Movie.py
CH02_SEC01_2_Gibbs_Movie.py:24:1: 'matplotlib.rc' imported but unused
tbo: beautified: CH02_SEC02_1_DFT.py
tbo: beautified: CH02_SEC02_2_Denoise.py
tbo: beautified: CH02_SEC02_3_SpectralDerivative.py
tbo: beautified: CH02_SEC03_1_FFTHeat.py
CH02_SEC03_1_FFTHeat.py:25:1: 'mpl_toolkits.mplot3d.axes3d' imported but unused
tbo: beautified: CH02_SEC03_2_FFTWave.py
CH02_SEC03_2_FFTWave.py:25:1: 'mpl_toolkits.mplot3d.axes3d' imported but unused
tbo: beautified: CH02_SEC03_3_FFTBurgers.py
CH02_SEC03_3_FFTBurgers.py:25:1: 'mpl_toolkits.mplot3d.axes3d' imported but unused
tbo: beautified: CH02_SEC04_1_SpectrogramChirp.py
tbo: beautified: CH02_SEC05_HAAR.py
tbo: beautified: CH02_SEC06_1_2DFFT.py
tbo: beautified: CH02_SEC06_2_Compress.py
tbo: beautified: CH02_SEC06_3_Denoise.py
tbo: beautified: CH02_SEC06_4_Wavelet.py
tbo: beautified: CH02_SEC06_5_WaveletCompress.py
tbo: beautified: CH03_SEC01_Compress.py
CH03_SEC01_Compress.py:26:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH03_SEC03_1_Underdetermined.py
CH03_SEC03_1_Underdetermined.py:24:1: 'os' imported but unused
tbo: beautified: CH03_SEC03_2_AudioCS.py
tbo: beautified: CH03_SEC04_Matrices.py
CH03_SEC04_Matrices.py:24:1: 'matplotlib.cm' imported but unused
CH03_SEC04_Matrices.py:25:1: 'matplotlib.colors.LinearSegmentedColormap' imported but unused
tbo: beautified: CH03_SEC05_1_RobustRegression.py
CH03_SEC05_1_RobustRegression.py:24:1: 'os' imported but unused
tbo: beautified: CH03_SEC05_2_LASSO.py
CH03_SEC05_2_LASSO.py:24:1: 'os' imported but unused
CH03_SEC05_2_LASSO.py:25:1: 'scipy.io' imported but unused
tbo: beautified: CH03_SEC06_SparseRepresentation.py
CH03_SEC06_SparseRepresentation.py:26:1: 'sklearn.linear_model' imported but unused
CH03_SEC06_SparseRepresentation.py:27:1: 'sklearn.model_selection' imported but unused
tbo: beautified: CH03_SEC07_RPCA.py
tbo: beautified: CH04_SEC01_LinearRegression.py
tbo: beautified: CH04_SEC02_1_GradientDescent.py
CH04_SEC02_1_GradientDescent.py:27:1: 'matplotlib.cm' imported but unused
CH04_SEC02_1_GradientDescent.py:28:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH04_SEC03_1_OverUnderDetermined.py
CH04_SEC03_1_OverUnderDetermined.py:25:1: 'scipy.optimize.fmin' imported but unused
tbo: beautified: CH04_SEC04_1_CompareRegression.py
tbo: beautified: CH04_SEC05_0_Fig4p16_Pareto.py
tbo: beautified: CH04_SEC05_1_CrossValidate.py
CH04_SEC05_1_CrossValidate.py:24:1: 'matplotlib.patches.Rectangle' imported but unused
tbo: beautified: CH04_SEC06_1_kFoldValidation.py
CH04_SEC06_1_kFoldValidation.py:26:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH04_SEC07_1_ModelValidation.py
tbo: beautified: CH04_SEC07_2_RegressAIC_BIC.py
CH04_SEC07_2_RegressAIC_BIC.py:25:1: 'statsmodels.tsa.arima_process' imported but unused
CH04_SEC07_2_RegressAIC_BIC.py:25:1: 'statsmodels.tsa.arima_model' imported but unused
CH04_SEC07_2_RegressAIC_BIC.py:48:16: undefined name 'sm'
CH04_SEC07_2_RegressAIC_BIC.py:56:17: undefined name 'sm'
tbo: beautified: CH05_SEC01_1_FischerExtraction.py
CH05_SEC01_1_FischerExtraction.py:27:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH05_SEC02_1_Fig5p7_Fig5p8.py
tbo: beautified: CH05_SEC03_1_Kmeans.py
tbo: beautified: CH05_SEC04_1_Dendrogram.py
tbo: beautified: CH05_SEC05_1_GaussianMixtureModels.py
CH05_SEC05_1_GaussianMixtureModels.py:28:1: 'mpl_toolkits.mplot3d' imported but unused
tbo: beautified: CH05_SEC06_1_LDA_Classify.py
CH05_SEC06_1_LDA_Classify.py:27:1: 'mpl_toolkits.mplot3d' imported but unused
tbo: beautified: CH05_SEC07_1_SVM.py
CH05_SEC07_1_SVM.py:29:1: 'mpl_toolkits.mplot3d' imported but unused
tbo: beautified: CH05_SEC08_1_Trees.py
CH05_SEC08_1_Trees.py:32:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH06_SEC01_1_NN.py
tbo: beautified: CH06_SEC04_1_StochasticGradientDescent.py
CH06_SEC04_1_StochasticGradientDescent.py:26:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH06_SEC05_1_DeepCNN.py
tbo: beautified: CH06_SEC06_1_NNLorenz.py
CH06_SEC06_1_NNLorenz.py:26:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
CH06_SEC06_1_NNLorenz.py:29:1: 'keras.layers.Conv2D' imported but unused
CH06_SEC06_1_NNLorenz.py:29:1: 'keras.layers.Flatten' imported but unused
CH06_SEC06_1_NNLorenz.py:29:1: 'keras.layers.MaxPool2D' imported but unused
CH06_SEC06_1_NNLorenz.py:31:1: 'keras.layers.Activation' imported but unused
CH06_SEC06_1_NNLorenz.py:32:1: 'keras.utils.generic_utils.get_custom_objects' imported but unused
tbo: beautified: CH07_SEC01_SimulateLogistic.py
tbo: beautified: CH07_SEC01_SimulateLorenz.py
CH07_SEC01_SimulateLorenz.py:25:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH07_SEC02_DMD_Cylinder.py
tbo: beautified: CH07_SEC03_SINDY_Lorenz.py
CH07_SEC03_SINDY_Lorenz.py:25:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH07_SEC04_Koopman.py
CH07_SEC04_Koopman.py:25:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH07_SEC05_HAVOK_Lorenz.py
CH07_SEC05_HAVOK_Lorenz.py:25:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH08_SEC01_CruiseControl.py
tbo: beautified: CH08_SEC07_1_LQR.py
CH08_SEC07_1_LQR.py:24:1: 'matplotlib.rcParams' imported but unused
CH08_SEC07_1_LQR.py:25:1: 'matplotlib.rc' imported but unused
CH08_SEC07_1_LQR.py:27:1: 'from control.matlab import *' used; unable to detect undefined names
CH08_SEC07_1_LQR.py:29:1: 'slycot' imported but unused
CH08_SEC07_1_LQR.py:55:21: 'ctrb' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_1_LQR.py:63:5: 'lqr' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_1_LQR.py:96:29: 't' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH08_SEC07_2b_Obsv.py
CH08_SEC07_2b_Obsv.py:24:1: 'matplotlib.rcParams' imported but unused
CH08_SEC07_2b_Obsv.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH08_SEC07_2b_Obsv.py:26:1: 'slycot' imported but unused
CH08_SEC07_2b_Obsv.py:27:1: 'scipy.integrate' imported but unused
CH08_SEC07_2b_Obsv.py:28:1: 'scipy.linalg.schur' imported but unused
CH08_SEC07_2b_Obsv.py:53:42: 'obsv' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2b_Obsv.py:54:67: 'obsv' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2b_Obsv.py:66:42: 'obsv' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2b_Obsv.py:70:7: 'ss' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2b_Obsv.py:71:54: 'gram' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH08_SEC07_2_KalmanFilter.py
CH08_SEC07_2_KalmanFilter.py:24:1: 'matplotlib.rcParams' imported but unused
CH08_SEC07_2_KalmanFilter.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH08_SEC07_2_KalmanFilter.py:26:1: 'slycot' imported but unused
CH08_SEC07_2_KalmanFilter.py:27:1: 'scipy.integrate' imported but unused
CH08_SEC07_2_KalmanFilter.py:53:68: 'obsv' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2_KalmanFilter.py:83:17: 'care' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2_KalmanFilter.py:105:8: 'ss' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2_KalmanFilter.py:108:12: 'ss' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2_KalmanFilter.py:111:9: 'ss' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2_KalmanFilter.py:128:11: 'lsim' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2_KalmanFilter.py:129:15: 'lsim' may be undefined, or defined from star imports: control.matlab
CH08_SEC07_2_KalmanFilter.py:130:14: 'lsim' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH08_SEC08_1_TransferFunction.py
CH08_SEC08_1_TransferFunction.py:24:1: 'matplotlib.rcParams' imported but unused
CH08_SEC08_1_TransferFunction.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH08_SEC08_1_TransferFunction.py:26:1: 'slycot' imported but unused
CH08_SEC08_1_TransferFunction.py:27:1: 'scipy.signal' imported but unused
CH08_SEC08_1_TransferFunction.py:36:5: 'tf' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_1_TransferFunction.py:38:17: 'bode' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_1_TransferFunction.py:46:5: 'ss2tf' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_1_TransferFunction.py:48:10: 'impulse' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH08_SEC08_2_SandT.py
CH08_SEC08_2_SandT.py:24:1: 'matplotlib.rcParams' imported but unused
CH08_SEC08_2_SandT.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH08_SEC08_2_SandT.py:26:1: 'slycot' imported but unused
CH08_SEC08_2_SandT.py:27:1: 'scipy.signal' imported but unused
CH08_SEC08_2_SandT.py:36:5: 'tf' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_2_SandT.py:40:11: 'bode' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_2_SandT.py:41:11: 'bode' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_2_SandT.py:42:11: 'bode' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH08_SEC08_3_PlantInversion.py
CH08_SEC08_3_PlantInversion.py:24:1: 'matplotlib.rcParams' imported but unused
CH08_SEC08_3_PlantInversion.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH08_SEC08_3_PlantInversion.py:26:1: 'slycot' imported but unused
CH08_SEC08_3_PlantInversion.py:27:1: 'scipy.signal' imported but unused
CH08_SEC08_3_PlantInversion.py:36:5: 'tf' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_3_PlantInversion.py:46:18: 'margin' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_3_PlantInversion.py:47:11: 'bode' may be undefined, or defined from star imports: control.matlab
CH08_SEC08_3_PlantInversion.py:57:6: 'feedback' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH09_SEC02_1_GramianPlot.py
CH09_SEC02_1_GramianPlot.py:24:1: 'matplotlib.rcParams' imported but unused
CH09_SEC02_1_GramianPlot.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH09_SEC02_1_GramianPlot.py:26:1: 'slycot' imported but unused
CH09_SEC02_1_GramianPlot.py:27:1: 'scipy.signal' imported but unused
CH09_SEC02_1_GramianPlot.py:42:7: 'ss' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_1_GramianPlot.py:44:6: 'gram' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_1_GramianPlot.py:45:6: 'gram' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_1_GramianPlot.py:47:8: 'balred' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_1_GramianPlot.py:49:7: 'gram' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_1_GramianPlot.py:50:7: 'gram' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH09_SEC02_2_BalancedTruncation.py
CH09_SEC02_2_BalancedTruncation.py:24:1: 'matplotlib.rcParams' imported but unused
CH09_SEC02_2_BalancedTruncation.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH09_SEC02_2_BalancedTruncation.py:26:1: 'slycot' imported but unused
CH09_SEC02_2_BalancedTruncation.py:28:1: 'scipy.signal' imported but unused
CH09_SEC02_2_BalancedTruncation.py:45:11: 'ss' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:54:8: 'hsvd' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:59:9: 'balred' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:65:30: 'p' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:65:33: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:66:30: 'n' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:66:33: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:70:10: 'ss' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:72:17: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:73:41: 'impulse' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:74:39: 'impulse' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:81:22: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:81:39: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:86:31: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:86:38: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:86:58: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:86:65: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:92:19: 'n' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:92:22: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:93:19: 'n' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:93:22: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:95:20: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:95:27: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:96:20: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:96:27: 'q' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:106:11: 'ss' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:111:24: 'impulse' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:112:20: 'impulse' may be undefined, or defined from star imports: control.matlab
CH09_SEC02_2_BalancedTruncation.py:113:24: 'impulse' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH09_SEC03_ERA_OKID.py
CH09_SEC03_ERA_OKID.py:24:1: 'matplotlib.rcParams' imported but unused
CH09_SEC03_ERA_OKID.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH09_SEC03_ERA_OKID.py:26:1: 'slycot' imported but unused
CH09_SEC03_ERA_OKID.py:27:1: 'scipy.signal' imported but unused
CH09_SEC03_ERA_OKID.py:50:11: 'ss' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_ERA_OKID.py:59:25: 'impulse' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_ERA_OKID.py:160:10: 'ss' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_ERA_OKID.py:166:11: 'lsim' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_ERA_OKID.py:174:14: 'ss' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_ERA_OKID.py:185:23: 'impulse' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_ERA_OKID.py:186:23: 'impulse' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_ERA_OKID.py:187:23: 'impulse' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH09_SEC03_Fig9p5.py
CH09_SEC03_Fig9p5.py:24:1: 'matplotlib.rcParams' imported but unused
CH09_SEC03_Fig9p5.py:25:1: 'from control.matlab import *' used; unable to detect undefined names
CH09_SEC03_Fig9p5.py:26:1: 'slycot' imported but unused
CH09_SEC03_Fig9p5.py:27:1: 'scipy.signal' imported but unused
CH09_SEC03_Fig9p5.py:29:1: 'scipy.linalg.fractional_matrix_power' imported but unused
CH09_SEC03_Fig9p5.py:50:7: 'ss' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_Fig9p5.py:57:8: 'impulse' may be undefined, or defined from star imports: control.matlab
CH09_SEC03_Fig9p5.py:84:11: 'lsim' may be undefined, or defined from star imports: control.matlab
tbo: beautified: CH10_SEC03_ESCfixed.py
CH10_SEC03_ESCfixed.py:24:1: 'matplotlib.rcParams' imported but unused
CH10_SEC03_ESCfixed.py:25:1: 'scipy.io' imported but unused
CH10_SEC03_ESCfixed.py:26:1: 'os' imported but unused
tbo: beautified: CH10_SEC03_ESCsinusoidal.py
CH10_SEC03_ESCsinusoidal.py:24:1: 'matplotlib.rcParams' imported but unused
CH10_SEC03_ESCsinusoidal.py:25:1: 'scipy.io' imported but unused
CH10_SEC03_ESCsinusoidal.py:26:1: 'os' imported but unused
tbo: beautified: CH11_SEC01_1_Fig11p1.py
CH11_SEC01_1_Fig11p1.py:24:1: 'matplotlib.rcParams' imported but unused
CH11_SEC01_1_Fig11p1.py:25:1: 'os' imported but unused
tbo: beautified: CH11_SEC02_1_HarmonicOscillator.py
CH11_SEC02_1_HarmonicOscillator.py:25:1: 'matplotlib.rcParams' imported but unused
tbo: beautified: CH11_SEC03_1_NonlinearSchrodinger.py
CH11_SEC03_1_NonlinearSchrodinger.py:24:1: 'matplotlib.rcParams' imported but unused
CH11_SEC03_1_NonlinearSchrodinger.py:24:1: 'matplotlib.cm' imported but unused
CH11_SEC03_1_NonlinearSchrodinger.py:26:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH11_SEC05_1_Invariance.py
CH11_SEC05_1_Invariance.py:24:1: 'matplotlib.rcParams' imported but unused
CH11_SEC05_1_Invariance.py:24:1: 'matplotlib.cm' imported but unused
CH11_SEC05_1_Invariance.py:25:1: 'scipy.integrate' imported but unused
CH11_SEC05_1_Invariance.py:26:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH12_SEC01_1_GAPPY.py
CH12_SEC01_1_GAPPY.py:25:1: 'matplotlib.rcParams' imported but unused
tbo: beautified: CH12_SEC02_1_GAPPY.py
CH12_SEC02_1_GAPPY.py:23:1: 'scipy.sparse.linalg' imported but unused
CH12_SEC02_1_GAPPY.py:25:1: 'matplotlib.rcParams' imported but unused
tbo: beautified: CH12_SEC03_1_GAPPY_ConditionNumber.py
CH12_SEC03_1_GAPPY_ConditionNumber.py:23:1: 'scipy.sparse.linalg' imported but unused
CH12_SEC03_1_GAPPY_ConditionNumber.py:25:1: 'matplotlib.rcParams' imported but unused
CH12_SEC03_1_GAPPY_ConditionNumber.py:26:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH12_SEC04_1_GAPPY_Variance.py
CH12_SEC04_1_GAPPY_Variance.py:23:1: 'scipy.sparse.linalg' imported but unused
CH12_SEC04_1_GAPPY_Variance.py:25:1: 'matplotlib.rcParams' imported but unused
CH12_SEC04_1_GAPPY_Variance.py:26:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH12_SEC06_1_DEIM.py
CH12_SEC06_1_DEIM.py:23:1: 'scipy.sparse.linalg' imported but unused
CH12_SEC06_1_DEIM.py:25:1: 'matplotlib.rcParams' imported but unused
CH12_SEC06_1_DEIM.py:28:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
tbo: beautified: CH12_SEC06_2_DEIM.py
CH12_SEC06_2_DEIM.py:23:1: 'scipy.sparse.linalg' imported but unused
CH12_SEC06_2_DEIM.py:25:1: 'matplotlib.rcParams' imported but unused
CH12_SEC06_2_DEIM.py:28:1: 'mpl_toolkits.mplot3d.Axes3D' imported but unused
</t>
<t tx="ekr.20241212164526.17">"""Convert files from .ipynb format to .py"""

g.cls()
import glob
import os

def is_pure_python(p) -&gt; bool:
    return not any(
        line.startswith('# %% [markdown]')
        for p2 in p.self_and_subtree()
        for line in g.splitLines(p2.b)
    )

last = c.lastTopLevel()
last = last.insertAfter()
last.h = '--- Converted ipynb files'
base_path = os.path.dirname(c.fileName())
dirs = [z for z in glob.glob(f"{base_path}{os.sep}*") if os.path.isdir(z)]
for dir_ in dirs:
    files = [z for z in glob.glob(f"{dir_}{os.sep}*.ipynb")]
    if not files:
        continue
    dir_s = os.path.basename(dir_)
    print(f"Importing {dir_s}...")
    short_files = [g.shortFileName(z) for z in files]
    parent = last.insertAsLastChild()
    parent.h = dir_s
    for the_file in files:
        p = parent.insertAsLastChild()
        p.h = f"@jupytext {the_file}"
        c.selectPosition(p)
        c.refreshFromDisk()
        if 0:  # Retain the full file name.
            new_fn = the_file.replace('.ipynb', '.py')
            p.h = f"# @file {new_fn}"
        else:  # Rely on @path
            new_fn = os.path.basename(the_file).replace('.ipynb', '.py')
            p.h = f"# @file {dir_s}{os.sep}{new_fn}"
        if 1:
            for child in p.children():
                if child.h == g.angleBrackets(' prefix '):
                    child.doDelete()
                    break
            p.b = p.b.replace(g.angleBrackets(' prefix ') + '\n', '')
        if is_pure_python(p):
            p.b = p.b.replace('@language jupytext', '@language python')
            for child in p.children():
                child.b = child.b.replace('# %%\n\n', '').replace('# %%\n', '')
c.contractAllHeadlines()
c.selectPosition(last)
last.expand()
c.redraw()</t>
<t tx="ekr.20241212164559.1"></t>
<t tx="ekr.20241212164559.106"></t>
<t tx="ekr.20241212164559.107"></t>
<t tx="ekr.20241212164559.108"></t>
<t tx="ekr.20241212164559.109"></t>
<t tx="ekr.20241212164559.111"></t>
<t tx="ekr.20241212164559.112"></t>
<t tx="ekr.20241212164559.113"></t>
<t tx="ekr.20241212164559.114"></t>
<t tx="ekr.20241212164559.115"></t>
<t tx="ekr.20241212164559.116"></t>
<t tx="ekr.20241212164559.117"></t>
<t tx="ekr.20241212164559.118"></t>
<t tx="ekr.20241212164559.119">@language rest
@wrap

See #3456.

</t>
<t tx="ekr.20241212164559.120"></t>
<t tx="ekr.20241212164559.121"></t>
<t tx="ekr.20241212164559.122"># leonine</t>
<t tx="ekr.20241212164559.124"></t>
<t tx="ekr.20241212164559.125"></t>
<t tx="ekr.20241212164559.126"></t>
<t tx="ekr.20241212164559.127">True: (Recommended) Make a "Recovered Nodes" node whenever
Leo reads a file that has been changed outside of Leo.
</t>
<t tx="ekr.20241212164559.128"></t>
<t tx="ekr.20241212164559.129"></t>
<t tx="ekr.20241212164559.13"></t>
<t tx="ekr.20241212164559.130"></t>
<t tx="ekr.20241212164559.131"></t>
<t tx="ekr.20241212164559.132"></t>
<t tx="ekr.20241212164559.133"></t>
<t tx="ekr.20241212164559.134"></t>
<t tx="ekr.20241212164559.135"></t>
<t tx="ekr.20241212164559.136"></t>
<t tx="ekr.20241212164559.137"></t>
<t tx="ekr.20241212164559.138"></t>
<t tx="ekr.20241212164559.139"></t>
<t tx="ekr.20241212164559.14"></t>
<t tx="ekr.20241212164559.141"># **Decluttering** replaces controls custom formatting of headlines, including:

# - Hiding or changing headline text,
# - Adding icons to headlines,
# - Changing the styling of headlines.

# @bool tree-declutter must be True to enable decluttering.

# blank lines and lines starting with '#' are ignored.
# See the children of this node for details.

RULE ^@file (.*)
REPLACE \1
ICON file_icons/file_file.png</t>
<t tx="ekr.20241212164559.142"></t>
<t tx="ekr.20241212164559.143"># **Decluttering** replaces controls custom formatting of headlines, including:

# - Hiding or changing headline text,
# - Adding icons to headlines,
# - Changing the styling of headlines.

# Decluttering is *inactive* when you are editing a headline.

# Decluttering is *completely optional*. To enable decluttering, use::

     # @bool tree-declutter = True
     
# Decluttering is controlled by **decluttering rulesets**.
# You specify decluttering rulesets in the body text of::
     
    # @data tree-declutter-patterns
    
# As usual with @data nodes:

# - Blank lines and lines starting with '#' are ignored.
# - You may organize the text of the @data node using child nodes.

# Each ruleset consists of a list of lines:

# - The first line is a **rule line**, containing a **find pattern**.
# - The second line is a **replacement line**.
# - The ruleset ends with zero or more **style lines**.

# Find patterns are `regular expressions &lt;https://docs.python.org/2/library/re.html&gt;`_.
# Decluttering affects only those headlines that match a rule pattern. 

# The following section shows some example rulesets. Later sections discuss decluttering commands, patterns and styles in more detail.
</t>
<t tx="ekr.20241212164559.144"># All rulesets start with a **rule line** of the form::

    # RULE &lt;regular expression&gt;
    
# The ruleset matches a headline if and only if the regular expression matches. Matches can start anywhere in the headline. Leo first attempts to a match using re.match. If that doesn't work, Leo tries re.search.

# A **replacement line** must follow the rule line. Here are the valid forms::

    # REPLACE &lt;substitution expression&gt;
    # REPLACE-HEAD
    # REPLACE-TAIL
    # REPLACE-REST
    
# - REPLACE replaces the headline by the value of the substitution expression.  For example::

    # REPLACE \1
    
  # matches replaces the headline by the first matched regex group.

# - REPLACE-HEAD replaces replace the headline by the text that precedes the matched text.

# - REPLACE-TAIL replaces the headline by the text that follows the matched text.

# - REPLACE-REST replaces the headline by everything except the matched text.
</t>
<t tx="ekr.20241212164559.145"># Leo applies style lines only if they appear in a ruleset that matches a headline.
# Style lines do the following...

# Add an icon to the headline::

    # ICON path/to/icon
    
# Set the background or foreground color to a color number or names::

    # BG #FF8800
    # FG @solarized-magenta

# Set the font to a given font name::

    # Font Times
    
# Set the font size in pixels (PX) or points (PT)::

    # PX 40
    # PT 16
    
# Enable or disable italics::

    # ITALIC 0
    # ITALIC 1

# Set the font weight to one of Light, Normal, DemiBold, Bold, Black::

    # WEIGHT DemoBold
</t>
<t tx="ekr.20241212164559.146"># Add Icon to folders and remove /-/
RULE ^/(.*)/$
REPLACE \1 
ICON file_icons/folder.png

# Add icon to path folders and remove @path
RULE ^@path (.*)
REPLACE \1 
ICON file_icons/folder_path.png

# Add Icon to removed folders and remove */-/*
RULE ^\*/(.*)/\*$
REPLACE \1 
ICON file_icons/folder_removed.png

# Add Icon to removed files and remove *-* but not **-**
RULE ^\*([^\*/]*[^\*]*[^\*/]*)\*$
REPLACE \1 
ICON file_icons/removed.png
</t>
<t tx="ekr.20241212164559.147"># if the node name starts with 'peacock node DEMO', make a mess of it
RULE ^(peacock node DEMO)
REPLACE LOOK: \1
ICON Tango/16x16/emotes/face-grin.png
ICON Tango/16x16/emotes/face-wink.png
FG @solarized-magenta
BG white
FONT Times
PX 40
ITALIC 1
WEIGHT Bold
</t>
<t tx="ekr.20241212164559.148"># RULE :([\w_@]+:)+\s*$
# REPLACE-HEAD
</t>
<t tx="ekr.20241212164559.149"># remove @clean etc. and use an icon
RULE ^@clean (.*)
REPLACE \1
ICON file_icons/file_clean.png

RULE ^@auto (.*)
REPLACE \1
ICON file_icons/file_auto.png

RULE ^@edit (.*)
REPLACE \1
ICON file_icons/file_edit.png

RULE ^@asis (.*)
REPLACE \1
ICON file_icons/file_asis.png

RULE ^@nosent (.*)
REPLACE \1
ICON file_icons/file_nosent.png

RULE ^@file (.*)
REPLACE \1
ICON file_icons/file_file.png
</t>
<t tx="ekr.20241212164559.15"># The headline must be: @outline-data tree-abbreviations

# A list tree abbreviation names.

# For each abbreviation name, there should be corresponding child node,
# the **abbreviation node** whose headline matches the abbreviation name.

# When a tree abbreviation fires, Leo pastes all the descendants of
# the abbreviation node as the last children of the presently selected node.

importer;;
per-commander-plugin;;
demo;;
</t>
<t tx="ekr.20241212164559.150"># show the last part of long filenames
RULE ^.{1,1000}/(.{20})
REPLACE â€¦/\1
</t>
<t tx="ekr.20241212164559.151"></t>
<t tx="ekr.20241212164559.152"></t>
<t tx="ekr.20241212164559.153"></t>
<t tx="ekr.20241212164559.154"></t>
<t tx="ekr.20241212164559.155"></t>
<t tx="ekr.20241212164559.156"></t>
<t tx="ekr.20241212164559.157"></t>
<t tx="ekr.20241212164559.158"></t>
<t tx="ekr.20241212164559.159">Only supported with the mod_tempfname.py plugin.

True: The plugin will store temporary files utilizing cleaner
file names (no unique number is appended to the node's headline text).
Unique temporary directory paths are used to insure unique files are
created by creating temporary directories reflecting each node's ancestor
nodes in the Leo outline. Note: Do not have multiple sibling nodes (nodes
having the same parent node) in Leo with the same headline text. There will
be a conflict if both are opened in an external editor at the same time.

False: The plugin will store temporary files with an appended
unique number to insure unique temporary filenames.
</t>
<t tx="ekr.20241212164559.16"></t>
<t tx="ekr.20241212164559.160">True: check all @&lt;file&gt; nodes in the outline for changes in corresponding external files.</t>
<t tx="ekr.20241212164559.161"></t>
<t tx="ekr.20241212164559.162"></t>
<t tx="ekr.20241212164559.163"></t>
<t tx="ekr.20241212164559.164"></t>
<t tx="ekr.20241212164559.165"></t>
<t tx="ekr.20241212164559.166">It is *strange* to set this to True!</t>
<t tx="ekr.20241212164559.167">@language rest

To test #2041 &amp; #2094

The @bool use-find-dialog and @bool minibuffer-find-mode settings comprise
a tri-state setting, as shown in this table:
    
minibuffer-find-mode    use-find-dialog     mode: Ctrl-F puts focus in
--------------------    ---------------     --------------------------
    True                    Ignored         minibuffer
    False                   True            dialog
    False                   False           Find tab in the log pane

*All modes*

- Start the search with Ctrl-F (start-search).
- Enter the find pattern.
- (Optional) Use &lt;Tab&gt; to enter the search pattern.
- Use &lt;Enter&gt; to start the search.

*dialog and find tab modes*

- Non-functional "buttons" remind you of key bindings.

*minibuffer mode*

- Use Ctrl-G as always to leave the minibuffer.
- The Find tab is not made visible, but the status area shows the settings.</t>
<t tx="ekr.20241212164559.168">@language rest

The @bool use-find-dialog and @bool minibuffer-find-mode settings comprise
a tri-state setting, as shown in this table:
    
minibuffer-find-mode    use-find-dialog     mode: Ctrl-F puts focus in
--------------------    ---------------     --------------------------
    True                    Ignored         minibuffer
    False                   True            dialog
    False                   False           Find tab in the log pane

*All modes*

- Start the seas with Ctrl-F (start-search).
- Enter the find pattern.
- (Optional) Use &lt;Tab&gt; to enter the search pattern.
- Use &lt;Enter&gt; to start the search.

*dialog and find tab modes*

- Non-functional "buttons" remind you of key bindings.

*minibuffer mode*

- Use Ctrl-G as always to leave the minibuffer.
- The Find tab is not made visible, but the status area shows the settings.</t>
<t tx="ekr.20241212164559.169">Added on-popover to import-html-tags (for leovue)</t>
<t tx="ekr.20241212164559.17"></t>
<t tx="ekr.20241212164559.170"># lowercase html tags, one per line.
# *** Add ons-popover tag for LeoVue.

a
abbr
acronym
address
applet
area
b
base
basefont
bdo
big
blockquote
body
br
button
caption
center
cite
code
col
colgroup
dd
del
dfn
dir
div
dl
dt
em
fieldset
font
form
frame
frameset
head
h1
h2
h3
h4
h5
h6
hr
html
i
iframe
img
input
ins
kbd
label
legend
li
link
map
menu
meta
noframes
noscript
object
ol
ons-popover
optgroup
option
p
param
pre
q
s
samp
script
select
small
span
strike
strong
style
sub
sup
table
tbody
td
textarea
tfoot
th
thead
title
tr
tt
u
ul
var</t>
<t tx="ekr.20241212164559.171"># lowercase xml tags, one per line.

html
body
head
div
table
</t>
<t tx="ekr.20241212164559.172">For make-stub-files</t>
<t tx="ekr.20241212164559.173">True: allow stub files to be overwritten
</t>
<t tx="ekr.20241212164559.174"></t>
<t tx="ekr.20241212164559.175"></t>
<t tx="ekr.20241212164559.176"></t>
<t tx="ekr.20241212164559.177"></t>
<t tx="ekr.20241212164559.178"></t>
<t tx="ekr.20241212164559.179">AstFormatter.*: str
Pattern.all_matches: Sequence
Pattern.full_balanced_match: Optional[int]
Pattern.match_balanced: int
Pattern.match_entire_string: bool
StandAloneMakeStubFile.scan_types: Dict[str, str]
StubFormatter.do_.*: str
StubTraverser.format_returns: str
StubTraverser.match_return_patterns: Tuple[bool,str]
StubTraverser.match_return_pattern: Optional[str]
StubTraverser.match_balanced: int</t>
<t tx="ekr.20241212164559.18"></t>
<t tx="ekr.20241212164559.180"># Patterns to be applied to argument lists and return expressions.

aList: Sequence
aList1: Sequence
aList2: Sequence
c: C
c1: C
c2: C
i: int
j: int
k: int
node: ast.Ast
p: P
p1: P
p2: P
s: str
s2: str
v: V
v1: V
v2: V

aList: Sequence
controller: StandAloneMakeStubFile
fn: str
i[0-3]*: int
parser: optparse.OptionParser
node: Node
s[0-3]*: str
strict: bool

repr(*): str
str.join(*): str
str.replace(*): str
str%(*): str
str%str: str

.*__name__: str
</t>
<t tx="ekr.20241212164559.181"># Lines to be inserted at the start of each stub file.

from typing import Any, Dict, Optional, Sequence, Tuple, Union
# At present, I don't understand how to tell mypy about ast.Node
# import ast
# Node = ast.Node

Node = Any
</t>
<t tx="ekr.20241212164559.182">The directory to which stub files are written.</t>
<t tx="ekr.20241212164559.183"></t>
<t tx="ekr.20241212164559.185">True: dynamically loads plugins in @plugin nodes when a window is created.</t>
<t tx="ekr.20241212164559.186"></t>
<t tx="ekr.20241212164559.187"></t>
<t tx="ekr.20241212164559.188"></t>
<t tx="ekr.20241212164559.189"></t>
<t tx="ekr.20241212164559.19">'''
A template for demonstrations based on plugins/demo.py.
The demo;; abbreviation will create this tree.
'''
&lt;&lt; imports &gt;&gt;
@others
# Use the *same* command/key binding for demo-start and demo.next.
try:
    if getattr(g.app, 'demo', None):
        g.app.demo.next()
    else:
        g.cls()
        print('starting demo')
        demo = MyDemo(c, trace=False)
        demo.bind('callout', callout)
        demo.bind('title', title)
        demo.start(script_string=script_string)
except Exception:
    g.app.demo = None
    raise
</t>
<t tx="ekr.20241212164559.190"></t>
<t tx="ekr.20241212164559.191"># True: show vr pane when opening a file.</t>
<t tx="ekr.20241212164559.192"># True: hide the vr pane for text-only renderings.</t>
<t tx="ekr.20241212164559.193"></t>
<t tx="ekr.20241212164559.194"></t>
<t tx="ekr.20241212164559.195"># regex patterns for text to be hidden by the wikiview plugin
# Blanks lines and lines starting with '#' are comment lines.

# Each non-comment line represents a pattern.
# Use \b# for patterns starting with '#'
# Only NON `groups` parts of the pattern in parentheses will be shown.
# The first character of the pattern (not counting \b) is the leadin character.
# The pattern will be applied only for strings starting with the leadin character.

# UNLs

\bunl:(//.*#.*--&gt;).*
\bunl:(//.*#).*
\bunl:(//.*--&gt;).*
\bunl:(//).*
\bfile:(//.*--&gt;).*
\bhttps?:(//.*--&gt;).*
## \bfile:(//.*--&gt;)\S+\b
## \bhttps?:(//.*--&gt;)\S+\b

# regular urls

\bhttps?:(//.*/)\w+\b
\bfile:(//.*/)\w+\b

# restructuredText `Visible text &lt;http://invisible.url/here&gt;`

(`)\S+(\s*&lt;https?://\S+&gt;`_)
(`)\S+(\s*&lt;file://\S+&gt;`_)

# Test patterns: see http://pythex.org/

# unl://leoSettings.leo#@settings--&gt;Plugins--&gt;wikiview plugin
# unl://ekr.leo#Startup--&gt;@settings--&gt;@@data global-abbreviations
# unl://#Startup--&gt;@settings--&gt;@@data global-abbreviations
# unl://Startup--&gt;@settings--&gt;@@data global-abbreviations
# file://Startup--&gt;@settings
# file://#some--&gt;headlines--&gt;mynode
# http://#some--&gt;headlines--&gt;mynode
# https://#some--&gt;headlines--&gt;mynode
# http://www.google.com/search
# https://www.google.com/search
# file://www.google.com/search
# `Python &lt;https://www.python.org/&gt;`_ 
# `Python &lt;file://www.python.org/&gt;`_ 
</t>
<t tx="ekr.20241212164559.196">Should wikiview mode be active by default?</t>
<t tx="ekr.20241212164559.197"></t>
<t tx="ekr.20241212164559.199"></t>
<t tx="ekr.20241212164559.20">if c.isChanged(): c.save()
import imp
from leo.core.leoQt import QtGui
import leo.plugins.demo as demo_module
imp.reload(demo_module)</t>
<t tx="ekr.20241212164559.200"></t>
<t tx="ekr.20241212164559.201"></t>
<t tx="ekr.20241212164559.202"></t>
<t tx="ekr.20241212164559.203"></t>
<t tx="ekr.20241212164559.204">Only difference from myLeoSettings.leo

Note: EKRWinowsDark.leo defines comment1_font

All three @color settings work.
The @font setting does not work.
</t>
<t tx="ekr.20241212164559.205">Bold</t>
<t tx="ekr.20241212164559.206">Italics</t>
<t tx="ekr.20241212164559.207"></t>
<t tx="ekr.20241212164559.208"># bold keywords defined in forth-bold-words</t>
<t tx="ekr.20241212164559.209"></t>
<t tx="ekr.20241212164559.21"># A short example. Change as needed.
script_string = '''\
callout('Callout 1 centered')
title('This is title 1')
###
callout('Callout 2 (700, 200)', position=[700, 200])
title('This is title 2')
demo.next()
'''
</t>
<t tx="ekr.20241212164559.210"># Note: the default font size is 12.
rest_comment1_family = None
rest_comment1_size = 12pt
rest_comment1_slant = italic
rest_comment1_weight = None
</t>
<t tx="ekr.20241212164559.211">These must be @string settings, even though they do affect colors.</t>
<t tx="ekr.20241212164559.212">solarized blue: #268bd2</t>
<t tx="ekr.20241212164559.213">solarized-red = #dc322f</t>
<t tx="ekr.20241212164559.214"></t>
<t tx="ekr.20241212164559.215">solarized blue: #268bd2</t>
<t tx="ekr.20241212164559.216"># Note: Use jj instead of escape to end insert mode.</t>
<t tx="ekr.20241212164559.22">class MyDemo (demo_module.Demo):
    
    def setup_script(self):
        '''Delete all previously shown widgets.'''
        self.delete_widgets()</t>
<t tx="ekr.20241212164559.23">def callout(text, **keys):
    w = demo_module.Callout(text, **keys)
    
def title(text, **keys):
    w = demo_module.Title(text, **keys)
</t>
<t tx="ekr.20241212164559.24"></t>
<t tx="ekr.20241212164559.25">&lt;&lt; docstring &gt;&gt;
### From leoSettings.leo
# Created 2017/05/30
@language python
@tabwidth -4
__version__ = '0.0'
&lt;&lt; version history &gt;&gt;
&lt;&lt; imports &gt;&gt;
@others</t>
<t tx="ekr.20241212164559.26">'''
&lt;|docstring|&gt;
'''
</t>
<t tx="ekr.20241212164559.27">@
Put notes about each version here.
&lt;|Initial version notes|&gt;</t>
<t tx="ekr.20241212164559.28">import leo.core.leoGlobals as g

&lt;|imports|&gt;</t>
<t tx="ekr.20241212164559.29">def init ():
        
    ok = g.app.gui.guiName() in ('qt','qttabs')
    if ok:
        if 1: # Create the commander class *before* the frame is created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Create the commander class *after* the frame is created.
            g.registerHandler('after-create-leo-frame',onCreate)
        g.plugin_signon(__name__)   
    return ok
</t>
<t tx="ekr.20241212164559.299"></t>
<t tx="ekr.20241212164559.3" __bookmarks="7d7100580700000069735f6475706571014930300a732e">@language rest
@wrap

The @settings tree contains all active settings. 

Settings outside this tree have no effect.</t>
<t tx="ekr.20241212164559.30">def onCreate (tag, keys):
    
    c = keys.get('c')
    if c:
        thePluginController = pluginController(c)
</t>
<t tx="ekr.20241212164559.300">Set to True to enable node appearance modifications
See tree-declutter-patterns
</t>
<t tx="ekr.20241212164559.302"></t>
<t tx="ekr.20241212164559.305">exec-py-file
import-ipynb
</t>
<t tx="ekr.20241212164559.306"># legacy: (default) Leo's legacy layout
# big-tree: replaces @bool big-outline-pane
# horizontal-thirds: VR &amp; VR3 panes at bottom.</t>
<t tx="ekr.20241212164559.307" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032312d30332d33307103752e"> # Recommended plugins, from leoSettings.leo:

plugins_menu.py
contextmenu.py      # Required by the vim.py and xemacs.py plugins.
mod_scripting.py
nav_qt.py
viewrendered.py
</t>
<t tx="ekr.20241212164559.31">class &lt;|Controller Class Name|&gt;:
    
    @others</t>
<t tx="ekr.20241212164559.32">def __init__ (self,c):
    
    self.c = c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
    &lt;|ivars|&gt;</t>
<t tx="ekr.20241212164559.33"></t>
<t tx="ekr.20241212164559.34">'''
The @auto importer for the {|{x=get_language()}|} language.

Created {|{x=time.strftime("%Y/%m/%d")}|} by the `importer;;` abbreviation.
'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {|{x=cap_name}|}_Importer,
    'extensions': [&lt;|comma-separated lists of extensions|&gt;],
        # Example: ['.c', '.cc', '.c++', '.cpp', '.cxx', '.h', '.h++']
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20241212164559.35">class {|{x=cap_name}|}_Importer(Importer):
    '''The importer for the {|{x=name}|} language.'''

    def __init__(self, importCommands):
        '''{|{x=cap_name}|}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            language = '{|{x=name}|}',
            state_class = {|{x=cap_name}|}_ScanState,
            strict = &lt;|True leading whitespace is significant. Otherwise False|&gt;,
        )
        
    @others
</t>
<t tx="ekr.20241212164559.36"># These can be overridden in subclasses.
</t>
<t tx="ekr.20241212164559.37">### define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
# A more complex example, for the C language.

# def clean_headline(self, s):
    # '''Return a cleaned up headline s.'''
    # import re
    # type1 = r'(static|extern)*'
    # type2 = r'(void|int|float|double|char)*'
    # class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
    # pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
    # m = re.match(class_pattern, s)
    # if m:
        # prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
        # return '%sclass %s' % (prefix1, m.group(2))
    # m = re.match(pattern, s)
    # if m:
        # prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
        # prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
        # h = m.group(3) or '&lt;no c function name&gt;'
        # return '%s%s%s' % (prefix1, prefix2, h)
    # else:
        # return s
</t>
<t tx="ekr.20241212164559.38">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an example.
    '''
    pass
</t>
<t tx="ekr.20241212164559.39">class {|{x=cap_name}|}_ScanState:
    '''A class representing the state of the {|{x=name}|} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{|{x=cap_name}|}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{|{x=cap_name}|}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{|{x=cap_name}|}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others

</t>
<t tx="ekr.20241212164559.4"></t>
<t tx="ekr.20241212164559.40">def level(self):
    '''{|{x=cap_name}|}_ScanState.level.'''
    return &lt;|self.curlies|&gt;
        ### Examples:
        # self.indent # for python, coffeescript.
        # self.curlies
        # (self, curlies, self.parens)
</t>
<t tx="ekr.20241212164559.41">def update(self, data):
    '''
    {|{x=cap_name}|}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {|{x=cap_name}|}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20241212164559.42"></t>
<t tx="ekr.20241212164559.43"></t>
<t tx="ekr.20241212164559.44">True: same as recent_files_group, except that even files (basenames) which are unique
have their containing path listed in the submenu - so visual clutter is reduced
but you can still see where things come from before you load them.

False: don't use submenus for multiple path entries, unless recent_files_group
is true (and recent_files_omit_directories is False)
</t>
<t tx="ekr.20241212164559.45"></t>
<t tx="ekr.20241212164559.46">True: show user tips on startup.</t>
<t tx="ekr.20241212164559.47"></t>
<t tx="ekr.20241212164559.48"></t>
<t tx="ekr.20241212164559.49"></t>
<t tx="ekr.20241212164559.5"></t>
<t tx="ekr.20241212164559.50"></t>
<t tx="ekr.20241212164559.51"></t>
<t tx="ekr.20241212164559.52">vertical (v) or horizontal (h)

myLeoSettings.leo: vertical</t>
<t tx="ekr.20241212164559.7"></t>
<t tx="ekr.20241212164559.8"># This node contains the commands needed to execute a program in a particular language.

# Format: language-name: command

# Create a temporary file if c.p is not any kind of @&lt;file&gt; node.

# Compute the final command as follows:

# 1. If command contains &lt;FILE&gt;, replace &lt;FILE&gt; with the full path to the external file.
# 2. If command contains &lt;NO-FILE&gt;, just remove &lt;NO-FILE&gt;.
# 3. Otherwise, append the full path to the external file to the command.

go: go run . &lt;NO-FILE&gt;
python: python
rust: rustc
</t>
<t tx="ekr.20241212164559.9"># This node contains the regex pattern to determine the line number in error messages.
# Format: language-name: regex pattern
#
# Patterns must define two groups, in either order:
# One group, containing only digits, defines the line number.
# The other group defines the file name.

go: ^\s*(.*):([0-9]+):([0-9]+):.+$
python: ^\s*File "(.+)", line ([0-9]+), in .+$
rust: ^\s*--&gt; (.+):([0-9]+):([0-9]+)\s*$</t>
<t tx="ekr.20241213022535.1"></t>
<t tx="ekr.20241213022535.101">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

n = 256
w = np.exp(-1j * 2 * np.pi / n)

</t>
<t tx="ekr.20241213022535.102">DFT = np.zeros((n,n))

# Slow
for i in range(n):
    for k in range(n):
        DFT[i,k] = w**(i*k)
        
DFT = np.real(DFT)
        
plt.imshow(DFT)
plt.show()

</t>
<t tx="ekr.20241213022535.103"># Fast
J,K = np.meshgrid(np.arange(n),np.arange(n))
DFT = np.power(w,J*K)
DFT = np.real(DFT)
       
plt.imshow(DFT)
plt.show()

</t>
<t tx="ekr.20241213022535.104"></t>
<t tx="ekr.20241213022535.105">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.107">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [16, 12]
plt.rcParams.update({'font.size': 18})

# Create a simple signal with two frequencies
dt = 0.001
t = np.arange(0,1,dt)
f = np.sin(2*np.pi*50*t) + np.sin(2*np.pi*120*t) # Sum of 2 frequencies
f_clean = f
f = f + 2.5*np.random.randn(len(t))              # Add some noise

</t>
<t tx="ekr.20241213022535.108">## Compute the Fast Fourier Transform (FFT)

n = len(t)
fhat = np.fft.fft(f,n)                     # Compute the FFT
PSD = fhat * np.conj(fhat) / n             # Power spectrum (power per freq)
freq = (1/(dt*n)) * np.arange(n)           # Create x-axis of frequencies in Hz
L = np.arange(1,np.floor(n/2),dtype='int') # Only plot the first half of freqs


</t>
<t tx="ekr.20241213022535.109">## Use the PSD to filter out noise
indices = PSD &gt; 100       # Find all freqs with large power
PSDclean = PSD * indices  # Zero out all others
fhat = indices * fhat     # Zero out small Fourier coeffs. in Y
ffilt = np.fft.ifft(fhat) # Inverse FFT for filtered time signal

</t>
<t tx="ekr.20241213022535.11">import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
plt.rcParams['figure.figsize'] = [16, 8]
plt.rcParams.update({'font.size': 18})

theta = np.array([np.pi/15, -np.pi/9, -np.pi/20])
Sigma = np.diag([3, 1, 0.5]) # scale x, then y, then z

# Rotation about x axis
Rx = np.array([[1, 0, 0],
               [0, np.cos(theta[0]), -np.sin(theta[0])],
               [0, np.sin(theta[0]), np.cos(theta[0])]])

# Rotation about y axis
Ry = np.array([[np.cos(theta[1]), 0, np.sin(theta[1])],
               [0, 1, 0],
               [-np.sin(theta[1]), 0, np.cos(theta[1])]])

# Rotation about z axis
Rz = np.array([[np.cos(theta[2]), -np.sin(theta[2]), 0],
               [np.sin(theta[2]), np.cos(theta[2]), 0],
               [0, 0, 1]])

# Rotate and scale
X = Rz @ Ry @ Rx @ Sigma

</t>
<t tx="ekr.20241213022535.110">## Plots
fig,axs = plt.subplots(3,1)

plt.sca(axs[0])
plt.plot(t,f,color='r',LineWidth=1.5,label='Noisy')
plt.plot(t,f_clean,color='k',LineWidth=2,label='Clean')
plt.xlim(t[0],t[-1])
plt.legend()

plt.sca(axs[1])
plt.plot(t,f_clean,color='k',LineWidth=1.5,label='Clean')
plt.plot(t,ffilt,color='b',LineWidth=2,label='Filtered')
plt.xlim(t[0],t[-1])
plt.legend()

plt.sca(axs[2])
plt.plot(freq[L],PSD[L],color='r',LineWidth=2,label='Noisy')
plt.plot(freq[L],PSDclean[L],color='b',LineWidth=1.5,label='Filtered')
plt.xlim(freq[L[0]],freq[L[-1]])
plt.legend()

plt.show()
</t>
<t tx="ekr.20241213022535.111">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.113">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})


n = 128
L = 30
dx = L/n
x = np.arange(-L/2,L/2,dx,dtype='complex_')
f = np.cos(x) * np.exp(-np.power(x,2)/25) # Function
df = -(np.sin(x) * np.exp(-np.power(x,2)/25) + (2/25)*x*f) # Derivative

</t>
<t tx="ekr.20241213022535.114">## Approximate derivative using finite difference
dfFD = np.zeros(len(df),dtype='complex_')
for kappa in range(len(df)-1):
    dfFD[kappa] = (f[kappa+1]-f[kappa])/dx
    
dfFD[-1] = dfFD[-2]

</t>
<t tx="ekr.20241213022535.115">## Derivative using FFT (spectral derivative)
fhat = np.fft.fft(f)
kappa = (2*np.pi/L)*np.arange(-n/2,n/2)
kappa = np.fft.fftshift(kappa) # Re-order fft frequencies
dfhat = kappa * fhat * (1j)
dfFFT = np.real(np.fft.ifft(dfhat))


</t>
<t tx="ekr.20241213022535.116">## Plots
plt.plot(x,df.real,color='k',LineWidth=2,label='True Derivative')
plt.plot(x,dfFD.real,'--',color='b',LineWidth=1.5,label='Finite Diff.')
plt.plot(x,dfFFT.real,'--',color='r',LineWidth=1.5,label='FFT Derivative')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022535.117"></t>
<t tx="ekr.20241213022535.118">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.12"># Plot sphere
fig = plt.figure()
ax1 = fig.add_subplot(121, projection='3d')
u = np.linspace(-np.pi, np.pi, 100)
v = np.linspace(0, np.pi, 100)
x = np.outer(np.cos(u), np.sin(v))
y = np.outer(np.sin(u), np.sin(v))
z = np.outer(np.ones(np.size(u)), np.cos(v))

# Plot the surface
surf1 = ax1.plot_surface(x, y, z, cmap='jet',alpha=0.6,facecolors=plt.cm.jet(z),linewidth=0.5,rcount=30,ccount=30)
surf1.set_edgecolor('k')
ax1.set_xlim3d(-2, 2)
ax1.set_ylim3d(-2, 2)
ax1.set_zlim3d(-2, 2)

xR = np.zeros_like(x)
yR = np.zeros_like(y)
zR = np.zeros_like(z)

for i in range(x.shape[0]):
    for j in range(x.shape[1]):
        vec = [x[i,j], y[i,j], z[i,j]]
        vecR = X @ vec
        xR[i,j] = vecR[0]
        yR[i,j] = vecR[1]
        zR[i,j] = vecR[2]
        
ax2 = fig.add_subplot(122, projection='3d')
surf2 = ax2.plot_surface(xR, yR, zR, cmap='jet',alpha=0.6,linewidth=0.5,facecolors=plt.cm.jet(z),rcount=30,ccount=30)
surf2.set_edgecolor('k')
ax2.set_xlim3d(-2, 2)
ax2.set_ylim3d(-2, 2)
ax2.set_zlim3d(-2, 2)
plt.show()

</t>
<t tx="ekr.20241213022535.120">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import axes3d
plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

a = 1    # Thermal diffusivity constant
L = 100  # Length of domain
N = 1000 # Number of discretization points
dx = L/N
x = np.arange(-L/2,L/2,dx) # Define x domain

# Define discrete wavenumbers
kappa = 2*np.pi*np.fft.fftfreq(N, d=dx)

# Initial condition
u0 = np.zeros_like(x)
u0[int((L/2 - L/10)/dx):int((L/2 + L/10)/dx)] = 1
u0hat = np.fft.fft(u0)

# SciPy's odeint function doesn't play well with complex numbers, so we recast 
# the state u0hat from an N-element complex vector to a 2N-element real vector
u0hat_ri = np.concatenate((u0hat.real,u0hat.imag))

# Simulate in Fourier frequency domain
dt = 0.1
t = np.arange(0,10,dt)

def rhsHeat(uhat_ri,t,kappa,a):
    uhat = uhat_ri[:N] + (1j) * uhat_ri[N:]
    d_uhat = -a**2 * (np.power(kappa,2)) * uhat
    d_uhat_ri = np.concatenate((d_uhat.real,d_uhat.imag)).astype('float64')
    return d_uhat_ri

uhat_ri = odeint(rhsHeat, u0hat_ri, t, args=(kappa,a))

uhat = uhat_ri[:,:N] + (1j) * uhat_ri[:,N:]

u = np.zeros_like(uhat)

for k in range(len(t)):
    u[k,:] = np.fft.ifft(uhat[k,:])

u = u.real    

# Waterfall plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

u_plot = u[0:-1:10,:]
for j in range(u_plot.shape[0]):
    ys = j*np.ones(u_plot.shape[1])
    ax.plot(x,ys,u_plot[j,:])
    
# Image plot
plt.figure()
plt.imshow(np.flipud(u), aspect=8)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.121"></t>
<t tx="ekr.20241213022535.122">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.124">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import axes3d
plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

c = 2    # Wave speed
L = 20   # Length of domain
N = 1000 # Number of discretization points
dx = L/N
x = np.arange(-L/2,L/2,dx) # Define x domain

# Define discrete wavenumbers
kappa = 2*np.pi*np.fft.fftfreq(N, d=dx)

# Initial condition
u0 = 1/np.cosh(x)
u0hat = np.fft.fft(u0)

# SciPy's odeint function doesn't play well with complex numbers, so we recast 
# the state u0hat from an N-element complex vector to a 2N-element real vector
u0hat_ri = np.concatenate((u0hat.real,u0hat.imag))

# Simulate in Fourier frequency domain
dt = 0.025
t = np.arange(0,100*dt,dt)

def rhsWave(uhat_ri,t,kappa,c):
    uhat = uhat_ri[:N] + (1j) * uhat_ri[N:]
    d_uhat = -c*(1j)*kappa*uhat
    d_uhat_ri = np.concatenate((d_uhat.real,d_uhat.imag)).astype('float64')
    return d_uhat_ri

uhat_ri = odeint(rhsWave, u0hat_ri, t, args=(kappa,c))
uhat = uhat_ri[:,:N] + (1j) * uhat_ri[:,N:]

# Alternatively, simulate in spatial domain
def rhsWaveSpatial(u,t,kappa,c):
    uhat = np.fft.fft(u)
    d_uhat = (1j)*kappa*uhat
    d_u = np.fft.ifft(d_uhat).real
    du_dt = -c*d_u
    return du_dt

u = odeint(rhsWaveSpatial,u0,t,args=(kappa,c))

# Inverse FFT to bring back to spatial domain
u = np.zeros_like(uhat)

for k in range(len(t)):
    u[k,:] = np.fft.ifft(uhat[k,:])

u = u.real   


# Waterfall plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

u_plot = u[0:-1:10,:]
for j in range(u_plot.shape[0]):
    ys = j*np.ones(u_plot.shape[1])
    ax.plot(x,ys,u_plot[j,:])
    
# Image plot
plt.figure()
plt.imshow(np.flipud(u), aspect=8)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.125"></t>
<t tx="ekr.20241213022535.126">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.128">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import axes3d
plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

nu = 0.001 # Diffusion constant
L = 20     # Length of domain
N = 1000   # Number of discretization points
dx = L/N
x = np.arange(-L/2,L/2,dx) # Define x domain

# Define discrete wavenumbers
kappa = 2*np.pi*np.fft.fftfreq(N, d=dx)

# Initial condition
u0 = 1/np.cosh(x)

# Simulate PDE in spatial domain
dt = 0.025
t = np.arange(0,100*dt,dt)

def rhsBurgers(u,t,kappa,nu):
    uhat = np.fft.fft(u)
    d_uhat = (1j)*kappa*uhat
    dd_uhat = -np.power(kappa,2)*uhat
    d_u = np.fft.ifft(d_uhat)
    dd_u = np.fft.ifft(dd_uhat)
    du_dt = -u * d_u + nu*dd_u
    return du_dt.real

u = odeint(rhsBurgers,u0,t,args=(kappa,nu))

# Waterfall plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

u_plot = u[0:-1:10,:]
for j in range(u_plot.shape[0]):
    ys = j*np.ones(u_plot.shape[1])
    ax.plot(x,ys,u_plot[j,:])
    
# Image plot
plt.figure()
plt.imshow(np.flipud(u), aspect=8)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.129"></t>
<t tx="ekr.20241213022535.13"></t>
<t tx="ekr.20241213022535.130">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.132">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})

dt = 0.001
t = np.arange(0,2,dt)
f0 = 50
f1 = 250
t1 = 2
x = np.cos(2*np.pi*t*(f0 + (f1-f0)*np.power(t,2)/(3*t1**2)))

plt.specgram(x, NFFT=128, Fs=1/dt, noverlap=120,cmap='jet')
plt.colorbar()
plt.show()

</t>
<t tx="ekr.20241213022535.133"></t>
<t tx="ekr.20241213022535.134"></t>
<t tx="ekr.20241213022535.135">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.137">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})


x = np.arange(0,1,0.001)
n = len(x)
n2 = int(np.floor(n/2))
n4 = int(np.floor(n/4))

f10 = np.zeros_like(x)
f10[:n2] = 1
f10[n2:] = -1

f21 = np.zeros_like(x)
f21[:n4] = 1
f21[n4:n2] = -1
f21 = f21 * np.sqrt(2)

f22 = np.zeros_like(x)
f22[n2:(n2+n4)] = 1
f22[(n2+n4):] = -1
f22 = f22 * np.sqrt(2)

# x = np.concatenate((-1, 0, x, 1, 2))
x = np.append([-1,0],x)
x = np.append(x,[1,2])

f10 = np.pad(f10, (2, 2), 'constant')
f21 = np.pad(f21, (2, 2), 'constant')
f22 = np.pad(f22, (2, 2), 'constant')

fig,axs = plt.subplots(3,1)
axs[0].plot(x,f10,color='k',LineWidth=2)
axs[0].set_xlim(-0.2,1.2)
axs[0].set_ylim(-1.75,1.75)
axs[1].plot(x,f21,color='k',LineWidth=2)
axs[1].set_xlim(-0.2,1.2)
axs[1].set_ylim(-1.75,1.75)
axs[2].plot(x,f22,color='k',LineWidth=2)
axs[2].set_xlim(-0.2,1.2)
axs[2].set_ylim(-1.75,1.75)
plt.show()

</t>
<t tx="ekr.20241213022535.138">x = np.arange(-5,5,0.001)
fMexHat = (1-np.power(x,2)) * np.exp(-np.power(x,2)/2)
plt.plot(x,fMexHat,color='k',LineWidth=2)
plt.show()

</t>
<t tx="ekr.20241213022535.139"></t>
<t tx="ekr.20241213022535.14">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.140">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.142">from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

fig,axs = plt.subplots(1,3)

# Plot image
img = axs[0].imshow(B)
img.set_cmap('gray')
axs[0].axis('off')

# Compute row-wise FFT

Cshift = np.zeros_like(B,dtype='complex_')
C = np.zeros_like(B,dtype='complex_')

for j in range(B.shape[0]):
    Cshift[j,:] = np.fft.fftshift(np.fft.fft(B[j,:]))
    C[j,:] = np.fft.fft(B[j,:])
    
img = axs[1].imshow(np.log(np.abs(Cshift)))
img.set_cmap('gray')
axs[1].axis('off')

# Compute column-wise FFT

D = np.zeros_like(C)
for j in range(C.shape[1]):
    D[:,j] = np.fft.fft(C[:,j])

img = axs[2].imshow(np.fft.fftshift(np.log(np.abs(D))))
img.set_cmap('gray')
axs[2].axis('off')

plt.show()

# Much more efficient to use fft2
D = np.fft.fft2(B)

</t>
<t tx="ekr.20241213022535.143"></t>
<t tx="ekr.20241213022535.144">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.146">from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

Bt = np.fft.fft2(B)
Btsort = np.sort(np.abs(Bt.reshape(-1))) # sort by magnitude

# Zero out all small coefficients and inverse transform
for keep in (0.1, 0.05, 0.01, 0.002):
    thresh = Btsort[int(np.floor((1-keep)*len(Btsort)))]
    ind = np.abs(Bt)&gt;thresh          # Find small indices
    Atlow = Bt * ind                 # Threshold small indices
    Alow = np.fft.ifft2(Atlow).real  # Compressed image
    plt.figure()
    plt.imshow(Alow,cmap='gray')
    plt.axis('off')
    plt.title('Compressed image: keep = ' + str(keep))

</t>
<t tx="ekr.20241213022535.147"></t>
<t tx="ekr.20241213022535.148"></t>
<t tx="ekr.20241213022535.149">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.151">from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
plt.rcParams['figure.figsize'] = [16, 16]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

</t>
<t tx="ekr.20241213022535.152">## Denoise
Bnoise = B + 200*np.random.randn(*B.shape).astype('uint8') # Add some noise
Bt = np.fft.fft2(Bnoise)
Btshift = np.fft.fftshift(Bt)
F = np.log(np.abs(Btshift)+1) # Put FFT on log scale

fig,axs = plt.subplots(2,2)

axs[0,0].imshow(Bnoise,cmap='gray')
axs[0,0].axis('off')

axs[0,1].imshow(F,cmap='gray')
axs[0,1].axis('off')

nx,ny = B.shape
X,Y = np.meshgrid(np.arange(-ny/2+1,ny/2+1),np.arange(-nx/2+1,nx/2+1))
# xgrid = np.fft.ifftshift(np.arange(-nx/2+1,nx/2+1))
# ygrid = np.fft.ifftshift(np.arange(-ny/2+1,ny/2+1))
# X,Y = np.meshgrid(ygrid,xgrid)
R2 = np.power(X,2) + np.power(Y,2)
ind = R2 &lt; 150**2
Btshiftfilt = Btshift * ind
Ffilt = np.log(np.abs(Btshiftfilt)+1) # Put FFT on log scale

axs[1,1].imshow(Ffilt,cmap='gray')
axs[1,1].axis('off')

Btfilt = np.fft.ifftshift(Btshiftfilt)
Bfilt = np.fft.ifft2(Btfilt).real
axs[1,0].imshow(Bfilt,cmap='gray')
axs[1,0].axis('off')

plt.show()
</t>
<t tx="ekr.20241213022535.153">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.155"># Using the PyWavelets module, available at 
# https://pywavelets.readthedocs.io/en/latest/install.html

from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
import pywt
plt.rcParams['figure.figsize'] = [16, 16]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

</t>
<t tx="ekr.20241213022535.156">## Wavelet decomposition (2 level)
n = 2
w = 'db1'
coeffs = pywt.wavedec2(B,wavelet=w,level=n)

# normalize each coefficient array
coeffs[0] /= np.abs(coeffs[0]).max()
for detail_level in range(n):
    coeffs[detail_level + 1] = [d/np.abs(d).max() for d in coeffs[detail_level + 1]]

arr, coeff_slices = pywt.coeffs_to_array(coeffs)



plt.imshow(arr,cmap='gray',vmin=-0.25,vmax=0.75)
plt.show()
</t>
<t tx="ekr.20241213022535.157">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.159"># Using the PyWavelets module, available at 
# https://pywavelets.readthedocs.io/en/latest/install.html

from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
import pywt
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

</t>
<t tx="ekr.20241213022535.16">import matplotlib.pyplot as plt
import numpy as np
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

x = 3 # True slope
a = np.arange(-2,2,0.25)
a = a.reshape(-1, 1)
b = x*a + np.random.randn(*a.shape) # Add noise

plt.plot(a, x*a, Color='k', LineWidth=2, label='True line') # True relationship
plt.plot(a, b, 'x', Color='r', MarkerSize = 10, label='Noisy data') # Noisy measurements

U, S, VT = np.linalg.svd(a,full_matrices=False)
xtilde = VT.T @ np.linalg.inv(np.diag(S)) @ U.T @ b # Least-square fit

plt.plot(a,xtilde * a,'--',Color='b',LineWidth=4, label='Regression line')

plt.xlabel('a')
plt.ylabel('b')

plt.grid(linestyle='--')
plt.legend()
plt.show()


</t>
<t tx="ekr.20241213022535.160">## Wavelet Compression
n = 4
w = 'db1'
coeffs = pywt.wavedec2(B,wavelet=w,level=n)

coeff_arr, coeff_slices = pywt.coeffs_to_array(coeffs)

Csort = np.sort(np.abs(coeff_arr.reshape(-1)))

for keep in (0.1, 0.05, 0.01, 0.005):
    thresh = Csort[int(np.floor((1-keep)*len(Csort)))]
    ind = np.abs(coeff_arr) &gt; thresh
    Cfilt = coeff_arr * ind # Threshold small indices
    
    coeffs_filt = pywt.array_to_coeffs(Cfilt,coeff_slices,output_format='wavedec2')
    
    # Plot reconstruction
    Arecon = pywt.waverec2(coeffs_filt,wavelet=w)
    plt.figure()
    plt.imshow(Arecon.astype('uint8'),cmap='gray')
    plt.axis('off')
    plt.title('keep = ' + str(keep))

</t>
<t tx="ekr.20241213022535.161"></t>
<t tx="ekr.20241213022535.162">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.164">from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
from mpl_toolkits.mplot3d import Axes3D
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','jelly.jpg'))
Abw = np.mean(A, -1); # Convert RGB to grayscale

plt.imshow(Abw,cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.165">## Compute FFT of image using fft2
At = np.fft.fft2(Abw)
F = np.log(np.abs(np.fft.fftshift(At))+1) # Put FFT on log scale
plt.imshow(F,cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.166">## Zero out all small coefficients and inverse transform
Bt = np.sort(np.abs(np.reshape(At,-1)))
keep = 0.05
thresh = Bt[int(np.floor((1-keep)*len(Bt)))]
ind = np.abs(At) &gt; thresh
Atlow = At * ind
Flow = np.log(np.abs(np.fft.fftshift(Atlow))+1) # Put FFT on log scale

plt.imshow(Flow,cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.167">## Plot Reconstruction
Alow = np.fft.ifft2(Atlow).astype('uint8')

plt.imshow(Alow,cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.168">plt.rcParams['figure.figsize'] = [16, 8]

fig = plt.figure()
ax1 = fig.add_subplot(1, 2, 1, projection='3d')
ax2 = fig.add_subplot(1, 2, 2, projection='3d')

Anew = Abw[::5,::5]

y = np.arange(Anew.shape[0])
x = np.arange(Anew.shape[1])

X,Y = np.meshgrid(x,y)

surf1 = ax1.plot_surface(X,Y,Anew, rstride=1, cstride=1,cmap='jet',
                       linewidth=1, antialiased=False)
surf2 = ax2.plot_surface(X,Y,Anew, rstride=1, cstride=1,cmap='jet',
                       linewidth=1, antialiased=False)

ax1.view_init(90, 90) 
ax1.axis('off')

ax2.view_init(60, 90) 
ax2.axis('off')

plt.show()

</t>
<t tx="ekr.20241213022535.169"></t>
<t tx="ekr.20241213022535.17"># Three methods of computing regression

xtilde1 = VT.T @ np.linalg.inv(np.diag(S)) @ U.T @ b
xtilde2 = np.linalg.pinv(a) @ b

# The third method is specific to Matlab:
# xtilde3 = regress(b,a)
</t>
<t tx="ekr.20241213022535.170"></t>
<t tx="ekr.20241213022535.18">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.2"></t>
<t tx="ekr.20241213022535.20">import matplotlib.pyplot as plt
import numpy as np
import os
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

# Load dataset
A = np.loadtxt(os.path.join('..','DATA','hald_ingredients.csv'),delimiter=',')
b = np.loadtxt(os.path.join('..','DATA','hald_heat.csv'),delimiter=',')

# Solve Ax=b using SVD
U, S, VT = np.linalg.svd(A,full_matrices=0)
x = VT.T @ np.linalg.inv(np.diag(S)) @ U.T @ b

plt.plot(b, Color='k', LineWidth=2, label='Heat Data') # True relationship
plt.plot(A@x, '-o', Color='r', LineWidth=1.5, MarkerSize=6, label='Regression')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022535.21"># Alternative Methods:

# The first alternative is specific to Matlab:
# x = regress(b,A)

# Alternative 2:
x = np.linalg.pinv(A)*b

</t>
<t tx="ekr.20241213022535.22"></t>
<t tx="ekr.20241213022535.23">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.25">import matplotlib.pyplot as plt
import numpy as np
import os
plt.rcParams['figure.figsize'] = [16, 8]
plt.rcParams.update({'font.size': 18})

# Load dataset
H = np.loadtxt(os.path.join('..','DATA','housing.data'))
b = H[:,-1] # housing values in $1000s
A = H[:,:-1] # other factors

# Pad with ones for nonzero offset
A = np.pad(A,[(0,0),(0,1)],mode='constant',constant_values=1)


# Solve Ax=b using SVD
# Note that the book uses the Matlab-specific "regress" command
U, S, VT = np.linalg.svd(A,full_matrices=0)
x = VT.T @ np.linalg.inv(np.diag(S)) @ U.T @ b

fig = plt.figure()
ax1 = fig.add_subplot(121)

plt.plot(b, Color='k', LineWidth=2, label='Housing Value') # True relationship
plt.plot(A@x, '-o', Color='r', LineWidth=1.5, MarkerSize=6, label='Regression')
plt.xlabel('Neighborhood')
plt.ylabel('Median Home Value [$1k]')
plt.legend()

ax2 = fig.add_subplot(122)
sort_ind = np.argsort(H[:,-1])
b = b[sort_ind] # sorted values
plt.plot(b, Color='k', LineWidth=2, label='Housing Value') # True relationship
plt.plot(A[sort_ind,:]@x, '-o', Color='r', LineWidth=1.5, MarkerSize=6, label='Regression')
plt.xlabel('Neighborhood')
plt.legend()

plt.show()

</t>
<t tx="ekr.20241213022535.26">A_mean = np.mean(A,axis=0)
A_mean = A_mean.reshape(-1, 1)

A2 = A - np.ones((A.shape[0],1)) @ A_mean.T

for j in range(A.shape[1]-1):
    A2std = np.std(A2[:,j])
    A2[:,j] = A2[:,j]/A2std
    
A2[:,-1] = np.ones(A.shape[0])

U, S, VT = np.linalg.svd(A2,full_matrices=0)
x = VT.T @ np.linalg.inv(np.diag(S)) @ U.T @ b
x_tick = range(len(x)-1)+np.ones(len(x)-1)
plt.bar(x_tick,x[:-1])
plt.xlabel('Attribute')
plt.ylabel('Significance')
plt.xticks(x_tick)
plt.show()

</t>
<t tx="ekr.20241213022535.27">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.29">import matplotlib.pyplot as plt
import numpy as np
plt.rcParams['figure.figsize'] = [16, 8]

xC = np.array([2, 1])      # Center of data (mean)
sig = np.array([2, 0.5])   # Principal axes

theta = np.pi/3            # Rotate cloud by pi/3

R = np.array([[np.cos(theta), -np.sin(theta)],     # Rotation matrix
              [np.sin(theta), np.cos(theta)]])

nPoints = 10000            # Create 10,000 points
X = R @ np.diag(sig) @ np.random.randn(2,nPoints) + np.diag(xC) @ np.ones((2,nPoints))

fig = plt.figure()
ax1 = fig.add_subplot(121)
ax1.plot(X[0,:],X[1,:], '.', Color='k')
ax1.grid()
plt.xlim((-6, 8))
plt.ylim((-6,8))

## f_ch01_ex03_1b

Xavg = np.mean(X,axis=1)                  # Compute mean
B = X - np.tile(Xavg,(nPoints,1)).T       # Mean-subtracted data

# Find principal components (SVD)
U, S, VT = np.linalg.svd(B/np.sqrt(nPoints),full_matrices=0)

ax2 = fig.add_subplot(122)
ax2.plot(X[0,:],X[1,:], '.', Color='k')   # Plot data to overlay PCA
ax2.grid()
plt.xlim((-6, 8))
plt.ylim((-6,8))

theta = 2 * np.pi * np.arange(0,1,0.01)

# 1-std confidence interval
Xstd = U @ np.diag(S) @ np.array([np.cos(theta),np.sin(theta)])

ax2.plot(Xavg[0] + Xstd[0,:], Xavg[1] + Xstd[1,:],'-',color='r',LineWidth=3)
ax2.plot(Xavg[0] + 2*Xstd[0,:], Xavg[1] + 2*Xstd[1,:],'-',color='r',LineWidth=3)
ax2.plot(Xavg[0] + 3*Xstd[0,:], Xavg[1] + 3*Xstd[1,:],'-',color='r',LineWidth=3)

# Plot principal components U[:,0]S[0] and U[:,1]S[1]
ax2.plot(np.array([Xavg[0], Xavg[0]+U[0,0]*S[0]]),
         np.array([Xavg[1], Xavg[1]+U[1,0]*S[0]]),'-',color='cyan',LineWidth=5)
ax2.plot(np.array([Xavg[0], Xavg[0]+U[0,1]*S[1]]),
         np.array([Xavg[1], Xavg[1]+U[1,1]*S[1]]),'-',color='cyan',LineWidth=5)

plt.show()

</t>
<t tx="ekr.20241213022535.3">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.30"></t>
<t tx="ekr.20241213022535.31">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.33">import matplotlib.pyplot as plt
import numpy as np
import os
from mpl_toolkits.mplot3d import Axes3D
plt.rcParams['figure.figsize'] = [16, 8]
plt.rcParams.update({'font.size': 18})


obs = np.loadtxt(os.path.join('..','DATA','ovariancancer_obs.csv'),delimiter=',')

f = open(os.path.join('..','DATA','ovariancancer_grp.csv'), "r")
grp = f.read().split("\n")

U, S, VT = np.linalg.svd(obs,full_matrices=0)

fig1 = plt.figure()
ax1 = fig1.add_subplot(121)
ax1.semilogy(S,'-o',color='k')
ax2 = fig1.add_subplot(122)
ax2.plot(np.cumsum(S)/np.sum(S),'-o',color='k')

plt.show()

</t>
<t tx="ekr.20241213022535.34">fig2 = plt.figure()
ax = fig2.add_subplot(111, projection='3d')

for j in range(obs.shape[0]):
    x = VT[0,:] @ obs[j,:].T
    y = VT[1,:] @ obs[j,:].T
    z = VT[2,:] @ obs[j,:].T
    
    if grp[j] == 'Cancer':
        ax.scatter(x,y,z,marker='x',color='r',s=50)
    else:
        ax.scatter(x,y,z,marker='o',color='b',s=50)

ax.view_init(25,20)
plt.show()
</t>
<t tx="ekr.20241213022535.35">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.37">import matplotlib.pyplot as plt
import numpy as np
import os
import scipy.io
plt.rcParams['figure.figsize'] = [10, 10]
plt.rcParams.update({'font.size': 18})

mat_contents = scipy.io.loadmat(os.path.join('..','DATA','allFaces.mat'))
faces = mat_contents['faces']
m = int(mat_contents['m'])
n = int(mat_contents['n'])
nfaces = np.ndarray.flatten(mat_contents['nfaces'])

allPersons = np.zeros((n*6,m*6))
count = 0

for j in range(6):
    for k in range(6):
        allPersons[j*n : (j+1)*n, k*m : (k+1)*m] = np.reshape(faces[:,np.sum(nfaces[:count])],(m,n)).T
        count += 1
        
img = plt.imshow(allPersons)
img.set_cmap('gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.38">for person in range(len(nfaces)):
    subset = faces[:,sum(nfaces[:person]) : sum(nfaces[:(person+1)])]
    allFaces = np.zeros((n*8,m*8))
    
    count = 0
    
    for j in range(8):
        for k in range(8):
            if count &lt; nfaces[person]:
                allFaces[j*n:(j+1)*n,k*m:(k+1)*m] = np.reshape(subset[:,count],(m,n)).T
                count += 1
                
    img = plt.imshow(allFaces)
    img.set_cmap('gray')
    plt.axis('off')
    plt.show()
</t>
<t tx="ekr.20241213022535.39">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.41">import matplotlib.pyplot as plt
import numpy as np
import os
import scipy.io
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

mat_contents = scipy.io.loadmat(os.path.join('..','DATA','allFaces.mat'))
faces = mat_contents['faces']
m = int(mat_contents['m'])
n = int(mat_contents['n'])
nfaces = np.ndarray.flatten(mat_contents['nfaces'])

# We use the first 36 people for training data
trainingFaces = faces[:,:np.sum(nfaces[:36])]
avgFace = np.mean(trainingFaces,axis=1) # size n*m by 1

# Compute eigenfaces on mean-subtracted training data
X = trainingFaces - np.tile(avgFace,(trainingFaces.shape[1],1)).T
U, S, VT = np.linalg.svd(X,full_matrices=0)

fig1 = plt.figure()
ax1 = fig1.add_subplot(121)
img_avg = ax1.imshow(np.reshape(avgFace,(m,n)).T)
img_avg.set_cmap('gray')
plt.axis('off')

ax2 = fig1.add_subplot(122)
img_u1 = ax2.imshow(np.reshape(U[:,0],(m,n)).T)
img_u1.set_cmap('gray')
plt.axis('off')

plt.show()

</t>
<t tx="ekr.20241213022535.42">## Now show eigenface reconstruction of image that was omitted from test set

testFace = faces[:,np.sum(nfaces[:36])] # First face of person 37
plt.imshow(np.reshape(testFace,(m,n)).T)
plt.set_cmap('gray')
plt.title('Original Image')
plt.axis('off')
plt.show()

testFaceMS = testFace - avgFace
r_list = [25, 50, 100, 200, 400, 800, 1600]

for r in r_list:
    reconFace = avgFace + U[:,:r]  @ U[:,:r].T @ testFaceMS
    img = plt.imshow(np.reshape(reconFace,(m,n)).T)
    img.set_cmap('gray')
    plt.title('r = ' + str(r))
    plt.axis('off')
    plt.show()

</t>
<t tx="ekr.20241213022535.43">## Project person 2 and 7 onto PC5 and PC6

P1num = 2 # Person number 2
P2num = 7 # Person number 7

P1 = faces[:,np.sum(nfaces[:(P1num-1)]):np.sum(nfaces[:P1num])]
P2 = faces[:,np.sum(nfaces[:(P2num-1)]):np.sum(nfaces[:P2num])]

P1 = P1 - np.tile(avgFace,(P1.shape[1],1)).T
P2 = P2 - np.tile(avgFace,(P2.shape[1],1)).T

PCAmodes = [5, 6] # Project onto PCA modes 5 and 6
PCACoordsP1 = U[:,PCAmodes-np.ones_like(PCAmodes)].T @ P1
PCACoordsP2 = U[:,PCAmodes-np.ones_like(PCAmodes)].T @ P2

plt.plot(PCACoordsP1[0,:],PCACoordsP1[1,:],'d',Color='k',label='Person 2')
plt.plot(PCACoordsP2[0,:],PCACoordsP2[1,:],'^',Color='r',label='Person 7')

plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022535.44"></t>
<t tx="ekr.20241213022535.45">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.47">import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

t = np.arange(-3,3,0.01)

Utrue = np.array([np.cos(17*t) * np.exp(-t**2), np.sin(11*t)]).T
Strue = np.array([[2, 0],[0, 0.5]])
Vtrue = np.array([np.sin(5*t) * np.exp(-t**2), np.cos(13*t)]).T

X = Utrue @ Strue @ Vtrue.T

plt.imshow(X)
plt.set_cmap('gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.48">sigma = 1
Xnoisy = X + sigma*np.random.randn(*X.shape)
plt.imshow(Xnoisy)
plt.set_cmap('gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.49">U, S, VT = np.linalg.svd(Xnoisy,full_matrices=0)
N = Xnoisy.shape[0]
cutoff = (4/np.sqrt(3)) * np.sqrt(N) * sigma # Hard threshold
r = np.max(np.where(S &gt; cutoff)) # Keep modes w/ sig &gt; cutoff 

Xclean = U[:,:(r+1)] @ np.diag(S[:(r+1)]) @ VT[:(r+1),:]
plt.imshow(Xclean)
plt.set_cmap('gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.5">from matplotlib.image import imread
import matplotlib.pyplot as plt
import numpy as np
import os

# c:/Users/Data is the data folder.
</t>
<t tx="ekr.20241213022535.50">cdS = np.cumsum(S) / np.sum(S) # Cumulative energy
r90 = np.min(np.where(cdS &gt; 0.90)) # Find r to capture 90% energy

X90 = U[:,:(r90+1)] @ np.diag(S[:(r90+1)]) @ VT[:(r90+1),:]
plt.imshow(X90)
plt.set_cmap('gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.51">## Plot Singular Values

fig1,ax1 = plt.subplots(1)

ax1.semilogy(S,'-o', color='k', LineWidth=2)
ax1.semilogy(np.diag(S[:(r+1)]),'o', color='r', LineWidth=2)
ax1.plot(np.array([-20, N+20]),np.array([cutoff, cutoff]),'--', color='r', LineWidth=2)
rect = patches.Rectangle((-5,20),100,200,LineWidth=2,LineStyle='--',FaceColor='none',EdgeColor='k')
ax1.add_patch(rect)
plt.xlim((-10,610))
plt.ylim((0.003,300))
ax1.grid()
plt.show()

fig2,ax2 = plt.subplots(1)

ax2.semilogy(S,'-o', color='k', LineWidth=2)
ax2.semilogy(np.diag(S[:(r+1)]),'o', color='r', LineWidth=2)
ax2.plot(np.array([-20, N+20]),np.array([cutoff, cutoff]),'--', color='r', LineWidth=2)
plt.xlim((-5,100))
plt.ylim((20,200))
ax2.grid()
plt.show()

fig3,ax3 = plt.subplots(1)
ax3.plot(cdS,'-o',color='k',LineWidth=2)
ax3.plot(cdS[:(r90+1)],'o',color='b',LineWidth=2)
ax3.plot(cdS[:(r+1)],'o',color='r',LineWidth=2)
plt.xticks(np.array([0, 300, r90, 600]))
plt.yticks(np.array([0, 0.5, 0.9, 1]))
plt.xlim((-10,610))
ax3.plot(np.array([r90, r90, -10]),np.array([0, 0.9, 0.9]),'--',color='b',LineWidth=2)

ax3.grid()
plt.show()



</t>
<t tx="ekr.20241213022535.52"></t>
<t tx="ekr.20241213022535.53">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.55">import matplotlib.pyplot as plt
import numpy as np
import scipy.misc
plt.rcParams['figure.figsize'] = [8,8]
plt.rcParams.update({'font.size': 18})

n = 1000
q = int(n/4)
X = np.zeros((n,n))
X[(q-1):(3*q),(q-1):(3*q)] = 1

plt.imshow(X)
plt.set_cmap('gray')
plt.axis('off')
plt.title('Unrotated Matrix')
plt.show()


</t>
<t tx="ekr.20241213022535.56">X_rot = skimage.transform.rotate(X,10)
X_rot[np.nonzero(X_rot)] = 1


plt.imshow(Y)
plt.set_cmap('gray')
plt.axis('off')
plt.title('Rotated Matrix')
plt.show()

</t>
<t tx="ekr.20241213022535.57">U, S, VT = np.linalg.svd(X,full_matrices=0)


plt.semilogy(S,'-o',color='k')
plt.ylim((10**(-16),10**(4)+1))
plt.yticks(np.power(10,np.arange(-16,4,4, dtype=float)))
plt.xticks(np.arange(0,1000,250))
plt.grid()
plt.title('Unrotated Matrix: Spectrum')
plt.show()

</t>
<t tx="ekr.20241213022535.58">U_rot, S_rot, VT_rot = np.linalg.svd(X_rot,full_matrices=0)

plt.semilogy(S_rot,'-o',color='k')
plt.ylim((10**(-16),10**(4)+1))
plt.yticks(np.power(10,np.arange(-16,4,4, dtype=float)))
plt.xticks(np.arange(0,1000,250))
plt.grid()
plt.title('Rotated Matrix: Spectrum')
plt.show()

</t>
<t tx="ekr.20241213022535.59"></t>
<t tx="ekr.20241213022535.6">plt.rcParams['figure.figsize'] = [16, 8]
A = imread(os.path.join('..', 'DATA', 'dog.jpg'))
X = np.mean(A, -1); # Convert RGB to grayscale

img = plt.imshow(X)
img.set_cmap('gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022535.60">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.62">import matplotlib.pyplot as plt
import matplotlib.cm
import numpy as np
import skimage.transform

plt.rcParams['figure.figsize'] = [12,6]
plt.rcParams.update({'font.size': 18})

n = 1000
q = int(n/4)
X = np.zeros((n,n))
X[(q-1):(3*q),(q-1):(3*q)] = 1

nAngles = 12 # Sweep through 12 different angles, from 0:4:44 degrees
cm_np = np.array([[0,0,2/3],
                 [0,0,1],
                 [0,1/3,1],
                 [0,2/3,1],
                 [0,1,1],
                 [1/3,1,2/3],
                 [2/3,1,1/3],
                 [1,1,0],
                 [1,2/3,0],
                 [1,1/3,0],
                 [1,0,0],
                 [2/3,0,0]])


cmap = plt.cm.jet
cmap.set_bad(alpha = 0.0)

U, S, VT = np.linalg.svd(X,full_matrices=0)

fig1 = plt.figure()
ax1 = fig1.add_subplot(121)
plt.imshow(np.ma.masked_where(X == 0, X),vmin=0,vmax=nAngles)
plt.set_cmap(cmap)
plt.axis('off')


ax2 = fig1.add_subplot(122)
plt.semilogy(S,'-o',color=tuple(cm_np[0]))
plt.grid()

plt.show()

</t>
<t tx="ekr.20241213022535.63">Xrot = X

fig, axs = plt.subplots(1,2)

for j in range(nAngles):
    Xrot = skimage.transform.rotate(X,j*4) #rotate by theta = j*4 degrees
    Xrot[np.nonzero(Xrot)] = j
    
    U, S, VT = np.linalg.svd(Xrot)

    axs[0].imshow(np.ma.masked_where(Xrot == 0, Xrot),vmin=0,vmax=nAngles)
    plt.set_cmap(cmap)
    axs[0].axis('off')

    axs[1].semilogy(S,'-o',color=tuple(cm_np[j]))
    axs[1].axis('on')
    axs[1].grid(1)

plt.show()

</t>
<t tx="ekr.20241213022535.64"></t>
<t tx="ekr.20241213022535.65">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.67">import matplotlib.pyplot as plt
from matplotlib.image import imread
import numpy as np
import os

plt.rcParams['figure.figsize'] = [16,6]
plt.rcParams.update({'font.size': 18})

# Define randomized SVD function
def rSVD(X,r,q,p):
    # Step 1: Sample column space of X with P matrix
    ny = X.shape[1]
    P = np.random.randn(ny,r+p)
    Z = X @ P
    for k in range(q):
        Z = X @ (X.T @ Z)

    Q, R = np.linalg.qr(Z,mode='reduced')

    # Step 2: Compute SVD on projected Y = Q.T @ X
    Y = Q.T @ X
    UY, S, VT = np.linalg.svd(Y,full_matrices=0)
    U = Q @ UY

    return U, S, VT


</t>
<t tx="ekr.20241213022535.68">A = imread(os.path.join('..','DATA','jupiter.jpg'))
X = np.mean(A,axis=2) # Convert RGB -&gt; grayscale

U, S, VT = np.linalg.svd(X,full_matrices=0) # Deterministic SVD

r = 400 # Target rank
q = 1   # Power iterations
p = 5   # Oversampling parameter

rU, rS, rVT = rSVD(X,r,q,p)

</t>
<t tx="ekr.20241213022535.69">## Reconstruction
XSVD = U[:,:(r+1)] @ np.diag(S[:(r+1)]) @ VT[:(r+1),:] # SVD approximation
errSVD = np.linalg.norm(X-XSVD,ord=2) / np.linalg.norm(X,ord=2)

XrSVD = rU[:,:(r+1)] @ np.diag(rS[:(r+1)]) @ rVT[:(r+1),:] # SVD approximation
errSVD = np.linalg.norm(X-XrSVD,ord=2) / np.linalg.norm(X,ord=2)

</t>
<t tx="ekr.20241213022535.7">U, S, VT = np.linalg.svd(X,full_matrices=False)
S = np.diag(S)

j = 0
for r in (5, 20, 100):
    # Construct approximate image
    Xapprox = U[:,:r] @ S[0:r,:r] @ VT[:r,:]
    plt.figure(j+1)
    j += 1
    img = plt.imshow(Xapprox)
    img.set_cmap('gray')
    plt.axis('off')
    plt.title('r = ' + str(r))
    plt.show()

</t>
<t tx="ekr.20241213022535.70">## Plot
fig, axs = plt.subplots(1,3)

plt.set_cmap('gray')
axs[0].imshow(X)
axs[0].axis('off')
axs[1].imshow(XSVD)
axs[1].axis('off')
axs[2].imshow(XrSVD)
axs[2].axis('off')

plt.show()

</t>
<t tx="ekr.20241213022535.71">## Illustrate power iterations
X = np.random.randn(1000,100)
U, S, VT = np.linalg.svd(X,full_matrices=0)
S = np.arange(1,0,-0.01)
X = U @ np.diag(S) @ VT

color_list = np.array([[0,0,2/3],  # Define color map
                 [0,0,1],
                 [0,1/3,1],
                 [0,2/3,1],
                 [0,1,1],
                 [1/3,1,2/3],
                 [2/3,1,1/3],
                 [1,1,0],
                 [1,2/3,0],
                 [1,1/3,0],
                 [1,0,0],
                 [2/3,0,0]])

plt.plot(S,'o-',color='k',LineWidth=2,label='SVD')

Y = X
for q in range(1,6):
    Y = X.T @ Y
    Y = X @ Y
    Uq, Sq, VTq = np.linalg.svd(Y,full_matrices=0)
    plt.plot(Sq,'-o',color=tuple(color_list[2*q+1]),LineWidth=2,label='rSVD, q = '+str(q))

plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022535.72"></t>
<t tx="ekr.20241213022535.73">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.75">import matplotlib.pyplot as plt
import numpy as np
import os
from matplotlib import animation, rc
from IPython.display import HTML
# # %matplotlib inline

plt.rcParams['figure.figsize'] = [8,8]
plt.rcParams.update({'font.size': 18})
plt.rcParams['animation.html'] = 'jshtml'

x = np.arange(-5,5.01,0.1)
y = np.arange(-6,6.01,0.1)
t = np.arange(0,10*np.pi+0.1,0.1)

X,Y,T = np.meshgrid(x,y,t)

A = np.exp(-(X**2 + 0.5*Y**2)) * np.cos(2*T) + \
    (np.divide(np.ones_like(X),np.cosh(X)) * np.tanh(X) * np.exp(-0.2*Y**2)) * np.sin(T)

fig = plt.figure()
pcm = plt.pcolormesh(X[:,:,0],Y[:,:,0],A[:,:,0],vmin=-1,vmax=1,shading='interp')

    
def init():
    pcm.set_array(np.array([]))
    return pcm

def animate(iter):
    pcm.set_array(A[:-1,:-1,iter].ravel())
#     print('Frame ' + str(iter))
    return pcm

anim = animation.FuncAnimation(fig,animate,init_func=init,frames=len(t),interval=50,blit=False,repeat=False)
HTML(anim.to_jshtml())

</t>
<t tx="ekr.20241213022535.76">plt.rcParams['figure.figsize'] = [16,10]

fig, axs = plt.subplots(2,4)
axs = axs.reshape(-1)

for j in range(8):
    plt.sca(axs[j])
    plt.pcolormesh(X[:,:,0],Y[:,:,0],A[:,:,8*(j+1)-3],vmin=-1,vmax=1,shading='interp')
    axs[j].axis('off')
    plt.set_cmap('hot')

</t>
<t tx="ekr.20241213022535.77"># Tensor factorization method requires the TensorLy module,
# available at http://tensorly.org/stable/installation.html

from tensorly.decomposition import parafac
plt.rcParams['figure.figsize'] = [12,12]


A1, A2, A3 = parafac(A,2)

fig, axs = plt.subplots(3,1)
axs[0].plot(y,A1,LineWidth=2)
axs[1].plot(x,A2,LineWidth=2)
axs[2].plot(t,A3,LineWidth=2)
plt.show()

</t>
<t tx="ekr.20241213022535.78"></t>
<t tx="ekr.20241213022535.79"></t>
<t tx="ekr.20241213022535.8">plt.figure(1)
plt.semilogy(np.diag(S))
plt.title('Singular Values')
plt.show()

plt.figure(2)
plt.plot(np.cumsum(np.diag(S))/np.sum(np.diag(S)))
plt.title('Singular Values: Cumulative Sum')
plt.show()

</t>
<t tx="ekr.20241213022535.80"></t>
<t tx="ekr.20241213022535.81">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.83">import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


f = np.array([0, 0, .1, .2, .25, .2, .25, .3, .35, .43, .45, .5, .55, .5, .4, .425, .45, .425, .4, .35, .3, .25, .225, .2, .1, 0, 0])
g = np.array([0, 0, .025, .1, .2, .175, .2, .25, .25, .3, .32, .35, .375, .325, .3, .275, .275, .25, .225, .225, .2, .175, .15, .15, .05, 0, 0])
g = g - 0.025 * np.ones_like(g)

x = 0.1 * np.arange(1,len(f)+1)
xf = np.arange(0.1,x[-1],0.01)

f_interp = interpolate.interp1d(x, f, kind='cubic')
g_interp = interpolate.interp1d(x, g, kind='cubic')

ff = f_interp(xf)  
gf = g_interp(xf)

plt.plot(xf[10:-10],ff[10:-10],color='k',LineWidth=2)
plt.plot(x[1:-2],f[1:-2],'o',color='b')

plt.plot(xf[10:-10],gf[10:-10],color='k',LineWidth=2)
plt.plot(x[1:-2],g[1:-2],'o',color='r')

plt.show()

</t>
<t tx="ekr.20241213022535.84">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.86">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.cm import get_cmap

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

# Define domain
dx = 0.001
L = np.pi
x = L * np.arange(-1+dx,1+dx,dx)
n = len(x)
nquart = int(np.floor(n/4))

# Define hat function
f = np.zeros_like(x)
f[nquart:2*nquart] = (4/n)*np.arange(1,nquart+1)
f[2*nquart:3*nquart] = np.ones(nquart) - (4/n)*np.arange(0,nquart)

fig, ax = plt.subplots()
ax.plot(x,f,'-',color='k',LineWidth=2)

# Compute Fourier series
name = "Accent"
cmap = get_cmap('tab10')
colors = cmap.colors
ax.set_prop_cycle(color=colors)

A0 = np.sum(f * np.ones_like(x)) * dx
fFS = A0/2

A = np.zeros(20)
B = np.zeros(20)
for k in range(20):
    A[k] = np.sum(f * np.cos(np.pi*(k+1)*x/L)) * dx # Inner product
    B[k] = np.sum(f * np.sin(np.pi*(k+1)*x/L)) * dx
    fFS = fFS + A[k]*np.cos((k+1)*np.pi*x/L) + B[k]*np.sin((k+1)*np.pi*x/L)
    ax.plot(x,fFS,'-')

</t>
<t tx="ekr.20241213022535.87">## Plot amplitudes

fFS = (A0/2) * np.ones_like(f)
kmax = 100
A = np.zeros(kmax)
B = np.zeros(kmax)
ERR = np.zeros(kmax)

A[0] = A0/2
ERR[0] = np.linalg.norm(f-fFS)/np.linalg.norm(f)

for k in range(1,kmax):
    A[k] = np.sum(f * np.cos(np.pi*k*x/L)) * dx
    B[k] = np.sum(f * np.sin(np.pi*k*x/L)) * dx
    fFS = fFS + A[k] * np.cos(k*np.pi*x/L) + B[k] * np.sin(k*np.pi*x/L)
    ERR[k] = np.linalg.norm(f-fFS)/np.linalg.norm(f)
    
thresh = np.median(ERR) * np.sqrt(kmax) * (4/np.sqrt(3))
r = np.max(np.where(ERR &gt; thresh))

fig, axs = plt.subplots(2,1)
axs[0].semilogy(np.arange(kmax),A,color='k',LineWidth=2)
axs[0].semilogy(r,A[r],'o',color='b',MarkerSize=10)
plt.sca(axs[0])
plt.title('Fourier Coefficients')

axs[1].semilogy(np.arange(kmax),ERR,color='k',LineWidth=2)
axs[1].semilogy(r,ERR[r],'o',color='b',MarkerSize=10)
plt.sca(axs[1])
plt.title('Error')

plt.show()

</t>
<t tx="ekr.20241213022535.88"></t>
<t tx="ekr.20241213022535.89">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.9">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.91">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

dx = 0.01
L = 2*np.pi
x = np.arange(0,L+dx,dx)
n = len(x)
nquart = int(np.floor(n/4))

f = np.zeros_like(x)
f[nquart:3*nquart] = 1

A0 = np.sum(f * np.ones_like(x)) * dx * 2 / L
fFS = A0/2 * np.ones_like(f)

for k in range(1,101):
    Ak = np.sum(f * np.cos(2*np.pi*k*x/L)) * dx * 2 / L
    Bk = np.sum(f * np.sin(2*np.pi*k*x/L)) * dx * 2 / L
    fFS = fFS + Ak*np.cos(2*k*np.pi*x/L) + Bk*np.sin(2*k*np.pi*x/L)
    
plt.plot(x,f,color='k',LineWidth=2)
plt.plot(x,fFS,'-',color='r',LineWidth=1.5)
plt.show()

</t>
<t tx="ekr.20241213022535.92"></t>
<t tx="ekr.20241213022535.93"></t>
<t tx="ekr.20241213022535.94">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022535.96">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation, rc
from IPython.display import HTML
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})
plt.rcParams['animation.html'] = 'jshtml'


dx = 0.01
L = 10
x = np.arange(0,L+dx,dx)
n = len(x)
nquart = int(np.floor(n/4))

f = np.zeros_like(x)
f[nquart:3*nquart] = 1

A0 = np.sum(f * np.ones_like(x)) * dx * 2 / L
fFS = A0/2 * np.ones_like(f)

fig,ax = plt.subplots()
plt.plot(x,f,color='k',LineWidth=2)
fFS_plot, = plt.plot([],[],color='r',LineWidth=2)

all_fFS = np.zeros((len(fFS),101))
all_fFS[:,0] = fFS

for k in range(1,101):
    Ak = np.sum(f * np.cos(2*np.pi*k*x/L)) * dx * 2 / L
    Bk = np.sum(f * np.sin(2*np.pi*k*x/L)) * dx * 2 / L
    fFS = fFS + Ak*np.cos(2*k*np.pi*x/L) + Bk*np.sin(2*k*np.pi*x/L)
    all_fFS[:,k] = fFS

def init():
    ax.set_xlim(x[0],x[-1])
    ax.set_ylim(-0.2, 1.2)
    return fFS

def animate(iter):
    fFS_plot.set_data(x,all_fFS[:,iter])
    return fFS_plot

anim = animation.FuncAnimation(fig,animate,init_func=init,frames=101,interval=50,blit=False,repeat=False)
HTML(anim.to_jshtml())

</t>
<t tx="ekr.20241213022535.97"></t>
<t tx="ekr.20241213022535.98"></t>
<t tx="ekr.20241213022535.99">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.1">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.10">import numpy as np
import matplotlib.pyplot as plt
import os
import sys
from scipy.fftpack import dct, idct
from scipy.optimize import minimize
sys.path.append(os.path.join('..','UTILS'))
from cosamp_fn import cosamp
# cosamp function is available at https://github.com/avirmaux/CoSaMP

plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022536.100">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.optimize import fmin
from matplotlib import rcParams
rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022536.101"># Underdetermined
n = 20
m = 100
A = np.random.rand(n,m)
b = np.random.rand(n)

def two_norm(x):
    return np.linalg.norm(x,ord=2)

constr = ({'type': 'eq', 'fun': lambda x:  A @ x - b})
x0 = np.random.rand(m)
res = minimize(two_norm, x0, method='SLSQP',constraints=constr)
x2 = res.x

def one_norm(x):
    return np.linalg.norm(x,ord=1)

res = minimize(one_norm, x0, method='SLSQP',constraints=constr)
x1 = res.x

</t>
<t tx="ekr.20241213022536.102">plt.rcParams['figure.figsize'] = [12, 8]
fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[0].bar(range(m),x2)
axs[0].set_title('x2')
axs[1].bar(range(m),x1)
axs[1].set_title('x1')

axs[2].hist(x2,40)
axs[3].hist(x1,40)


plt.show()

</t>
<t tx="ekr.20241213022536.103"># Overdetermined
n = 500
m = 100
A = np.random.rand(n,m)
b = np.random.rand(n)

xdag = np.linalg.pinv(A)@b

lam = np.array([0, 0.1, 0.5])



def reg_norm(x,A,b,lam):
    return np.linalg.norm(A@x-b,ord=2) + lam*np.linalg.norm(x,ord=1)

fig,axs = plt.subplots(len(lam),2)
for j in range(len(lam)):
    res = minimize(reg_norm,args=(A,b,lam[j]),x0=xdag)
    x = res.x
    axs[j,0].bar(range(m),x)
    axs[j,0].set_ylabel('lam='+str(lam[j]))
    axs[j,1].hist(x,20)
    axs[j,1].set_xlim(-0.15,0.15)


</t>
<t tx="ekr.20241213022536.104">## Matrix Overdetermined System
plt.rcParams['figure.figsize'] = [12, 12]

# overdetermined
n = 300
m = 60
p = 20
A = np.random.rand(n,m)
b = np.random.rand(n,p)
lam = np.array([0,0.1])

xdag = np.linalg.pinv(A)@b
xdag = xdag.reshape(-1)

def reg_norm_2d(x,A,b,lam,m,p):
    # scipy minimize() does not accept multidimensional x
    # To get around this, we pass x as a vector and reshape it
    x = np.reshape(x,(m,p))
    return np.linalg.norm(A@x-b,ord=2) + lam*np.linalg.norm(x,ord=1)


fig,axs = plt.subplots(len(lam),1)
for j in range(len(lam)):
    res = minimize(reg_norm_2d,args=(A,b,lam[j],m,p),x0=xdag)
    x = res.x
    x = x.reshape(m,p)
    x_pcolor = axs[j].pcolor(x.T,cmap='hot')
    fig.colorbar(x_pcolor, ax=axs[j])
    axs[j].set_ylabel('lam='+str(lam[j]))
    
plt.show()

</t>
<t tx="ekr.20241213022536.105"></t>
<t tx="ekr.20241213022536.106">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.108">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from sklearn import linear_model

rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022536.109">n = 100
L = 4
x = np.linspace(0,L,n)
f = np.power(x,2) # Parabola with 100 data points

M = 20 # Polynomial degree

phi = np.zeros((n,M))
for j in range(M):
    phi[:,j] = np.power(x,j) # Build matrix A
    
plt.figure()
plt.plot(x,f,color='k')
    
fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

for j in range(4):
    fn = np.power(x,2) + 0.1*np.random.randn(*x.shape)
    an = np.linalg.pinv(phi) @ fn # Least-square fit
    fna = phi @ an 
    En = np.linalg.norm(f-fna,ord=2)/np.linalg.norm(f,ord=2)
    axs[j].bar(range(len(an)),an)

plt.show()

</t>
<t tx="ekr.20241213022536.11">## Generate signal, DCT of signal

n = 4096 # points in high resolution signal
t = np.linspace(0,1,n)
x = np.cos(2 * 97 * np.pi * t) + np.cos(2 * 777 * np.pi * t)
xt = np.fft.fft(x) # Fourier transformed signal
PSD = xt * np.conj(xt) / n # Power spectral density

</t>
<t tx="ekr.20241213022536.110">## Different regressions
plt.figure()
plt.plot(x,f,color='k')

lam = 0.1
phi2 = phi[:,1:]
E1 = np.zeros(100)
E2 = np.zeros(100)
E3 = np.zeros(100)
E4 = np.zeros(100)
E5 = np.zeros(100)
E6 = np.zeros(100)

A1 = np.zeros((M,100))
A2 = np.zeros((M,100))
A3 = np.zeros((M,100))
A4 = np.zeros((M,100))
A5 = np.zeros((M,100))
A6 = np.zeros((M,100))

for jj in range(100):
# for jj in range(10):
    f = np.power(x,2)+0.2*np.random.randn(n)
    
    a1 = np.linalg.pinv(phi) @ f
    f1 = phi @ a1
    E1[jj] = np.linalg.norm(f-f1,ord=2)/np.linalg.norm(f,ord=2)
    
    a2 = np.linalg.lstsq(phi,f,rcond=None)[0]
    f2 = phi @ a2
    E2[jj] = np.linalg.norm(f-f2,ord=2)/np.linalg.norm(f,ord=2)
    
    regr3 = linear_model.ElasticNet(alpha=1.0, copy_X=True, l1_ratio=lam, max_iter=10**5,random_state=0)
    regr3.fit(phi, f)  
    a3 = regr3.coef_
    f3 = phi @ a3
    E3[jj] = np.linalg.norm(f-f3,ord=2)/np.linalg.norm(f,ord=2)
    
    regr4 = linear_model.ElasticNet(alpha=0.8, copy_X=True, l1_ratio=lam, max_iter=10**5,random_state=0)
    regr4.fit(phi, f)  
    a4 = regr4.coef_
    f4 = phi @ a4
    E4[jj] = np.linalg.norm(f-f4,ord=2)/np.linalg.norm(f,ord=2)
    
    huber = linear_model.HuberRegressor().fit(phi, f) # matlab's robustfit() does not have an exact sklearn analogue
    a5 = huber.coef_
    f5 = phi @ a5
    E5[jj] = np.linalg.norm(f-f5,ord=2)/np.linalg.norm(f,ord=2)

    ridge = linear_model.Ridge(alpha=1.0).fit(phi,f)
    a6 = ridge.coef_
    f6 = phi @ a6
    E6[jj] = np.linalg.norm(f-f6,ord=2)/np.linalg.norm(f,ord=2)

    
    A1[:,jj] = a1
    A2[:,jj] = a2
    A3[:,jj] = a3
    A4[:,jj] = a4
    A5[:,jj] = a5
    A6[:,jj] = a6

    plt.plot(x,f)
    
Err = np.column_stack((E1,E2,E3,E4,E5,E6))
Err2 = np.column_stack((E1,E2,E3,E4,E5))

</t>
<t tx="ekr.20241213022536.111">plt.rcParams['figure.figsize'] = [12, 18]
rcParams.update({'font.size': 14})
fig,axs = plt.subplots(3,2)
axs = axs.reshape(-1)

axs[0].boxplot(A1.T)
axs[0].set_title('pinv')
axs[1].boxplot(A2.T)
axs[1].set_title('lstsq')
axs[2].boxplot(A3.T)
axs[2].set_title('elastic (alpha=1)')
axs[3].boxplot(A4.T)
axs[3].set_title('elastic (alpha=0.8)')
axs[4].boxplot(A5.T)
axs[4].set_title('huber')
axs[5].boxplot(A6.T)
axs[5].set_title('ridge')

for ax in axs:
    ax.set_xlim(0,M)
    
plt.rcParams['figure.figsize'] = [8, 8]

plt.figure()
plt.boxplot(Err)

plt.show()

</t>
<t tx="ekr.20241213022536.112">M = 10
En = np.zeros((100,M))
phi = np.zeros((len(x),M))
for jj in range(M):
    for j in range(jj):
        phi[:,j] = np.power(x,j)
    f = np.power(x,2)
    for j in range(100):
        fn = np.power(x,2) + 0.1*np.random.randn(n)
        an = np.linalg.pinv(phi) @ fn
        fna = phi @ an
        En[j,jj] = np.linalg.norm(f-fna,ord=2)/np.linalg.norm(f,ord=2)
        
plt.boxplot(En)

plt.show()

</t>
<t tx="ekr.20241213022536.113"></t>
<t tx="ekr.20241213022536.114">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.116">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib import rcParams
rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [8,8]


</t>
<t tx="ekr.20241213022536.117">fig,ax = plt.subplots(1)
x = np.arange(0.2,5,0.1)
y = np.divide(1,x)

x2 = np.copy(x)
n = len(x2)
y2 = np.divide(1,x2) + 0.5*np.random.randn(n)

y3 = (np.tile(y2,(5,1)) + 2*np.random.rand(5,n) + 1)
y3 = np.reshape(y3,-1)
x3 = np.tile(x,(1,5)).reshape(-1)

plt.plot(x,y,color='k',LineWidth=2)

rect = Rectangle((0.5,0.4), 0.9, 1.6,LineWidth=1,edgecolor='k',facecolor='grey',alpha=0.6) 
ax.add_patch(rect)

plt.scatter(x2,y2,100,color='magenta',edgecolors='k')
plt.scatter(x3,y3,100,color='lime',edgecolors='k')


plt.xlim(0.2,4)
plt.ylim(0,5.5)

plt.show()

</t>
<t tx="ekr.20241213022536.118"></t>
<t tx="ekr.20241213022536.119">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.12">## Randomly sample signal
p = 128 # num. random samples, p = n/32
perm = np.floor(np.random.rand(p) * n).astype(int)
y = x[perm]

</t>
<t tx="ekr.20241213022536.121">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib import rcParams
rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [8,8]


</t>
<t tx="ekr.20241213022536.122">n = 200
L = 8
x = np.linspace(0,L,n)
x1 = x[:100]    # Train
x2 = x[100:200] # Test
n1 = len(x1)
n2 = len(x2)
ftrain = np.power(x1,2) # Train parabola x = [0,4]
ftest = np.power(x2,2)  # Test parabola x = [4,8]

plt.plot(x1,ftrain,color='r',LineWidth=2)
plt.plot(x2,ftest,color='b',LineWidth=2)
plt.show()
M = 30 # number of model terms
Eni = np.zeros((100,M))
Ene = np.zeros((100,M))
for jj in range(M):
    phi_i = np.zeros((n1,jj+1))
    phi_e = np.zeros((n2,jj+1))
    for j in range(jj):
        phi_i[:,j] = np.power(x1,j) # interpolation key
        phi_e[:,j] = np.power(x2,j) # extrapolation key
    
    f = np.power(x,2)
    for j in range(100):
        fni = np.power(x1,2) + 0.1*np.random.randn(n1) # interpolation
        fne = np.power(x2,2) + 0.1*np.random.randn(n2) # extrapolation
        
        ani = np.linalg.pinv(phi_i) @ fni
        fnai = phi_i @ ani
        Eni[j,jj] = np.linalg.norm(ftrain-fnai,ord=2)/np.linalg.norm(ftrain,ord=2)
        
        fnae = phi_e @ ani # use loadings from x in [0,4]
        Ene[j,jj] = np.linalg.norm(ftest-fnae,ord=2)/np.linalg.norm(ftest,ord=2)
        
        

</t>
<t tx="ekr.20241213022536.123">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[0].boxplot(Eni)
axs[0].set_ylim(0,0.7)
axs[1].boxplot(Eni)
axs[1].set_ylim(0,0.02)
axs[2].boxplot(Ene)
axs[3].boxplot(np.log(Ene+1))
axs[3].set_ylim(0,30)

for ax in axs:
    ax.set_xticks((1,5,10,15,20,25,30))
    ax.set_xticklabels((1,5,10,15,20,25,30))

plt.show()


</t>
<t tx="ekr.20241213022536.124"></t>
<t tx="ekr.20241213022536.125">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.127">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from sklearn import linear_model
from mpl_toolkits.mplot3d import Axes3D 


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]


</t>
<t tx="ekr.20241213022536.128">n = 100
L = 4
x = np.linspace(0,L,n)
f = np.power(x,2) # parabola with 100 data points

M = 21 # Polynomial degree
phi = np.zeros((n,M))
for j in range(M):
    phi[:,j] = np.power(x,j) # build matrix A
    
trials = np.array([2, 10, 100])

fig,axs = plt.subplots(3,3)

for j in range(len(trials)):
    trial = trials[j]
    E1 = np.zeros(trial)
    E2 = np.zeros(trial)
    E3 = np.zeros(trial)
    
    A1 = np.zeros((M,trial))
    A2 = np.zeros((M,trial))
    A3 = np.zeros((M,trial))

    
    for jj in range(trial):
        f = np.power(x,2) + 0.2*np.random.randn(n)
        a1 = np.linalg.pinv(np.copy(phi)) @ np.copy(f)
        f1 = phi @ a1
        E1[jj] = np.linalg.norm(f-f1,ord=2)/np.linalg.norm(f,ord=2)
        
        a2 = np.linalg.lstsq(np.copy(phi),np.copy(f),rcond=None)[0]
        f2 = phi @ a2
        E2[jj] = np.linalg.norm(f-f2,ord=2)/np.linalg.norm(f,ord=2)
        
#         regr3 = linear_model.ElasticNet(alpha=1.0, copy_X=True, l1_ratio=0.1, max_iter=10**5,random_state=0)
        regr3 = linear_model.Lasso(alpha=1)
        regr3.fit(phi, f)  
        a3 = regr3.coef_
        f3 = phi @ a3
        E3[jj] = np.linalg.norm(f-f3,ord=2)/np.linalg.norm(f,ord=2)
        
        A1[:,jj] = a1
        A2[:,jj] = a2
        A3[:,jj] = a3
        
    A1m = np.mean(A1,axis=1)
    A2m = np.mean(A2,axis=1)
    A3m = np.mean(A3,axis=1)
    
    Err = np.column_stack((E1,E2,E3))
    
    axs[0,j].bar(range(M),A1m)
    axs[1,j].bar(range(M),A2m)
    axs[2,j].bar(range(M),A3m)
    
plt.show()

</t>
<t tx="ekr.20241213022536.129">plt.rcParams['figure.figsize'] = [8,8]

Atot = np.column_stack((A1m,A2m,A3m)) # Average loadings of three methods
Atot2 = (Atot&gt;0.2) * Atot # threshold
Atot3 = np.column_stack((Atot,Atot2)) # combine both thresholded and not

for j in range(3):
    plt.bar(np.arange(Atot.shape[0])*4+j,Atot[:,j],label='A'+str(j+1)+'m')
    
plt.xlim(0,4*M)
plt.title('Unthresholded')
plt.legend()

plt.figure()
for j in range(3):
    plt.bar(np.arange(Atot2.shape[0])*8+j,Atot[:,j],label='A'+str(j+1)+'m')
    
plt.title('Thresholded')
plt.xlim(0,4*M)
plt.legend()

plt.show()



</t>
<t tx="ekr.20241213022536.13">## Solve compressed sensing problem
Psi = dct(np.identity(n)) # Build Psi
Theta = Psi[perm,:]       # Measure rows of Psi

s = cosamp(Theta,y,10,epsilon=1.e-10,max_iter=10) # CS via matching pursuit
xrecon = idct(s) # reconstruct full signal

</t>
<t tx="ekr.20241213022536.130">n = 200
L = 8
x = np.linspace(0,L,n)
x1 = x[:100]    # Train
x2 = x[100:200] # Test
n1 = len(x1)
n2 = len(x2)
ftrain = np.power(x1,2) # Train parabola x = [0,4]
ftest = np.power(x2,2)  # Test parabola x = [4,8]

phi_i = np.zeros((n1,M))
phi_e = np.zeros((n2,M))

for j in range(M):
    phi_i[:,j] = np.power(x1,j) # interpolation key
    phi_e[:,j] = np.power(x2,j) # extrapolation key
    
Eni = np.zeros(6)
Ene = np.zeros(6)
for jj in range(6): # compute inter/extra-polation scores
    ani = Atot3[:,jj]
    fnai = phi_i @ ani
    Eni[jj] = np.linalg.norm(ftrain-fnai,ord=2)/np.linalg.norm(ftrain,ord=2)
    fnae = phi_e @ ani
    Ene[jj] = np.linalg.norm(ftest-fnae,ord=2)/np.linalg.norm(ftest,ord=2)
    
fig,axs = plt.subplots(2,2)
axs[0,0].bar(range(6),Eni)
axs[0,1].bar(range(6),Ene)
axs[1,0].bar(range(6),Eni)
axs[1,0].set_xlim(-0.5,6.5)
axs[1,0].set_ylim(0,0.01)
axs[1,1].bar(range(6),Ene)
axs[1,1].set_xlim(-0.5,6.5)
axs[1,1].set_ylim(0,0.1)

plt.show()

</t>
<t tx="ekr.20241213022536.131"></t>
<t tx="ekr.20241213022536.132">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.134">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.135">n = 10000
x1 = np.random.randn(n) # "truth" model (data)
x2 = 0.8 * np.random.randn(n) + 1 # model 1
x3 = 0.5 * np.random.randn(n) - 1 # model 3 components
x4 = 0.7 * np.random.randn(n) - 3
x5 = 5.0 * np.random.rand(n) - 0.5 

x = np.arange(-6,6.01,0.01) # range for data
x_bincenters = np.arange(-6.005,6.01,0.01)


</t>
<t tx="ekr.20241213022536.136">f = np.histogram(x1,bins=x_bincenters)[0] + 0.01 # generate PDFs
g1 = np.histogram(x2,bins=x_bincenters)[0] + 0.01
g2a = np.histogram(x3,bins=x_bincenters)[0]
g2b = np.histogram(x4,bins=x_bincenters)[0]
g2 = g2a + 0.3*g2b + 0.01
g3 = np.histogram(x5,bins=x_bincenters)[0] + 0.01

f = f/np.trapz(f,x) # normalize data
g1 = g1/np.trapz(g1,x)
g2 = g2/np.trapz(g2,x)
g3 = g3/np.trapz(g3,x)

plt.figure()
plt.plot(x,f,LineWidth=2,label='f')
plt.plot(x,g1,LineWidth=2,label='g1')
plt.plot(x,g2,LineWidth=2,label='g2')
plt.plot(x,g3,LineWidth=2,label='g3')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022536.137"># Compute integrand
Int1 = f * np.log(np.divide(f,g1))
Int2 = f * np.log(np.divide(f,g2))
Int3 = f * np.log(np.divide(f,g3))

# KL divergence
I1 = np.trapz(Int1,x)
I2 = np.trapz(Int2,x)
I3 = np.trapz(Int3,x)

</t>
<t tx="ekr.20241213022536.138"></t>
<t tx="ekr.20241213022536.139">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.14">## Plot
time_window = np.array([1024,1280])/4096
freq = np.arange(n)
L = int(np.floor(n/2))


fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[1].plot(freq[:L],PSD[:L],color='k',LineWidth=2)
axs[1].set_xlim(0, 1024)
axs[1].set_ylim(0, 1200)

axs[0].plot(t,x,color='k',LineWidth=2)
axs[0].plot(perm/n,y,color='r',marker='x',LineWidth=0,ms=12,mew=4)
axs[0].set_xlim(time_window[0],time_window[1])
axs[0].set_ylim(-2, 2)

axs[2].plot(t,xrecon,color='r',LineWidth=2)
axs[2].set_xlim(time_window[0],time_window[1])
axs[2].set_ylim(-2, 2)

xtrecon = np.fft.fft(xrecon,n) # computes the (fast) discrete fourier transform
PSDrecon = xtrecon * np.conj(xtrecon)/n # Power spectrum (how much power in each freq)

axs[3].plot(freq[:L],PSDrecon[:L],color='r',LineWidth=2)
axs[3].set_xlim(0, 1024)
axs[3].set_ylim(0, 1200)

plt.show()


</t>
<t tx="ekr.20241213022536.141">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from statsmodels.tsa import arima_process, arima_model
# Using the StatsModels module available at
# https://www.statsmodels.org/dev/install.html


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]


</t>
<t tx="ekr.20241213022536.142">np.random.seed(123) # for random data reproducibility
T = 100 # Sample size
# DGP = sm.ARIMA(x,order=(0,0,0))
# arparams = np.array([.2, 0.5])
# maparams = np.array([-4])
# arparams = np.r_[1, arparams]

arparams = np.array([-4, .2, 0.5])
maparams = np.array([1])



arma_process = sm.tsa.arima_process.ArmaProcess(arparams, maparams)
y = arma_process.generate_sample(T,scale=2)

logL = np.zeros(3) # log likelihood vector
aic = np.zeros(3)  # AIC vector
bic = np.zeros(3)  # BIC vector

for j in range(2):
    model_res = sm.tsa.arima_model.ARMA(y, (0,0)).fit(trend='c', disp=0,start_ar_lags=j+1,method='mle')
    logL[j] = model_res.llf
    aic[j] = model_res.aic
    bic[j] = model_res.bic

print('AIC: {:}'.format(aic))
print('BIC: {:}'.format(bic))

</t>
<t tx="ekr.20241213022536.143"></t>
<t tx="ekr.20241213022536.144"></t>
<t tx="ekr.20241213022536.145">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.147">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from mpl_toolkits.mplot3d import Axes3D

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.148">fisheriris_mat = io.loadmat(os.path.join('..','DATA','fisheriris.mat'))
meas = fisheriris_mat['meas']

x1 = meas[:50,:] # setosa
x2 = meas[50:100,:] # versicolor
x3 = meas[100:,:] # virginica

</t>
<t tx="ekr.20241213022536.149">fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(x1[:,0], x1[:,1], x1[:,3], c='g', marker='o')
ax.scatter(x2[:,0], x2[:,1], x2[:,3], c='m', marker='o')
ax.scatter(x3[:,0], x3[:,1], x3[:,3], c='r', marker='o')

plt.show()

</t>
<t tx="ekr.20241213022536.15">## L1-Minimization using SciPy
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'eq', 'fun': lambda x:  Theta @ x - y})
x0 = np.linalg.pinv(Theta) @ y 
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s = res.x

</t>
<t tx="ekr.20241213022536.150">dogdata_mat = io.loadmat(os.path.join('..','DATA','dogData.mat'))
catdata_mat = io.loadmat(os.path.join('..','DATA','catData.mat'))

dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog = dogdata_mat['dog']
cat = catdata_mat['cat']

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog,cat),axis=1)
CD2 = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
u2,s2,vT2 = np.linalg.svd(CD2-np.mean(CD2),full_matrices=0)

</t>
<t tx="ekr.20241213022536.151">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
for j in range(4):
    U = np.flipud(np.reshape(u[:,j],(64,64)))
    U2 = U[::2,::2]
    axs[j].pcolor(np.rot90(U2),cmap='hot')
    axs[j].axis('off')

</t>
<t tx="ekr.20241213022536.152">fig,axs = plt.subplots(4,1)
axs = axs.reshape(-1)
for j in range(4):
    axs[j].bar(range(len(s)),vT[j,:])

</t>
<t tx="ekr.20241213022536.153">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
for j in range(4):
    Xd = np.flipud(np.reshape(dog_wave[:,j],(32,32)))
    axs[j].pcolor(np.rot90(Xd),cmap='hot')
    axs[j].axis('off')

</t>
<t tx="ekr.20241213022536.154">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
for j in range(4):
    U3 = np.flipud(np.reshape(u2[:,j],(32,32)))
    axs[j].pcolor(np.rot90(U3),cmap='hot')
    axs[j].axis('off')

</t>
<t tx="ekr.20241213022536.155">fig,axs = plt.subplots(4,1)
axs = axs.reshape(-1)
for j in range(4):
    axs[j].bar(range(len(s2)),vT2[j,:])

</t>
<t tx="ekr.20241213022536.156">xbin = np.linspace(-0.25,0.25,20)
xbin_edges = np.append(xbin,xbin[-1]+(xbin[1]-xbin[0])) - (xbin[1]-xbin[0])/2
fig,axs = plt.subplots(4,2)
for j in range(4):
    pdf1 = np.histogram(vT[j,:80],bins=xbin_edges)[0]
    pdf2 = np.histogram(vT[j,80:],bins=xbin_edges)[0]
    axs[j,0].plot(xbin,pdf1)
    axs[j,0].plot(xbin,pdf2)
    
    pdf1 = np.histogram(vT2[j,:80],bins=xbin_edges)[0]
    pdf2 = np.histogram(vT2[j,80:],bins=xbin_edges)[0]
    axs[j,1].plot(xbin,pdf1)
    axs[j,1].plot(xbin,pdf2)

</t>
<t tx="ekr.20241213022536.157">fig = plt.figure()
ax1 = fig.add_subplot(211, projection='3d')
ax1.scatter(vT[0,:80],vT[1,:80],vT[2,:80],c='r',marker='o',s=20)
ax1.scatter(vT[0,80:],vT[1,80:],vT[2,80:],c='b',marker='o',s=20)

ax2 = fig.add_subplot(212, projection='3d')
ax2.scatter(vT2[0,:80],vT2[1,:80],vT2[2,:80],c='r',marker='o',s=20)
ax2.scatter(vT2[0,80:],vT2[1,80:],vT2[2,80:],c='b',marker='o',s=20)

plt.show()

</t>
<t tx="ekr.20241213022536.158">master = np.zeros((32*5,32*4))
count = 0

for jj in range(4):
    for j in range(5):
        T2 = np.flipud(np.reshape(dog[:,count],(64,64)))
        T = T2[::2,::2]
        master[32*j:32*(j+1),32*jj:32*(jj+1)] = T
        count += 1
        
plt.figure()
plt.pcolor(np.rot90(master),cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.159">master = np.zeros((32*5,32*4))
count = 0

for jj in range(4):
    for j in range(5):
        T2 = np.flipud(np.reshape(cat[:,count],(64,64)))
        T = T2[::2,::2]
        master[32*j:32*(j+1),32*jj:32*(jj+1)] = T
        count += 1
        
plt.figure()
plt.pcolor(np.rot90(master),cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.16">Theta.shape

</t>
<t tx="ekr.20241213022536.160"></t>
<t tx="ekr.20241213022536.161">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.163">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.164"># Training and test set sizes
n1 = 100 # Training set size
n2 = 50  # Test set size

# Random ellipse 1 centered at (-2,0)
x = np.random.randn(n1+n2) - 2
y = 0.5*np.random.randn(n1+n2)

# Random ellipse 5 centered at (1,0)
x5 = 2*np.random.randn(n1+n2) + 1
y5 = 0.5*np.random.randn(n1+n2)

# Random ellipse 2 centered at (2,-2)
x2 = np.random.randn(n1+n2) + 2
y2 = 0.2*np.random.randn(n1+n2) - 2

# Rotate ellipse 2 by theta
theta = np.pi/4
A = np.zeros((2,2))
A[0,0] = np.cos(theta)
A[0,1] = -np.sin(theta)
A[1,0] = np.sin(theta)
A[1,1] = np.cos(theta)

x3 = A[0,0]*x2 + A[0,1]*y2
y3 = A[1,0]*x2 + A[1,1]*y2

</t>
<t tx="ekr.20241213022536.165">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[0].plot(x[:n1],y[:n1],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[0].plot(x3[:n1],y3[:n1],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)


axs[1].plot(x[:70],y[:70],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[1].plot(x3[:70],y3[:70],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[1].plot(x[70:100],y[70:100],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=15)
axs[1].plot(x3[70:100],y3[70:100],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=15)

axs[2].plot(x5[:n1],y5[:n1],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[2].plot(x3[:n1],y3[:n1],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)

axs[3].plot(x5[:70],y5[:70],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[3].plot(x3[:70],y3[:70],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[3].plot(x5[70:100],y5[70:100],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=15)
axs[3].plot(x3[70:100],y3[70:100],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=15)

for ax in axs:
    ax.set_xlim(-6,6)
    ax.set_ylim(-2,2)

plt.show()

</t>
<t tx="ekr.20241213022536.166">n1 = 300 # training set size
x1 = 1.5*np.random.randn(n1)-1.5
y1 = 1.2*np.random.randn(n1)+np.power(x1+1.5,2)-7
x2 = 1.5*np.random.randn(n1)+1.5
y2 = 1.2*np.random.randn(n1)-np.power(x2-1.5,2)+7

fig,axs = plt.subplots(2)
axs[0].plot(x1,y1,'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=15)
axs[0].plot(x2,y2,'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=15)
axs[0].set_xlim(-6,6)
axs[0].set_ylim(-12,12)

r = 7 + np.random.randn(n1)
th = 2*np.pi*np.random.randn(n1)
xr = r * np.cos(th)
yr = r * np.sin(th)

x5 = np.random.randn(n1)
y5 = np.random.randn(n1)

axs[1].plot(xr,yr,'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=15)
axs[1].plot(x5,y5,'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=15)
axs[1].set_xlim(-10,10)
axs[1].set_ylim(-10,10)

plt.show()

</t>
<t tx="ekr.20241213022536.167"></t>
<t tx="ekr.20241213022536.168">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.17">y.shape

</t>
<t tx="ekr.20241213022536.170">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from sklearn.cluster import KMeans
from scipy.cluster import hierarchy
from scipy.spatial.distance import pdist

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.171"># Training and testing set sizes
n1 = 100 # Train
n2 = 50  # Test

# Random ellipse 1 centered at (0,0)
x = np.random.randn(n1+n2)
y = 0.5*np.random.randn(n1+n2)

# Random ellipse 2 centered at (1,-2)
x2 = np.random.randn(n1+n2) + 1
y2 = 0.2*np.random.randn(n1+n2) - 2

# Rotate ellipse 2 by theta
theta = np.pi/4
A = np.zeros((2,2))
A[0,0] = np.cos(theta)
A[0,1] = -np.sin(theta)
A[1,0] = np.sin(theta)
A[1,1] = np.cos(theta)

x3 = A[0,0]*x2 + A[0,1]*y2
y3 = A[1,0]*x2 + A[1,1]*y2

</t>
<t tx="ekr.20241213022536.172">plt.figure()
plt.plot(x[:n1],y[:n1],'ro')
plt.plot(x3[:n1],y3[:n1],'bo')
plt.show()

</t>
<t tx="ekr.20241213022536.173"># Training set: first 200 of 240 points
X1 = np.column_stack((x3[:n1],y3[:n1]))
X2 = np.column_stack((x[:n1],y[:n1]))

Y = np.concatenate((X1,X2))
Z = np.column_stack((np.ones(n1),2*np.ones(n1)))

# Test set: remaining 40 points
x1test = np.column_stack((x3[n1:],y3[n1:]))
x2test = np.column_stack((x[n1:],y[n1:]))


</t>
<t tx="ekr.20241213022536.174">g1 = np.array([-1, 0]) # Initial guess
g2 = np.array([1, 0])
fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
for j in range(4):
    class1 = np.zeros((1,2))
    class2 = np.zeros((1,2))
    for jj in range(Y.shape[0]):
        d1 = np.linalg.norm(g1-Y[jj,:],ord=2)
        d2 = np.linalg.norm(g2-Y[jj,:],ord=2)
        if d1&lt;d2:
            class1 = np.append(class1,Y[jj,:].reshape((1,2)),axis=0)
        else:
            class2 = np.append(class2,Y[jj,:].reshape((1,2)),axis=0)
    class1 = np.delete(class1, (0), axis=0) # remove zeros used to initialize
    class2 = np.delete(class2, (0), axis=0)
    
    axs[j].plot(class1[:,0],class1[:,1],'ro',ms=5)
    axs[j].plot(class2[:,0],class2[:,1],'bo',ms=5)
    axs[j].plot(g1[0],g1[1],'k*',ms=30)
    axs[j].plot(g2[0],g2[1],'k*',ms=30)
    
    g1 = np.array([np.mean(class1[:,0]),np.mean(class1[:,1])])
    g2 = np.array([np.mean(class2[:,0]),np.mean(class2[:,1])])
    
plt.show()

</t>
<t tx="ekr.20241213022536.175"># kmeans code
kmeans = KMeans(n_clusters=2, random_state=0).fit(Y)
c = kmeans.cluster_centers_
ind = kmeans.labels_

# result from previous section
plt.plot(g1[0],g1[1],'ko',ms=20)
plt.plot(g2[0],g2[1],'ko',ms=20)

# kmeans result
plt.plot(c[0,0],c[0,1],'k*',ms=20)
plt.plot(c[1,0],c[1,1],'k*',ms=20)

plt.show()

</t>
<t tx="ekr.20241213022536.176">midx = (c[0,0]+c[1,0])/2
midy = (c[0,1]+c[1,1])/2
slope = (c[1,1]-c[0,1])/(c[1,0]-c[0,0]) # rise/run
b = midy+(1/slope)*midx
xsep = np.arange(-1,2,0.1)
ysep = -(1/slope)*xsep+b

fig,axs = plt.subplots(2)
axs[0].plot(x[:n1],y[:n1],'ro')
axs[0].plot(x3[:n1],y3[:n1],'bo')
axs[0].plot(xsep,ysep,c='k',LineWidth=2)
axs[0].set_xlim(-2,4)
axs[0].set_ylim(-3,2)

# error on test data

axs[1].plot(x[n1:],y[n1:],'ro')
axs[1].plot(x3[n1:],y3[n1:],'bo')
axs[1].plot(xsep,ysep,c='k',LineWidth=2)
axs[1].set_xlim(-2,4)
axs[1].set_ylim(-3,2)

plt.show()

</t>
<t tx="ekr.20241213022536.177">## Dendrograms

Y3 = np.concatenate((X1[:50,:],X2[:50,:]))

Y2 = pdist(Y3,metric='euclidean')
Z = hierarchy.linkage(Y2,method='average')
thresh = 0.85*np.max(Z[:,2])

plt.figure()
dn = hierarchy.dendrogram(Z,p=100,color_threshold=thresh)

plt.show()

</t>
<t tx="ekr.20241213022536.178">plt.bar(range(100),dn['leaves'])
plt.plot(np.array([0, 100]),np.array([50, 50]),'r:',LineWidth=2)
plt.plot(np.array([50.5, 50.5]),np.array([0, 100]),'r:',LineWidth=2)

plt.show()

</t>
<t tx="ekr.20241213022536.179"></t>
<t tx="ekr.20241213022536.18"></t>
<t tx="ekr.20241213022536.180">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.182">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy.cluster import hierarchy
from scipy.spatial.distance import pdist

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.183"># Training and testing set sizes
n1 = 100 # Train
n2 = 50  # Test

# Random ellipse 1 centered at (0,0)
x = np.random.randn(n1+n2)
y = 0.5*np.random.randn(n1+n2)

# Random ellipse 2 centered at (1,-2)
x2 = np.random.randn(n1+n2) + 1
y2 = 0.2*np.random.randn(n1+n2) - 2

# Rotate ellipse 2 by theta
theta = np.pi/4
A = np.zeros((2,2))
A[0,0] = np.cos(theta)
A[0,1] = -np.sin(theta)
A[1,0] = np.sin(theta)
A[1,1] = np.cos(theta)

x3 = A[0,0]*x2 + A[0,1]*y2
y3 = A[1,0]*x2 + A[1,1]*y2

</t>
<t tx="ekr.20241213022536.184">plt.figure()
plt.plot(x[:n1],y[:n1],'ro')
plt.plot(x3[:n1],y3[:n1],'bo')
plt.show()

</t>
<t tx="ekr.20241213022536.185"># Training set: first 200 of 240 points
X1 = np.column_stack((x3[:n1],y3[:n1]))
X2 = np.column_stack((x[:n1],y[:n1]))

Y = np.concatenate((X1,X2))
Z = np.column_stack((np.ones(n1),2*np.ones(n1)))

# Test set: remaining 40 points
x1test = np.column_stack((x3[n1:],y3[n1:]))
x2test = np.column_stack((x[n1:],y[n1:]))


</t>
<t tx="ekr.20241213022536.186">## Dendrograms

Y3 = np.concatenate((X1[:50,:],X2[:50,:]))

Y2 = pdist(Y3,metric='euclidean')
Z = hierarchy.linkage(Y2,method='average')
thresh = 0.85*np.max(Z[:,2])

plt.figure()
dn = hierarchy.dendrogram(Z,p=100,color_threshold=thresh)
plt.axis('off')

plt.show()

</t>
<t tx="ekr.20241213022536.187">plt.bar(range(100),dn['leaves'])
plt.plot(np.array([0, 100]),np.array([50, 50]),'r:',LineWidth=2)
plt.plot(np.array([50.5, 50.5]),np.array([0, 100]),'r:',LineWidth=2)

plt.show()

</t>
<t tx="ekr.20241213022536.188">thresh = 0.25*np.max(Z[:,2])

plt.figure()
dn = hierarchy.dendrogram(Z,p=100,color_threshold=thresh)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.189"></t>
<t tx="ekr.20241213022536.19">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.190"></t>
<t tx="ekr.20241213022536.191">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.193">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
from sklearn.mixture import GaussianMixture
import os
from mpl_toolkits import mplot3d

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.194">dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241213022536.195">dogcat = v[:,(1,3)]
GMModel = GaussianMixture(n_components=2).fit(dogcat)
AIC = GMModel.aic(dogcat)

plt.plot(v[:80,1],v[:80,3],'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
plt.plot(v[80:,1],v[80:,3],'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

x = np.linspace(-0.15, 0.25)
y = np.linspace(-0.25, 0.2)
X, Y = np.meshgrid(x, y)
XX = np.array([X.ravel(), Y.ravel()]).T
Z = np.exp(GMModel.score_samples(XX))
Z = Z.reshape(X.shape)

CS = plt.contour(X, Y, Z,levels=np.arange(3,32,4),colors='k',linestyles='solid')

plt.show()

</t>
<t tx="ekr.20241213022536.196">ax = plt.axes(projection='3d')
ax.plot_wireframe(X, Y, Z, color='black')
ax.view_init(30, -20)
plt.show()

</t>
<t tx="ekr.20241213022536.197">## AIC Scores
AIC = np.zeros(4)
GMModels = [GaussianMixture(k+1,covariance_type='diag',max_iter=500).fit(dogcat)
          for k in range(4)]

fig,axs = plt.subplots(2,2,subplot_kw={'projection': '3d'})
axs = axs.reshape(-1)

for j in range(len(axs)):
    Z = np.exp(GMModels[j].score_samples(XX))
    Z = Z.reshape(X.shape)
    AIC[j] = GMModels[j].aic(dogcat)
    axs[j].plot_wireframe(X, Y, Z, color='black')
    axs[j].view_init(30, -20)
    axs[j].set_title('AIC = {:.4}'.format(AIC[j]))


</t>
<t tx="ekr.20241213022536.198"></t>
<t tx="ekr.20241213022536.199">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.201">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from mpl_toolkits import mplot3d
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.202">dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241213022536.203">xtrain = np.concatenate((v[:60,np.array([1,3])],v[80:140,np.array([1,3])]))
label = np.repeat(np.array([1,-1]),60)
test = np.concatenate((v[60:80,np.array([1,3])],v[140:160,np.array([1,3])]))

lda = LinearDiscriminantAnalysis()
test_class = lda.fit(xtrain, label).predict(test)

truth = np.repeat(np.array([1,-1]),20)
E = 100*(1-np.sum(0.5*np.abs(test_class - truth))/40)

fig,axs = plt.subplots(2)
axs[0].bar(range(40),test_class)

axs[1].plot(v[:80,1],v[:80,3],'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
axs[1].plot(v[80:,1],v[80:,3],'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

plt.show()

</t>
<t tx="ekr.20241213022536.204">plt.rcParams['figure.figsize'] = [8,4]
fig,axs = plt.subplots(1,2)
for j in range(2):
    U3 = np.flipud(np.reshape(u[:,2*j+1],(32,32)))
    axs[j].pcolor(np.rot90(U3),cmap='hot')
    axs[j].axis('off')

</t>
<t tx="ekr.20241213022536.205">dogdata_mat = io.loadmat(os.path.join('..','DATA','dogData.mat'))
catdata_mat = io.loadmat(os.path.join('..','DATA','catData.mat'))

dog = dogdata_mat['dog']
cat = catdata_mat['cat']

CD = np.concatenate((dog,cat),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241213022536.206">plt.rcParams['figure.figsize'] = [12, 12]
xtrain = np.concatenate((v[:60,np.array([1,3])],v[80:140,np.array([1,3])]))
label = np.repeat(np.array([1,-1]),60)
test = np.concatenate((v[60:80,np.array([1,3])],v[140:160,np.array([1,3])]))

lda = LinearDiscriminantAnalysis()
test_class = lda.fit(xtrain, label).predict(test)

fig,axs = plt.subplots(2)
axs[0].bar(range(40),test_class)

axs[1].plot(v[:80,1],v[:80,3],'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
axs[1].plot(v[80:,1],v[80:,3],'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

plt.show()

</t>
<t tx="ekr.20241213022536.207">## Cross-validate
E = np.zeros(100)

for jj in range(100):
    r1 = np.random.permutation(80)
    r2 = np.random.permutation(80)
    ind1 = r1[:60]
    ind2 = r2[:60]+60
    ind1t = r1[60:80]
    ind2t = r2[60:80]+60
    
    xtrain = np.concatenate((v[ind1[:, np.newaxis],np.array([1,3])], v[ind2[:, np.newaxis],np.array([1,3])]))
    test = np.concatenate((v[ind1t[:, np.newaxis],np.array([1,3])], v[ind2t[:, np.newaxis],np.array([1,3])]))
    
    label = np.repeat(np.array([1,-1]),60)

    lda = LinearDiscriminantAnalysis()
    test_class = lda.fit(xtrain, label).predict(test)

    truth = np.repeat(np.array([1,-1]),20)
    E[jj] = 100*np.sum(np.abs(test_class-truth))/40
    
plt.bar(range(100),E,color=(0.5,0.5,0.5))
plt.plot(range(100),np.mean(E)*np.ones(100),'r:',LineWidth=3)
plt.show()

</t>
<t tx="ekr.20241213022536.208">dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241213022536.209">plt.rcParams['figure.figsize'] = [12, 6]
fig,axs = plt.subplots(1,2)
for j in range(2):
    axs[j].plot(v[:80,1],v[:80,3],'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
    axs[j].plot(v[80:,1],v[80:,3],'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

# Linear Discriminant
xtrain = np.concatenate((v[:60,np.array([1,3])],v[80:140,np.array([1,3])]))
test = np.concatenate((v[60:80,np.array([1,3])],v[140:160,np.array([1,3])]))
label = np.repeat(np.array([1,-1]),60)



lda = LinearDiscriminantAnalysis().fit(xtrain, label)
test_class = lda.predict(test)
K = -lda.intercept_[0]
L = -lda.coef_[0]


x = np.arange(-0.15,0.25,0.005)
axs[0].plot(x,-(L[0]*x+K)/L[1],'k',LineWidth=2)


# Quadratic Discriminant
qda = QuadraticDiscriminantAnalysis().fit(xtrain, label)
y = np.arange(-0.3,0.25,0.005)
X,Y = np.meshgrid(x,y)

Z = np.zeros_like(X)

for jj in range(len(x)):
    for kk in range(len(y)):
        Z[kk,jj] = qda.predict(np.array([[x[jj],y[kk]]]))

axs[1].contour(X,Y,Z,0,colors='k',linewidths=2)        

plt.show()


</t>
<t tx="ekr.20241213022536.21">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import os
import scipy.io
from scipy.fftpack import dct, idct
from scipy.optimize import minimize


plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

mat = scipy.io.loadmat(os.path.join('..','DATA','CC2.mat'))
CC = mat['CC']
CC_map = ListedColormap(CC)

p = 14
n = 32

</t>
<t tx="ekr.20241213022536.210"></t>
<t tx="ekr.20241213022536.211">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.213">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from sklearn import svm
from sklearn.model_selection import cross_val_score
from mpl_toolkits import mplot3d


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.214"># Random ellipse 1

n1 = 300 # Training set size

x1 = 1.5*np.random.randn(n1) - 1.5
y1 = 1.2*np.random.randn(n1) + np.power(x1+1.5,2) - 7
x2 = 1.5*np.random.randn(n1) + 1.5
y2 = 1.2*np.random.randn(n1) - np.power(x2-1.5,2) + 7

plt.plot(x1,y1,'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
plt.plot(x2,y2,'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

plt.show()

</t>
<t tx="ekr.20241213022536.215">z1 = np.power(x1,2) * y1
z2 = np.power(x2,2) * y2

fig = plt.figure()
ax = plt.axes(projection='3d')

ax.plot(x1,y1,z1,'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
ax.plot(x2,y2,z2,'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

ax.view_init(20, -135)

plt.show()

</t>
<t tx="ekr.20241213022536.216">r = 7 + np.random.randn(n1)
th = 2 * np.pi * np.random.randn(n1)
xr = r * np.cos(th)
yr = r * np.sin(th)
x5 = np.random.randn(n1)
y5 = np.random.randn(n1)

zr = np.power(xr,2) + np.power(yr,2)
z5 = np.power(x5,2) + np.power(y5,2)

fig = plt.figure()
ax = plt.axes(projection='3d')
ax.view_init(20, -135)

ax.plot(xr,yr,zr+40,'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
ax.plot(x5,y5,z5+40,'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)


x = np.arange(-10,10.5,0.5)
y = x
X,Y = np.meshgrid(x,y)
F3 = 54 + 0*X + 0*Y

ax.plot_surface(X, Y, F3, cmap='gray',linewidth=0, antialiased=True,alpha=0.2)

ax.plot(xr,yr,np.zeros(*xr.shape),'ro',MarkerFaceColor=(179/255,1,179/255),MarkerEdgeColor='k',ms=12)
ax.plot(x5,y5,np.zeros(*x5.shape),'bo',MarkerFaceColor=(240/255,194/255,224/255),MarkerEdgeColor='k',ms=12)

theta = np.linspace(0,2*np.pi,100)
xrr = np.sqrt(14)*np.cos(theta)
yrr = np.sqrt(14)*np.sin(theta)

ax.plot(xrr,yrr,np.zeros(*xrr.shape),'k-',linewidth=2)

plt.show()

</t>
<t tx="ekr.20241213022536.217"># Classify dogs vs. cats
dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241213022536.218">features = np.arange(1,21)
xtrain = np.concatenate((v[:60,features],v[80:140,features]))
test = np.concatenate((v[60:80,features],v[140:160,features]))

label = np.repeat(np.array([1,-1]),60)
truth = np.repeat(np.array([1,-1]),20)


Mdl = svm.SVC(kernel='rbf',gamma='auto').fit(xtrain,label)
test_labels = Mdl.predict(test)

CMdl = cross_val_score(Mdl, xtrain, label, cv=10) #cross-validate the model
classLoss = 1-np.mean(CMdl) # average error over all cross-validation iterations



</t>
<t tx="ekr.20241213022536.219"></t>
<t tx="ekr.20241213022536.22">## Plot Psi
# def padflip(X):
#     nx,ny = X.shape
#     X = np.flipud(X)
#     Y = np.zeros((nx+1,ny+1))
#     Y[:-1,:-1] = X
#     return Y

Psi = dct(np.identity(n))
plt.pcolor(np.flipud(Psi),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.220">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.222">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from sklearn import tree, preprocessing
from sklearn.model_selection import cross_val_score
from IPython.display import Image  
from sklearn.externals.six import StringIO  
import pydotplus
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.223">fisheriris_mat = io.loadmat(os.path.join('..','DATA','fisheriris.mat'))
meas = fisheriris_mat['meas']
species = fisheriris_mat['species']
le = preprocessing.LabelEncoder()
le.fit(species.reshape(-1).tolist())
species_label = le.transform(species.reshape(-1).tolist()) 

decision_tree = tree.DecisionTreeClassifier(max_depth=3).fit(meas,species_label)

dot_data = StringIO()

tree.export_graphviz(decision_tree, out_file=dot_data,  
                filled=True, rounded=True,
                special_characters=True)
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
Image(graph.create_png())

cv = cross_val_score(decision_tree, meas, species_label, cv=10) #cross-validate the model
classError = 1-np.mean(cv) # average error over all cross-validation iterations

</t>
<t tx="ekr.20241213022536.224">x1 = meas[:50,:]     # setosa
x2 = meas[50:100,:]  # versicolor
x3 = meas[100:150,:] # virginica

fig = plt.figure()
ax = plt.subplot(111,projection='3d')
ax.plot(x1[:,0],x1[:,1],x1[:,3],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=12)
ax.plot(x2[:,0],x2[:,1],x2[:,3],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=12)
ax.plot(x3[:,0],x3[:,1],x3[:,3],'o',markerfacecolor=(1,0.64,0.098),markeredgecolor='k',ms=12)

plt.show()

</t>
<t tx="ekr.20241213022536.225"># dogs vs. cats
dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

features = np.arange(1,21)
xtrain = np.concatenate((v[:60,features],v[80:140,features]))
test = np.concatenate((v[60:80,features],v[140:160,features]))

label = np.repeat(np.array([1,-1]),60)
truth = np.repeat(np.array([1,-1]),20)

Mdl = tree.DecisionTreeClassifier(max_depth=2).fit(xtrain,label)
cv = cross_val_score(Mdl, xtrain, label, cv=10) #cross-validate the model
classError = 1-np.mean(cv) # average error over all cross-validation iterations

dot_data = StringIO()

tree.export_graphviz(Mdl, out_file=dot_data,  
                filled=True, rounded=True,
                special_characters=True)
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
Image(graph.create_png())

</t>
<t tx="ekr.20241213022536.226">## Census Data
adultdata = pd.read_csv(os.path.join('..','DATA','census1994.csv'))

adultdata = adultdata.loc[:,('age','workClass','education_num','marital_status','race','sex','capital_gain','capital_loss','hours_per_week','salary')]

nFeatures = len(adultdata.columns)-1

# convert categorical variables to one-hot representation
adultdata = pd.get_dummies(adultdata, columns=['workClass', 'marital_status', 'race', 'sex', 'salary'])

adultdata_input = adultdata.drop(['salary_&gt;50K','salary_&lt;=50K'],axis=1)
adultdata_salary = adultdata['salary_&gt;50K']

Mdl = tree.DecisionTreeClassifier(max_features=10).fit(adultdata_input,adultdata_salary)
imp = Mdl.feature_importances_
imp_combine = np.zeros(nFeatures)
imp_combine[:5] = imp[:5]
imp_combine[5] = np.mean(imp[5:14])
imp_combine[6] = np.mean(imp[14:21])
imp_combine[7] = np.mean(imp[21:26])
imp_combine[8] = np.mean(imp[26:28])

plt.bar(range(len(imp_combine)),imp_combine)
infeatures = ['age','workClass','education_num', 'marital_status', 'race', 'sex', 'capital_gain','capital_loss','hours_per_week']
plt.xticks(range(len(infeatures)), infeatures, size='small',rotation=45)
plt.show()

</t>
<t tx="ekr.20241213022536.227">## Splitting Procedure
fisheriris_mat = io.loadmat(os.path.join('..','DATA','fisheriris.mat'))
meas = fisheriris_mat['meas']
species = fisheriris_mat['species']

x1 = meas[:50,:]     # setosa
x2 = meas[50:100,:]  # versicolor
x3 = meas[100:150,:] # virginica

plt.plot(x1[:,2],x1[:,3],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=12)
plt.plot(x2[:,2],x2[:,3],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=12)
plt.plot(x3[:,2],x3[:,3],'o',markerfacecolor=(1,0.64,0.098),markeredgecolor='k',ms=12)

plt.plot(np.array([2.35, 2.35]),np.array([0, 3]),'k:',linewidth=2)
plt.plot(np.array([2.35, 10]),np.array([1.75, 1.75]),'k:',linewidth=2)
plt.plot(np.array([4.95, 4.95]),np.array([0, 1.75]),'k:',linewidth=2)

plt.xlim(0,7)
plt.ylim(0,3)

plt.show()

</t>
<t tx="ekr.20241213022536.228">plt.plot(x1[:,0],x1[:,1],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=12)
plt.plot(x2[:,0],x2[:,1],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=12)
plt.plot(x3[:,0],x3[:,1],'o',markerfacecolor=(1,0.64,0.098),markeredgecolor='k',ms=12)

plt.xlim(4,8)
plt.ylim(2,6)

plt.show()

</t>
<t tx="ekr.20241213022536.229"></t>
<t tx="ekr.20241213022536.23">## Plot C
plt.rcParams['figure.figsize'] = [12, 6]
fig,ax = plt.subplots(1,1)
C = np.identity(n)
perm = np.random.permutation(n)[:p]
C = C[perm,:] # compressed measurement
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.grid(True)
plt.xticks(np.arange(n))
plt.yticks(np.arange(len(perm)))
ax.set_xticklabels([])
ax.set_yticklabels([])
plt.show()

</t>
<t tx="ekr.20241213022536.230"></t>
<t tx="ekr.20241213022536.231">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.233">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from sklearn import linear_model


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.234"># dogs vs. cats
dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

train = np.concatenate((dog_wave[:,:60],cat_wave[:,:60]),axis=1)
test = np.concatenate((dog_wave[:,60:80],cat_wave[:,60:80]),axis=1)
label = np.repeat(np.array([1,-1]),60)

A = label @ np.linalg.pinv(train)
test_labels = np.sign(A@test)

</t>
<t tx="ekr.20241213022536.235">lasso = linear_model.Lasso().fit(train.T,label)
A_lasso = lasso.coef_
test_labels_lasso = np.sign(A_lasso@test)

</t>
<t tx="ekr.20241213022536.236">fig,axs = plt.subplots(4,1)
axs[0].bar(range(len(test_labels)),test_labels)
axs[1].bar(range(len(A)),A)
axs[2].bar(range(len(test_labels_lasso)),test_labels_lasso)
axs[3].bar(range(len(A_lasso)),A_lasso)


plt.show()

</t>
<t tx="ekr.20241213022536.237">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
A2 = np.flipud(np.reshape(A,(32,32)))
A2_lasso = np.flipud(np.reshape(A_lasso,(32,32)))
axs[0].pcolor(np.rot90(A2),cmap='gray')
axs[1].pcolor(np.rot90(A2_lasso),cmap='gray')


plt.show()

</t>
<t tx="ekr.20241213022536.238">## To be implemented: Python version of Matlab's patternnet()

</t>
<t tx="ekr.20241213022536.239"></t>
<t tx="ekr.20241213022536.24">## Plot Theta

Theta = C @ Psi
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.240"></t>
<t tx="ekr.20241213022536.241">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.243">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import interpolate
from mpl_toolkits.mplot3d import Axes3D



rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022536.244">iterMax = 100
h = 0.1
x_grid = np.arange(-6,6+h,h)
y_grid = np.copy(x_grid)
n = len(x_grid)
X,Y = np.meshgrid(x_grid,y_grid)

F1 = 1.5 - 1.6*np.exp(-0.05*(3*np.power(X+3,2)+np.power(Y+3,2)))
F = F1 + (0.5 - np.exp(-0.1*(3*np.power(X-3,2)+np.power(Y-3,2))))
dFy,dFx = np.gradient(F,h,h)

x0 = np.array([4,0,-5])
y0 = np.array([0,-5,2])

x = np.zeros(iterMax+1)
y = np.copy(x)
f = np.copy(x)

x_out = np.zeros((iterMax+1,3));
y_out = np.copy(x_out)
f_out = np.copy(x_out)

interp_type = 'linear'

for jj in range(3):
    q = np.random.permutation(n)
    i1 = np.sort(q[:10])
    q2 = np.random.permutation(n)
    i2 = np.sort(q2[:10])
    x[0] = x0[jj]
    y[0] = y0[jj]
    
    F_i12 = F[i1[:, np.newaxis],i2]
    dFx_i12 = dFx[i1[:, np.newaxis],i2]
    dFy_i12 = dFy[i1[:, np.newaxis],i2]
    
    F_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], F_i12, kind=interp_type)
    dfx_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], dFx_i12, kind=interp_type)
    dfy_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], dFy_i12, kind=interp_type)
    
    f[0] = F_interp(x[0],y[0])
    dfx = dfx_interp(x[0],y[0])
    dfy = dfy_interp(x[0],y[0])
    
#     tau = 2
    tau = 1.5
    for j in range(iterMax):
        x[j+1] = x[j]-tau*dfx # update x, y, and f
        y[j+1] = y[j]-tau*dfy
        q = np.random.permutation(n)
        i1 = np.sort(q[:10])
#         ind1 = np.sort(q[:10])
        q2 = np.random.permutation(n)
        i2 = np.sort(q2[:10])
#         ind2 = np.sort(q2[:10])
        
        F_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], F_i12, kind=interp_type)
        dfx_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], dFx_i12, kind=interp_type)
        dfy_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], dFy_i12, kind=interp_type)
        
        f[j+1] = F_interp(x[j+1],y[j+1])
        dfx = dfx_interp(x[j+1],y[j+1])
        dfy = dfy_interp(x[j+1],y[j+1])
        
        if np.abs(f[j+1]-f[j]) &lt; 10**(-6): # check convergence
            print('Converged after {} iterations'.format(j+1))
            break
        if j == iterMax-1:
            print('Failed to converge after {} iterations'.format(j+1))
    x_out[:,jj] = x
    y_out[:,jj] = y
    f_out[:,jj] = f
    
    # If converged before iterMax, replace 0s with NaNs
    x_out[(j+2):,jj] = np.nan
    y_out[(j+2):,jj] = np.nan
    f_out[(j+2):,jj] = np.nan


</t>
<t tx="ekr.20241213022536.245">plt.figure()
plt.contour(X,Y,F,colors='k')
for jj in range(3):
    plt.plot(x_out[:,jj],y_out[:,jj],'o')
plt.show()

</t>
<t tx="ekr.20241213022536.246">fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})
ax.plot_surface(X, Y, F,linewidth=0,cmap='binary',alpha=0.3)
for jj in range(3):
    ax.scatter(x_out[:,jj],y_out[:,jj],f_out[:,jj]+0.1,'o',s=100)
ax.view_init(elev=40, azim=-100)
plt.show()

</t>
<t tx="ekr.20241213022536.247"></t>
<t tx="ekr.20241213022536.248"></t>
<t tx="ekr.20241213022536.25">## Plot s, y
s = np.zeros((n,1))
s[2] = 1.4
s[13] = 0.7
s[27] = 2.2
y = C @ Psi @ s

fig,axs = plt.subplots(1,4)
axs[0].pcolor(np.flipud(s),cmap=CC_map)
axs[0].set_xlabel('s')

sL2 = np.linalg.pinv(Theta) @ y
axs[1].pcolor(np.flipud(sL2),cmap=CC_map)
axs[1].set_xlabel('sL2')

sbackslash = np.linalg.lstsq(Theta,y)[0]
axs[2].pcolor(np.flipud(sbackslash),cmap=CC_map)
axs[2].set_xlabel('sbackslash')

axs[3].pcolor(np.flipud(y),cmap=CC_map)
axs[3].set_xlabel('y')

for ax in axs:
    ax.set_xticklabels([])
    ax.set_yticklabels([])

plt.show()


</t>
<t tx="ekr.20241213022536.26">## L1-Minimization using SciPy
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

y = y.reshape(-1)
constr = ({'type': 'eq', 'fun': lambda x:  Theta @ x - y})
x0 = np.linalg.pinv(Theta) @ y
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s2 = res.x

</t>
<t tx="ekr.20241213022536.27">## Plot C and Theta (2) - Gaussian Random
plt.rcParams['figure.figsize'] = [8, 4]

C = np.random.randn(p,n)

plt.figure()
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.axis('off')
plt.show()

Theta = C @ Psi
plt.figure()
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.28"># Plot C and Theta (3) - Bernoulli Random
C = np.random.randn(p,n)
C = C &gt; 0

plt.figure()
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.axis('off')
plt.show()

plt.figure()
Theta = C @ Psi
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.29"># Plot C and Theta (4) - Sparse Bernoulli
C = np.random.randn(p,n)
C = C &gt; 1

plt.figure()
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.axis('off')
plt.show()

plt.figure()
Theta = C @ Psi
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.3">import numpy as np
import matplotlib.pyplot as plt
import os
from scipy.optimize import minimize
plt.rcParams['figure.figsize'] = [12, 18]
plt.rcParams.update({'font.size': 18})

# Solve y = Theta * s for "s"
n = 1000 # dimension of s
p = 200  # number of measurements, dim(y)
Theta = np.random.randn(p,n)
y = np.random.randn(p)

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'eq', 'fun': lambda x:  Theta @ x - y})
x0 = np.linalg.pinv(Theta) @ y # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s_L1 = res.x

</t>
<t tx="ekr.20241213022536.30"># Bad C and Theta (5) - DCT Meas
C = idct(np.identity(n))
perm = np.arange(n-p,n)
C = C[perm,:] # compressed measurement

plt.figure()
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.axis('off')
plt.show()

plt.figure()
Theta = C @ Psi
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

plt.figure()
y = Theta @ s
plt.pcolor(np.flipud(y),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241213022536.31"></t>
<t tx="ekr.20241213022536.32"></t>
<t tx="ekr.20241213022536.33"></t>
<t tx="ekr.20241213022536.34">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.36">import numpy as np
import matplotlib.pyplot as plt
import os
from scipy.optimize import minimize


plt.rcParams['figure.figsize'] = [7, 7]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022536.37">x = np.sort(4*(np.random.rand(25,1)-0.5),axis=0) # Random data from [-2,2]
b = 0.9*x + 0.1*np.random.randn(len(x),1)  # Line y = 0.9x with noise
atrue = np.linalg.lstsq(x,b,rcond=None)[0] # Least-squares slope (no outliers)
atrue = atrue.item(0)

b[-1] = -5.5  # Introduce outlier
acorrupt = np.linalg.lstsq(x,b,rcond=None)[0] # New slope
acorrupt = acorrupt.item(0)


</t>
<t tx="ekr.20241213022536.38">## L1 optimization to reject outlier
def L1_norm(a):
    return np.linalg.norm(a*x-b,ord=1)

a0 = acorrupt   # initialize to L2 solution
res = minimize(L1_norm, a0)
aL1 = res.x[0]  # aL1 is robust

</t>
<t tx="ekr.20241213022536.39">plt.plot(x[:-1],b[:-1],'o',color='b',ms=8) # Data
plt.plot(x[-1],b[-1],'o',color='r',ms=8)   # Outlier

xgrid = np.arange(-2,2,0.01)
plt.plot(xgrid,atrue*xgrid,'--',color='k')    # L2 fit (no outlier)
plt.plot(xgrid,acorrupt*xgrid,'--',color='r') # L2 fit (outlier)
plt.plot(xgrid,aL1*xgrid,'--',color='b')      # L1 fit

plt.show()

</t>
<t tx="ekr.20241213022536.4"># L2 Minimum norm solution s_L2
s_L2 = np.linalg.pinv(Theta) @ y 

</t>
<t tx="ekr.20241213022536.40"></t>
<t tx="ekr.20241213022536.41">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.43">import numpy as np
import matplotlib.pyplot as plt
import os
import scipy.io
from sklearn import linear_model
from sklearn import model_selection

plt.rcParams['figure.figsize'] = [7, 7]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022536.44">A = np.random.randn(100,10) # Matrix of possible predictors
x = np.array([0, 0, 1, 0, 0, 0, -1, 0, 0, 0]) #Two nonzero predictors
b = A @ x + 2*np.random.randn(100)

xL2 = np.linalg.pinv(A) @ b

</t>
<t tx="ekr.20241213022536.45">reg = linear_model.LassoCV(cv=10).fit(A, b)

lasso = linear_model.Lasso(random_state=0, max_iter=10000)
alphas = np.logspace(-4, -0.5, 30)

tuned_parameters = [{'alpha': alphas}]

clf = model_selection.GridSearchCV(lasso, tuned_parameters, cv=10, refit=False)
clf.fit(A, b)

scores = clf.cv_results_['mean_test_score']
scores_std = clf.cv_results_['std_test_score']
plt.semilogx(alphas, scores,'r-')

# plot error lines showing +/- std. errors of the scores
std_error = scores_std / np.sqrt(10)

plt.semilogx(alphas, scores + std_error, 'k--')
plt.semilogx(alphas, scores - std_error, 'k--')
plt.fill_between(alphas, scores + std_error, scores - std_error, alpha=0.1,color='k')

plt.ylabel('CV score +/- std error')
plt.xlabel('alpha')
plt.axhline(np.max(scores), linestyle='--', color='.5')
plt.xlim([alphas[-1], alphas[0]])

plt.show()

</t>
<t tx="ekr.20241213022536.46">XL1 = linear_model.Lasso(alpha=clf.best_params_['alpha'])
XL1.fit(A,b)
xL1 = XL1.coef_
xL1DeBiased = np.linalg.pinv(A[:,np.abs(xL1)&gt;0]) @ b

</t>
<t tx="ekr.20241213022536.47"></t>
<t tx="ekr.20241213022536.48">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.5">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
axs[0].plot(s_L1,color='b',LineWidth=1.5)
axs[0].set_ylim(-0.2,0.2)
axs[1].plot(s_L2,color='r',LineWidth=1.5)
axs[1].set_ylim(-0.2,0.2)
axs[2].hist(s_L1,bins=np.arange(-0.105,0.105,0.01),rwidth=0.9)
axs[3].hist(s_L2,bins=np.arange(-0.105,0.105,0.01),rwidth=0.9)

plt.show()

</t>
<t tx="ekr.20241213022536.50">import numpy as np
import matplotlib.pyplot as plt
import os
import scipy.io
from sklearn import linear_model
from sklearn import model_selection
from scipy.optimize import minimize
from skimage.transform import resize
from matplotlib.image import imread


plt.rcParams['figure.figsize'] = [7, 7]
plt.rcParams.update({'font.size': 18})

mustache = imread(os.path.join('..','DATA','mustache.jpg'))
mustache = np.mean(mustache, -1); # Convert RGB to grayscale
mustache = (mustache/255).astype(int)
mustache = mustache.T

mat = scipy.io.loadmat(os.path.join('..','DATA','allFaces.mat'))
X = mat['faces']
nfaces = mat['nfaces'].reshape(-1)
n = mat['n']
n = int(n)
m = mat['m']
m = int(m)

</t>
<t tx="ekr.20241213022536.51">## Build Training and Test sets
nTrain = 30
nTest = 20
nPeople = 20
Train = np.zeros((X.shape[0],nTrain*nPeople))
Test = np.zeros((X.shape[0],nTest*nPeople))

for k in range(nPeople):
    baseind = 0
    if k &gt; 0:
        baseind = np.sum(nfaces[:k])
    inds = range(baseind,baseind+nfaces[k])
    Train[:,k*nTrain:(k+1)*nTrain] = X[:,inds[:nTrain]]
    Test[:,k*nTest:(k+1)*nTest] = X[:,inds[nTrain:(nTrain+nTest)]]

</t>
<t tx="ekr.20241213022536.52">## Downsample Training Images (Build Theta)
M = Train.shape[1]

Theta = np.zeros((120,M))
for k in range(M):
    temp = np.reshape(np.copy(Train[:,k]),(m,n))
    tempSmall = resize(temp, (10, 12), anti_aliasing=True)
    Theta[:,k] = np.reshape(tempSmall,120,1)

</t>
<t tx="ekr.20241213022536.53">## Renormalize Columns of Theta
normTheta = np.zeros(M)
for k in range(M):
    normTheta[k] = np.linalg.norm(Theta[:,k])
    Theta[:,k] = Theta[:,k]/normTheta[k]

</t>
<t tx="ekr.20241213022536.54">## Occlude Test Image (Test[:,125] = test image 6, person 7)
x1 = np.copy(Test[:,125]) # Clean image
x2 = np.copy(Test[:,125]) * mustache.reshape(n*m)
randvec = np.random.permutation(n*m)
first30 = randvec[:int(np.floor(0.3*len(randvec)))]
vals30 = (255*np.random.rand(*first30.shape)).astype(int)
x3 = np.copy(x1)
x3[first30] = vals30 # 30% occluded
x4 = np.copy(x1) + 50*np.random.randn(*x1.shape) # Random noise

</t>
<t tx="ekr.20241213022536.55">## Downsample Test Images
X = np.zeros((x1.shape[0],4))
X[:,0] = x1
X[:,1] = x2
X[:,2] = x3
X[:,3] = x4

Y = np.zeros((120,4))
for k in range(4):
    temp = np.reshape(np.copy(X[:,k]),(m,n))
    tempSmall = resize(temp, (10, 12), anti_aliasing=True)
    Y[:,k] = np.reshape(tempSmall,120,1)

</t>
<t tx="ekr.20241213022536.56">## L1 Search, Testclean
y1 = np.copy(Y[:,0])
eps = 0.01

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'ineq', 'fun': lambda x:  eps - np.linalg.norm(Theta @ x - y1,2)})
x0 = np.linalg.pinv(Theta) @ y1 # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s1 = res.x

</t>
<t tx="ekr.20241213022536.57">plt.figure()
plt.plot(s1)
plt.figure()
plt.imshow(np.reshape(Train @ (s1/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x1 - Train @ (s1/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x1-Train[:,L] @ (s1[L]/normTheta[L]))/np.linalg.norm(x1)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()


</t>
<t tx="ekr.20241213022536.58">## L1 Search, Mustache
y2 = np.copy(Y[:,1])
eps = 500

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'ineq', 'fun': lambda x:  eps - np.linalg.norm(Theta @ x - y2,2)})
x0 = np.linalg.pinv(Theta) @ y2 # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s2 = res.x

</t>
<t tx="ekr.20241213022536.59">plt.figure()
plt.plot(s2)
plt.figure()
plt.imshow(np.reshape(Train @ (s2/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x2 - Train @ (s2/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x2-Train[:,L] @ (s2[L]/normTheta[L]))/np.linalg.norm(x2)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()

</t>
<t tx="ekr.20241213022536.6"></t>
<t tx="ekr.20241213022536.60">## L1 Search, Occlusion
y3 = np.copy(Y[:,2])
eps = 1000

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'ineq', 'fun': lambda x:  eps - np.linalg.norm(Theta @ x - y3,2)})
x0 = np.linalg.pinv(Theta) @ y3 # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s3 = res.x

</t>
<t tx="ekr.20241213022536.61">plt.figure()
plt.plot(s3)
plt.figure()
plt.imshow(np.reshape(Train @ (s3/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x3 - Train @ (s3/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x3-Train[:,L] @ (s3[L]/normTheta[L]))/np.linalg.norm(x3)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()

</t>
<t tx="ekr.20241213022536.62">## L1 Search, Noise
y4 = np.copy(Y[:,3])
eps = 10

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'ineq', 'fun': lambda x:  eps - np.linalg.norm(Theta @ x - y4,2)})
x0 = np.linalg.pinv(Theta) @ y4 # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s4 = res.x

</t>
<t tx="ekr.20241213022536.63">plt.figure()
plt.plot(s4)
plt.figure()
plt.imshow(np.reshape(Train @ (s4/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x4 - Train @ (s4/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x4-Train[:,L] @ (s4[L]/normTheta[L]))/np.linalg.norm(x4)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()

</t>
<t tx="ekr.20241213022536.64">## Least Squares Is No Good
s4L2 = np.linalg.pinv(Train) @ x4
plt.figure()
plt.plot(s4L2)
plt.figure()
plt.imshow(np.reshape(Train @ (s4L2/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x4 - Train @ (s4L2/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x4-Train[:,L] @ (s4L2[L]/normTheta[L]))/np.linalg.norm(x4)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()

</t>
<t tx="ekr.20241213022536.65"></t>
<t tx="ekr.20241213022536.66"></t>
<t tx="ekr.20241213022536.67">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.69">import numpy as np
import matplotlib.pyplot as plt
import os
import scipy.io

plt.rcParams['figure.figsize'] = [7, 7]
plt.rcParams.update({'font.size': 18})

mat = scipy.io.loadmat(os.path.join('..','DATA','allFaces.mat'))
faces = mat['faces']
nfaces = mat['nfaces'].reshape(-1)


</t>
<t tx="ekr.20241213022536.7"></t>
<t tx="ekr.20241213022536.70">## Function Definitions

def shrink(X,tau):
    Y = np.abs(X)-tau
    return np.sign(X) * np.maximum(Y,np.zeros_like(Y))
def SVT(X,tau):
    U,S,VT = np.linalg.svd(X,full_matrices=0)
    out = U @ np.diag(shrink(S,tau)) @ VT
    return out
def RPCA(X):
    n1,n2 = X.shape
    mu = n1*n2/(4*np.sum(np.abs(X.reshape(-1))))
    lambd = 1/np.sqrt(np.maximum(n1,n2))
    thresh = 10**(-7) * np.linalg.norm(X)
    
    S = np.zeros_like(X)
    Y = np.zeros_like(X)
    L = np.zeros_like(X)
    count = 0
    while (np.linalg.norm(X-L-S) &gt; thresh) and (count &lt; 1000):
        L = SVT(X-S+(1/mu)*Y,1/mu)
        S = shrink(X-L+(1/mu)*Y,lambd/mu)
        Y = Y + mu*(X-L-S)
        count += 1
    return L,S


</t>
<t tx="ekr.20241213022536.71">X = faces[:,:nfaces[0]]
L,S = RPCA(X)

</t>
<t tx="ekr.20241213022536.72">inds = (3,4,14,15,17,18,19,20,21,32,43)

for k in inds:
    fig,axs = plt.subplots(2,2)
    axs = axs.reshape(-1)
    axs[0].imshow(np.reshape(X[:,k-1],(168,192)).T,cmap='gray')
    axs[0].set_title('X')
    axs[1].imshow(np.reshape(L[:,k-1],(168,192)).T,cmap='gray')
    axs[1].set_title('L')
    axs[2].imshow(np.reshape(S[:,k-1],(168,192)).T,cmap='gray')
    axs[2].set_title('S')
    for ax in axs:
        ax.axis('off')

</t>
<t tx="ekr.20241213022536.73"></t>
<t tx="ekr.20241213022536.74"></t>
<t tx="ekr.20241213022536.75"></t>
<t tx="ekr.20241213022536.76">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.78">import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize
from matplotlib import rcParams
rcParams['figure.figsize'] = [12, 8]
rcParams.update({'font.size': 18})


# Function definitions
def fit1(x0,t):
    x,y=t
    return np.max(np.abs(x0[0]*x + x0[1]-y))
def fit2(x0,t):
    x,y=t
    return np.sum(np.abs(x0[0]*x + x0[1]-y))
def fit3(x0,t):
    x,y=t
    return np.sum(np.power(np.abs(x0[0]*x + x0[1]-y),2))


</t>
<t tx="ekr.20241213022536.79"># The data
x = np.arange(1,11)
y = np.array([0.2,0.5,0.3,3.5,1.0,1.5,1.8,2.0,2.3,2.2])
t = (x,y)

x0 = np.array([1,1])
p1 = scipy.optimize.fmin(fit1,x0,args=(t,));
p2 = scipy.optimize.fmin(fit2,x0,args=(t,));
p3 = scipy.optimize.fmin(fit3,x0,args=(t,));

xf = np.arange(0,11,0.1)
y1 = np.polyval(p1,xf)
y2 = np.polyval(p2,xf)
y3 = np.polyval(p3,xf)

plt.figure()
plt.plot(xf,y1,color='k',label='E_\infty')
plt.plot(xf,y2,'--',color='k',LineWidth=2,label='E_1')
plt.plot(xf,y3,color='k',LineWidth=2,label='E_2')
plt.plot(x,y,'o',color='r',LineWidth=2)

plt.ylim(0,4)
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022536.8">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.80">x = np.arange(1,11)
y = np.array([0.2,0.5,0.3,0.7,1.0,1.5,1.8,2.0,2.3,2.2])
t = (x,y)

x0 = np.array([1,1])
p1 = scipy.optimize.fmin(fit1,x0,args=(t,));
p2 = scipy.optimize.fmin(fit2,x0,args=(t,));
p3 = scipy.optimize.fmin(fit3,x0,args=(t,));

xf = np.arange(0,11,0.1)
y1 = np.polyval(p1,xf)
y2 = np.polyval(p2,xf)
y3 = np.polyval(p3,xf)

plt.figure()
plt.plot(xf,y1,color='k',label='E_\infty')
plt.plot(xf,y2,'--',color='k',LineWidth=2,label='E_1')
plt.plot(xf,y3,color='k',LineWidth=2,label='E_2')
plt.plot(x,y,'o',color='r',LineWidth=2)

plt.ylim(0,4)
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022536.81"></t>
<t tx="ekr.20241213022536.82"></t>
<t tx="ekr.20241213022536.83">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022536.85">import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize
import scipy.interpolate
from matplotlib import rcParams
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241213022536.86">h = 0.5
x = np.arange(-6,6+h,h)
y = np.arange(-6,6+h,h)

X,Y = np.meshgrid(x,y)
F0 = 1.5 - 1.0*np.exp(-0.03*(3*np.power(X,2)+np.power(Y,2)))
F = 1.5 - 1.6*np.exp(-0.05*(3*np.power(X,2)+np.power(Y+3,2)))
F2 = F + (0.5 - 1.0*np.exp(-0.1*(3*np.power(X-3,2)+np.power(Y-3,2))))

# dF0x,dF0y = np.gradient(F0,h,h) 
# dF2x,dF2y = np.gradient(F2,h,h) 

dF0y,dF0x = np.gradient(F0,h,h) 
dF2y,dF2x = np.gradient(F2,h,h) 

</t>
<t tx="ekr.20241213022536.87">rcParams['figure.figsize'] = [16, 8]
fig,axs = plt.subplots(1,2,subplot_kw={'projection': '3d'})
axs[0].plot_surface(X, Y, F0, cmap='gray',linewidth=0, antialiased=False)
axs[0].contour(X, Y, F0, zdir='z', offset=axs[0].get_zlim()[0], cmap='gray')
axs[1].plot_surface(X, Y, F2, cmap='gray',linewidth=0, antialiased=False)
axs[1].contour(X, Y, F2, zdir='z', offset=axs[0].get_zlim()[0], cmap='gray')

plt.show()

</t>
<t tx="ekr.20241213022536.88">rcParams['figure.figsize'] = [16, 16]
fig,axs = plt.subplots(2,2,subplot_kw={'projection': '3d'})
axs = axs.reshape(-1)
axs[0].plot_surface(X, Y, dF0x, cmap='gray',linewidth=0, antialiased=False)
axs[2].plot_surface(X, Y, dF0y, cmap='gray',linewidth=0, antialiased=False)
axs[1].plot_surface(X, Y, dF2x, cmap='gray',linewidth=0, antialiased=False)
axs[3].plot_surface(X, Y, dF2y, cmap='gray',linewidth=0, antialiased=False)

plt.show()

</t>
<t tx="ekr.20241213022536.89">## Gradient Descent
x = np.zeros(10)
y = np.zeros(10)
f = np.zeros(10)

Fquad = np.power(X,2) + 3*np.power(Y,2)

x[0] = 3  # Initial guess
y[0] = 2 

f[0] = x[0]**2 + 3*y[0]**2 # Initial function value

for j in range(len(x)-1):
    Del = (x[j]**2 + 9*y[j]**2)/(2*x[j]**2 + 54*y[j]**2)
    x[j+1] = (1 - 2*Del)*x[j] # update values
    y[j+1] = (1 - 6*Del)*y[j]
    f[j+1] = x[j+1]**2 + 3*y[j+1]**2
    
    if np.abs(f[j+1]-f[j]) &lt; 10**(-6): # check convergence
        x = x[:j+2]
        y = y[:j+2]
        f = f[:j+2]
        break

</t>
<t tx="ekr.20241213022536.90">fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})
ax.plot_surface(X, Y, Fquad,linewidth=0,color='k',alpha=0.3)
ax.scatter(x,y,f,'o',color='r',s=200)
ax.plot(x,y,f,':',color='k',LineWidth=3)
ax.contour(X, Y, Fquad, zdir='z', offset=ax.get_zlim()[0], cmap='gray')
ax.view_init(elev=40, azim=-140)
plt.show()

</t>
<t tx="ekr.20241213022536.91">## Computing the gradient descent with fmin

h = 0.1
x = np.arange(-6,6+h,h)
y = np.arange(-6,6+h,h)
X,Y = np.meshgrid(x,y)

F1 = 1.5 - 1.6*np.exp(-0.05*(3*np.power(X+3,2)+np.power(Y+3,2)))
F = F1 + 0.5 - np.exp(-0.1*(3*np.power(X-3,2)+np.power(Y-3,2)))

dFy,dFx = np.gradient(F,h,h)

F_interp = scipy.interpolate.RectBivariateSpline(x,y,F)
dFx_interp = scipy.interpolate.RectBivariateSpline(x,y,dFx)
dFy_interp = scipy.interpolate.RectBivariateSpline(x,y,dFy)


x0 = np.array([4,0,-5])
y0 = np.array([0,-5,2])

def delsearch(Del,t):
    x,y,dfx,dfy,X,Y,F = t
    x0 = x-Del*dfx
    y0 = y-Del*dfy
    return F_interp(x0,y0)


for jj in range(3):
    x = np.zeros(10)
    y = np.zeros(10)
    f = np.zeros(10)
    x[0] = x0[jj]
    y[0] = y0[jj]
    f[0] = F_interp(x[0],y[0])
    dfx = dFx_interp(x[0],y[0])
    dfy = dFy_interp(x[0],y[0])
    for j in range(len(x)-1):
        t = x[j],y[j],dfx,dfy,X,Y,F
        Del = scipy.optimize.fmin(delsearch,0.2,args=(t,),disp=False);
        x[j+1] = x[j]-Del*dfx # Update x, y, and f
        y[j+1] = y[j]-Del*dfy
        f[j+1] = F_interp(x[j+1],y[j+1])
        dfx = dFx_interp(x[j+1],y[j+1])
        dfy = dFy_interp(x[j+1],y[j+1])
        
        if np.abs(f[j+1]-f[j]) &lt; 10**(-6):
            x = x[:j+2]
            y = y[:j+2]
            f = f[:j+2]
            break
    
    if jj == 0:
        x1 = x
        y1 = y
        f1 = f
    if jj == 1:
        x2 = x
        y2 = y
        f2 = f
    if jj == 2:
        x3 = x
        y3 = y
        f3 = f

</t>
<t tx="ekr.20241213022536.92">rcParams['figure.figsize'] = [12, 8]
plt.figure()
plt.contour(X,Y,F-1,10,cmap='binary')
plt.plot(x1,y1,'o',color='r')
plt.plot(x1,y1,':',color='k')
plt.plot(x2,y2,'o',color='m')
plt.plot(x2,y2,':',color='k')
plt.plot(x3,y3,'o',color='b')
plt.plot(x3,y3,':',color='k')
plt.show()

</t>
<t tx="ekr.20241213022536.93">fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})
ax.plot_surface(X, Y, F-0.2,cmap='binary',alpha=0.5)
ax.plot(x1,y1,f1,'o',color='r',MarkerSize=10)
ax.plot(x1,y1,f1,':',color='k')
ax.plot(x2,y2,f2,'o',color='m',MarkerSize=10)
ax.plot(x2,y2,f2,':',color='k')
ax.plot(x3,y3,f3,'o',color='b',MarkerSize=10)
ax.plot(x3,y3,f3,':',color='k')
ax.view_init(elev=40, azim=-100)
plt.show()

</t>
<t tx="ekr.20241213022536.94">## Alternating Descent
h = 0.1
x = np.arange(-6,6+h,h)
y = np.arange(-6,6+h,h)
X,Y = np.meshgrid(x,y)

F1 = 1.5 - 1.6*np.exp(-0.05*(3*np.power(X+3,2)+np.power(Y+3,2)))
F = F1 + 0.5 - np.exp(-0.1*(3*np.power(X-3,2)+np.power(Y-3,2)))

F_interp = scipy.interpolate.RectBivariateSpline(x,y,F)

x0 = np.array([4,0,-5])
y0 = np.array([0,-5,2])

for jj in range(3):
    xa = np.zeros(5)
    ya = np.zeros(5)
    f = np.zeros(5)
    xa[0] = x0[jj]
    ya[0] = y0[jj]
    f[0] = F_interp(xa[0],ya[0])
    
    fx = F_interp(xa[0],y)
    xa[1]=xa[0]
    ya[1]=y[np.argmin(fx)]
    
    fy = F_interp(x,ya[1])
    ya[2]=ya[1]
    xa[2]=x[np.argmin(fy)]
    
    fx = F_interp(xa[2],y)
    xa[3]=xa[2]
    ya[3]=y[np.argmin(fx)]
    
    fy = F_interp(x,ya[3])
    ya[4]=ya[3]
    xa[4]=x[np.argmin(fy)]
    
    for j in range(1,5):
        f[j] = F_interp(xa[j],ya[j])
    
    if jj == 0:
        x1 = xa
        y1 = ya
        f1 = f
    if jj == 1:
        x2 = xa
        y2 = ya
        f2 = f
    if jj == 2:
        x3 = xa
        y3 = ya
        f3 = f

</t>
<t tx="ekr.20241213022536.95">rcParams['figure.figsize'] = [12, 8]
plt.figure()
plt.contour(X,Y,F-1,10,cmap='binary')
plt.plot(x1,y1,'o',color='r')
plt.plot(x1,y1,':',color='k')
plt.plot(x2,y2,'o',color='m')
plt.plot(x2,y2,':',color='k')
plt.plot(x3,y3,'o',color='b')
plt.plot(x3,y3,':',color='k')
plt.show()

</t>
<t tx="ekr.20241213022536.96">fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})
ax.plot_surface(X, Y, F-0.2,cmap='binary',alpha=0.5)
ax.plot(x1,y1,f1,'o',color='r',MarkerSize=10)
ax.plot(x1,y1,f1,':',color='k')
ax.plot(x2,y2,f2,'o',color='m',MarkerSize=10)
ax.plot(x2,y2,f2,':',color='k')
ax.plot(x3,y3,f3,'o',color='b',MarkerSize=10)
ax.plot(x3,y3,f3,':',color='k')
ax.view_init(elev=40, azim=-100)
plt.show()

</t>
<t tx="ekr.20241213022536.97"></t>
<t tx="ekr.20241213022536.98">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.1">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.10">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.100">plt.plot(t,y,color=(0.5,0.5,0.5),label='y (measured)')
plt.plot(t,xtrue[:,0],color='k',label='y (no noise)')
plt.plot(t,xhat[:,0],color=(0,0.447,0.741),label='y (KF estimate)')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022537.101">x_labels = ('x','v','theta','omega')
[plt.plot(t,xtrue[:,k],linewidth=1.2,label=x_labels[k]) for k in range(4)]
plt.gca().set_prop_cycle(None) # reset color cycle
[plt.plot(t,xhat[:,k],'--',linewidth=2,label=x_labels[k]+'_hat') for k in range(4)]
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022537.102"></t>
<t tx="ekr.20241213022537.103">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.105">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241213022537.106">s = tf(np.array([1,0]),np.array([0,1]))
G = 1/(s**2 + s + 2)
w, mag, phase = bode(G)

</t>
<t tx="ekr.20241213022537.107">A = np.array([[0,1],[-2,-1]])
B = np.array([0,1]).reshape((2,1))
C = np.array([1,0])
D = 0
G = ss2tf(A,B,C,D)

ia,it = impulse(G)

plt.plot(it[[0,-1]],np.array([0,0]),'k:')
plt.plot(it,ia)
plt.title('Impulse Response')
plt.ylabel('Amplitude')
plt.xlabel('Time')
plt.show()

</t>
<t tx="ekr.20241213022537.108"></t>
<t tx="ekr.20241213022537.109">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.111">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241213022537.112">s = tf(np.array([1,0]),np.array([0,1]))
L = 1/s
S = (1/(1+L))
T = L/(1+L)
_,_,_ = bode(L,label='L')
_,_,_ = bode(S,label='S')
_,_,_ = bode(T,label='T')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022537.113"></t>
<t tx="ekr.20241213022537.114">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.116">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241213022537.117">s = tf(np.array([1,0]),np.array([0,1]))
G = (s+1)/(s-2)
Gtrue = (s+0.9)/(s-1.9)

K = 1/G

L = K*Gtrue


fig = plt.figure()
gm, pm, wg, wp = margin(L)
_,_,_ = bode(L)
for ax in fig.axes:
    xl = ax.get_xlim()
    yl = ax.get_ylim()
    ax.plot(wg*np.ones(2),ax.get_ylim(),'k--',linewidth=2)
    ax.plot(wp*np.ones(2),ax.get_ylim(),'k--',linewidth=2)
    ax.plot(ax.get_xlim(),np.zeros(2),'k--',linewidth=2)
    ax.set_xlim(xl)
    ax.set_ylim(yl)
    
CL = feedback(L,1)
CL

</t>
<t tx="ekr.20241213022537.118"></t>
<t tx="ekr.20241213022537.119"></t>
<t tx="ekr.20241213022537.12">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import integrate
from mpl_toolkits.mplot3d import Axes3D

from keras.models import Sequential
from keras.layers import Dense, Conv2D, Flatten, MaxPool2D
from keras import optimizers
from keras.layers import Activation
from keras.utils.generic_utils import get_custom_objects
from keras import backend as K


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022537.120"></t>
<t tx="ekr.20241213022537.121">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.123">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal
from scipy.linalg import fractional_matrix_power
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241213022537.124">A = np.array([[-0.75,1],[-0.3,-0.75]])
B = np.array([2,1]).reshape((2,1))
C = np.array([1,2])
D = 0

sys = ss(A,B,C,D)

Wc = gram(sys,'c') # Controllability Gramian
Wo = gram(sys,'o') # Observability Gramian

sysb = balred(sys,len(B)) # Balance the system

BWc = gram(sysb,'c') # Balanced Gramians
BWo = gram(sysb,'o')

</t>
<t tx="ekr.20241213022537.125"># Manually compute transform matrix for balanced Gramians
_,Tu = np.linalg.eig(Wc@Wo)

# Resolve sign ambiguity of eigenvectors
for j in range(Tu.shape[1]):
    if Tu[0,j] &lt; 0:
        Tu[:,j] = -Tu[:,j]
        
Sig_c = np.linalg.inv(Tu) @ Wc @ np.linalg.inv(Tu).T
Sig_o = Tu.T @ Wo @ Tu
Sig_s = fractional_matrix_power(Sig_c,1/4) @ fractional_matrix_power(Sig_o,-1/4)

T = Tu @ Sig_s
Ti = np.linalg.inv(T)

</t>
<t tx="ekr.20241213022537.126">## Plot Gramians
theta = np.arange(0,2*np.pi,0.01)
xc = np.cos(theta)
yc = np.sin(theta)
CIRC = np.row_stack((xc,yc))

# Off-diagonals should be within machine precision of 0, but
# in case that machine error is negative we manually threshold them:
BWc[BWc&lt;0] = 0
BWo[BWo&lt;0] = 0

ELLIPb = Ti @ np.sqrt(BWc) @ T @ CIRC
ELLIPc = np.sqrt(Wc) @ CIRC
ELLIPo = np.sqrt(Wo) @ CIRC

</t>
<t tx="ekr.20241213022537.127">plt.plot(xc,yc,'k--',linewidth=2)

# Draw controllability Gramian (unbalanced)
plt.plot(ELLIPc[0,:],ELLIPc[1,:],'r',linewidth=2)
plt.fill(ELLIPc[0,:],ELLIPc[1,:],'r',alpha=0.75)

# Draw observability Gramian (unbalanced)
plt.plot(ELLIPo[0,:],ELLIPo[1,:],'b',linewidth=2)
plt.fill(ELLIPo[0,:],ELLIPo[1,:],'b',alpha=0.75)

# Draw balanced Gramians
plt.plot(ELLIPb[0,:],ELLIPb[1,:],color=(0.35,0,0.35),linewidth=2)
plt.fill(ELLIPb[0,:],ELLIPb[1,:],color=(0.5,0,0.5),alpha=0.25)

plt.show()

</t>
<t tx="ekr.20241213022537.128"></t>
<t tx="ekr.20241213022537.129">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.13">## Simulate the Lorenz System

dt = 0.01
T = 8
t = np.arange(0,T+dt,dt)
beta = 8/3
sigma = 10
rho = 28


nn_input = np.zeros((100*(len(t)-1),3))
nn_output = np.zeros_like(nn_input)

fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})


def lorenz_deriv(x_y_z, t0, sigma=sigma, beta=beta, rho=rho):
    x, y, z = x_y_z
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]

np.random.seed(123)
x0 = -15 + 30 * np.random.random((100, 3))

x_t = np.asarray([integrate.odeint(lorenz_deriv, x0_j, t)
                  for x0_j in x0])

for j in range(100):
    nn_input[j*(len(t)-1):(j+1)*(len(t)-1),:] = x_t[j,:-1,:]
    nn_output[j*(len(t)-1):(j+1)*(len(t)-1),:] = x_t[j,1:,:]
    x, y, z = x_t[j,:,:].T
    ax.plot(x, y, z,linewidth=1)
    ax.scatter(x0[j,0],x0[j,1],x0[j,2],color='r')
             
ax.view_init(18, -113)
plt.show()


</t>
<t tx="ekr.20241213022537.131">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
import os
from scipy import signal, io
from scipy.linalg import fractional_matrix_power

# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241213022537.132">testSys_mat = io.loadmat(os.path.join('..','DATA','testSys_ABCD.mat'))
A = testSys_mat['A']
B = testSys_mat['B']
C = testSys_mat['C']
D = testSys_mat['D']

sysFull = ss(A,B,C,D,1)
r = 10 # Reduced model order

</t>
<t tx="ekr.20241213022537.133">## Plot Hankel Singular Values
# n_stable = np.count_nonzero(np.logical_and(np.linalg.eigvals(sysFull.A).real &gt;= 0, np.linalg.eigvals(sysFull.A).real &lt;= 1))
# sysFull_stable = balred(sysFull,n_stable,method='truncate',alpha=np.array([0,1])) # This is necessary to remove unstable eigenvalues
# hsvs = hsvd(sysFull_stable) # Hankel singular values
hsvs = hsvd(sysFull)

</t>
<t tx="ekr.20241213022537.134"># Balanced truncation
sysBT = balred(sysFull,r)

</t>
<t tx="ekr.20241213022537.135"># Compute BPOD

yFull = np.zeros((r*5+2,p,q))
xFull = np.zeros((r*5+2,n,q))
yAdj = np.zeros_like(yFull)
xAdj = np.zeros_like(xFull)

sysAdj = ss(sysFull.A.T,sysFull.C.T,sysFull.B.T,sysFull.D.T,1)

for qi in range(q):
    yFull[:,:,qi],_,xFull[:,:,qi] = impulse(sysFull,T=np.arange(0,(r*5+2),1),input=qi,return_x=True)
    yAdj[:,:,qi],_,xAdj[:,:,qi] = impulse(sysAdj,T=np.arange(0,(r*5+2),1),input=qi,return_x=True)


# Not the fastest way to compute, but illustrative
# Both xAdj and xFull are size (length of t) * (number of states) * (number of inputs)


HankelOC = np.zeros((q*(r*5+1),q*(r*5+1)))
for i in range(xAdj.shape[0]-1): # start at 1 to avoid the D matrix
    for j in range(xFull.shape[0]-1):
        Ystar = np.swapaxes(np.squeeze(xAdj[i+1,:,:]),0,1);        
        MarkovParameter = Ystar@np.squeeze(xFull[j+1,:,:]);
        HankelOC[np.ix_(range(q*i,q*(i+1)),range(q*j,q*(j+1)))] = MarkovParameter

U,Sig,VT = np.linalg.svd(HankelOC)
Sig = np.diag(Sig)
V = VT.T

Xdata = np.zeros((n,q*(xFull.shape[0]-1)))
Ydata = np.zeros((n,q*(xFull.shape[0]-1)))
for i in range(xFull.shape[0]-1):
    Xdata[:,range(q*i,q*(i+1))] = xFull[i+1,:,:]
    Ydata[:,range(q*i,q*(i+1))] = xAdj[i+1,:,:]
    
Phi = Xdata @ V @ fractional_matrix_power(Sig,-1/2)
Psi = Ydata @ U @ fractional_matrix_power(Sig,-1/2)

Ar = Psi[:,:r].T @ sysFull.A @ Phi[:,:r]
Br = Psi[:,:r].T @ sysFull.B
Cr = sysFull.C @ Phi[:,:r]
Dr = sysFull.D

sysBPOD = ss(Ar,Br,Cr,Dr,1)

</t>
<t tx="ekr.20241213022537.136">## Plot impulse responses for all methods
yout_full,tout_full = impulse(sysFull,np.arange(0,60,1))
yout_BT,tout_BT = impulse(sysBT,np.arange(0,60,1))
yout_BPOD,tout_BPOD = impulse(sysBPOD,np.arange(0,60,1))

plt.plot(tout_full,yout_full,label='Full model, n=100')
plt.plot(tout_BT,yout_BT,label='Balanced truncation, r=10')
plt.plot(tout_BPOD,yout_BPOD,label='Balanced POD, r=10')
plt.show()

</t>
<t tx="ekr.20241213022537.137"></t>
<t tx="ekr.20241213022537.138">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.14">## Neural Net

# Define activation functions
def logsig(x):
    return K.variable(np.divide(1,(1+np.exp(-K.eval(x)))))

def radbas(x):
    return K.variable(np.exp(-np.power(K.eval(x),2)))

def purelin(x):
    return x


#create model
model = Sequential()

#add model layers
model.add(Dense(10, activation=logsig))
model.add(Dense(10, activation=radbas))
model.add(Dense(10, activation=purelin))




sgd_optimizer = optimizers.SGD(momentum=0.9)
model.compile(optimizer=sgd_optimizer, loss='categorical_crossentropy')
model.fit(nn_input, nn_output, epochs=30)

</t>
<t tx="ekr.20241213022537.140">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal,io
import os
from scipy.linalg import fractional_matrix_power

# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241213022537.141">q = 2   # Number of inputs
p = 2   # Number of outputs
n = 100 # State dimension
r = 10 # Reduced model order

testSys_mat = io.loadmat(os.path.join('..','DATA','testSys_ABCD.mat'))
A = testSys_mat['A']
B = testSys_mat['B']
C = testSys_mat['C']
D = testSys_mat['D']

sysFull = ss(A,B,C,D,1)

</t>
<t tx="ekr.20241213022537.142">yFull = np.zeros((r*5+2,p,q))
tspan = np.arange(0,(r*5+2),1)
m = len(tspan)

for qi in range(q):
    yFull[:,:,qi],t = impulse(sysFull,T=tspan,input=qi)


YY = np.transpose(yFull,axes=(1,2,0)) # reorder to size p x q x m


</t>
<t tx="ekr.20241213022537.143">## ERA and OKID Function Definitions

def ERA(YY,m,n,nin,nout,r):
    Dr = np.zeros((nout,nin))
    Y = np.zeros((nout,nin,YY.shape[2]-1))
    for i in range(nout):
        for j in range(nin):
            Dr[i,j] = YY[i,j,0]
            Y[i,j,:] = YY[i,j,1:]
            
    assert len(Y[:,1,1]) == nout
    assert len(Y[1,:,1]) == nin
    assert len(Y[1,1,:]) &gt;= m+n
    
    H = np.zeros((nout*m,nin*n))
    H2 = np.zeros((nout*m,nin*n))
    
    for i in range(m):
        for j in range(n):
            for Q in range(nout):
                for P in range(nin):
                    H[nout*i+Q,nin*j+P] = Y[Q,P,i+j]
                    H2[nout*i+Q,nin*j+P] = Y[Q,P,i+j+1]
                    
    U,S,VT = np.linalg.svd(H,full_matrices=0)
    V = VT.T
    Sigma = np.diag(S[:r])
    Ur = U[:,:r]
    Vr = V[:,:r]
    Ar = fractional_matrix_power(Sigma,-0.5) @ Ur.T @ H2 @ Vr @ fractional_matrix_power(Sigma,-0.5)
    Br = fractional_matrix_power(Sigma,-0.5) @ Ur.T @ H[:,:nin]
    Cr = H[:nout,:] @ Vr @ fractional_matrix_power(Sigma,-0.5)
    HSVs = S
    
    return Ar,Br,Cr,Dr,HSVs

def OKID(y,u,r):
    # inputs:  y (sampled output), u (sampled input), r (effective system order)
    # outputs: H (Markov parameters), M (Observer gain)
    
    PP = y.shape[0] # number of outputs
    MM = y.shape[1] # number of output samples
    QQ = u.shape[0] # number of inputs
    lu = u.shape[1] # number of input samples
    
    assert MM == lu
    
    LL = r*5
    
    # Form data matrices y and V
    V = np.zeros((QQ+(QQ+PP)*LL,MM))
    for i in range(MM):
        V[:QQ,i] = u[:QQ,i]
        
    for i in range(1,LL+1):
        for j in range(MM-i):
            vtemp = np.concatenate((u[:,j],y[:,j]))
            V[QQ+(i-1)*(QQ+PP):QQ+i*(QQ+PP),i+j] = vtemp
    
    # Solve for observer Markov parameters Ybar
    Ybar = y @ np.linalg.pinv(V,rcond=10**(-3))
    
    # Isolate system Markov parameters H, and observer gain M
    D = Ybar[:,:QQ] # feed-through term (or D matrix) is the first term
    
    Y = np.zeros((PP,QQ,LL))
    Ybar1 = np.zeros((PP,QQ,LL))
    Ybar2 = np.zeros((PP,QQ,LL))
    
    for i in range(LL):
        Ybar1[:,:,i] = Ybar[:,QQ+(QQ+PP)*i : QQ+(QQ+PP)*i+QQ]
        Ybar2[:,:,i] = Ybar[:,QQ+(QQ+PP)*i+QQ : QQ+(QQ+PP)*(i+1)]
    
    Y[:,:,0] = Ybar1[:,:,0] + Ybar2[:,:,0] @ D
    for k in range(1,LL):
        Y[:,:,k] = Ybar1[:,:,k] + Ybar2[:,:,k] @ D
        for i in range(k-1):
            Y[:,:,k] += Ybar2[:,:,i] @ Y[:,:,k-i-1]
            
    H = np.zeros((D.shape[0],D.shape[1],LL+1))
    H[:,:,0] = D
    
    for k in range(1,LL+1):
        H[:,:,k] = Y[:,:,k-1]
        
    return H


</t>
<t tx="ekr.20241213022537.144">## Compute ERA from impulse response
mco = int(np.floor((yFull.shape[0]-1)/2)) # m_c = m_o = (m-1)/2
Ar,Br,Cr,Dr,HSVs = ERA(YY,mco,mco,q,p,r)
sysERA = ss(Ar,Br,Cr,Dr,1)

</t>
<t tx="ekr.20241213022537.145">## Compute random input simulation for OKID
uRandom = np.random.randn(q,200) # Random forcing input
yRandom = lsim(sysFull,uRandom,range(200))[0].T # Output

</t>
<t tx="ekr.20241213022537.146">## Compute OKID and then ERA
H = OKID(yRandom,uRandom,r)
mco = int(np.floor((H.shape[2]-1)/2)) # m_c = m_o
Ar,Br,Cr,Dr,HSVs = ERA(H,mco,mco,q,p,r)
sysERAOKID = ss(Ar,Br,Cr,Dr,1)

</t>
<t tx="ekr.20241213022537.147">## Plot impulse responses for all methods

y1 = np.zeros((200,p,q))
y2 = np.zeros((100,p,q))
y3 = np.zeros((100,p,q))

for qi in range(q):
    y1[:,:,qi],t1 = impulse(sysFull,np.arange(200),input=qi)
    y2[:,:,qi],t2 = impulse(sysERA,np.arange(100),input=qi)
    y3[:,:,qi],t3 = impulse(sysERAOKID,np.arange(100),input=qi)

    


fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[0].step(t1,y1[:,0,0],linewidth=2)
axs[0].step(t2,y2[:,0,0],linewidth=1.2)
axs[0].step(t3,y3[:,0,0],linewidth=1)
axs[0].set_ylabel('y1')
axs[0].set_title('u1')

axs[1].step(t1,y1[:,0,1],linewidth=2)
axs[1].step(t2,y2[:,0,1],linewidth=1.2)
axs[1].step(t3,y3[:,0,1],linewidth=1)
axs[1].set_title('u2')

axs[2].step(t1,y1[:,1,0],linewidth=2)
axs[2].step(t2,y2[:,1,0],linewidth=1.2)
axs[2].step(t3,y3[:,1,0],linewidth=1)
axs[2].set_ylabel('y2')

axs[3].step(t1,y1[:,1,1],linewidth=2,label='Full model, n=100')
axs[3].step(t2,y2[:,1,1],linewidth=1.2,label='ERA, r={}'.format(r))
axs[3].step(t3,y3[:,1,1],linewidth=1,label='ERA/OKID, r={}'.format(r))
axs[3].legend(prop={'size': 12})

for ax in axs:
    ax.set_xlim(0,60)

plt.show()

</t>
<t tx="ekr.20241213022537.148">## Plot input/output pair for OKID
fig,axs = plt.subplots(2)

axs[0].set_title('Inputs')
axs[0].step(range(uRandom.shape[1]),uRandom[0,:],label='u1')
axs[0].step(range(uRandom.shape[1]),uRandom[1,:],label='u2')
axs[0].set_xlabel('t')
axs[0].set_ylabel('u')

axs[1].set_title('Outputs')
axs[1].step(range(yRandom.shape[1]),uRandom[0,:],label='y1')
axs[1].step(range(yRandom.shape[1]),uRandom[1,:],label='y2')
axs[1].set_xlabel('t')
axs[1].set_ylabel('y')

for ax in axs:
    ax.legend(prop={'size': 12})


plt.show()

</t>
<t tx="ekr.20241213022537.149">uRandom.shape

</t>
<t tx="ekr.20241213022537.15">nn_input.shape

</t>
<t tx="ekr.20241213022537.150"></t>
<t tx="ekr.20241213022537.151">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.153">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal,io
import os
from scipy.linalg import fractional_matrix_power

# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241213022537.154">q = 2   # Number of inputs
p = 2   # Number of outputs
n = 100 # State dimension
r = 10 # Reduced model order

testSys_mat = io.loadmat(os.path.join('..','DATA','testSys_Fig9p5_ABCD.mat'))
A = testSys_mat['A']
B = testSys_mat['B']
C = testSys_mat['C']
D = testSys_mat['D']

sys = ss(A,B,C,D,1)

</t>
<t tx="ekr.20241213022537.155">## Figure 1 = simple impulse response

tspan = np.arange(100)
y,t = impulse(sys,T=tspan)
t = np.concatenate((np.arange(-10,0,1),t))
y = np.concatenate((np.zeros((10,1)),y))
u = np.zeros_like(y)
u[10] = 1

</t>
<t tx="ekr.20241213022537.156">plt.step(t,u,'k',linewidth=1.5)
plt.grid()
plt.title('u')
plt.show()

</t>
<t tx="ekr.20241213022537.157">plt.step(t,y,'k',linewidth=1.5)
plt.grid()
plt.title('y')
plt.show()

</t>
<t tx="ekr.20241213022537.158">## FIgure 2 - OKID response

t = np.arange(100)
u = np.zeros_like(t)
u[:50] = np.random.randn(50)
y,t,_ = lsim(sys,u,t)

t = np.concatenate((np.arange(-10,0,1),t))
y = np.concatenate((np.zeros((10,1)),y))
u = np.concatenate((np.zeros(10),u))

</t>
<t tx="ekr.20241213022537.159">plt.step(t,u,'k',linewidth=1.5)
plt.grid()
plt.title('u')
plt.show()

</t>
<t tx="ekr.20241213022537.16"></t>
<t tx="ekr.20241213022537.160">plt.step(t,y,'k',linewidth=1.5)
plt.grid()
plt.title('y')
plt.show()
</t>
<t tx="ekr.20241213022537.161"></t>
<t tx="ekr.20241213022537.162">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.164">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io, signal
import os

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022537.165">J = lambda u,t: (25-np.power((5-u),2)) 
u = 0
y0 = J(u,0)

</t>
<t tx="ekr.20241213022537.166">## Extremum Seeking Control Parameters
freq = 10*2*np.pi # sample frequency
dt = 1/freq
T = 10 # total period of simulation (in seconds)
A = 0.2 # amplitude
omega = 10*2*np.pi # 10 Hz
phase = 0
K = 5 # Integration gain

</t>
<t tx="ekr.20241213022537.167">## High pass filter (Butterworth filter)
butterorder = 1
butterfreq = 2 # in Hz
butterfreq = butterfreq/(freq/2) # normalize to Nyquist frequency
b,a = signal.butter(butterorder,butterfreq,'highpass')
ys = np.zeros(butterorder+1)+y0
HPF = np.zeros(butterorder+1)

uhat = u
yvals = np.zeros(int(T/dt))
uhats = np.zeros_like(yvals)
uvals = np.zeros_like(yvals)
for ii in range(int(T/dt)):
    t = ii*dt
    yvals[ii] = J(u,t)
    for k in range(butterorder):
        ys[k] = ys[k+1]
        HPF[k] = HPF[k+1]
    ys[butterorder] = yvals[ii]
    HPFnew = 0
    for k in range(butterorder+1):
        HPFnew = HPFnew + b[k]*ys[butterorder-k]
    for k in range(1,butterorder+1):
        HPFnew = HPFnew - a[k]*HPF[butterorder-k]
    
    HPF[butterorder] = HPFnew
    
    xi = HPFnew*np.sin(omega*t + phase)
    uhat = uhat + xi*K*dt
    u = uhat + A*np.sin(omega*t + phase)
    uhats[ii] = uhat
    uvals[ii] = u

</t>
<t tx="ekr.20241213022537.168">## Figures
tspan = dt*np.arange(int(T/dt))
fig,axs = plt.subplots(2,1)
axs[0].plot(tspan,uvals,linewidth=1.2,label='u')
axs[0].plot(tspan,uhats,linewidth=1.2,label='uhat')
axs[0].legend()
axs[0].grid()

axs[1].plot(tspan,yvals,linewidth=1.2)
axs[1].grid()
axs[1].set_ylim(-1,26)

plt.show()

</t>
<t tx="ekr.20241213022537.169"></t>
<t tx="ekr.20241213022537.17"></t>
<t tx="ekr.20241213022537.170"></t>
<t tx="ekr.20241213022537.171">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.173">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io, signal
import os

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022537.174">J = lambda u,t: (25-np.power((5-u-np.sin(t)),2)) 
u = 0
y0 = J(u,0)

</t>
<t tx="ekr.20241213022537.175">## Extremum Seeking Control Parameters
freq = 100 # sample frequency
dt = 1/freq
T = 100 # total period of simulation (in seconds)
A = 0.2 # amplitude
omega = 10*2*np.pi # 10 Hz
phase = 0
K = 5 # Integration gain

</t>
<t tx="ekr.20241213022537.176">## High pass filter (Butterworth filter)
butterorder = 1
butterfreq = 2 # in Hz
butterfreq = butterfreq/(freq/2) # normalize to Nyquist frequency
b,a = signal.butter(butterorder,butterfreq,'highpass')
ys = np.zeros(butterorder+1)+y0
HPF = np.zeros(butterorder+1)

uhat = u
yvals = np.zeros(int(T/dt))
uhats = np.zeros_like(yvals)
uvals = np.zeros_like(yvals)
for ii in range(int(T/dt)):
    t = ii*dt
    yvals[ii] = J(u,t)
    for k in range(butterorder):
        ys[k] = ys[k+1]
        HPF[k] = HPF[k+1]
    ys[butterorder] = yvals[ii]
    HPFnew = 0
    for k in range(butterorder+1):
        HPFnew = HPFnew + b[k]*ys[butterorder-k]
    for k in range(1,butterorder+1):
        HPFnew = HPFnew - a[k]*HPF[butterorder-k]
    
    HPF[butterorder] = HPFnew
    
    xi = HPFnew*np.sin(omega*t + phase)
    uhat = uhat + xi*K*dt
    u = uhat + A*np.sin(omega*t + phase)
    uhats[ii] = uhat
    uvals[ii] = u

</t>
<t tx="ekr.20241213022537.177">## Figures
tspan = dt*np.arange(int(T/dt))
fig,axs = plt.subplots(2,1)
axs[0].plot(tspan,uvals,linewidth=1.2,label='u')
axs[0].plot(tspan,uhats,linewidth=1.2,label='uhat')
axs[0].legend()
axs[0].grid()

axs[1].plot(tspan,yvals,linewidth=1.2)
axs[1].grid()
axs[1].set_ylim(-1,26)

plt.show()

</t>
<t tx="ekr.20241213022537.178"></t>
<t tx="ekr.20241213022537.18">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.20">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022537.21">startval = 1
endval = 4
xvals = np.array([[],[]])
n_iter = 1000
n_plot = 100

def logistic(xk,r):
    return r*xk*(1-xk)

for r in np.arange(startval,endval,0.00025):
    x = 0.5
    for i in range(n_iter):
        x = logistic(x,r)
        if i == n_iter-n_plot:
            xss = x
        if i &gt; n_iter-n_plot:
            xvals = np.append(xvals,np.array([[r],[x]]),axis=1)
            if np.abs(x-xss) &lt; 0.001:
                break


</t>
<t tx="ekr.20241213022537.22">plt.plot(xvals[1,:],xvals[0,:],'.',ms=0.1,color='k')
plt.xlim(0,1)
plt.ylim(1,endval)
plt.gca().invert_yaxis()

</t>
<t tx="ekr.20241213022537.23">plt.plot(xvals[1,:],xvals[0,:],'.',ms=0.1,color='k')
plt.xlim(0,1)
plt.ylim(3.45,4)
plt.gca().invert_yaxis()

</t>
<t tx="ekr.20241213022537.24"></t>
<t tx="ekr.20241213022537.25">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.27">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D
from scipy import integrate


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022537.28">## Simulate the Lorenz System

dt = 0.001
T = 50
t = np.arange(0,T+dt,dt)
beta = 8/3
sigma = 10
rho = 28

fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})


def lorenz_deriv(x_y_z, t0, sigma=sigma, beta=beta, rho=rho):
    x, y, z = x_y_z
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]

np.random.seed(123)
x0 = (0,1,20)

x_t = integrate.odeint(lorenz_deriv, x0, t,rtol=10**(-12),atol=10**(-12)*np.ones_like(x0))

x, y, z = x_t.T
plt.plot(x, y, z,linewidth=1)
plt.scatter(x0[0],x0[1],x0[2],color='r')
             
ax.view_init(18, -113)
plt.show()

</t>
<t tx="ekr.20241213022537.29"></t>
<t tx="ekr.20241213022537.3">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from keras.utils import to_categorical
from keras.models import Sequential
from keras.layers import Dense, Conv2D, Flatten, MaxPool2D
from keras import optimizers


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022537.30"></t>
<t tx="ekr.20241213022537.31">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.33">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [8, 16]

</t>
<t tx="ekr.20241213022537.34">vortall_mat = io.loadmat(os.path.join('..','DATA','VORTALL.mat'))
X = vortall_mat['VORTALL']
# VORTALL contains flow fields reshaped into column vectors

</t>
<t tx="ekr.20241213022537.35">def DMD(X,Xprime,r):
    U,Sigma,VT = np.linalg.svd(X,full_matrices=0) # Step 1
    Ur = U[:,:r]
    Sigmar = np.diag(Sigma[:r])
    VTr = VT[:r,:]
    Atilde = np.linalg.solve(Sigmar.T,(Ur.T @ Xprime @ VTr.T).T).T # Step 2
    Lambda, W = np.linalg.eig(Atilde) # Step 3
    Lambda = np.diag(Lambda)
    
    Phi = Xprime @ np.linalg.solve(Sigmar.T,VTr).T @ W # Step 4
    alpha1 = Sigmar @ VTr[:,0]
    b = np.linalg.solve(W @ Lambda,alpha1)
    return Phi, Lambda, b


</t>
<t tx="ekr.20241213022537.36">Phi, Lambda, b = DMD(X[:,:-1],X[:,1:],21)

</t>
<t tx="ekr.20241213022537.37">## Plot Mode 2
vortmin = -5
vortmax = 5
V2 = np.copy(np.real(np.reshape(Phi[:,1],(449,199))))
V2 = V2.T

# normalize values... not symmetric
minval = np.min(V2)
maxval = np.max(V2)

if np.abs(minval) &lt; 5 and np.abs(maxval) &lt; 5:
    if np.abs(minval) &gt; np.abs(maxval):
        vortmax = maxval
        vortmin = -maxval
    else:
        vortmin = minval
        vortmax = -minval

V2[V2 &gt; vortmax] = vortmax
V2[V2 &lt; vortmin] = vortmin

plt.imshow(V2,cmap='jet',vmin=vortmin,vmax=vortmax)

cvals = np.array([-4,-2,-1,-0.5,-0.25,-0.155])
plt.contour(V2,cvals*vortmax/5,colors='k',linestyles='dashed',linewidths=1)
plt.contour(V2,np.flip(-cvals)*vortmax/5,colors='k',linestyles='solid',linewidths=0.4)

plt.scatter(49,99,5000,color='k') # draw cylinder


plt.show()

</t>
<t tx="ekr.20241213022537.38">V2 = np.real(np.reshape(Phi[:,1],(199,449)))

# plt.hist(np.real(Phi).reshape(-1),128)
plt.hist(V2.reshape(-1),128)
plt.show()

</t>
<t tx="ekr.20241213022537.39"></t>
<t tx="ekr.20241213022537.4">letters_train_mat = io.loadmat(os.path.join('..','DATA','lettersTrainSet.mat'))
letters_test_mat = io.loadmat(os.path.join('..','DATA','lettersTestSet.mat'))
XTrain = letters_train_mat['XTrain']
TTrain = letters_train_mat['TTrain_cell']
XTest = letters_test_mat['XTest']
TTest = letters_test_mat['TTest_cell']

perm = np.random.permutation(1500)[:20]


# By default, Keras expects data in form (batch, height, width, channels) 
XTrain = np.transpose(XTrain,axes=[3,0,1,2])
XTest = np.transpose(XTest,axes=[3,0,1,2])



fig,axs = plt.subplots(4,5)
axs = axs.reshape(-1)

for j in range(len(axs)):
    axs[j].imshow(np.squeeze(XTrain[perm[j],:,:,:]),cmap='gray')
    axs[j].axis('off')

</t>
<t tx="ekr.20241213022537.40"></t>
<t tx="ekr.20241213022537.41">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.43">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D
from scipy import integrate


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022537.44">## Simulate the Lorenz System

dt = 0.01
T = 50
t = np.arange(dt,T+dt,dt)
beta = 8/3
sigma = 10
rho = 28
n = 3

def lorenz_deriv(x_y_z, t0, sigma=sigma, beta=beta, rho=rho):
    x, y, z = x_y_z
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]

np.random.seed(123)
x0 = (-8,8,27)

x = integrate.odeint(lorenz_deriv, x0, t,rtol=10**(-12),atol=10**(-12)*np.ones_like(x0))


</t>
<t tx="ekr.20241213022537.45">## Compute Derivative
dx = np.zeros_like(x)
for j in range(len(t)):
    dx[j,:] = lorenz_deriv(x[j,:],0,sigma,beta,rho)


</t>
<t tx="ekr.20241213022537.46">## SINDy Function Definitions

def poolData(yin,nVars,polyorder):
    n = yin.shape[0]
    yout = np.zeros((n,1))
    
    # poly order 0
    yout[:,0] = np.ones(n)
    
    # poly order 1
    for i in range(nVars):
        yout = np.append(yout,yin[:,i].reshape((yin.shape[0],1)),axis=1)
    
    # poly order 2
    if polyorder &gt;= 2:
        for i in range(nVars):
            for j in range(i,nVars):
                yout = np.append(yout,(yin[:,i]*yin[:,j]).reshape((yin.shape[0],1)),axis=1)
                
    # poly order 3
    if polyorder &gt;= 3:
        for i in range(nVars):
            for j in range(i,nVars):
                for k in range(j,nVars):
                    yout = np.append(yout,(yin[:,i]*yin[:,j]*yin[:,k]).reshape((yin.shape[0],1)),axis=1)
    
    return yout

def sparsifyDynamics(Theta,dXdt,lamb,n):
    Xi = np.linalg.lstsq(Theta,dXdt,rcond=None)[0] # Initial guess: Least-squares
    
    for k in range(10):
        smallinds = np.abs(Xi) &lt; lamb # Find small coefficients
        Xi[smallinds] = 0                          # and threshold
        for ind in range(n):                       # n is state dimension
            biginds = smallinds[:,ind] == 0
            # Regress dynamics onto remaining terms to find sparse Xi
            Xi[biginds,ind] = np.linalg.lstsq(Theta[:,biginds],dXdt[:,ind],rcond=None)[0]
            
    return Xi


</t>
<t tx="ekr.20241213022537.47">Theta = poolData(x,n,3) # Up to third order polynomials
lamb = 0.025 # sparsification knob lambda
Xi = sparsifyDynamics(Theta,dx,lamb,n)

print(Xi)

</t>
<t tx="ekr.20241213022537.48"></t>
<t tx="ekr.20241213022537.49">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.5">classes = np.unique(TTrain)
y_train_label = np.zeros_like(TTrain)
y_test_label = np.zeros_like(TTest)
for nc in range(len(classes)):
    y_train_label[TTrain == classes[nc]] = nc
    y_test_label[TTest == classes[nc]] = nc

y_train_label = y_train_label.reshape(-1)
y_test_label = y_test_label.reshape(-1)
    
#one-hot encode categorical classes
y_train = to_categorical(y_train_label)
y_test = to_categorical(y_test_label)

</t>
<t tx="ekr.20241213022537.51">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D
from scipy import integrate


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022537.52">mu = -0.05
lamb = -1
A = np.array([[mu,0,0],[0,lamb,-lamb],[0,0,2*mu]]) # Koopman linear dynamics
D,T = np.linalg.eig(A)
slope_stab_man = T[2,2]/T[1,2] # slope of stable subspace (green)


</t>
<t tx="ekr.20241213022537.53">## Integrate Koopman trajectories

y0A = np.array([1.5,-1,2.25])
y0B = np.array([1,-1,1])
y0C = np.array([2,-1,4])
tspan = np.arange(0,1000,0.01)

def koopman_deriv(y,t0,A=A):
    return A@y

yA = integrate.odeint(koopman_deriv, y0A, tspan)
yB = integrate.odeint(koopman_deriv, y0B, tspan)
yC = integrate.odeint(koopman_deriv, y0C, tspan)


</t>
<t tx="ekr.20241213022537.54">## Plot invariant surfaces
fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})

# Attracting manifold y_2 = y_1^2  (red manifold)
X,Z = np.meshgrid(np.arange(-2,2,0.01),np.arange(-1,4,0.01))
Y = np.power(X,2)

ax.plot_surface(X,Y,Z,alpha=0.1,color='r',shade=True)

# Invariant set y_3 = y_1^2  (blue manifold)
X1,Y1 = np.meshgrid(np.arange(-2,2,0.01),np.arange(-1,4,0.01))
Z1 = np.power(X1,2)

ax.plot_surface(X1,Y1,Z1,alpha=0.1,color='b',shade=True)

# Stable invariant subspace of Koopman linear system  (green plane)
X2,Y2 = np.meshgrid(np.arange(-2,2,0.01),np.arange(0,4,0.01))
Z2 = slope_stab_man*Y2

ax.plot_surface(X2,Y2,Z2,alpha=0.7,color=(0.3,0.7,0.3),shade=True)

x = np.arange(-2,2,0.1)
# Intersection of green and blue surfaces (below)
ax.plot(x,(1/slope_stab_man)*np.power(x,2),np.power(x,2),color='g',linewidth=2)

# Intersection of red and blue surfaces (below)
ax.plot(x,np.power(x,2),np.power(x,2),'--',color='r',linewidth=2)
ax.plot(x,np.power(x,2),-np.ones_like(x),'--',color='r',linewidth=2)

# Plot Koopman Trajectories
ax.plot(yA[:,0],yA[:,1],-np.ones_like(yA[:,0]),'k-',linewidth=1)
ax.plot(yB[:,0],yB[:,1],-np.ones_like(yB[:,0]),'k-',linewidth=1)
ax.plot(yC[:,0],yC[:,1],-np.ones_like(yC[:,0]),'k-',linewidth=1)

ax.plot(yA[:,0],yA[:,1],yA[:,2],'k-',linewidth=1.5)
ax.plot(yB[:,0],yB[:,1],yB[:,2],'k-',linewidth=1.5)
ax.plot(yC[:,0],yC[:,1],yC[:,2],'k-',linewidth=1.5)

ax.plot(np.array([0,0]),np.array([0,0]),np.array([0,-1]),'ko')

ax.view_init(azim=-105,elev=8)

ax.set_xlim(-4,4)
ax.set_ylim(-1,4)
ax.set_zlim(-1,4)

ax.set_xlabel('y1')
ax.set_ylabel('y2')
ax.set_zlabel('y3')

plt.show()

</t>
<t tx="ekr.20241213022537.55"></t>
<t tx="ekr.20241213022537.56"></t>
<t tx="ekr.20241213022537.57">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.59">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D
from scipy import integrate


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022537.6">#create model
model = Sequential()

#add model layers
model.add(Conv2D(filters=16, kernel_size=5, activation='relu', input_shape=(28,28,1)))
model.add(MaxPool2D(pool_size=2, strides=2))
model.add(Flatten())
model.add(Dense(len(classes), activation='softmax'))

sgd_optimizer = optimizers.SGD(momentum=0.9)
model.compile(optimizer=sgd_optimizer, loss='categorical_crossentropy')
model.fit(XTrain, y_train, epochs=30)

</t>
<t tx="ekr.20241213022537.60">## Simulate the Lorenz System

dt = 0.01
T = 50
t = np.arange(0,T+dt,dt)
beta = 8/3
sigma = 10
rho = 28


def lorenz_deriv(x_y_z, t0, sigma=sigma, beta=beta, rho=rho):
    x, y, z = x_y_z
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]

np.random.seed(123)
x0 = (-8,8,27)

x = integrate.odeint(lorenz_deriv, x0, t,rtol=10**(-12),atol=10**(-12)*np.ones_like(x0))


</t>
<t tx="ekr.20241213022537.61">## Eigen-time delay coordinates
stackmax = 10 # Number of shift-stacked rows
r = 10        # rank of HAVOK model
H = np.zeros((stackmax,x.shape[0]-stackmax))

for k in range(stackmax):
    H[k,:] = x[k:-(stackmax-k),0]
    
U,S,VT = np.linalg.svd(H,full_matrices=0)
V = VT.T

</t>
<t tx="ekr.20241213022537.62">## Compute Derivatives (4th Order Central Difference)
# dV = np.zeros((V.shape[0]-5,r))
# for i in range(2,V.shape[0]-3):
#     for k in range(r):
#         dV[i-1,k] = (1/(12*dt))

dV = (1/(12*dt)) * (-V[4:,:] + 8*V[3:-1,:] - 8*V[1:-3,:] + V[:-4,:])

# trim first and last two that are lost in derivative
V = V[2:-2]

</t>
<t tx="ekr.20241213022537.63">## Build HAVOK Regression Model on Time Delay Coordinates
Xi = np.linalg.lstsq(V,dV,rcond=None)[0]
A = Xi[:(r-1),:(r-1)].T
B = Xi[-1,:(r-1)].T

</t>
<t tx="ekr.20241213022537.64">print(1/2/3)

</t>
<t tx="ekr.20241213022537.65"></t>
<t tx="ekr.20241213022537.66"></t>
<t tx="ekr.20241213022537.67">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.69">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241213022537.7">YPredict = np.argmax(model.predict(XTest),axis=1)
# argmax reverses the one-hot encoding scheme

accuracy = np.sum(YPredict == y_test_label)/len(y_test_label)
print('Accuracy = {}'.format(accuracy))

</t>
<t tx="ekr.20241213022537.70">t = np.arange(0,10,0.01)   # time

wr = 60 * np.ones_like(t)  # reference speed
d = 10*np.sin(np.pi*t)     # disturbance

aModel = 1                 # y = aModel*u
aTrue = 0.5                # y = aTrue*u

uOL = wr/aModel            # Open-loop u based on model
yOL = aTrue*uOL + d        # Open-loop response

K = 50                     # control gain, u=K(wr-y)
yCL = (aTrue*K/(1+aTrue*K))*wr + d/(1+aTrue*K)

</t>
<t tx="ekr.20241213022537.71">plt.plot(t,wr,'k',linewidth=2,label='Reference')
plt.plot(t,d,'k--',linewidth=1.5,label='Disturbance')
plt.plot(t,yOL,'r',linewidth=1.5,label='Open Loop')
plt.plot(t,yCL,'b',linewidth=1.5,label='Closed Loop')

plt.xlabel('Time')
plt.ylabel('Speed')

plt.legend(loc="upper left", bbox_to_anchor=(1,1))
plt.show()

</t>
<t tx="ekr.20241213022537.72"></t>
<t tx="ekr.20241213022537.73">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.75">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from matplotlib import animation, rc
from IPython.display import HTML
from control.matlab import *
from control import place
import slycot
from scipy import integrate
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})
plt.rcParams['animation.html'] = 'jshtml'

</t>
<t tx="ekr.20241213022537.76">m = 1
M = 5
L = 2
g = -10
d = 1

b = 1 # pendulum up (b=1)

A = np.array([[0,1,0,0],\
              [0,-d/M,b*m*g/M,0],\
              [0,0,0,1],\
              [0,-b*d/(M*L),-b*(m+M)*g/(M*L),0]])

B = np.array([0,1/M,0,b/(M*L)]).reshape((4,1))

print(np.linalg.eig(A)[0])       # Eigenvalues
print(np.linalg.det(ctrb(A,B)))  # Determinant of controllability matrix

</t>
<t tx="ekr.20241213022537.77">## Design LQR Controller
Q = np.eye(4)
R = 0.0001

K = lqr(A,B,Q,R)[0]


</t>
<t tx="ekr.20241213022537.78">## ODE RHS Function Definition
def pendcart(x,t,m,M,L,g,d,uf):
    u = uf(x) # evaluate anonymous function at x
    Sx = np.sin(x[2])
    Cx = np.cos(x[2])
    D = m*L*L*(M+m*(1-Cx**2))
    
    dx = np.zeros(4)
    dx[0] = x[1]
    dx[1] = (1/D)*(-(m**2)*(L**2)*g*Cx*Sx + m*(L**2)*(m*L*(x[3]**2)*Sx - d*x[1])) + m*L*L*(1/D)*u
    dx[2] = x[3]
    dx[3] = (1/D)*((m+M)*m*g*L*Sx - m*L*Cx*(m*L*(x[3]**2)*Sx - d*x[1])) - m*L*Cx*(1/D)*u;
    
    return dx


</t>
<t tx="ekr.20241213022537.79">## Simulate closed-loop system
tspan = np.arange(0,10,0.001)
x0 = np.array([-1,0,np.pi+0.1,0]) # Initial condition
wr = np.array([1,0,np.pi,0])      # Reference position
u = lambda x: -K@(x-wr)           # Control law

x = integrate.odeint(pendcart,x0,tspan,args=(m,M,L,g,d,u))

</t>
<t tx="ekr.20241213022537.8"></t>
<t tx="ekr.20241213022537.80">for k in range(np.floor(len(t)/100)):
    plt.plot

</t>
<t tx="ekr.20241213022537.81">fig,ax = plt.subplots()
H = 0.5*np.sqrt(M/5)
p_pend, = plt.plot([],[],'o-',linewidth=2,ms=40,markerfacecolor='r')
p_cart, = plt.plot([],[],'ks',ms=100)

x_plot = x[::100,:]
t_plot = tspan[::100]

def init():
    ax.set_xlim(-5,5)
    ax.set_ylim(-0.5, 2.7)
    return x

def animate(iter):
    x_iter = x_plot[iter,0]
    th_iter = x_plot[iter,2]
    
    p_cart.set_data(x_iter,0.1+H/2)
    p_pend.set_data(x_iter+np.array([0,L*np.sin(th_iter)]),\
                    0.1+H/2+np.array([0,-L*np.cos(th_iter)]))
    return p_pend

anim = animation.FuncAnimation(fig,animate,init_func=init,frames=len(t_plot),interval=50,blit=False,repeat=False)
HTML(anim.to_jshtml())

</t>
<t tx="ekr.20241213022537.82">plot_labels = ('x','v','theta','omega')
[plt.plot(tspan,x[:,j],linewidth=2,label=plot_labels[j]) for j in range(4)]
plt.xlabel('Time')
plt.ylabel('State')

plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022537.83">## Compare with many examples of Pole Placement
JLQR = np.zeros(len(tspan))
for k in range(len(tspan)):
    JLQR[k] = (x[k,:]-wr) @ Q @ (x[k,:]-wr) + (u(x[k,:])**2)*R
    
t_plot = tspan[::50]
all_x_plot = np.zeros((len(t_plot),4,100))
all_J = np.zeros((len(tspan),100))
all_Jz = np.zeros((len(tspan)-1,100))

for count in range(100):
    p = -0.5 - 3*np.random.rand(4)
    K = place(A,B,p)
    u = lambda x: -K@(x-wr)
    
    x = integrate.odeint(pendcart,x0,tspan,args=(m,M,L,g,d,u))
    all_x_plot[:,:,count] = x[::50,:]
    for k in range(len(tspan)):
        all_J[k,count] = (x[k,:]-wr)@Q@(x[k,:]-wr) + (u(x[k,:])**2)*R
    
    all_Jz[:,count] = integrate.cumtrapz(all_J[:,count])


</t>
<t tx="ekr.20241213022537.84">## Plots
for count in range(100):
    plt.plot(t_plot,all_x_plot[:,:,count],linewidth=0.5)
    plt.gca().set_prop_cycle(None) # reset color cycle
    
plt.xlabel('Time')
plt.ylabel('State')
plt.show()

</t>
<t tx="ekr.20241213022537.85">for count in range(100):
    plt.plot(t_plot,all_Jz[::50,count],color=(0.5,0.5,0.5))
    
plt.xlabel('Time')
plt.ylabel('Cost')
plt.show()
</t>
<t tx="ekr.20241213022537.86">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.88">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import integrate
from scipy.linalg import schur
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022537.89">m = 1
M = 5
L = 2
g = -10
d = 1

b = -1 # pendulum down (b = -1)

A = np.array([[0,1,0,0],\
              [0,-d/M,b*m*g/M,0],\
              [0,0,0,1],\
              [0,-b*d/(M*L),-b*(m+M)*g/(M*L),0]])

B = np.array([0,1/M,0,b/(M*L)]).reshape((4,1))

C = np.array([0,0,1,0]) # only observable if x measured... because x can't be

print('Observability matrix:\n{}'.format(obsv(A,C)))
print('Observability matrix determinant: {}'.format(np.linalg.det(obsv(A,C))))


</t>
<t tx="ekr.20241213022537.9"></t>
<t tx="ekr.20241213022537.90">## Which measurements are best if we omit "x"
Ah = A[1:,1:]
Bh = B[1:]
# Ch = np.array([1,0,0])
Ch = np.array([0,1,0])
# Ch = np.array([0,0,1])

print('Observability matrix:\n{}'.format(obsv(Ah,Ch)))

Ch = Ch.reshape((1,len(Ch)))
Dh = np.zeros((Ch.shape[0],Bh.shape[1]))
sys = ss(Ah,Bh,Ch,Dh)
print('Gramian determinant: {}'.format(np.linalg.det(gram(sys,'o'))))


</t>
<t tx="ekr.20241213022537.91"></t>
<t tx="ekr.20241213022537.92">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022537.94">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import integrate
from scipy.linalg import schur
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022537.95">m = 1
M = 5
L = 2
g = -10
d = 1

b = -1 # pendulum down (b = -1)

A = np.array([[0,1,0,0],\
              [0,-d/M,b*m*g/M,0],\
              [0,0,0,1],\
              [0,-b*d/(M*L),-b*(m+M)*g/(M*L),0]])

B = np.array([0,1/M,0,b/(M*L)]).reshape((4,1))

C = np.array([1,0,0,0]) # measure cart position, x

print('Observability matrix rank: {}'.format(np.linalg.matrix_rank(obsv(A,C))))

D = np.zeros((C.shape[0],B.shape[1]))


</t>
<t tx="ekr.20241213022537.96"># Kalman estimator design

def lqe(a,g,c,q,r):
    r = np.atleast_2d(r)
    nn = np.zeros((q.shape[0],len(r)))
    qg = g @ q @ g.T
    ng = g @ nn
    
    qg = (qg + qg.T)/2
    r = (r + r.T)/2
    u,t = schur(r)
    
    t = np.real(np.diag(t))
    
    if np.min(t) &lt;= 0:
        print('Error: covariance matrix must be positive definite')
    else:
        Nr = (ng@u)*np.diag(np.power(np.sqrt(t),-1))
        Qr = qg - Nr @ Nr.T
        if np.min(np.real(np.linalg.eig(Qr)[0])) &lt; -(10**3)*np.finfo(float).eps:
            print('Warning: The matrix [G*Q*G'' G*N;N''*G'' R] should be nonnegative definite')
    c = np.diag(c)
    r = np.squeeze(r)
    (p,e,k) = care(a.T,c.T,qg)#,R=r,S=ng)
    l = k[0,:]
    
    return (l,p,e)


</t>
<t tx="ekr.20241213022537.97">## Specify disturbance and noise magnitude
Vd = np.eye(4)  # distrubance covariance
Vn = 1          # noise covariance

# Build Kalman filter
Kf, P, E = lqe(A,np.eye(4),C,Vd,Vn)


</t>
<t tx="ekr.20241213022537.98">## Augment system with additional inputs
Baug = np.concatenate((B, np.eye(4),np.zeros_like(B)),axis=1) # [u I*wd 0*wn]
Daug = np.array([0,0,0,0,0,1]) # D matrix passes noise through

sysC = ss(A,Baug,C,Daug) # Single-measurement system

# "True" system w/ full-state output, disturbance, no noise
sysTruth = ss(A,Baug,np.eye(4),np.zeros((4,Baug.shape[1])))

BKf = np.concatenate((B,np.atleast_2d(Kf).T),axis=1)
sysKF = ss(A-np.outer(Kf,C),BKf,np.eye(4),np.zeros_like(BKf))

</t>
<t tx="ekr.20241213022537.99">## Estimate linearized system in "down" position (Gantry crane)
dt = 0.01
t = np.arange(0,50,dt)

uDIST = np.sqrt(Vd) @ np.random.randn(4,len(t)) # random disturbance
uNOISE = np.sqrt(Vn) * np.random.randn(len(t))    # random noise
u = np.zeros_like(t)
u[100] = 20/dt   # positive impulse
u[1500] = -20/dt # negative impulse

# input w/ disturbance and noise:
uAUG = np.concatenate((u.reshape((1,len(u))),uDIST,uNOISE.reshape((1,len(uNOISE))))).T

y,t,_ = lsim(sysC,uAUG,t)                      # noisy measurement
xtrue,t,_ = lsim(sysTruth,uAUG,t)              # true state
xhat,t,_ = lsim(sysKF,np.row_stack((u,y)).T,t) # state estimate

</t>
<t tx="ekr.20241213022538.1"></t>
<t tx="ekr.20241213022538.10">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.100"># spatial discretization
L = 40 
n = 256
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n]

# wavenumbers for FFT
k = n*(2*np.pi/L)*np.fft.fftfreq(n) # k-vector

# time domain collection points
t = np.linspace(0,2*np.pi,61)


</t>
<t tx="ekr.20241213022538.101">def ch_pod_sol_rhs(ut_split,t,k=k):
    ut = ut_split[:n] + (1j)*ut_split[n:]
    u = np.fft.ifft(ut)
    rhs = -0.5*(1j)*np.power(k,2)*ut + (1j)*np.fft.fft(np.power(np.abs(u),2)*u)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241213022538.102">N = 2
u0 = N/np.cosh(x)
ut = np.fft.fft(u0)

ut_split = np.concatenate((np.real(ut),np.imag(ut))) # Separate real/complex pieces

utsol_split = integrate.odeint(ch_pod_sol_rhs,ut_split,t,mxstep=10**6)
utsol = utsol_split[:,:n] + (1j)*utsol_split[:,n:]

usol = np.zeros_like(utsol)
for jj in range(len(t)):
    usol[jj,:] = np.fft.ifft(utsol[jj,:]) # transforming back


</t>
<t tx="ekr.20241213022538.103">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
ax.view_init(elev=25, azim=110)

for tt in range(len(t)):
    ax.plot(x,t[tt]*np.ones_like(x),np.abs(usol[tt,:]),color='k',linewidth=0.75)

ax.set_ylim(0,2*np.pi)
plt.show()

</t>
<t tx="ekr.20241213022538.104">X = usol.T # data matrix X
U,S,WT = np.linalg.svd(X,full_matrices=0) # SVD reduction

r = 3 # select rank truncation
Psi = U[:,:r] # select POD modes
a0 = Psi.T @ u0 # project initial conditions

</t>
<t tx="ekr.20241213022538.105">NL = (1j)*np.power(np.abs(X),2)*X
XI,S_NL,WT = np.linalg.svd(NL,full_matrices=0)

# First DEIM point
nmax = np.argmax(np.abs(XI[:,0]))
XI_m = XI[:,0].reshape(n,1)
z = np.zeros((n,1))
P = np.copy(z)
P[nmax] = 1

# DEIM points 2 to r
for jj in range(1,r):
    c = np.linalg.solve(P.T @ XI_m, P.T @ XI[:,jj].reshape(n,1))
    res = XI[:,jj].reshape(n,1) - XI_m @ c
    nmax = np.argmax(np.abs(res))
    XI_m = np.concatenate((XI_m,XI[:,jj].reshape(n,1)),axis=1)
    P = np.concatenate((P,z),axis=1)
    P[nmax,jj] = 1

</t>
<t tx="ekr.20241213022538.106">P_NL = Psi.T @ (XI_m @ np.linalg.inv(P.T @ XI_m)) # nonlinear projection
P_Psi = P.T @ Psi # interpolation of Psi

Lxx = np.zeros((n,r),dtype='complex_')
for jj in range(r):
    Lxx[:,jj] = np.fft.ifft(-np.power(k,2)*np.fft.fft(Psi[:,jj]))

L = 0.5 * (1j) * Psi.T @ Lxx # projected linear term


</t>
<t tx="ekr.20241213022538.107">def rom_deim_rhs(a_split,tspan,P_NL=P_NL,P_Psi=P_Psi,L=L):
    a = a_split[:r] + (1j)*a_split[r:]
    N = P_Psi @ a
    rhs = L @ a + (1j) * P_NL @ (np.power(np.abs(N),2)*N)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241213022538.108">a0_split = np.concatenate((np.real(a0),np.imag(a0))) # Separate real/complex pieces

a_split = integrate.odeint(rom_deim_rhs,a0_split,t,mxstep=10**6)
a = a_split[:,:r] + (1j)*a_split[:,r:]

Xtilde = Psi @ a.T # DEIM approximation

</t>
<t tx="ekr.20241213022538.109">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
ax.view_init(elev=25, azim=110)

for tt in range(len(t)):
    ax.plot(x,t[tt]*np.ones_like(x),np.abs(Xtilde[:,tt]),color='k',linewidth=0.75)

ax.set_ylim(0,2*np.pi)
plt.show()

</t>
<t tx="ekr.20241213022538.110">## QR DEIM
Q,R,pivot = qr(NL.T,pivoting=True)
P_qr = np.zeros_like(x)
P_qr[pivot[:3]] = 1

plt.rcParams['figure.figsize'] = [10,2]
plt.bar(x,P_qr,width=0.05)
plt.show()

</t>
<t tx="ekr.20241213022538.111"></t>
<t tx="ekr.20241213022538.112"></t>
<t tx="ekr.20241213022538.113">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.115">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import integrate
from scipy.linalg import qr
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.116"># spatial discretization
L = 40 
n = 256
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n]

# wavenumbers for FFT
k = n*(2*np.pi/L)*np.fft.fftfreq(n) # k-vector

# time domain collection points
t = np.linspace(0,2*np.pi,61)


</t>
<t tx="ekr.20241213022538.117">def ch_pod_sol_rhs(ut_split,t,k=k):
    ut = ut_split[:n] + (1j)*ut_split[n:]
    u = np.fft.ifft(ut)
    rhs = -0.5*(1j)*np.power(k,2)*ut + (1j)*np.fft.fft(np.power(np.abs(u),2)*u)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241213022538.118">N = 2
u0 = N/np.cosh(x)
ut = np.fft.fft(u0)

ut_split = np.concatenate((np.real(ut),np.imag(ut))) # Separate real/complex pieces

utsol_split = integrate.odeint(ch_pod_sol_rhs,ut_split,t,mxstep=10**6)
utsol = utsol_split[:,:n] + (1j)*utsol_split[:,n:]

usol = np.zeros_like(utsol)
for jj in range(len(t)):
    usol[jj,:] = np.fft.ifft(utsol[jj,:]) # transforming back


</t>
<t tx="ekr.20241213022538.119">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
ax.view_init(elev=25, azim=110)

for tt in range(len(t)):
    ax.plot(x,t[tt]*np.ones_like(x),np.abs(usol[tt,:]),color='k',linewidth=0.75)

ax.set_ylim(0,2*np.pi)
plt.show()

</t>
<t tx="ekr.20241213022538.12">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LightSource, Normalize
from matplotlib import rcParams, cm
from scipy import integrate
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [12, 6]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.120">X = usol.T # data matrix X
U,S,WT = np.linalg.svd(X,full_matrices=0) # SVD reduction

r = 3 # select rank truncation
Psi = U[:,:r] # select POD modes
a0 = Psi.T @ u0 # project initial conditions

</t>
<t tx="ekr.20241213022538.121">NL = (1j)*np.power(np.abs(X),2)*X
XI,S_NL,WT = np.linalg.svd(NL,full_matrices=0)

# First DEIM point
nmax = np.argmax(np.abs(XI[:,0]))
XI_m = XI[:,0].reshape(n,1)
z = np.zeros((n,1))
P = np.copy(z)
P[nmax] = 1

# DEIM points 2 to r
for jj in range(1,r):
    c = np.linalg.solve(P.T @ XI_m, P.T @ XI[:,jj].reshape(n,1))
    res = XI[:,jj].reshape(n,1) - XI_m @ c
    nmax = np.argmax(np.abs(res))
    XI_m = np.concatenate((XI_m,XI[:,jj].reshape(n,1)),axis=1)
    P = np.concatenate((P,z),axis=1)
    P[nmax,jj] = 1

</t>
<t tx="ekr.20241213022538.122">P_NL = Psi.T @ (XI_m @ np.linalg.inv(P.T @ XI_m)) # nonlinear projection
P_Psi = P.T @ Psi # interpolation of Psi

Lxx = np.zeros((n,r),dtype='complex_')
for jj in range(r):
    Lxx[:,jj] = np.fft.ifft(-np.power(k,2)*np.fft.fft(Psi[:,jj]))

L = 0.5 * (1j) * Psi.T @ Lxx # projected linear term


</t>
<t tx="ekr.20241213022538.123">def rom_deim_rhs(a_split,tspan,P_NL=P_NL,P_Psi=P_Psi,L=L):
    a = a_split[:r] + (1j)*a_split[r:]
    N = P_Psi @ a
    rhs = L @ a + (1j) * P_NL @ (np.power(np.abs(N),2)*N)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241213022538.124">a0_split = np.concatenate((np.real(a0),np.imag(a0))) # Separate real/complex pieces

a_split = integrate.odeint(rom_deim_rhs,a0_split,t,mxstep=10**6)
a = a_split[:,:r] + (1j)*a_split[:,r:]

Xtilde = Psi @ a.T # DEIM approximation

</t>
<t tx="ekr.20241213022538.125">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
ax.view_init(elev=25, azim=110)

for tt in range(len(t)):
    ax.plot(x,t[tt]*np.ones_like(x),np.abs(Xtilde[:,tt]),color='k',linewidth=0.75)

ax.set_ylim(0,2*np.pi)
plt.show()

</t>
<t tx="ekr.20241213022538.126">plt.plot(x,-np.real(Psi[:,:3]))
plt.xlim(-4,4)
plt.ylim(-1,1)
[plt.bar(x, P[:,jj],width=0.025,color='k') for jj in range(3)]
[plt.bar(x,-P[:,jj],width=0.025,color='k') for jj in range(3)]
plt.show()

</t>
<t tx="ekr.20241213022538.127">## QR compare
plt.rcParams['figure.figsize'] = [8,8]
fig,axs = plt.subplots(2,1)
axs[0].plot(x,-np.real(Psi[:,:3]))
[axs[0].bar(x, P[:,jj],width=0.025,color='k') for jj in range(3)]
[axs[0].bar(x,-P[:,jj],width=0.025,color='k') for jj in range(3)]

Q,R,pivot = qr(NL.T,pivoting=True)
P_qr = np.zeros_like(x)
P_qr[pivot[:3]] = 1

axs[1].plot(x,-np.real(Psi[:,:3]))
axs[1].bar(x, P_qr,width=0.025,color='k')
axs[1].bar(x,-P_qr,width=0.025,color='k')

for ax in axs:
    ax.set_xlim(-4,4)
    ax.set_ylim(-1,1)

plt.show()

</t>
<t tx="ekr.20241213022538.128"></t>
<t tx="ekr.20241213022538.13">L = 30
n = 512
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n] # Spatial discretization

k = n*(2*np.pi/L)*np.fft.fftfreq(n)
V = np.power(x,2) # potential
t = np.arange(0,20,.2) # time domain collection points


</t>
<t tx="ekr.20241213022538.14">def harm_rhs(ut_split,t,k=k,V=V,n=n):
    ut = ut_split[:n] + (1j)*ut_split[n:]
    u = np.fft.ifft(ut)
    rhs = -0.5*(1j)*np.power(k,2)*ut - 0.5*(1j)*np.fft.fft(V*u)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241213022538.15">u = np.exp(-0.2*np.power(x-1,2)) # initial conditions
ut = np.fft.fft(u) # FFT initial data
ut_split = np.concatenate((np.real(ut),np.imag(ut)))

utsol_split = integrate.odeint(harm_rhs,ut_split,t,mxstep=10**6)
utsol = utsol_split[:,:n] + (1j)*utsol_split[:,n:]

usol = np.zeros_like(utsol)
for jj in range(len(t)):
    usol[jj,:] = np.fft.ifft(utsol[jj,:])

</t>
<t tx="ekr.20241213022538.16">u2 = np.exp(-0.2*np.power(x-0,2)) # initial conditions
ut2 = np.fft.fft(u2) # FFT initial data
ut2_split = np.concatenate((np.real(ut2),np.imag(ut2)))

ut2sol_split = integrate.odeint(harm_rhs,ut2_split,t,mxstep=10**6)
ut2sol = ut2sol_split[:,:n] + (1j)*ut2sol_split[:,n:]

u2sol = np.zeros_like(ut2sol)
for jj in range(len(t)):
    u2sol[jj,:] = np.fft.ifft(ut2sol[jj,:])

</t>
<t tx="ekr.20241213022538.17">ax = Axes3D(plt.figure())
T,X = np.meshgrid(t,x)
light = LightSource(90, 45)
illuminated_surface = light.shade(np.abs(usol.T)+2, cmap=cm.Greys_r)
ax.plot_surface(X, T, np.abs(usol.T)+2, rstride=1, cstride=1,linewidth=0, antialiased=True, \
                facecolors=illuminated_surface,vmin=0)

cmap = plt.cm.Greys_r
norm = Normalize(vmin=np.abs(usol).min(), vmax=np.abs(usol).max())
colors = cmap(norm(np.abs(usol.T)))
ax.plot_surface(X, T, np.zeros_like(X), rstride=1, cstride=1,linewidth=0, antialiased=False, \
                facecolors=colors)

tv = np.zeros_like(x)+20
Vx = np.power(x,2)
ax.plot(x[11:-12],tv[11:-12],Vx[11:-12]/100+2,'k',linewidth=2)
ax.set_title('u (1-centered)')
plt.show()

</t>
<t tx="ekr.20241213022538.18">ax = Axes3D(plt.figure())
T,X = np.meshgrid(t,x)
light = LightSource(90, 45)
illuminated_surface = light.shade(np.abs(u2sol.T)+2, cmap=cm.Greys_r)
ax.plot_surface(X, T, np.abs(u2sol.T)+2, rstride=1, cstride=1,linewidth=0, antialiased=True, \
                facecolors=illuminated_surface,vmin=0)

cmap = plt.cm.Greys_r
norm = Normalize(vmin=np.abs(u2sol).min(), vmax=np.abs(u2sol).max())
colors = cmap(norm(np.abs(u2sol.T)))
ax.plot_surface(X, T, np.zeros_like(X), rstride=1, cstride=1,linewidth=0, antialiased=False, \
                facecolors=colors)

tv = np.zeros_like(x)+20
Vx = np.power(x,2)
ax.plot(x[11:-12],tv[11:-12],Vx[11:-12]/100+2,'k',linewidth=2)
ax.set_title('u2 (0-centered)')
plt.show()

</t>
<t tx="ekr.20241213022538.19">usol3 = np.zeros_like(usol)
for jj in range(len(t)):
    usol3[jj,:] = usol[jj,np.flip(np.arange(n))]
    
usym = np.concatenate((usol,usol3))

U,S,VT = np.linalg.svd(usol.T)
U2,S2,VT2 = np.linalg.svd(u2sol.T)
U3,S3,VT3 = np.linalg.svd(usym.T)

</t>
<t tx="ekr.20241213022538.2">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.20">plt.plot(100*S/np.sum(S),'ko',linewidth=2)
plt.title('Singular values: u (1-centered)')
plt.show()

</t>
<t tx="ekr.20241213022538.21">plt.plot(100*S2/np.sum(S2),'ko',linewidth=2)
plt.title('Singular values: u2 (0-centered)')
plt.show()

</t>
<t tx="ekr.20241213022538.22">fig,axs = plt.subplots(3,1)
Up = np.zeros((n,5))
for jj in range(5):
    Up[:,jj] = np.real(U[:,jj]/np.linalg.norm(U[:,jj]))
    
[axs[2].plot(x,np.real(Up[:,k]),linewidth=2,label='mode {}'.format(k+1)) for k in range(5)]

Up2 = np.zeros((n,5))
for jj in range(5):
    Up2[:,jj] = np.real(U2[:,jj]/np.linalg.norm(U2[:,jj]))
    
[axs[1].plot(x,np.real(Up2[:,k]),linewidth=2) for k in range(5)]


h = np.array([np.ones_like(x),2*x,4*np.power(x,2),8*np.power(x,3)-12*x,\
             16*np.power(x,4)-48*np.power(x,2)+12])

phi = np.zeros((n,5))
phi2 = np.zeros((n,5))


for jj in range(5):
    phi[:,jj] = (1/(np.sqrt(np.math.factorial(jj)*(2**jj)*np.sqrt(np.pi))) * \
                np.exp(-np.power(x,2)/2)*h[jj,:])
    phi2[:,jj] = phi[:,jj]/np.linalg.norm(phi[:,jj])
    
[axs[0].plot(x,np.real(phi2[:,k]),linewidth=2) for k in range(5)]

for ax in axs:
    ax.set_xlim(-5,5)
    
axs[1].set_ylabel('u2')
axs[2].set_ylabel('u')
axs[2].legend(bbox_to_anchor=(1.03,1.55), loc="upper left")
plt.show()

</t>
<t tx="ekr.20241213022538.23"></t>
<t tx="ekr.20241213022538.24">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.26">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams, cm
from scipy import integrate
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.27">L = 40
n = 512
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n] # Spatial discretization

k = n*(2*np.pi/L)*np.fft.fftfreq(n)
t = np.linspace(0,2*np.pi,21) 


</t>
<t tx="ekr.20241213022538.28">def nls_rhs(ut_split,t,k=k):
    ut = ut_split[:n] + (1j)*ut_split[n:]
    u = np.fft.ifft(ut)
    rhs = -0.5*(1j)*np.power(k,2)*ut + (1j)*np.fft.fft(np.power(np.abs(u),2)*u)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241213022538.29">N = 1
u = N/np.cosh(x)   # initial conditions
ut = np.fft.fft(u) # FFT initial data
ut_split = np.concatenate((np.real(ut),np.imag(ut))) # Separate real/complex pieces

utsol_split = integrate.odeint(nls_rhs,ut_split,t,mxstep=10**6)
utsol = utsol_split[:,:n] + (1j)*utsol_split[:,n:]

usol = np.zeros_like(utsol)
for jj in range(len(t)):
    usol[jj,:] = np.fft.ifft(utsol[jj,:]) # transforming back


</t>
<t tx="ekr.20241213022538.30">N = 2
u2 = N/np.cosh(x)   # initial conditions
ut2 = np.fft.fft(u2) # FFT initial data
ut2_split = np.concatenate((np.real(ut2),np.imag(ut2))) # Separate real/complex pieces

ut2sol_split = integrate.odeint(nls_rhs,ut2_split,t,mxstep=10**6)
ut2sol = ut2sol_split[:,:n] + (1j)*ut2sol_split[:,n:]

u2sol = np.zeros_like(ut2sol)
for jj in range(len(t)):
    u2sol[jj,:] = np.fft.ifft(ut2sol[jj,:]) # transforming back


</t>
<t tx="ekr.20241213022538.31">fig = plt.figure()
axs = [fig.add_subplot(2, 2, k, projection='3d') for k in range(1,5)]

for ax in axs:
    ax.view_init(elev=25, azim=110)


for tt in range(len(t)):
    axs[0].plot(x,t[tt]*np.ones_like(x),np.abs(usol[tt,:]),color='k',linewidth=0.75)
    axs[2].plot(np.fft.fftshift(k),t[tt]*np.ones_like(x), \
                np.abs(np.fft.fftshift(utsol[tt,:])),color='k',linewidth=0.75)
    
    axs[1].plot(x,t[tt]*np.ones_like(x),np.abs(u2sol[tt,:]),color='k',linewidth=0.75)
    axs[3].plot(np.fft.fftshift(k),t[tt]*np.ones_like(x), \
                np.abs(np.fft.fftshift(ut2sol[tt,:])),color='k',linewidth=0.75)

plt.show()

</t>
<t tx="ekr.20241213022538.32">U,S,VT = np.linalg.svd(usol.T)
U2,S2,VT2 = np.linalg.svd(u2sol.T)

</t>
<t tx="ekr.20241213022538.33">plt.rcParams['figure.figsize'] = [12, 6]

fig,axs = plt.subplots(1,2)
axs[0].semilogy(100*S/np.sum(S),'ko',ms=10)
axs[0].semilogy(0,100*S[0]/np.sum(S),'bo',ms=10)
axs[0].semilogy(1,100*S[1]/np.sum(S),'go',ms=10)
axs[0].semilogy(2,100*S[2]/np.sum(S),'ro',ms=10)
axs[0].set_xlim(-1,21)

axs[1].semilogy(100*S2/np.sum(S2),'ko',ms=10)
axs[1].semilogy(0,100*S2[0]/np.sum(S2),'bo',ms=10)
axs[1].semilogy(1,100*S2[1]/np.sum(S2),'go',ms=10)
axs[1].semilogy(2,100*S2[2]/np.sum(S2),'ro',ms=10)
axs[1].set_xlim(-1,21)

plt.show()

</t>
<t tx="ekr.20241213022538.34">color_list = ['b','g','r']
for jj in range(3):
    plt.plot(x,np.real(U[:,jj]),color=color_list[jj],linewidth=2, \
             label='mode {}'.format(jj+1))
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022538.35">for jj in range(3):
    plt.plot(x,np.real(U2[:,jj]),color=color_list[jj],linewidth=2, \
        label='mode {}'.format(jj+1))
plt.legend()
plt.show()

</t>
<t tx="ekr.20241213022538.36"></t>
<t tx="ekr.20241213022538.37">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.39">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams, cm
from scipy import integrate
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.4">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
import os

plt.rcParams['figure.figsize'] = [12, 6]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.40">L = 20
n = 100
x = np.linspace(-L,L,n)
y = np.copy(x)

X,Y = np.meshgrid(x,y)

Xd = np.zeros((n**2,n))
for jj in range(n):
    u = np.tanh(np.sqrt(np.power(X,2)+np.power(Y,2))) * \
            np.cos(np.angle(X+(1j)*Y)- \
            np.sqrt(np.power(X,2)+np.power(Y,2)) + \
           (jj+1)/10)
    f = np.exp(-0.01*(np.power(X,2) + np.power(Y,2)))
    uf = u * f
    Xd[:,jj] = uf.reshape(-1)

plt.pcolor(x,y,uf,cmap='hot')
plt.show()

</t>
<t tx="ekr.20241213022538.41">U,S,VT = np.linalg.svd(Xd,full_matrices=0)
V = VT.T

plt.rcParams['figure.figsize'] = [12, 6]

[plt.plot(V[:,k],linewidth=2,label='mode {}'.format(k+1)) for k in range(4)]

plt.legend(loc='lower right')
plt.show()

</t>
<t tx="ekr.20241213022538.42">fig, axs = plt.subplots(2,1)
axs[0].plot(100*S/np.sum(S),'ko',ms=10)
axs[0].set_ylabel('Singular Values')
axs[1].semilogy(100*S/np.sum(S),'ko',ms=10)
axs[1].set_ylabel('Singular Values (log)')

for ax in axs:
    ax.set_xlim(-1,40)

plt.show()

</t>
<t tx="ekr.20241213022538.43">plt.rcParams['figure.figsize'] = [12, 12]
fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

for jj in range(4):
    mode = np.reshape(U[:,jj],(n,n))
    axs[jj].pcolor(X,Y,mode,cmap='gray')
    axs[jj].axis(False)


</t>
<t tx="ekr.20241213022538.44">u = np.tanh(np.sqrt(np.power(X,2)+np.power(Y,2))) * \
            np.cos(np.angle(X+(1j)*Y)- \
            np.sqrt(np.power(X,2)+np.power(Y,2)))
f = np.exp(-0.01*(np.power(X,2)+np.power(Y,2)))
uf = u*f

plt.rcParams['figure.figsize'] = [12,4]
fig,axs = plt.subplots(1,3)
axs[0].pcolor(x,y,uf,cmap='gray')
axs[1].pcolor(x,y,np.abs(uf),cmap='gray')
axs[2].pcolor(x,y,np.power(uf,5),cmap='gray')

for ax in axs:
    ax.axis(False)

</t>
<t tx="ekr.20241213022538.45">## Translation
n = 200
L = 20
x = np.linspace(-L,L,n) # space
y = np.copy(x)
m = 41
T = 10
t = np.linspace(0,T,m) # time
c = 3 # wave speed

X = np.zeros((n,m))
for jj in range(m):
    X[:,jj] = np.exp(-np.power(x+15-c*t[jj],2))
    
U,S,VT = np.linalg.svd(X)
V = VT.T

</t>
<t tx="ekr.20241213022538.46">plt.rcParams['figure.figsize'] = [12,12]
fig = plt.figure()
ax = fig.add_subplot(1,1,1,projection='3d')
ax.view_init(elev=70, azim=-70)

for jj in range(m):
    ax.plot(x,t[jj]*np.ones_like(x),X[:,jj],'k',linewidth=0.75)

</t>
<t tx="ekr.20241213022538.47">U2,S2,V2T = np.linalg.svd(X)
V2 = V2T.T

fig, axs = plt.subplots(2,1)
axs[0].plot(100*S2/np.sum(S2),'ko',ms=10)
axs[0].set_ylabel('Singular Values')
axs[1].semilogy(100*S2/np.sum(S2),'ko',ms=10)
axs[1].set_ylabel('Singular Values (log)')

for ax in axs:
    ax.set_xlim(-1,40)

plt.show()

</t>
<t tx="ekr.20241213022538.48"></t>
<t tx="ekr.20241213022538.49"></t>
<t tx="ekr.20241213022538.5">L = 20
n = 80
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n]
u = np.exp(-np.power(x,2))
u1 = np.exp(-0.1*np.power(x,2))
u2 = np.exp(-10*np.power(x,2))

ut = np.fft.fft(u)
ut1 = np.fft.fft(u1)
ut2 = np.fft.fft(u2)

uts = np.fft.fftshift(ut)
uts1 = np.fft.fftshift(ut1)
uts2 = np.fft.fftshift(ut2)

k = n*(2*np.pi/L)*np.fft.fftfreq(n)
km = n*np.fft.fftfreq(n)

</t>
<t tx="ekr.20241213022538.50">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.52">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams


plt.rcParams['figure.figsize'] = [12,6]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.53">L = 10 # define domain
x2 = np.arange(-L,L,0.1) 
n = len(x2)
k = n*(2*np.pi/(2*L))*np.fft.fftfreq(n) # k-vector
ye = np.exp(-np.power(x2,2))
ye2 = np.exp(np.power(x2,2)/2) # define Gaussians

y = np.zeros((n,10))

for jj in range(10): # loop through 10 modes
    # 2nd derivative
    yd = np.real(np.fft.ifft((np.power((1j)*k,jj))*np.fft.fft(ye)))
    
    mode = np.power(-1,jj) * \
        np.power((np.power(2,jj)*np.math.factorial(jj)*np.sqrt(np.pi)),-0.5) * \
        ye2 * yd
            
    y[:,jj] = mode # store modes as columns
            
x = x2[int(n/2)-40 : int(n/2)+41] # keep only -4&lt;x&lt;4
yharm = y[int(n/2)-40 : int(n/2)+41,:]

plt.pcolor(np.flipud(np.rot90(yharm)),cmap='hot')
plt.axis(False)
plt.show()

</t>
<t tx="ekr.20241213022538.54">plt.rcParams['figure.figsize'] = [12,12]
fig, axs = plt.subplots(3,1)

n = len(x)
f = np.exp(-np.power(x-0.5,2)) + 3*np.exp(-2*np.power(x+1.5,2))
axs[0].plot(x,f,'k')
Err = np.zeros(4)

a = np.zeros(10)

for jj in range(10):
    a[jj] = np.trapz(f*yharm[:,jj],x)

f2 = yharm @ a
axs[0].plot(x,f2,'r')
Err[0] = np.linalg.norm(f2-f) # recontruction error
    
M = np.zeros((10,10))

for jj in range(10): # matrix M reconstruction
    for kk in range(jj+1):
        Area = np.trapz(yharm[:,jj]*yharm[:,kk],x)
        M[jj,kk] = Area
        M[kk,jj] = Area
        
print('Conditioning number of M: {}'.format(np.linalg.cond(M)))

color_list = ['g','m','b']
MJ = np.zeros((10,10,3))
condJ = np.zeros(3)
sJ = np.zeros((3,n))
for jloop in range(3):
    s = (np.random.rand(n) &gt; 0.8) # grab 20% random measurements
    sJ[jloop,:] = s
    # construct M_j
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(s*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
    MJ[:,:,jloop] = M2
    condJ[jloop] = np.linalg.cond(M2)
    print('Conditioning number of M{}: {}'.format((jloop+1),np.linalg.cond(M2)))

    
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(s*f*yharm[:,jj],x)
    
    atild = np.linalg.solve(M2,ftild) # compute error
    f2 = yharm @ atild
    axs[0].plot(x,f2,color=color_list[jloop])
    Err[jloop+1] = np.linalg.norm(f2-f)
    
con2 = np.concatenate(([1],condJ))
axs[1].bar(range(len(con2)),np.log(con2)+1)
axs[2].bar(range(len(Err)),Err)

for ax in axs:
    ax.set_xticklabels([''])
    ax.set_yticklabels([''])

plt.show()

</t>
<t tx="ekr.20241213022538.55">plt.rcParams['figure.figsize'] = [12,12]
fig,axs = plt.subplots(4,1)
axs[0].pcolor(x,range(10),np.flipud(np.rot90(yharm)),cmap='hot')
for jloop in range(3):
    axs[jloop+1].bar(x,sJ[jloop,:],align='edge', width=0.05)
    axs[jloop+1].set_xlim(x[0],x[-1])
for ax in axs:
    ax.axis(False)
plt.show()

</t>
<t tx="ekr.20241213022538.56">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
axs[0].pcolor(np.arange(10,0,-1),np.arange(0,10),M.T,cmap='hot')

for jloop in range(3):
    axs[jloop+1].pcolor(np.arange(10,0,-1),np.arange(0,10),np.squeeze(MJ[:,:,jloop]).T,cmap='hot')
    
for ax in axs:
    ax.axis(False)

</t>
<t tx="ekr.20241213022538.57">plt.rcParams['figure.figsize'] = [12,6]
L = 4
x = np.arange(-L,L+0.1,0.1)
n = len(x)
dx = x[1]-x[0]
A = np.zeros((n-2,n-2))
for jj in range(n-2):
    A[jj,jj] = -2 -(dx**2)*x[jj+1]**2
    
for jj in range(n-3):
    A[jj+1,jj] = 1
    A[jj,jj+1] = 1
    
A[0,0] = A[0,0]+4/3
A[0,1] = A[0,1]-1/3
A[-1,-1] = A[-1,-1]+4/3
A[-1,-2] = A[-1,-2]-1/3

D, V3 = linalg.eigs(-A,10,which='SR') # 10 eigenvalues with the smallest real parts

V2 = np.row_stack(((4/3)*V3[0,:]-(1/3)*V3[1,:] , V3 , (4/3)*V3[-1,:]-(1/3)*V3[-2,:]))
V = np.zeros_like(V2)

for jj in range(10):
    V[:,jj] = V2[:,jj]/np.sqrt(np.trapz(np.power(V2[:,jj],2),x))
    
sort_ind = np.argsort(D/dx**2)
Esolb = D[sort_ind]/dx**2

ysolb = np.zeros_like(V)

for jj in range(10):
    ysolb[:,jj] = V[:,sort_ind[jj]]
    
plt.pcolor(-np.real(np.flipud(np.rot90(ysolb))),cmap='hot')
plt.axis(False)
plt.show()

</t>
<t tx="ekr.20241213022538.58"></t>
<t tx="ekr.20241213022538.59">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.6">fig,axs = plt.subplots(1,2)
axs[0].plot(x,u2,'b-o')
axs[0].plot(x,u1,'r-o')
axs[0].plot(x,u,'k-o')
axs[0].set_title('u(x)')

axs[1].plot(km,np.abs(ut2)/np.max(np.abs(ut2)),'b-o')
axs[1].plot(km,np.abs(ut1)/np.max(np.abs(ut1)),'r-o')
axs[1].plot(km,np.abs(ut)/np.max(np.abs(ut)),'k-o')
axs[1].set_title('uhat(k)')

plt.show()

</t>
<t tx="ekr.20241213022538.61">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.62">L = 10 # define domain
x2 = np.arange(-L,L,0.1) 
n = len(x2)
k = n*(2*np.pi/(2*L))*np.fft.fftfreq(n) # k-vector
ye = np.exp(-np.power(x2,2))
ye2 = np.exp(np.power(x2,2)/2) # define Gaussians

y = np.zeros((n,10))

for jj in range(10): # loop through 10 modes
    # 2nd derivative
    yd = np.real(np.fft.ifft((np.power((1j)*k,jj))*np.fft.fft(ye)))
    
    mode = np.power(-1,jj) * \
        np.power((np.power(2,jj)*np.math.factorial(jj)*np.sqrt(np.pi)),-0.5) * \
        ye2 * yd
            
    y[:,jj] = mode # store modes as columns
            
x = x2[int(n/2)-40 : int(n/2)+41] # keep only -4&lt;x&lt;4
yharm = y[int(n/2)-40 : int(n/2)+41,:]

</t>
<t tx="ekr.20241213022538.63">n = len(x)
f = np.exp(-np.power(x-0.5,2)) + 3*np.exp(-2*np.power(x+1.5,2))

a = np.zeros(10)

for jj in range(10):
    a[jj] = np.trapz(f*yharm[:,jj],x)

f2 = yharm @ a
Efull = np.linalg.norm(f2-f) # recontruction error
    
M = np.zeros((10,10))

for jj in range(10): # matrix M reconstruction
    for kk in range(jj+1):
        Area = np.trapz(yharm[:,jj]*yharm[:,kk],x)
        M[jj,kk] = Area
        M[kk,jj] = Area

Cfull = np.linalg.cond(M) # get condition number

</t>
<t tx="ekr.20241213022538.64">## Test Random trials with P% of measurements

# matrices for mean and variance of error and conditioning numbers
E = np.zeros(5)
Ec = np.zeros(5)
V = np.zeros(5)
Vc = np.zeros(5)

for thresh in range(5):
    Err = np.zeros(1000)
    con = np.zeros(1000)
    for jloop in range(1000): # 1000 random trials
        n2 = np.random.choice(n,size=8*(thresh+1)) # random sampling
        P = np.zeros(n)
        P[n2] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
        
        ftild = np.zeros(10)
        for jj in range(10): # reconstruction using gappy
            ftild[jj] = np.trapz(P*f*yharm[:,jj],x)

        atild = np.linalg.solve(M2,ftild) # compute error
        f2 = yharm @ atild                # compute reconstruction
        Err[jloop] = np.linalg.norm(f2-f) # L2 error
        con[jloop] = np.linalg.cond(M2)   # condition number
        
    # mean and variance
    E[thresh] = np.mean(np.log(Err+1))
    V[thresh] = np.var(np.log(Err+1))
    Ec[thresh] = np.mean(np.log(con))
    Vc[thresh] = np.var(np.log(con))
    
E = np.concatenate((E,[Efull]))
V = np.concatenate((V,[0]))
Ec = np.concatenate((Ec,[Cfull]))
Vc = np.concatenate((Vc,[0]))

</t>
<t tx="ekr.20241213022538.65">fig,axs = plt.subplots(2,1)
axs[0].bar(range(len(E)),E,yerr=V,ecolor='r',capsize=5)
axs[1].bar(range(len(Ec)),Ec,yerr=Vc,ecolor='r',capsize=5)

plt.show()

</t>
<t tx="ekr.20241213022538.66">## For 20% measurements, sort great from bad
Pmaster = np.zeros((n,200))
Er = np.zeros(200)
co = np.zeros(200)
for jloop in range(200): # 200 random trials
    n2 = np.random.choice(n,20) # random sampling
    P = np.zeros(n)
    P[n2] = 1
    Pmaster[:,jloop] = P

    # compute M matrix
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area

    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*f*yharm[:,jj],x)

    atild = np.linalg.solve(M2,ftild) # compute error
    f2 = yharm @ atild                # compute reconstruction
    Er[jloop] = np.linalg.norm(f2-f) # L2 error
    co[jloop] = np.linalg.cond(M2)   # condition number

</t>
<t tx="ekr.20241213022538.67">fig,axs = plt.subplots(3,1)
axs[0].bar(range(len(co)),np.log(co))
axs[0].set_xlim(0,len(co))
axs[1].hist(np.log(Er+1),50)
axs[2].hist(np.log(co),50)

plt.show()

</t>
<t tx="ekr.20241213022538.68">fig, ax = plt.subplots(1,1)
ax.pcolor(-Pmaster,cmap='hot')
ax.set_aspect('equal', 'box')

</t>
<t tx="ekr.20241213022538.69">jloc = np.argsort(co)
Cloc = co[jloc]

jbest = jloc[:11]
jworst = jloc[-11:]
Sbest = Pmaster[:,jbest]
Sworst = Pmaster[:,jworst]
csor = np.concatenate((100*Cloc[:10],np.zeros(10),Cloc[-10:]))
# Note that the values for the 10 best are inflated 100-fold 
# for plotting visibility

fig,axs = plt.subplots(3,1)
axs[0].pcolor(-Sbest.T,cmap='hot')
axs[1].pcolor(-Sworst.T,cmap='hot')
axs[2].bar(range(len(csor)),csor)

for ax in axs[:-1]:
    ax.set_aspect('equal', 'box')
plt.show()

</t>
<t tx="ekr.20241213022538.7">ut21 = np.zeros(n,dtype='complex_')
ut22 = np.zeros_like(ut21)
ut23 = np.zeros_like(ut21)

erx = np.zeros(19)
er1 = np.zeros_like(erx)
er2 = np.zeros_like(erx)
er3 = np.zeros_like(erx)

for j in range(19):
    for jj in range(j):
        ut21[(int(n/2)-1-jj) : (int(n/2)+1+jj)] = uts[(int(n/2)-1-jj) : (int(n/2)+1+jj)]
        ut22[(int(n/2)-1-jj) : (int(n/2)+1+jj)] = uts1[(int(n/2)-1-jj) : (int(n/2)+1+jj)]
        ut23[(int(n/2)-1-jj) : (int(n/2)+1+jj)] = uts2[(int(n/2)-1-jj) : (int(n/2)+1+jj)]
    
    ut31 = np.fft.fftshift(ut21)
    ut32 = np.fft.fftshift(ut22)
    ut33 = np.fft.fftshift(ut23)
    
    u31 = np.fft.ifft(ut31)
    u32 = np.fft.ifft(ut32)
    u33 = np.fft.ifft(ut33)
    
    plt.plot(x,np.real(u31),'k')
    
    erx[j] = 2*(j+1)+1
    er1[j] = np.linalg.norm(u-u31)
    er2[j] = np.linalg.norm(u1-u32)
    er3[j] = np.linalg.norm(u2-u33)


</t>
<t tx="ekr.20241213022538.70">m = 30
q = np.random.rand(m,m)
q = q.reshape(-1)
n = m**2
p = np.random.choice(n,200)
q2 = np.zeros(n)
q2[p] = q[p]
p2 = np.random.choice(n,40)
q3 = np.zeros(n)
q3[p2] = q[p2]
q = q.reshape((m,m))
q2 = q2.reshape((m,m))
q3 = q3.reshape((m,m))

fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
axs[0].pcolormesh(-q,cmap='hot')
axs[1].pcolormesh(-q2,cmap='hot')
axs[2].pcolor(-q3,cmap='hot')

for ax in axs[:-1]:
    ax.set_aspect('equal', 'box')
    ax.minorticks_off()
    ax.grid(True, which='major', axis='both', linestyle='-', color='k')
    ax.set_xticks(range(m), minor=False)
    ax.set_yticks(range(m), minor=False)
    ax.tick_params(bottom=False,left=False)
    ax.set_xticklabels('')
    ax.set_yticklabels('')
    ax.set_xlim(0,m)
    ax.set_ylim(0,m)

axs[-1].axis(False)
plt.show()

</t>
<t tx="ekr.20241213022538.71"></t>
<t tx="ekr.20241213022538.72">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.74">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.75">L = 10 # define domain
x2 = np.arange(-L,L,0.1) 
n = len(x2)
k = n*(2*np.pi/(2*L))*np.fft.fftfreq(n) # k-vector
ye = np.exp(-np.power(x2,2))
ye2 = np.exp(np.power(x2,2)/2) # define Gaussians

y = np.zeros((n,10))

for jj in range(10): # loop through 10 modes
    # 2nd derivative
    yd = np.real(np.fft.ifft((np.power((1j)*k,jj))*np.fft.fft(ye)))
    
    mode = np.power(-1,jj) * \
        np.power((np.power(2,jj)*np.math.factorial(jj)*np.sqrt(np.pi)),-0.5) * \
        ye2 * yd
            
    y[:,jj] = mode # store modes as columns
            
x = x2[int(n/2)-40 : int(n/2)+41] # keep only -4&lt;x&lt;4
yharm = y[int(n/2)-40 : int(n/2)+41,:]
n = len(x)
f = np.exp(-np.power(x-0.5,2)) + 3*np.exp(-2*np.power(x+1.5,2))


</t>
<t tx="ekr.20241213022538.76">## Method 1 -- Condition Number
n2 = 20 # number of sensors
nall = np.arange(n)
ns = np.array([],dtype='int')
kond = np.zeros(n2)
Psum = np.zeros((n,n2))
f1 = np.zeros((n,n2))
E = np.zeros(n2)
for jsense in range(n2):
    con = np.zeros(n-jsense-1)
    for jloop in range(n-jsense-1):
        P = np.zeros(n)
        P[ns] = 1
        P[nall[jloop]] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
        
        con[jloop] = np.linalg.cond(M2) # compute condition number
    n1 = np.argmin(con) # location to minimize condition #
    s1 = con[n1]
    kond[jsense] = s1
    ns = np.append(ns,nall[n1]) # add sensor location
    nall = np.setdiff1d(nall,ns) # new sensor indices
    P = np.zeros(n)
    P[ns] = 1
    Psum[:,jsense] = P
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
            
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f1[:,jsense] = yharm @ atild        # iterative reconstruction
    E[jsense] = np.linalg.norm(f1[:,jsense]-f) # iterative error

</t>
<t tx="ekr.20241213022538.77">plt.rcParams['figure.figsize'] = [12,10]
fig, axs = plt.subplots(3,1)
axs[0].bar(range(n2),np.log(kond),facecolor=(0.7,0.7,0.7))
axs[1].bar(range(n2),np.log(E+1),facecolor=(0.7,0.7,0.7))
axs[2].pcolor(-Psum.T,cmap='hot')

plt.show()

</t>
<t tx="ekr.20241213022538.78">titer = np.arange(1,21)
titer = np.append(titer,25)
titer2 = np.arange(9,21)
titer2 = np.append(titer2,25)
f1 = np.concatenate((f1,f.reshape(n,1)),axis=1)
f2 = np.concatenate((f1[:,9:21],f.reshape(n,1)),axis=1)


</t>
<t tx="ekr.20241213022538.79">plt.rcParams['figure.figsize'] = [12,6]
fig, axs = plt.subplots(ncols=2, subplot_kw={'projection': '3d'})
for ti in range(len(titer)):
    axs[0].plot(x,titer[ti]*np.ones_like(x),f1[:,ti],color='k')
    
for ti in range(len(titer2)):
    axs[1].plot(x,titer2[ti]*np.ones_like(x),f2[:,ti],color='k')
    
for ax in axs:
    ax.view_init(azim=120,elev=30)
    ax.set_xlim(-4,4)
    ax.set_ylim(0,25)


</t>
<t tx="ekr.20241213022538.8">plt.semilogy(erx,er3,'b',linewidth=2)
plt.semilogy(erx,er2,'r',linewidth=2)
plt.semilogy(erx,er1,'k',linewidth=2)
plt.ylabel('Error')
plt.xlabel('# of modes')
plt.grid()

plt.show()

</t>
<t tx="ekr.20241213022538.80">## Method 2 -- Max Diagonal vs. Off-Diagonal
n2 = 60 # number of sensors
nall = np.arange(n)
ns = np.array([],dtype='int')
kond2 = np.zeros(n2)
Psum2 = np.zeros((n,n2))
f2 = np.zeros((n,n2))
E2 = np.zeros(n2)
for jsense in range(n2):
    con = np.zeros(n-jsense-1)
    for jloop in range(n-jsense-1):
        P = np.zeros(n)
        P[ns] = 1
        P[nall[jloop]] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
                
        # compute proxy measure
        con[jloop] = 2*np.sum(np.diag(M2))-np.sum(M2.reshape(-1))
    n1 = np.argmax(con) # location to maximize condition #
    s1 = con[n1]
    kond2[jsense] = s1
    ns = np.append(ns,nall[n1]) # add sensor location
    nall = np.setdiff1d(nall,ns) # new sensor indices
    P = np.zeros(n)
    P[ns] = 1
    Psum2[:,jsense] = P
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
            
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f2[:,jsense] = yharm @ atild        # iterative reconstruction
    E2[jsense] = np.linalg.norm(f2[:,jsense]-f) # iterative error

</t>
<t tx="ekr.20241213022538.81">plt.rcParams['figure.figsize'] = [12,10]
fig, axs = plt.subplots(3,1)
axs[0].bar(range(n2),kond2,facecolor=(0.7,0.7,0.7))
axs[0].set_xlim(0,61)
axs[0].set_ylim(0,15)
axs[1].bar(range(n2),np.log(E2+1),facecolor=(0.7,0.7,0.7))
axs[1].set_xlim(0,61)
axs[1].set_ylim(0,12)
axs[2].pcolor(-Psum2.T,cmap='hot')

plt.show()

</t>
<t tx="ekr.20241213022538.82">## Method 1 -- First 4 Condition Number
n2 = 4 # number of sensors
nall = np.arange(n)
ns = np.array([],dtype='int')
kond = np.zeros(n2)
Psum = np.zeros((n,n2))
f1 = np.zeros((n,n2))
E = np.zeros(n2)
fig,axs = plt.subplots(4,1)
for jsense in range(n2):
    con = np.zeros(n-jsense-1)
    for jloop in range(n-jsense-1):
        P = np.zeros(n)
        P[ns] = 1
        P[nall[jloop]] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
        
        con[jloop] = np.linalg.cond(M2) # compute condition number
    n1 = np.argmin(con) # location to minimize condition #
    s1 = con[n1]
    kond[jsense] = s1
    ns = np.append(ns,nall[n1]) # add sensor location
    nall = np.setdiff1d(nall,ns) # new sensor indices
    P = np.zeros(n)
    P[ns] = 1
    Psum[:,jsense] = P
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
            
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f1[:,jsense] = yharm @ atild        # iterative reconstruction
    E[jsense] = np.linalg.norm(f1[:,jsense]-f) # iterative error
    
    temp = np.zeros(n)
    if jsense == 0:
        contemp = con
        temp[n1] = s1
    elif jsense == 1:
        contemp = np.concatenate((con[:ns[0]],[0],con[ns[0]:]))
        con2 = contemp
        temp[n1+1] = s1
    elif jsense == 2:
        contemp = np.concatenate((con[:ns[0]],[0],con[ns[0]:ns[1]],[0],con[ns[1]:]))
        con3 = contemp
        temp[n1+1] = s1
    elif jsense == 3:
        contemp = np.concatenate((con[:ns[0]],[0],con[ns[0]:ns[1]],[0],con[ns[1]:ns[2]],[0],con[ns[2]:]))
        con4 = contemp
        temp[n1+1] = s1
        
    axs[jsense].bar(range(len(contemp)),np.log(contemp),facecolor=(0.7,0.7,0.7))
    axs[jsense].bar(range(len(temp)),np.log(temp),facecolor='r')
    axs[jsense].set_xlim(0,80)
    axs[jsense].set_ylim(0,100)

</t>
<t tx="ekr.20241213022538.83"></t>
<t tx="ekr.20241213022538.84">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.86">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213022538.87">L = 10 # define domain
x2 = np.arange(-L,L,0.1) 
n = len(x2)
k = n*(2*np.pi/(2*L))*np.fft.fftfreq(n) # k-vector
ye = np.exp(-np.power(x2,2))
ye2 = np.exp(np.power(x2,2)/2) # define Gaussians

y = np.zeros((n,10))

for jj in range(10): # loop through 10 modes
    # 2nd derivative
    yd = np.real(np.fft.ifft((np.power((1j)*k,jj))*np.fft.fft(ye)))
    
    mode = np.power(-1,jj) * \
        np.power((np.power(2,jj)*np.math.factorial(jj)*np.sqrt(np.pi)),-0.5) * \
        ye2 * yd
            
    y[:,jj] = mode # store modes as columns
            
x = x2[int(n/2)-40 : int(n/2)+41] # keep only -4&lt;x&lt;4
yharm = y[int(n/2)-40 : int(n/2)+41,:]
n = len(x)
f = np.exp(-np.power(x-0.5,2)) + 3*np.exp(-2*np.power(x+1.5,2))

E = np.zeros(13)
con = np.zeros(13)

</t>
<t tx="ekr.20241213022538.88">## Method 1 -- Start with max of each mode
ns = np.array([],dtype='int')

for jj in range(10): # walk through the modes
    n1 = np.argmax(yharm[:,jj]) # pick max
    s1 = yharm[n1,jj]
    ns = np.append(ns,n1)

P = np.zeros(n)
P[ns] = 1

# compute M matrix
M2 = np.zeros((10,10))
for jj in range(10):
    for kk in range(jj+1):
        Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
        M2[jj,kk] = Area
        M2[kk,jj] = Area

ftild = np.zeros(10)
for jj in range(10): # reconstruction using gappy
    ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
atild = np.linalg.solve(M2,ftild) # compute error
f1 = yharm @ atild        # iterative reconstruction
E[0] = np.linalg.norm(f1-f) # iterative error
con[0] = np.linalg.cond(M2)

plt.plot(x,f,'r')
plt.plot(x,f1,'k')
plt.show()

</t>
<t tx="ekr.20241213022538.89">## Method 2 -- Start with max and mins of each mode
ns = np.array([],dtype='int')

for jj in range(10): # walk through the modes
    n1 = np.argmax(yharm[:,jj]) # pick max
    s1 = yharm[n1,jj]
    ns = np.append(ns,n1)

for jj in range(1,10): # no minimum on first mode
    n2 = np.argmin(yharm[:,jj]) # pick min
    s2 = yharm[n2,jj]
    ns = np.append(ns,n2)
    
    
P = np.zeros(n)
P[ns] = 1

# compute M matrix
M2 = np.zeros((10,10))
for jj in range(10):
    for kk in range(jj+1):
        Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
        M2[jj,kk] = Area
        M2[kk,jj] = Area

ftild = np.zeros(10)
for jj in range(10): # reconstruction using gappy
    ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
atild = np.linalg.solve(M2,ftild) # compute error
f1 = yharm @ atild        # iterative reconstruction
E[1] = np.linalg.norm(f1-f) # iterative error
con[1] = np.linalg.cond(M2)

plt.plot(x,f,'r')
plt.plot(x,f1,'k')
plt.show()

</t>
<t tx="ekr.20241213022538.9"></t>
<t tx="ekr.20241213022538.90">## Method 3 -- Search for extrema, then select random N sensors
nmax = np.array([],dtype='int')
nmin = np.copy(nmax)
Psum = np.zeros((n,10))
for jj in range(10): # walk through the modes
    nmaxt = np.array([],dtype='int')
    nmint = np.copy(nmaxt)
    
    for kk in range(1,n-1):
        if yharm[kk,jj] &gt; yharm[kk-1,jj] and yharm[kk,jj] &gt; yharm[kk+1,jj]:
            nmax = np.append(nmax,kk)
            nmaxt = np.append(nmaxt,kk)
        if yharm[kk,jj] &lt; yharm[kk-1,jj] and yharm[kk,jj] &lt; yharm[kk+1,jj]:
            nmin = np.append(nmin,kk)
            nmint = np.append(nmint,kk)
    
    nst = np.concatenate((nmaxt, nmint))
    Psum[nst,jj] = 1

ns = np.concatenate((nmax,nmin))
ni = np.random.choice(len(ns),20)
nsr = ns[ni]
# P = np.zeros(n)
# P[nsr] = 1

fig,axs = plt.subplots(2,1)
axs[0].pcolor(yharm.T,cmap='hot')
axs[1].pcolor(-Psum.T,cmap='hot')
    
P = np.zeros(n)
P[ns] = 1

# compute M matrix
M2 = np.zeros((10,10))
for jj in range(10):
    for kk in range(jj+1):
        Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
        M2[jj,kk] = Area
        M2[kk,jj] = Area

ftild = np.zeros(10)
for jj in range(10): # reconstruction using gappy
    ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
atild = np.linalg.solve(M2,ftild) # compute error
f1 = yharm @ atild        # iterative reconstruction
E[2] = np.linalg.norm(f1-f) # iterative error
con[2] = np.linalg.cond(M2)

plt.figure()
plt.plot(x,f,'r')
plt.plot(x,f1,'k')
plt.show()

</t>
<t tx="ekr.20241213022538.91">## select random 20 - shuffle
ntot = len(ns)
E_tri = np.zeros(100)
con_tri = np.copy(E_tri)
for jtrials in range(100):
    ni = np.random.choice(ntot,20)
    nsr = ns[ni]
    P = np.zeros(n)
    P[nsr] = 1

    # compute M matrix
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area

    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f1 = yharm @ atild        # iterative reconstruction
    E_tri[jtrials] = np.linalg.norm(f1-f) # iterative error
    con_tri[jtrials] = np.linalg.cond(M2)

fig, axs = plt.subplots(2,1)
axs[0].bar(range(100),np.log(con_tri),facecolor=(0.7,0.7,0.7))
axs[1].bar(range(100),np.log(E_tri+1),facecolor=(0.7,0.7,0.7))

plt.show()

E[3:5] = 0
con[3:5] = 0
Estri = np.sort(E_tri)
contri = np.sort(con_tri)
E[5:10] = Estri[:5]
con[5:10] = contri[:5]
con[10:12] = 0
E[10:12] = 0

</t>
<t tx="ekr.20241213022538.92">## Method to compare -- Willcox condition number
n2 = 20 # number of sensors
nall = np.arange(n)
ns = np.array([],dtype='int')
kond = np.zeros(n2)
Psum = np.zeros((n,n2))
f1 = np.zeros((n,n2))
EW = np.zeros(n2)
for jsense in range(n2):
    con2 = np.zeros(n-jsense-1)
    for jloop in range(n-jsense-1):
        P = np.zeros(n)
        P[ns] = 1
        P[nall[jloop]] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
        
        con2[jloop] = np.linalg.cond(M2) # compute condition number
    n1 = np.argmin(con2) # location to minimize condition #
    s1 = con2[n1]
    kond[jsense] = s1
    ns = np.append(ns,nall[n1]) # add sensor location
    nall = np.setdiff1d(nall,ns) # new sensor indices
    P = np.zeros(n)
    P[ns] = 1
    Psum[:,jsense] = P
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
            
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f1[:,jsense] = yharm @ atild        # iterative reconstruction
    EW[jsense] = np.linalg.norm(f1[:,jsense]-f) # iterative error
    
E[12] = EW[-1]
con[12] = kond[-1]

dum1 = np.zeros(13)
dum2 = np.zeros(13)
dum1[-1] = EW[-1]
dum2[-1] = kond[-1]

fig, axs = plt.subplots(2,1)
axs[0].bar(range(13),np.log(E+1),facecolor=(0.7,0.7,0.7))
axs[1].bar(range(13),np.log(con),facecolor=(0.7,0.7,0.7))
axs[0].bar(range(13),np.log(dum1+1),facecolor='r')
axs[1].bar(range(13),np.log(dum2),facecolor='r')


plt.show()

</t>
<t tx="ekr.20241213022538.93">fig,axs = plt.subplots(3,1)
axs[0].bar(range(len(kond)),np.log(kond),facecolor=(0.7,0.7,0.7))
axs[1].bar(range(len(EW)),np.log(EW+1),facecolor=(0.7,0.7,0.7))
axs[2].pcolor(-Psum.T,cmap='hot')
plt.show()

</t>
<t tx="ekr.20241213022538.94">titer = np.arange(1,21)
titer = np.append(titer,25)
titer2 = np.arange(9,21)
titer2 = np.append(titer2,25)
f1 = np.concatenate((f1,f.reshape(n,1)),axis=1)
f2 = np.concatenate((f1[:,9:21],f.reshape(n,1)),axis=1)

</t>
<t tx="ekr.20241213022538.95">plt.rcParams['figure.figsize'] = [12,6]
fig, axs = plt.subplots(ncols=2, subplot_kw={'projection': '3d'})
for ti in range(len(titer)):
    axs[0].plot(x,titer[ti]*np.ones_like(x),f1[:,ti],color='k')
    
for ti in range(len(titer2)):
    axs[1].plot(x,titer2[ti]*np.ones_like(x),f2[:,ti],color='k')
    
for ax in axs:
    ax.view_init(azim=120,elev=30)
    ax.set_xlim(-4,4)
    ax.set_ylim(0,25)


</t>
<t tx="ekr.20241213022538.96"></t>
<t tx="ekr.20241213022538.97">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241213022538.99">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import integrate
from scipy.linalg import qr
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241213035513.1">@language rest
@wrap

This file, math.leo, contains scripts and files related to Steve Brunton's course, Mechanical Engineering 564: http://faculty.washington.edu/sbrunton/me564/

Directory Structure
===================

The @button scripts in this file will work properly only if math.leo is in the proper directory.

The directory structure should be that created by unpacking CODE_PYTHYON.zip and DATA_PYTHON.zip. These .zip files *were* available from the URL above, but do not seem to be available now.
However, individual .ipynb files are still available.

*Contact me* if you would like a copy of these .zip files.

- python folder
  - CODE_PYTHON folder
    - math.leo (this file)
    - CH01 folder
      - various .ipynb files converted by `@button import-ipynb`.
      ...
    - CH12 folder
    - UTILS folder (ignored by this file)
  - DATA
    - Various .csv, .data, .jpg, .csv, .mat and .mpg files.

Earlier versions of `@button import-ipynb` used hard-coded paths.
In a pinch you could do the same.</t>
</tnodes>
</leo_file>
